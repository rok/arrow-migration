{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13357678",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678",
    "key": "ARROW-11568",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": null,
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
            "name": "yibocai",
            "key": "yibo",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
            },
            "displayName": "Yibo Cai",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
            "name": "yibocai",
            "key": "yibo",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
            },
            "displayName": "Yibo Cai",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11568/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 16,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/581557",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 opened a new pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009\n\n\n   Arrow mode kernel performance is bad compared with scipy.stats.mode\r\n   (based on numpy.unique). Arrow mode kernel stores value:count pair in\r\n   a map, while numpy.unique sorts the input array then count the adjacent\r\n   same values. Per my test, the map approach only wins when there are\r\n   many duplicated values (length / value_range > 100), looks not very\r\n   useful in practice.\r\n   \r\n   This patch rewrites mode kernel to use the sort and count approach for\r\n   floating points and integers with wide value range. 2x performance\r\n   improvement is observed.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T05:38:50.571+0000",
                    "updated": "2021-04-13T05:38:50.571+0000",
                    "started": "2021-04-13T05:38:50.570+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581557",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/581558",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#issuecomment-818452704\n\n\n   Benchmark on skylake, clang-9.\r\n   \r\n   ```\r\n   -----------------------------------------------------------------------------------------------\r\n   Non-regressions: (40)\r\n   -----------------------------------------------------------------------------------------------\r\n                                    benchmark         baseline        contender  change % counters\r\n          ModeKernelWide<Int32Type>/1048576/0   20.644 MiB/sec   66.187 MiB/sec   220.613       {}\r\n        ModeKernelWide<Int32Type>/1048576/100   20.768 MiB/sec   65.772 MiB/sec   216.699       {}\r\n      ModeKernelWide<Int32Type>/1048576/10000   20.626 MiB/sec   65.291 MiB/sec   216.546       {}\r\n         ModeKernelWide<Int32Type>/1048576/10   22.390 MiB/sec   69.904 MiB/sec   212.209       {}\r\n      ModeKernelWide<FloatType>/1048576/10000   18.174 MiB/sec   54.517 MiB/sec   199.975       {}\r\n          ModeKernelWide<FloatType>/1048576/0   18.423 MiB/sec   54.869 MiB/sec   197.826       {}\r\n         ModeKernelWide<FloatType>/1048576/10   20.009 MiB/sec   59.346 MiB/sec   196.601       {}\r\n        ModeKernelWide<FloatType>/1048576/100   18.486 MiB/sec   54.568 MiB/sec   195.186       {}\r\n        ModeKernelWide<Int64Type>/1048576/100   46.593 MiB/sec  136.786 MiB/sec   193.578       {}\r\n          ModeKernelWide<Int64Type>/1048576/0   46.434 MiB/sec  134.296 MiB/sec   189.221       {}\r\n      ModeKernelWide<Int64Type>/1048576/10000   46.435 MiB/sec  134.149 MiB/sec   188.894       {}\r\n        ModeKernelNarrow<Int64Type>/1048576/0  893.469 MiB/sec    2.515 GiB/sec   188.197       {}\r\n    ModeKernelNarrow<Int64Type>/1048576/10000  886.403 MiB/sec    2.484 GiB/sec   186.933       {}\r\n         ModeKernelWide<Int64Type>/1048576/10   50.182 MiB/sec  143.034 MiB/sec   185.029       {}\r\n     ModeKernelWide<DoubleType>/1048576/10000   40.525 MiB/sec  115.477 MiB/sec   184.953       {}\r\n       ModeKernelWide<DoubleType>/1048576/100   41.114 MiB/sec  116.862 MiB/sec   184.241       {}\r\n        ModeKernelWide<DoubleType>/1048576/10   44.555 MiB/sec  126.095 MiB/sec   183.008       {}\r\n         ModeKernelWide<DoubleType>/1048576/0   41.083 MiB/sec  113.499 MiB/sec   176.263       {}\r\n          ModeKernelWide<FloatType>/1048576/2   39.704 MiB/sec  106.142 MiB/sec   167.335       {}\r\n      ModeKernelNarrow<Int64Type>/1048576/100  853.217 MiB/sec    2.223 GiB/sec   166.836       {}\r\n          ModeKernelWide<Int32Type>/1048576/2   43.329 MiB/sec  115.209 MiB/sec   165.893       {}\r\n         ModeKernelWide<DoubleType>/1048576/2   88.485 MiB/sec  223.284 MiB/sec   152.340       {}\r\n          ModeKernelWide<Int64Type>/1048576/2   97.572 MiB/sec  236.831 MiB/sec   142.723       {}\r\n        ModeKernelNarrow<Int32Type>/1048576/0  715.706 MiB/sec    1.522 GiB/sec   117.703       {}\r\n    ModeKernelNarrow<Int32Type>/1048576/10000  714.237 MiB/sec    1.497 GiB/sec   114.577       {}\r\n       ModeKernelNarrow<Int64Type>/1048576/10  701.986 MiB/sec    1.399 GiB/sec   104.094       {}\r\n      ModeKernelNarrow<Int32Type>/1048576/100  666.834 MiB/sec    1.291 GiB/sec    98.234       {}\r\n        ModeKernelNarrow<Int64Type>/1048576/2  611.412 MiB/sec    1.057 GiB/sec    77.008       {}\r\n       ModeKernelNarrow<Int32Type>/1048576/10  499.852 MiB/sec  780.344 MiB/sec    56.115       {}\r\n        ModeKernelNarrow<Int32Type>/1048576/2  402.986 MiB/sec  562.758 MiB/sec    39.647       {}\r\n         ModeKernelNarrow<Int8Type>/1048576/1  499.705 GiB/sec  639.311 GiB/sec    27.938       {}\r\n         ModeKernelWide<DoubleType>/1048576/1  599.969 GiB/sec  738.218 GiB/sec    23.043       {}\r\n        ModeKernelNarrow<Int64Type>/1048576/1  610.213 GiB/sec  743.338 GiB/sec    21.816       {}\r\n          ModeKernelWide<Int64Type>/1048576/1  608.551 GiB/sec  735.741 GiB/sec    20.901       {}\r\n          ModeKernelWide<Int32Type>/1048576/1  611.261 GiB/sec  727.163 GiB/sec    18.961       {}\r\n        ModeKernelNarrow<Int32Type>/1048576/1  601.834 GiB/sec  714.017 GiB/sec    18.640       {}\r\n          ModeKernelWide<FloatType>/1048576/1  612.628 GiB/sec  716.591 GiB/sec    16.970       {}\r\n      ModeKernelNarrow<BooleanType>/1048576/1  628.851 GiB/sec  691.936 GiB/sec    10.032       {}\r\n      ModeKernelNarrow<BooleanType>/1048576/0   21.709 GiB/sec   22.397 GiB/sec     3.166       {}\r\n         ModeKernelNarrow<Int8Type>/1048576/2  293.420 MiB/sec  286.770 MiB/sec    -2.266       {}\r\n   \r\n   -------------------------------------------------------------------------------------------------\r\n   Regressions: (8)\r\n   -------------------------------------------------------------------------------------------------\r\n                                      benchmark         baseline        contender  change % counters\r\n    ModeKernelNarrow<BooleanType>/1048576/10000    1.959 GiB/sec    1.856 GiB/sec    -5.274       {}\r\n        ModeKernelNarrow<BooleanType>/1048576/2    1.957 GiB/sec    1.854 GiB/sec    -5.293       {}\r\n      ModeKernelNarrow<BooleanType>/1048576/100    1.972 GiB/sec    1.866 GiB/sec    -5.374       {}\r\n       ModeKernelNarrow<BooleanType>/1048576/10    1.974 GiB/sec    1.855 GiB/sec    -6.027       {}\r\n          ModeKernelNarrow<Int8Type>/1048576/10  364.472 MiB/sec  342.415 MiB/sec    -6.052       {}\r\n           ModeKernelNarrow<Int8Type>/1048576/0  484.491 MiB/sec  440.347 MiB/sec    -9.111       {}\r\n         ModeKernelNarrow<Int8Type>/1048576/100  458.333 MiB/sec  416.045 MiB/sec    -9.226       {}\r\n       ModeKernelNarrow<Int8Type>/1048576/10000  486.679 MiB/sec  439.186 MiB/sec    -9.759       {}\r\n   ```\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T05:39:34.390+0000",
                    "updated": "2021-04-13T05:39:34.390+0000",
                    "started": "2021-04-13T05:39:34.389+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581558",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/581675",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#issuecomment-818629589\n\n\n   https://issues.apache.org/jira/browse/ARROW-11568\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T10:27:58.246+0000",
                    "updated": "2021-04-13T10:27:58.246+0000",
                    "started": "2021-04-13T10:27:58.245+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581675",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/581878",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#issuecomment-818855204\n\n\n   Benchmarks on Zen 2, clang 10.\r\n   ```\r\n   ----------------------------------------------------------------------------------------------\r\n   Non-regressions: (44)\r\n   ----------------------------------------------------------------------------------------------\r\n                                     benchmark        baseline       contender  change % counters\r\n     ModeKernelNarrow<Int64Type>/1048576/10000   1.344 GiB/sec   3.077 GiB/sec   129.033       {}\r\n           ModeKernelWide<FloatType>/1048576/0  26.692 MiB/sec  60.554 MiB/sec   126.860       {}\r\n         ModeKernelWide<FloatType>/1048576/100  26.720 MiB/sec  60.031 MiB/sec   124.667       {}\r\n       ModeKernelWide<FloatType>/1048576/10000  26.707 MiB/sec  59.770 MiB/sec   123.799       {}\r\n           ModeKernelWide<Int32Type>/1048576/0  35.031 MiB/sec  77.918 MiB/sec   122.426       {}\r\n         ModeKernelNarrow<Int64Type>/1048576/0   1.399 GiB/sec   3.091 GiB/sec   120.934       {}\r\n       ModeKernelWide<Int32Type>/1048576/10000  34.942 MiB/sec  77.128 MiB/sec   120.729       {}\r\n        ModeKernelWide<DoubleType>/1048576/100  57.929 MiB/sec 127.702 MiB/sec   120.447       {}\r\n       ModeKernelNarrow<Int64Type>/1048576/100   1.328 GiB/sec   2.874 GiB/sec   116.482       {}\r\n      ModeKernelWide<DoubleType>/1048576/10000  58.316 MiB/sec 125.540 MiB/sec   115.276       {}\r\n          ModeKernelWide<DoubleType>/1048576/0  58.070 MiB/sec 122.623 MiB/sec   111.164       {}\r\n           ModeKernelWide<FloatType>/1048576/2  55.623 MiB/sec 117.360 MiB/sec   110.994       {}\r\n          ModeKernelWide<DoubleType>/1048576/2 116.593 MiB/sec 243.300 MiB/sec   108.675       {}\r\n         ModeKernelWide<Int64Type>/1048576/100  79.077 MiB/sec 162.463 MiB/sec   105.449       {}\r\n       ModeKernelWide<Int64Type>/1048576/10000  78.890 MiB/sec 158.923 MiB/sec   101.450       {}\r\n        ModeKernelNarrow<Int64Type>/1048576/10 994.277 MiB/sec   1.895 GiB/sec    95.196       {}\r\n           ModeKernelWide<Int32Type>/1048576/2  70.771 MiB/sec 136.449 MiB/sec    92.804       {}\r\n           ModeKernelWide<Int64Type>/1048576/0  79.140 MiB/sec 150.926 MiB/sec    90.709       {}\r\n         ModeKernelWide<DoubleType>/1048576/10  72.236 MiB/sec 136.781 MiB/sec    89.354       {}\r\n           ModeKernelWide<Int64Type>/1048576/2 149.834 MiB/sec 282.411 MiB/sec    88.482       {}\r\n          ModeKernelWide<FloatType>/1048576/10  34.595 MiB/sec  65.197 MiB/sec    88.457       {}\r\n          ModeKernelWide<Int32Type>/1048576/10  44.789 MiB/sec  82.908 MiB/sec    85.107       {}\r\n         ModeKernelWide<Int32Type>/1048576/100  41.497 MiB/sec  76.746 MiB/sec    84.946       {}\r\n         ModeKernelNarrow<Int64Type>/1048576/2 799.410 MiB/sec   1.407 GiB/sec    80.226       {}\r\n          ModeKernelWide<Int64Type>/1048576/10  94.448 MiB/sec 168.857 MiB/sec    78.782       {}\r\n         ModeKernelNarrow<Int32Type>/1048576/0   1.099 GiB/sec   1.709 GiB/sec    55.441       {}\r\n        ModeKernelNarrow<Int32Type>/1048576/10 700.749 MiB/sec   1.059 GiB/sec    54.802       {}\r\n         ModeKernelNarrow<Int32Type>/1048576/2 500.474 MiB/sec 727.773 MiB/sec    45.417       {}\r\n       ModeKernelNarrow<Int32Type>/1048576/100   1.083 GiB/sec   1.529 GiB/sec    41.151       {}\r\n     ModeKernelNarrow<Int32Type>/1048576/10000   1.258 GiB/sec   1.658 GiB/sec    31.790       {}\r\n          ModeKernelNarrow<Int8Type>/1048576/1 504.487 GiB/sec 625.852 GiB/sec    24.057       {}\r\n           ModeKernelWide<Int32Type>/1048576/1 584.030 GiB/sec 704.471 GiB/sec    20.622       {}\r\n         ModeKernelNarrow<Int32Type>/1048576/1 595.824 GiB/sec 712.818 GiB/sec    19.636       {}\r\n         ModeKernelNarrow<Int64Type>/1048576/1 597.643 GiB/sec 707.585 GiB/sec    18.396       {}\r\n           ModeKernelWide<FloatType>/1048576/1 582.116 GiB/sec 679.811 GiB/sec    16.783       {}\r\n          ModeKernelWide<DoubleType>/1048576/1 583.923 GiB/sec 674.269 GiB/sec    15.472       {}\r\n           ModeKernelWide<Int64Type>/1048576/1 590.544 GiB/sec 678.023 GiB/sec    14.813       {}\r\n       ModeKernelNarrow<BooleanType>/1048576/1 593.884 GiB/sec 648.047 GiB/sec     9.120       {}\r\n       ModeKernelNarrow<BooleanType>/1048576/0  36.364 GiB/sec  38.774 GiB/sec     6.626       {}\r\n          ModeKernelNarrow<Int8Type>/1048576/2 366.079 MiB/sec 378.478 MiB/sec     3.387       {}\r\n      ModeKernelNarrow<BooleanType>/1048576/10   2.393 GiB/sec   2.412 GiB/sec     0.784       {}\r\n   ModeKernelNarrow<BooleanType>/1048576/10000   2.392 GiB/sec   2.395 GiB/sec     0.115       {}\r\n       ModeKernelNarrow<BooleanType>/1048576/2   2.393 GiB/sec   2.391 GiB/sec    -0.071       {}\r\n     ModeKernelNarrow<BooleanType>/1048576/100   2.395 GiB/sec   2.369 GiB/sec    -1.084       {}\r\n   \r\n   -------------------------------------------------------------------------------------------\r\n   Regressions: (4)\r\n   -------------------------------------------------------------------------------------------\r\n                                  benchmark        baseline       contender  change % counters\r\n       ModeKernelNarrow<Int8Type>/1048576/0 517.607 MiB/sec 477.913 MiB/sec    -7.669       {}\r\n   ModeKernelNarrow<Int8Type>/1048576/10000 597.905 MiB/sec 473.417 MiB/sec   -20.821       {}\r\n      ModeKernelNarrow<Int8Type>/1048576/10 616.529 MiB/sec 486.274 MiB/sec   -21.127       {}\r\n     ModeKernelNarrow<Int8Type>/1048576/100 652.528 MiB/sec 478.726 MiB/sec   -26.635       {}\r\n   ```\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T16:05:10.657+0000",
                    "updated": "2021-04-13T16:05:10.657+0000",
                    "started": "2021-04-13T16:05:10.657+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581878",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/581889",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#discussion_r612599321\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_mode.cc\n##########\n@@ -31,340 +33,359 @@ namespace internal {\n \n namespace {\n \n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using ModeState = OptionsWrapper<ModeOptions>;\n+\n constexpr char kModeFieldName[] = \"mode\";\n constexpr char kCountFieldName[] = \"count\";\n \n-// {value:count} map\n-template <typename CType>\n-using CounterMap = std::unordered_map<CType, int64_t>;\n-\n-// map based counter for floating points\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<std::is_floating_point<CType>::value, CounterMap<CType>> CountValuesByMap(\n-    const ArrayType& array, int64_t& nan_count) {\n-  CounterMap<CType> value_counts_map;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  nan_count = 0;\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             const auto value = values[pos + i];\n-                                             if (std::isnan(value)) {\n-                                               ++nan_count;\n-                                             } else {\n-                                               ++value_counts_map[value];\n-                                             }\n-                                           }\n-                                         });\n+template <typename InType, typename CType = typename InType::c_type>\n+Result<std::pair<CType*, int64_t*>> PrepareOutput(int64_t n, KernelContext* ctx,\n+                                                  Datum* out) {\n+  const auto& mode_type = TypeTraits<InType>::type_singleton();\n+  const auto& count_type = int64();\n+\n+  auto mode_data = ArrayData::Make(mode_type, /*length=*/n, /*null_count=*/0);\n+  mode_data->buffers.resize(2, nullptr);\n+  auto count_data = ArrayData::Make(count_type, n, 0);\n+  count_data->buffers.resize(2, nullptr);\n+\n+  CType* mode_buffer = nullptr;\n+  int64_t* count_buffer = nullptr;\n+\n+  if (n > 0) {\n+    ARROW_ASSIGN_OR_RAISE(mode_data->buffers[1], ctx->Allocate(n * sizeof(CType)));\n+    ARROW_ASSIGN_OR_RAISE(count_data->buffers[1], ctx->Allocate(n * sizeof(int64_t)));\n+    mode_buffer = mode_data->template GetMutableValues<CType>(1);\n+    count_buffer = count_data->template GetMutableValues<int64_t>(1);\n   }\n \n-  return value_counts_map;\n-}\n-\n-// map base counter for non floating points\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<!std::is_floating_point<CType>::value, CounterMap<CType>> CountValuesByMap(\n-    const ArrayType& array) {\n-  CounterMap<CType> value_counts_map;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             ++value_counts_map[values[pos + i]];\n-                                           }\n-                                         });\n-  }\n+  const auto& out_type =\n+      struct_({field(kModeFieldName, mode_type), field(kCountFieldName, count_type)});\n+  *out = Datum(ArrayData::Make(out_type, n, {nullptr}, {mode_data, count_data}, 0));\n \n-  return value_counts_map;\n+  return std::make_pair(mode_buffer, count_buffer);\n }\n \n-// vector based counter for int8 or integers with small value range\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-CounterMap<CType> CountValuesByVector(const ArrayType& array, CType min, CType max) {\n-  const int range = static_cast<int>(max - min);\n-  DCHECK(range >= 0 && range < 64 * 1024 * 1024);\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  std::vector<int64_t> value_counts_vector(range + 1);\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             ++value_counts_vector[values[pos + i] - min];\n-                                           }\n-                                         });\n-  }\n-\n-  // Transfer value counts to a map to be consistent with other chunks\n-  CounterMap<CType> value_counts_map(range + 1);\n-  for (int i = 0; i <= range; ++i) {\n-    CType value = static_cast<CType>(i + min);\n-    int64_t count = value_counts_vector[i];\n-    if (count) {\n-      value_counts_map[value] = count;\n+// find top-n value:count pairs with minimal heap\n+// suboptimal for tiny or large n, possibly okay as we're not in hot path\n+template <typename InType, typename Generator>\n+void Finalize(KernelContext* ctx, Datum* out, Generator&& gen) {\n+  using CType = typename InType::c_type;\n+\n+  using ValueCountPair = std::pair<CType, int64_t>;\n+  auto gt = [](const ValueCountPair& lhs, const ValueCountPair& rhs) {\n+    const bool rhs_is_nan = rhs.first != rhs.first;  // nan as largest value\n+    return lhs.second > rhs.second ||\n+           (lhs.second == rhs.second && (lhs.first < rhs.first || rhs_is_nan));\n+  };\n+\n+  std::priority_queue<ValueCountPair, std::vector<ValueCountPair>, decltype(gt)> min_heap(\n+      std::move(gt));\n+\n+  const ModeOptions& options = ModeState::Get(ctx);\n+  while (true) {\n+    const ValueCountPair& value_count = gen();\n+    DCHECK_NE(value_count.second, 0);\n+    if (value_count.second < 0) break;  // EOF reached\n+    if (static_cast<int64_t>(min_heap.size()) < options.n) {\n+      min_heap.push(value_count);\n+    } else if (gt(value_count, min_heap.top())) {\n+      min_heap.pop();\n+      min_heap.push(value_count);\n     }\n   }\n+  const int64_t n = min_heap.size();\n \n-  return value_counts_map;\n-}\n-\n-// map or vector based counter for int16/32/64 per value range\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-CounterMap<CType> CountValuesByMapOrVector(const ArrayType& array) {\n-  // see https://issues.apache.org/jira/browse/ARROW-9873\n-  static constexpr int kMinArraySize = 8192 / sizeof(CType);\n-  static constexpr int kMaxValueRange = 16384;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  if ((array.length() - array.null_count()) >= kMinArraySize) {\n-    CType min = std::numeric_limits<CType>::max();\n-    CType max = std::numeric_limits<CType>::min();\n-\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             const auto value = values[pos + i];\n-                                             min = std::min(min, value);\n-                                             max = std::max(max, value);\n-                                           }\n-                                         });\n-\n-    if (static_cast<uint64_t>(max) - static_cast<uint64_t>(min) <= kMaxValueRange) {\n-      return CountValuesByVector(array, min, max);\n-    }\n-  }\n-  return CountValuesByMap(array);\n-}\n+  CType* mode_buffer;\n+  int64_t* count_buffer;\n+  KERNEL_ASSIGN_OR_RAISE(std::tie(mode_buffer, count_buffer), ctx,\n+                         PrepareOutput<InType>(n, ctx, out));\n \n-// bool\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_boolean_type<typename ArrayType::TypeClass>::value, CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  // we need just count ones and zeros\n-  CounterMap<CType> map;\n-  if (array.length() > array.null_count()) {\n-    map[true] = array.true_count();\n-    map[false] = array.length() - array.null_count() - map[true];\n+  for (int64_t i = n - 1; i >= 0; --i) {\n+    std::tie(mode_buffer[i], count_buffer[i]) = min_heap.top();\n+    min_heap.pop();\n   }\n-  nan_count = 0;\n-  return map;\n }\n \n-// int8\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_integer_type<typename ArrayType::TypeClass>::value && sizeof(CType) == 1,\n-            CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  using Limits = std::numeric_limits<CType>;\n-  nan_count = 0;\n-  return CountValuesByVector(array, Limits::min(), Limits::max());\n-}\n+// count value occurances for integers with narrow value range\n+// O(1) space, O(n) time\n+template <typename T>\n+struct CountModer {\n+  using CType = typename T::c_type;\n \n-// int16/32/64\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_integer_type<typename ArrayType::TypeClass>::value && (sizeof(CType) > 1),\n-            CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  nan_count = 0;\n-  return CountValuesByMapOrVector(array);\n-}\n+  CType min;\n+  std::vector<int64_t> counts;\n \n-// float/double\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<(std::is_floating_point<CType>::value), CounterMap<CType>>  // NOLINT format\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  nan_count = 0;\n-  return CountValuesByMap(array, nan_count);\n-}\n+  CountModer(CType min, CType max) {\n+    uint32_t value_range = static_cast<uint32_t>(max - min) + 1;\n+    DCHECK_LT(value_range, 1 << 20);\n+    this->min = min;\n+    this->counts.resize(value_range, 0);\n+  }\n \n-template <typename ArrowType>\n-struct ModeState {\n-  using ThisType = ModeState<ArrowType>;\n-  using CType = typename ArrowType::c_type;\n-\n-  void MergeFrom(ThisType&& state) {\n-    if (this->value_counts.empty()) {\n-      this->value_counts = std::move(state.value_counts);\n-    } else {\n-      for (const auto& value_count : state.value_counts) {\n-        auto value = value_count.first;\n-        auto count = value_count.second;\n-        this->value_counts[value] += count;\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // count values in all chunks, ignore nulls\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                ++this->counts[values[pos + i] - this->min];\n+                              }\n+                            });\n       }\n     }\n-    if (is_floating_type<ArrowType>::value) {\n-      this->nan_count += state.nan_count;\n-    }\n-  }\n-\n-  // find top-n value/count pairs with min-heap (priority queue with '>' comparator)\n-  void Finalize(CType* modes, int64_t* counts, const int64_t n) {\n-    DCHECK(n >= 1 && n <= this->DistinctValues());\n \n-    // mode 'greater than' comparator: larger count or same count with smaller value\n-    using ValueCountPair = std::pair<CType, int64_t>;\n-    auto mode_gt = [](const ValueCountPair& lhs, const ValueCountPair& rhs) {\n-      const bool rhs_is_nan = rhs.first != rhs.first;  // nan as largest value\n-      return lhs.second > rhs.second ||\n-             (lhs.second == rhs.second && (lhs.first < rhs.first || rhs_is_nan));\n+    // generator to emit next value:count pair\n+    int index = 0;\n+    auto gen = [&]() {\n+      for (; index < static_cast<int>(counts.size()); ++index) {\n+        if (counts[index] != 0) {\n+          auto value_count =\n+              std::make_pair(static_cast<CType>(index + this->min), counts[index]);\n+          ++index;\n+          return value_count;\n+        }\n+      }\n+      return std::make_pair<CType, int64_t>(0, -1);  // EOF\n     };\n \n-    // initialize min-heap with first n modes\n-    std::vector<ValueCountPair> vector(n);\n-    // push nan if exists\n-    const bool has_nan = is_floating_type<ArrowType>::value && this->nan_count > 0;\n-    if (has_nan) {\n-      vector[0] = std::make_pair(static_cast<CType>(NAN), this->nan_count);\n-    }\n-    // push n or n-1 modes\n-    auto it = this->value_counts.cbegin();\n-    for (int i = has_nan; i < n; ++i) {\n-      vector[i] = *it++;\n-    }\n-    // turn to min-heap\n-    std::priority_queue<ValueCountPair, std::vector<ValueCountPair>, decltype(mode_gt)>\n-        min_heap(std::move(mode_gt), std::move(vector));\n-\n-    // iterate and insert modes into min-heap\n-    // - mode < heap top: ignore mode\n-    // - mode > heap top: discard heap top, insert mode\n-    for (; it != this->value_counts.cend(); ++it) {\n-      if (mode_gt(*it, min_heap.top())) {\n-        min_heap.pop();\n-        min_heap.push(*it);\n-      }\n+    Finalize<T>(ctx, out, std::move(gen));\n+  }\n+};\n+\n+// booleans can be handled more straightforward\n+template <>\n+struct CountModer<BooleanType> {\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    int64_t counts[2]{};\n+\n+    const Datum& datum = batch[0];\n+    for (const auto& array : datum.chunks()) {\n+      if (array->length() > array->null_count()) {\n+        const int64_t true_count =\n+            checked_pointer_cast<BooleanArray>(array)->true_count();\n+        const int64_t false_count = array->length() - array->null_count() - true_count;\n+        counts[true] += true_count;\n+        counts[false] += false_count;\n+      };\n     }\n \n-    // pop modes from min-heap and insert into output array (in reverse order)\n-    DCHECK_EQ(min_heap.size(), static_cast<size_t>(n));\n-    for (int64_t i = n - 1; i >= 0; --i) {\n-      std::tie(modes[i], counts[i]) = min_heap.top();\n-      min_heap.pop();\n+    const ModeOptions& options = ModeState::Get(ctx);\n+    const int64_t distinct_values = (counts[0] != 0) + (counts[1] != 0);\n+    const int64_t n = std::min(options.n, distinct_values);\n+\n+    bool* mode_buffer;\n+    int64_t* count_buffer;\n+    KERNEL_ASSIGN_OR_RAISE(std::tie(mode_buffer, count_buffer), ctx,\n+                           PrepareOutput<BooleanType>(n, ctx, out));\n+\n+    if (n >= 1) {\n+      const bool index = counts[1] > counts[0];\n+      mode_buffer[0] = index;\n+      count_buffer[0] = counts[index];\n+      if (n == 2) {\n+        mode_buffer[1] = !index;\n+        count_buffer[1] = counts[!index];\n+      }\n     }\n   }\n+};\n \n-  int64_t DistinctValues() const {\n-    return this->value_counts.size() +\n-           (is_floating_type<ArrowType>::value && this->nan_count > 0);\n-  }\n+// copy and sort approach for floating points or integers with wide value range\n+// O(n) space, O(nlogn) time\n+template <typename T>\n+struct SortModer {\n+  using CType = typename T::c_type;\n+  using Allocator = arrow::stl::allocator<CType>;\n \n-  int64_t nan_count = 0;  // only make sense to floating types\n-  CounterMap<CType> value_counts;\n-};\n+  int64_t nan_count = 0;\n \n-template <typename ArrowType>\n-struct ModeImpl : public ScalarAggregator {\n-  using ThisType = ModeImpl<ArrowType>;\n-  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n-  using CType = typename ArrowType::c_type;\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType, Allocator> in_buffer(Allocator(ctx->memory_pool()));\n \n-  ModeImpl(const std::shared_ptr<DataType>& out_type, const ModeOptions& options)\n-      : out_type(out_type), options(options) {}\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n \n-  void Consume(KernelContext*, const ExecBatch& batch) override {\n-    ArrayType array(batch[0].array());\n-    this->state.value_counts = CountValues(array, this->state.nan_count);\n-  }\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n \n-  void MergeFrom(KernelContext*, KernelState&& src) override {\n-    auto& other = checked_cast<ThisType&>(src);\n-    this->state.MergeFrom(std::move(other.state));\n-  }\n+      // drop nan\n+      if (is_floating_type<T>::value) {\n+        const auto& it = std::remove_if(in_buffer.begin(), in_buffer.end(),\n+                                        [](CType v) { return v != v; });\n+        this->nan_count = in_buffer.end() - it;\n+        in_buffer.resize(it - in_buffer.begin());\n+      }\n+    }\n \n-  static std::shared_ptr<ArrayData> MakeArrayData(\n-      const std::shared_ptr<DataType>& data_type, int64_t n) {\n-    auto data = ArrayData::Make(data_type, n, 0);\n-    data->buffers.resize(2);\n-    data->buffers[0] = nullptr;\n-    data->buffers[1] = nullptr;\n-    return data;\n+    // sort the input data to count same values\n+    std::sort(in_buffer.begin(), in_buffer.end());\n+\n+    // generator to emit next value:count pair\n+    auto it = in_buffer.cbegin();\n+    int64_t nan_count_copy = this->nan_count;\n+    auto gen = [&]() {\n+      if (ARROW_PREDICT_FALSE(it == in_buffer.cend())) {\n+        // handle NAN at last\n+        if (nan_count_copy > 0) {\n+          auto value_count = std::make_pair(static_cast<CType>(NAN), nan_count_copy);\n+          nan_count_copy = 0;\n+          return value_count;\n+        }\n+        return std::make_pair<CType, int64_t>(0, -1);  // EOF\n+      }\n+      // count same values\n+      const CType value = *it;\n+      int64_t count = 0;\n+      do {\n+        ++it;\n+        ++count;\n+      } while (it != in_buffer.cend() && *it == value);\n+      return std::make_pair(value, count);\n+    };\n+\n+    Finalize<T>(ctx, out, std::move(gen));\n   }\n \n-  void Finalize(KernelContext* ctx, Datum* out) override {\n-    const auto& mode_type = TypeTraits<ArrowType>::type_singleton();\n-    const auto& count_type = int64();\n-    const auto& out_type =\n-        struct_({field(kModeFieldName, mode_type), field(kCountFieldName, count_type)});\n-\n-    int64_t n = this->options.n;\n-    if (n > state.DistinctValues()) {\n-      n = state.DistinctValues();\n-    } else if (n < 0) {\n-      n = 0;\n+  static int64_t CopyArray(CType* buffer, const Array& array) {\n+    const int64_t n = array.length() - array.null_count();\n+    if (n > 0) {\n+      int64_t index = 0;\n+      const ArrayData& data = *array.data();\n+      const CType* values = data.GetValues<CType>(1);\n+      VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                          [&](int64_t pos, int64_t len) {\n+                            memcpy(buffer + index, values + pos, len * sizeof(CType));\n+                            index += len;\n+                          });\n+      DCHECK_EQ(index, n);\n     }\n+    return n;\n+  }\n+};\n \n-    auto mode_data = this->MakeArrayData(mode_type, n);\n-    auto count_data = this->MakeArrayData(count_type, n);\n-    if (n > 0) {\n-      KERNEL_ASSIGN_OR_RAISE(mode_data->buffers[1], ctx,\n-                             ctx->Allocate(n * sizeof(CType)));\n-      KERNEL_ASSIGN_OR_RAISE(count_data->buffers[1], ctx,\n-                             ctx->Allocate(n * sizeof(int64_t)));\n-      CType* mode_buffer = mode_data->template GetMutableValues<CType>(1);\n-      int64_t* count_buffer = count_data->template GetMutableValues<int64_t>(1);\n-      this->state.Finalize(mode_buffer, count_buffer, n);\n+// pick counting or sorting approach per integers value range\n+template <typename T>\n+struct CountOrSortModer {\n+  using CType = typename T::c_type;\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // cross point to benefit from counting approach\n+    // about 2x improvement for int32/64 from micro-benchmarking\n+    static constexpr int kMinArraySize = 8192;\n+    static constexpr int kMaxValueRange = 32768;\n+\n+    const Datum& datum = batch[0];\n+    if (datum.length() - datum.null_count() >= kMinArraySize) {\n+      CType min = std::numeric_limits<CType>::max();\n+      CType max = std::numeric_limits<CType>::min();\n+\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                min = std::min(min, values[pos + i]);\n+                                max = std::max(max, values[pos + i]);\n+                              }\n+                            });\n\nReview comment:\n       It looks like this operation (compute the minmax of a Datum or ArrayData) is common enough to be factored out in an internal header file?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T16:25:47.626+0000",
                    "updated": "2021-04-13T16:25:47.626+0000",
                    "started": "2021-04-13T16:25:47.626+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581889",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/581890",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#discussion_r612600080\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_mode.cc\n##########\n@@ -31,340 +33,359 @@ namespace internal {\n \n namespace {\n \n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using ModeState = OptionsWrapper<ModeOptions>;\n+\n constexpr char kModeFieldName[] = \"mode\";\n constexpr char kCountFieldName[] = \"count\";\n \n-// {value:count} map\n-template <typename CType>\n-using CounterMap = std::unordered_map<CType, int64_t>;\n-\n-// map based counter for floating points\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<std::is_floating_point<CType>::value, CounterMap<CType>> CountValuesByMap(\n-    const ArrayType& array, int64_t& nan_count) {\n-  CounterMap<CType> value_counts_map;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  nan_count = 0;\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             const auto value = values[pos + i];\n-                                             if (std::isnan(value)) {\n-                                               ++nan_count;\n-                                             } else {\n-                                               ++value_counts_map[value];\n-                                             }\n-                                           }\n-                                         });\n+template <typename InType, typename CType = typename InType::c_type>\n+Result<std::pair<CType*, int64_t*>> PrepareOutput(int64_t n, KernelContext* ctx,\n+                                                  Datum* out) {\n+  const auto& mode_type = TypeTraits<InType>::type_singleton();\n+  const auto& count_type = int64();\n+\n+  auto mode_data = ArrayData::Make(mode_type, /*length=*/n, /*null_count=*/0);\n+  mode_data->buffers.resize(2, nullptr);\n+  auto count_data = ArrayData::Make(count_type, n, 0);\n+  count_data->buffers.resize(2, nullptr);\n+\n+  CType* mode_buffer = nullptr;\n+  int64_t* count_buffer = nullptr;\n+\n+  if (n > 0) {\n+    ARROW_ASSIGN_OR_RAISE(mode_data->buffers[1], ctx->Allocate(n * sizeof(CType)));\n+    ARROW_ASSIGN_OR_RAISE(count_data->buffers[1], ctx->Allocate(n * sizeof(int64_t)));\n+    mode_buffer = mode_data->template GetMutableValues<CType>(1);\n+    count_buffer = count_data->template GetMutableValues<int64_t>(1);\n   }\n \n-  return value_counts_map;\n-}\n-\n-// map base counter for non floating points\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<!std::is_floating_point<CType>::value, CounterMap<CType>> CountValuesByMap(\n-    const ArrayType& array) {\n-  CounterMap<CType> value_counts_map;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             ++value_counts_map[values[pos + i]];\n-                                           }\n-                                         });\n-  }\n+  const auto& out_type =\n+      struct_({field(kModeFieldName, mode_type), field(kCountFieldName, count_type)});\n+  *out = Datum(ArrayData::Make(out_type, n, {nullptr}, {mode_data, count_data}, 0));\n \n-  return value_counts_map;\n+  return std::make_pair(mode_buffer, count_buffer);\n }\n \n-// vector based counter for int8 or integers with small value range\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-CounterMap<CType> CountValuesByVector(const ArrayType& array, CType min, CType max) {\n-  const int range = static_cast<int>(max - min);\n-  DCHECK(range >= 0 && range < 64 * 1024 * 1024);\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  std::vector<int64_t> value_counts_vector(range + 1);\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             ++value_counts_vector[values[pos + i] - min];\n-                                           }\n-                                         });\n-  }\n-\n-  // Transfer value counts to a map to be consistent with other chunks\n-  CounterMap<CType> value_counts_map(range + 1);\n-  for (int i = 0; i <= range; ++i) {\n-    CType value = static_cast<CType>(i + min);\n-    int64_t count = value_counts_vector[i];\n-    if (count) {\n-      value_counts_map[value] = count;\n+// find top-n value:count pairs with minimal heap\n+// suboptimal for tiny or large n, possibly okay as we're not in hot path\n+template <typename InType, typename Generator>\n+void Finalize(KernelContext* ctx, Datum* out, Generator&& gen) {\n+  using CType = typename InType::c_type;\n+\n+  using ValueCountPair = std::pair<CType, int64_t>;\n+  auto gt = [](const ValueCountPair& lhs, const ValueCountPair& rhs) {\n+    const bool rhs_is_nan = rhs.first != rhs.first;  // nan as largest value\n+    return lhs.second > rhs.second ||\n+           (lhs.second == rhs.second && (lhs.first < rhs.first || rhs_is_nan));\n+  };\n+\n+  std::priority_queue<ValueCountPair, std::vector<ValueCountPair>, decltype(gt)> min_heap(\n+      std::move(gt));\n+\n+  const ModeOptions& options = ModeState::Get(ctx);\n+  while (true) {\n+    const ValueCountPair& value_count = gen();\n+    DCHECK_NE(value_count.second, 0);\n+    if (value_count.second < 0) break;  // EOF reached\n+    if (static_cast<int64_t>(min_heap.size()) < options.n) {\n+      min_heap.push(value_count);\n+    } else if (gt(value_count, min_heap.top())) {\n+      min_heap.pop();\n+      min_heap.push(value_count);\n     }\n   }\n+  const int64_t n = min_heap.size();\n \n-  return value_counts_map;\n-}\n-\n-// map or vector based counter for int16/32/64 per value range\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-CounterMap<CType> CountValuesByMapOrVector(const ArrayType& array) {\n-  // see https://issues.apache.org/jira/browse/ARROW-9873\n-  static constexpr int kMinArraySize = 8192 / sizeof(CType);\n-  static constexpr int kMaxValueRange = 16384;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  if ((array.length() - array.null_count()) >= kMinArraySize) {\n-    CType min = std::numeric_limits<CType>::max();\n-    CType max = std::numeric_limits<CType>::min();\n-\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             const auto value = values[pos + i];\n-                                             min = std::min(min, value);\n-                                             max = std::max(max, value);\n-                                           }\n-                                         });\n-\n-    if (static_cast<uint64_t>(max) - static_cast<uint64_t>(min) <= kMaxValueRange) {\n-      return CountValuesByVector(array, min, max);\n-    }\n-  }\n-  return CountValuesByMap(array);\n-}\n+  CType* mode_buffer;\n+  int64_t* count_buffer;\n+  KERNEL_ASSIGN_OR_RAISE(std::tie(mode_buffer, count_buffer), ctx,\n+                         PrepareOutput<InType>(n, ctx, out));\n \n-// bool\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_boolean_type<typename ArrayType::TypeClass>::value, CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  // we need just count ones and zeros\n-  CounterMap<CType> map;\n-  if (array.length() > array.null_count()) {\n-    map[true] = array.true_count();\n-    map[false] = array.length() - array.null_count() - map[true];\n+  for (int64_t i = n - 1; i >= 0; --i) {\n+    std::tie(mode_buffer[i], count_buffer[i]) = min_heap.top();\n+    min_heap.pop();\n   }\n-  nan_count = 0;\n-  return map;\n }\n \n-// int8\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_integer_type<typename ArrayType::TypeClass>::value && sizeof(CType) == 1,\n-            CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  using Limits = std::numeric_limits<CType>;\n-  nan_count = 0;\n-  return CountValuesByVector(array, Limits::min(), Limits::max());\n-}\n+// count value occurances for integers with narrow value range\n+// O(1) space, O(n) time\n+template <typename T>\n+struct CountModer {\n+  using CType = typename T::c_type;\n \n-// int16/32/64\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_integer_type<typename ArrayType::TypeClass>::value && (sizeof(CType) > 1),\n-            CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  nan_count = 0;\n-  return CountValuesByMapOrVector(array);\n-}\n+  CType min;\n+  std::vector<int64_t> counts;\n \n-// float/double\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<(std::is_floating_point<CType>::value), CounterMap<CType>>  // NOLINT format\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  nan_count = 0;\n-  return CountValuesByMap(array, nan_count);\n-}\n+  CountModer(CType min, CType max) {\n+    uint32_t value_range = static_cast<uint32_t>(max - min) + 1;\n+    DCHECK_LT(value_range, 1 << 20);\n+    this->min = min;\n+    this->counts.resize(value_range, 0);\n+  }\n \n-template <typename ArrowType>\n-struct ModeState {\n-  using ThisType = ModeState<ArrowType>;\n-  using CType = typename ArrowType::c_type;\n-\n-  void MergeFrom(ThisType&& state) {\n-    if (this->value_counts.empty()) {\n-      this->value_counts = std::move(state.value_counts);\n-    } else {\n-      for (const auto& value_count : state.value_counts) {\n-        auto value = value_count.first;\n-        auto count = value_count.second;\n-        this->value_counts[value] += count;\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // count values in all chunks, ignore nulls\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                ++this->counts[values[pos + i] - this->min];\n+                              }\n+                            });\n       }\n     }\n-    if (is_floating_type<ArrowType>::value) {\n-      this->nan_count += state.nan_count;\n-    }\n-  }\n-\n-  // find top-n value/count pairs with min-heap (priority queue with '>' comparator)\n-  void Finalize(CType* modes, int64_t* counts, const int64_t n) {\n-    DCHECK(n >= 1 && n <= this->DistinctValues());\n \n-    // mode 'greater than' comparator: larger count or same count with smaller value\n-    using ValueCountPair = std::pair<CType, int64_t>;\n-    auto mode_gt = [](const ValueCountPair& lhs, const ValueCountPair& rhs) {\n-      const bool rhs_is_nan = rhs.first != rhs.first;  // nan as largest value\n-      return lhs.second > rhs.second ||\n-             (lhs.second == rhs.second && (lhs.first < rhs.first || rhs_is_nan));\n+    // generator to emit next value:count pair\n+    int index = 0;\n+    auto gen = [&]() {\n+      for (; index < static_cast<int>(counts.size()); ++index) {\n+        if (counts[index] != 0) {\n+          auto value_count =\n+              std::make_pair(static_cast<CType>(index + this->min), counts[index]);\n+          ++index;\n+          return value_count;\n+        }\n+      }\n+      return std::make_pair<CType, int64_t>(0, -1);  // EOF\n     };\n \n-    // initialize min-heap with first n modes\n-    std::vector<ValueCountPair> vector(n);\n-    // push nan if exists\n-    const bool has_nan = is_floating_type<ArrowType>::value && this->nan_count > 0;\n-    if (has_nan) {\n-      vector[0] = std::make_pair(static_cast<CType>(NAN), this->nan_count);\n-    }\n-    // push n or n-1 modes\n-    auto it = this->value_counts.cbegin();\n-    for (int i = has_nan; i < n; ++i) {\n-      vector[i] = *it++;\n-    }\n-    // turn to min-heap\n-    std::priority_queue<ValueCountPair, std::vector<ValueCountPair>, decltype(mode_gt)>\n-        min_heap(std::move(mode_gt), std::move(vector));\n-\n-    // iterate and insert modes into min-heap\n-    // - mode < heap top: ignore mode\n-    // - mode > heap top: discard heap top, insert mode\n-    for (; it != this->value_counts.cend(); ++it) {\n-      if (mode_gt(*it, min_heap.top())) {\n-        min_heap.pop();\n-        min_heap.push(*it);\n-      }\n+    Finalize<T>(ctx, out, std::move(gen));\n+  }\n+};\n+\n+// booleans can be handled more straightforward\n+template <>\n+struct CountModer<BooleanType> {\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    int64_t counts[2]{};\n+\n+    const Datum& datum = batch[0];\n+    for (const auto& array : datum.chunks()) {\n+      if (array->length() > array->null_count()) {\n+        const int64_t true_count =\n+            checked_pointer_cast<BooleanArray>(array)->true_count();\n+        const int64_t false_count = array->length() - array->null_count() - true_count;\n+        counts[true] += true_count;\n+        counts[false] += false_count;\n+      };\n     }\n \n-    // pop modes from min-heap and insert into output array (in reverse order)\n-    DCHECK_EQ(min_heap.size(), static_cast<size_t>(n));\n-    for (int64_t i = n - 1; i >= 0; --i) {\n-      std::tie(modes[i], counts[i]) = min_heap.top();\n-      min_heap.pop();\n+    const ModeOptions& options = ModeState::Get(ctx);\n+    const int64_t distinct_values = (counts[0] != 0) + (counts[1] != 0);\n+    const int64_t n = std::min(options.n, distinct_values);\n+\n+    bool* mode_buffer;\n+    int64_t* count_buffer;\n+    KERNEL_ASSIGN_OR_RAISE(std::tie(mode_buffer, count_buffer), ctx,\n+                           PrepareOutput<BooleanType>(n, ctx, out));\n+\n+    if (n >= 1) {\n+      const bool index = counts[1] > counts[0];\n+      mode_buffer[0] = index;\n+      count_buffer[0] = counts[index];\n+      if (n == 2) {\n+        mode_buffer[1] = !index;\n+        count_buffer[1] = counts[!index];\n+      }\n     }\n   }\n+};\n \n-  int64_t DistinctValues() const {\n-    return this->value_counts.size() +\n-           (is_floating_type<ArrowType>::value && this->nan_count > 0);\n-  }\n+// copy and sort approach for floating points or integers with wide value range\n+// O(n) space, O(nlogn) time\n+template <typename T>\n+struct SortModer {\n+  using CType = typename T::c_type;\n+  using Allocator = arrow::stl::allocator<CType>;\n \n-  int64_t nan_count = 0;  // only make sense to floating types\n-  CounterMap<CType> value_counts;\n-};\n+  int64_t nan_count = 0;\n \n-template <typename ArrowType>\n-struct ModeImpl : public ScalarAggregator {\n-  using ThisType = ModeImpl<ArrowType>;\n-  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n-  using CType = typename ArrowType::c_type;\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType, Allocator> in_buffer(Allocator(ctx->memory_pool()));\n \n-  ModeImpl(const std::shared_ptr<DataType>& out_type, const ModeOptions& options)\n-      : out_type(out_type), options(options) {}\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n \n-  void Consume(KernelContext*, const ExecBatch& batch) override {\n-    ArrayType array(batch[0].array());\n-    this->state.value_counts = CountValues(array, this->state.nan_count);\n-  }\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n \n-  void MergeFrom(KernelContext*, KernelState&& src) override {\n-    auto& other = checked_cast<ThisType&>(src);\n-    this->state.MergeFrom(std::move(other.state));\n-  }\n+      // drop nan\n+      if (is_floating_type<T>::value) {\n+        const auto& it = std::remove_if(in_buffer.begin(), in_buffer.end(),\n+                                        [](CType v) { return v != v; });\n+        this->nan_count = in_buffer.end() - it;\n+        in_buffer.resize(it - in_buffer.begin());\n+      }\n+    }\n \n-  static std::shared_ptr<ArrayData> MakeArrayData(\n-      const std::shared_ptr<DataType>& data_type, int64_t n) {\n-    auto data = ArrayData::Make(data_type, n, 0);\n-    data->buffers.resize(2);\n-    data->buffers[0] = nullptr;\n-    data->buffers[1] = nullptr;\n-    return data;\n+    // sort the input data to count same values\n+    std::sort(in_buffer.begin(), in_buffer.end());\n+\n+    // generator to emit next value:count pair\n+    auto it = in_buffer.cbegin();\n+    int64_t nan_count_copy = this->nan_count;\n+    auto gen = [&]() {\n+      if (ARROW_PREDICT_FALSE(it == in_buffer.cend())) {\n+        // handle NAN at last\n+        if (nan_count_copy > 0) {\n+          auto value_count = std::make_pair(static_cast<CType>(NAN), nan_count_copy);\n+          nan_count_copy = 0;\n+          return value_count;\n+        }\n+        return std::make_pair<CType, int64_t>(0, -1);  // EOF\n+      }\n+      // count same values\n+      const CType value = *it;\n+      int64_t count = 0;\n+      do {\n+        ++it;\n+        ++count;\n+      } while (it != in_buffer.cend() && *it == value);\n+      return std::make_pair(value, count);\n+    };\n+\n+    Finalize<T>(ctx, out, std::move(gen));\n   }\n \n-  void Finalize(KernelContext* ctx, Datum* out) override {\n-    const auto& mode_type = TypeTraits<ArrowType>::type_singleton();\n-    const auto& count_type = int64();\n-    const auto& out_type =\n-        struct_({field(kModeFieldName, mode_type), field(kCountFieldName, count_type)});\n-\n-    int64_t n = this->options.n;\n-    if (n > state.DistinctValues()) {\n-      n = state.DistinctValues();\n-    } else if (n < 0) {\n-      n = 0;\n+  static int64_t CopyArray(CType* buffer, const Array& array) {\n+    const int64_t n = array.length() - array.null_count();\n+    if (n > 0) {\n+      int64_t index = 0;\n+      const ArrayData& data = *array.data();\n+      const CType* values = data.GetValues<CType>(1);\n+      VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                          [&](int64_t pos, int64_t len) {\n+                            memcpy(buffer + index, values + pos, len * sizeof(CType));\n+                            index += len;\n+                          });\n+      DCHECK_EQ(index, n);\n     }\n+    return n;\n+  }\n+};\n \n-    auto mode_data = this->MakeArrayData(mode_type, n);\n-    auto count_data = this->MakeArrayData(count_type, n);\n-    if (n > 0) {\n-      KERNEL_ASSIGN_OR_RAISE(mode_data->buffers[1], ctx,\n-                             ctx->Allocate(n * sizeof(CType)));\n-      KERNEL_ASSIGN_OR_RAISE(count_data->buffers[1], ctx,\n-                             ctx->Allocate(n * sizeof(int64_t)));\n-      CType* mode_buffer = mode_data->template GetMutableValues<CType>(1);\n-      int64_t* count_buffer = count_data->template GetMutableValues<int64_t>(1);\n-      this->state.Finalize(mode_buffer, count_buffer, n);\n+// pick counting or sorting approach per integers value range\n+template <typename T>\n+struct CountOrSortModer {\n+  using CType = typename T::c_type;\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // cross point to benefit from counting approach\n+    // about 2x improvement for int32/64 from micro-benchmarking\n+    static constexpr int kMinArraySize = 8192;\n+    static constexpr int kMaxValueRange = 32768;\n+\n+    const Datum& datum = batch[0];\n+    if (datum.length() - datum.null_count() >= kMinArraySize) {\n+      CType min = std::numeric_limits<CType>::max();\n+      CType max = std::numeric_limits<CType>::min();\n+\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                min = std::min(min, values[pos + i]);\n+                                max = std::max(max, values[pos + i]);\n+                              }\n+                            });\n+      }\n+\n+      if (static_cast<uint64_t>(max) - static_cast<uint64_t>(min) <= kMaxValueRange) {\n+        CountModer<T>(min, max).Exec(ctx, batch, out);\n+        return;\n+      }\n     }\n \n-    *out = Datum(ArrayData::Make(out_type, n, {nullptr}, {mode_data, count_data}, 0));\n+    SortModer<T>().Exec(ctx, batch, out);\n   }\n+};\n \n-  std::shared_ptr<DataType> out_type;\n-  ModeState<ArrowType> state;\n-  ModeOptions options;\n+template <typename InType, typename Enable = void>\n+struct Moder;\n+\n+template <>\n+struct Moder<Int8Type> {\n+  CountModer<Int8Type> impl;\n+  Moder() : impl(-128, 127) {}\n };\n \n-struct ModeInitState {\n-  std::unique_ptr<KernelState> state;\n-  KernelContext* ctx;\n-  const DataType& in_type;\n-  const std::shared_ptr<DataType>& out_type;\n-  const ModeOptions& options;\n+template <>\n+struct Moder<UInt8Type> {\n+  CountModer<UInt8Type> impl;\n+  Moder() : impl(0, 255) {}\n+};\n \n-  ModeInitState(KernelContext* ctx, const DataType& in_type,\n-                const std::shared_ptr<DataType>& out_type, const ModeOptions& options)\n-      : ctx(ctx), in_type(in_type), out_type(out_type), options(options) {}\n+template <>\n+struct Moder<BooleanType> {\n+  CountModer<BooleanType> impl;\n+};\n \n-  Status Visit(const DataType&) { return Status::NotImplemented(\"No mode implemented\"); }\n+template <typename InType>\n+struct Moder<InType, enable_if_t<(is_integer_type<InType>::value &&\n+                                  (sizeof(typename InType::c_type) > 1))>> {\n+  CountOrSortModer<InType> impl;\n+};\n \n-  Status Visit(const HalfFloatType&) {\n-    return Status::NotImplemented(\"No mode implemented\");\n-  }\n+template <typename InType>\n+struct Moder<InType, enable_if_t<is_floating_type<InType>::value>> {\n+  SortModer<InType> impl;\n+};\n \n-  template <typename Type>\n-  enable_if_t<is_number_type<Type>::value || is_boolean_type<Type>::value, Status> Visit(\n-      const Type&) {\n-    state.reset(new ModeImpl<Type>(out_type, options));\n-    return Status::OK();\n-  }\n+template <typename _, typename InType>\n+struct ModeExecutor {\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Mode requires ModeOptions\"));\n+      return;\n+    }\n+    const ModeOptions& options = ModeState::Get(ctx);\n+    if (options.n <= 0) {\n+      ctx->SetStatus(Status::Invalid(\"ModeOption::n must be positive\"));\n\nReview comment:\n       \"strictly positive\" or \"> 0\"\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T16:26:41.089+0000",
                    "updated": "2021-04-13T16:26:41.089+0000",
                    "started": "2021-04-13T16:26:41.089+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581890",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/581891",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#issuecomment-818871509\n\n\n   Do the existing tests exercise both the narrow and wide cases?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T16:27:14.170+0000",
                    "updated": "2021-04-13T16:27:14.170+0000",
                    "started": "2021-04-13T16:27:14.170+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581891",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/582149",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#issuecomment-819167274\n\n\n   > Do the existing tests exercise both the narrow and wide cases?\r\n   \r\n   Yes. https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernels/aggregate_test.cc#L1075-L1082\r\n   I do find a comment should be updated `hashmap-based` -> `sorter-based`\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T02:02:50.535+0000",
                    "updated": "2021-04-14T02:02:50.535+0000",
                    "started": "2021-04-14T02:02:50.534+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582149",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/582155",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#discussion_r612891573\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_mode.cc\n##########\n@@ -31,340 +33,359 @@ namespace internal {\n \n namespace {\n \n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using ModeState = OptionsWrapper<ModeOptions>;\n+\n constexpr char kModeFieldName[] = \"mode\";\n constexpr char kCountFieldName[] = \"count\";\n \n-// {value:count} map\n-template <typename CType>\n-using CounterMap = std::unordered_map<CType, int64_t>;\n-\n-// map based counter for floating points\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<std::is_floating_point<CType>::value, CounterMap<CType>> CountValuesByMap(\n-    const ArrayType& array, int64_t& nan_count) {\n-  CounterMap<CType> value_counts_map;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  nan_count = 0;\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             const auto value = values[pos + i];\n-                                             if (std::isnan(value)) {\n-                                               ++nan_count;\n-                                             } else {\n-                                               ++value_counts_map[value];\n-                                             }\n-                                           }\n-                                         });\n+template <typename InType, typename CType = typename InType::c_type>\n+Result<std::pair<CType*, int64_t*>> PrepareOutput(int64_t n, KernelContext* ctx,\n+                                                  Datum* out) {\n+  const auto& mode_type = TypeTraits<InType>::type_singleton();\n+  const auto& count_type = int64();\n+\n+  auto mode_data = ArrayData::Make(mode_type, /*length=*/n, /*null_count=*/0);\n+  mode_data->buffers.resize(2, nullptr);\n+  auto count_data = ArrayData::Make(count_type, n, 0);\n+  count_data->buffers.resize(2, nullptr);\n+\n+  CType* mode_buffer = nullptr;\n+  int64_t* count_buffer = nullptr;\n+\n+  if (n > 0) {\n+    ARROW_ASSIGN_OR_RAISE(mode_data->buffers[1], ctx->Allocate(n * sizeof(CType)));\n+    ARROW_ASSIGN_OR_RAISE(count_data->buffers[1], ctx->Allocate(n * sizeof(int64_t)));\n+    mode_buffer = mode_data->template GetMutableValues<CType>(1);\n+    count_buffer = count_data->template GetMutableValues<int64_t>(1);\n   }\n \n-  return value_counts_map;\n-}\n-\n-// map base counter for non floating points\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<!std::is_floating_point<CType>::value, CounterMap<CType>> CountValuesByMap(\n-    const ArrayType& array) {\n-  CounterMap<CType> value_counts_map;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             ++value_counts_map[values[pos + i]];\n-                                           }\n-                                         });\n-  }\n+  const auto& out_type =\n+      struct_({field(kModeFieldName, mode_type), field(kCountFieldName, count_type)});\n+  *out = Datum(ArrayData::Make(out_type, n, {nullptr}, {mode_data, count_data}, 0));\n \n-  return value_counts_map;\n+  return std::make_pair(mode_buffer, count_buffer);\n }\n \n-// vector based counter for int8 or integers with small value range\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-CounterMap<CType> CountValuesByVector(const ArrayType& array, CType min, CType max) {\n-  const int range = static_cast<int>(max - min);\n-  DCHECK(range >= 0 && range < 64 * 1024 * 1024);\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  std::vector<int64_t> value_counts_vector(range + 1);\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             ++value_counts_vector[values[pos + i] - min];\n-                                           }\n-                                         });\n-  }\n-\n-  // Transfer value counts to a map to be consistent with other chunks\n-  CounterMap<CType> value_counts_map(range + 1);\n-  for (int i = 0; i <= range; ++i) {\n-    CType value = static_cast<CType>(i + min);\n-    int64_t count = value_counts_vector[i];\n-    if (count) {\n-      value_counts_map[value] = count;\n+// find top-n value:count pairs with minimal heap\n+// suboptimal for tiny or large n, possibly okay as we're not in hot path\n+template <typename InType, typename Generator>\n+void Finalize(KernelContext* ctx, Datum* out, Generator&& gen) {\n+  using CType = typename InType::c_type;\n+\n+  using ValueCountPair = std::pair<CType, int64_t>;\n+  auto gt = [](const ValueCountPair& lhs, const ValueCountPair& rhs) {\n+    const bool rhs_is_nan = rhs.first != rhs.first;  // nan as largest value\n+    return lhs.second > rhs.second ||\n+           (lhs.second == rhs.second && (lhs.first < rhs.first || rhs_is_nan));\n+  };\n+\n+  std::priority_queue<ValueCountPair, std::vector<ValueCountPair>, decltype(gt)> min_heap(\n+      std::move(gt));\n+\n+  const ModeOptions& options = ModeState::Get(ctx);\n+  while (true) {\n+    const ValueCountPair& value_count = gen();\n+    DCHECK_NE(value_count.second, 0);\n+    if (value_count.second < 0) break;  // EOF reached\n+    if (static_cast<int64_t>(min_heap.size()) < options.n) {\n+      min_heap.push(value_count);\n+    } else if (gt(value_count, min_heap.top())) {\n+      min_heap.pop();\n+      min_heap.push(value_count);\n     }\n   }\n+  const int64_t n = min_heap.size();\n \n-  return value_counts_map;\n-}\n-\n-// map or vector based counter for int16/32/64 per value range\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-CounterMap<CType> CountValuesByMapOrVector(const ArrayType& array) {\n-  // see https://issues.apache.org/jira/browse/ARROW-9873\n-  static constexpr int kMinArraySize = 8192 / sizeof(CType);\n-  static constexpr int kMaxValueRange = 16384;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  if ((array.length() - array.null_count()) >= kMinArraySize) {\n-    CType min = std::numeric_limits<CType>::max();\n-    CType max = std::numeric_limits<CType>::min();\n-\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             const auto value = values[pos + i];\n-                                             min = std::min(min, value);\n-                                             max = std::max(max, value);\n-                                           }\n-                                         });\n-\n-    if (static_cast<uint64_t>(max) - static_cast<uint64_t>(min) <= kMaxValueRange) {\n-      return CountValuesByVector(array, min, max);\n-    }\n-  }\n-  return CountValuesByMap(array);\n-}\n+  CType* mode_buffer;\n+  int64_t* count_buffer;\n+  KERNEL_ASSIGN_OR_RAISE(std::tie(mode_buffer, count_buffer), ctx,\n+                         PrepareOutput<InType>(n, ctx, out));\n \n-// bool\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_boolean_type<typename ArrayType::TypeClass>::value, CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  // we need just count ones and zeros\n-  CounterMap<CType> map;\n-  if (array.length() > array.null_count()) {\n-    map[true] = array.true_count();\n-    map[false] = array.length() - array.null_count() - map[true];\n+  for (int64_t i = n - 1; i >= 0; --i) {\n+    std::tie(mode_buffer[i], count_buffer[i]) = min_heap.top();\n+    min_heap.pop();\n   }\n-  nan_count = 0;\n-  return map;\n }\n \n-// int8\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_integer_type<typename ArrayType::TypeClass>::value && sizeof(CType) == 1,\n-            CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  using Limits = std::numeric_limits<CType>;\n-  nan_count = 0;\n-  return CountValuesByVector(array, Limits::min(), Limits::max());\n-}\n+// count value occurances for integers with narrow value range\n+// O(1) space, O(n) time\n+template <typename T>\n+struct CountModer {\n+  using CType = typename T::c_type;\n \n-// int16/32/64\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_integer_type<typename ArrayType::TypeClass>::value && (sizeof(CType) > 1),\n-            CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  nan_count = 0;\n-  return CountValuesByMapOrVector(array);\n-}\n+  CType min;\n+  std::vector<int64_t> counts;\n \n-// float/double\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<(std::is_floating_point<CType>::value), CounterMap<CType>>  // NOLINT format\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  nan_count = 0;\n-  return CountValuesByMap(array, nan_count);\n-}\n+  CountModer(CType min, CType max) {\n+    uint32_t value_range = static_cast<uint32_t>(max - min) + 1;\n+    DCHECK_LT(value_range, 1 << 20);\n+    this->min = min;\n+    this->counts.resize(value_range, 0);\n+  }\n \n-template <typename ArrowType>\n-struct ModeState {\n-  using ThisType = ModeState<ArrowType>;\n-  using CType = typename ArrowType::c_type;\n-\n-  void MergeFrom(ThisType&& state) {\n-    if (this->value_counts.empty()) {\n-      this->value_counts = std::move(state.value_counts);\n-    } else {\n-      for (const auto& value_count : state.value_counts) {\n-        auto value = value_count.first;\n-        auto count = value_count.second;\n-        this->value_counts[value] += count;\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // count values in all chunks, ignore nulls\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                ++this->counts[values[pos + i] - this->min];\n+                              }\n+                            });\n       }\n     }\n-    if (is_floating_type<ArrowType>::value) {\n-      this->nan_count += state.nan_count;\n-    }\n-  }\n-\n-  // find top-n value/count pairs with min-heap (priority queue with '>' comparator)\n-  void Finalize(CType* modes, int64_t* counts, const int64_t n) {\n-    DCHECK(n >= 1 && n <= this->DistinctValues());\n \n-    // mode 'greater than' comparator: larger count or same count with smaller value\n-    using ValueCountPair = std::pair<CType, int64_t>;\n-    auto mode_gt = [](const ValueCountPair& lhs, const ValueCountPair& rhs) {\n-      const bool rhs_is_nan = rhs.first != rhs.first;  // nan as largest value\n-      return lhs.second > rhs.second ||\n-             (lhs.second == rhs.second && (lhs.first < rhs.first || rhs_is_nan));\n+    // generator to emit next value:count pair\n+    int index = 0;\n+    auto gen = [&]() {\n+      for (; index < static_cast<int>(counts.size()); ++index) {\n+        if (counts[index] != 0) {\n+          auto value_count =\n+              std::make_pair(static_cast<CType>(index + this->min), counts[index]);\n+          ++index;\n+          return value_count;\n+        }\n+      }\n+      return std::make_pair<CType, int64_t>(0, -1);  // EOF\n     };\n \n-    // initialize min-heap with first n modes\n-    std::vector<ValueCountPair> vector(n);\n-    // push nan if exists\n-    const bool has_nan = is_floating_type<ArrowType>::value && this->nan_count > 0;\n-    if (has_nan) {\n-      vector[0] = std::make_pair(static_cast<CType>(NAN), this->nan_count);\n-    }\n-    // push n or n-1 modes\n-    auto it = this->value_counts.cbegin();\n-    for (int i = has_nan; i < n; ++i) {\n-      vector[i] = *it++;\n-    }\n-    // turn to min-heap\n-    std::priority_queue<ValueCountPair, std::vector<ValueCountPair>, decltype(mode_gt)>\n-        min_heap(std::move(mode_gt), std::move(vector));\n-\n-    // iterate and insert modes into min-heap\n-    // - mode < heap top: ignore mode\n-    // - mode > heap top: discard heap top, insert mode\n-    for (; it != this->value_counts.cend(); ++it) {\n-      if (mode_gt(*it, min_heap.top())) {\n-        min_heap.pop();\n-        min_heap.push(*it);\n-      }\n+    Finalize<T>(ctx, out, std::move(gen));\n+  }\n+};\n+\n+// booleans can be handled more straightforward\n+template <>\n+struct CountModer<BooleanType> {\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    int64_t counts[2]{};\n+\n+    const Datum& datum = batch[0];\n+    for (const auto& array : datum.chunks()) {\n+      if (array->length() > array->null_count()) {\n+        const int64_t true_count =\n+            checked_pointer_cast<BooleanArray>(array)->true_count();\n+        const int64_t false_count = array->length() - array->null_count() - true_count;\n+        counts[true] += true_count;\n+        counts[false] += false_count;\n+      };\n     }\n \n-    // pop modes from min-heap and insert into output array (in reverse order)\n-    DCHECK_EQ(min_heap.size(), static_cast<size_t>(n));\n-    for (int64_t i = n - 1; i >= 0; --i) {\n-      std::tie(modes[i], counts[i]) = min_heap.top();\n-      min_heap.pop();\n+    const ModeOptions& options = ModeState::Get(ctx);\n+    const int64_t distinct_values = (counts[0] != 0) + (counts[1] != 0);\n+    const int64_t n = std::min(options.n, distinct_values);\n+\n+    bool* mode_buffer;\n+    int64_t* count_buffer;\n+    KERNEL_ASSIGN_OR_RAISE(std::tie(mode_buffer, count_buffer), ctx,\n+                           PrepareOutput<BooleanType>(n, ctx, out));\n+\n+    if (n >= 1) {\n+      const bool index = counts[1] > counts[0];\n+      mode_buffer[0] = index;\n+      count_buffer[0] = counts[index];\n+      if (n == 2) {\n+        mode_buffer[1] = !index;\n+        count_buffer[1] = counts[!index];\n+      }\n     }\n   }\n+};\n \n-  int64_t DistinctValues() const {\n-    return this->value_counts.size() +\n-           (is_floating_type<ArrowType>::value && this->nan_count > 0);\n-  }\n+// copy and sort approach for floating points or integers with wide value range\n+// O(n) space, O(nlogn) time\n+template <typename T>\n+struct SortModer {\n+  using CType = typename T::c_type;\n+  using Allocator = arrow::stl::allocator<CType>;\n \n-  int64_t nan_count = 0;  // only make sense to floating types\n-  CounterMap<CType> value_counts;\n-};\n+  int64_t nan_count = 0;\n \n-template <typename ArrowType>\n-struct ModeImpl : public ScalarAggregator {\n-  using ThisType = ModeImpl<ArrowType>;\n-  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n-  using CType = typename ArrowType::c_type;\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType, Allocator> in_buffer(Allocator(ctx->memory_pool()));\n \n-  ModeImpl(const std::shared_ptr<DataType>& out_type, const ModeOptions& options)\n-      : out_type(out_type), options(options) {}\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n \n-  void Consume(KernelContext*, const ExecBatch& batch) override {\n-    ArrayType array(batch[0].array());\n-    this->state.value_counts = CountValues(array, this->state.nan_count);\n-  }\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n \n-  void MergeFrom(KernelContext*, KernelState&& src) override {\n-    auto& other = checked_cast<ThisType&>(src);\n-    this->state.MergeFrom(std::move(other.state));\n-  }\n+      // drop nan\n+      if (is_floating_type<T>::value) {\n+        const auto& it = std::remove_if(in_buffer.begin(), in_buffer.end(),\n+                                        [](CType v) { return v != v; });\n+        this->nan_count = in_buffer.end() - it;\n+        in_buffer.resize(it - in_buffer.begin());\n+      }\n+    }\n \n-  static std::shared_ptr<ArrayData> MakeArrayData(\n-      const std::shared_ptr<DataType>& data_type, int64_t n) {\n-    auto data = ArrayData::Make(data_type, n, 0);\n-    data->buffers.resize(2);\n-    data->buffers[0] = nullptr;\n-    data->buffers[1] = nullptr;\n-    return data;\n+    // sort the input data to count same values\n+    std::sort(in_buffer.begin(), in_buffer.end());\n+\n+    // generator to emit next value:count pair\n+    auto it = in_buffer.cbegin();\n+    int64_t nan_count_copy = this->nan_count;\n+    auto gen = [&]() {\n+      if (ARROW_PREDICT_FALSE(it == in_buffer.cend())) {\n+        // handle NAN at last\n+        if (nan_count_copy > 0) {\n+          auto value_count = std::make_pair(static_cast<CType>(NAN), nan_count_copy);\n+          nan_count_copy = 0;\n+          return value_count;\n+        }\n+        return std::make_pair<CType, int64_t>(0, -1);  // EOF\n+      }\n+      // count same values\n+      const CType value = *it;\n+      int64_t count = 0;\n+      do {\n+        ++it;\n+        ++count;\n+      } while (it != in_buffer.cend() && *it == value);\n+      return std::make_pair(value, count);\n+    };\n+\n+    Finalize<T>(ctx, out, std::move(gen));\n   }\n \n-  void Finalize(KernelContext* ctx, Datum* out) override {\n-    const auto& mode_type = TypeTraits<ArrowType>::type_singleton();\n-    const auto& count_type = int64();\n-    const auto& out_type =\n-        struct_({field(kModeFieldName, mode_type), field(kCountFieldName, count_type)});\n-\n-    int64_t n = this->options.n;\n-    if (n > state.DistinctValues()) {\n-      n = state.DistinctValues();\n-    } else if (n < 0) {\n-      n = 0;\n+  static int64_t CopyArray(CType* buffer, const Array& array) {\n+    const int64_t n = array.length() - array.null_count();\n+    if (n > 0) {\n+      int64_t index = 0;\n+      const ArrayData& data = *array.data();\n+      const CType* values = data.GetValues<CType>(1);\n+      VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                          [&](int64_t pos, int64_t len) {\n+                            memcpy(buffer + index, values + pos, len * sizeof(CType));\n+                            index += len;\n+                          });\n+      DCHECK_EQ(index, n);\n     }\n+    return n;\n+  }\n+};\n \n-    auto mode_data = this->MakeArrayData(mode_type, n);\n-    auto count_data = this->MakeArrayData(count_type, n);\n-    if (n > 0) {\n-      KERNEL_ASSIGN_OR_RAISE(mode_data->buffers[1], ctx,\n-                             ctx->Allocate(n * sizeof(CType)));\n-      KERNEL_ASSIGN_OR_RAISE(count_data->buffers[1], ctx,\n-                             ctx->Allocate(n * sizeof(int64_t)));\n-      CType* mode_buffer = mode_data->template GetMutableValues<CType>(1);\n-      int64_t* count_buffer = count_data->template GetMutableValues<int64_t>(1);\n-      this->state.Finalize(mode_buffer, count_buffer, n);\n+// pick counting or sorting approach per integers value range\n+template <typename T>\n+struct CountOrSortModer {\n+  using CType = typename T::c_type;\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // cross point to benefit from counting approach\n+    // about 2x improvement for int32/64 from micro-benchmarking\n+    static constexpr int kMinArraySize = 8192;\n+    static constexpr int kMaxValueRange = 32768;\n+\n+    const Datum& datum = batch[0];\n+    if (datum.length() - datum.null_count() >= kMinArraySize) {\n+      CType min = std::numeric_limits<CType>::max();\n+      CType max = std::numeric_limits<CType>::min();\n+\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                min = std::min(min, values[pos + i]);\n+                                max = std::max(max, values[pos + i]);\n+                              }\n+                            });\n+      }\n+\n+      if (static_cast<uint64_t>(max) - static_cast<uint64_t>(min) <= kMaxValueRange) {\n+        CountModer<T>(min, max).Exec(ctx, batch, out);\n+        return;\n+      }\n     }\n \n-    *out = Datum(ArrayData::Make(out_type, n, {nullptr}, {mode_data, count_data}, 0));\n+    SortModer<T>().Exec(ctx, batch, out);\n   }\n+};\n \n-  std::shared_ptr<DataType> out_type;\n-  ModeState<ArrowType> state;\n-  ModeOptions options;\n+template <typename InType, typename Enable = void>\n+struct Moder;\n+\n+template <>\n+struct Moder<Int8Type> {\n+  CountModer<Int8Type> impl;\n+  Moder() : impl(-128, 127) {}\n };\n \n-struct ModeInitState {\n-  std::unique_ptr<KernelState> state;\n-  KernelContext* ctx;\n-  const DataType& in_type;\n-  const std::shared_ptr<DataType>& out_type;\n-  const ModeOptions& options;\n+template <>\n+struct Moder<UInt8Type> {\n+  CountModer<UInt8Type> impl;\n+  Moder() : impl(0, 255) {}\n+};\n \n-  ModeInitState(KernelContext* ctx, const DataType& in_type,\n-                const std::shared_ptr<DataType>& out_type, const ModeOptions& options)\n-      : ctx(ctx), in_type(in_type), out_type(out_type), options(options) {}\n+template <>\n+struct Moder<BooleanType> {\n+  CountModer<BooleanType> impl;\n+};\n \n-  Status Visit(const DataType&) { return Status::NotImplemented(\"No mode implemented\"); }\n+template <typename InType>\n+struct Moder<InType, enable_if_t<(is_integer_type<InType>::value &&\n+                                  (sizeof(typename InType::c_type) > 1))>> {\n+  CountOrSortModer<InType> impl;\n+};\n \n-  Status Visit(const HalfFloatType&) {\n-    return Status::NotImplemented(\"No mode implemented\");\n-  }\n+template <typename InType>\n+struct Moder<InType, enable_if_t<is_floating_type<InType>::value>> {\n+  SortModer<InType> impl;\n+};\n \n-  template <typename Type>\n-  enable_if_t<is_number_type<Type>::value || is_boolean_type<Type>::value, Status> Visit(\n-      const Type&) {\n-    state.reset(new ModeImpl<Type>(out_type, options));\n-    return Status::OK();\n-  }\n+template <typename _, typename InType>\n+struct ModeExecutor {\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    if (ctx->state() == nullptr) {\n+      ctx->SetStatus(Status::Invalid(\"Mode requires ModeOptions\"));\n+      return;\n+    }\n+    const ModeOptions& options = ModeState::Get(ctx);\n+    if (options.n <= 0) {\n+      ctx->SetStatus(Status::Invalid(\"ModeOption::n must be positive\"));\n\nReview comment:\n       Done\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T02:18:49.580+0000",
                    "updated": "2021-04-14T02:18:49.580+0000",
                    "started": "2021-04-14T02:18:49.580+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582155",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/582208",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#discussion_r612950895\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_mode.cc\n##########\n@@ -31,340 +33,359 @@ namespace internal {\n \n namespace {\n \n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using ModeState = OptionsWrapper<ModeOptions>;\n+\n constexpr char kModeFieldName[] = \"mode\";\n constexpr char kCountFieldName[] = \"count\";\n \n-// {value:count} map\n-template <typename CType>\n-using CounterMap = std::unordered_map<CType, int64_t>;\n-\n-// map based counter for floating points\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<std::is_floating_point<CType>::value, CounterMap<CType>> CountValuesByMap(\n-    const ArrayType& array, int64_t& nan_count) {\n-  CounterMap<CType> value_counts_map;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  nan_count = 0;\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             const auto value = values[pos + i];\n-                                             if (std::isnan(value)) {\n-                                               ++nan_count;\n-                                             } else {\n-                                               ++value_counts_map[value];\n-                                             }\n-                                           }\n-                                         });\n+template <typename InType, typename CType = typename InType::c_type>\n+Result<std::pair<CType*, int64_t*>> PrepareOutput(int64_t n, KernelContext* ctx,\n+                                                  Datum* out) {\n+  const auto& mode_type = TypeTraits<InType>::type_singleton();\n+  const auto& count_type = int64();\n+\n+  auto mode_data = ArrayData::Make(mode_type, /*length=*/n, /*null_count=*/0);\n+  mode_data->buffers.resize(2, nullptr);\n+  auto count_data = ArrayData::Make(count_type, n, 0);\n+  count_data->buffers.resize(2, nullptr);\n+\n+  CType* mode_buffer = nullptr;\n+  int64_t* count_buffer = nullptr;\n+\n+  if (n > 0) {\n+    ARROW_ASSIGN_OR_RAISE(mode_data->buffers[1], ctx->Allocate(n * sizeof(CType)));\n+    ARROW_ASSIGN_OR_RAISE(count_data->buffers[1], ctx->Allocate(n * sizeof(int64_t)));\n+    mode_buffer = mode_data->template GetMutableValues<CType>(1);\n+    count_buffer = count_data->template GetMutableValues<int64_t>(1);\n   }\n \n-  return value_counts_map;\n-}\n-\n-// map base counter for non floating points\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<!std::is_floating_point<CType>::value, CounterMap<CType>> CountValuesByMap(\n-    const ArrayType& array) {\n-  CounterMap<CType> value_counts_map;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             ++value_counts_map[values[pos + i]];\n-                                           }\n-                                         });\n-  }\n+  const auto& out_type =\n+      struct_({field(kModeFieldName, mode_type), field(kCountFieldName, count_type)});\n+  *out = Datum(ArrayData::Make(out_type, n, {nullptr}, {mode_data, count_data}, 0));\n \n-  return value_counts_map;\n+  return std::make_pair(mode_buffer, count_buffer);\n }\n \n-// vector based counter for int8 or integers with small value range\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-CounterMap<CType> CountValuesByVector(const ArrayType& array, CType min, CType max) {\n-  const int range = static_cast<int>(max - min);\n-  DCHECK(range >= 0 && range < 64 * 1024 * 1024);\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  std::vector<int64_t> value_counts_vector(range + 1);\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             ++value_counts_vector[values[pos + i] - min];\n-                                           }\n-                                         });\n-  }\n-\n-  // Transfer value counts to a map to be consistent with other chunks\n-  CounterMap<CType> value_counts_map(range + 1);\n-  for (int i = 0; i <= range; ++i) {\n-    CType value = static_cast<CType>(i + min);\n-    int64_t count = value_counts_vector[i];\n-    if (count) {\n-      value_counts_map[value] = count;\n+// find top-n value:count pairs with minimal heap\n+// suboptimal for tiny or large n, possibly okay as we're not in hot path\n+template <typename InType, typename Generator>\n+void Finalize(KernelContext* ctx, Datum* out, Generator&& gen) {\n+  using CType = typename InType::c_type;\n+\n+  using ValueCountPair = std::pair<CType, int64_t>;\n+  auto gt = [](const ValueCountPair& lhs, const ValueCountPair& rhs) {\n+    const bool rhs_is_nan = rhs.first != rhs.first;  // nan as largest value\n+    return lhs.second > rhs.second ||\n+           (lhs.second == rhs.second && (lhs.first < rhs.first || rhs_is_nan));\n+  };\n+\n+  std::priority_queue<ValueCountPair, std::vector<ValueCountPair>, decltype(gt)> min_heap(\n+      std::move(gt));\n+\n+  const ModeOptions& options = ModeState::Get(ctx);\n+  while (true) {\n+    const ValueCountPair& value_count = gen();\n+    DCHECK_NE(value_count.second, 0);\n+    if (value_count.second < 0) break;  // EOF reached\n+    if (static_cast<int64_t>(min_heap.size()) < options.n) {\n+      min_heap.push(value_count);\n+    } else if (gt(value_count, min_heap.top())) {\n+      min_heap.pop();\n+      min_heap.push(value_count);\n     }\n   }\n+  const int64_t n = min_heap.size();\n \n-  return value_counts_map;\n-}\n-\n-// map or vector based counter for int16/32/64 per value range\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-CounterMap<CType> CountValuesByMapOrVector(const ArrayType& array) {\n-  // see https://issues.apache.org/jira/browse/ARROW-9873\n-  static constexpr int kMinArraySize = 8192 / sizeof(CType);\n-  static constexpr int kMaxValueRange = 16384;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  if ((array.length() - array.null_count()) >= kMinArraySize) {\n-    CType min = std::numeric_limits<CType>::max();\n-    CType max = std::numeric_limits<CType>::min();\n-\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             const auto value = values[pos + i];\n-                                             min = std::min(min, value);\n-                                             max = std::max(max, value);\n-                                           }\n-                                         });\n-\n-    if (static_cast<uint64_t>(max) - static_cast<uint64_t>(min) <= kMaxValueRange) {\n-      return CountValuesByVector(array, min, max);\n-    }\n-  }\n-  return CountValuesByMap(array);\n-}\n+  CType* mode_buffer;\n+  int64_t* count_buffer;\n+  KERNEL_ASSIGN_OR_RAISE(std::tie(mode_buffer, count_buffer), ctx,\n+                         PrepareOutput<InType>(n, ctx, out));\n \n-// bool\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_boolean_type<typename ArrayType::TypeClass>::value, CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  // we need just count ones and zeros\n-  CounterMap<CType> map;\n-  if (array.length() > array.null_count()) {\n-    map[true] = array.true_count();\n-    map[false] = array.length() - array.null_count() - map[true];\n+  for (int64_t i = n - 1; i >= 0; --i) {\n+    std::tie(mode_buffer[i], count_buffer[i]) = min_heap.top();\n+    min_heap.pop();\n   }\n-  nan_count = 0;\n-  return map;\n }\n \n-// int8\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_integer_type<typename ArrayType::TypeClass>::value && sizeof(CType) == 1,\n-            CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  using Limits = std::numeric_limits<CType>;\n-  nan_count = 0;\n-  return CountValuesByVector(array, Limits::min(), Limits::max());\n-}\n+// count value occurances for integers with narrow value range\n+// O(1) space, O(n) time\n+template <typename T>\n+struct CountModer {\n+  using CType = typename T::c_type;\n \n-// int16/32/64\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_integer_type<typename ArrayType::TypeClass>::value && (sizeof(CType) > 1),\n-            CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  nan_count = 0;\n-  return CountValuesByMapOrVector(array);\n-}\n+  CType min;\n+  std::vector<int64_t> counts;\n \n-// float/double\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<(std::is_floating_point<CType>::value), CounterMap<CType>>  // NOLINT format\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  nan_count = 0;\n-  return CountValuesByMap(array, nan_count);\n-}\n+  CountModer(CType min, CType max) {\n+    uint32_t value_range = static_cast<uint32_t>(max - min) + 1;\n+    DCHECK_LT(value_range, 1 << 20);\n+    this->min = min;\n+    this->counts.resize(value_range, 0);\n+  }\n \n-template <typename ArrowType>\n-struct ModeState {\n-  using ThisType = ModeState<ArrowType>;\n-  using CType = typename ArrowType::c_type;\n-\n-  void MergeFrom(ThisType&& state) {\n-    if (this->value_counts.empty()) {\n-      this->value_counts = std::move(state.value_counts);\n-    } else {\n-      for (const auto& value_count : state.value_counts) {\n-        auto value = value_count.first;\n-        auto count = value_count.second;\n-        this->value_counts[value] += count;\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // count values in all chunks, ignore nulls\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                ++this->counts[values[pos + i] - this->min];\n+                              }\n+                            });\n       }\n     }\n-    if (is_floating_type<ArrowType>::value) {\n-      this->nan_count += state.nan_count;\n-    }\n-  }\n-\n-  // find top-n value/count pairs with min-heap (priority queue with '>' comparator)\n-  void Finalize(CType* modes, int64_t* counts, const int64_t n) {\n-    DCHECK(n >= 1 && n <= this->DistinctValues());\n \n-    // mode 'greater than' comparator: larger count or same count with smaller value\n-    using ValueCountPair = std::pair<CType, int64_t>;\n-    auto mode_gt = [](const ValueCountPair& lhs, const ValueCountPair& rhs) {\n-      const bool rhs_is_nan = rhs.first != rhs.first;  // nan as largest value\n-      return lhs.second > rhs.second ||\n-             (lhs.second == rhs.second && (lhs.first < rhs.first || rhs_is_nan));\n+    // generator to emit next value:count pair\n+    int index = 0;\n+    auto gen = [&]() {\n+      for (; index < static_cast<int>(counts.size()); ++index) {\n+        if (counts[index] != 0) {\n+          auto value_count =\n+              std::make_pair(static_cast<CType>(index + this->min), counts[index]);\n+          ++index;\n+          return value_count;\n+        }\n+      }\n+      return std::make_pair<CType, int64_t>(0, -1);  // EOF\n     };\n \n-    // initialize min-heap with first n modes\n-    std::vector<ValueCountPair> vector(n);\n-    // push nan if exists\n-    const bool has_nan = is_floating_type<ArrowType>::value && this->nan_count > 0;\n-    if (has_nan) {\n-      vector[0] = std::make_pair(static_cast<CType>(NAN), this->nan_count);\n-    }\n-    // push n or n-1 modes\n-    auto it = this->value_counts.cbegin();\n-    for (int i = has_nan; i < n; ++i) {\n-      vector[i] = *it++;\n-    }\n-    // turn to min-heap\n-    std::priority_queue<ValueCountPair, std::vector<ValueCountPair>, decltype(mode_gt)>\n-        min_heap(std::move(mode_gt), std::move(vector));\n-\n-    // iterate and insert modes into min-heap\n-    // - mode < heap top: ignore mode\n-    // - mode > heap top: discard heap top, insert mode\n-    for (; it != this->value_counts.cend(); ++it) {\n-      if (mode_gt(*it, min_heap.top())) {\n-        min_heap.pop();\n-        min_heap.push(*it);\n-      }\n+    Finalize<T>(ctx, out, std::move(gen));\n+  }\n+};\n+\n+// booleans can be handled more straightforward\n+template <>\n+struct CountModer<BooleanType> {\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    int64_t counts[2]{};\n+\n+    const Datum& datum = batch[0];\n+    for (const auto& array : datum.chunks()) {\n+      if (array->length() > array->null_count()) {\n+        const int64_t true_count =\n+            checked_pointer_cast<BooleanArray>(array)->true_count();\n+        const int64_t false_count = array->length() - array->null_count() - true_count;\n+        counts[true] += true_count;\n+        counts[false] += false_count;\n+      };\n     }\n \n-    // pop modes from min-heap and insert into output array (in reverse order)\n-    DCHECK_EQ(min_heap.size(), static_cast<size_t>(n));\n-    for (int64_t i = n - 1; i >= 0; --i) {\n-      std::tie(modes[i], counts[i]) = min_heap.top();\n-      min_heap.pop();\n+    const ModeOptions& options = ModeState::Get(ctx);\n+    const int64_t distinct_values = (counts[0] != 0) + (counts[1] != 0);\n+    const int64_t n = std::min(options.n, distinct_values);\n+\n+    bool* mode_buffer;\n+    int64_t* count_buffer;\n+    KERNEL_ASSIGN_OR_RAISE(std::tie(mode_buffer, count_buffer), ctx,\n+                           PrepareOutput<BooleanType>(n, ctx, out));\n+\n+    if (n >= 1) {\n+      const bool index = counts[1] > counts[0];\n+      mode_buffer[0] = index;\n+      count_buffer[0] = counts[index];\n+      if (n == 2) {\n+        mode_buffer[1] = !index;\n+        count_buffer[1] = counts[!index];\n+      }\n     }\n   }\n+};\n \n-  int64_t DistinctValues() const {\n-    return this->value_counts.size() +\n-           (is_floating_type<ArrowType>::value && this->nan_count > 0);\n-  }\n+// copy and sort approach for floating points or integers with wide value range\n+// O(n) space, O(nlogn) time\n+template <typename T>\n+struct SortModer {\n+  using CType = typename T::c_type;\n+  using Allocator = arrow::stl::allocator<CType>;\n \n-  int64_t nan_count = 0;  // only make sense to floating types\n-  CounterMap<CType> value_counts;\n-};\n+  int64_t nan_count = 0;\n \n-template <typename ArrowType>\n-struct ModeImpl : public ScalarAggregator {\n-  using ThisType = ModeImpl<ArrowType>;\n-  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n-  using CType = typename ArrowType::c_type;\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType, Allocator> in_buffer(Allocator(ctx->memory_pool()));\n \n-  ModeImpl(const std::shared_ptr<DataType>& out_type, const ModeOptions& options)\n-      : out_type(out_type), options(options) {}\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n \n-  void Consume(KernelContext*, const ExecBatch& batch) override {\n-    ArrayType array(batch[0].array());\n-    this->state.value_counts = CountValues(array, this->state.nan_count);\n-  }\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n \n-  void MergeFrom(KernelContext*, KernelState&& src) override {\n-    auto& other = checked_cast<ThisType&>(src);\n-    this->state.MergeFrom(std::move(other.state));\n-  }\n+      // drop nan\n+      if (is_floating_type<T>::value) {\n+        const auto& it = std::remove_if(in_buffer.begin(), in_buffer.end(),\n+                                        [](CType v) { return v != v; });\n+        this->nan_count = in_buffer.end() - it;\n+        in_buffer.resize(it - in_buffer.begin());\n+      }\n+    }\n \n-  static std::shared_ptr<ArrayData> MakeArrayData(\n-      const std::shared_ptr<DataType>& data_type, int64_t n) {\n-    auto data = ArrayData::Make(data_type, n, 0);\n-    data->buffers.resize(2);\n-    data->buffers[0] = nullptr;\n-    data->buffers[1] = nullptr;\n-    return data;\n+    // sort the input data to count same values\n+    std::sort(in_buffer.begin(), in_buffer.end());\n+\n+    // generator to emit next value:count pair\n+    auto it = in_buffer.cbegin();\n+    int64_t nan_count_copy = this->nan_count;\n+    auto gen = [&]() {\n+      if (ARROW_PREDICT_FALSE(it == in_buffer.cend())) {\n+        // handle NAN at last\n+        if (nan_count_copy > 0) {\n+          auto value_count = std::make_pair(static_cast<CType>(NAN), nan_count_copy);\n+          nan_count_copy = 0;\n+          return value_count;\n+        }\n+        return std::make_pair<CType, int64_t>(0, -1);  // EOF\n+      }\n+      // count same values\n+      const CType value = *it;\n+      int64_t count = 0;\n+      do {\n+        ++it;\n+        ++count;\n+      } while (it != in_buffer.cend() && *it == value);\n+      return std::make_pair(value, count);\n+    };\n+\n+    Finalize<T>(ctx, out, std::move(gen));\n   }\n \n-  void Finalize(KernelContext* ctx, Datum* out) override {\n-    const auto& mode_type = TypeTraits<ArrowType>::type_singleton();\n-    const auto& count_type = int64();\n-    const auto& out_type =\n-        struct_({field(kModeFieldName, mode_type), field(kCountFieldName, count_type)});\n-\n-    int64_t n = this->options.n;\n-    if (n > state.DistinctValues()) {\n-      n = state.DistinctValues();\n-    } else if (n < 0) {\n-      n = 0;\n+  static int64_t CopyArray(CType* buffer, const Array& array) {\n+    const int64_t n = array.length() - array.null_count();\n+    if (n > 0) {\n+      int64_t index = 0;\n+      const ArrayData& data = *array.data();\n+      const CType* values = data.GetValues<CType>(1);\n+      VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                          [&](int64_t pos, int64_t len) {\n+                            memcpy(buffer + index, values + pos, len * sizeof(CType));\n+                            index += len;\n+                          });\n+      DCHECK_EQ(index, n);\n     }\n+    return n;\n+  }\n+};\n \n-    auto mode_data = this->MakeArrayData(mode_type, n);\n-    auto count_data = this->MakeArrayData(count_type, n);\n-    if (n > 0) {\n-      KERNEL_ASSIGN_OR_RAISE(mode_data->buffers[1], ctx,\n-                             ctx->Allocate(n * sizeof(CType)));\n-      KERNEL_ASSIGN_OR_RAISE(count_data->buffers[1], ctx,\n-                             ctx->Allocate(n * sizeof(int64_t)));\n-      CType* mode_buffer = mode_data->template GetMutableValues<CType>(1);\n-      int64_t* count_buffer = count_data->template GetMutableValues<int64_t>(1);\n-      this->state.Finalize(mode_buffer, count_buffer, n);\n+// pick counting or sorting approach per integers value range\n+template <typename T>\n+struct CountOrSortModer {\n+  using CType = typename T::c_type;\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // cross point to benefit from counting approach\n+    // about 2x improvement for int32/64 from micro-benchmarking\n+    static constexpr int kMinArraySize = 8192;\n+    static constexpr int kMaxValueRange = 32768;\n+\n+    const Datum& datum = batch[0];\n+    if (datum.length() - datum.null_count() >= kMinArraySize) {\n+      CType min = std::numeric_limits<CType>::max();\n+      CType max = std::numeric_limits<CType>::min();\n+\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                min = std::min(min, values[pos + i]);\n+                                max = std::max(max, values[pos + i]);\n+                              }\n+                            });\n\nReview comment:\n       Will do.\r\n   Quantile and Mode kernels share many common code. Will also factor.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T05:41:41.006+0000",
                    "updated": "2021-04-14T05:41:41.006+0000",
                    "started": "2021-04-14T05:41:41.006+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582208",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/583097",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#discussion_r613724252\n\n\n\n##########\nFile path: cpp/src/arrow/util/bit_run_reader.h\n##########\n@@ -480,8 +480,8 @@ Status VisitSetBitRuns(const uint8_t* bitmap, int64_t offset, int64_t length,\n }\n \n template <typename Visit>\n-void VisitSetBitRunsVoid(const uint8_t* bitmap, int64_t offset, int64_t length,\n-                         Visit&& visit) {\n+inline void VisitSetBitRunsVoid(const uint8_t* bitmap, int64_t offset, int64_t length,\n\nReview comment:\n       Add `inline` hint.\r\n   If the caller is from a cpp source, compiler is willing to inline. But if the caller is from a header file, compiler prefers non-inline, though in reality it doesn't increase binary size compared with called from source. Non-inline causes big perf drop as the visitor becomes a function call and cannot be optimized together with the loop.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-15T03:01:32.852+0000",
                    "updated": "2021-04-15T03:01:32.852+0000",
                    "started": "2021-04-15T03:01:32.852+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "583097",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/583098",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#discussion_r613725348\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -492,16 +493,8 @@ class ArrayCountOrCompareSorter {\n   uint64_t* Sort(uint64_t* indices_begin, uint64_t* indices_end, const ArrayType& values,\n                  int64_t offset, const ArraySortOptions& options) {\n     if (values.length() >= countsort_min_len_ && values.length() > values.null_count()) {\n-      c_type min{std::numeric_limits<c_type>::max()};\n-      c_type max{std::numeric_limits<c_type>::min()};\n-\n-      VisitRawValuesInline(\n-          values,\n-          [&](c_type v) {\n-            min = std::min(min, v);\n-            max = std::max(max, v);\n-          },\n-          []() {});\n+      c_type min, max;\n+      std::tie(min, max) = GetMinMax<c_type>(*values.data());\n\nReview comment:\n       A bit performance improvement for int64narrow sorting.\r\n   ```\r\n                              benchmark            baseline           contender  change %\r\n    ArraySortIndicesInt64Narrow/32768/2     507.257 MiB/sec     632.995 MiB/sec    24.788\r\n   ArraySortIndicesInt64Narrow/32768/10     643.182 MiB/sec     724.483 MiB/sec    12.640\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-15T03:06:03.434+0000",
                    "updated": "2021-04-15T03:06:03.434+0000",
                    "started": "2021-04-15T03:06:03.433+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "583098",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/583103",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#discussion_r613727094\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/aggregate_mode.cc\n##########\n@@ -31,340 +33,359 @@ namespace internal {\n \n namespace {\n \n+using arrow::internal::checked_pointer_cast;\n+using arrow::internal::VisitSetBitRunsVoid;\n+\n+using ModeState = OptionsWrapper<ModeOptions>;\n+\n constexpr char kModeFieldName[] = \"mode\";\n constexpr char kCountFieldName[] = \"count\";\n \n-// {value:count} map\n-template <typename CType>\n-using CounterMap = std::unordered_map<CType, int64_t>;\n-\n-// map based counter for floating points\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<std::is_floating_point<CType>::value, CounterMap<CType>> CountValuesByMap(\n-    const ArrayType& array, int64_t& nan_count) {\n-  CounterMap<CType> value_counts_map;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  nan_count = 0;\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             const auto value = values[pos + i];\n-                                             if (std::isnan(value)) {\n-                                               ++nan_count;\n-                                             } else {\n-                                               ++value_counts_map[value];\n-                                             }\n-                                           }\n-                                         });\n+template <typename InType, typename CType = typename InType::c_type>\n+Result<std::pair<CType*, int64_t*>> PrepareOutput(int64_t n, KernelContext* ctx,\n+                                                  Datum* out) {\n+  const auto& mode_type = TypeTraits<InType>::type_singleton();\n+  const auto& count_type = int64();\n+\n+  auto mode_data = ArrayData::Make(mode_type, /*length=*/n, /*null_count=*/0);\n+  mode_data->buffers.resize(2, nullptr);\n+  auto count_data = ArrayData::Make(count_type, n, 0);\n+  count_data->buffers.resize(2, nullptr);\n+\n+  CType* mode_buffer = nullptr;\n+  int64_t* count_buffer = nullptr;\n+\n+  if (n > 0) {\n+    ARROW_ASSIGN_OR_RAISE(mode_data->buffers[1], ctx->Allocate(n * sizeof(CType)));\n+    ARROW_ASSIGN_OR_RAISE(count_data->buffers[1], ctx->Allocate(n * sizeof(int64_t)));\n+    mode_buffer = mode_data->template GetMutableValues<CType>(1);\n+    count_buffer = count_data->template GetMutableValues<int64_t>(1);\n   }\n \n-  return value_counts_map;\n-}\n-\n-// map base counter for non floating points\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<!std::is_floating_point<CType>::value, CounterMap<CType>> CountValuesByMap(\n-    const ArrayType& array) {\n-  CounterMap<CType> value_counts_map;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             ++value_counts_map[values[pos + i]];\n-                                           }\n-                                         });\n-  }\n+  const auto& out_type =\n+      struct_({field(kModeFieldName, mode_type), field(kCountFieldName, count_type)});\n+  *out = Datum(ArrayData::Make(out_type, n, {nullptr}, {mode_data, count_data}, 0));\n \n-  return value_counts_map;\n+  return std::make_pair(mode_buffer, count_buffer);\n }\n \n-// vector based counter for int8 or integers with small value range\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-CounterMap<CType> CountValuesByVector(const ArrayType& array, CType min, CType max) {\n-  const int range = static_cast<int>(max - min);\n-  DCHECK(range >= 0 && range < 64 * 1024 * 1024);\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  std::vector<int64_t> value_counts_vector(range + 1);\n-  if (array.length() > array.null_count()) {\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             ++value_counts_vector[values[pos + i] - min];\n-                                           }\n-                                         });\n-  }\n-\n-  // Transfer value counts to a map to be consistent with other chunks\n-  CounterMap<CType> value_counts_map(range + 1);\n-  for (int i = 0; i <= range; ++i) {\n-    CType value = static_cast<CType>(i + min);\n-    int64_t count = value_counts_vector[i];\n-    if (count) {\n-      value_counts_map[value] = count;\n+// find top-n value:count pairs with minimal heap\n+// suboptimal for tiny or large n, possibly okay as we're not in hot path\n+template <typename InType, typename Generator>\n+void Finalize(KernelContext* ctx, Datum* out, Generator&& gen) {\n+  using CType = typename InType::c_type;\n+\n+  using ValueCountPair = std::pair<CType, int64_t>;\n+  auto gt = [](const ValueCountPair& lhs, const ValueCountPair& rhs) {\n+    const bool rhs_is_nan = rhs.first != rhs.first;  // nan as largest value\n+    return lhs.second > rhs.second ||\n+           (lhs.second == rhs.second && (lhs.first < rhs.first || rhs_is_nan));\n+  };\n+\n+  std::priority_queue<ValueCountPair, std::vector<ValueCountPair>, decltype(gt)> min_heap(\n+      std::move(gt));\n+\n+  const ModeOptions& options = ModeState::Get(ctx);\n+  while (true) {\n+    const ValueCountPair& value_count = gen();\n+    DCHECK_NE(value_count.second, 0);\n+    if (value_count.second < 0) break;  // EOF reached\n+    if (static_cast<int64_t>(min_heap.size()) < options.n) {\n+      min_heap.push(value_count);\n+    } else if (gt(value_count, min_heap.top())) {\n+      min_heap.pop();\n+      min_heap.push(value_count);\n     }\n   }\n+  const int64_t n = min_heap.size();\n \n-  return value_counts_map;\n-}\n-\n-// map or vector based counter for int16/32/64 per value range\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-CounterMap<CType> CountValuesByMapOrVector(const ArrayType& array) {\n-  // see https://issues.apache.org/jira/browse/ARROW-9873\n-  static constexpr int kMinArraySize = 8192 / sizeof(CType);\n-  static constexpr int kMaxValueRange = 16384;\n-  const ArrayData& data = *array.data();\n-  const CType* values = data.GetValues<CType>(1);\n-\n-  if ((array.length() - array.null_count()) >= kMinArraySize) {\n-    CType min = std::numeric_limits<CType>::max();\n-    CType max = std::numeric_limits<CType>::min();\n-\n-    arrow::internal::VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n-                                         [&](int64_t pos, int64_t len) {\n-                                           for (int64_t i = 0; i < len; ++i) {\n-                                             const auto value = values[pos + i];\n-                                             min = std::min(min, value);\n-                                             max = std::max(max, value);\n-                                           }\n-                                         });\n-\n-    if (static_cast<uint64_t>(max) - static_cast<uint64_t>(min) <= kMaxValueRange) {\n-      return CountValuesByVector(array, min, max);\n-    }\n-  }\n-  return CountValuesByMap(array);\n-}\n+  CType* mode_buffer;\n+  int64_t* count_buffer;\n+  KERNEL_ASSIGN_OR_RAISE(std::tie(mode_buffer, count_buffer), ctx,\n+                         PrepareOutput<InType>(n, ctx, out));\n \n-// bool\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_boolean_type<typename ArrayType::TypeClass>::value, CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  // we need just count ones and zeros\n-  CounterMap<CType> map;\n-  if (array.length() > array.null_count()) {\n-    map[true] = array.true_count();\n-    map[false] = array.length() - array.null_count() - map[true];\n+  for (int64_t i = n - 1; i >= 0; --i) {\n+    std::tie(mode_buffer[i], count_buffer[i]) = min_heap.top();\n+    min_heap.pop();\n   }\n-  nan_count = 0;\n-  return map;\n }\n \n-// int8\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_integer_type<typename ArrayType::TypeClass>::value && sizeof(CType) == 1,\n-            CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  using Limits = std::numeric_limits<CType>;\n-  nan_count = 0;\n-  return CountValuesByVector(array, Limits::min(), Limits::max());\n-}\n+// count value occurances for integers with narrow value range\n+// O(1) space, O(n) time\n+template <typename T>\n+struct CountModer {\n+  using CType = typename T::c_type;\n \n-// int16/32/64\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<is_integer_type<typename ArrayType::TypeClass>::value && (sizeof(CType) > 1),\n-            CounterMap<CType>>\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  nan_count = 0;\n-  return CountValuesByMapOrVector(array);\n-}\n+  CType min;\n+  std::vector<int64_t> counts;\n \n-// float/double\n-template <typename ArrayType, typename CType = typename ArrayType::TypeClass::c_type>\n-enable_if_t<(std::is_floating_point<CType>::value), CounterMap<CType>>  // NOLINT format\n-CountValues(const ArrayType& array, int64_t& nan_count) {\n-  nan_count = 0;\n-  return CountValuesByMap(array, nan_count);\n-}\n+  CountModer(CType min, CType max) {\n+    uint32_t value_range = static_cast<uint32_t>(max - min) + 1;\n+    DCHECK_LT(value_range, 1 << 20);\n+    this->min = min;\n+    this->counts.resize(value_range, 0);\n+  }\n \n-template <typename ArrowType>\n-struct ModeState {\n-  using ThisType = ModeState<ArrowType>;\n-  using CType = typename ArrowType::c_type;\n-\n-  void MergeFrom(ThisType&& state) {\n-    if (this->value_counts.empty()) {\n-      this->value_counts = std::move(state.value_counts);\n-    } else {\n-      for (const auto& value_count : state.value_counts) {\n-        auto value = value_count.first;\n-        auto count = value_count.second;\n-        this->value_counts[value] += count;\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // count values in all chunks, ignore nulls\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                ++this->counts[values[pos + i] - this->min];\n+                              }\n+                            });\n       }\n     }\n-    if (is_floating_type<ArrowType>::value) {\n-      this->nan_count += state.nan_count;\n-    }\n-  }\n-\n-  // find top-n value/count pairs with min-heap (priority queue with '>' comparator)\n-  void Finalize(CType* modes, int64_t* counts, const int64_t n) {\n-    DCHECK(n >= 1 && n <= this->DistinctValues());\n \n-    // mode 'greater than' comparator: larger count or same count with smaller value\n-    using ValueCountPair = std::pair<CType, int64_t>;\n-    auto mode_gt = [](const ValueCountPair& lhs, const ValueCountPair& rhs) {\n-      const bool rhs_is_nan = rhs.first != rhs.first;  // nan as largest value\n-      return lhs.second > rhs.second ||\n-             (lhs.second == rhs.second && (lhs.first < rhs.first || rhs_is_nan));\n+    // generator to emit next value:count pair\n+    int index = 0;\n+    auto gen = [&]() {\n+      for (; index < static_cast<int>(counts.size()); ++index) {\n+        if (counts[index] != 0) {\n+          auto value_count =\n+              std::make_pair(static_cast<CType>(index + this->min), counts[index]);\n+          ++index;\n+          return value_count;\n+        }\n+      }\n+      return std::make_pair<CType, int64_t>(0, -1);  // EOF\n     };\n \n-    // initialize min-heap with first n modes\n-    std::vector<ValueCountPair> vector(n);\n-    // push nan if exists\n-    const bool has_nan = is_floating_type<ArrowType>::value && this->nan_count > 0;\n-    if (has_nan) {\n-      vector[0] = std::make_pair(static_cast<CType>(NAN), this->nan_count);\n-    }\n-    // push n or n-1 modes\n-    auto it = this->value_counts.cbegin();\n-    for (int i = has_nan; i < n; ++i) {\n-      vector[i] = *it++;\n-    }\n-    // turn to min-heap\n-    std::priority_queue<ValueCountPair, std::vector<ValueCountPair>, decltype(mode_gt)>\n-        min_heap(std::move(mode_gt), std::move(vector));\n-\n-    // iterate and insert modes into min-heap\n-    // - mode < heap top: ignore mode\n-    // - mode > heap top: discard heap top, insert mode\n-    for (; it != this->value_counts.cend(); ++it) {\n-      if (mode_gt(*it, min_heap.top())) {\n-        min_heap.pop();\n-        min_heap.push(*it);\n-      }\n+    Finalize<T>(ctx, out, std::move(gen));\n+  }\n+};\n+\n+// booleans can be handled more straightforward\n+template <>\n+struct CountModer<BooleanType> {\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    int64_t counts[2]{};\n+\n+    const Datum& datum = batch[0];\n+    for (const auto& array : datum.chunks()) {\n+      if (array->length() > array->null_count()) {\n+        const int64_t true_count =\n+            checked_pointer_cast<BooleanArray>(array)->true_count();\n+        const int64_t false_count = array->length() - array->null_count() - true_count;\n+        counts[true] += true_count;\n+        counts[false] += false_count;\n+      };\n     }\n \n-    // pop modes from min-heap and insert into output array (in reverse order)\n-    DCHECK_EQ(min_heap.size(), static_cast<size_t>(n));\n-    for (int64_t i = n - 1; i >= 0; --i) {\n-      std::tie(modes[i], counts[i]) = min_heap.top();\n-      min_heap.pop();\n+    const ModeOptions& options = ModeState::Get(ctx);\n+    const int64_t distinct_values = (counts[0] != 0) + (counts[1] != 0);\n+    const int64_t n = std::min(options.n, distinct_values);\n+\n+    bool* mode_buffer;\n+    int64_t* count_buffer;\n+    KERNEL_ASSIGN_OR_RAISE(std::tie(mode_buffer, count_buffer), ctx,\n+                           PrepareOutput<BooleanType>(n, ctx, out));\n+\n+    if (n >= 1) {\n+      const bool index = counts[1] > counts[0];\n+      mode_buffer[0] = index;\n+      count_buffer[0] = counts[index];\n+      if (n == 2) {\n+        mode_buffer[1] = !index;\n+        count_buffer[1] = counts[!index];\n+      }\n     }\n   }\n+};\n \n-  int64_t DistinctValues() const {\n-    return this->value_counts.size() +\n-           (is_floating_type<ArrowType>::value && this->nan_count > 0);\n-  }\n+// copy and sort approach for floating points or integers with wide value range\n+// O(n) space, O(nlogn) time\n+template <typename T>\n+struct SortModer {\n+  using CType = typename T::c_type;\n+  using Allocator = arrow::stl::allocator<CType>;\n \n-  int64_t nan_count = 0;  // only make sense to floating types\n-  CounterMap<CType> value_counts;\n-};\n+  int64_t nan_count = 0;\n \n-template <typename ArrowType>\n-struct ModeImpl : public ScalarAggregator {\n-  using ThisType = ModeImpl<ArrowType>;\n-  using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n-  using CType = typename ArrowType::c_type;\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // copy all chunks to a buffer, ignore nulls and nans\n+    std::vector<CType, Allocator> in_buffer(Allocator(ctx->memory_pool()));\n \n-  ModeImpl(const std::shared_ptr<DataType>& out_type, const ModeOptions& options)\n-      : out_type(out_type), options(options) {}\n+    const Datum& datum = batch[0];\n+    const int64_t in_length = datum.length() - datum.null_count();\n+    if (in_length > 0) {\n+      in_buffer.resize(in_length);\n \n-  void Consume(KernelContext*, const ExecBatch& batch) override {\n-    ArrayType array(batch[0].array());\n-    this->state.value_counts = CountValues(array, this->state.nan_count);\n-  }\n+      int64_t index = 0;\n+      for (const auto& array : datum.chunks()) {\n+        index += CopyArray(in_buffer.data() + index, *array);\n+      }\n \n-  void MergeFrom(KernelContext*, KernelState&& src) override {\n-    auto& other = checked_cast<ThisType&>(src);\n-    this->state.MergeFrom(std::move(other.state));\n-  }\n+      // drop nan\n+      if (is_floating_type<T>::value) {\n+        const auto& it = std::remove_if(in_buffer.begin(), in_buffer.end(),\n+                                        [](CType v) { return v != v; });\n+        this->nan_count = in_buffer.end() - it;\n+        in_buffer.resize(it - in_buffer.begin());\n+      }\n+    }\n \n-  static std::shared_ptr<ArrayData> MakeArrayData(\n-      const std::shared_ptr<DataType>& data_type, int64_t n) {\n-    auto data = ArrayData::Make(data_type, n, 0);\n-    data->buffers.resize(2);\n-    data->buffers[0] = nullptr;\n-    data->buffers[1] = nullptr;\n-    return data;\n+    // sort the input data to count same values\n+    std::sort(in_buffer.begin(), in_buffer.end());\n+\n+    // generator to emit next value:count pair\n+    auto it = in_buffer.cbegin();\n+    int64_t nan_count_copy = this->nan_count;\n+    auto gen = [&]() {\n+      if (ARROW_PREDICT_FALSE(it == in_buffer.cend())) {\n+        // handle NAN at last\n+        if (nan_count_copy > 0) {\n+          auto value_count = std::make_pair(static_cast<CType>(NAN), nan_count_copy);\n+          nan_count_copy = 0;\n+          return value_count;\n+        }\n+        return std::make_pair<CType, int64_t>(0, -1);  // EOF\n+      }\n+      // count same values\n+      const CType value = *it;\n+      int64_t count = 0;\n+      do {\n+        ++it;\n+        ++count;\n+      } while (it != in_buffer.cend() && *it == value);\n+      return std::make_pair(value, count);\n+    };\n+\n+    Finalize<T>(ctx, out, std::move(gen));\n   }\n \n-  void Finalize(KernelContext* ctx, Datum* out) override {\n-    const auto& mode_type = TypeTraits<ArrowType>::type_singleton();\n-    const auto& count_type = int64();\n-    const auto& out_type =\n-        struct_({field(kModeFieldName, mode_type), field(kCountFieldName, count_type)});\n-\n-    int64_t n = this->options.n;\n-    if (n > state.DistinctValues()) {\n-      n = state.DistinctValues();\n-    } else if (n < 0) {\n-      n = 0;\n+  static int64_t CopyArray(CType* buffer, const Array& array) {\n+    const int64_t n = array.length() - array.null_count();\n+    if (n > 0) {\n+      int64_t index = 0;\n+      const ArrayData& data = *array.data();\n+      const CType* values = data.GetValues<CType>(1);\n+      VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                          [&](int64_t pos, int64_t len) {\n+                            memcpy(buffer + index, values + pos, len * sizeof(CType));\n+                            index += len;\n+                          });\n+      DCHECK_EQ(index, n);\n     }\n+    return n;\n+  }\n+};\n \n-    auto mode_data = this->MakeArrayData(mode_type, n);\n-    auto count_data = this->MakeArrayData(count_type, n);\n-    if (n > 0) {\n-      KERNEL_ASSIGN_OR_RAISE(mode_data->buffers[1], ctx,\n-                             ctx->Allocate(n * sizeof(CType)));\n-      KERNEL_ASSIGN_OR_RAISE(count_data->buffers[1], ctx,\n-                             ctx->Allocate(n * sizeof(int64_t)));\n-      CType* mode_buffer = mode_data->template GetMutableValues<CType>(1);\n-      int64_t* count_buffer = count_data->template GetMutableValues<int64_t>(1);\n-      this->state.Finalize(mode_buffer, count_buffer, n);\n+// pick counting or sorting approach per integers value range\n+template <typename T>\n+struct CountOrSortModer {\n+  using CType = typename T::c_type;\n+\n+  void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // cross point to benefit from counting approach\n+    // about 2x improvement for int32/64 from micro-benchmarking\n+    static constexpr int kMinArraySize = 8192;\n+    static constexpr int kMaxValueRange = 32768;\n+\n+    const Datum& datum = batch[0];\n+    if (datum.length() - datum.null_count() >= kMinArraySize) {\n+      CType min = std::numeric_limits<CType>::max();\n+      CType max = std::numeric_limits<CType>::min();\n+\n+      for (const auto& array : datum.chunks()) {\n+        const ArrayData& data = *array->data();\n+        const CType* values = data.GetValues<CType>(1);\n+        VisitSetBitRunsVoid(data.buffers[0], data.offset, data.length,\n+                            [&](int64_t pos, int64_t len) {\n+                              for (int64_t i = 0; i < len; ++i) {\n+                                min = std::min(min, values[pos + i]);\n+                                max = std::max(max, values[pos + i]);\n+                              }\n+                            });\n\nReview comment:\n       Done\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-15T03:12:15.856+0000",
                    "updated": "2021-04-15T03:12:15.856+0000",
                    "started": "2021-04-15T03:12:15.856+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "583103",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/583129",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#discussion_r613725348\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/vector_sort.cc\n##########\n@@ -492,16 +493,8 @@ class ArrayCountOrCompareSorter {\n   uint64_t* Sort(uint64_t* indices_begin, uint64_t* indices_end, const ArrayType& values,\n                  int64_t offset, const ArraySortOptions& options) {\n     if (values.length() >= countsort_min_len_ && values.length() > values.null_count()) {\n-      c_type min{std::numeric_limits<c_type>::max()};\n-      c_type max{std::numeric_limits<c_type>::min()};\n-\n-      VisitRawValuesInline(\n-          values,\n-          [&](c_type v) {\n-            min = std::min(min, v);\n-            max = std::max(max, v);\n-          },\n-          []() {});\n+      c_type min, max;\n+      std::tie(min, max) = GetMinMax<c_type>(*values.data());\n\nReview comment:\n       Small performance improvement for int64narrow sorting.\r\n   ```\r\n                              benchmark            baseline           contender  change %\r\n    ArraySortIndicesInt64Narrow/32768/2     507.257 MiB/sec     632.995 MiB/sec    24.788\r\n   ArraySortIndicesInt64Narrow/32768/10     643.182 MiB/sec     724.483 MiB/sec    12.640\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-15T04:35:47.961+0000",
                    "updated": "2021-04-15T04:35:47.961+0000",
                    "started": "2021-04-15T04:35:47.960+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "583129",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/583502",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009#issuecomment-820516174\n\n\n   I checked Github Actions and Travis-CI on my fork, will merge.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-15T15:23:46.028+0000",
                    "updated": "2021-04-15T15:23:46.028+0000",
                    "started": "2021-04-15T15:23:46.028+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "583502",
                    "issueId": "13357678"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/worklog/583503",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou closed pull request #10009:\nURL: https://github.com/apache/arrow/pull/10009\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-15T15:24:09.127+0000",
                    "updated": "2021-04-15T15:24:09.127+0000",
                    "started": "2021-04-15T15:24:09.127+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "583503",
                    "issueId": "13357678"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 9600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@39f2f323[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7b4b3f28[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2364acf8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@17465c3[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@512b3b97[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5562e1ab[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@53679493[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@711fa941[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7960c376[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@3bcd1a48[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@54e1c2ae[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@58b83cd2[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 9600,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Apr 15 15:23:55 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-04-15T15:23:55.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11568/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2021-02-09T04:56:53.000+0000",
        "updated": "2021-04-15T15:24:10.000+0000",
        "timeoriginalestimate": null,
        "description": "Comparing with scipy.stats.mode, arrow mode kernel is much slower in some conditions. See below example.\r\n\r\n{noformat}\r\nIn [1]: import numpy as np\r\n\r\nIn [2]: import scipy.stats\r\n\r\nIn [3]: import pyarrow.compute as pc\r\n\r\nIn [4]: f = np.random.rand(12345678)\r\n\r\nIn [5]: time scipy.stats.mode(f)\r\nCPU times: user 1.14 s, sys: 111 ms, total: 1.25 s\r\nWall time: 1.25 s\r\nOut[5]: ModeResult(mode=array([2.25710692e-08]), count=array([1]))\r\n\r\nIn [6]: time pc.mode(f)[0]\r\nCPU times: user 8.44 s, sys: 338 ms, total: 8.77 s\r\nWall time: 8.77 s\r\nOut[6]: <pyarrow.StructScalar: {'mode': 2.2571069235866048e-08, 'count': 1}>\r\n\r\nIn [7]: i = np.random.randint(0, 1234567, 12345678)\r\n\r\nIn [8]: time scipy.stats.mode(i)\r\nCPU times: user 1.03 s, sys: 3.11 ms, total: 1.03 s\r\nWall time: 1.03 s\r\nOut[8]: ModeResult(mode=array([607002]), count=array([28]))\r\n\r\nIn [9]: time pc.mode(i)[0]\r\nCPU times: user 1.57 s, sys: 0 ns, total: 1.57 s\r\nWall time: 1.57 s\r\nOut[9]: <pyarrow.StructScalar: {'mode': 607002, 'count': 28}>\r\n{noformat}",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 9600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Compute] Mode kernel performance is bad in some conditions",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/comment/17315355",
                    "id": "17315355",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai%231",
                        "name": "yibocai#1",
                        "key": "yibocai",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10453",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10453",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10453",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10453"
                        },
                        "displayName": "yibocai#1",
                        "active": false,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "scipy.stats.mode calls numpy.unique to do the jobs.\r\nnumpy.unique sorts the array and counts same values. It looks a better approach than arrow approach, which stores value counts to a map.\r\nBoth has O(n) space. Arrow's map approach only outperforms numpy when there are many duplicated values (> 100 for each value), which looks not useful.\r\nI think numpy's sort and count approach is better.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai%231",
                        "name": "yibocai#1",
                        "key": "yibocai",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10453",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10453",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10453",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10453"
                        },
                        "displayName": "yibocai#1",
                        "active": false,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-04-06T08:54:37.573+0000",
                    "updated": "2021-04-06T08:54:37.573+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13357678/comment/17322268",
                    "id": "17322268",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 10009\n[https://github.com/apache/arrow/pull/10009]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-04-15T15:23:55.451+0000",
                    "updated": "2021-04-15T15:23:55.451+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0nil4:",
        "customfield_12314139": null
    }
}