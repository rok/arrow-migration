{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13370235",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235",
    "key": "ARROW-12289",
    "fields": {
        "parent": {
            "id": "13264619",
            "key": "ARROW-7001",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13264619",
            "fields": {
                "summary": "[C++] Develop threading APIs to accommodate nested parallelism ",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 21600,
            "total": 21600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 21600,
            "total": 21600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12289/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 36,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/581515",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace opened a new pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008\n\n\n   WIP\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T03:41:14.231+0000",
                    "updated": "2021-04-13T03:41:14.231+0000",
                    "started": "2021-04-13T03:41:14.231+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581515",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/581656",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#issuecomment-818601902\n\n\n   https://issues.apache.org/jira/browse/ARROW-12289\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T09:42:36.449+0000",
                    "updated": "2021-04-13T09:42:36.449+0000",
                    "started": "2021-04-13T09:42:36.449+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581656",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/581798",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r612469861\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/dataset.cc\n##########\n@@ -95,6 +95,33 @@ Result<ScanTaskIterator> InMemoryFragment::Scan(std::shared_ptr<ScanOptions> opt\n   return MakeMapIterator(fn, std::move(batches_it));\n }\n \n+Result<RecordBatchGenerator> InMemoryFragment::ScanBatchesAsync(\n+    const ScanOptions& options) {\n+  struct Generator {\n+    Future<std::shared_ptr<RecordBatch>> operator()() {\n+      if (batch_index >= self->record_batches_.size()) {\n+        return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+      }\n+      const auto& next_parent = self->record_batches_[batch_index];\n+      if (offset + batch_size < next_parent->num_rows()) {\n+        offset += batch_size;\n+        auto next = next_parent->Slice(offset, batch_size);\n+        return Future<std::shared_ptr<RecordBatch>>::MakeFinished(std::move(next));\n+      }\n+      batch_index++;\n+      auto next = next_parent->Slice(offset, batch_size);\n+      return Future<std::shared_ptr<RecordBatch>>::MakeFinished(std::move(next));\n\nReview comment:\n       A few things here:\r\n   - Shouldn't `offset` be reset when we advance to the next batch?\r\n   - The check for whether we've consumed the current batch should just be `offset < num_rows()` I think.\r\n   - `next_parent->Slice` should come before we update the offset.\r\n   - It might be easier to just recurse after advancing to the next batch, if we care about avoiding empty batches. Else, we should update `offset` after the second `Slice` call too.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner_test.cc\n##########\n@@ -36,8 +36,20 @@ constexpr int64_t kNumberChildDatasets = 2;\n constexpr int64_t kNumberBatches = 16;\n constexpr int64_t kBatchSize = 1024;\n \n-class TestScanner : public DatasetFixtureMixin {\n+struct PrintIsAsyncParam {\n+  std::string operator()(::testing::TestParamInfo<bool> info) {\n+    if (info.param) {\n+      return \"async\";\n+    } else {\n+      return \"sync\";\n+    }\n+  }\n+};\n+\n+class TestScanner : public DatasetFixtureMixinWithParam<bool> {\n\nReview comment:\n       ARROW-11797 uses the param to toggle UseThreads, so this will have to become a `std::pair<bool, bool>` (or really, just a custom struct) in the end.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T14:13:21.835+0000",
                    "updated": "2021-04-13T14:13:21.835+0000",
                    "started": "2021-04-13T14:13:21.835+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581798",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/581806",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r612491223\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner_test.cc\n##########\n@@ -36,8 +36,20 @@ constexpr int64_t kNumberChildDatasets = 2;\n constexpr int64_t kNumberBatches = 16;\n constexpr int64_t kBatchSize = 1024;\n \n-class TestScanner : public DatasetFixtureMixin {\n+struct PrintIsAsyncParam {\n+  std::string operator()(::testing::TestParamInfo<bool> info) {\n+    if (info.param) {\n+      return \"async\";\n+    } else {\n+      return \"sync\";\n+    }\n+  }\n+};\n+\n+class TestScanner : public DatasetFixtureMixinWithParam<bool> {\n\nReview comment:\n       Ah, yes.  I was planning on adding whether to scan with `Scan` (to ensure we still test the legacy), `ScanBatches`, or `ScanBatchesUnordered` as a parameter as well.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T14:19:32.108+0000",
                    "updated": "2021-04-13T14:19:32.108+0000",
                    "started": "2021-04-13T14:19:32.108+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581806",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/581807",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r612491538\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner_test.cc\n##########\n@@ -36,8 +36,20 @@ constexpr int64_t kNumberChildDatasets = 2;\n constexpr int64_t kNumberBatches = 16;\n constexpr int64_t kBatchSize = 1024;\n \n-class TestScanner : public DatasetFixtureMixin {\n+struct PrintIsAsyncParam {\n+  std::string operator()(::testing::TestParamInfo<bool> info) {\n+    if (info.param) {\n+      return \"async\";\n+    } else {\n+      return \"sync\";\n+    }\n+  }\n+};\n+\n+class TestScanner : public DatasetFixtureMixinWithParam<bool> {\n\nReview comment:\n       I'll tackle that when I rebase ARROW-11797\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T14:19:55.946+0000",
                    "updated": "2021-04-13T14:19:55.946+0000",
                    "started": "2021-04-13T14:19:55.945+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581807",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/581812",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r612500764\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/dataset.cc\n##########\n@@ -95,6 +95,33 @@ Result<ScanTaskIterator> InMemoryFragment::Scan(std::shared_ptr<ScanOptions> opt\n   return MakeMapIterator(fn, std::move(batches_it));\n }\n \n+Result<RecordBatchGenerator> InMemoryFragment::ScanBatchesAsync(\n+    const ScanOptions& options) {\n+  struct Generator {\n+    Future<std::shared_ptr<RecordBatch>> operator()() {\n+      if (batch_index >= self->record_batches_.size()) {\n+        return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+      }\n+      const auto& next_parent = self->record_batches_[batch_index];\n+      if (offset + batch_size < next_parent->num_rows()) {\n+        offset += batch_size;\n+        auto next = next_parent->Slice(offset, batch_size);\n+        return Future<std::shared_ptr<RecordBatch>>::MakeFinished(std::move(next));\n+      }\n+      batch_index++;\n+      auto next = next_parent->Slice(offset, batch_size);\n+      return Future<std::shared_ptr<RecordBatch>>::MakeFinished(std::move(next));\n\nReview comment:\n       Yep.  This logic was all backwards.  I've since changed it to a while loop.  Just pushed the change.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-13T14:29:54.448+0000",
                    "updated": "2021-04-13T14:29:54.448+0000",
                    "started": "2021-04-13T14:29:54.448+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "581812",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/582590",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r613321431\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -364,5 +365,228 @@ Future<std::shared_ptr<Table>> SyncScanner::ToTableInternal(\n           });\n }\n \n+namespace {\n+\n+inline Result<EnumeratedRecordBatch> DoFilterAndProjectRecordBatchAsync(\n+    const std::shared_ptr<Scanner>& scanner, const EnumeratedRecordBatch& in) {\n+  ARROW_ASSIGN_OR_RAISE(Expression simplified_filter,\n+                        SimplifyWithGuarantee(scanner->options()->filter,\n+                                              in.fragment.value->partition_expression()));\n+\n+  compute::ExecContext exec_context{scanner->options()->pool};\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum mask, ExecuteScalarExpression(simplified_filter, Datum(in.record_batch.value),\n+                                          &exec_context));\n+\n+  Datum filtered;\n+  if (mask.is_scalar()) {\n+    const auto& mask_scalar = mask.scalar_as<BooleanScalar>();\n+    if (mask_scalar.is_valid && mask_scalar.value) {\n+      // filter matches entire table\n+      filtered = in.record_batch.value;\n+    } else {\n+      // Filter matches nothing\n+      filtered = in.record_batch.value->Slice(0, 0);\n+    }\n+  } else {\n+    ARROW_ASSIGN_OR_RAISE(\n+        filtered, compute::Filter(in.record_batch.value, mask,\n+                                  compute::FilterOptions::Defaults(), &exec_context));\n+  }\n+\n+  ARROW_ASSIGN_OR_RAISE(Expression simplified_projection,\n+                        SimplifyWithGuarantee(scanner->options()->projection,\n+                                              in.fragment.value->partition_expression()));\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum projected,\n+      ExecuteScalarExpression(simplified_projection, filtered, &exec_context));\n+\n+  DCHECK_EQ(projected.type()->id(), Type::STRUCT);\n+  if (projected.shape() == ValueDescr::SCALAR) {\n+    // Only virtual columns are projected. Broadcast to an array\n+    ARROW_ASSIGN_OR_RAISE(\n+        projected,\n+        MakeArrayFromScalar(*projected.scalar(), filtered.record_batch()->num_rows(),\n+                            scanner->options()->pool));\n+  }\n+  ARROW_ASSIGN_OR_RAISE(auto out,\n+                        RecordBatch::FromStructArray(projected.array_as<StructArray>()));\n+  auto projected_batch =\n+      out->ReplaceSchemaMetadata(in.record_batch.value->schema()->metadata());\n+\n+  return EnumeratedRecordBatch{\n+      {std::move(projected_batch), in.record_batch.index, in.record_batch.last},\n+      in.fragment};\n+}\n+\n+inline EnumeratedRecordBatchGenerator FilterAndProjectRecordBatchAsync(\n+    const std::shared_ptr<Scanner>& scanner, EnumeratedRecordBatchGenerator rbs) {\n+  auto mapper = [scanner](const EnumeratedRecordBatch& in) {\n+    return DoFilterAndProjectRecordBatchAsync(scanner, in);\n+  };\n+  return MakeMappedGenerator<EnumeratedRecordBatch>(std::move(rbs), mapper);\n+}\n+\n+Result<EnumeratedRecordBatchGenerator> FragmentToBatches(\n+    std::shared_ptr<AsyncScanner> scanner,\n+    const Enumerated<std::shared_ptr<Fragment>>& fragment) {\n+  ARROW_ASSIGN_OR_RAISE(auto batch_gen,\n+                        fragment.value->ScanBatchesAsync(*scanner->options()));\n+  auto enumerated_batch_gen = MakeEnumeratedGenerator(std::move(batch_gen));\n+\n+  auto combine_fn =\n+      [fragment](const Enumerated<std::shared_ptr<RecordBatch>>& record_batch) {\n+        return EnumeratedRecordBatch{record_batch, fragment};\n+      };\n+\n+  auto combined_gen = MakeMappedGenerator<EnumeratedRecordBatch>(enumerated_batch_gen,\n+                                                                 std::move(combine_fn));\n+\n+  return FilterAndProjectRecordBatchAsync(scanner, std::move(combined_gen));\n+}\n+\n+Result<AsyncGenerator<EnumeratedRecordBatchGenerator>> FragmentsToBatches(\n+    std::shared_ptr<AsyncScanner> scanner, FragmentGenerator fragment_gen) {\n+  auto enumerated_fragment_gen = MakeEnumeratedGenerator(std::move(fragment_gen));\n+  return MakeMappedGenerator<EnumeratedRecordBatchGenerator>(\n+      std::move(enumerated_fragment_gen),\n+      [scanner](const Enumerated<std::shared_ptr<Fragment>>& fragment) {\n+        return FragmentToBatches(scanner, fragment);\n+      });\n+}\n+\n+}  // namespace\n+\n+Result<FragmentGenerator> AsyncScanner::GetFragments() const {\n+  // TODO(ARROW-8163): Async fragment scanning will return AsyncGenerator<Fragment> here.\n+  // Current iterator based versions are all fast & sync so we will just ToVector it\n+  ARROW_ASSIGN_OR_RAISE(auto fragments_it, dataset_->GetFragments(scan_options_->filter));\n+  ARROW_ASSIGN_OR_RAISE(auto fragments_vec, fragments_it.ToVector());\n+  return MakeVectorGenerator(std::move(fragments_vec));\n+}\n+\n+Result<TaggedRecordBatchIterator> AsyncScanner::ScanBatches() {\n+  ARROW_ASSIGN_OR_RAISE(auto batches_gen, ScanBatchesAsync(scan_options_->cpu_executor));\n+  return MakeGeneratorIterator(std::move(batches_gen));\n+}\n+\n+Result<EnumeratedRecordBatchIterator> AsyncScanner::ScanBatchesUnordered() {\n+  ARROW_ASSIGN_OR_RAISE(auto batches_gen,\n+                        ScanBatchesUnorderedAsync(scan_options_->cpu_executor));\n+  return MakeGeneratorIterator(std::move(batches_gen));\n+}\n+\n+Result<std::shared_ptr<Table>> AsyncScanner::ToTable() {\n+  auto table_fut = ToTableAsync(scan_options_->cpu_executor);\n+  return table_fut.result();\n+}\n+\n+Result<EnumeratedRecordBatchGenerator> AsyncScanner::ScanBatchesUnorderedAsync(\n+    internal::Executor* cpu_executor) {\n+  auto self = shared_from_this();\n+  ARROW_ASSIGN_OR_RAISE(auto fragment_gen, GetFragments());\n+  ARROW_ASSIGN_OR_RAISE(auto batch_gen_gen,\n+                        FragmentsToBatches(self, std::move(fragment_gen)));\n+  return MakeConcatenatedGenerator(std::move(batch_gen_gen));\n\nReview comment:\n       Could this be MakeMergedGenerator?\n\n##########\nFile path: cpp/src/arrow/dataset/dataset.cc\n##########\n@@ -95,6 +95,55 @@ Result<ScanTaskIterator> InMemoryFragment::Scan(std::shared_ptr<ScanOptions> opt\n   return MakeMapIterator(fn, std::move(batches_it));\n }\n \n+Result<RecordBatchGenerator> InMemoryFragment::ScanBatchesAsync(\n+    const ScanOptions& options) {\n+  struct State {\n+    State(std::shared_ptr<InMemoryFragment> fragment, int64_t batch_size)\n+        : fragment(std::move(fragment)),\n+          batch_index(0),\n+          offset(0),\n+          batch_size(batch_size) {}\n+\n+    std::shared_ptr<RecordBatch> Next() {\n+      const auto& next_parent = fragment->record_batches_[batch_index];\n+      if (offset < next_parent->num_rows()) {\n+        auto next = next_parent->Slice(offset, batch_size);\n+        offset += batch_size;\n+        return next;\n+      }\n+      batch_index++;\n+      offset = 0;\n+      return nullptr;\n+    }\n+\n+    bool Finished() { return batch_index >= fragment->record_batches_.size(); }\n+\n+    std::shared_ptr<InMemoryFragment> fragment;\n+    std::size_t batch_index;\n+    int64_t offset;\n+    int64_t batch_size;\n+  };\n+\n+  struct Generator {\n+    Generator(std::shared_ptr<InMemoryFragment> fragment, int64_t batch_size)\n+        : state(std::make_shared<State>(std::move(fragment), batch_size)) {}\n+\n+    Future<std::shared_ptr<RecordBatch>> operator()() {\n+      while (!state->Finished()) {\n+        auto next = state->Next();\n+        if (next) {\n+          return Future<std::shared_ptr<RecordBatch>>::MakeFinished(std::move(next));\n+        }\n+      }\n+      return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+    }\n+\n+    std::shared_ptr<State> state;\n+  };\n+  return Generator(std::dynamic_pointer_cast<InMemoryFragment>(shared_from_this()),\n\nReview comment:\n       nit: maybe `internal::checked_pointer_cast`? (though admittedly it's not used super consistently throughout the codebase)\n\n##########\nFile path: cpp/src/arrow/dataset/file_base.cc\n##########\n@@ -102,6 +102,79 @@ Result<std::shared_ptr<FileFragment>> FileFormat::MakeFragment(\n                        std::move(partition_expression), std::move(physical_schema)));\n }\n \n+// TODO(ARROW-12355[CSV], ARROW-11772[IPC], ARROW-11843[Parquet]) The following\n+// implementation of ScanBatchesAsync is both ugly and terribly ineffecient.  Each of the\n+// formats should provide their own efficient implementation.\n+Result<RecordBatchGenerator> FileFormat::ScanBatchesAsync(\n+    const ScanOptions& options, const std::shared_ptr<FileFragment>& file) {\n+  std::shared_ptr<ScanOptions> scan_options = std::make_shared<ScanOptions>(options);\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_it, ScanFile(scan_options, file));\n+  struct State {\n+    State(std::shared_ptr<ScanOptions> scan_options, ScanTaskIterator scan_task_it)\n+        : scan_options(std::move(scan_options)),\n+          scan_task_it(std::move(scan_task_it)),\n+          current_rb_it(),\n+          current_rb_gen(),\n+          finished(false) {}\n+\n+    std::shared_ptr<ScanOptions> scan_options;\n+    ScanTaskIterator scan_task_it;\n+    RecordBatchIterator current_rb_it;\n+    RecordBatchGenerator current_rb_gen;\n+    bool finished;\n+  };\n+  struct Generator {\n+    Future<std::shared_ptr<RecordBatch>> operator()() {\n+      if (state->finished) {\n+        return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+      }\n+      if (!state->current_rb_it && !state->current_rb_gen) {\n+        RETURN_NOT_OK(PumpScanTask());\n+        if (state->finished) {\n+          return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+        }\n+      }\n+      if (state->current_rb_gen) {\n+        return NextAsync();\n+      }\n+      return NextSync();\n+    }\n+    Future<std::shared_ptr<RecordBatch>> NextSync() {\n+      ARROW_ASSIGN_OR_RAISE(auto next_sync, state->current_rb_it.Next());\n+      if (IsIterationEnd(next_sync)) {\n\nReview comment:\n       Don't we need to check again if NextSync/NextAsync return the end marker? Otherwise, operator() will return a Future that resolves to the end marker and the consumer will stop early.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T15:10:44.471+0000",
                    "updated": "2021-04-14T15:10:44.471+0000",
                    "started": "2021-04-14T15:10:44.470+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582590",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/582694",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r613414017\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_base.cc\n##########\n@@ -102,6 +102,79 @@ Result<std::shared_ptr<FileFragment>> FileFormat::MakeFragment(\n                        std::move(partition_expression), std::move(physical_schema)));\n }\n \n+// TODO(ARROW-12355[CSV], ARROW-11772[IPC], ARROW-11843[Parquet]) The following\n+// implementation of ScanBatchesAsync is both ugly and terribly ineffecient.  Each of the\n+// formats should provide their own efficient implementation.\n+Result<RecordBatchGenerator> FileFormat::ScanBatchesAsync(\n+    const ScanOptions& options, const std::shared_ptr<FileFragment>& file) {\n+  std::shared_ptr<ScanOptions> scan_options = std::make_shared<ScanOptions>(options);\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_it, ScanFile(scan_options, file));\n+  struct State {\n+    State(std::shared_ptr<ScanOptions> scan_options, ScanTaskIterator scan_task_it)\n+        : scan_options(std::move(scan_options)),\n+          scan_task_it(std::move(scan_task_it)),\n+          current_rb_it(),\n+          current_rb_gen(),\n+          finished(false) {}\n+\n+    std::shared_ptr<ScanOptions> scan_options;\n+    ScanTaskIterator scan_task_it;\n+    RecordBatchIterator current_rb_it;\n+    RecordBatchGenerator current_rb_gen;\n+    bool finished;\n+  };\n+  struct Generator {\n+    Future<std::shared_ptr<RecordBatch>> operator()() {\n+      if (state->finished) {\n+        return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+      }\n+      if (!state->current_rb_it && !state->current_rb_gen) {\n+        RETURN_NOT_OK(PumpScanTask());\n+        if (state->finished) {\n+          return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+        }\n+      }\n+      if (state->current_rb_gen) {\n+        return NextAsync();\n+      }\n+      return NextSync();\n+    }\n+    Future<std::shared_ptr<RecordBatch>> NextSync() {\n+      ARROW_ASSIGN_OR_RAISE(auto next_sync, state->current_rb_it.Next());\n+      if (IsIterationEnd(next_sync)) {\n\nReview comment:\n       There is a silent precondition here that every fragment scan should return scan tasks that return at least 1 record batch (unless the entire fragment is empty in which case either 0 scan tasks or 1 scan task with 0 batches should both be ok).\r\n   \r\n   I'm know this precondition holds for IPC and CSV (by virtue of there being only one scan task) but wasn't sure about parquet (i.e. can a push down filter cause a batch-less scan task to be emitted in the middle of a set of scan tasks?)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T16:48:55.816+0000",
                    "updated": "2021-04-14T16:48:55.816+0000",
                    "started": "2021-04-14T16:48:55.816+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582694",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/582697",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r613415855\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -364,5 +365,228 @@ Future<std::shared_ptr<Table>> SyncScanner::ToTableInternal(\n           });\n }\n \n+namespace {\n+\n+inline Result<EnumeratedRecordBatch> DoFilterAndProjectRecordBatchAsync(\n+    const std::shared_ptr<Scanner>& scanner, const EnumeratedRecordBatch& in) {\n+  ARROW_ASSIGN_OR_RAISE(Expression simplified_filter,\n+                        SimplifyWithGuarantee(scanner->options()->filter,\n+                                              in.fragment.value->partition_expression()));\n+\n+  compute::ExecContext exec_context{scanner->options()->pool};\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum mask, ExecuteScalarExpression(simplified_filter, Datum(in.record_batch.value),\n+                                          &exec_context));\n+\n+  Datum filtered;\n+  if (mask.is_scalar()) {\n+    const auto& mask_scalar = mask.scalar_as<BooleanScalar>();\n+    if (mask_scalar.is_valid && mask_scalar.value) {\n+      // filter matches entire table\n+      filtered = in.record_batch.value;\n+    } else {\n+      // Filter matches nothing\n+      filtered = in.record_batch.value->Slice(0, 0);\n+    }\n+  } else {\n+    ARROW_ASSIGN_OR_RAISE(\n+        filtered, compute::Filter(in.record_batch.value, mask,\n+                                  compute::FilterOptions::Defaults(), &exec_context));\n+  }\n+\n+  ARROW_ASSIGN_OR_RAISE(Expression simplified_projection,\n+                        SimplifyWithGuarantee(scanner->options()->projection,\n+                                              in.fragment.value->partition_expression()));\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum projected,\n+      ExecuteScalarExpression(simplified_projection, filtered, &exec_context));\n+\n+  DCHECK_EQ(projected.type()->id(), Type::STRUCT);\n+  if (projected.shape() == ValueDescr::SCALAR) {\n+    // Only virtual columns are projected. Broadcast to an array\n+    ARROW_ASSIGN_OR_RAISE(\n+        projected,\n+        MakeArrayFromScalar(*projected.scalar(), filtered.record_batch()->num_rows(),\n+                            scanner->options()->pool));\n+  }\n+  ARROW_ASSIGN_OR_RAISE(auto out,\n+                        RecordBatch::FromStructArray(projected.array_as<StructArray>()));\n+  auto projected_batch =\n+      out->ReplaceSchemaMetadata(in.record_batch.value->schema()->metadata());\n+\n+  return EnumeratedRecordBatch{\n+      {std::move(projected_batch), in.record_batch.index, in.record_batch.last},\n+      in.fragment};\n+}\n+\n+inline EnumeratedRecordBatchGenerator FilterAndProjectRecordBatchAsync(\n+    const std::shared_ptr<Scanner>& scanner, EnumeratedRecordBatchGenerator rbs) {\n+  auto mapper = [scanner](const EnumeratedRecordBatch& in) {\n+    return DoFilterAndProjectRecordBatchAsync(scanner, in);\n+  };\n+  return MakeMappedGenerator<EnumeratedRecordBatch>(std::move(rbs), mapper);\n+}\n+\n+Result<EnumeratedRecordBatchGenerator> FragmentToBatches(\n+    std::shared_ptr<AsyncScanner> scanner,\n+    const Enumerated<std::shared_ptr<Fragment>>& fragment) {\n+  ARROW_ASSIGN_OR_RAISE(auto batch_gen,\n+                        fragment.value->ScanBatchesAsync(*scanner->options()));\n+  auto enumerated_batch_gen = MakeEnumeratedGenerator(std::move(batch_gen));\n+\n+  auto combine_fn =\n+      [fragment](const Enumerated<std::shared_ptr<RecordBatch>>& record_batch) {\n+        return EnumeratedRecordBatch{record_batch, fragment};\n+      };\n+\n+  auto combined_gen = MakeMappedGenerator<EnumeratedRecordBatch>(enumerated_batch_gen,\n+                                                                 std::move(combine_fn));\n+\n+  return FilterAndProjectRecordBatchAsync(scanner, std::move(combined_gen));\n+}\n+\n+Result<AsyncGenerator<EnumeratedRecordBatchGenerator>> FragmentsToBatches(\n+    std::shared_ptr<AsyncScanner> scanner, FragmentGenerator fragment_gen) {\n+  auto enumerated_fragment_gen = MakeEnumeratedGenerator(std::move(fragment_gen));\n+  return MakeMappedGenerator<EnumeratedRecordBatchGenerator>(\n+      std::move(enumerated_fragment_gen),\n+      [scanner](const Enumerated<std::shared_ptr<Fragment>>& fragment) {\n+        return FragmentToBatches(scanner, fragment);\n+      });\n+}\n+\n+}  // namespace\n+\n+Result<FragmentGenerator> AsyncScanner::GetFragments() const {\n+  // TODO(ARROW-8163): Async fragment scanning will return AsyncGenerator<Fragment> here.\n+  // Current iterator based versions are all fast & sync so we will just ToVector it\n+  ARROW_ASSIGN_OR_RAISE(auto fragments_it, dataset_->GetFragments(scan_options_->filter));\n+  ARROW_ASSIGN_OR_RAISE(auto fragments_vec, fragments_it.ToVector());\n+  return MakeVectorGenerator(std::move(fragments_vec));\n+}\n+\n+Result<TaggedRecordBatchIterator> AsyncScanner::ScanBatches() {\n+  ARROW_ASSIGN_OR_RAISE(auto batches_gen, ScanBatchesAsync(scan_options_->cpu_executor));\n+  return MakeGeneratorIterator(std::move(batches_gen));\n+}\n+\n+Result<EnumeratedRecordBatchIterator> AsyncScanner::ScanBatchesUnordered() {\n+  ARROW_ASSIGN_OR_RAISE(auto batches_gen,\n+                        ScanBatchesUnorderedAsync(scan_options_->cpu_executor));\n+  return MakeGeneratorIterator(std::move(batches_gen));\n+}\n+\n+Result<std::shared_ptr<Table>> AsyncScanner::ToTable() {\n+  auto table_fut = ToTableAsync(scan_options_->cpu_executor);\n+  return table_fut.result();\n+}\n+\n+Result<EnumeratedRecordBatchGenerator> AsyncScanner::ScanBatchesUnorderedAsync(\n+    internal::Executor* cpu_executor) {\n+  auto self = shared_from_this();\n+  ARROW_ASSIGN_OR_RAISE(auto fragment_gen, GetFragments());\n+  ARROW_ASSIGN_OR_RAISE(auto batch_gen_gen,\n+                        FragmentsToBatches(self, std::move(fragment_gen)));\n+  return MakeConcatenatedGenerator(std::move(batch_gen_gen));\n\nReview comment:\n       It will need to be.  The problem is that `MakeMergedGenerator` is immediately consuming `EnumeratingGenerator` which is not async-reentrant.  `MakeMergedGenerator` (erroneously) pulls from the outer (the gen_gen) generator in an async-reentrant fashion.  I'll make a follow-up JIRA just to keep this one simple.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T16:51:33.305+0000",
                    "updated": "2021-04-14T16:51:33.305+0000",
                    "started": "2021-04-14T16:51:33.305+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582697",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/582698",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r613417793\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -364,5 +365,228 @@ Future<std::shared_ptr<Table>> SyncScanner::ToTableInternal(\n           });\n }\n \n+namespace {\n+\n+inline Result<EnumeratedRecordBatch> DoFilterAndProjectRecordBatchAsync(\n+    const std::shared_ptr<Scanner>& scanner, const EnumeratedRecordBatch& in) {\n+  ARROW_ASSIGN_OR_RAISE(Expression simplified_filter,\n+                        SimplifyWithGuarantee(scanner->options()->filter,\n+                                              in.fragment.value->partition_expression()));\n+\n+  compute::ExecContext exec_context{scanner->options()->pool};\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum mask, ExecuteScalarExpression(simplified_filter, Datum(in.record_batch.value),\n+                                          &exec_context));\n+\n+  Datum filtered;\n+  if (mask.is_scalar()) {\n+    const auto& mask_scalar = mask.scalar_as<BooleanScalar>();\n+    if (mask_scalar.is_valid && mask_scalar.value) {\n+      // filter matches entire table\n+      filtered = in.record_batch.value;\n+    } else {\n+      // Filter matches nothing\n+      filtered = in.record_batch.value->Slice(0, 0);\n+    }\n+  } else {\n+    ARROW_ASSIGN_OR_RAISE(\n+        filtered, compute::Filter(in.record_batch.value, mask,\n+                                  compute::FilterOptions::Defaults(), &exec_context));\n+  }\n+\n+  ARROW_ASSIGN_OR_RAISE(Expression simplified_projection,\n+                        SimplifyWithGuarantee(scanner->options()->projection,\n+                                              in.fragment.value->partition_expression()));\n+  ARROW_ASSIGN_OR_RAISE(\n+      Datum projected,\n+      ExecuteScalarExpression(simplified_projection, filtered, &exec_context));\n+\n+  DCHECK_EQ(projected.type()->id(), Type::STRUCT);\n+  if (projected.shape() == ValueDescr::SCALAR) {\n+    // Only virtual columns are projected. Broadcast to an array\n+    ARROW_ASSIGN_OR_RAISE(\n+        projected,\n+        MakeArrayFromScalar(*projected.scalar(), filtered.record_batch()->num_rows(),\n+                            scanner->options()->pool));\n+  }\n+  ARROW_ASSIGN_OR_RAISE(auto out,\n+                        RecordBatch::FromStructArray(projected.array_as<StructArray>()));\n+  auto projected_batch =\n+      out->ReplaceSchemaMetadata(in.record_batch.value->schema()->metadata());\n+\n+  return EnumeratedRecordBatch{\n+      {std::move(projected_batch), in.record_batch.index, in.record_batch.last},\n+      in.fragment};\n+}\n+\n+inline EnumeratedRecordBatchGenerator FilterAndProjectRecordBatchAsync(\n+    const std::shared_ptr<Scanner>& scanner, EnumeratedRecordBatchGenerator rbs) {\n+  auto mapper = [scanner](const EnumeratedRecordBatch& in) {\n+    return DoFilterAndProjectRecordBatchAsync(scanner, in);\n+  };\n+  return MakeMappedGenerator<EnumeratedRecordBatch>(std::move(rbs), mapper);\n+}\n+\n+Result<EnumeratedRecordBatchGenerator> FragmentToBatches(\n+    std::shared_ptr<AsyncScanner> scanner,\n+    const Enumerated<std::shared_ptr<Fragment>>& fragment) {\n+  ARROW_ASSIGN_OR_RAISE(auto batch_gen,\n+                        fragment.value->ScanBatchesAsync(*scanner->options()));\n+  auto enumerated_batch_gen = MakeEnumeratedGenerator(std::move(batch_gen));\n+\n+  auto combine_fn =\n+      [fragment](const Enumerated<std::shared_ptr<RecordBatch>>& record_batch) {\n+        return EnumeratedRecordBatch{record_batch, fragment};\n+      };\n+\n+  auto combined_gen = MakeMappedGenerator<EnumeratedRecordBatch>(enumerated_batch_gen,\n+                                                                 std::move(combine_fn));\n+\n+  return FilterAndProjectRecordBatchAsync(scanner, std::move(combined_gen));\n+}\n+\n+Result<AsyncGenerator<EnumeratedRecordBatchGenerator>> FragmentsToBatches(\n+    std::shared_ptr<AsyncScanner> scanner, FragmentGenerator fragment_gen) {\n+  auto enumerated_fragment_gen = MakeEnumeratedGenerator(std::move(fragment_gen));\n+  return MakeMappedGenerator<EnumeratedRecordBatchGenerator>(\n+      std::move(enumerated_fragment_gen),\n+      [scanner](const Enumerated<std::shared_ptr<Fragment>>& fragment) {\n+        return FragmentToBatches(scanner, fragment);\n+      });\n+}\n+\n+}  // namespace\n+\n+Result<FragmentGenerator> AsyncScanner::GetFragments() const {\n+  // TODO(ARROW-8163): Async fragment scanning will return AsyncGenerator<Fragment> here.\n+  // Current iterator based versions are all fast & sync so we will just ToVector it\n+  ARROW_ASSIGN_OR_RAISE(auto fragments_it, dataset_->GetFragments(scan_options_->filter));\n+  ARROW_ASSIGN_OR_RAISE(auto fragments_vec, fragments_it.ToVector());\n+  return MakeVectorGenerator(std::move(fragments_vec));\n+}\n+\n+Result<TaggedRecordBatchIterator> AsyncScanner::ScanBatches() {\n+  ARROW_ASSIGN_OR_RAISE(auto batches_gen, ScanBatchesAsync(scan_options_->cpu_executor));\n+  return MakeGeneratorIterator(std::move(batches_gen));\n+}\n+\n+Result<EnumeratedRecordBatchIterator> AsyncScanner::ScanBatchesUnordered() {\n+  ARROW_ASSIGN_OR_RAISE(auto batches_gen,\n+                        ScanBatchesUnorderedAsync(scan_options_->cpu_executor));\n+  return MakeGeneratorIterator(std::move(batches_gen));\n+}\n+\n+Result<std::shared_ptr<Table>> AsyncScanner::ToTable() {\n+  auto table_fut = ToTableAsync(scan_options_->cpu_executor);\n+  return table_fut.result();\n+}\n+\n+Result<EnumeratedRecordBatchGenerator> AsyncScanner::ScanBatchesUnorderedAsync(\n+    internal::Executor* cpu_executor) {\n+  auto self = shared_from_this();\n+  ARROW_ASSIGN_OR_RAISE(auto fragment_gen, GetFragments());\n+  ARROW_ASSIGN_OR_RAISE(auto batch_gen_gen,\n+                        FragmentsToBatches(self, std::move(fragment_gen)));\n+  return MakeConcatenatedGenerator(std::move(batch_gen_gen));\n\nReview comment:\n       ARROW-12386\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T16:54:24.445+0000",
                    "updated": "2021-04-14T16:54:24.445+0000",
                    "started": "2021-04-14T16:54:24.445+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582698",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/582712",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r613433698\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_base.cc\n##########\n@@ -102,6 +102,79 @@ Result<std::shared_ptr<FileFragment>> FileFormat::MakeFragment(\n                        std::move(partition_expression), std::move(physical_schema)));\n }\n \n+// TODO(ARROW-12355[CSV], ARROW-11772[IPC], ARROW-11843[Parquet]) The following\n+// implementation of ScanBatchesAsync is both ugly and terribly ineffecient.  Each of the\n+// formats should provide their own efficient implementation.\n+Result<RecordBatchGenerator> FileFormat::ScanBatchesAsync(\n+    const ScanOptions& options, const std::shared_ptr<FileFragment>& file) {\n+  std::shared_ptr<ScanOptions> scan_options = std::make_shared<ScanOptions>(options);\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_it, ScanFile(scan_options, file));\n+  struct State {\n+    State(std::shared_ptr<ScanOptions> scan_options, ScanTaskIterator scan_task_it)\n+        : scan_options(std::move(scan_options)),\n+          scan_task_it(std::move(scan_task_it)),\n+          current_rb_it(),\n+          current_rb_gen(),\n+          finished(false) {}\n+\n+    std::shared_ptr<ScanOptions> scan_options;\n+    ScanTaskIterator scan_task_it;\n+    RecordBatchIterator current_rb_it;\n+    RecordBatchGenerator current_rb_gen;\n+    bool finished;\n+  };\n+  struct Generator {\n+    Future<std::shared_ptr<RecordBatch>> operator()() {\n+      if (state->finished) {\n+        return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+      }\n+      if (!state->current_rb_it && !state->current_rb_gen) {\n+        RETURN_NOT_OK(PumpScanTask());\n+        if (state->finished) {\n+          return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+        }\n+      }\n+      if (state->current_rb_gen) {\n+        return NextAsync();\n+      }\n+      return NextSync();\n+    }\n+    Future<std::shared_ptr<RecordBatch>> NextSync() {\n+      ARROW_ASSIGN_OR_RAISE(auto next_sync, state->current_rb_it.Next());\n+      if (IsIterationEnd(next_sync)) {\n\nReview comment:\n       I may be reading this wrong, but when we finish one scan task and move on to the next, since we just fall through here, we'll return a completed Future which contains a nullptr, which gets returned as the result of `operator()`. So the generator's consumer will think that the generator has ended, even though we still have more scan tasks.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T17:18:26.210+0000",
                    "updated": "2021-04-14T17:18:26.210+0000",
                    "started": "2021-04-14T17:18:26.209+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582712",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/582714",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r613435402\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_base.cc\n##########\n@@ -102,6 +102,79 @@ Result<std::shared_ptr<FileFragment>> FileFormat::MakeFragment(\n                        std::move(partition_expression), std::move(physical_schema)));\n }\n \n+// TODO(ARROW-12355[CSV], ARROW-11772[IPC], ARROW-11843[Parquet]) The following\n+// implementation of ScanBatchesAsync is both ugly and terribly ineffecient.  Each of the\n+// formats should provide their own efficient implementation.\n+Result<RecordBatchGenerator> FileFormat::ScanBatchesAsync(\n+    const ScanOptions& options, const std::shared_ptr<FileFragment>& file) {\n+  std::shared_ptr<ScanOptions> scan_options = std::make_shared<ScanOptions>(options);\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_it, ScanFile(scan_options, file));\n+  struct State {\n+    State(std::shared_ptr<ScanOptions> scan_options, ScanTaskIterator scan_task_it)\n+        : scan_options(std::move(scan_options)),\n+          scan_task_it(std::move(scan_task_it)),\n+          current_rb_it(),\n+          current_rb_gen(),\n+          finished(false) {}\n+\n+    std::shared_ptr<ScanOptions> scan_options;\n+    ScanTaskIterator scan_task_it;\n+    RecordBatchIterator current_rb_it;\n+    RecordBatchGenerator current_rb_gen;\n+    bool finished;\n+  };\n+  struct Generator {\n+    Future<std::shared_ptr<RecordBatch>> operator()() {\n+      if (state->finished) {\n+        return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+      }\n+      if (!state->current_rb_it && !state->current_rb_gen) {\n+        RETURN_NOT_OK(PumpScanTask());\n+        if (state->finished) {\n+          return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+        }\n+      }\n+      if (state->current_rb_gen) {\n+        return NextAsync();\n+      }\n+      return NextSync();\n+    }\n+    Future<std::shared_ptr<RecordBatch>> NextSync() {\n+      ARROW_ASSIGN_OR_RAISE(auto next_sync, state->current_rb_it.Next());\n+      if (IsIterationEnd(next_sync)) {\n\nReview comment:\n       Oh.  I think you are right.  I should probably add a scanner unit test that generates more than one scan task.  I'll work on that.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T17:21:05.328+0000",
                    "updated": "2021-04-14T17:21:05.328+0000",
                    "started": "2021-04-14T17:21:05.327+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582714",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/582825",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r613549219\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_base.cc\n##########\n@@ -102,6 +102,79 @@ Result<std::shared_ptr<FileFragment>> FileFormat::MakeFragment(\n                        std::move(partition_expression), std::move(physical_schema)));\n }\n \n+// TODO(ARROW-12355[CSV], ARROW-11772[IPC], ARROW-11843[Parquet]) The following\n+// implementation of ScanBatchesAsync is both ugly and terribly ineffecient.  Each of the\n+// formats should provide their own efficient implementation.\n+Result<RecordBatchGenerator> FileFormat::ScanBatchesAsync(\n+    const ScanOptions& options, const std::shared_ptr<FileFragment>& file) {\n+  std::shared_ptr<ScanOptions> scan_options = std::make_shared<ScanOptions>(options);\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_it, ScanFile(scan_options, file));\n+  struct State {\n+    State(std::shared_ptr<ScanOptions> scan_options, ScanTaskIterator scan_task_it)\n+        : scan_options(std::move(scan_options)),\n+          scan_task_it(std::move(scan_task_it)),\n+          current_rb_it(),\n+          current_rb_gen(),\n+          finished(false) {}\n+\n+    std::shared_ptr<ScanOptions> scan_options;\n+    ScanTaskIterator scan_task_it;\n+    RecordBatchIterator current_rb_it;\n+    RecordBatchGenerator current_rb_gen;\n+    bool finished;\n+  };\n+  struct Generator {\n+    Future<std::shared_ptr<RecordBatch>> operator()() {\n+      if (state->finished) {\n+        return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+      }\n+      if (!state->current_rb_it && !state->current_rb_gen) {\n+        RETURN_NOT_OK(PumpScanTask());\n+        if (state->finished) {\n+          return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+        }\n+      }\n+      if (state->current_rb_gen) {\n+        return NextAsync();\n+      }\n+      return NextSync();\n+    }\n+    Future<std::shared_ptr<RecordBatch>> NextSync() {\n+      ARROW_ASSIGN_OR_RAISE(auto next_sync, state->current_rb_it.Next());\n+      if (IsIterationEnd(next_sync)) {\n\nReview comment:\n       I see that there's now a parameter to generate multiple scan tasks per fragment in InMemoryDataset - however, is that necessary? For one, it doesn't affect this code path, since this only affects file fragments. For another, it doesn't affect the scanner, which doesn't use scan tasks (directly); it'll use ScanBatchesAsync on the Fragment, which flattens all the scan tasks itself anyways.\r\n   \r\n   So I think the issue pointed out here doesn't show up in test purely because only Parquet fragments expose multiple scan tasks per fragment right now.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T20:00:45.235+0000",
                    "updated": "2021-04-14T20:00:45.235+0000",
                    "started": "2021-04-14T20:00:45.235+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582825",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/582834",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r613551889\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_base.cc\n##########\n@@ -102,6 +102,79 @@ Result<std::shared_ptr<FileFragment>> FileFormat::MakeFragment(\n                        std::move(partition_expression), std::move(physical_schema)));\n }\n \n+// TODO(ARROW-12355[CSV], ARROW-11772[IPC], ARROW-11843[Parquet]) The following\n+// implementation of ScanBatchesAsync is both ugly and terribly ineffecient.  Each of the\n+// formats should provide their own efficient implementation.\n+Result<RecordBatchGenerator> FileFormat::ScanBatchesAsync(\n+    const ScanOptions& options, const std::shared_ptr<FileFragment>& file) {\n+  std::shared_ptr<ScanOptions> scan_options = std::make_shared<ScanOptions>(options);\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_it, ScanFile(scan_options, file));\n+  struct State {\n+    State(std::shared_ptr<ScanOptions> scan_options, ScanTaskIterator scan_task_it)\n+        : scan_options(std::move(scan_options)),\n+          scan_task_it(std::move(scan_task_it)),\n+          current_rb_it(),\n+          current_rb_gen(),\n+          finished(false) {}\n+\n+    std::shared_ptr<ScanOptions> scan_options;\n+    ScanTaskIterator scan_task_it;\n+    RecordBatchIterator current_rb_it;\n+    RecordBatchGenerator current_rb_gen;\n+    bool finished;\n+  };\n+  struct Generator {\n+    Future<std::shared_ptr<RecordBatch>> operator()() {\n+      if (state->finished) {\n+        return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+      }\n+      if (!state->current_rb_it && !state->current_rb_gen) {\n+        RETURN_NOT_OK(PumpScanTask());\n+        if (state->finished) {\n+          return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+        }\n+      }\n+      if (state->current_rb_gen) {\n+        return NextAsync();\n+      }\n+      return NextSync();\n+    }\n+    Future<std::shared_ptr<RecordBatch>> NextSync() {\n+      ARROW_ASSIGN_OR_RAISE(auto next_sync, state->current_rb_it.Next());\n+      if (IsIterationEnd(next_sync)) {\n\nReview comment:\n       Fair point.  I think it's still necessary but could be renamed as it is a bit vague.  In the async case it is \"batches per fragment\" and in the sync case it is \"scan tasks per fragment\".  It was enough to break the async scanner (it currently fails these tests).  I also agree it doesn't expose this issue so I'll some more tests.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T20:05:33.584+0000",
                    "updated": "2021-04-14T20:05:33.584+0000",
                    "started": "2021-04-14T20:05:33.584+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582834",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/582835",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r613553173\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_base.cc\n##########\n@@ -102,6 +102,79 @@ Result<std::shared_ptr<FileFragment>> FileFormat::MakeFragment(\n                        std::move(partition_expression), std::move(physical_schema)));\n }\n \n+// TODO(ARROW-12355[CSV], ARROW-11772[IPC], ARROW-11843[Parquet]) The following\n+// implementation of ScanBatchesAsync is both ugly and terribly ineffecient.  Each of the\n+// formats should provide their own efficient implementation.\n+Result<RecordBatchGenerator> FileFormat::ScanBatchesAsync(\n+    const ScanOptions& options, const std::shared_ptr<FileFragment>& file) {\n+  std::shared_ptr<ScanOptions> scan_options = std::make_shared<ScanOptions>(options);\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_it, ScanFile(scan_options, file));\n+  struct State {\n+    State(std::shared_ptr<ScanOptions> scan_options, ScanTaskIterator scan_task_it)\n+        : scan_options(std::move(scan_options)),\n+          scan_task_it(std::move(scan_task_it)),\n+          current_rb_it(),\n+          current_rb_gen(),\n+          finished(false) {}\n+\n+    std::shared_ptr<ScanOptions> scan_options;\n+    ScanTaskIterator scan_task_it;\n+    RecordBatchIterator current_rb_it;\n+    RecordBatchGenerator current_rb_gen;\n+    bool finished;\n+  };\n+  struct Generator {\n+    Future<std::shared_ptr<RecordBatch>> operator()() {\n+      if (state->finished) {\n+        return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+      }\n+      if (!state->current_rb_it && !state->current_rb_gen) {\n+        RETURN_NOT_OK(PumpScanTask());\n+        if (state->finished) {\n+          return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+        }\n+      }\n+      if (state->current_rb_gen) {\n+        return NextAsync();\n+      }\n+      return NextSync();\n+    }\n+    Future<std::shared_ptr<RecordBatch>> NextSync() {\n+      ARROW_ASSIGN_OR_RAISE(auto next_sync, state->current_rb_it.Next());\n+      if (IsIterationEnd(next_sync)) {\n\nReview comment:\n       Well, technically speaking the # of batches per fragment depends both on this and max batch size.  So I suppose we could have gotten sufficient testing by setting the max batch size small enough.  At the moment these tests help exercise the SyncScanner if nothing else.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T20:07:37.690+0000",
                    "updated": "2021-04-14T20:07:37.690+0000",
                    "started": "2021-04-14T20:07:37.689+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582835",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/582838",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r613553323\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_base.cc\n##########\n@@ -102,6 +102,79 @@ Result<std::shared_ptr<FileFragment>> FileFormat::MakeFragment(\n                        std::move(partition_expression), std::move(physical_schema)));\n }\n \n+// TODO(ARROW-12355[CSV], ARROW-11772[IPC], ARROW-11843[Parquet]) The following\n+// implementation of ScanBatchesAsync is both ugly and terribly ineffecient.  Each of the\n+// formats should provide their own efficient implementation.\n+Result<RecordBatchGenerator> FileFormat::ScanBatchesAsync(\n+    const ScanOptions& options, const std::shared_ptr<FileFragment>& file) {\n+  std::shared_ptr<ScanOptions> scan_options = std::make_shared<ScanOptions>(options);\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_it, ScanFile(scan_options, file));\n+  struct State {\n+    State(std::shared_ptr<ScanOptions> scan_options, ScanTaskIterator scan_task_it)\n+        : scan_options(std::move(scan_options)),\n+          scan_task_it(std::move(scan_task_it)),\n+          current_rb_it(),\n+          current_rb_gen(),\n+          finished(false) {}\n+\n+    std::shared_ptr<ScanOptions> scan_options;\n+    ScanTaskIterator scan_task_it;\n+    RecordBatchIterator current_rb_it;\n+    RecordBatchGenerator current_rb_gen;\n+    bool finished;\n+  };\n+  struct Generator {\n+    Future<std::shared_ptr<RecordBatch>> operator()() {\n+      if (state->finished) {\n+        return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+      }\n+      if (!state->current_rb_it && !state->current_rb_gen) {\n+        RETURN_NOT_OK(PumpScanTask());\n+        if (state->finished) {\n+          return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+        }\n+      }\n+      if (state->current_rb_gen) {\n+        return NextAsync();\n+      }\n+      return NextSync();\n+    }\n+    Future<std::shared_ptr<RecordBatch>> NextSync() {\n+      ARROW_ASSIGN_OR_RAISE(auto next_sync, state->current_rb_it.Next());\n+      if (IsIterationEnd(next_sync)) {\n\nReview comment:\n       Ah good point. It is mostly just a nit as it's really a testing parameter that's unfortunately getting exposed in the public API.\r\n   \r\n   This isn't a very strong precedent, but TableBatchReader handles batch_size by letting you set it after construction and that feels like an analogue of this. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T20:07:56.027+0000",
                    "updated": "2021-04-14T20:07:56.027+0000",
                    "started": "2021-04-14T20:07:56.027+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582838",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/582839",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r613554161\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/file_base.cc\n##########\n@@ -102,6 +102,79 @@ Result<std::shared_ptr<FileFragment>> FileFormat::MakeFragment(\n                        std::move(partition_expression), std::move(physical_schema)));\n }\n \n+// TODO(ARROW-12355[CSV], ARROW-11772[IPC], ARROW-11843[Parquet]) The following\n+// implementation of ScanBatchesAsync is both ugly and terribly ineffecient.  Each of the\n+// formats should provide their own efficient implementation.\n+Result<RecordBatchGenerator> FileFormat::ScanBatchesAsync(\n+    const ScanOptions& options, const std::shared_ptr<FileFragment>& file) {\n+  std::shared_ptr<ScanOptions> scan_options = std::make_shared<ScanOptions>(options);\n+  ARROW_ASSIGN_OR_RAISE(auto scan_task_it, ScanFile(scan_options, file));\n+  struct State {\n+    State(std::shared_ptr<ScanOptions> scan_options, ScanTaskIterator scan_task_it)\n+        : scan_options(std::move(scan_options)),\n+          scan_task_it(std::move(scan_task_it)),\n+          current_rb_it(),\n+          current_rb_gen(),\n+          finished(false) {}\n+\n+    std::shared_ptr<ScanOptions> scan_options;\n+    ScanTaskIterator scan_task_it;\n+    RecordBatchIterator current_rb_it;\n+    RecordBatchGenerator current_rb_gen;\n+    bool finished;\n+  };\n+  struct Generator {\n+    Future<std::shared_ptr<RecordBatch>> operator()() {\n+      if (state->finished) {\n+        return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+      }\n+      if (!state->current_rb_it && !state->current_rb_gen) {\n+        RETURN_NOT_OK(PumpScanTask());\n+        if (state->finished) {\n+          return AsyncGeneratorEnd<std::shared_ptr<RecordBatch>>();\n+        }\n+      }\n+      if (state->current_rb_gen) {\n+        return NextAsync();\n+      }\n+      return NextSync();\n+    }\n+    Future<std::shared_ptr<RecordBatch>> NextSync() {\n+      ARROW_ASSIGN_OR_RAISE(auto next_sync, state->current_rb_it.Next());\n+      if (IsIterationEnd(next_sync)) {\n\nReview comment:\n       Once SyncScanner goes away we could probably change `InMemoryFragment::record_batches_` to `InMemoryFragment::record_batch_`.  This reflects the spirit of \"getting rid of scan tasks\" better anyways.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-14T20:09:20.303+0000",
                    "updated": "2021-04-14T20:09:20.303+0000",
                    "started": "2021-04-14T20:09:20.303+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "582839",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/584255",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r614827209\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -318,6 +337,28 @@ class ARROW_DS_EXPORT SyncScanner : public Scanner {\n   std::shared_ptr<Fragment> fragment_;\n };\n \n+class ARROW_DS_EXPORT AsyncScanner : public Scanner,\n\nReview comment:\n       Is this worth declaring in the header? We could keep it in the .cc file so that people don't instantiate it directly.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.cc\n##########\n@@ -244,6 +244,8 @@ Status ScannerBuilder::UseThreads(bool use_threads) {\n   return Status::OK();\n }\n \n+void ScannerBuilder::UseAsync(bool use_async) { scan_options_->use_async = use_async; }\n\nReview comment:\n       nit: all the other methods return Status (even if it's a bit pointless)\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -166,13 +169,29 @@ class ARROW_DS_EXPORT ScanTask {\n   std::shared_ptr<Fragment> fragment_;\n };\n \n-template <typename T>\n-struct Enumerated {\n-  T value;\n-  int index;\n-  bool last;\n+/// \\brief A trivial ScanTask that yields the RecordBatch of an array.\n\nReview comment:\n       FWIW I had moved these helpers to the bottom of the file (outside the `@}`) so that they don't get picked up in the API docs as I'd basically consider them implementation details. Though at that point we may actually want them to be in one of the `_internal` headers.\n\n##########\nFile path: cpp/src/arrow/dataset/file_base.cc\n##########\n@@ -102,6 +102,58 @@ Result<std::shared_ptr<FileFragment>> FileFormat::MakeFragment(\n                        std::move(partition_expression), std::move(physical_schema)));\n }\n \n+// TODO(ARROW-12355[CSV], ARROW-11772[IPC], ARROW-11843[Parquet]) The following\n+// implementation of ScanBatchesAsync is both ugly and terribly ineffecient.  Each of the\n+// formats should provide their own efficient implementation.\n+Result<RecordBatchGenerator> FileFormat::ScanBatchesAsync(\n+    const ScanOptions& options, const std::shared_ptr<FileFragment>& file) {\n+  std::shared_ptr<ScanOptions> scan_options = std::make_shared<ScanOptions>(options);\n\nReview comment:\n       nit: if we're going to heap-allocate them anyways, and the sync version takes a shared_ptr, maybe we can just take a shared_ptr here in the first place\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-16T13:20:07.731+0000",
                    "updated": "2021-04-16T13:20:07.731+0000",
                    "started": "2021-04-16T13:20:07.730+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "584255",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/584256",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#issuecomment-821169242\n\n\n   After this lands I can rebase and implement ScanBatchesAsync for IPC/Parquet and give that another test.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-16T13:20:50.857+0000",
                    "updated": "2021-04-16T13:20:50.857+0000",
                    "started": "2021-04-16T13:20:50.857+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "584256",
                    "issueId": "13370235"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/worklog/584416",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10008:\nURL: https://github.com/apache/arrow/pull/10008#discussion_r615039360\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -318,6 +337,28 @@ class ARROW_DS_EXPORT SyncScanner : public Scanner {\n   std::shared_ptr<Fragment> fragment_;\n };\n \n+class ARROW_DS_EXPORT AsyncScanner : public Scanner,\n\nReview comment:\n       Ah, that's a good idea.  I can move both the scanners to `.cc`.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-16T18:15:37.746+0000",
                    "updated": "2021-04-16T18:15:37.746+0000",
                    "started": "2021-04-16T18:15:37.745+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "584416",
                    "issueId": "13370235"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 21600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3ee0e3eb[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7d7b6903[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5775e645[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@71e0bed9[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@59dee806[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2ae01959[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@52df858e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@26bdff7a[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@80dad73[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@228d47fa[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@c5045d0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@455f2d0f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 21600,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Apr 19 19:44:25 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-04-19T19:44:25.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12289/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2021-04-08T01:17:26.000+0000",
        "updated": "2021-04-21T12:12:43.000+0000",
        "timeoriginalestimate": null,
        "description": "This will also add Async default implementations to the fragments & formats.\u00a0 These will initially just defer to the synchronous implementation via the serial executor which will lead to rotten performance but we can add proper async implementations in the follow-up tasks.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "6h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 21600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Create basic AsyncScanner implementation",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13370235/comment/17325279",
                    "id": "17325279",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 10008\n[https://github.com/apache/arrow/pull/10008]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-04-19T19:44:25.846+0000",
                    "updated": "2021-04-19T19:44:25.846+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0pn8g:",
        "customfield_12314139": null
    }
}