{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13248476",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476",
    "key": "ARROW-6110",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12347769",
                "id": "12347769",
                "description": "",
                "name": "1.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-07-24"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/1",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/blocker.svg",
            "name": "Blocker",
            "id": "1"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12585829",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12585829",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "outwardIssue": {
                    "id": "13298332",
                    "key": "ARROW-8450",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298332",
                    "fields": {
                        "summary": "[Integration][C++] Implement large list/binary/utf8 integration",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rymurr",
            "name": "rymurr",
            "key": "rymurr",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Ryan Murray",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333774",
                "id": "12333774",
                "name": "Integration",
                "description": "Issues related to integration / compatibility tests between implementations"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 25800,
            "total": 25800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 25800,
            "total": 25800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-6110/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 43,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/437415",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#issuecomment-634071815\n\n\n   https://issues.apache.org/jira/browse/ARROW-6110\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-27T03:46:17.194+0000",
                    "updated": "2020-05-27T03:46:17.194+0000",
                    "started": "2020-05-27T03:46:17.194+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "437415",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/437540",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rymurr opened a new pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275\n\n\n   Add large list and ensure it works with Integration tests. As noted in the JIRA\r\n   ticket this is rather limited as the underlying vector doesn't support int64 addressing\r\n   \r\n   The important downcasts to int32 have been noted for a follow up once vectors with\r\n   long addresses are supported\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-05-27T04:05:01.357+0000",
                    "updated": "2020-05-27T04:05:01.357+0000",
                    "started": "2020-05-27T04:05:01.357+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "437540",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/439920",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#issuecomment-637308504\n\n\n   @BryanCutler would you have time to review?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-02T06:31:43.919+0000",
                    "updated": "2020-06-02T06:31:43.919+0000",
                    "started": "2020-06-02T06:31:43.918+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "439920",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/439921",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#issuecomment-637308552\n\n\n   @rymurr looks like this needs a rebase\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-02T06:31:56.780+0000",
                    "updated": "2020-06-02T06:31:56.780+0000",
                    "started": "2020-06-02T06:31:56.780+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "439921",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/439990",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rymurr commented on pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#issuecomment-637392636\n\n\n   > @rymurr looks like this needs a rebase\r\n   \r\n   Thanks for the reminder @emkornfield, done.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-02T08:49:39.322+0000",
                    "updated": "2020-06-02T08:49:39.322+0000",
                    "started": "2020-06-02T08:49:39.322+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "439990",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/443457",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#issuecomment-641623134\n\n\n   I'm a little swamped right now, but I'll try to review sometime this week\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-09T22:55:43.723+0000",
                    "updated": "2020-06-09T22:55:43.723+0000",
                    "started": "2020-06-09T22:55:43.723+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "443457",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/444821",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#discussion_r439373604\n\n\n\n##########\nFile path: java/vector/src/main/codegen/templates/UnionLargeListWriter.java\n##########\n@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.complex.writer.DecimalWriter;\n+import org.apache.arrow.vector.holders.DecimalHolder;\n+\n+import java.lang.UnsupportedOperationException;\n+import java.math.BigDecimal;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/UnionLargeListWriter.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+package org.apache.arrow.vector.complex.impl;\n+\n+    import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+<#include \"/@includes/vv_imports.ftl\" />\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+\n+@SuppressWarnings(\"unused\")\n+public class UnionLargeListWriter extends AbstractFieldWriter {\n+\n+  protected LargeListVector vector;\n+  protected PromotableWriter writer;\n+  private long index = 0L;\n+  private boolean inStruct = false;\n+  private String structName;\n+  private static final int OFFSET_WIDTH = 8;\n+\n+  public UnionLargeListWriter(LargeListVector vector) {\n+    this(vector, NullableStructWriterFactory.getNullableStructWriterFactoryInstance());\n+  }\n+\n+  public UnionLargeListWriter(LargeListVector vector, NullableStructWriterFactory nullableStructWriterFactory) {\n+    this.vector = vector;\n+    this.writer = new PromotableWriter(vector.getDataVector(), vector, nullableStructWriterFactory);\n+  }\n+\n+  public UnionLargeListWriter(LargeListVector vector, AbstractFieldWriter parent) {\n+    this(vector);\n+  }\n+\n+  @Override\n+  public void allocate() {\n+    vector.allocateNew();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    vector.clear();\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return vector.getField();\n+  }\n+\n+  public void setValueCount(int count) {\n+    vector.setValueCount(count);\n+  }\n+\n+  @Override\n+  public int getValueCapacity() {\n+    return vector.getValueCapacity();\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    vector.close();\n+    writer.close();\n+  }\n+\n+  @Override\n+  public void setPosition(int index) {\n+    throw new UnsupportedOperationException(\"cant set int index for long list\");\n+  }\n+\n+  public void setIndex(long index) {\n+    this.index = index;\n+  }\n+  <#list vv.types as type><#list type.minor as minor><#assign name = minor.class?cap_first />\n+  <#assign fields = minor.fields!type.fields />\n+  <#assign uncappedName = name?uncap_first/>\n+  <#if uncappedName == \"int\" ><#assign uncappedName = \"integer\" /></#if>\n+  <#if !minor.typeParams?? >\n+\n+  @Override\n+  public ${name}Writer ${uncappedName}() {\n+    return this;\n+  }\n+\n+  @Override\n+  public ${name}Writer ${uncappedName}(String name) {\n+    structName = name;\n+    return writer.${uncappedName}(name);\n+  }\n+  </#if>\n+  </#list></#list>\n+\n+  @Override\n+  public DecimalWriter decimal() {\n+    return this;\n+  }\n+\n+  @Override\n+  public DecimalWriter decimal(String name, int scale, int precision) {\n+    return writer.decimal(name, scale, precision);\n+  }\n+\n+  @Override\n+  public DecimalWriter decimal(String name) {\n+    return writer.decimal(name);\n+  }\n+\n+  @Override\n+  public StructWriter struct() {\n+    inStruct = true;\n+    return this;\n+  }\n+\n+  @Override\n+  public ListWriter list() {\n+    return writer;\n+  }\n+\n+  @Override\n+  public ListWriter list(String name) {\n+    ListWriter listWriter = writer.list(name);\n+    return listWriter;\n+  }\n+\n+  @Override\n+  public StructWriter struct(String name) {\n+    StructWriter structWriter = writer.struct(name);\n+    return structWriter;\n+  }\n+\n+  @Override\n+  public void startList() {\n+    vector.startNewValue(index);\n+    writer.setPosition(checkedCastToInt(vector.getOffsetBuffer().getLong((index + 1) * OFFSET_WIDTH)));\n\nReview comment:\n       Here we need to cast the argument of getLong to long, to avoid integer overflow. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-12T11:52:38.853+0000",
                    "updated": "2020-06-12T11:52:38.853+0000",
                    "started": "2020-06-12T11:52:38.853+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "444821",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/444822",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#discussion_r439373751\n\n\n\n##########\nFile path: java/vector/src/main/codegen/templates/UnionLargeListWriter.java\n##########\n@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.complex.writer.DecimalWriter;\n+import org.apache.arrow.vector.holders.DecimalHolder;\n+\n+import java.lang.UnsupportedOperationException;\n+import java.math.BigDecimal;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/UnionLargeListWriter.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+package org.apache.arrow.vector.complex.impl;\n+\n+    import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+<#include \"/@includes/vv_imports.ftl\" />\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+\n+@SuppressWarnings(\"unused\")\n+public class UnionLargeListWriter extends AbstractFieldWriter {\n+\n+  protected LargeListVector vector;\n+  protected PromotableWriter writer;\n+  private long index = 0L;\n+  private boolean inStruct = false;\n+  private String structName;\n+  private static final int OFFSET_WIDTH = 8;\n+\n+  public UnionLargeListWriter(LargeListVector vector) {\n+    this(vector, NullableStructWriterFactory.getNullableStructWriterFactoryInstance());\n+  }\n+\n+  public UnionLargeListWriter(LargeListVector vector, NullableStructWriterFactory nullableStructWriterFactory) {\n+    this.vector = vector;\n+    this.writer = new PromotableWriter(vector.getDataVector(), vector, nullableStructWriterFactory);\n+  }\n+\n+  public UnionLargeListWriter(LargeListVector vector, AbstractFieldWriter parent) {\n+    this(vector);\n+  }\n+\n+  @Override\n+  public void allocate() {\n+    vector.allocateNew();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    vector.clear();\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return vector.getField();\n+  }\n+\n+  public void setValueCount(int count) {\n+    vector.setValueCount(count);\n+  }\n+\n+  @Override\n+  public int getValueCapacity() {\n+    return vector.getValueCapacity();\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    vector.close();\n+    writer.close();\n+  }\n+\n+  @Override\n+  public void setPosition(int index) {\n+    throw new UnsupportedOperationException(\"cant set int index for long list\");\n+  }\n+\n+  public void setIndex(long index) {\n+    this.index = index;\n+  }\n+  <#list vv.types as type><#list type.minor as minor><#assign name = minor.class?cap_first />\n+  <#assign fields = minor.fields!type.fields />\n+  <#assign uncappedName = name?uncap_first/>\n+  <#if uncappedName == \"int\" ><#assign uncappedName = \"integer\" /></#if>\n+  <#if !minor.typeParams?? >\n+\n+  @Override\n+  public ${name}Writer ${uncappedName}() {\n+    return this;\n+  }\n+\n+  @Override\n+  public ${name}Writer ${uncappedName}(String name) {\n+    structName = name;\n+    return writer.${uncappedName}(name);\n+  }\n+  </#if>\n+  </#list></#list>\n+\n+  @Override\n+  public DecimalWriter decimal() {\n+    return this;\n+  }\n+\n+  @Override\n+  public DecimalWriter decimal(String name, int scale, int precision) {\n+    return writer.decimal(name, scale, precision);\n+  }\n+\n+  @Override\n+  public DecimalWriter decimal(String name) {\n+    return writer.decimal(name);\n+  }\n+\n+  @Override\n+  public StructWriter struct() {\n+    inStruct = true;\n+    return this;\n+  }\n+\n+  @Override\n+  public ListWriter list() {\n+    return writer;\n+  }\n+\n+  @Override\n+  public ListWriter list(String name) {\n+    ListWriter listWriter = writer.list(name);\n+    return listWriter;\n+  }\n+\n+  @Override\n+  public StructWriter struct(String name) {\n+    StructWriter structWriter = writer.struct(name);\n+    return structWriter;\n+  }\n+\n+  @Override\n+  public void startList() {\n+    vector.startNewValue(index);\n+    writer.setPosition(checkedCastToInt(vector.getOffsetBuffer().getLong((index + 1) * OFFSET_WIDTH)));\n+  }\n+\n+  @Override\n+  public void endList() {\n+    vector.getOffsetBuffer().setLong((index + 1) * OFFSET_WIDTH, writer.idx());\n\nReview comment:\n       Here we need to cast the first argument, too. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-12T11:53:01.875+0000",
                    "updated": "2020-06-12T11:53:01.875+0000",
                    "started": "2020-06-12T11:53:01.875+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "444822",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/444823",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#discussion_r439375810\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\n##########\n@@ -73,6 +87,28 @@ public static void setBit(ArrowBuf validityBuffer, int index) {\n     validityBuffer.setByte(byteIndex, currentByte);\n   }\n \n+  /**\n+   * Set the bit at provided index to 1.\n+   *\n+   * @param validityBuffer validity buffer of the vector\n+   * @param index index to be set\n+   */\n+  public static void setBit(ArrowBuf validityBuffer, long index) {\n+    // it can be observed that some logic is duplicate of the logic in setValidityBit.\n\nReview comment:\n       I think we can replace the old implementation \r\n   ```\r\n   void setBit(ArrowBuf validityBuffer, int index)\r\n   ```\r\n   with this one, as now ArrowBuf is based on 64-bit index. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-12T11:57:52.398+0000",
                    "updated": "2020-06-12T11:57:52.398+0000",
                    "started": "2020-06-12T11:57:52.398+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "444823",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/444824",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#discussion_r439376364\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compare/RangeEqualsVisitor.java\n##########\n@@ -494,4 +505,46 @@ protected boolean compareFixedSizeListVectors(Range range) {\n     }\n     return true;\n   }\n+\n+  protected boolean compareLargeListVectors(Range range) {\n+    LargeListVector leftVector = (LargeListVector) left;\n+    LargeListVector rightVector = (LargeListVector) right;\n+\n+    RangeEqualsVisitor innerVisitor =\n+        createInnerVisitor(leftVector.getDataVector(), rightVector.getDataVector(), /*type comparator*/ null);\n+    Range innerRange = new Range();\n+\n+    for (int i = 0; i < range.getLength(); i++) {\n+      int leftIndex = range.getLeftStart() + i;\n+      int rightIndex = range.getRightStart() + i;\n+\n+      boolean isNull = leftVector.isNull(leftIndex);\n+      if (isNull != rightVector.isNull(rightIndex)) {\n+        return false;\n+      }\n+\n+      int offsetWidth = LargeListVector.OFFSET_WIDTH;\n+\n+      if (!isNull) {\n+        final long startIndexLeft = leftVector.getOffsetBuffer().getLong(leftIndex * offsetWidth);\n\nReview comment:\n       Here we need to cast getLong argument to long. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-12T11:59:25.779+0000",
                    "updated": "2020-06-12T11:59:25.779+0000",
                    "started": "2020-06-12T11:59:25.779+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "444824",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/444854",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on a change in pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#discussion_r439398445\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n\nReview comment:\n       We need to cast (numRecords + 1) to long. Otherwise, integer overflow may happen before promoting the result to long. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-12T12:50:06.907+0000",
                    "updated": "2020-06-12T12:50:06.907+0000",
                    "started": "2020-06-12T12:50:06.907+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "444854",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/446612",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rymurr commented on a change in pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#discussion_r440974308\n\n\n\n##########\nFile path: java/vector/src/main/codegen/templates/UnionLargeListWriter.java\n##########\n@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.complex.writer.DecimalWriter;\n+import org.apache.arrow.vector.holders.DecimalHolder;\n+\n+import java.lang.UnsupportedOperationException;\n+import java.math.BigDecimal;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/UnionLargeListWriter.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+package org.apache.arrow.vector.complex.impl;\n+\n+    import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+<#include \"/@includes/vv_imports.ftl\" />\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+\n+@SuppressWarnings(\"unused\")\n+public class UnionLargeListWriter extends AbstractFieldWriter {\n+\n+  protected LargeListVector vector;\n+  protected PromotableWriter writer;\n+  private long index = 0L;\n+  private boolean inStruct = false;\n+  private String structName;\n+  private static final int OFFSET_WIDTH = 8;\n+\n+  public UnionLargeListWriter(LargeListVector vector) {\n+    this(vector, NullableStructWriterFactory.getNullableStructWriterFactoryInstance());\n+  }\n+\n+  public UnionLargeListWriter(LargeListVector vector, NullableStructWriterFactory nullableStructWriterFactory) {\n+    this.vector = vector;\n+    this.writer = new PromotableWriter(vector.getDataVector(), vector, nullableStructWriterFactory);\n+  }\n+\n+  public UnionLargeListWriter(LargeListVector vector, AbstractFieldWriter parent) {\n+    this(vector);\n+  }\n+\n+  @Override\n+  public void allocate() {\n+    vector.allocateNew();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    vector.clear();\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return vector.getField();\n+  }\n+\n+  public void setValueCount(int count) {\n+    vector.setValueCount(count);\n+  }\n+\n+  @Override\n+  public int getValueCapacity() {\n+    return vector.getValueCapacity();\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    vector.close();\n+    writer.close();\n+  }\n+\n+  @Override\n+  public void setPosition(int index) {\n+    throw new UnsupportedOperationException(\"cant set int index for long list\");\n+  }\n+\n+  public void setIndex(long index) {\n+    this.index = index;\n+  }\n+  <#list vv.types as type><#list type.minor as minor><#assign name = minor.class?cap_first />\n+  <#assign fields = minor.fields!type.fields />\n+  <#assign uncappedName = name?uncap_first/>\n+  <#if uncappedName == \"int\" ><#assign uncappedName = \"integer\" /></#if>\n+  <#if !minor.typeParams?? >\n+\n+  @Override\n+  public ${name}Writer ${uncappedName}() {\n+    return this;\n+  }\n+\n+  @Override\n+  public ${name}Writer ${uncappedName}(String name) {\n+    structName = name;\n+    return writer.${uncappedName}(name);\n+  }\n+  </#if>\n+  </#list></#list>\n+\n+  @Override\n+  public DecimalWriter decimal() {\n+    return this;\n+  }\n+\n+  @Override\n+  public DecimalWriter decimal(String name, int scale, int precision) {\n+    return writer.decimal(name, scale, precision);\n+  }\n+\n+  @Override\n+  public DecimalWriter decimal(String name) {\n+    return writer.decimal(name);\n+  }\n+\n+  @Override\n+  public StructWriter struct() {\n+    inStruct = true;\n+    return this;\n+  }\n+\n+  @Override\n+  public ListWriter list() {\n+    return writer;\n+  }\n+\n+  @Override\n+  public ListWriter list(String name) {\n+    ListWriter listWriter = writer.list(name);\n+    return listWriter;\n+  }\n+\n+  @Override\n+  public StructWriter struct(String name) {\n+    StructWriter structWriter = writer.struct(name);\n+    return structWriter;\n+  }\n+\n+  @Override\n+  public void startList() {\n+    vector.startNewValue(index);\n+    writer.setPosition(checkedCastToInt(vector.getOffsetBuffer().getLong((index + 1) * OFFSET_WIDTH)));\n\nReview comment:\n       Hey @liyafan82 not sure what you mean. `getLong` returns `long` and `checkedCastToInt` takes a `long`. Sorry if I am missing something obvious\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T16:13:18.271+0000",
                    "updated": "2020-06-16T16:13:18.271+0000",
                    "started": "2020-06-16T16:13:18.271+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446612",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/446620",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rymurr commented on a change in pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#discussion_r440974308\n\n\n\n##########\nFile path: java/vector/src/main/codegen/templates/UnionLargeListWriter.java\n##########\n@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.complex.writer.DecimalWriter;\n+import org.apache.arrow.vector.holders.DecimalHolder;\n+\n+import java.lang.UnsupportedOperationException;\n+import java.math.BigDecimal;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/UnionLargeListWriter.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+package org.apache.arrow.vector.complex.impl;\n+\n+    import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+<#include \"/@includes/vv_imports.ftl\" />\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+\n+@SuppressWarnings(\"unused\")\n+public class UnionLargeListWriter extends AbstractFieldWriter {\n+\n+  protected LargeListVector vector;\n+  protected PromotableWriter writer;\n+  private long index = 0L;\n+  private boolean inStruct = false;\n+  private String structName;\n+  private static final int OFFSET_WIDTH = 8;\n+\n+  public UnionLargeListWriter(LargeListVector vector) {\n+    this(vector, NullableStructWriterFactory.getNullableStructWriterFactoryInstance());\n+  }\n+\n+  public UnionLargeListWriter(LargeListVector vector, NullableStructWriterFactory nullableStructWriterFactory) {\n+    this.vector = vector;\n+    this.writer = new PromotableWriter(vector.getDataVector(), vector, nullableStructWriterFactory);\n+  }\n+\n+  public UnionLargeListWriter(LargeListVector vector, AbstractFieldWriter parent) {\n+    this(vector);\n+  }\n+\n+  @Override\n+  public void allocate() {\n+    vector.allocateNew();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    vector.clear();\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return vector.getField();\n+  }\n+\n+  public void setValueCount(int count) {\n+    vector.setValueCount(count);\n+  }\n+\n+  @Override\n+  public int getValueCapacity() {\n+    return vector.getValueCapacity();\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    vector.close();\n+    writer.close();\n+  }\n+\n+  @Override\n+  public void setPosition(int index) {\n+    throw new UnsupportedOperationException(\"cant set int index for long list\");\n+  }\n+\n+  public void setIndex(long index) {\n+    this.index = index;\n+  }\n+  <#list vv.types as type><#list type.minor as minor><#assign name = minor.class?cap_first />\n+  <#assign fields = minor.fields!type.fields />\n+  <#assign uncappedName = name?uncap_first/>\n+  <#if uncappedName == \"int\" ><#assign uncappedName = \"integer\" /></#if>\n+  <#if !minor.typeParams?? >\n+\n+  @Override\n+  public ${name}Writer ${uncappedName}() {\n+    return this;\n+  }\n+\n+  @Override\n+  public ${name}Writer ${uncappedName}(String name) {\n+    structName = name;\n+    return writer.${uncappedName}(name);\n+  }\n+  </#if>\n+  </#list></#list>\n+\n+  @Override\n+  public DecimalWriter decimal() {\n+    return this;\n+  }\n+\n+  @Override\n+  public DecimalWriter decimal(String name, int scale, int precision) {\n+    return writer.decimal(name, scale, precision);\n+  }\n+\n+  @Override\n+  public DecimalWriter decimal(String name) {\n+    return writer.decimal(name);\n+  }\n+\n+  @Override\n+  public StructWriter struct() {\n+    inStruct = true;\n+    return this;\n+  }\n+\n+  @Override\n+  public ListWriter list() {\n+    return writer;\n+  }\n+\n+  @Override\n+  public ListWriter list(String name) {\n+    ListWriter listWriter = writer.list(name);\n+    return listWriter;\n+  }\n+\n+  @Override\n+  public StructWriter struct(String name) {\n+    StructWriter structWriter = writer.struct(name);\n+    return structWriter;\n+  }\n+\n+  @Override\n+  public void startList() {\n+    vector.startNewValue(index);\n+    writer.setPosition(checkedCastToInt(vector.getOffsetBuffer().getLong((index + 1) * OFFSET_WIDTH)));\n\nReview comment:\n       Hey @liyafan82 not sure what you mean. `getLong` returns `long` and `checkedCastToInt` takes a `long`. Sorry if I am missing something obvious\n\n##########\nFile path: java/vector/src/main/codegen/templates/UnionLargeListWriter.java\n##########\n@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.complex.writer.DecimalWriter;\n+import org.apache.arrow.vector.holders.DecimalHolder;\n+\n+import java.lang.UnsupportedOperationException;\n+import java.math.BigDecimal;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/UnionLargeListWriter.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+package org.apache.arrow.vector.complex.impl;\n+\n+    import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+<#include \"/@includes/vv_imports.ftl\" />\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+\n+@SuppressWarnings(\"unused\")\n+public class UnionLargeListWriter extends AbstractFieldWriter {\n+\n+  protected LargeListVector vector;\n+  protected PromotableWriter writer;\n+  private long index = 0L;\n+  private boolean inStruct = false;\n+  private String structName;\n+  private static final int OFFSET_WIDTH = 8;\n+\n+  public UnionLargeListWriter(LargeListVector vector) {\n+    this(vector, NullableStructWriterFactory.getNullableStructWriterFactoryInstance());\n+  }\n+\n+  public UnionLargeListWriter(LargeListVector vector, NullableStructWriterFactory nullableStructWriterFactory) {\n+    this.vector = vector;\n+    this.writer = new PromotableWriter(vector.getDataVector(), vector, nullableStructWriterFactory);\n+  }\n+\n+  public UnionLargeListWriter(LargeListVector vector, AbstractFieldWriter parent) {\n+    this(vector);\n+  }\n+\n+  @Override\n+  public void allocate() {\n+    vector.allocateNew();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    vector.clear();\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return vector.getField();\n+  }\n+\n+  public void setValueCount(int count) {\n+    vector.setValueCount(count);\n+  }\n+\n+  @Override\n+  public int getValueCapacity() {\n+    return vector.getValueCapacity();\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    vector.close();\n+    writer.close();\n+  }\n+\n+  @Override\n+  public void setPosition(int index) {\n+    throw new UnsupportedOperationException(\"cant set int index for long list\");\n+  }\n+\n+  public void setIndex(long index) {\n+    this.index = index;\n+  }\n+  <#list vv.types as type><#list type.minor as minor><#assign name = minor.class?cap_first />\n+  <#assign fields = minor.fields!type.fields />\n+  <#assign uncappedName = name?uncap_first/>\n+  <#if uncappedName == \"int\" ><#assign uncappedName = \"integer\" /></#if>\n+  <#if !minor.typeParams?? >\n+\n+  @Override\n+  public ${name}Writer ${uncappedName}() {\n+    return this;\n+  }\n+\n+  @Override\n+  public ${name}Writer ${uncappedName}(String name) {\n+    structName = name;\n+    return writer.${uncappedName}(name);\n+  }\n+  </#if>\n+  </#list></#list>\n+\n+  @Override\n+  public DecimalWriter decimal() {\n+    return this;\n+  }\n+\n+  @Override\n+  public DecimalWriter decimal(String name, int scale, int precision) {\n+    return writer.decimal(name, scale, precision);\n+  }\n+\n+  @Override\n+  public DecimalWriter decimal(String name) {\n+    return writer.decimal(name);\n+  }\n+\n+  @Override\n+  public StructWriter struct() {\n+    inStruct = true;\n+    return this;\n+  }\n+\n+  @Override\n+  public ListWriter list() {\n+    return writer;\n+  }\n+\n+  @Override\n+  public ListWriter list(String name) {\n+    ListWriter listWriter = writer.list(name);\n+    return listWriter;\n+  }\n+\n+  @Override\n+  public StructWriter struct(String name) {\n+    StructWriter structWriter = writer.struct(name);\n+    return structWriter;\n+  }\n+\n+  @Override\n+  public void startList() {\n+    vector.startNewValue(index);\n+    writer.setPosition(checkedCastToInt(vector.getOffsetBuffer().getLong((index + 1) * OFFSET_WIDTH)));\n\nReview comment:\n       done\n\n##########\nFile path: java/vector/src/main/codegen/templates/UnionLargeListWriter.java\n##########\n@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.complex.writer.DecimalWriter;\n+import org.apache.arrow.vector.holders.DecimalHolder;\n+\n+import java.lang.UnsupportedOperationException;\n+import java.math.BigDecimal;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/UnionLargeListWriter.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+package org.apache.arrow.vector.complex.impl;\n+\n+    import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+<#include \"/@includes/vv_imports.ftl\" />\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+\n+@SuppressWarnings(\"unused\")\n+public class UnionLargeListWriter extends AbstractFieldWriter {\n+\n+  protected LargeListVector vector;\n+  protected PromotableWriter writer;\n+  private long index = 0L;\n+  private boolean inStruct = false;\n+  private String structName;\n+  private static final int OFFSET_WIDTH = 8;\n+\n+  public UnionLargeListWriter(LargeListVector vector) {\n+    this(vector, NullableStructWriterFactory.getNullableStructWriterFactoryInstance());\n+  }\n+\n+  public UnionLargeListWriter(LargeListVector vector, NullableStructWriterFactory nullableStructWriterFactory) {\n+    this.vector = vector;\n+    this.writer = new PromotableWriter(vector.getDataVector(), vector, nullableStructWriterFactory);\n+  }\n+\n+  public UnionLargeListWriter(LargeListVector vector, AbstractFieldWriter parent) {\n+    this(vector);\n+  }\n+\n+  @Override\n+  public void allocate() {\n+    vector.allocateNew();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    vector.clear();\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return vector.getField();\n+  }\n+\n+  public void setValueCount(int count) {\n+    vector.setValueCount(count);\n+  }\n+\n+  @Override\n+  public int getValueCapacity() {\n+    return vector.getValueCapacity();\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    vector.close();\n+    writer.close();\n+  }\n+\n+  @Override\n+  public void setPosition(int index) {\n+    throw new UnsupportedOperationException(\"cant set int index for long list\");\n+  }\n+\n+  public void setIndex(long index) {\n+    this.index = index;\n+  }\n+  <#list vv.types as type><#list type.minor as minor><#assign name = minor.class?cap_first />\n+  <#assign fields = minor.fields!type.fields />\n+  <#assign uncappedName = name?uncap_first/>\n+  <#if uncappedName == \"int\" ><#assign uncappedName = \"integer\" /></#if>\n+  <#if !minor.typeParams?? >\n+\n+  @Override\n+  public ${name}Writer ${uncappedName}() {\n+    return this;\n+  }\n+\n+  @Override\n+  public ${name}Writer ${uncappedName}(String name) {\n+    structName = name;\n+    return writer.${uncappedName}(name);\n+  }\n+  </#if>\n+  </#list></#list>\n+\n+  @Override\n+  public DecimalWriter decimal() {\n+    return this;\n+  }\n+\n+  @Override\n+  public DecimalWriter decimal(String name, int scale, int precision) {\n+    return writer.decimal(name, scale, precision);\n+  }\n+\n+  @Override\n+  public DecimalWriter decimal(String name) {\n+    return writer.decimal(name);\n+  }\n+\n+  @Override\n+  public StructWriter struct() {\n+    inStruct = true;\n+    return this;\n+  }\n+\n+  @Override\n+  public ListWriter list() {\n+    return writer;\n+  }\n+\n+  @Override\n+  public ListWriter list(String name) {\n+    ListWriter listWriter = writer.list(name);\n+    return listWriter;\n+  }\n+\n+  @Override\n+  public StructWriter struct(String name) {\n+    StructWriter structWriter = writer.struct(name);\n+    return structWriter;\n+  }\n+\n+  @Override\n+  public void startList() {\n+    vector.startNewValue(index);\n+    writer.setPosition(checkedCastToInt(vector.getOffsetBuffer().getLong((index + 1) * OFFSET_WIDTH)));\n+  }\n+\n+  @Override\n+  public void endList() {\n+    vector.getOffsetBuffer().setLong((index + 1) * OFFSET_WIDTH, writer.idx());\n\nReview comment:\n       done\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T16:23:56.383+0000",
                    "updated": "2020-06-16T16:23:56.383+0000",
                    "started": "2020-06-16T16:23:56.382+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446620",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/446621",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rymurr commented on a change in pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#discussion_r440981167\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/compare/RangeEqualsVisitor.java\n##########\n@@ -494,4 +505,46 @@ protected boolean compareFixedSizeListVectors(Range range) {\n     }\n     return true;\n   }\n+\n+  protected boolean compareLargeListVectors(Range range) {\n+    LargeListVector leftVector = (LargeListVector) left;\n+    LargeListVector rightVector = (LargeListVector) right;\n+\n+    RangeEqualsVisitor innerVisitor =\n+        createInnerVisitor(leftVector.getDataVector(), rightVector.getDataVector(), /*type comparator*/ null);\n+    Range innerRange = new Range();\n+\n+    for (int i = 0; i < range.getLength(); i++) {\n+      int leftIndex = range.getLeftStart() + i;\n+      int rightIndex = range.getRightStart() + i;\n+\n+      boolean isNull = leftVector.isNull(leftIndex);\n+      if (isNull != rightVector.isNull(rightIndex)) {\n+        return false;\n+      }\n+\n+      int offsetWidth = LargeListVector.OFFSET_WIDTH;\n+\n+      if (!isNull) {\n+        final long startIndexLeft = leftVector.getOffsetBuffer().getLong(leftIndex * offsetWidth);\n\nReview comment:\n       done\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T16:24:09.521+0000",
                    "updated": "2020-06-16T16:24:09.521+0000",
                    "started": "2020-06-16T16:24:09.521+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446621",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/446624",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rymurr commented on a change in pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#discussion_r440981394\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\n##########\n@@ -73,6 +87,28 @@ public static void setBit(ArrowBuf validityBuffer, int index) {\n     validityBuffer.setByte(byteIndex, currentByte);\n   }\n \n+  /**\n+   * Set the bit at provided index to 1.\n+   *\n+   * @param validityBuffer validity buffer of the vector\n+   * @param index index to be set\n+   */\n+  public static void setBit(ArrowBuf validityBuffer, long index) {\n+    // it can be observed that some logic is duplicate of the logic in setValidityBit.\n\nReview comment:\n       done\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T16:24:36.933+0000",
                    "updated": "2020-06-16T16:24:36.933+0000",
                    "started": "2020-06-16T16:24:36.932+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446624",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/446628",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rymurr commented on a change in pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#discussion_r440982045\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n\nReview comment:\n       done\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-16T16:25:36.137+0000",
                    "updated": "2020-06-16T16:25:36.137+0000",
                    "started": "2020-06-16T16:25:36.137+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "446628",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/450482",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#issuecomment-648886550\n\n\n   Is this good to merge now? @BryanCutler are you still planning to review this? Would like to get this in 1.0.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-24T15:19:45.870+0000",
                    "updated": "2020-06-24T15:19:45.870+0000",
                    "started": "2020-06-24T15:19:45.869+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "450482",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/453078",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#issuecomment-651984931\n\n\n   > Is this good to merge now? @BryanCutler are you still planning to review this? Would like to get this in 1.0.\r\n   \r\n   I'm taking a look now, I'd like to get it in for 1.0 too.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-30T19:03:31.241+0000",
                    "updated": "2020-06-30T19:03:31.241+0000",
                    "started": "2020-06-30T19:03:31.241+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "453078",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/453161",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on a change in pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#discussion_r447866233\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\n##########\n@@ -73,6 +87,28 @@ public static void setBit(ArrowBuf validityBuffer, int index) {\n     validityBuffer.setByte(byteIndex, currentByte);\n   }\n \n+  /**\n+   * Set the bit at provided index to 1.\n+   *\n+   * @param validityBuffer validity buffer of the vector\n+   * @param index index to be set\n+   */\n+  public static void setBit(ArrowBuf validityBuffer, long index) {\n+    // it can be observed that some logic is duplicate of the logic in setValidityBit.\n\nReview comment:\n       please update the link in `setValidityBitToOne` here https://github.com/apache/arrow/pull/7275/files#diff-bc5e2a2a1b6b348c39f57c91defb855bL79\n\n##########\nFile path: java/vector/src/main/codegen/templates/UnionLargeListWriter.java\n##########\n@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.vector.complex.writer.DecimalWriter;\n+import org.apache.arrow.vector.holders.DecimalHolder;\n+\n+import java.lang.UnsupportedOperationException;\n+import java.math.BigDecimal;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/UnionLargeListWriter.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+package org.apache.arrow.vector.complex.impl;\n+\n+    import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+<#include \"/@includes/vv_imports.ftl\" />\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+\n+@SuppressWarnings(\"unused\")\n+public class UnionLargeListWriter extends AbstractFieldWriter {\n\nReview comment:\n       It would be nice not to add a new template and combine with the UnionListWriter if possible. That doesn't have to be done here though, it can be looked at later.\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\n##########\n@@ -37,6 +37,20 @@\n \n   private BitVectorHelper() {}\n \n+  /**\n+   * Get the index of byte corresponding to bit index in validity buffer.\n+   */\n+  public static long byteIndex(long absoluteBitIndex) {\n+    return absoluteBitIndex >> 3;\n+  }\n+\n+  /**\n+   * Get the relative index of bit within the byte in validity buffer.\n+   */\n+  public static long bitIndex(long absoluteBitIndex) {\n\nReview comment:\n       Since this is the relative bit index, it's not possible to return long. Can you change return value to an `int`?\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n\nReview comment:\n       This logic seems to deviate from `ListVector.reallocateOffsetBuffer`, could you explain the reason for the difference? I don't see the case if `newAllocationSize` == 0.\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n\nReview comment:\n       maybe `throw new UnsupportedOperationException(\"There is no inner offset vector\");` which is the behavior of `ListVector`?\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the inner data vector for this list vector.\n+   * @return data vector\n+   */\n+  @Override\n+  public FieldVector getDataVector() {\n+    return vector;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((LargeListVector) target);\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return (offsetBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  @Override\n+  public int hashCode(int index) {\n+    return hashCode(index, null);\n+  }\n+\n+  @Override\n+  public int hashCode(int index, ArrowBufHasher hasher) {\n+    if (isSet(index) == 0) {\n+      return ArrowBufPointer.NULL_HASH_CODE;\n+    }\n+    int hash = 0;\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    for (long i = start; i < end; i++) {\n+      hash = ByteFunctionHelpers.combineHash(hash, vector.hashCode(checkedCastToInt(i), hasher));\n+    }\n+    return hash;\n+  }\n+\n+  @Override\n+  public <OUT, IN> OUT accept(VectorVisitor<OUT, IN> visitor, IN value) {\n+    return visitor.visit(this, value);\n+  }\n+\n+  public UnionLargeListWriter getWriter() {\n+    return new UnionLargeListWriter(this);\n+  }\n+\n+  protected void replaceDataVector(FieldVector v) {\n+    vector.clear();\n+    vector = v;\n+  }\n+\n+  @Override\n+  public UnionVector promoteToUnion() {\n+    UnionVector vector = new UnionVector(\"$data$\", allocator, callBack);\n+    replaceDataVector(vector);\n+    invalidateReader();\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return vector;\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+\n+    LargeListVector to;\n+    TransferPair dataTransferPair;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(new LargeListVector(name, allocator, fieldType, callBack));\n+    }\n+\n+    public TransferImpl(LargeListVector to) {\n+      this.to = to;\n+      to.addOrGetVector(vector.getField().getFieldType());\n+      if (to.getDataVector() instanceof ZeroVector) {\n+        to.addOrGetVector(vector.getField().getFieldType());\n+      }\n+      dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n+    }\n+\n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = transferBuffer(validityBuffer, to.allocator);\n+      to.offsetBuffer = transferBuffer(offsetBuffer, to.allocator);\n+      to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n+    }\n+\n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      Preconditions.checkArgument(startIndex >= 0 && length >= 0 && startIndex + length <= valueCount,\n+          \"Invalid parameters startIndex: %s, length: %s for valueCount: %s\", startIndex, length, valueCount);\n+      final long startPoint = offsetBuffer.getLong(startIndex * OFFSET_WIDTH);\n+      final long sliceLength = offsetBuffer.getLong((startIndex + length) * OFFSET_WIDTH) - startPoint;\n+      to.clear();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n+      for (int i = 0; i < length + 1; i++) {\n+        final long relativeOffset = offsetBuffer.getLong((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setLong(i * OFFSET_WIDTH, relativeOffset);\n+      }\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n+      dataTransferPair.splitAndTransfer(checkedCastToInt(startPoint), checkedCastToInt(sliceLength));\n+      to.lastSet = length - 1;\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, LargeListVector target) {\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.getReferenceManager().release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.getReferenceManager().retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, LargeListVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public UnionLargeListReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionLargeListReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * Initialize the data vector (and execute callback) if it hasn't already been done,\n+   * returns the data vector.\n+   */\n+  public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+    boolean created = false;\n+    if (vector instanceof NullVector) {\n+      vector = fieldType.createNewSingleVector(defaultDataVectorName, allocator, callBack);\n+      // returned vector must have the same field\n+      created = true;\n+      if (callBack != null &&\n+          // not a schema change if changing from ZeroVector to ZeroVector\n+          (fieldType.getType().getTypeID() != ArrowType.ArrowTypeID.Null)) {\n+        callBack.doWork();\n+      }\n+    }\n+\n+    if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+      final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+      throw new SchemaChangeRuntimeException(msg);\n+    }\n+\n+    invalidateReader();\n+    return new AddOrGetResult<>((T) vector, created);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n+  }\n+  \n+  @Override\n+  public int getBufferSizeFor(int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    long innerVectorValueCount = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+\n+    return ((valueCount + 1) * OFFSET_WIDTH) +\n+        vector.getBufferSizeFor(checkedCastToInt(innerVectorValueCount)) +\n+        validityBufferSize;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return new Field(getName(), fieldType, Collections.singletonList(getDataVector().getField()));\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.LIST;\n\nReview comment:\n       LARGELIST\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileReader.java\n##########\n@@ -564,8 +564,10 @@ private ArrowBuf readIntoBuffer(BufferAllocator allocator, BufferType bufferType\n     } else if (bufferType.equals(OFFSET)) {\n       if (type == Types.MinorType.LARGEVARCHAR || type == Types.MinorType.LARGEVARBINARY) {\n\nReview comment:\n       could you add a check for `Types.MinorType.LARGELIST` here are remove the changes below?\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the inner data vector for this list vector.\n+   * @return data vector\n+   */\n+  @Override\n+  public FieldVector getDataVector() {\n+    return vector;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((LargeListVector) target);\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return (offsetBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  @Override\n+  public int hashCode(int index) {\n+    return hashCode(index, null);\n+  }\n+\n+  @Override\n+  public int hashCode(int index, ArrowBufHasher hasher) {\n+    if (isSet(index) == 0) {\n+      return ArrowBufPointer.NULL_HASH_CODE;\n+    }\n+    int hash = 0;\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    for (long i = start; i < end; i++) {\n+      hash = ByteFunctionHelpers.combineHash(hash, vector.hashCode(checkedCastToInt(i), hasher));\n+    }\n+    return hash;\n+  }\n+\n+  @Override\n+  public <OUT, IN> OUT accept(VectorVisitor<OUT, IN> visitor, IN value) {\n+    return visitor.visit(this, value);\n+  }\n+\n+  public UnionLargeListWriter getWriter() {\n+    return new UnionLargeListWriter(this);\n+  }\n+\n+  protected void replaceDataVector(FieldVector v) {\n+    vector.clear();\n+    vector = v;\n+  }\n+\n+  @Override\n+  public UnionVector promoteToUnion() {\n+    UnionVector vector = new UnionVector(\"$data$\", allocator, callBack);\n+    replaceDataVector(vector);\n+    invalidateReader();\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return vector;\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+\n+    LargeListVector to;\n+    TransferPair dataTransferPair;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(new LargeListVector(name, allocator, fieldType, callBack));\n+    }\n+\n+    public TransferImpl(LargeListVector to) {\n+      this.to = to;\n+      to.addOrGetVector(vector.getField().getFieldType());\n+      if (to.getDataVector() instanceof ZeroVector) {\n+        to.addOrGetVector(vector.getField().getFieldType());\n+      }\n+      dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n+    }\n+\n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = transferBuffer(validityBuffer, to.allocator);\n+      to.offsetBuffer = transferBuffer(offsetBuffer, to.allocator);\n+      to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n+    }\n+\n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      Preconditions.checkArgument(startIndex >= 0 && length >= 0 && startIndex + length <= valueCount,\n+          \"Invalid parameters startIndex: %s, length: %s for valueCount: %s\", startIndex, length, valueCount);\n+      final long startPoint = offsetBuffer.getLong(startIndex * OFFSET_WIDTH);\n+      final long sliceLength = offsetBuffer.getLong((startIndex + length) * OFFSET_WIDTH) - startPoint;\n+      to.clear();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n+      for (int i = 0; i < length + 1; i++) {\n+        final long relativeOffset = offsetBuffer.getLong((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setLong(i * OFFSET_WIDTH, relativeOffset);\n+      }\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n+      dataTransferPair.splitAndTransfer(checkedCastToInt(startPoint), checkedCastToInt(sliceLength));\n+      to.lastSet = length - 1;\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, LargeListVector target) {\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.getReferenceManager().release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.getReferenceManager().retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, LargeListVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public UnionLargeListReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionLargeListReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * Initialize the data vector (and execute callback) if it hasn't already been done,\n+   * returns the data vector.\n+   */\n+  public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+    boolean created = false;\n+    if (vector instanceof NullVector) {\n+      vector = fieldType.createNewSingleVector(defaultDataVectorName, allocator, callBack);\n+      // returned vector must have the same field\n+      created = true;\n+      if (callBack != null &&\n+          // not a schema change if changing from ZeroVector to ZeroVector\n+          (fieldType.getType().getTypeID() != ArrowType.ArrowTypeID.Null)) {\n+        callBack.doWork();\n+      }\n+    }\n+\n+    if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+      final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+      throw new SchemaChangeRuntimeException(msg);\n+    }\n+\n+    invalidateReader();\n+    return new AddOrGetResult<>((T) vector, created);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n+  }\n+  \n+  @Override\n+  public int getBufferSizeFor(int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    long innerVectorValueCount = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+\n+    return ((valueCount + 1) * OFFSET_WIDTH) +\n+        vector.getBufferSizeFor(checkedCastToInt(innerVectorValueCount)) +\n+        validityBufferSize;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return new Field(getName(), fieldType, Collections.singletonList(getDataVector().getField()));\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.LIST;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    vector.clear();\n+    valueCount = 0;\n+    super.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    lastSet = -1;\n+  }\n+\n+  @Override\n+  public void reset() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    vector.reset();\n+    valueCount = 0;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      List<ArrowBuf> list = new ArrayList<>();\n+      list.add(offsetBuffer);\n+      list.add(validityBuffer);\n+      list.addAll(Arrays.asList(vector.getBuffers(false)));\n+      buffers = list.toArray(new ArrowBuf[list.size()]);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  protected void invalidateReader() {\n+    reader = null;\n+  }\n+\n+  /**\n+   * Get the element in the list vector at a particular index.\n+   * @param index position of the element\n+   * @return Object at given position\n+   */\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (long i = start; i < end; i++) {\n+      vals.add(vv.getObject(checkedCastToInt(i)));\n+    }\n+\n+    return vals;\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index position of element\n+   * @return true if element at given index is null, false otherwise\n+   */\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Check if element at given index is empty list.\n+   * @param index position of element\n+   * @return true if element at given index is empty list or NULL, false otherwise\n+   */\n+  public boolean isEmpty(int index) {\n+    if (isNull(index)) {\n+      return true;\n+    } else {\n+      final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+      final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+      return start == end;\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return (b >> bitIndex) & 0x01;\n+  }\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return getValidityAndOffsetValueCapacity();\n+  }\n+  \n+  protected int getOffsetBufferValueCapacity() {\n+    return checkedCastToInt(offsetBuffer.capacity() / OFFSET_WIDTH);\n+  }\n+  \n+  private int getValidityAndOffsetValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return capAtMaxInt(validityBuffer.capacity() * 8);\n+  }\n+\n+  /**\n+   * Sets the list at index to be not-null.  Reallocates validity buffer if index\n+   * is larger than current capacity.\n+   */\n+  public void setNotNull(int index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Start a new value in the list vector.\n+   *\n+   * @param index index of the value to start\n+   */\n+  public long startNewValue(long index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    for (long i = lastSet + 1; i <= index; i++) {\n+      final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+      offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+    return checkedCastToInt(offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * End the current value.\n+   *\n+   * @param index index of the value to end\n+   * @param size  number of elements in the list that was written\n+   */\n+  public void endValue(int index, int size) {\n\nReview comment:\n       should `size` be long?\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the inner data vector for this list vector.\n+   * @return data vector\n+   */\n+  @Override\n+  public FieldVector getDataVector() {\n+    return vector;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((LargeListVector) target);\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return (offsetBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  @Override\n+  public int hashCode(int index) {\n+    return hashCode(index, null);\n+  }\n+\n+  @Override\n+  public int hashCode(int index, ArrowBufHasher hasher) {\n+    if (isSet(index) == 0) {\n+      return ArrowBufPointer.NULL_HASH_CODE;\n+    }\n+    int hash = 0;\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    for (long i = start; i < end; i++) {\n+      hash = ByteFunctionHelpers.combineHash(hash, vector.hashCode(checkedCastToInt(i), hasher));\n+    }\n+    return hash;\n+  }\n+\n+  @Override\n+  public <OUT, IN> OUT accept(VectorVisitor<OUT, IN> visitor, IN value) {\n+    return visitor.visit(this, value);\n+  }\n+\n+  public UnionLargeListWriter getWriter() {\n+    return new UnionLargeListWriter(this);\n+  }\n+\n+  protected void replaceDataVector(FieldVector v) {\n+    vector.clear();\n+    vector = v;\n+  }\n+\n+  @Override\n+  public UnionVector promoteToUnion() {\n+    UnionVector vector = new UnionVector(\"$data$\", allocator, callBack);\n+    replaceDataVector(vector);\n+    invalidateReader();\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return vector;\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+\n+    LargeListVector to;\n+    TransferPair dataTransferPair;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(new LargeListVector(name, allocator, fieldType, callBack));\n+    }\n+\n+    public TransferImpl(LargeListVector to) {\n+      this.to = to;\n+      to.addOrGetVector(vector.getField().getFieldType());\n+      if (to.getDataVector() instanceof ZeroVector) {\n+        to.addOrGetVector(vector.getField().getFieldType());\n+      }\n+      dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n+    }\n+\n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = transferBuffer(validityBuffer, to.allocator);\n+      to.offsetBuffer = transferBuffer(offsetBuffer, to.allocator);\n+      to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n+    }\n+\n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      Preconditions.checkArgument(startIndex >= 0 && length >= 0 && startIndex + length <= valueCount,\n+          \"Invalid parameters startIndex: %s, length: %s for valueCount: %s\", startIndex, length, valueCount);\n+      final long startPoint = offsetBuffer.getLong(startIndex * OFFSET_WIDTH);\n+      final long sliceLength = offsetBuffer.getLong((startIndex + length) * OFFSET_WIDTH) - startPoint;\n+      to.clear();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n+      for (int i = 0; i < length + 1; i++) {\n+        final long relativeOffset = offsetBuffer.getLong((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setLong(i * OFFSET_WIDTH, relativeOffset);\n+      }\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n+      dataTransferPair.splitAndTransfer(checkedCastToInt(startPoint), checkedCastToInt(sliceLength));\n+      to.lastSet = length - 1;\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, LargeListVector target) {\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.getReferenceManager().release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.getReferenceManager().retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, LargeListVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public UnionLargeListReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionLargeListReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * Initialize the data vector (and execute callback) if it hasn't already been done,\n+   * returns the data vector.\n+   */\n+  public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+    boolean created = false;\n+    if (vector instanceof NullVector) {\n+      vector = fieldType.createNewSingleVector(defaultDataVectorName, allocator, callBack);\n+      // returned vector must have the same field\n+      created = true;\n+      if (callBack != null &&\n+          // not a schema change if changing from ZeroVector to ZeroVector\n+          (fieldType.getType().getTypeID() != ArrowType.ArrowTypeID.Null)) {\n+        callBack.doWork();\n+      }\n+    }\n+\n+    if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+      final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+      throw new SchemaChangeRuntimeException(msg);\n+    }\n+\n+    invalidateReader();\n+    return new AddOrGetResult<>((T) vector, created);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n+  }\n+  \n+  @Override\n+  public int getBufferSizeFor(int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    long innerVectorValueCount = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+\n+    return ((valueCount + 1) * OFFSET_WIDTH) +\n+        vector.getBufferSizeFor(checkedCastToInt(innerVectorValueCount)) +\n+        validityBufferSize;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return new Field(getName(), fieldType, Collections.singletonList(getDataVector().getField()));\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.LIST;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    vector.clear();\n+    valueCount = 0;\n+    super.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    lastSet = -1;\n+  }\n+\n+  @Override\n+  public void reset() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    vector.reset();\n+    valueCount = 0;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      List<ArrowBuf> list = new ArrayList<>();\n+      list.add(offsetBuffer);\n+      list.add(validityBuffer);\n+      list.addAll(Arrays.asList(vector.getBuffers(false)));\n+      buffers = list.toArray(new ArrowBuf[list.size()]);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  protected void invalidateReader() {\n+    reader = null;\n+  }\n+\n+  /**\n+   * Get the element in the list vector at a particular index.\n+   * @param index position of the element\n+   * @return Object at given position\n+   */\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (long i = start; i < end; i++) {\n+      vals.add(vv.getObject(checkedCastToInt(i)));\n+    }\n+\n+    return vals;\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index position of element\n+   * @return true if element at given index is null, false otherwise\n+   */\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Check if element at given index is empty list.\n+   * @param index position of element\n+   * @return true if element at given index is empty list or NULL, false otherwise\n+   */\n+  public boolean isEmpty(int index) {\n+    if (isNull(index)) {\n+      return true;\n+    } else {\n+      final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+      final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+      return start == end;\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return (b >> bitIndex) & 0x01;\n+  }\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return getValidityAndOffsetValueCapacity();\n+  }\n+  \n+  protected int getOffsetBufferValueCapacity() {\n+    return checkedCastToInt(offsetBuffer.capacity() / OFFSET_WIDTH);\n+  }\n+  \n+  private int getValidityAndOffsetValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return capAtMaxInt(validityBuffer.capacity() * 8);\n+  }\n+\n+  /**\n+   * Sets the list at index to be not-null.  Reallocates validity buffer if index\n+   * is larger than current capacity.\n+   */\n+  public void setNotNull(int index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Start a new value in the list vector.\n+   *\n+   * @param index index of the value to start\n+   */\n+  public long startNewValue(long index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    for (long i = lastSet + 1; i <= index; i++) {\n+      final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+      offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+    return checkedCastToInt(offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * End the current value.\n+   *\n+   * @param index index of the value to end\n+   * @param size  number of elements in the list that was written\n+   */\n+  public void endValue(int index, int size) {\n+    final long currentOffset = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    offsetBuffer.setLong((index + 1) * OFFSET_WIDTH, currentOffset + size);\n+  }\n+\n+  /**\n+   * Sets the value count for the vector.\n+   *\n+   * @param valueCount   value count\n+   */\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    if (valueCount > 0) {\n+      while (valueCount > getValidityAndOffsetValueCapacity()) {\n+        /* check if validity and offset buffers need to be re-allocated */\n+        reallocValidityAndOffsetBuffers();\n+      }\n+      for (long i = lastSet + 1; i < valueCount; i++) {\n+        /* fill the holes with offsets */\n+        final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+        offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+      }\n+    }\n+    /* valueCount for the data vector is the current end offset */\n+    final long childValueCount = (valueCount == 0) ? 0 :\n+            offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH);\n+    /* set the value count of data vector and this will take care of\n+     * checking whether data buffer needs to be reallocated.\n+     */\n+    vector.setValueCount(checkedCastToInt(childValueCount));\n+  }\n+\n+  public void setLastSet(int value) {\n+    lastSet = value;\n+  }\n+\n+  public long getLastSet() {\n\nReview comment:\n       return `int`\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n\nReview comment:\n       I don't think this should be a long, it's the index of the last element set right?\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/BitVectorHelper.java\n##########\n@@ -57,12 +71,12 @@ public static int bitIndex(int absoluteBitIndex) {\n    * @param validityBuffer validity buffer of the vector\n    * @param index index to be set\n    */\n-  public static void setBit(ArrowBuf validityBuffer, int index) {\n+  public static void setBit(ArrowBuf validityBuffer, long index) {\n     // it can be observed that some logic is duplicate of the logic in setValidityBit.\n     // this is because JIT cannot always remove the if branch in setValidityBit,\n     // so we give a dedicated implementation for setting bits.\n-    final int byteIndex = byteIndex(index);\n-    final int bitIndex = bitIndex(index);\n+    final long byteIndex = byteIndex(index);\n+    final long bitIndex = bitIndex(index);\n\nReview comment:\n       From the comment above, I think this should still be an `int`\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n\nReview comment:\n       shouldn't this be long?\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n\nReview comment:\n       same comment as above\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the inner data vector for this list vector.\n+   * @return data vector\n+   */\n+  @Override\n+  public FieldVector getDataVector() {\n+    return vector;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((LargeListVector) target);\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return (offsetBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  @Override\n+  public int hashCode(int index) {\n+    return hashCode(index, null);\n+  }\n+\n+  @Override\n+  public int hashCode(int index, ArrowBufHasher hasher) {\n+    if (isSet(index) == 0) {\n+      return ArrowBufPointer.NULL_HASH_CODE;\n+    }\n+    int hash = 0;\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    for (long i = start; i < end; i++) {\n+      hash = ByteFunctionHelpers.combineHash(hash, vector.hashCode(checkedCastToInt(i), hasher));\n+    }\n+    return hash;\n+  }\n+\n+  @Override\n+  public <OUT, IN> OUT accept(VectorVisitor<OUT, IN> visitor, IN value) {\n+    return visitor.visit(this, value);\n+  }\n+\n+  public UnionLargeListWriter getWriter() {\n+    return new UnionLargeListWriter(this);\n+  }\n+\n+  protected void replaceDataVector(FieldVector v) {\n+    vector.clear();\n+    vector = v;\n+  }\n+\n+  @Override\n+  public UnionVector promoteToUnion() {\n+    UnionVector vector = new UnionVector(\"$data$\", allocator, callBack);\n+    replaceDataVector(vector);\n+    invalidateReader();\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return vector;\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+\n+    LargeListVector to;\n+    TransferPair dataTransferPair;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(new LargeListVector(name, allocator, fieldType, callBack));\n+    }\n+\n+    public TransferImpl(LargeListVector to) {\n+      this.to = to;\n+      to.addOrGetVector(vector.getField().getFieldType());\n+      if (to.getDataVector() instanceof ZeroVector) {\n+        to.addOrGetVector(vector.getField().getFieldType());\n+      }\n+      dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n+    }\n+\n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = transferBuffer(validityBuffer, to.allocator);\n+      to.offsetBuffer = transferBuffer(offsetBuffer, to.allocator);\n+      to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n+    }\n+\n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      Preconditions.checkArgument(startIndex >= 0 && length >= 0 && startIndex + length <= valueCount,\n+          \"Invalid parameters startIndex: %s, length: %s for valueCount: %s\", startIndex, length, valueCount);\n+      final long startPoint = offsetBuffer.getLong(startIndex * OFFSET_WIDTH);\n+      final long sliceLength = offsetBuffer.getLong((startIndex + length) * OFFSET_WIDTH) - startPoint;\n+      to.clear();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n+      for (int i = 0; i < length + 1; i++) {\n+        final long relativeOffset = offsetBuffer.getLong((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setLong(i * OFFSET_WIDTH, relativeOffset);\n+      }\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n+      dataTransferPair.splitAndTransfer(checkedCastToInt(startPoint), checkedCastToInt(sliceLength));\n+      to.lastSet = length - 1;\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, LargeListVector target) {\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.getReferenceManager().release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.getReferenceManager().retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, LargeListVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public UnionLargeListReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionLargeListReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * Initialize the data vector (and execute callback) if it hasn't already been done,\n+   * returns the data vector.\n+   */\n+  public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+    boolean created = false;\n+    if (vector instanceof NullVector) {\n+      vector = fieldType.createNewSingleVector(defaultDataVectorName, allocator, callBack);\n+      // returned vector must have the same field\n+      created = true;\n+      if (callBack != null &&\n+          // not a schema change if changing from ZeroVector to ZeroVector\n+          (fieldType.getType().getTypeID() != ArrowType.ArrowTypeID.Null)) {\n+        callBack.doWork();\n+      }\n+    }\n+\n+    if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+      final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+      throw new SchemaChangeRuntimeException(msg);\n+    }\n+\n+    invalidateReader();\n+    return new AddOrGetResult<>((T) vector, created);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n+  }\n+  \n+  @Override\n+  public int getBufferSizeFor(int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    long innerVectorValueCount = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+\n+    return ((valueCount + 1) * OFFSET_WIDTH) +\n+        vector.getBufferSizeFor(checkedCastToInt(innerVectorValueCount)) +\n+        validityBufferSize;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return new Field(getName(), fieldType, Collections.singletonList(getDataVector().getField()));\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.LIST;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    vector.clear();\n+    valueCount = 0;\n+    super.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    lastSet = -1;\n+  }\n+\n+  @Override\n+  public void reset() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    vector.reset();\n+    valueCount = 0;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      List<ArrowBuf> list = new ArrayList<>();\n+      list.add(offsetBuffer);\n+      list.add(validityBuffer);\n+      list.addAll(Arrays.asList(vector.getBuffers(false)));\n+      buffers = list.toArray(new ArrowBuf[list.size()]);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  protected void invalidateReader() {\n+    reader = null;\n+  }\n+\n+  /**\n+   * Get the element in the list vector at a particular index.\n+   * @param index position of the element\n+   * @return Object at given position\n+   */\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (long i = start; i < end; i++) {\n+      vals.add(vv.getObject(checkedCastToInt(i)));\n+    }\n+\n+    return vals;\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index position of element\n+   * @return true if element at given index is null, false otherwise\n+   */\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Check if element at given index is empty list.\n+   * @param index position of element\n+   * @return true if element at given index is empty list or NULL, false otherwise\n+   */\n+  public boolean isEmpty(int index) {\n+    if (isNull(index)) {\n+      return true;\n+    } else {\n+      final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+      final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+      return start == end;\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return (b >> bitIndex) & 0x01;\n+  }\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return getValidityAndOffsetValueCapacity();\n+  }\n+  \n+  protected int getOffsetBufferValueCapacity() {\n+    return checkedCastToInt(offsetBuffer.capacity() / OFFSET_WIDTH);\n+  }\n+  \n+  private int getValidityAndOffsetValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return capAtMaxInt(validityBuffer.capacity() * 8);\n+  }\n+\n+  /**\n+   * Sets the list at index to be not-null.  Reallocates validity buffer if index\n+   * is larger than current capacity.\n+   */\n+  public void setNotNull(int index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Start a new value in the list vector.\n+   *\n+   * @param index index of the value to start\n+   */\n+  public long startNewValue(long index) {\n\nReview comment:\n       `index` should be `int` I believe\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the inner data vector for this list vector.\n+   * @return data vector\n+   */\n+  @Override\n+  public FieldVector getDataVector() {\n+    return vector;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((LargeListVector) target);\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return (offsetBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  @Override\n+  public int hashCode(int index) {\n+    return hashCode(index, null);\n+  }\n+\n+  @Override\n+  public int hashCode(int index, ArrowBufHasher hasher) {\n+    if (isSet(index) == 0) {\n+      return ArrowBufPointer.NULL_HASH_CODE;\n+    }\n+    int hash = 0;\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    for (long i = start; i < end; i++) {\n+      hash = ByteFunctionHelpers.combineHash(hash, vector.hashCode(checkedCastToInt(i), hasher));\n+    }\n+    return hash;\n+  }\n+\n+  @Override\n+  public <OUT, IN> OUT accept(VectorVisitor<OUT, IN> visitor, IN value) {\n+    return visitor.visit(this, value);\n+  }\n+\n+  public UnionLargeListWriter getWriter() {\n+    return new UnionLargeListWriter(this);\n+  }\n+\n+  protected void replaceDataVector(FieldVector v) {\n+    vector.clear();\n+    vector = v;\n+  }\n+\n+  @Override\n+  public UnionVector promoteToUnion() {\n+    UnionVector vector = new UnionVector(\"$data$\", allocator, callBack);\n+    replaceDataVector(vector);\n+    invalidateReader();\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return vector;\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+\n+    LargeListVector to;\n+    TransferPair dataTransferPair;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(new LargeListVector(name, allocator, fieldType, callBack));\n+    }\n+\n+    public TransferImpl(LargeListVector to) {\n+      this.to = to;\n+      to.addOrGetVector(vector.getField().getFieldType());\n+      if (to.getDataVector() instanceof ZeroVector) {\n+        to.addOrGetVector(vector.getField().getFieldType());\n+      }\n+      dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n+    }\n+\n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = transferBuffer(validityBuffer, to.allocator);\n+      to.offsetBuffer = transferBuffer(offsetBuffer, to.allocator);\n+      to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n+    }\n+\n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      Preconditions.checkArgument(startIndex >= 0 && length >= 0 && startIndex + length <= valueCount,\n+          \"Invalid parameters startIndex: %s, length: %s for valueCount: %s\", startIndex, length, valueCount);\n+      final long startPoint = offsetBuffer.getLong(startIndex * OFFSET_WIDTH);\n+      final long sliceLength = offsetBuffer.getLong((startIndex + length) * OFFSET_WIDTH) - startPoint;\n+      to.clear();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n+      for (int i = 0; i < length + 1; i++) {\n+        final long relativeOffset = offsetBuffer.getLong((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setLong(i * OFFSET_WIDTH, relativeOffset);\n+      }\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n+      dataTransferPair.splitAndTransfer(checkedCastToInt(startPoint), checkedCastToInt(sliceLength));\n+      to.lastSet = length - 1;\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, LargeListVector target) {\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.getReferenceManager().release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.getReferenceManager().retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, LargeListVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public UnionLargeListReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionLargeListReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * Initialize the data vector (and execute callback) if it hasn't already been done,\n+   * returns the data vector.\n+   */\n+  public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+    boolean created = false;\n+    if (vector instanceof NullVector) {\n+      vector = fieldType.createNewSingleVector(defaultDataVectorName, allocator, callBack);\n+      // returned vector must have the same field\n+      created = true;\n+      if (callBack != null &&\n+          // not a schema change if changing from ZeroVector to ZeroVector\n+          (fieldType.getType().getTypeID() != ArrowType.ArrowTypeID.Null)) {\n+        callBack.doWork();\n+      }\n+    }\n+\n+    if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+      final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+      throw new SchemaChangeRuntimeException(msg);\n+    }\n+\n+    invalidateReader();\n+    return new AddOrGetResult<>((T) vector, created);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n+  }\n+  \n+  @Override\n+  public int getBufferSizeFor(int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    long innerVectorValueCount = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+\n+    return ((valueCount + 1) * OFFSET_WIDTH) +\n+        vector.getBufferSizeFor(checkedCastToInt(innerVectorValueCount)) +\n+        validityBufferSize;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return new Field(getName(), fieldType, Collections.singletonList(getDataVector().getField()));\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.LIST;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n\nReview comment:\n       shouldn't this return a name?\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileReader.java\n##########\n@@ -564,8 +564,10 @@ private ArrowBuf readIntoBuffer(BufferAllocator allocator, BufferType bufferType\n     } else if (bufferType.equals(OFFSET)) {\n       if (type == Types.MinorType.LARGEVARCHAR || type == Types.MinorType.LARGEVARBINARY) {\n\nReview comment:\n       you also won't need `typeBitWidth` as an arg\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the inner data vector for this list vector.\n+   * @return data vector\n+   */\n+  @Override\n+  public FieldVector getDataVector() {\n+    return vector;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((LargeListVector) target);\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return (offsetBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  @Override\n+  public int hashCode(int index) {\n+    return hashCode(index, null);\n+  }\n+\n+  @Override\n+  public int hashCode(int index, ArrowBufHasher hasher) {\n+    if (isSet(index) == 0) {\n+      return ArrowBufPointer.NULL_HASH_CODE;\n+    }\n+    int hash = 0;\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    for (long i = start; i < end; i++) {\n+      hash = ByteFunctionHelpers.combineHash(hash, vector.hashCode(checkedCastToInt(i), hasher));\n+    }\n+    return hash;\n+  }\n+\n+  @Override\n+  public <OUT, IN> OUT accept(VectorVisitor<OUT, IN> visitor, IN value) {\n+    return visitor.visit(this, value);\n+  }\n+\n+  public UnionLargeListWriter getWriter() {\n+    return new UnionLargeListWriter(this);\n+  }\n+\n+  protected void replaceDataVector(FieldVector v) {\n+    vector.clear();\n+    vector = v;\n+  }\n+\n+  @Override\n+  public UnionVector promoteToUnion() {\n+    UnionVector vector = new UnionVector(\"$data$\", allocator, callBack);\n+    replaceDataVector(vector);\n+    invalidateReader();\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return vector;\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+\n+    LargeListVector to;\n+    TransferPair dataTransferPair;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(new LargeListVector(name, allocator, fieldType, callBack));\n+    }\n+\n+    public TransferImpl(LargeListVector to) {\n+      this.to = to;\n+      to.addOrGetVector(vector.getField().getFieldType());\n+      if (to.getDataVector() instanceof ZeroVector) {\n+        to.addOrGetVector(vector.getField().getFieldType());\n+      }\n+      dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n+    }\n+\n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = transferBuffer(validityBuffer, to.allocator);\n+      to.offsetBuffer = transferBuffer(offsetBuffer, to.allocator);\n+      to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n+    }\n+\n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      Preconditions.checkArgument(startIndex >= 0 && length >= 0 && startIndex + length <= valueCount,\n+          \"Invalid parameters startIndex: %s, length: %s for valueCount: %s\", startIndex, length, valueCount);\n+      final long startPoint = offsetBuffer.getLong(startIndex * OFFSET_WIDTH);\n+      final long sliceLength = offsetBuffer.getLong((startIndex + length) * OFFSET_WIDTH) - startPoint;\n+      to.clear();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n+      for (int i = 0; i < length + 1; i++) {\n+        final long relativeOffset = offsetBuffer.getLong((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setLong(i * OFFSET_WIDTH, relativeOffset);\n+      }\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n+      dataTransferPair.splitAndTransfer(checkedCastToInt(startPoint), checkedCastToInt(sliceLength));\n+      to.lastSet = length - 1;\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, LargeListVector target) {\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.getReferenceManager().release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.getReferenceManager().retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, LargeListVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public UnionLargeListReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionLargeListReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * Initialize the data vector (and execute callback) if it hasn't already been done,\n+   * returns the data vector.\n+   */\n+  public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+    boolean created = false;\n+    if (vector instanceof NullVector) {\n+      vector = fieldType.createNewSingleVector(defaultDataVectorName, allocator, callBack);\n+      // returned vector must have the same field\n+      created = true;\n+      if (callBack != null &&\n+          // not a schema change if changing from ZeroVector to ZeroVector\n+          (fieldType.getType().getTypeID() != ArrowType.ArrowTypeID.Null)) {\n+        callBack.doWork();\n+      }\n+    }\n+\n+    if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+      final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+      throw new SchemaChangeRuntimeException(msg);\n+    }\n+\n+    invalidateReader();\n+    return new AddOrGetResult<>((T) vector, created);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n+  }\n+  \n+  @Override\n+  public int getBufferSizeFor(int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    long innerVectorValueCount = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+\n+    return ((valueCount + 1) * OFFSET_WIDTH) +\n+        vector.getBufferSizeFor(checkedCastToInt(innerVectorValueCount)) +\n+        validityBufferSize;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return new Field(getName(), fieldType, Collections.singletonList(getDataVector().getField()));\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.LIST;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    vector.clear();\n+    valueCount = 0;\n+    super.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    lastSet = -1;\n+  }\n+\n+  @Override\n+  public void reset() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    vector.reset();\n+    valueCount = 0;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      List<ArrowBuf> list = new ArrayList<>();\n+      list.add(offsetBuffer);\n+      list.add(validityBuffer);\n+      list.addAll(Arrays.asList(vector.getBuffers(false)));\n+      buffers = list.toArray(new ArrowBuf[list.size()]);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  protected void invalidateReader() {\n+    reader = null;\n+  }\n+\n+  /**\n+   * Get the element in the list vector at a particular index.\n+   * @param index position of the element\n+   * @return Object at given position\n+   */\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (long i = start; i < end; i++) {\n+      vals.add(vv.getObject(checkedCastToInt(i)));\n+    }\n+\n+    return vals;\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index position of element\n+   * @return true if element at given index is null, false otherwise\n+   */\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Check if element at given index is empty list.\n+   * @param index position of element\n+   * @return true if element at given index is empty list or NULL, false otherwise\n+   */\n+  public boolean isEmpty(int index) {\n+    if (isNull(index)) {\n+      return true;\n+    } else {\n+      final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+      final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+      return start == end;\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return (b >> bitIndex) & 0x01;\n+  }\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return getValidityAndOffsetValueCapacity();\n+  }\n+  \n+  protected int getOffsetBufferValueCapacity() {\n+    return checkedCastToInt(offsetBuffer.capacity() / OFFSET_WIDTH);\n+  }\n+  \n+  private int getValidityAndOffsetValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return capAtMaxInt(validityBuffer.capacity() * 8);\n+  }\n+\n+  /**\n+   * Sets the list at index to be not-null.  Reallocates validity buffer if index\n+   * is larger than current capacity.\n+   */\n+  public void setNotNull(int index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Start a new value in the list vector.\n+   *\n+   * @param index index of the value to start\n+   */\n+  public long startNewValue(long index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    for (long i = lastSet + 1; i <= index; i++) {\n\nReview comment:\n       `i` should be `int`\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the inner data vector for this list vector.\n+   * @return data vector\n+   */\n+  @Override\n+  public FieldVector getDataVector() {\n+    return vector;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((LargeListVector) target);\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return (offsetBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  @Override\n+  public int hashCode(int index) {\n+    return hashCode(index, null);\n+  }\n+\n+  @Override\n+  public int hashCode(int index, ArrowBufHasher hasher) {\n+    if (isSet(index) == 0) {\n+      return ArrowBufPointer.NULL_HASH_CODE;\n+    }\n+    int hash = 0;\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    for (long i = start; i < end; i++) {\n+      hash = ByteFunctionHelpers.combineHash(hash, vector.hashCode(checkedCastToInt(i), hasher));\n+    }\n+    return hash;\n+  }\n+\n+  @Override\n+  public <OUT, IN> OUT accept(VectorVisitor<OUT, IN> visitor, IN value) {\n+    return visitor.visit(this, value);\n+  }\n+\n+  public UnionLargeListWriter getWriter() {\n+    return new UnionLargeListWriter(this);\n+  }\n+\n+  protected void replaceDataVector(FieldVector v) {\n+    vector.clear();\n+    vector = v;\n+  }\n+\n+  @Override\n+  public UnionVector promoteToUnion() {\n+    UnionVector vector = new UnionVector(\"$data$\", allocator, callBack);\n+    replaceDataVector(vector);\n+    invalidateReader();\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return vector;\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+\n+    LargeListVector to;\n+    TransferPair dataTransferPair;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(new LargeListVector(name, allocator, fieldType, callBack));\n+    }\n+\n+    public TransferImpl(LargeListVector to) {\n+      this.to = to;\n+      to.addOrGetVector(vector.getField().getFieldType());\n+      if (to.getDataVector() instanceof ZeroVector) {\n+        to.addOrGetVector(vector.getField().getFieldType());\n+      }\n+      dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n+    }\n+\n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = transferBuffer(validityBuffer, to.allocator);\n+      to.offsetBuffer = transferBuffer(offsetBuffer, to.allocator);\n+      to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n+    }\n+\n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      Preconditions.checkArgument(startIndex >= 0 && length >= 0 && startIndex + length <= valueCount,\n+          \"Invalid parameters startIndex: %s, length: %s for valueCount: %s\", startIndex, length, valueCount);\n+      final long startPoint = offsetBuffer.getLong(startIndex * OFFSET_WIDTH);\n+      final long sliceLength = offsetBuffer.getLong((startIndex + length) * OFFSET_WIDTH) - startPoint;\n+      to.clear();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n+      for (int i = 0; i < length + 1; i++) {\n+        final long relativeOffset = offsetBuffer.getLong((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setLong(i * OFFSET_WIDTH, relativeOffset);\n+      }\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n+      dataTransferPair.splitAndTransfer(checkedCastToInt(startPoint), checkedCastToInt(sliceLength));\n+      to.lastSet = length - 1;\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, LargeListVector target) {\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.getReferenceManager().release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.getReferenceManager().retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, LargeListVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public UnionLargeListReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionLargeListReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * Initialize the data vector (and execute callback) if it hasn't already been done,\n+   * returns the data vector.\n+   */\n+  public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+    boolean created = false;\n+    if (vector instanceof NullVector) {\n+      vector = fieldType.createNewSingleVector(defaultDataVectorName, allocator, callBack);\n+      // returned vector must have the same field\n+      created = true;\n+      if (callBack != null &&\n+          // not a schema change if changing from ZeroVector to ZeroVector\n+          (fieldType.getType().getTypeID() != ArrowType.ArrowTypeID.Null)) {\n+        callBack.doWork();\n+      }\n+    }\n+\n+    if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+      final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+      throw new SchemaChangeRuntimeException(msg);\n+    }\n+\n+    invalidateReader();\n+    return new AddOrGetResult<>((T) vector, created);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n+  }\n+  \n+  @Override\n+  public int getBufferSizeFor(int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    long innerVectorValueCount = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+\n+    return ((valueCount + 1) * OFFSET_WIDTH) +\n+        vector.getBufferSizeFor(checkedCastToInt(innerVectorValueCount)) +\n+        validityBufferSize;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return new Field(getName(), fieldType, Collections.singletonList(getDataVector().getField()));\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.LIST;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    vector.clear();\n+    valueCount = 0;\n+    super.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    lastSet = -1;\n+  }\n+\n+  @Override\n+  public void reset() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    vector.reset();\n+    valueCount = 0;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      List<ArrowBuf> list = new ArrayList<>();\n+      list.add(offsetBuffer);\n+      list.add(validityBuffer);\n+      list.addAll(Arrays.asList(vector.getBuffers(false)));\n+      buffers = list.toArray(new ArrowBuf[list.size()]);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  protected void invalidateReader() {\n+    reader = null;\n+  }\n+\n+  /**\n+   * Get the element in the list vector at a particular index.\n+   * @param index position of the element\n+   * @return Object at given position\n+   */\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (long i = start; i < end; i++) {\n+      vals.add(vv.getObject(checkedCastToInt(i)));\n+    }\n+\n+    return vals;\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index position of element\n+   * @return true if element at given index is null, false otherwise\n+   */\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Check if element at given index is empty list.\n+   * @param index position of element\n+   * @return true if element at given index is empty list or NULL, false otherwise\n+   */\n+  public boolean isEmpty(int index) {\n+    if (isNull(index)) {\n+      return true;\n+    } else {\n+      final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+      final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+      return start == end;\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return (b >> bitIndex) & 0x01;\n+  }\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return getValidityAndOffsetValueCapacity();\n+  }\n+  \n+  protected int getOffsetBufferValueCapacity() {\n+    return checkedCastToInt(offsetBuffer.capacity() / OFFSET_WIDTH);\n+  }\n+  \n+  private int getValidityAndOffsetValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return capAtMaxInt(validityBuffer.capacity() * 8);\n+  }\n+\n+  /**\n+   * Sets the list at index to be not-null.  Reallocates validity buffer if index\n+   * is larger than current capacity.\n+   */\n+  public void setNotNull(int index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Start a new value in the list vector.\n+   *\n+   * @param index index of the value to start\n+   */\n+  public long startNewValue(long index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    for (long i = lastSet + 1; i <= index; i++) {\n+      final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+      offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+    return checkedCastToInt(offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * End the current value.\n+   *\n+   * @param index index of the value to end\n+   * @param size  number of elements in the list that was written\n+   */\n+  public void endValue(int index, int size) {\n+    final long currentOffset = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    offsetBuffer.setLong((index + 1) * OFFSET_WIDTH, currentOffset + size);\n+  }\n+\n+  /**\n+   * Sets the value count for the vector.\n+   *\n+   * @param valueCount   value count\n+   */\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    if (valueCount > 0) {\n+      while (valueCount > getValidityAndOffsetValueCapacity()) {\n+        /* check if validity and offset buffers need to be re-allocated */\n+        reallocValidityAndOffsetBuffers();\n+      }\n+      for (long i = lastSet + 1; i < valueCount; i++) {\n\nReview comment:\n       `i` should be `int`\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the inner data vector for this list vector.\n+   * @return data vector\n+   */\n+  @Override\n+  public FieldVector getDataVector() {\n+    return vector;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((LargeListVector) target);\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return (offsetBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  @Override\n+  public int hashCode(int index) {\n+    return hashCode(index, null);\n+  }\n+\n+  @Override\n+  public int hashCode(int index, ArrowBufHasher hasher) {\n+    if (isSet(index) == 0) {\n+      return ArrowBufPointer.NULL_HASH_CODE;\n+    }\n+    int hash = 0;\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    for (long i = start; i < end; i++) {\n+      hash = ByteFunctionHelpers.combineHash(hash, vector.hashCode(checkedCastToInt(i), hasher));\n+    }\n+    return hash;\n+  }\n+\n+  @Override\n+  public <OUT, IN> OUT accept(VectorVisitor<OUT, IN> visitor, IN value) {\n+    return visitor.visit(this, value);\n+  }\n+\n+  public UnionLargeListWriter getWriter() {\n+    return new UnionLargeListWriter(this);\n+  }\n+\n+  protected void replaceDataVector(FieldVector v) {\n+    vector.clear();\n+    vector = v;\n+  }\n+\n+  @Override\n+  public UnionVector promoteToUnion() {\n+    UnionVector vector = new UnionVector(\"$data$\", allocator, callBack);\n+    replaceDataVector(vector);\n+    invalidateReader();\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return vector;\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+\n+    LargeListVector to;\n+    TransferPair dataTransferPair;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(new LargeListVector(name, allocator, fieldType, callBack));\n+    }\n+\n+    public TransferImpl(LargeListVector to) {\n+      this.to = to;\n+      to.addOrGetVector(vector.getField().getFieldType());\n+      if (to.getDataVector() instanceof ZeroVector) {\n+        to.addOrGetVector(vector.getField().getFieldType());\n+      }\n+      dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n+    }\n+\n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = transferBuffer(validityBuffer, to.allocator);\n+      to.offsetBuffer = transferBuffer(offsetBuffer, to.allocator);\n+      to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n+    }\n+\n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      Preconditions.checkArgument(startIndex >= 0 && length >= 0 && startIndex + length <= valueCount,\n+          \"Invalid parameters startIndex: %s, length: %s for valueCount: %s\", startIndex, length, valueCount);\n+      final long startPoint = offsetBuffer.getLong(startIndex * OFFSET_WIDTH);\n+      final long sliceLength = offsetBuffer.getLong((startIndex + length) * OFFSET_WIDTH) - startPoint;\n+      to.clear();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n+      for (int i = 0; i < length + 1; i++) {\n+        final long relativeOffset = offsetBuffer.getLong((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setLong(i * OFFSET_WIDTH, relativeOffset);\n+      }\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n+      dataTransferPair.splitAndTransfer(checkedCastToInt(startPoint), checkedCastToInt(sliceLength));\n+      to.lastSet = length - 1;\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, LargeListVector target) {\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.getReferenceManager().release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.getReferenceManager().retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, LargeListVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public UnionLargeListReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionLargeListReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * Initialize the data vector (and execute callback) if it hasn't already been done,\n+   * returns the data vector.\n+   */\n+  public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+    boolean created = false;\n+    if (vector instanceof NullVector) {\n+      vector = fieldType.createNewSingleVector(defaultDataVectorName, allocator, callBack);\n+      // returned vector must have the same field\n+      created = true;\n+      if (callBack != null &&\n+          // not a schema change if changing from ZeroVector to ZeroVector\n+          (fieldType.getType().getTypeID() != ArrowType.ArrowTypeID.Null)) {\n+        callBack.doWork();\n+      }\n+    }\n+\n+    if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+      final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+      throw new SchemaChangeRuntimeException(msg);\n+    }\n+\n+    invalidateReader();\n+    return new AddOrGetResult<>((T) vector, created);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n+  }\n+  \n+  @Override\n+  public int getBufferSizeFor(int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    long innerVectorValueCount = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+\n+    return ((valueCount + 1) * OFFSET_WIDTH) +\n+        vector.getBufferSizeFor(checkedCastToInt(innerVectorValueCount)) +\n+        validityBufferSize;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return new Field(getName(), fieldType, Collections.singletonList(getDataVector().getField()));\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.LIST;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    vector.clear();\n+    valueCount = 0;\n+    super.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    lastSet = -1;\n+  }\n+\n+  @Override\n+  public void reset() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    vector.reset();\n+    valueCount = 0;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      List<ArrowBuf> list = new ArrayList<>();\n+      list.add(offsetBuffer);\n+      list.add(validityBuffer);\n+      list.addAll(Arrays.asList(vector.getBuffers(false)));\n+      buffers = list.toArray(new ArrowBuf[list.size()]);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  protected void invalidateReader() {\n+    reader = null;\n+  }\n+\n+  /**\n+   * Get the element in the list vector at a particular index.\n+   * @param index position of the element\n+   * @return Object at given position\n+   */\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (long i = start; i < end; i++) {\n+      vals.add(vv.getObject(checkedCastToInt(i)));\n+    }\n+\n+    return vals;\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index position of element\n+   * @return true if element at given index is null, false otherwise\n+   */\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Check if element at given index is empty list.\n+   * @param index position of element\n+   * @return true if element at given index is empty list or NULL, false otherwise\n+   */\n+  public boolean isEmpty(int index) {\n+    if (isNull(index)) {\n+      return true;\n+    } else {\n+      final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+      final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+      return start == end;\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return (b >> bitIndex) & 0x01;\n+  }\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return getValidityAndOffsetValueCapacity();\n+  }\n+  \n+  protected int getOffsetBufferValueCapacity() {\n+    return checkedCastToInt(offsetBuffer.capacity() / OFFSET_WIDTH);\n+  }\n+  \n+  private int getValidityAndOffsetValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return capAtMaxInt(validityBuffer.capacity() * 8);\n+  }\n+\n+  /**\n+   * Sets the list at index to be not-null.  Reallocates validity buffer if index\n+   * is larger than current capacity.\n+   */\n+  public void setNotNull(int index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Start a new value in the list vector.\n+   *\n+   * @param index index of the value to start\n+   */\n+  public long startNewValue(long index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    for (long i = lastSet + 1; i <= index; i++) {\n+      final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+      offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+    return checkedCastToInt(offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH));\n\nReview comment:\n       I don't think you should cast the return value\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the inner data vector for this list vector.\n+   * @return data vector\n+   */\n+  @Override\n+  public FieldVector getDataVector() {\n+    return vector;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((LargeListVector) target);\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return (offsetBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  @Override\n+  public int hashCode(int index) {\n+    return hashCode(index, null);\n+  }\n+\n+  @Override\n+  public int hashCode(int index, ArrowBufHasher hasher) {\n+    if (isSet(index) == 0) {\n+      return ArrowBufPointer.NULL_HASH_CODE;\n+    }\n+    int hash = 0;\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    for (long i = start; i < end; i++) {\n+      hash = ByteFunctionHelpers.combineHash(hash, vector.hashCode(checkedCastToInt(i), hasher));\n+    }\n+    return hash;\n+  }\n+\n+  @Override\n+  public <OUT, IN> OUT accept(VectorVisitor<OUT, IN> visitor, IN value) {\n+    return visitor.visit(this, value);\n+  }\n+\n+  public UnionLargeListWriter getWriter() {\n+    return new UnionLargeListWriter(this);\n+  }\n+\n+  protected void replaceDataVector(FieldVector v) {\n+    vector.clear();\n+    vector = v;\n+  }\n+\n+  @Override\n+  public UnionVector promoteToUnion() {\n+    UnionVector vector = new UnionVector(\"$data$\", allocator, callBack);\n+    replaceDataVector(vector);\n+    invalidateReader();\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return vector;\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+\n+    LargeListVector to;\n+    TransferPair dataTransferPair;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(new LargeListVector(name, allocator, fieldType, callBack));\n+    }\n+\n+    public TransferImpl(LargeListVector to) {\n+      this.to = to;\n+      to.addOrGetVector(vector.getField().getFieldType());\n+      if (to.getDataVector() instanceof ZeroVector) {\n+        to.addOrGetVector(vector.getField().getFieldType());\n+      }\n+      dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n+    }\n+\n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = transferBuffer(validityBuffer, to.allocator);\n+      to.offsetBuffer = transferBuffer(offsetBuffer, to.allocator);\n+      to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n+    }\n+\n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      Preconditions.checkArgument(startIndex >= 0 && length >= 0 && startIndex + length <= valueCount,\n+          \"Invalid parameters startIndex: %s, length: %s for valueCount: %s\", startIndex, length, valueCount);\n+      final long startPoint = offsetBuffer.getLong(startIndex * OFFSET_WIDTH);\n+      final long sliceLength = offsetBuffer.getLong((startIndex + length) * OFFSET_WIDTH) - startPoint;\n+      to.clear();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n+      for (int i = 0; i < length + 1; i++) {\n+        final long relativeOffset = offsetBuffer.getLong((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setLong(i * OFFSET_WIDTH, relativeOffset);\n+      }\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n+      dataTransferPair.splitAndTransfer(checkedCastToInt(startPoint), checkedCastToInt(sliceLength));\n+      to.lastSet = length - 1;\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, LargeListVector target) {\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.getReferenceManager().release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.getReferenceManager().retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, LargeListVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public UnionLargeListReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionLargeListReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * Initialize the data vector (and execute callback) if it hasn't already been done,\n+   * returns the data vector.\n+   */\n+  public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+    boolean created = false;\n+    if (vector instanceof NullVector) {\n+      vector = fieldType.createNewSingleVector(defaultDataVectorName, allocator, callBack);\n+      // returned vector must have the same field\n+      created = true;\n+      if (callBack != null &&\n+          // not a schema change if changing from ZeroVector to ZeroVector\n+          (fieldType.getType().getTypeID() != ArrowType.ArrowTypeID.Null)) {\n+        callBack.doWork();\n+      }\n+    }\n+\n+    if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+      final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+      throw new SchemaChangeRuntimeException(msg);\n+    }\n+\n+    invalidateReader();\n+    return new AddOrGetResult<>((T) vector, created);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n+  }\n+  \n+  @Override\n+  public int getBufferSizeFor(int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    long innerVectorValueCount = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+\n+    return ((valueCount + 1) * OFFSET_WIDTH) +\n+        vector.getBufferSizeFor(checkedCastToInt(innerVectorValueCount)) +\n+        validityBufferSize;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return new Field(getName(), fieldType, Collections.singletonList(getDataVector().getField()));\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.LIST;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    vector.clear();\n+    valueCount = 0;\n+    super.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    lastSet = -1;\n+  }\n+\n+  @Override\n+  public void reset() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    vector.reset();\n+    valueCount = 0;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      List<ArrowBuf> list = new ArrayList<>();\n+      list.add(offsetBuffer);\n+      list.add(validityBuffer);\n+      list.addAll(Arrays.asList(vector.getBuffers(false)));\n+      buffers = list.toArray(new ArrowBuf[list.size()]);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  protected void invalidateReader() {\n+    reader = null;\n+  }\n+\n+  /**\n+   * Get the element in the list vector at a particular index.\n+   * @param index position of the element\n+   * @return Object at given position\n+   */\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (long i = start; i < end; i++) {\n+      vals.add(vv.getObject(checkedCastToInt(i)));\n+    }\n+\n+    return vals;\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index position of element\n+   * @return true if element at given index is null, false otherwise\n+   */\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Check if element at given index is empty list.\n+   * @param index position of element\n+   * @return true if element at given index is empty list or NULL, false otherwise\n+   */\n+  public boolean isEmpty(int index) {\n+    if (isNull(index)) {\n+      return true;\n+    } else {\n+      final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+      final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+      return start == end;\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return (b >> bitIndex) & 0x01;\n+  }\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return getValidityAndOffsetValueCapacity();\n+  }\n+  \n+  protected int getOffsetBufferValueCapacity() {\n+    return checkedCastToInt(offsetBuffer.capacity() / OFFSET_WIDTH);\n+  }\n+  \n+  private int getValidityAndOffsetValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return capAtMaxInt(validityBuffer.capacity() * 8);\n+  }\n+\n+  /**\n+   * Sets the list at index to be not-null.  Reallocates validity buffer if index\n+   * is larger than current capacity.\n+   */\n+  public void setNotNull(int index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Start a new value in the list vector.\n+   *\n+   * @param index index of the value to start\n+   */\n+  public long startNewValue(long index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    for (long i = lastSet + 1; i <= index; i++) {\n+      final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+      offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+    return checkedCastToInt(offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * End the current value.\n+   *\n+   * @param index index of the value to end\n+   * @param size  number of elements in the list that was written\n+   */\n+  public void endValue(int index, int size) {\n+    final long currentOffset = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    offsetBuffer.setLong((index + 1) * OFFSET_WIDTH, currentOffset + size);\n+  }\n+\n+  /**\n+   * Sets the value count for the vector.\n+   *\n+   * @param valueCount   value count\n+   */\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    if (valueCount > 0) {\n+      while (valueCount > getValidityAndOffsetValueCapacity()) {\n+        /* check if validity and offset buffers need to be re-allocated */\n+        reallocValidityAndOffsetBuffers();\n+      }\n+      for (long i = lastSet + 1; i < valueCount; i++) {\n+        /* fill the holes with offsets */\n+        final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+        offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+      }\n+    }\n+    /* valueCount for the data vector is the current end offset */\n+    final long childValueCount = (valueCount == 0) ? 0 :\n+            offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH);\n+    /* set the value count of data vector and this will take care of\n+     * checking whether data buffer needs to be reallocated.\n+     */\n+    vector.setValueCount(checkedCastToInt(childValueCount));\n\nReview comment:\n       Could you add a TODO to revisit once 64 bit vectors are supported?\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the inner data vector for this list vector.\n+   * @return data vector\n+   */\n+  @Override\n+  public FieldVector getDataVector() {\n+    return vector;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((LargeListVector) target);\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return (offsetBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  @Override\n+  public int hashCode(int index) {\n+    return hashCode(index, null);\n+  }\n+\n+  @Override\n+  public int hashCode(int index, ArrowBufHasher hasher) {\n+    if (isSet(index) == 0) {\n+      return ArrowBufPointer.NULL_HASH_CODE;\n+    }\n+    int hash = 0;\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    for (long i = start; i < end; i++) {\n+      hash = ByteFunctionHelpers.combineHash(hash, vector.hashCode(checkedCastToInt(i), hasher));\n+    }\n+    return hash;\n+  }\n+\n+  @Override\n+  public <OUT, IN> OUT accept(VectorVisitor<OUT, IN> visitor, IN value) {\n+    return visitor.visit(this, value);\n+  }\n+\n+  public UnionLargeListWriter getWriter() {\n+    return new UnionLargeListWriter(this);\n+  }\n+\n+  protected void replaceDataVector(FieldVector v) {\n+    vector.clear();\n+    vector = v;\n+  }\n+\n+  @Override\n+  public UnionVector promoteToUnion() {\n+    UnionVector vector = new UnionVector(\"$data$\", allocator, callBack);\n+    replaceDataVector(vector);\n+    invalidateReader();\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return vector;\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+\n+    LargeListVector to;\n+    TransferPair dataTransferPair;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(new LargeListVector(name, allocator, fieldType, callBack));\n+    }\n+\n+    public TransferImpl(LargeListVector to) {\n+      this.to = to;\n+      to.addOrGetVector(vector.getField().getFieldType());\n+      if (to.getDataVector() instanceof ZeroVector) {\n+        to.addOrGetVector(vector.getField().getFieldType());\n+      }\n+      dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n+    }\n+\n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = transferBuffer(validityBuffer, to.allocator);\n+      to.offsetBuffer = transferBuffer(offsetBuffer, to.allocator);\n+      to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n+    }\n+\n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      Preconditions.checkArgument(startIndex >= 0 && length >= 0 && startIndex + length <= valueCount,\n+          \"Invalid parameters startIndex: %s, length: %s for valueCount: %s\", startIndex, length, valueCount);\n+      final long startPoint = offsetBuffer.getLong(startIndex * OFFSET_WIDTH);\n+      final long sliceLength = offsetBuffer.getLong((startIndex + length) * OFFSET_WIDTH) - startPoint;\n+      to.clear();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n+      for (int i = 0; i < length + 1; i++) {\n+        final long relativeOffset = offsetBuffer.getLong((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setLong(i * OFFSET_WIDTH, relativeOffset);\n+      }\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n+      dataTransferPair.splitAndTransfer(checkedCastToInt(startPoint), checkedCastToInt(sliceLength));\n+      to.lastSet = length - 1;\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, LargeListVector target) {\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.getReferenceManager().release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.getReferenceManager().retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, LargeListVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public UnionLargeListReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionLargeListReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * Initialize the data vector (and execute callback) if it hasn't already been done,\n+   * returns the data vector.\n+   */\n+  public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+    boolean created = false;\n+    if (vector instanceof NullVector) {\n+      vector = fieldType.createNewSingleVector(defaultDataVectorName, allocator, callBack);\n+      // returned vector must have the same field\n+      created = true;\n+      if (callBack != null &&\n+          // not a schema change if changing from ZeroVector to ZeroVector\n+          (fieldType.getType().getTypeID() != ArrowType.ArrowTypeID.Null)) {\n+        callBack.doWork();\n+      }\n+    }\n+\n+    if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+      final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+      throw new SchemaChangeRuntimeException(msg);\n+    }\n+\n+    invalidateReader();\n+    return new AddOrGetResult<>((T) vector, created);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n+  }\n+  \n+  @Override\n+  public int getBufferSizeFor(int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    long innerVectorValueCount = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+\n+    return ((valueCount + 1) * OFFSET_WIDTH) +\n+        vector.getBufferSizeFor(checkedCastToInt(innerVectorValueCount)) +\n+        validityBufferSize;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return new Field(getName(), fieldType, Collections.singletonList(getDataVector().getField()));\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.LIST;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    vector.clear();\n+    valueCount = 0;\n+    super.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    lastSet = -1;\n+  }\n+\n+  @Override\n+  public void reset() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    vector.reset();\n+    valueCount = 0;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      List<ArrowBuf> list = new ArrayList<>();\n+      list.add(offsetBuffer);\n+      list.add(validityBuffer);\n+      list.addAll(Arrays.asList(vector.getBuffers(false)));\n+      buffers = list.toArray(new ArrowBuf[list.size()]);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  protected void invalidateReader() {\n+    reader = null;\n+  }\n+\n+  /**\n+   * Get the element in the list vector at a particular index.\n+   * @param index position of the element\n+   * @return Object at given position\n+   */\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (long i = start; i < end; i++) {\n+      vals.add(vv.getObject(checkedCastToInt(i)));\n+    }\n+\n+    return vals;\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index position of element\n+   * @return true if element at given index is null, false otherwise\n+   */\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Check if element at given index is empty list.\n+   * @param index position of element\n+   * @return true if element at given index is empty list or NULL, false otherwise\n+   */\n+  public boolean isEmpty(int index) {\n+    if (isNull(index)) {\n+      return true;\n+    } else {\n+      final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+      final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+      return start == end;\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return (b >> bitIndex) & 0x01;\n+  }\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return getValidityAndOffsetValueCapacity();\n+  }\n+  \n+  protected int getOffsetBufferValueCapacity() {\n+    return checkedCastToInt(offsetBuffer.capacity() / OFFSET_WIDTH);\n+  }\n+  \n+  private int getValidityAndOffsetValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return capAtMaxInt(validityBuffer.capacity() * 8);\n+  }\n+\n+  /**\n+   * Sets the list at index to be not-null.  Reallocates validity buffer if index\n+   * is larger than current capacity.\n+   */\n+  public void setNotNull(int index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Start a new value in the list vector.\n+   *\n+   * @param index index of the value to start\n+   */\n+  public long startNewValue(long index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    for (long i = lastSet + 1; i <= index; i++) {\n+      final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+      offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+    return checkedCastToInt(offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * End the current value.\n+   *\n+   * @param index index of the value to end\n+   * @param size  number of elements in the list that was written\n+   */\n+  public void endValue(int index, int size) {\n+    final long currentOffset = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    offsetBuffer.setLong((index + 1) * OFFSET_WIDTH, currentOffset + size);\n+  }\n+\n+  /**\n+   * Sets the value count for the vector.\n+   *\n+   * @param valueCount   value count\n+   */\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    if (valueCount > 0) {\n+      while (valueCount > getValidityAndOffsetValueCapacity()) {\n+        /* check if validity and offset buffers need to be re-allocated */\n+        reallocValidityAndOffsetBuffers();\n+      }\n+      for (long i = lastSet + 1; i < valueCount; i++) {\n+        /* fill the holes with offsets */\n+        final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+        offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+      }\n+    }\n+    /* valueCount for the data vector is the current end offset */\n+    final long childValueCount = (valueCount == 0) ? 0 :\n+            offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH);\n+    /* set the value count of data vector and this will take care of\n+     * checking whether data buffer needs to be reallocated.\n+     */\n+    vector.setValueCount(checkedCastToInt(childValueCount));\n+  }\n+\n+  public void setLastSet(int value) {\n+    lastSet = value;\n+  }\n+\n+  public long getLastSet() {\n+    return lastSet;\n+  }\n+\n+  @Override\n+  public int getElementStartIndex(int index) {\n+    return checkedCastToInt(offsetBuffer.getLong(index * OFFSET_WIDTH));\n+  }\n+\n+  @Override\n+  public int getElementEndIndex(int index) {\n\nReview comment:\n       same here\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the inner data vector for this list vector.\n+   * @return data vector\n+   */\n+  @Override\n+  public FieldVector getDataVector() {\n+    return vector;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((LargeListVector) target);\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return (offsetBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  @Override\n+  public int hashCode(int index) {\n+    return hashCode(index, null);\n+  }\n+\n+  @Override\n+  public int hashCode(int index, ArrowBufHasher hasher) {\n+    if (isSet(index) == 0) {\n+      return ArrowBufPointer.NULL_HASH_CODE;\n+    }\n+    int hash = 0;\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    for (long i = start; i < end; i++) {\n+      hash = ByteFunctionHelpers.combineHash(hash, vector.hashCode(checkedCastToInt(i), hasher));\n+    }\n+    return hash;\n+  }\n+\n+  @Override\n+  public <OUT, IN> OUT accept(VectorVisitor<OUT, IN> visitor, IN value) {\n+    return visitor.visit(this, value);\n+  }\n+\n+  public UnionLargeListWriter getWriter() {\n+    return new UnionLargeListWriter(this);\n+  }\n+\n+  protected void replaceDataVector(FieldVector v) {\n+    vector.clear();\n+    vector = v;\n+  }\n+\n+  @Override\n+  public UnionVector promoteToUnion() {\n+    UnionVector vector = new UnionVector(\"$data$\", allocator, callBack);\n+    replaceDataVector(vector);\n+    invalidateReader();\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return vector;\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+\n+    LargeListVector to;\n+    TransferPair dataTransferPair;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(new LargeListVector(name, allocator, fieldType, callBack));\n+    }\n+\n+    public TransferImpl(LargeListVector to) {\n+      this.to = to;\n+      to.addOrGetVector(vector.getField().getFieldType());\n+      if (to.getDataVector() instanceof ZeroVector) {\n+        to.addOrGetVector(vector.getField().getFieldType());\n+      }\n+      dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n+    }\n+\n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = transferBuffer(validityBuffer, to.allocator);\n+      to.offsetBuffer = transferBuffer(offsetBuffer, to.allocator);\n+      to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n+    }\n+\n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      Preconditions.checkArgument(startIndex >= 0 && length >= 0 && startIndex + length <= valueCount,\n+          \"Invalid parameters startIndex: %s, length: %s for valueCount: %s\", startIndex, length, valueCount);\n+      final long startPoint = offsetBuffer.getLong(startIndex * OFFSET_WIDTH);\n+      final long sliceLength = offsetBuffer.getLong((startIndex + length) * OFFSET_WIDTH) - startPoint;\n+      to.clear();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n+      for (int i = 0; i < length + 1; i++) {\n+        final long relativeOffset = offsetBuffer.getLong((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setLong(i * OFFSET_WIDTH, relativeOffset);\n+      }\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n+      dataTransferPair.splitAndTransfer(checkedCastToInt(startPoint), checkedCastToInt(sliceLength));\n+      to.lastSet = length - 1;\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, LargeListVector target) {\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.getReferenceManager().release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.getReferenceManager().retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, LargeListVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public UnionLargeListReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionLargeListReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * Initialize the data vector (and execute callback) if it hasn't already been done,\n+   * returns the data vector.\n+   */\n+  public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+    boolean created = false;\n+    if (vector instanceof NullVector) {\n+      vector = fieldType.createNewSingleVector(defaultDataVectorName, allocator, callBack);\n+      // returned vector must have the same field\n+      created = true;\n+      if (callBack != null &&\n+          // not a schema change if changing from ZeroVector to ZeroVector\n+          (fieldType.getType().getTypeID() != ArrowType.ArrowTypeID.Null)) {\n+        callBack.doWork();\n+      }\n+    }\n+\n+    if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+      final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+      throw new SchemaChangeRuntimeException(msg);\n+    }\n+\n+    invalidateReader();\n+    return new AddOrGetResult<>((T) vector, created);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n+  }\n+  \n+  @Override\n+  public int getBufferSizeFor(int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    long innerVectorValueCount = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+\n+    return ((valueCount + 1) * OFFSET_WIDTH) +\n+        vector.getBufferSizeFor(checkedCastToInt(innerVectorValueCount)) +\n+        validityBufferSize;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return new Field(getName(), fieldType, Collections.singletonList(getDataVector().getField()));\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.LIST;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    vector.clear();\n+    valueCount = 0;\n+    super.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    lastSet = -1;\n+  }\n+\n+  @Override\n+  public void reset() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    vector.reset();\n+    valueCount = 0;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      List<ArrowBuf> list = new ArrayList<>();\n+      list.add(offsetBuffer);\n+      list.add(validityBuffer);\n+      list.addAll(Arrays.asList(vector.getBuffers(false)));\n+      buffers = list.toArray(new ArrowBuf[list.size()]);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  protected void invalidateReader() {\n+    reader = null;\n+  }\n+\n+  /**\n+   * Get the element in the list vector at a particular index.\n+   * @param index position of the element\n+   * @return Object at given position\n+   */\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (long i = start; i < end; i++) {\n+      vals.add(vv.getObject(checkedCastToInt(i)));\n+    }\n+\n+    return vals;\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index position of element\n+   * @return true if element at given index is null, false otherwise\n+   */\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Check if element at given index is empty list.\n+   * @param index position of element\n+   * @return true if element at given index is empty list or NULL, false otherwise\n+   */\n+  public boolean isEmpty(int index) {\n+    if (isNull(index)) {\n+      return true;\n+    } else {\n+      final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+      final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+      return start == end;\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return (b >> bitIndex) & 0x01;\n+  }\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return getValidityAndOffsetValueCapacity();\n+  }\n+  \n+  protected int getOffsetBufferValueCapacity() {\n+    return checkedCastToInt(offsetBuffer.capacity() / OFFSET_WIDTH);\n+  }\n+  \n+  private int getValidityAndOffsetValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return capAtMaxInt(validityBuffer.capacity() * 8);\n+  }\n+\n+  /**\n+   * Sets the list at index to be not-null.  Reallocates validity buffer if index\n+   * is larger than current capacity.\n+   */\n+  public void setNotNull(int index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Start a new value in the list vector.\n+   *\n+   * @param index index of the value to start\n+   */\n+  public long startNewValue(long index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    for (long i = lastSet + 1; i <= index; i++) {\n+      final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+      offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+    return checkedCastToInt(offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * End the current value.\n+   *\n+   * @param index index of the value to end\n+   * @param size  number of elements in the list that was written\n+   */\n+  public void endValue(int index, int size) {\n+    final long currentOffset = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    offsetBuffer.setLong((index + 1) * OFFSET_WIDTH, currentOffset + size);\n+  }\n+\n+  /**\n+   * Sets the value count for the vector.\n+   *\n+   * @param valueCount   value count\n+   */\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    if (valueCount > 0) {\n+      while (valueCount > getValidityAndOffsetValueCapacity()) {\n+        /* check if validity and offset buffers need to be re-allocated */\n+        reallocValidityAndOffsetBuffers();\n+      }\n+      for (long i = lastSet + 1; i < valueCount; i++) {\n+        /* fill the holes with offsets */\n+        final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+        offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+      }\n+    }\n+    /* valueCount for the data vector is the current end offset */\n+    final long childValueCount = (valueCount == 0) ? 0 :\n+            offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH);\n+    /* set the value count of data vector and this will take care of\n+     * checking whether data buffer needs to be reallocated.\n+     */\n+    vector.setValueCount(checkedCastToInt(childValueCount));\n+  }\n+\n+  public void setLastSet(int value) {\n+    lastSet = value;\n+  }\n+\n+  public long getLastSet() {\n+    return lastSet;\n+  }\n+\n+  @Override\n+  public int getElementStartIndex(int index) {\n\nReview comment:\n       This should return `long` and not be casted to `int`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-30T23:23:10.067+0000",
                    "updated": "2020-06-30T23:23:10.067+0000",
                    "started": "2020-06-30T23:23:10.066+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "453161",
                    "issueId": "13248476"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/worklog/453162",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "BryanCutler commented on a change in pull request #7275:\nURL: https://github.com/apache/arrow/pull/7275#discussion_r448032771\n\n\n\n##########\nFile path: java/vector/src/main/java/org/apache/arrow/vector/complex/LargeListVector.java\n##########\n@@ -0,0 +1,991 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.capAtMaxInt;\n+import static org.apache.arrow.memory.util.LargeMemoryUtil.checkedCastToInt;\n+import static org.apache.arrow.util.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.memory.util.ArrowBufPointer;\n+import org.apache.arrow.memory.util.ByteFunctionHelpers;\n+import org.apache.arrow.memory.util.CommonUtil;\n+import org.apache.arrow.memory.util.hash.ArrowBufHasher;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.AddOrGetResult;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BaseVariableWidthVector;\n+import org.apache.arrow.vector.BitVectorHelper;\n+import org.apache.arrow.vector.BufferBacked;\n+import org.apache.arrow.vector.DensityAwareVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.NullVector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.ZeroVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListReader;\n+import org.apache.arrow.vector.complex.impl.UnionLargeListWriter;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringArrayList;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n+import org.apache.arrow.vector.util.SchemaChangeRuntimeException;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+/**\n+ * A list vector contains lists of a specific type of elements.  Its structure contains 3 elements.\n+ * <ol>\n+ * <li>A validity buffer.</li>\n+ * <li> An offset buffer, that denotes lists boundaries. </li>\n+ * <li> A child data vector that contains the elements of lists. </li>\n+ * </ol>\n+ *\n+ * This is the LargeList variant of list, it has a 64-bit wide offset\n+ *\n+ * <p>\n+ *   todo review checkedCastToInt usage in this class.\n+ *   Once int64 indexed vectors are supported these checks aren't needed.\n+ * </p>\n+ */\n+public class LargeListVector extends BaseValueVector implements RepeatedValueVector, BaseListVector, PromotableVector {\n+\n+  public static LargeListVector empty(String name, BufferAllocator allocator) {\n+    return new LargeListVector(name, allocator, FieldType.nullable(ArrowType.LargeList.INSTANCE), null);\n+  }\n+\n+  public static final FieldVector DEFAULT_DATA_VECTOR = ZeroVector.INSTANCE;\n+  public static final String DATA_VECTOR_NAME = \"$data$\";\n+\n+  public static final byte OFFSET_WIDTH = 8;\n+  protected ArrowBuf offsetBuffer;\n+  protected FieldVector vector;\n+  protected final CallBack callBack;\n+  protected int valueCount;\n+  protected long offsetAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  private final String name;\n+\n+  protected String defaultDataVectorName = DATA_VECTOR_NAME;\n+  protected ArrowBuf validityBuffer;\n+  protected UnionLargeListReader reader;\n+  private final FieldType fieldType;\n+  private int validityAllocationSizeInBytes;\n+\n+  /**\n+   * The maximum index that is actually set.\n+   */\n+  private long lastSet;\n+\n+  /**\n+   * Constructs a new instance.\n+   *\n+   * @param name The name of the instance.\n+   * @param allocator The allocator to use for allocating/reallocating buffers.\n+   * @param fieldType The type of this list.\n+   * @param callBack A schema change callback.\n+   */\n+  public LargeListVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(allocator);\n+    this.name = name;\n+    this.validityBuffer = allocator.getEmpty();\n+    this.fieldType = checkNotNull(fieldType);\n+    this.callBack = callBack;\n+    this.validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n+    this.lastSet = -1;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.vector = vector == null ? DEFAULT_DATA_VECTOR : vector;\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    if (children.size() != 1) {\n+      throw new IllegalArgumentException(\"Lists have only one child. Found: \" + children);\n+    }\n+    Field field = children.get(0);\n+    AddOrGetResult<FieldVector> addOrGetVector = addOrGetVector(field.getFieldType());\n+    if (!addOrGetVector.isCreated()) {\n+      throw new IllegalArgumentException(\"Child vector already existed: \" + addOrGetVector.getVector());\n+    }\n+\n+    addOrGetVector.getVector().initializeChildrenFromFields(field.getChildren());\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    offsetAllocationSizeInBytes = (long) (numRecords + 1) * OFFSET_WIDTH;\n+    if (vector instanceof BaseFixedWidthVector || vector instanceof BaseVariableWidthVector) {\n+      vector.setInitialCapacity(numRecords * RepeatedValueVector.DEFAULT_REPEAT_PER_RECORD);\n+    } else {\n+      vector.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  /**\n+   * Specialized version of setInitialCapacity() for ListVector. This is\n+   * used by some callers when they want to explicitly control and be\n+   * conservative about memory allocated for inner data vector. This is\n+   * very useful when we are working with memory constraints for a query\n+   * and have a fixed amount of memory reserved for the record batch. In\n+   * such cases, we are likely to face OOM or related problems when\n+   * we reserve memory for a record batch with value count x and\n+   * do setInitialCapacity(x) such that each vector allocates only\n+   * what is necessary and not the default amount but the multiplier\n+   * forces the memory requirement to go beyond what was needed.\n+   *\n+   * @param numRecords value count\n+   * @param density density of ListVector. Density is the average size of\n+   *                list per position in the List vector. For example, a\n+   *                density value of 10 implies each position in the list\n+   *                vector has a list of 10 values.\n+   *                A density value of 0.1 implies out of 10 positions in\n+   *                the list vector, 1 position has a list of size 1 and\n+   *                remaining positions are null (no lists) or empty lists.\n+   *                This helps in tightly controlling the memory we provision\n+   *                for inner data vector.\n+   */\n+  @Override\n+  public void setInitialCapacity(int numRecords, double density) {\n+    validityAllocationSizeInBytes = getValidityBufferSizeFromCount(numRecords);\n+    if ((numRecords * density) >= Integer.MAX_VALUE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+\n+    offsetAllocationSizeInBytes = (numRecords + 1) * OFFSET_WIDTH;\n+\n+    int innerValueCapacity = Math.max((int) (numRecords * density), 1);\n+\n+    if (vector instanceof DensityAwareVector) {\n+      ((DensityAwareVector) vector).setInitialCapacity(innerValueCapacity, density);\n+    } else {\n+      vector.setInitialCapacity(innerValueCapacity);\n+    }\n+  }\n+\n+  /**\n+   * Get the density of this ListVector.\n+   * @return density\n+   */\n+  public double getDensity() {\n+    if (valueCount == 0) {\n+      return 0.0D;\n+    }\n+    final long startOffset = offsetBuffer.getLong(0);\n+    final long endOffset = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+    final double totalListSize = endOffset - startOffset;\n+    return totalListSize / valueCount;\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return singletonList(getDataVector());\n+  }\n+\n+  /**\n+   * Load the buffers of this vector with provided source buffers.\n+   * The caller manages the source buffers and populates them before invoking\n+   * this method.\n+   * @param fieldNode  the fieldNode indicating the value count\n+   * @param ownBuffers the buffers for this Field (own buffers only, children not included)\n+   */\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n+    ArrowBuf offBuffer = ownBuffers.get(1);\n+\n+    validityBuffer.getReferenceManager().release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = offBuffer.getReferenceManager().retain(offBuffer, allocator);\n+\n+    validityAllocationSizeInBytes = checkedCastToInt(validityBuffer.capacity());\n+    offsetAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    lastSet = fieldNode.getLength() - 1;\n+    valueCount = fieldNode.getLength();\n+  }\n+\n+  /**\n+   * Get the buffers belonging to this vector.\n+   * @return the inner buffers.\n+   */\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(2);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  /**\n+   * Set the reader and writer indexes for the inner buffers.\n+   */\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    offsetBuffer.readerIndex(0);\n+    if (valueCount == 0) {\n+      validityBuffer.writerIndex(0);\n+      offsetBuffer.writerIndex(0);\n+    } else {\n+      validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n+      offsetBuffer.writerIndex((valueCount + 1) * OFFSET_WIDTH);\n+    }\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n+  }\n+\n+  /**\n+   * Same as {@link #allocateNewSafe()}.\n+   */\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    if (!allocateNewSafe()) {\n+      throw new OutOfMemoryException(\"Failure while allocating memory\");\n+    }\n+  }\n+\n+  /**\n+   * Allocate memory for the vector. We internally use a default value count\n+   * of 4096 to allocate memory for at least these many elements in the\n+   * vector.\n+   *\n+   * @return false if memory allocation fails, true otherwise.\n+   */\n+  public boolean allocateNewSafe() {\n+    boolean success = false;\n+    try {\n+      /* we are doing a new allocation -- release the current buffers */\n+      clear();\n+      /* allocate validity buffer */\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      /* allocate offset and data buffer */\n+      boolean dataAlloc = false;\n+      try {\n+        allocateOffsetBuffer(offsetAllocationSizeInBytes);\n+        dataAlloc = vector.allocateNewSafe();\n+      } catch (Exception e) {\n+        e.printStackTrace();\n+        clear();\n+        return false;\n+      } finally {\n+        if (!dataAlloc) {\n+          clear();\n+        }\n+      }\n+      success = dataAlloc;\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+  }\n+  \n+  protected void allocateOffsetBuffer(final long size) {\n+    final int curSize = (int) size;\n+    offsetBuffer = allocator.buffer(curSize);\n+    offsetBuffer.readerIndex(0);\n+    offsetAllocationSizeInBytes = curSize;\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+  \n+  /**\n+   * Resize the vector to increase the capacity. The internal behavior is to\n+   * double the current value capacity.\n+   */\n+  @Override\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    /* reallocate the offset and data */\n+    reallocOffsetBuffer();\n+    vector.reAlloc();\n+  }\n+\n+  private void reallocValidityAndOffsetBuffers() {\n+    reallocOffsetBuffer();\n+    reallocValidityBuffer();\n+  }\n+  \n+  protected void reallocOffsetBuffer() {\n+    final long currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize = offsetAllocationSizeInBytes;\n+\n+    if (baseSize < currentBufferCapacity) {\n+      baseSize = currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    newAllocationSize = Math.min(newAllocationSize, (long) (OFFSET_WIDTH) * Integer.MAX_VALUE);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE || newAllocationSize <= baseSize) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer(newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetAllocationSizeInBytes = newAllocationSize;\n+  }\n+  \n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = checkedCastToInt(validityBuffer.capacity());\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = CommonUtil.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    validityBuffer.getReferenceManager().release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  /**\n+   * Same as {@link #copyFrom(int, int, ValueVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector.\n+   * @param inIndex position to copy from in source vector\n+   * @param outIndex position to copy to in this vector\n+   * @param from source vector\n+   */\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    FieldReader in = from.getReader();\n+    in.setPosition(inIndex);\n+    UnionLargeListWriter out = getWriter();\n+    out.setIndex(outIndex);\n+    ComplexCopier.copy(in, out);\n+  }\n+\n+  @Override\n+  public UInt4Vector getOffsetVector() {\n+    return null;\n+  }\n+\n+  /**\n+   * Get the inner data vector for this list vector.\n+   * @return data vector\n+   */\n+  @Override\n+  public FieldVector getDataVector() {\n+    return vector;\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((LargeListVector) target);\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return (validityBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return (offsetBuffer.memoryAddress());\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    return offsetBuffer;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  @Override\n+  public int hashCode(int index) {\n+    return hashCode(index, null);\n+  }\n+\n+  @Override\n+  public int hashCode(int index, ArrowBufHasher hasher) {\n+    if (isSet(index) == 0) {\n+      return ArrowBufPointer.NULL_HASH_CODE;\n+    }\n+    int hash = 0;\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    for (long i = start; i < end; i++) {\n+      hash = ByteFunctionHelpers.combineHash(hash, vector.hashCode(checkedCastToInt(i), hasher));\n+    }\n+    return hash;\n+  }\n+\n+  @Override\n+  public <OUT, IN> OUT accept(VectorVisitor<OUT, IN> visitor, IN value) {\n+    return visitor.visit(this, value);\n+  }\n+\n+  public UnionLargeListWriter getWriter() {\n+    return new UnionLargeListWriter(this);\n+  }\n+\n+  protected void replaceDataVector(FieldVector v) {\n+    vector.clear();\n+    vector = v;\n+  }\n+\n+  @Override\n+  public UnionVector promoteToUnion() {\n+    UnionVector vector = new UnionVector(\"$data$\", allocator, callBack);\n+    replaceDataVector(vector);\n+    invalidateReader();\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return vector;\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+\n+    LargeListVector to;\n+    TransferPair dataTransferPair;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      this(new LargeListVector(name, allocator, fieldType, callBack));\n+    }\n+\n+    public TransferImpl(LargeListVector to) {\n+      this.to = to;\n+      to.addOrGetVector(vector.getField().getFieldType());\n+      if (to.getDataVector() instanceof ZeroVector) {\n+        to.addOrGetVector(vector.getField().getFieldType());\n+      }\n+      dataTransferPair = getDataVector().makeTransferPair(to.getDataVector());\n+    }\n+\n+    /**\n+     * Transfer this vector'data to another vector. The memory associated\n+     * with this vector is transferred to the allocator of target vector\n+     * for accounting and management purposes.\n+     */\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      dataTransferPair.transfer();\n+      to.validityBuffer = transferBuffer(validityBuffer, to.allocator);\n+      to.offsetBuffer = transferBuffer(offsetBuffer, to.allocator);\n+      to.lastSet = lastSet;\n+      if (valueCount > 0) {\n+        to.setValueCount(valueCount);\n+      }\n+      clear();\n+    }\n+\n+    /**\n+     * Slice this vector at desired index and length and transfer the\n+     * corresponding data to the target vector.\n+     * @param startIndex start position of the split in source vector.\n+     * @param length length of the split.\n+     */\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      Preconditions.checkArgument(startIndex >= 0 && length >= 0 && startIndex + length <= valueCount,\n+          \"Invalid parameters startIndex: %s, length: %s for valueCount: %s\", startIndex, length, valueCount);\n+      final long startPoint = offsetBuffer.getLong(startIndex * OFFSET_WIDTH);\n+      final long sliceLength = offsetBuffer.getLong((startIndex + length) * OFFSET_WIDTH) - startPoint;\n+      to.clear();\n+      to.allocateOffsetBuffer((length + 1) * OFFSET_WIDTH);\n+      /* splitAndTransfer offset buffer */\n+      for (int i = 0; i < length + 1; i++) {\n+        final long relativeOffset = offsetBuffer.getLong((startIndex + i) * OFFSET_WIDTH) - startPoint;\n+        to.offsetBuffer.setLong(i * OFFSET_WIDTH, relativeOffset);\n+      }\n+      /* splitAndTransfer validity buffer */\n+      splitAndTransferValidityBuffer(startIndex, length, to);\n+      /* splitAndTransfer data buffer */\n+      dataTransferPair.splitAndTransfer(checkedCastToInt(startPoint), checkedCastToInt(sliceLength));\n+      to.lastSet = length - 1;\n+      to.setValueCount(length);\n+    }\n+\n+    /*\n+     * transfer the validity.\n+     */\n+    private void splitAndTransferValidityBuffer(int startIndex, int length, LargeListVector target) {\n+      int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+      int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+      int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+      int offset = startIndex % 8;\n+\n+      if (length > 0) {\n+        if (offset == 0) {\n+          // slice\n+          if (target.validityBuffer != null) {\n+            target.validityBuffer.getReferenceManager().release();\n+          }\n+          target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+          target.validityBuffer.getReferenceManager().retain(1);\n+        } else {\n+          /* Copy data\n+           * When the first bit starts from the middle of a byte (offset != 0),\n+           * copy data from src BitVector.\n+           * Each byte in the target is composed by a part in i-th byte,\n+           * another part in (i+1)-th byte.\n+           */\n+          target.allocateValidityBuffer(byteSizeTarget);\n+\n+          for (int i = 0; i < byteSizeTarget - 1; i++) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+            target.validityBuffer.setByte(i, (b1 + b2));\n+          }\n+\n+          /* Copying the last piece is done in the following manner:\n+           * if the source vector has 1 or more bytes remaining, we copy\n+           * the last piece as a byte formed by shifting data\n+           * from the current byte and the next byte.\n+           *\n+           * if the source vector has no more bytes remaining\n+           * (we are at the last byte), we copy the last piece as a byte\n+           * by shifting data from the current byte.\n+           */\n+          if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget, offset);\n+\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+          } else {\n+            byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                    firstByteSource + byteSizeTarget - 1, offset);\n+            target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+          }\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, LargeListVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public UnionLargeListReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionLargeListReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  /**\n+   * Initialize the data vector (and execute callback) if it hasn't already been done,\n+   * returns the data vector.\n+   */\n+  public <T extends ValueVector> AddOrGetResult<T> addOrGetVector(FieldType fieldType) {\n+    boolean created = false;\n+    if (vector instanceof NullVector) {\n+      vector = fieldType.createNewSingleVector(defaultDataVectorName, allocator, callBack);\n+      // returned vector must have the same field\n+      created = true;\n+      if (callBack != null &&\n+          // not a schema change if changing from ZeroVector to ZeroVector\n+          (fieldType.getType().getTypeID() != ArrowType.ArrowTypeID.Null)) {\n+        callBack.doWork();\n+      }\n+    }\n+\n+    if (vector.getField().getType().getTypeID() != fieldType.getType().getTypeID()) {\n+      final String msg = String.format(\"Inner vector type mismatch. Requested type: [%s], actual type: [%s]\",\n+          fieldType.getType().getTypeID(), vector.getField().getType().getTypeID());\n+      throw new SchemaChangeRuntimeException(msg);\n+    }\n+\n+    invalidateReader();\n+    return new AddOrGetResult<>((T) vector, created);\n+  }\n+\n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector.\n+   * @return size of underlying buffers.\n+   */\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int offsetBufferSize = (valueCount + 1) * OFFSET_WIDTH;\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    return offsetBufferSize + validityBufferSize + vector.getBufferSize();\n+  }\n+  \n+  @Override\n+  public int getBufferSizeFor(int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    final int validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n+    long innerVectorValueCount = offsetBuffer.getLong(valueCount * OFFSET_WIDTH);\n+\n+    return ((valueCount + 1) * OFFSET_WIDTH) +\n+        vector.getBufferSizeFor(checkedCastToInt(innerVectorValueCount)) +\n+        validityBufferSize;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    return new Field(getName(), fieldType, Collections.singletonList(getDataVector().getField()));\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.LIST;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return null;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    offsetBuffer = releaseBuffer(offsetBuffer);\n+    vector.clear();\n+    valueCount = 0;\n+    super.clear();\n+    validityBuffer = releaseBuffer(validityBuffer);\n+    lastSet = -1;\n+  }\n+\n+  @Override\n+  public void reset() {\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    vector.reset();\n+    valueCount = 0;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n+    lastSet = -1;\n+  }\n+\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      List<ArrowBuf> list = new ArrayList<>();\n+      list.add(offsetBuffer);\n+      list.add(validityBuffer);\n+      list.addAll(Arrays.asList(vector.getBuffers(false)));\n+      buffers = list.toArray(new ArrowBuf[list.size()]);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.getReferenceManager().retain();\n+      }\n+      clear();\n+    }\n+    return buffers;\n+  }\n+\n+  protected void invalidateReader() {\n+    reader = null;\n+  }\n+\n+  /**\n+   * Get the element in the list vector at a particular index.\n+   * @param index position of the element\n+   * @return Object at given position\n+   */\n+  @Override\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    }\n+    final List<Object> vals = new JsonStringArrayList<>();\n+    final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+    final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    final ValueVector vv = getDataVector();\n+    for (long i = start; i < end; i++) {\n+      vals.add(vv.getObject(checkedCastToInt(i)));\n+    }\n+\n+    return vals;\n+  }\n+\n+  /**\n+   * Check if element at given index is null.\n+   *\n+   * @param index position of element\n+   * @return true if element at given index is null, false otherwise\n+   */\n+  @Override\n+  public boolean isNull(int index) {\n+    return (isSet(index) == 0);\n+  }\n+\n+  /**\n+   * Check if element at given index is empty list.\n+   * @param index position of element\n+   * @return true if element at given index is empty list or NULL, false otherwise\n+   */\n+  public boolean isEmpty(int index) {\n+    if (isNull(index)) {\n+      return true;\n+    } else {\n+      final long start = offsetBuffer.getLong(index * OFFSET_WIDTH);\n+      final long end = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+      return start == end;\n+    }\n+  }\n+\n+  /**\n+   * Same as {@link #isNull(int)}.\n+   *\n+   * @param index  position of element\n+   * @return 1 if element at given index is not null, 0 otherwise\n+   */\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return (b >> bitIndex) & 0x01;\n+  }\n+\n+  /**\n+   * Get the number of elements that are null in the vector.\n+   *\n+   * @return the number of null elements.\n+   */\n+  @Override\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector.\n+   * @return number of elements that vector can hold.\n+   */\n+  @Override\n+  public int getValueCapacity() {\n+    return getValidityAndOffsetValueCapacity();\n+  }\n+  \n+  protected int getOffsetBufferValueCapacity() {\n+    return checkedCastToInt(offsetBuffer.capacity() / OFFSET_WIDTH);\n+  }\n+  \n+  private int getValidityAndOffsetValueCapacity() {\n+    final int offsetValueCapacity = Math.max(getOffsetBufferValueCapacity() - 1, 0);\n+    return Math.min(offsetValueCapacity, getValidityBufferValueCapacity());\n+  }\n+\n+  private int getValidityBufferValueCapacity() {\n+    return capAtMaxInt(validityBuffer.capacity() * 8);\n+  }\n+\n+  /**\n+   * Sets the list at index to be not-null.  Reallocates validity buffer if index\n+   * is larger than current capacity.\n+   */\n+  public void setNotNull(int index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+  }\n+\n+  /**\n+   * Start a new value in the list vector.\n+   *\n+   * @param index index of the value to start\n+   */\n+  public long startNewValue(long index) {\n+    while (index >= getValidityAndOffsetValueCapacity()) {\n+      reallocValidityAndOffsetBuffers();\n+    }\n+    for (long i = lastSet + 1; i <= index; i++) {\n+      final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+      offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+    }\n+    BitVectorHelper.setBit(validityBuffer, index);\n+    lastSet = index;\n+    return checkedCastToInt(offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH));\n+  }\n+\n+  /**\n+   * End the current value.\n+   *\n+   * @param index index of the value to end\n+   * @param size  number of elements in the list that was written\n+   */\n+  public void endValue(int index, int size) {\n+    final long currentOffset = offsetBuffer.getLong((index + 1) * OFFSET_WIDTH);\n+    offsetBuffer.setLong((index + 1) * OFFSET_WIDTH, currentOffset + size);\n+  }\n+\n+  /**\n+   * Sets the value count for the vector.\n+   *\n+   * @param valueCount   value count\n+   */\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    if (valueCount > 0) {\n+      while (valueCount > getValidityAndOffsetValueCapacity()) {\n+        /* check if validity and offset buffers need to be re-allocated */\n+        reallocValidityAndOffsetBuffers();\n+      }\n+      for (long i = lastSet + 1; i < valueCount; i++) {\n+        /* fill the holes with offsets */\n+        final long currentOffset = offsetBuffer.getLong(i * OFFSET_WIDTH);\n+        offsetBuffer.setLong((i + 1) * OFFSET_WIDTH, currentOffset);\n+      }\n+    }\n+    /* valueCount for the data vector is the current end offset */\n+    final long childValueCount = (valueCount == 0) ? 0 :\n+            offsetBuffer.getLong((lastSet + 1) * OFFSET_WIDTH);\n+    /* set the value count of data vector and this will take care of\n+     * checking whether data buffer needs to be reallocated.\n+     */\n+    vector.setValueCount(checkedCastToInt(childValueCount));\n\nReview comment:\n       Also indicate this in the javadoc here and probably for the class. It might even be a good idea to raise an error if the user tries to add too many elements, otherwise things might just start looking wrong.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-30T23:24:34.899+0000",
                    "updated": "2020-06-30T23:24:34.899+0000",
                    "started": "2020-06-30T23:24:34.899+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "453162",
                    "issueId": "13248476"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 25800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@63a2f08c[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6ccfc76e[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@20431fe[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@10626267[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3db5cd20[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7fe80ce7[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5cc04925[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5fb27980[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4c7d739b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@73cdd1c7[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2d9a27fa[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@61a825b0[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 25800,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Jul 06 05:42:00 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-07-06T05:42:00.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-6110/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2019-08-02T03:42:02.000+0000",
        "updated": "2020-07-06T05:42:35.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "7h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 25800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Java] Support LargeList Type and add integration test with C++",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/comment/17045492",
                    "id": "17045492",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=projjal",
                        "name": "projjal",
                        "key": "projjal",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34050",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34050",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34050",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34050"
                        },
                        "displayName": "Projjal Chanda",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "[~emkornfield@gmail.com] [~wesm] Can I help with this? Or any other blocking issues which might need help?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=projjal",
                        "name": "projjal",
                        "key": "projjal",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34050",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34050",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34050",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34050"
                        },
                        "displayName": "Projjal Chanda",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2020-02-26T12:17:57.545+0000",
                    "updated": "2020-02-26T12:17:57.545+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/comment/17045633",
                    "id": "17045633",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "[~projjal]\u00a0please do :).\u00a0 There isn't a direct blocker but until Vectors support int64 indexing, the value of this will likely be limited.\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2020-02-26T15:42:22.605+0000",
                    "updated": "2020-02-26T15:42:22.605+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13248476/comment/17151759",
                    "id": "17151759",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 7275\n[https://github.com/apache/arrow/pull/7275]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-07-06T05:42:00.556+0000",
                    "updated": "2020-07-06T05:42:00.556+0000"
                }
            ],
            "maxResults": 3,
            "total": 3,
            "startAt": 0
        },
        "customfield_12311820": "0|z059jc:",
        "customfield_12314139": null
    }
}