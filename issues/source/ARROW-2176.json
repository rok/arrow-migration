{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13139477",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13139477",
    "key": "ARROW-2176",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341707",
                "id": "12341707",
                "description": "",
                "name": "0.9.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-03-19"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alendit",
            "name": "alendit",
            "key": "alendit",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Dimitri Vorona",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alendit",
            "name": "alendit",
            "key": "alendit",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Dimitri Vorona",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alendit",
            "name": "alendit",
            "key": "alendit",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Dimitri Vorona",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2176/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@2fd69d74[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e3cbf4f[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3062722f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4bdf75ab[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@917085d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@16362f6[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@22b38bff[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@1271c02f[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@239577dc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@397bc58a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7a95d29[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@1b45954b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Mar 02 14:37:38 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-03-02T14:29:31.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2176/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2018-02-19T16:18:21.000+0000",
        "updated": "2018-03-02T14:37:38.000+0000",
        "timeoriginalestimate": null,
        "description": "[The IPC format|https://arrow.apache.org/docs/ipc.html]\u00a0specifies a possibility of sending additional dictionary batches with a previously seen id and a isDelta flag to extend the existing dictionaries with new entries. Right now, the DictioniaryBuilder (as well as IPC writer and reader) do not support generation of delta dictionaries.\r\n\r\nThis pull request contains a basic implementation of the DictionaryBuilder with delta dictionaries support. The use API can be seen in the dictionary tests (i.e. [here|https://github.com/alendit/arrow/blob/delta_dictionary_builder/cpp/src/arrow/array-test.cc#L1773]). The basic idea is that the user just reuses the builder object after calling Finish(Array*) for the first time. Subsequent calls to Append will create new entries only for the unseen element and reuse id from previous dictionaries for the seen ones.\r\n\r\nSome considerations:\r\n # The API is pretty implicit, and additional flag for Finish, which explicitly indicates a desire to use the builder for delta dictionary generation might be expedient from the error avoidance point of view.\r\n # Right now the implementation uses an additional \"overflow dictionary\" to store the seen items. This adds a copy on each Finish call and an additional lookup at each GetItem or Append call. I assume, we might get away with returning Array slices at Finish, which would remove the need for an additional overflow dictionary. If the gist of the PR is approved, I can look into further optimizations.\r\n\r\nThe Writer and Reader extensions would be pretty simple, since the DictionaryBuilder API remains basically the same.\u00a0",
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Extend DictionaryBuilder to support delta dictionaries",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": "https://github.com/apache/arrow/pull/1629",
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13139477/comment/16369282",
                    "id": "16369282",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "alendit opened a new pull request #1629: ARROW-2176: [C++] Extend DictionaryBuilder to support delta dictionaries\nURL: https://github.com/apache/arrow/pull/1629\n \n \n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-02-19T16:21:11.106+0000",
                    "updated": "2018-02-19T16:21:11.106+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13139477/comment/16371534",
                    "id": "16371534",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "alendit commented on issue #1629: ARROW-2176: [C++] Extend DictionaryBuilder to support delta dictionaries\nURL: https://github.com/apache/arrow/pull/1629#issuecomment-367360826\n \n \n   Added a comment to the `DictionaryBuilder` and ammended the comments on `Finish` and `FinishInternal`. Also rebased on newest `master`.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-02-21T15:21:07.804+0000",
                    "updated": "2018-02-21T15:21:07.804+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13139477/comment/16372196",
                    "id": "16372196",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1629: ARROW-2176: [C++] Extend DictionaryBuilder to support delta dictionaries\nURL: https://github.com/apache/arrow/pull/1629#issuecomment-367511802\n \n \n   rebaed\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-02-21T23:18:48.151+0000",
                    "updated": "2018-02-21T23:18:48.151+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13139477/comment/16372197",
                    "id": "16372197",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1629: ARROW-2176: [C++] Extend DictionaryBuilder to support delta dictionaries\nURL: https://github.com/apache/arrow/pull/1629#issuecomment-367511802\n \n \n   rebased\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-02-21T23:18:52.167+0000",
                    "updated": "2018-02-21T23:18:52.167+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13139477/comment/16372483",
                    "id": "16372483",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "alendit commented on issue #1629: ARROW-2176: [C++] Extend DictionaryBuilder to support delta dictionaries\nURL: https://github.com/apache/arrow/pull/1629#issuecomment-367583889\n \n \n   There was a typo in the last commit. Fixed it and rebased again.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-02-22T06:47:01.552+0000",
                    "updated": "2018-02-22T06:47:01.552+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13139477/comment/16383632",
                    "id": "16383632",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "xhochy closed pull request #1629: ARROW-2176: [C++] Extend DictionaryBuilder to support delta dictionaries\nURL: https://github.com/apache/arrow/pull/1629\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/array-test.cc b/cpp/src/arrow/array-test.cc\nindex 1d321e677..4aaf18256 100644\n--- a/cpp/src/arrow/array-test.cc\n+++ b/cpp/src/arrow/array-test.cc\n@@ -1770,6 +1770,154 @@ TYPED_TEST(TestDictionaryBuilder, DoubleTableSize) {\n   }\n }\n \n+TYPED_TEST(TestDictionaryBuilder, DeltaDictionary) {\n+  DictionaryBuilder<TypeParam> builder(default_memory_pool());\n+\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Build expected data for the initial dictionary\n+  NumericBuilder<TypeParam> dict_builder1;\n+  ASSERT_OK(dict_builder1.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(dict_builder1.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> dict_array1;\n+  ASSERT_OK(dict_builder1.Finish(&dict_array1));\n+  auto dtype1 = std::make_shared<DictionaryType>(int8(), dict_array1);\n+\n+  Int8Builder int_builder1;\n+  ASSERT_OK(int_builder1.Append(0));\n+  ASSERT_OK(int_builder1.Append(1));\n+  ASSERT_OK(int_builder1.Append(0));\n+  ASSERT_OK(int_builder1.Append(1));\n+  std::shared_ptr<Array> int_array1;\n+  ASSERT_OK(int_builder1.Finish(&int_array1));\n+\n+  DictionaryArray expected(dtype1, int_array1);\n+  ASSERT_TRUE(expected.Equals(result));\n+\n+  // extend the dictionary builder with new data\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+\n+  std::shared_ptr<Array> result_delta;\n+  ASSERT_OK(builder.Finish(&result_delta));\n+\n+  // Build expected data for the delta dictionary\n+  NumericBuilder<TypeParam> dict_builder2;\n+  ASSERT_OK(dict_builder2.Append(static_cast<typename TypeParam::c_type>(3)));\n+  std::shared_ptr<Array> dict_array2;\n+  ASSERT_OK(dict_builder2.Finish(&dict_array2));\n+  auto dtype2 = std::make_shared<DictionaryType>(int8(), dict_array2);\n+\n+  Int8Builder int_builder2;\n+  ASSERT_OK(int_builder2.Append(1));\n+  ASSERT_OK(int_builder2.Append(2));\n+  ASSERT_OK(int_builder2.Append(2));\n+  ASSERT_OK(int_builder2.Append(0));\n+  ASSERT_OK(int_builder2.Append(2));\n+  std::shared_ptr<Array> int_array2;\n+  ASSERT_OK(int_builder2.Finish(&int_array2));\n+\n+  DictionaryArray expected_delta(dtype2, int_array2);\n+  ASSERT_TRUE(expected_delta.Equals(result_delta));\n+}\n+\n+TYPED_TEST(TestDictionaryBuilder, DoubleDeltaDictionary) {\n+  DictionaryBuilder<TypeParam> builder(default_memory_pool());\n+\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Build expected data for the initial dictionary\n+  NumericBuilder<TypeParam> dict_builder1;\n+  ASSERT_OK(dict_builder1.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(dict_builder1.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> dict_array1;\n+  ASSERT_OK(dict_builder1.Finish(&dict_array1));\n+  auto dtype1 = std::make_shared<DictionaryType>(int8(), dict_array1);\n+\n+  Int8Builder int_builder1;\n+  ASSERT_OK(int_builder1.Append(0));\n+  ASSERT_OK(int_builder1.Append(1));\n+  ASSERT_OK(int_builder1.Append(0));\n+  ASSERT_OK(int_builder1.Append(1));\n+  std::shared_ptr<Array> int_array1;\n+  ASSERT_OK(int_builder1.Finish(&int_array1));\n+\n+  DictionaryArray expected(dtype1, int_array1);\n+  ASSERT_TRUE(expected.Equals(result));\n+\n+  // extend the dictionary builder with new data\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+\n+  std::shared_ptr<Array> result_delta1;\n+  ASSERT_OK(builder.Finish(&result_delta1));\n+\n+  // Build expected data for the delta dictionary\n+  NumericBuilder<TypeParam> dict_builder2;\n+  ASSERT_OK(dict_builder2.Append(static_cast<typename TypeParam::c_type>(3)));\n+  std::shared_ptr<Array> dict_array2;\n+  ASSERT_OK(dict_builder2.Finish(&dict_array2));\n+  auto dtype2 = std::make_shared<DictionaryType>(int8(), dict_array2);\n+\n+  Int8Builder int_builder2;\n+  ASSERT_OK(int_builder2.Append(1));\n+  ASSERT_OK(int_builder2.Append(2));\n+  ASSERT_OK(int_builder2.Append(2));\n+  ASSERT_OK(int_builder2.Append(0));\n+  ASSERT_OK(int_builder2.Append(2));\n+  std::shared_ptr<Array> int_array2;\n+  ASSERT_OK(int_builder2.Finish(&int_array2));\n+\n+  DictionaryArray expected_delta1(dtype2, int_array2);\n+  ASSERT_TRUE(expected_delta1.Equals(result_delta1));\n+\n+  // extend the dictionary builder with new data again\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(4)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(5)));\n+\n+  std::shared_ptr<Array> result_delta2;\n+  ASSERT_OK(builder.Finish(&result_delta2));\n+\n+  // Build expected data for the delta dictionary again\n+  NumericBuilder<TypeParam> dict_builder3;\n+  ASSERT_OK(dict_builder3.Append(static_cast<typename TypeParam::c_type>(4)));\n+  ASSERT_OK(dict_builder3.Append(static_cast<typename TypeParam::c_type>(5)));\n+  std::shared_ptr<Array> dict_array3;\n+  ASSERT_OK(dict_builder3.Finish(&dict_array3));\n+  auto dtype3 = std::make_shared<DictionaryType>(int8(), dict_array3);\n+\n+  Int8Builder int_builder3;\n+  ASSERT_OK(int_builder3.Append(0));\n+  ASSERT_OK(int_builder3.Append(1));\n+  ASSERT_OK(int_builder3.Append(2));\n+  ASSERT_OK(int_builder3.Append(3));\n+  ASSERT_OK(int_builder3.Append(4));\n+  std::shared_ptr<Array> int_array3;\n+  ASSERT_OK(int_builder3.Finish(&int_array3));\n+\n+  DictionaryArray expected_delta2(dtype3, int_array3);\n+  ASSERT_TRUE(expected_delta2.Equals(result_delta2));\n+}\n+\n TEST(TestStringDictionaryBuilder, Basic) {\n   // Build the dictionary Array\n   StringDictionaryBuilder builder(default_memory_pool());\n@@ -1835,6 +1983,146 @@ TEST(TestStringDictionaryBuilder, DoubleTableSize) {\n   ASSERT_TRUE(expected.Equals(result));\n }\n \n+TEST(TestStringDictionaryBuilder, DeltaDictionary) {\n+  // Build the dictionary Array\n+  StringDictionaryBuilder builder(default_memory_pool());\n+  ASSERT_OK(builder.Append(\"test\"));\n+  ASSERT_OK(builder.Append(\"test2\"));\n+  ASSERT_OK(builder.Append(\"test\"));\n+\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Build expected data\n+  StringBuilder str_builder1;\n+  ASSERT_OK(str_builder1.Append(\"test\"));\n+  ASSERT_OK(str_builder1.Append(\"test2\"));\n+  std::shared_ptr<Array> str_array1;\n+  ASSERT_OK(str_builder1.Finish(&str_array1));\n+  auto dtype1 = std::make_shared<DictionaryType>(int8(), str_array1);\n+\n+  Int8Builder int_builder1;\n+  ASSERT_OK(int_builder1.Append(0));\n+  ASSERT_OK(int_builder1.Append(1));\n+  ASSERT_OK(int_builder1.Append(0));\n+  std::shared_ptr<Array> int_array1;\n+  ASSERT_OK(int_builder1.Finish(&int_array1));\n+\n+  DictionaryArray expected(dtype1, int_array1);\n+  ASSERT_TRUE(expected.Equals(result));\n+\n+  // build a delta dictionary\n+  ASSERT_OK(builder.Append(\"test2\"));\n+  ASSERT_OK(builder.Append(\"test3\"));\n+  ASSERT_OK(builder.Append(\"test2\"));\n+\n+  std::shared_ptr<Array> result_delta;\n+  ASSERT_OK(builder.Finish(&result_delta));\n+\n+  // Build expected data\n+  StringBuilder str_builder2;\n+  ASSERT_OK(str_builder2.Append(\"test3\"));\n+  std::shared_ptr<Array> str_array2;\n+  ASSERT_OK(str_builder2.Finish(&str_array2));\n+  auto dtype2 = std::make_shared<DictionaryType>(int8(), str_array2);\n+\n+  Int8Builder int_builder2;\n+  ASSERT_OK(int_builder2.Append(1));\n+  ASSERT_OK(int_builder2.Append(2));\n+  ASSERT_OK(int_builder2.Append(1));\n+  std::shared_ptr<Array> int_array2;\n+  ASSERT_OK(int_builder2.Finish(&int_array2));\n+\n+  DictionaryArray expected_delta(dtype2, int_array2);\n+  ASSERT_TRUE(expected_delta.Equals(result_delta));\n+}\n+\n+TEST(TestStringDictionaryBuilder, BigDeltaDictionary) {\n+  constexpr int16_t kTestLength = 2048;\n+  // Build the dictionary Array\n+  StringDictionaryBuilder builder(default_memory_pool());\n+\n+  StringBuilder str_builder1;\n+  Int16Builder int_builder1;\n+\n+  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n+    std::stringstream sstream;\n+    sstream << \"test\" << idx;\n+    ASSERT_OK(builder.Append(sstream.str()));\n+    ASSERT_OK(str_builder1.Append(sstream.str()));\n+    ASSERT_OK(int_builder1.Append(idx));\n+  }\n+\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  std::shared_ptr<Array> str_array1;\n+  ASSERT_OK(str_builder1.Finish(&str_array1));\n+  auto dtype1 = std::make_shared<DictionaryType>(int16(), str_array1);\n+\n+  std::shared_ptr<Array> int_array1;\n+  ASSERT_OK(int_builder1.Finish(&int_array1));\n+\n+  DictionaryArray expected(dtype1, int_array1);\n+  ASSERT_TRUE(expected.Equals(result));\n+\n+  // build delta 1\n+  StringBuilder str_builder2;\n+  Int16Builder int_builder2;\n+\n+  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n+    ASSERT_OK(builder.Append(\"test1\"));\n+    ASSERT_OK(int_builder2.Append(1));\n+  }\n+\n+  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n+    ASSERT_OK(builder.Append(\"test_new_value1\"));\n+    ASSERT_OK(int_builder2.Append(kTestLength));\n+  }\n+  ASSERT_OK(str_builder2.Append(\"test_new_value1\"));\n+\n+  std::shared_ptr<Array> result2;\n+  ASSERT_OK(builder.Finish(&result2));\n+\n+  std::shared_ptr<Array> str_array2;\n+  ASSERT_OK(str_builder2.Finish(&str_array2));\n+  auto dtype2 = std::make_shared<DictionaryType>(int16(), str_array2);\n+\n+  std::shared_ptr<Array> int_array2;\n+  ASSERT_OK(int_builder2.Finish(&int_array2));\n+\n+  DictionaryArray expected2(dtype2, int_array2);\n+  ASSERT_TRUE(expected2.Equals(result2));\n+\n+  // build delta 2\n+  StringBuilder str_builder3;\n+  Int16Builder int_builder3;\n+\n+  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n+    ASSERT_OK(builder.Append(\"test2\"));\n+    ASSERT_OK(int_builder3.Append(2));\n+  }\n+\n+  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n+    ASSERT_OK(builder.Append(\"test_new_value2\"));\n+    ASSERT_OK(int_builder3.Append(kTestLength + 1));\n+  }\n+  ASSERT_OK(str_builder3.Append(\"test_new_value2\"));\n+\n+  std::shared_ptr<Array> result3;\n+  ASSERT_OK(builder.Finish(&result3));\n+\n+  std::shared_ptr<Array> str_array3;\n+  ASSERT_OK(str_builder3.Finish(&str_array3));\n+  auto dtype3 = std::make_shared<DictionaryType>(int16(), str_array3);\n+\n+  std::shared_ptr<Array> int_array3;\n+  ASSERT_OK(int_builder3.Finish(&int_array3));\n+\n+  DictionaryArray expected3(dtype3, int_array3);\n+  ASSERT_TRUE(expected3.Equals(result3));\n+}\n+\n TEST(TestFixedSizeBinaryDictionaryBuilder, Basic) {\n   // Build the dictionary Array\n   DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n@@ -1867,6 +2155,65 @@ TEST(TestFixedSizeBinaryDictionaryBuilder, Basic) {\n   ASSERT_TRUE(expected.Equals(result));\n }\n \n+TEST(TestFixedSizeBinaryDictionaryBuilder, DeltaDictionary) {\n+  // Build the dictionary Array\n+  DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n+                                                 default_memory_pool());\n+  std::vector<uint8_t> test{12, 12, 11, 12};\n+  std::vector<uint8_t> test2{12, 12, 11, 11};\n+  std::vector<uint8_t> test3{12, 12, 11, 10};\n+\n+  ASSERT_OK(builder.Append(test.data()));\n+  ASSERT_OK(builder.Append(test2.data()));\n+  ASSERT_OK(builder.Append(test.data()));\n+\n+  std::shared_ptr<Array> result1;\n+  ASSERT_OK(builder.Finish(&result1));\n+\n+  // Build expected data\n+  FixedSizeBinaryBuilder fsb_builder1(arrow::fixed_size_binary(4));\n+  ASSERT_OK(fsb_builder1.Append(test.data()));\n+  ASSERT_OK(fsb_builder1.Append(test2.data()));\n+  std::shared_ptr<Array> fsb_array1;\n+  ASSERT_OK(fsb_builder1.Finish(&fsb_array1));\n+  auto dtype1 = std::make_shared<DictionaryType>(int8(), fsb_array1);\n+\n+  Int8Builder int_builder1;\n+  ASSERT_OK(int_builder1.Append(0));\n+  ASSERT_OK(int_builder1.Append(1));\n+  ASSERT_OK(int_builder1.Append(0));\n+  std::shared_ptr<Array> int_array1;\n+  ASSERT_OK(int_builder1.Finish(&int_array1));\n+\n+  DictionaryArray expected1(dtype1, int_array1);\n+  ASSERT_TRUE(expected1.Equals(result1));\n+\n+  // build delta dictionary\n+  ASSERT_OK(builder.Append(test.data()));\n+  ASSERT_OK(builder.Append(test2.data()));\n+  ASSERT_OK(builder.Append(test3.data()));\n+\n+  std::shared_ptr<Array> result2;\n+  ASSERT_OK(builder.Finish(&result2));\n+\n+  // Build expected data\n+  FixedSizeBinaryBuilder fsb_builder2(arrow::fixed_size_binary(4));\n+  ASSERT_OK(fsb_builder2.Append(test3.data()));\n+  std::shared_ptr<Array> fsb_array2;\n+  ASSERT_OK(fsb_builder2.Finish(&fsb_array2));\n+  auto dtype2 = std::make_shared<DictionaryType>(int8(), fsb_array2);\n+\n+  Int8Builder int_builder2;\n+  ASSERT_OK(int_builder2.Append(0));\n+  ASSERT_OK(int_builder2.Append(1));\n+  ASSERT_OK(int_builder2.Append(2));\n+  std::shared_ptr<Array> int_array2;\n+  ASSERT_OK(int_builder2.Finish(&int_array2));\n+\n+  DictionaryArray expected2(dtype2, int_array2);\n+  ASSERT_TRUE(expected2.Equals(result2));\n+}\n+\n TEST(TestFixedSizeBinaryDictionaryBuilder, DoubleTableSize) {\n   // Build the dictionary Array\n   DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\ndiff --git a/cpp/src/arrow/builder.cc b/cpp/src/arrow/builder.cc\nindex 6f9749d19..ef4e7fde9 100644\n--- a/cpp/src/arrow/builder.cc\n+++ b/cpp/src/arrow/builder.cc\n@@ -818,6 +818,7 @@ DictionaryBuilder<T>::DictionaryBuilder(const std::shared_ptr<DataType>& type,\n     : ArrayBuilder(type, pool),\n       hash_slots_(nullptr),\n       dict_builder_(type, pool),\n+      overflow_dict_builder_(type, pool),\n       values_builder_(pool),\n       byte_width_(-1) {\n   if (!::arrow::CpuInfo::initialized()) {\n@@ -841,6 +842,7 @@ DictionaryBuilder<FixedSizeBinaryType>::DictionaryBuilder(\n     : ArrayBuilder(type, pool),\n       hash_slots_(nullptr),\n       dict_builder_(type, pool),\n+      overflow_dict_builder_(type, pool),\n       values_builder_(pool),\n       byte_width_(static_cast<const FixedSizeBinaryType&>(*type).byte_width()) {\n   if (!::arrow::CpuInfo::initialized()) {\n@@ -856,6 +858,7 @@ Status DictionaryBuilder<T>::Init(int64_t elements) {\n   RETURN_NOT_OK(internal::NewHashTable(kInitialHashTableSize, pool_, &hash_table_));\n   hash_slots_ = reinterpret_cast<int32_t*>(hash_table_->mutable_data());\n   hash_table_size_ = kInitialHashTableSize;\n+  entry_id_offset_ = 0;\n   mod_bitmask_ = kInitialHashTableSize - 1;\n   hash_table_load_threshold_ =\n       static_cast<int64_t>(static_cast<double>(elements) * kMaxHashTableLoad);\n@@ -893,24 +896,6 @@ Status DictionaryBuilder<NullType>::Resize(int64_t capacity) {\n   }\n }\n \n-template <typename T>\n-Status DictionaryBuilder<T>::FinishInternal(std::shared_ptr<ArrayData>* out) {\n-  std::shared_ptr<Array> dictionary;\n-  RETURN_NOT_OK(dict_builder_.Finish(&dictionary));\n-\n-  RETURN_NOT_OK(values_builder_.FinishInternal(out));\n-  (*out)->type = std::make_shared<DictionaryType>((*out)->type, dictionary);\n-  return Status::OK();\n-}\n-\n-Status DictionaryBuilder<NullType>::FinishInternal(std::shared_ptr<ArrayData>* out) {\n-  std::shared_ptr<Array> dictionary = std::make_shared<NullArray>(0);\n-\n-  RETURN_NOT_OK(values_builder_.FinishInternal(out));\n-  (*out)->type = std::make_shared<DictionaryType>((*out)->type, dictionary);\n-  return Status::OK();\n-}\n-\n template <typename T>\n Status DictionaryBuilder<T>::Append(const Scalar& value) {\n   RETURN_NOT_OK(Reserve(1));\n@@ -930,7 +915,7 @@ Status DictionaryBuilder<T>::Append(const Scalar& value) {\n \n   if (index == kHashSlotEmpty) {\n     // Not in the hash table, so we insert it now\n-    index = static_cast<hash_slot_t>(dict_builder_.length());\n+    index = static_cast<hash_slot_t>(dict_builder_.length() + entry_id_offset_);\n     hash_slots_[j] = index;\n     RETURN_NOT_OK(AppendDictionary(value));\n \n@@ -991,8 +976,8 @@ Status DictionaryBuilder<NullType>::AppendNull() { return values_builder_.Append\n \n template <typename T>\n Status DictionaryBuilder<T>::DoubleTableSize() {\n-#define INNER_LOOP                                                \\\n-  Scalar value = GetDictionaryValue(static_cast<int64_t>(index)); \\\n+#define INNER_LOOP                                                               \\\n+  Scalar value = GetDictionaryValue(dict_builder_, static_cast<int64_t>(index)); \\\n   int64_t j = HashValue(value) & new_mod_bitmask;\n \n   DOUBLE_TABLE_SIZE(, INNER_LOOP);\n@@ -1002,14 +987,64 @@ Status DictionaryBuilder<T>::DoubleTableSize() {\n \n template <typename T>\n typename DictionaryBuilder<T>::Scalar DictionaryBuilder<T>::GetDictionaryValue(\n-    int64_t index) {\n-  const Scalar* data = reinterpret_cast<const Scalar*>(dict_builder_.data()->data());\n+    typename TypeTraits<T>::BuilderType& dictionary_builder, int64_t index) {\n+  const Scalar* data = reinterpret_cast<const Scalar*>(dictionary_builder.data()->data());\n   return data[index];\n }\n \n+template <typename T>\n+Status DictionaryBuilder<T>::FinishInternal(std::shared_ptr<ArrayData>* out) {\n+  entry_id_offset_ += dict_builder_.length();\n+  RETURN_NOT_OK(overflow_dict_builder_.Append(\n+      reinterpret_cast<const DictionaryBuilder<T>::Scalar*>(dict_builder_.data()->data()),\n+      dict_builder_.length(), nullptr));\n+\n+  std::shared_ptr<Array> dictionary;\n+  RETURN_NOT_OK(dict_builder_.Finish(&dictionary));\n+\n+  RETURN_NOT_OK(values_builder_.FinishInternal(out));\n+  (*out)->type = std::make_shared<DictionaryType>((*out)->type, dictionary);\n+\n+  RETURN_NOT_OK(dict_builder_.Init(capacity_));\n+  RETURN_NOT_OK(values_builder_.Init(capacity_));\n+  return Status::OK();\n+}\n+\n+Status DictionaryBuilder<NullType>::FinishInternal(std::shared_ptr<ArrayData>* out) {\n+  std::shared_ptr<Array> dictionary = std::make_shared<NullArray>(0);\n+\n+  RETURN_NOT_OK(values_builder_.FinishInternal(out));\n+  (*out)->type = std::make_shared<DictionaryType>((*out)->type, dictionary);\n+  return Status::OK();\n+}\n+\n template <>\n-const uint8_t* DictionaryBuilder<FixedSizeBinaryType>::GetDictionaryValue(int64_t index) {\n-  return dict_builder_.GetValue(index);\n+const uint8_t* DictionaryBuilder<FixedSizeBinaryType>::GetDictionaryValue(\n+    typename TypeTraits<FixedSizeBinaryType>::BuilderType& dictionary_builder,\n+    int64_t index) {\n+  return dictionary_builder.GetValue(index);\n+}\n+\n+template <>\n+Status DictionaryBuilder<FixedSizeBinaryType>::FinishInternal(\n+    std::shared_ptr<ArrayData>* out) {\n+  entry_id_offset_ += dict_builder_.length();\n+\n+  for (uint64_t index = 0, limit = dict_builder_.length(); index < limit; ++index) {\n+    const Scalar value = GetDictionaryValue(dict_builder_, index);\n+    RETURN_NOT_OK(overflow_dict_builder_.Append(value));\n+  }\n+\n+  std::shared_ptr<Array> dictionary;\n+  RETURN_NOT_OK(dict_builder_.Finish(&dictionary));\n+\n+  RETURN_NOT_OK(values_builder_.FinishInternal(out));\n+  (*out)->type = std::make_shared<DictionaryType>((*out)->type, dictionary);\n+\n+  RETURN_NOT_OK(dict_builder_.Init(capacity_));\n+  RETURN_NOT_OK(values_builder_.Init(capacity_));\n+\n+  return Status::OK();\n }\n \n template <typename T>\n@@ -1024,16 +1059,34 @@ int64_t DictionaryBuilder<FixedSizeBinaryType>::HashValue(const Scalar& value) {\n \n template <typename T>\n bool DictionaryBuilder<T>::SlotDifferent(hash_slot_t index, const Scalar& value) {\n-  const Scalar other = GetDictionaryValue(static_cast<int64_t>(index));\n-  return other != value;\n+  const bool value_found =\n+      index >= entry_id_offset_ &&\n+      GetDictionaryValue(dict_builder_, static_cast<int64_t>(index - entry_id_offset_)) ==\n+          value;\n+  const bool value_found_overflow =\n+      entry_id_offset_ > 0 &&\n+      GetDictionaryValue(overflow_dict_builder_, static_cast<int64_t>(index)) == value;\n+  return !(value_found || value_found_overflow);\n }\n \n template <>\n bool DictionaryBuilder<FixedSizeBinaryType>::SlotDifferent(hash_slot_t index,\n                                                            const Scalar& value) {\n   int32_t width = static_cast<const FixedSizeBinaryType&>(*type_).byte_width();\n-  const Scalar other = GetDictionaryValue(static_cast<int64_t>(index));\n-  return memcmp(other, value, width) != 0;\n+  bool value_found = false;\n+  if (index >= entry_id_offset_) {\n+    const Scalar other =\n+        GetDictionaryValue(dict_builder_, static_cast<int64_t>(index - entry_id_offset_));\n+    value_found = memcmp(other, value, width) == 0;\n+  }\n+\n+  bool value_found_overflow = false;\n+  if (entry_id_offset_ > 0) {\n+    const Scalar other_overflow =\n+        GetDictionaryValue(overflow_dict_builder_, static_cast<int64_t>(index));\n+    value_found_overflow = memcmp(other_overflow, value, width) == 0;\n+  }\n+  return !(value_found || value_found_overflow);\n }\n \n template <typename T>\n@@ -1041,47 +1094,82 @@ Status DictionaryBuilder<T>::AppendDictionary(const Scalar& value) {\n   return dict_builder_.Append(value);\n }\n \n-#define BINARY_DICTIONARY_SPECIALIZATIONS(Type)                                     \\\n-  template <>                                                                       \\\n-  WrappedBinary DictionaryBuilder<Type>::GetDictionaryValue(int64_t index) {        \\\n-    int32_t v_len;                                                                  \\\n-    const uint8_t* v = dict_builder_.GetValue(static_cast<int64_t>(index), &v_len); \\\n-    return WrappedBinary(v, v_len);                                                 \\\n-  }                                                                                 \\\n-                                                                                    \\\n-  template <>                                                                       \\\n-  Status DictionaryBuilder<Type>::AppendDictionary(const WrappedBinary& value) {    \\\n-    return dict_builder_.Append(value.ptr_, value.length_);                         \\\n-  }                                                                                 \\\n-                                                                                    \\\n-  template <>                                                                       \\\n-  Status DictionaryBuilder<Type>::AppendArray(const Array& array) {                 \\\n-    const BinaryArray& binary_array = static_cast<const BinaryArray&>(array);       \\\n-    WrappedBinary value(nullptr, 0);                                                \\\n-    for (int64_t i = 0; i < array.length(); i++) {                                  \\\n-      if (array.IsNull(i)) {                                                        \\\n-        RETURN_NOT_OK(AppendNull());                                                \\\n-      } else {                                                                      \\\n-        value.ptr_ = binary_array.GetValue(i, &value.length_);                      \\\n-        RETURN_NOT_OK(Append(value));                                               \\\n-      }                                                                             \\\n-    }                                                                               \\\n-    return Status::OK();                                                            \\\n-  }                                                                                 \\\n-                                                                                    \\\n-  template <>                                                                       \\\n-  int64_t DictionaryBuilder<Type>::HashValue(const WrappedBinary& value) {          \\\n-    return HashUtil::Hash(value.ptr_, value.length_, 0);                            \\\n-  }                                                                                 \\\n-                                                                                    \\\n-  template <>                                                                       \\\n-  bool DictionaryBuilder<Type>::SlotDifferent(hash_slot_t index,                    \\\n-                                              const WrappedBinary& value) {         \\\n-    int32_t other_length;                                                           \\\n-    const uint8_t* other_value =                                                    \\\n-        dict_builder_.GetValue(static_cast<int64_t>(index), &other_length);         \\\n-    return !(other_length == value.length_ &&                                       \\\n-             0 == memcmp(other_value, value.ptr_, value.length_));                  \\\n+#define BINARY_DICTIONARY_SPECIALIZATIONS(Type)                                        \\\n+  template <>                                                                          \\\n+  WrappedBinary DictionaryBuilder<Type>::GetDictionaryValue(                           \\\n+      typename TypeTraits<Type>::BuilderType& dictionary_builder, int64_t index) {     \\\n+    int32_t v_len;                                                                     \\\n+    const uint8_t* v = dictionary_builder.GetValue(                                    \\\n+        static_cast<int64_t>(index - entry_id_offset_), &v_len);                       \\\n+    return WrappedBinary(v, v_len);                                                    \\\n+  }                                                                                    \\\n+                                                                                       \\\n+  template <>                                                                          \\\n+  Status DictionaryBuilder<Type>::AppendDictionary(const WrappedBinary& value) {       \\\n+    return dict_builder_.Append(value.ptr_, value.length_);                            \\\n+  }                                                                                    \\\n+                                                                                       \\\n+  template <>                                                                          \\\n+  Status DictionaryBuilder<Type>::AppendArray(const Array& array) {                    \\\n+    const BinaryArray& binary_array = static_cast<const BinaryArray&>(array);          \\\n+    WrappedBinary value(nullptr, 0);                                                   \\\n+    for (int64_t i = 0; i < array.length(); i++) {                                     \\\n+      if (array.IsNull(i)) {                                                           \\\n+        RETURN_NOT_OK(AppendNull());                                                   \\\n+      } else {                                                                         \\\n+        value.ptr_ = binary_array.GetValue(i, &value.length_);                         \\\n+        RETURN_NOT_OK(Append(value));                                                  \\\n+      }                                                                                \\\n+    }                                                                                  \\\n+    return Status::OK();                                                               \\\n+  }                                                                                    \\\n+                                                                                       \\\n+  template <>                                                                          \\\n+  int64_t DictionaryBuilder<Type>::HashValue(const WrappedBinary& value) {             \\\n+    return HashUtil::Hash(value.ptr_, value.length_, 0);                               \\\n+  }                                                                                    \\\n+                                                                                       \\\n+  template <>                                                                          \\\n+  bool DictionaryBuilder<Type>::SlotDifferent(hash_slot_t index,                       \\\n+                                              const WrappedBinary& value) {            \\\n+    int32_t other_length;                                                              \\\n+    bool value_found = false;                                                          \\\n+    if (index >= entry_id_offset_) {                                                   \\\n+      const uint8_t* other_value = dict_builder_.GetValue(                             \\\n+          static_cast<int64_t>(index - entry_id_offset_), &other_length);              \\\n+      value_found = other_length == value.length_ &&                                   \\\n+                    memcmp(other_value, value.ptr_, value.length_) == 0;               \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    bool value_found_overflow = false;                                                 \\\n+    if (entry_id_offset_ > 0) {                                                        \\\n+      const uint8_t* other_value_overflow =                                            \\\n+          overflow_dict_builder_.GetValue(static_cast<int64_t>(index), &other_length); \\\n+      value_found_overflow =                                                           \\\n+          other_length == value.length_ &&                                             \\\n+          memcmp(other_value_overflow, value.ptr_, value.length_) == 0;                \\\n+    }                                                                                  \\\n+    return !(value_found || value_found_overflow);                                     \\\n+  }                                                                                    \\\n+                                                                                       \\\n+  template <>                                                                          \\\n+  Status DictionaryBuilder<Type>::FinishInternal(std::shared_ptr<ArrayData>* out) {    \\\n+    entry_id_offset_ += dict_builder_.length();                                        \\\n+    for (uint64_t index = 0, limit = dict_builder_.length(); index < limit; ++index) { \\\n+      int32_t out_length;                                                              \\\n+      const uint8_t* value = dict_builder_.GetValue(index, &out_length);               \\\n+      RETURN_NOT_OK(overflow_dict_builder_.Append(value, out_length));                 \\\n+    }                                                                                  \\\n+                                                                                       \\\n+    std::shared_ptr<Array> dictionary;                                                 \\\n+    RETURN_NOT_OK(dict_builder_.Finish(&dictionary));                                  \\\n+                                                                                       \\\n+    RETURN_NOT_OK(values_builder_.FinishInternal(out));                                \\\n+    (*out)->type = std::make_shared<DictionaryType>((*out)->type, dictionary);         \\\n+                                                                                       \\\n+    RETURN_NOT_OK(dict_builder_.Init(capacity_));                                      \\\n+    RETURN_NOT_OK(values_builder_.Init(capacity_));                                    \\\n+    return Status::OK();                                                               \\\n   }\n \n BINARY_DICTIONARY_SPECIALIZATIONS(StringType);\n@@ -1344,6 +1432,9 @@ Status FixedSizeBinaryBuilder::FinishInternal(std::shared_ptr<ArrayData>* out) {\n   RETURN_NOT_OK(byte_builder_.Finish(&data));\n \n   *out = ArrayData::Make(type_, length_, {null_bitmap_, data}, null_count_);\n+\n+  null_bitmap_ = nullptr;\n+  capacity_ = length_ = null_count_ = 0;\n   return Status::OK();\n }\n \ndiff --git a/cpp/src/arrow/builder.h b/cpp/src/arrow/builder.h\nindex 9826a6c83..dabfb7506 100644\n--- a/cpp/src/arrow/builder.h\n+++ b/cpp/src/arrow/builder.h\n@@ -109,13 +109,14 @@ class ARROW_EXPORT ArrayBuilder {\n   std::shared_ptr<PoolBuffer> null_bitmap() const { return null_bitmap_; }\n \n   /// \\brief Return result of builder as an internal generic ArrayData\n-  /// object. Resets builder\n+  /// object. Resets builder except for dictionary builder\n   ///\n   /// \\param[out] out the finalized ArrayData object\n   /// \\return Status\n   virtual Status FinishInternal(std::shared_ptr<ArrayData>* out) = 0;\n \n-  /// \\brief Return result of builder as an Array object. Resets builder\n+  /// \\brief Return result of builder as an Array object.\n+  ///        Resets the builder except for DictionaryBuilder\n   ///\n   /// \\param[out] out the finalized Array object\n   /// \\return Status\n@@ -851,6 +852,12 @@ struct DictionaryScalar<FixedSizeBinaryType> {\n }  // namespace internal\n \n /// \\brief Array builder for created encoded DictionaryArray from dense array\n+///\n+/// Unlike other builders, dictionary builder does not completely reset the state\n+/// on Finish calls. The arrays built after the initial Finish call will reuse\n+/// the previously created encoding and build a delta dictionary when new terms\n+/// occur.\n+///\n /// data\n template <typename T>\n class ARROW_EXPORT DictionaryBuilder : public ArrayBuilder {\n@@ -879,9 +886,13 @@ class ARROW_EXPORT DictionaryBuilder : public ArrayBuilder {\n   Status Resize(int64_t capacity) override;\n   Status FinishInternal(std::shared_ptr<ArrayData>* out) override;\n \n+  /// is the dictionary builder in the delta building mode\n+  bool is_building_delta() { return entry_id_offset_ > 0; }\n+\n  protected:\n   Status DoubleTableSize();\n-  Scalar GetDictionaryValue(int64_t index);\n+  Scalar GetDictionaryValue(typename TypeTraits<T>::BuilderType& dictionary_builder,\n+                            int64_t index);\n   int64_t HashValue(const Scalar& value);\n   bool SlotDifferent(hash_slot_t slot, const Scalar& value);\n   Status AppendDictionary(const Scalar& value);\n@@ -892,11 +903,18 @@ class ARROW_EXPORT DictionaryBuilder : public ArrayBuilder {\n   /// Size of the table. Must be a power of 2.\n   int64_t hash_table_size_;\n \n+  // offset for the entry ids. Used to build delta dictionaries,\n+  // increased on every InternalFinish by the number of current entries\n+  // in the dictionary\n+  int64_t entry_id_offset_;\n+\n   // Store hash_table_size_ - 1, so that j & mod_bitmask_ is equivalent to j %\n   // hash_table_size_, but uses far fewer CPU cycles\n   int64_t mod_bitmask_;\n \n   typename TypeTraits<T>::BuilderType dict_builder_;\n+  typename TypeTraits<T>::BuilderType overflow_dict_builder_;\n+\n   AdaptiveIntBuilder values_builder_;\n   int32_t byte_width_;\n \n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-02T14:29:27.808+0000",
                    "updated": "2018-03-02T14:29:27.808+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13139477/comment/16383633",
                    "id": "16383633",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "Issue resolved by pull request 1629\n[https://github.com/apache/arrow/pull/1629]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2018-03-02T14:29:31.167+0000",
                    "updated": "2018-03-02T14:29:31.167+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13139477/comment/16383640",
                    "id": "16383640",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1629: ARROW-2176: [C++] Extend DictionaryBuilder to support delta dictionaries\nURL: https://github.com/apache/arrow/pull/1629#issuecomment-369936294\n \n \n   I'm still going to review this and see if there's anything we want to improve. We also need to integrate this with the IPC read path \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-02T14:32:27.296+0000",
                    "updated": "2018-03-02T14:32:27.296+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13139477/comment/16383648",
                    "id": "16383648",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "alendit commented on issue #1629: ARROW-2176: [C++] Extend DictionaryBuilder to support delta dictionaries\nURL: https://github.com/apache/arrow/pull/1629#issuecomment-369937651\n \n \n   I have a half-done optimization which avoids buffer chaining and double lookups. I also have some ideas about IPC reader and writer. I'll submit them as a separate JIRAs.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-02T14:37:38.308+0000",
                    "updated": "2018-03-02T14:37:38.308+0000"
                }
            ],
            "maxResults": 9,
            "total": 9,
            "startAt": 0
        },
        "customfield_12311820": "0|i3qcjj:",
        "customfield_12314139": null
    }
}