{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13111269",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269",
    "key": "ARROW-1710",
    "fields": {
        "parent": {
            "id": "13099860",
            "key": "ARROW-1463",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13099860",
            "fields": {
                "summary": "[JAVA] Restructure ValueVector hierarchy to minimize compile-time generated code",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341352",
                "id": "12341352",
                "name": "0.8.0",
                "archived": false,
                "released": true,
                "releaseDate": "2017-12-18"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12521041",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12521041",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13121385",
                    "key": "ARROW-1866",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13121385",
                    "fields": {
                        "summary": "[Java] Combine MapVector and NonNullableMapVector Classes",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                            "id": "7",
                            "description": "The sub-task of the issue",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                            "name": "Sub-task",
                            "subtask": true,
                            "avatarId": 21146
                        }
                    }
                }
            },
            {
                "id": "12520499",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12520499",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13119446",
                    "key": "ARROW-1833",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13119446",
                    "fields": {
                        "summary": "[Java] Add accessor methods for data buffers that skip null checking",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
            "name": "bryanc",
            "key": "bryanc",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
            },
            "displayName": "Bryan Cutler",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=icexelloss",
            "name": "icexelloss",
            "key": "icexelloss",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Li Jin",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=icexelloss",
            "name": "icexelloss",
            "key": "icexelloss",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Li Jin",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1710/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@4e01709a[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2a0ac43e[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4e583669[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@328f20a8[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@770b9204[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@3c490757[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@332d85c9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@786c6964[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@535c5fdf[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@27db995c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@788743a3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@633b329e[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Nov 28 17:52:06 UTC 2017",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2017-11-28T17:32:50.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1710/watchers",
            "watchCount": 5,
            "isWatching": false
        },
        "created": "2017-10-23T02:14:36.000+0000",
        "updated": "2017-11-28T17:52:06.000+0000",
        "timeoriginalestimate": null,
        "description": "So far the consensus seems to be remove all non-nullable vectors. ",
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Java] Remove non-nullable vectors in new vector class hierarchy ",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16214748",
                    "id": "16214748",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=gortizja",
                        "name": "gortizja",
                        "key": "gortizja",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Gonzalo Ortiz",
                        "active": true,
                        "timeZone": "Europe/Madrid"
                    },
                    "body": "I'm a little bit concern about performance loss if non-nullable vectors are removed. Arrow on Java has quite bad performance so far (compared with plan ByteBuffers) and to remove non-nullable vectors can make it even worst.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=gortizja",
                        "name": "gortizja",
                        "key": "gortizja",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Gonzalo Ortiz",
                        "active": true,
                        "timeZone": "Europe/Madrid"
                    },
                    "created": "2017-10-23T07:07:45.726+0000",
                    "updated": "2017-10-23T07:07:45.726+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16215113",
                    "id": "16215113",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "As the saying goes, \"you only have a performance problem if you can prove it\". So we shouldn't make any technical decisions about performance unless we have hard numbers to back them up. Since you always have the option to ignore the validity bitmap if the null count is 0, I am not sure why not having non-nullable containers would preclude performance optimizations for data without nulls. \r\n\r\nIt would be helpful to understand the reason for the bad performance that you're talking about, whether it's something about the Java class structure or something lower level (e.g. ByteBuffer vs. netty's AbstractByteBuf)",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-10-23T13:13:02.953+0000",
                    "updated": "2017-10-23T13:13:02.953+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16217560",
                    "id": "16217560",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=e.levine",
                        "name": "e.levine",
                        "key": "e.levine",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Ethan Levine",
                        "active": true,
                        "timeZone": "America/Chicago"
                    },
                    "body": "The BitVector is an extra object that has to be allocated (both in terms of the backing data and in terms of the Java objects involved). You'd also need to perform bit masking of the underlying data with every write, which could involve a cache miss if the data for the BitVector isn't neatly colocated with the actual data for the nullable vector.\r\n\r\nPerhaps a tracking flag could be added to the nullable vectors, though. It would start out \"false\", and get set to \"true\" if you ever write a null value. That way you could avoid the extra allocation and computation involved with tracking the validity of each value in the case where there are no null values. This seems like it would be more complicated than just keeping non-nullable vectors around, however.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=e.levine",
                        "name": "e.levine",
                        "key": "e.levine",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Ethan Levine",
                        "active": true,
                        "timeZone": "America/Chicago"
                    },
                    "created": "2017-10-24T19:49:10.248+0000",
                    "updated": "2017-10-24T19:49:10.248+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16218606",
                    "id": "16218606",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "See https://github.com/apache/arrow/blob/master/format/Layout.md#null-bitmaps. \"Arrays having a 0 null count may choose to not allocate the null bitmap.\". So when there are no nulls, it is not necessary to create a BitVector. It is also not necessary to populate the bit vector, so as you say waiting until the first null to create the bitmap might be the way to go.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-10-25T13:22:27.625+0000",
                    "updated": "2017-10-25T13:22:27.625+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16219836",
                    "id": "16219836",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "I'm one of the voices strongly arguing for dropping the additional class objects. (I also was the one who originally introduced the two separate sets when the code was first developed.) My experience has been the following:\r\n\r\n* Extra complexity of managing two different runtime classes is very expensive (maintenance, coercing between, managing runtime code generation, etc)\r\n* Most source data is actually declared as nullable but rarely has nulls\r\n\r\nAs such, having an adaptive interaction where you look at cells 64 values at a time and adapt your behavior based on actual nullability (as opposed to declared nullability) provides a much better performance lift in real world use cases than having specialized code for declared non-nullable situations.\r\n\r\nFYI: [~e.levine], the updated approach with vectors is moving to a situation where we don't have a bit vector and ultimately also consolidates the buffer for the bits and the fixed bytes in the same buffer. In that case, there is no heap memory overhead and the direct memory overhead is 1 bit per value, far less than necessary.\r\n\r\nAlso note that in reality, most people focused on super high performance Java implementations interact directly with the memory. You can see an example of how we do this here: https://github.com/dremio/dremio-oss/blob/master/sabot/kernel/src/main/java/com/dremio/sabot/op/common/ht2/Pivots.java#L89\r\n\r\nIf, in the future, if people need the vector classes to have an additional set of methods such as: \r\nallocateNewNoNull()\r\nsetSafeIgnoreNull(int index, int value) \r\n\r\nlet's just add those when someone's usecase requires it. No need to have an extra set of vectors for that purpose.\r\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2017-10-26T01:39:32.435+0000",
                    "updated": "2017-10-26T01:39:32.435+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16220392",
                    "id": "16220392",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=e.levine",
                        "name": "e.levine",
                        "key": "e.levine",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Ethan Levine",
                        "active": true,
                        "timeZone": "America/Chicago"
                    },
                    "body": "[~jnadeau]: I'd be interested to learn more about that consolidation. It sounds like the validity bits will be stored inline with the data? It seems like eliding that could be difficult.\r\n\r\nOur use case involves data that's mostly not nullable, and we take care to ensure that it's declared that way. If the costs of writing only non-null values to a nullable array (in terms of memory and computation) become insignificant, then it makes sense to only include nullable arrays. But if that's not the case then I think it makes sense to keep both.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=e.levine",
                        "name": "e.levine",
                        "key": "e.levine",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Ethan Levine",
                        "active": true,
                        "timeZone": "America/Chicago"
                    },
                    "created": "2017-10-26T12:56:00.770+0000",
                    "updated": "2017-10-26T12:56:00.770+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16220962",
                    "id": "16220962",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "The consolidation doesn't inline the values. They are simply prepended. All validity bits come before all data bytes. They are just in the same ArrowBuf rather than maintaining two ArrowBufs. Normally we use different buffers to support resizing only one. However, in the case of validity and data, both will get resized at the same time depending on the values held.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2017-10-26T18:26:03.197+0000",
                    "updated": "2017-10-26T18:26:03.197+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16242687",
                    "id": "16242687",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=icexelloss",
                        "name": "icexelloss",
                        "key": "icexelloss",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Li Jin",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Seems we agree to remove non nullable vectors.\r\n\r\nThe next question is, what do people feel about dropping the \"Nullable\" prefix in new vector classes? [~bryanc] brought this up initially.\r\n\r\nI am +1 for dropping the \"Nullable\" prefix. I think It makes the code more concise. ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=icexelloss",
                        "name": "icexelloss",
                        "key": "icexelloss",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Li Jin",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-07T19:17:55.527+0000",
                    "updated": "2017-11-07T19:18:17.859+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16257872",
                    "id": "16257872",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I would also propose to remove the Nullable prefix and add \"dirty\" accessor methods for users who are working with data without nulls (or that can be used on the hot path when you see that the null count for a vector is 0)",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-11-18T02:10:40.371+0000",
                    "updated": "2017-11-18T02:10:40.371+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16258123",
                    "id": "16258123",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Agree to both nullable prefix removable and adding \"dirty\" accessor/mutator methods but i think the latter could come in 0.9.0 since it is enhancement to the api.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jnadeau",
                        "name": "jnadeau",
                        "key": "jnadeau",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Jacques Nadeau",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2017-11-18T16:45:07.010+0000",
                    "updated": "2017-11-18T16:45:07.010+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16258231",
                    "id": "16258231",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "+1. See ARROW-1833",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-11-18T21:43:27.405+0000",
                    "updated": "2017-11-18T21:43:27.405+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16258884",
                    "id": "16258884",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Sounds good to me, I'll work on this and have a PR soon.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
                        "name": "bryanc",
                        "key": "bryanc",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
                        },
                        "displayName": "Bryan Cutler",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2017-11-20T07:16:11.774+0000",
                    "updated": "2017-11-20T07:16:11.774+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260016",
                    "id": "16260016",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler opened a new pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341\n \n \n   This removes non-nullable vectors that are no longer part of the vector class hierarchy and renames Nullable*Vector classes to remove the Nullable prefix.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-20T23:27:06.364+0000",
                    "updated": "2017-11-20T23:27:06.364+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260026",
                    "id": "16260026",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152142514\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -242,90 +230,81 @@ public void testReallocAfterVectorTransfer1() {\n       int valueCapacity = vector.getValueCapacity();\n       assertEquals(4096, valueCapacity);\n \n-      final BitVector.Mutator mutator = vector.getMutator();\n-      final BitVector.Accessor accessor = vector.getAccessor();\n-\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          mutator.setToOne(i);\n+          vector.set(i, 1);\n \n Review comment:\n   Slightly different API with the new BitVector\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-20T23:38:55.987+0000",
                    "updated": "2017-11-20T23:38:55.987+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260028",
                    "id": "16260028",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152142654\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -242,90 +230,81 @@ public void testReallocAfterVectorTransfer1() {\n       int valueCapacity = vector.getValueCapacity();\n       assertEquals(4096, valueCapacity);\n \n-      final BitVector.Mutator mutator = vector.getMutator();\n-      final BitVector.Accessor accessor = vector.getAccessor();\n-\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          mutator.setToOne(i);\n+          vector.set(i, 1);\n         }\n       }\n \n       for (int i = 0; i < valueCapacity; i++) {\n-        int val = accessor.get(i);\n         if ((i & 1) == 1) {\n-          assertEquals(\"unexpected cleared bit at index: \" + i, 1, val);\n+          assertEquals(\"unexpected cleared bit at index: \" + i, 1, vector.get(i));\n         }\n         else {\n-          assertEquals(\"unexpected set bit at index: \" + i, 0, val);\n+          assertTrue(\"unexpected set bit at index: \" + i, vector.isNull(i));\n \n Review comment:\n   since it's now a nullable `BitVector`, can't get values where a null is set\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-20T23:39:44.385+0000",
                    "updated": "2017-11-20T23:39:44.385+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260030",
                    "id": "16260030",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152142911\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -426,81 +405,81 @@ public void testReallocAfterVectorTransfer2() {\n   public void testBitVector() {\n     // Create a new value vector for 1024 integers\n     try (final BitVector vector = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final BitVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n       // Put and set a few values\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(100, 0);\n-      m.set(1022, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(100, 0);\n+      vector.set(1022, 1);\n \n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n-      final BitVector.Accessor accessor = vector.getAccessor();\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n-      assertEquals(0, accessor.get(100));\n-      assertEquals(1, accessor.get(1022));\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n+      assertEquals(0, vector.get(100));\n+      assertEquals(1, vector.get(1022));\n \n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n Review comment:\n   The value checked here seem wrong before, am I missing something?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-20T23:41:20.523+0000",
                    "updated": "2017-11-20T23:41:20.523+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260031",
                    "id": "16260031",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152143001\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -426,81 +405,81 @@ public void testReallocAfterVectorTransfer2() {\n   public void testBitVector() {\n     // Create a new value vector for 1024 integers\n     try (final BitVector vector = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final BitVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n       // Put and set a few values\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(100, 0);\n-      m.set(1022, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(100, 0);\n+      vector.set(1022, 1);\n \n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n-      final BitVector.Accessor accessor = vector.getAccessor();\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n-      assertEquals(0, accessor.get(100));\n-      assertEquals(1, accessor.get(1022));\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n+      assertEquals(0, vector.get(100));\n+      assertEquals(1, vector.get(1022));\n \n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n       // test setting the same value twice\n-      m.set(0, 1);\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(1, 0);\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n+      vector.set(0, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(1, 0);\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n \n       // test toggling the values\n-      m.set(0, 0);\n-      m.set(1, 1);\n-      assertEquals(0, accessor.get(0));\n-      assertEquals(1, accessor.get(1));\n+      vector.set(0, 0);\n+      vector.set(1, 1);\n+      assertEquals(0, vector.get(0));\n+      assertEquals(1, vector.get(1));\n \n       // should not change\n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n Review comment:\n   again, this value seemed wrong before\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-20T23:41:52.018+0000",
                    "updated": "2017-11-20T23:41:52.018+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260032",
                    "id": "16260032",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152142911\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -426,81 +405,81 @@ public void testReallocAfterVectorTransfer2() {\n   public void testBitVector() {\n     // Create a new value vector for 1024 integers\n     try (final BitVector vector = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final BitVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n       // Put and set a few values\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(100, 0);\n-      m.set(1022, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(100, 0);\n+      vector.set(1022, 1);\n \n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n-      final BitVector.Accessor accessor = vector.getAccessor();\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n-      assertEquals(0, accessor.get(100));\n-      assertEquals(1, accessor.get(1022));\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n+      assertEquals(0, vector.get(100));\n+      assertEquals(1, vector.get(1022));\n \n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n Review comment:\n   The value checked here seem wrong before, am I missing something?  There are 4 values set out of 1024 total, so 1020 null values.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-20T23:42:30.794+0000",
                    "updated": "2017-11-20T23:42:30.794+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260033",
                    "id": "16260033",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152143196\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -426,81 +405,81 @@ public void testReallocAfterVectorTransfer2() {\n   public void testBitVector() {\n     // Create a new value vector for 1024 integers\n     try (final BitVector vector = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final BitVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n       // Put and set a few values\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(100, 0);\n-      m.set(1022, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(100, 0);\n+      vector.set(1022, 1);\n \n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n-      final BitVector.Accessor accessor = vector.getAccessor();\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n-      assertEquals(0, accessor.get(100));\n-      assertEquals(1, accessor.get(1022));\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n+      assertEquals(0, vector.get(100));\n+      assertEquals(1, vector.get(1022));\n \n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n       // test setting the same value twice\n-      m.set(0, 1);\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(1, 0);\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n+      vector.set(0, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(1, 0);\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n \n       // test toggling the values\n-      m.set(0, 0);\n-      m.set(1, 1);\n-      assertEquals(0, accessor.get(0));\n-      assertEquals(1, accessor.get(1));\n+      vector.set(0, 0);\n+      vector.set(1, 1);\n+      assertEquals(0, vector.get(0));\n+      assertEquals(1, vector.get(1));\n \n       // should not change\n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n-      // Ensure unallocated space returns 0\n-      assertEquals(0, accessor.get(3));\n+      // Ensure null value\n+      assertTrue(vector.isNull(3));\n \n Review comment:\n   can't check that a null entry has any type of value\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-20T23:43:07.165+0000",
                    "updated": "2017-11-20T23:43:07.165+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260034",
                    "id": "16260034",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152143299\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -426,81 +405,81 @@ public void testReallocAfterVectorTransfer2() {\n   public void testBitVector() {\n     // Create a new value vector for 1024 integers\n     try (final BitVector vector = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final BitVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n       // Put and set a few values\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(100, 0);\n-      m.set(1022, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(100, 0);\n+      vector.set(1022, 1);\n \n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n-      final BitVector.Accessor accessor = vector.getAccessor();\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n-      assertEquals(0, accessor.get(100));\n-      assertEquals(1, accessor.get(1022));\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n+      assertEquals(0, vector.get(100));\n+      assertEquals(1, vector.get(1022));\n \n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n       // test setting the same value twice\n-      m.set(0, 1);\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(1, 0);\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n+      vector.set(0, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(1, 0);\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n \n       // test toggling the values\n-      m.set(0, 0);\n-      m.set(1, 1);\n-      assertEquals(0, accessor.get(0));\n-      assertEquals(1, accessor.get(1));\n+      vector.set(0, 0);\n+      vector.set(1, 1);\n+      assertEquals(0, vector.get(0));\n+      assertEquals(1, vector.get(1));\n \n       // should not change\n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n-      // Ensure unallocated space returns 0\n-      assertEquals(0, accessor.get(3));\n+      // Ensure null value\n+      assertTrue(vector.isNull(3));\n \n       // unset the previously set bits\n-      m.set(1, 0);\n-      m.set(1022, 0);\n+      vector.setNull(0);\n+      vector.setNull(1);\n+      vector.setNull(100);\n+      vector.setNull(1022);\n \n Review comment:\n   again this seemed wrong before... since 4 values are set earlier, then all 4 should be unset\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-20T23:43:48.853+0000",
                    "updated": "2017-11-20T23:43:48.853+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260035",
                    "id": "16260035",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152143477\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -526,15 +505,17 @@ private void validateRange(int length, int start, int count) {\n     try (BitVector bitVector = new BitVector(\"bits\", allocator)) {\n       bitVector.reset();\n       bitVector.allocateNew(length);\n-      bitVector.getMutator().setRangeToOne(start, count);\n+      for (int i = start; i < start + count; i++) {\n+        bitVector.set(i, 1);\n+      }\n \n Review comment:\n   again, slightly different API, need to check range manually\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-20T23:44:51.163+0000",
                    "updated": "2017-11-20T23:44:51.163+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260037",
                    "id": "16260037",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152143688\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestOversizedAllocationForValueVector.java\n ##########\n @@ -112,10 +112,10 @@ public void testVariableVectorReallocation() {\n     try {\n       vector.allocateNew(expectedAllocationInBytes, 10);\n       assertTrue(expectedOffsetSize <= vector.getValueCapacity());\n-      assertTrue(expectedAllocationInBytes <= vector.getBuffer().capacity());\n+      assertTrue(expectedAllocationInBytes <= vector.getDataBuffer().capacity());\n \n Review comment:\n   Is this correct? it is checking only the data buffer capacity i believe\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-20T23:46:07.101+0000",
                    "updated": "2017-11-20T23:46:07.101+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260040",
                    "id": "16260040",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152144518\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\n ##########\n @@ -108,7 +107,8 @@ public void testListType() {\n       assertEquals(1023, vector.getValueCapacity());\n \n       try {\n-        vector.getOffsetVector().getAccessor().get(2014);\n+        // TODO: is this right?\n+        vector.getInnerValueCountAt(2014);\n \n Review comment:\n   Is this what the test is checking for?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-20T23:51:42.968+0000",
                    "updated": "2017-11-20T23:51:42.968+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260045",
                    "id": "16260045",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-345871911\n \n \n   @siddharthteotia @icexelloss please take a look when you have a chance. There are still some things I was not sure of so I marked this as a WIP:\r\n   \r\n   1) MapVector still has a non-nullable vector class in it's hierarchy.  Maybe I missed some previous discussion from the refactoring, but I couldn't just remove the non-nullable class so I renamed them to be consistent with the other vectors\r\n   \r\n   2) Holders have both nullable and non-nullable, not sure if there is still a use for that so I left it for now... maybe after ARROW-1833 we can fix this up\r\n   \r\n   3) There are still references to NullableMapWriter/Reader, that got a little messy trying to remove but I can try again later\r\n   \r\n   cc @jacques-n @wesm \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-21T00:01:34.603+0000",
                    "updated": "2017-11-21T00:01:34.603+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260049",
                    "id": "16260049",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-345872196\n \n \n   Given the scope of this, I would be nice to get it and resolve the above issues later as long as this doesn't break anything - looks like I already need to do a rebase..\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-21T00:03:08.695+0000",
                    "updated": "2017-11-21T00:03:08.695+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16260093",
                    "id": "16260093",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152151282\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -426,81 +405,81 @@ public void testReallocAfterVectorTransfer2() {\n   public void testBitVector() {\n     // Create a new value vector for 1024 integers\n     try (final BitVector vector = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final BitVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n       // Put and set a few values\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(100, 0);\n-      m.set(1022, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(100, 0);\n+      vector.set(1022, 1);\n \n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n-      final BitVector.Accessor accessor = vector.getAccessor();\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n-      assertEquals(0, accessor.get(100));\n-      assertEquals(1, accessor.get(1022));\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n+      assertEquals(0, vector.get(100));\n+      assertEquals(1, vector.get(1022));\n \n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n Review comment:\n   My guess is old (non-nullable vector) checks how many values are \"0\" rather than how many values are \"set\", so when you set two values to \"0\", they are still counted in NullCount. \r\n   \r\n   I think the new behavior makes more sense, although this could be backward incompatible. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-21T00:39:35.893+0000",
                    "updated": "2017-11-21T00:39:35.893+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16261250",
                    "id": "16261250",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152364883\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -426,81 +405,81 @@ public void testReallocAfterVectorTransfer2() {\n   public void testBitVector() {\n     // Create a new value vector for 1024 integers\n     try (final BitVector vector = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final BitVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n       // Put and set a few values\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(100, 0);\n-      m.set(1022, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(100, 0);\n+      vector.set(1022, 1);\n \n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n-      final BitVector.Accessor accessor = vector.getAccessor();\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n-      assertEquals(0, accessor.get(100));\n-      assertEquals(1, accessor.get(1022));\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n+      assertEquals(0, vector.get(100));\n+      assertEquals(1, vector.get(1022));\n \n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n Review comment:\n   Yeah that would make sense, but sort of a misnomer imo.  Should we include this change in the release notes somewhere?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-21T18:38:03.340+0000",
                    "updated": "2017-11-21T18:38:03.340+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16261273",
                    "id": "16261273",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152368299\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -426,81 +405,81 @@ public void testReallocAfterVectorTransfer2() {\n   public void testBitVector() {\n     // Create a new value vector for 1024 integers\n     try (final BitVector vector = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final BitVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n       // Put and set a few values\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(100, 0);\n-      m.set(1022, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(100, 0);\n+      vector.set(1022, 1);\n \n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n-      final BitVector.Accessor accessor = vector.getAccessor();\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n-      assertEquals(0, accessor.get(100));\n-      assertEquals(1, accessor.get(1022));\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n+      assertEquals(0, vector.get(100));\n+      assertEquals(1, vector.get(1022));\n \n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n Review comment:\n   I agree this is an misnomer. I think this is fine as long as it doesn't break Dremio. cc @siddharthteotia.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-21T18:50:36.868+0000",
                    "updated": "2017-11-21T18:50:36.868+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16261308",
                    "id": "16261308",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-346128441\n \n \n   @icexelloss I didn't see you were already working on #1330, which is also a sizable change, before I started on this.  I'm not sure which one would be easier to merge first, any thoughts?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-21T19:05:05.017+0000",
                    "updated": "2017-11-21T19:05:05.017+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16261324",
                    "id": "16261324",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-346132669\n \n \n   @BryanCutler There might be some conflicts but I think we should be fine.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-21T19:20:05.283+0000",
                    "updated": "2017-11-21T19:20:05.283+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16261330",
                    "id": "16261330",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-346132977\n \n \n   If this is merged first. I would just delete different files, shouldn't be hard. If #1330 get merged first, you need to rename NullableTimestampVector -> TimestampVector.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-21T19:21:15.515+0000",
                    "updated": "2017-11-21T19:21:15.515+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16261733",
                    "id": "16261733",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-346203057\n \n \n   @BryanCutler Good work! High level looks good. I will try to look more closely tomorrow.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T00:16:58.240+0000",
                    "updated": "2017-11-22T00:16:58.240+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16261736",
                    "id": "16261736",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152439296\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n ##########\n @@ -21,332 +21,492 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Iterator;\n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n \n-import javax.annotation.Nullable;\n-\n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Ordering;\n-import com.google.common.primitives.Ints;\n+import com.google.common.collect.ObjectArrays;\n \n import io.netty.buffer.ArrowBuf;\n-\n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n-import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n+import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n+import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.JsonStringHashMap;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n-public class MapVector extends AbstractMapVector {\n-  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MapVector.class);\n+public class MapVector extends NonNullableMapVector implements FieldVector {\n \n Review comment:\n   Is `NonNullableMapVector` something new? Can you explain the change of class hierarchy here?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T00:19:55.392+0000",
                    "updated": "2017-11-22T00:19:55.392+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16261744",
                    "id": "16261744",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152439861\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n ##########\n @@ -21,332 +21,492 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Iterator;\n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n \n-import javax.annotation.Nullable;\n-\n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Ordering;\n-import com.google.common.primitives.Ints;\n+import com.google.common.collect.ObjectArrays;\n \n import io.netty.buffer.ArrowBuf;\n-\n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n-import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n+import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n+import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.JsonStringHashMap;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n-public class MapVector extends AbstractMapVector {\n-  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MapVector.class);\n+public class MapVector extends NonNullableMapVector implements FieldVector {\n \n Review comment:\n   If I understand it correctly, the original MapVector has now become NonNullableMapVector and NullableMapVector (subclass of of MapVector) has now become MapVector. @BryanCutler  can confirm.\r\n   \r\n   I would prefer to not change the naming here since there are essentially two classes -- NullableMapVector and MapVector where the former one is a MapVector with a validity buffer.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T00:23:55.296+0000",
                    "updated": "2017-11-22T00:23:55.296+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16261754",
                    "id": "16261754",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152440144\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n ##########\n @@ -21,332 +21,492 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Iterator;\n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n \n-import javax.annotation.Nullable;\n-\n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Ordering;\n-import com.google.common.primitives.Ints;\n+import com.google.common.collect.ObjectArrays;\n \n import io.netty.buffer.ArrowBuf;\n-\n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n-import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n+import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n+import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.JsonStringHashMap;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n-public class MapVector extends AbstractMapVector {\n-  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MapVector.class);\n+public class MapVector extends NonNullableMapVector implements FieldVector {\n \n Review comment:\n   This is slightly different from changing the name of NullableInt to Int since we are going to remove the latter one. \r\n   \r\n   For the MapVector case, I don't think so we are removing anything and instead keeping around both -- base class MapVector and subclass NullableMapVector. So probably no need to change name here.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T00:25:39.953+0000",
                    "updated": "2017-11-22T00:25:39.953+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16261761",
                    "id": "16261761",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152441194\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n ##########\n @@ -21,332 +21,492 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Iterator;\n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n \n-import javax.annotation.Nullable;\n-\n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Ordering;\n-import com.google.common.primitives.Ints;\n+import com.google.common.collect.ObjectArrays;\n \n import io.netty.buffer.ArrowBuf;\n-\n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n-import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n+import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.schema.ArrowFieldNode;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n+import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.JsonStringHashMap;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n-public class MapVector extends AbstractMapVector {\n-  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MapVector.class);\n+public class MapVector extends NonNullableMapVector implements FieldVector {\n \n Review comment:\n   Yes, the above is correct and what I was referencing in (1) from https://github.com/apache/arrow/pull/1341#issuecomment-345871911.  Maybe I missed the discussion, so I thought we would be removing the `NonNullableMapVector` and would combine the 2 classes.  Why do we need to keep both?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T00:34:08.372+0000",
                    "updated": "2017-11-22T00:34:08.372+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16262773",
                    "id": "16262773",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152593713\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\n ##########\n @@ -18,342 +18,469 @@\n \n package org.apache.arrow.vector;\n \n+import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.memory.BaseAllocator;\n-import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.vector.complex.impl.BitReaderImpl;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.BitHolder;\n import org.apache.arrow.vector.holders.NullableBitHolder;\n-import org.apache.arrow.vector.schema.ArrowFieldNode;\n-import org.apache.arrow.vector.types.Types.MinorType;\n-import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n-import io.netty.buffer.ArrowBuf;\n-\n /**\n- * Bit implements a vector of bit-width values. Elements in the vector are accessed by position from the logical start\n- * of the vector. The width of each element is 1 bit. The equivalent Java primitive is an int containing the value '0'\n- * or '1'.\n+ * BitVector implements a fixed width (1 bit) vector of\n+ * boolean values which could be null. Each value in the vector corresponds\n+ * to a single bit in the underlying data stream backing the vector.\n  */\n-public final class BitVector extends BaseDataValueVector implements FixedWidthVector {\n-  static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(BitVector.class);\n-\n-  private final Accessor accessor = new Accessor();\n-  private final Mutator mutator = new Mutator();\n-\n-  int valueCount;\n-  private int allocationSizeInBytes = getSizeFromCount(INITIAL_VALUE_ALLOCATION);\n-  private int allocationMonitor = 0;\n+public class BitVector extends BaseFixedWidthVector {\n+  private final FieldReader reader;\n \n+  /**\n+   * Instantiate a BitVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n   public BitVector(String name, BufferAllocator allocator) {\n-    super(name, allocator);\n+    this(name, FieldType.nullable(Types.MinorType.BIT.getType()),\n+            allocator);\n   }\n \n-  @Override\n-  public void load(ArrowFieldNode fieldNode, ArrowBuf data) {\n-    // When the vector is all nulls or all defined, the content of the buffer can be omitted\n-    if (data.readableBytes() == 0 && fieldNode.getLength() != 0) {\n-      int count = fieldNode.getLength();\n-      allocateNew(count);\n-      int n = getSizeFromCount(count);\n-      if (fieldNode.getNullCount() == 0) {\n-        // all defined\n-        // create an all 1s buffer\n-        // set full bytes\n-        int fullBytesCount = count / 8;\n-        for (int i = 0; i < fullBytesCount; ++i) {\n-          this.data.setByte(i, 0xFF);\n-        }\n-        int remainder = count % 8;\n-        // set remaining bits\n-        if (remainder > 0) {\n-          byte bitMask = (byte) (0xFFL >>> ((8 - remainder) & 7));\n-          this.data.setByte(fullBytesCount, bitMask);\n-        }\n-      } else if (fieldNode.getNullCount() == fieldNode.getLength()) {\n-        // all null\n-        // create an all 0s buffer\n-        zeroVector();\n-      } else {\n-        throw new IllegalArgumentException(\"The buffer can be empty only if there's no data or it's all null or all defined\");\n-      }\n-      this.data.writerIndex(n);\n-    } else {\n-      super.load(fieldNode, data);\n-    }\n-    this.valueCount = fieldNode.getLength();\n+  /**\n+   * Instantiate a BitVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public BitVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, (byte) 0);\n+    reader = new BitReaderImpl(BitVector.this);\n   }\n \n+  /**\n+   * Get a reader that supports reading values from this vector\n+   *\n+   * @return Field Reader for this vector\n+   */\n   @Override\n-  public Field getField() {\n-    throw new UnsupportedOperationException(\"internal vector\");\n+  public FieldReader getReader() {\n+    return reader;\n   }\n \n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   *\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n   @Override\n-  public MinorType getMinorType() {\n-    return MinorType.BIT;\n+  public Types.MinorType getMinorType() {\n \n Review comment:\n   Why not \"MinorType\"?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T15:16:36.052+0000",
                    "updated": "2017-11-22T15:16:36.052+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16262788",
                    "id": "16262788",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152596476\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -426,81 +405,81 @@ public void testReallocAfterVectorTransfer2() {\n   public void testBitVector() {\n     // Create a new value vector for 1024 integers\n     try (final BitVector vector = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final BitVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n       // Put and set a few values\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(100, 0);\n-      m.set(1022, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(100, 0);\n+      vector.set(1022, 1);\n \n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n-      final BitVector.Accessor accessor = vector.getAccessor();\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n-      assertEquals(0, accessor.get(100));\n-      assertEquals(1, accessor.get(1022));\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n+      assertEquals(0, vector.get(100));\n+      assertEquals(1, vector.get(1022));\n \n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n Review comment:\n   For migration purpose, should me provide an alternative method to provide the old behavior? Something like `getNullAndUnsetCount()`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T15:26:12.867+0000",
                    "updated": "2017-11-22T15:26:12.867+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16262789",
                    "id": "16262789",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152596476\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -426,81 +405,81 @@ public void testReallocAfterVectorTransfer2() {\n   public void testBitVector() {\n     // Create a new value vector for 1024 integers\n     try (final BitVector vector = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final BitVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n       // Put and set a few values\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(100, 0);\n-      m.set(1022, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(100, 0);\n+      vector.set(1022, 1);\n \n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n-      final BitVector.Accessor accessor = vector.getAccessor();\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n-      assertEquals(0, accessor.get(100));\n-      assertEquals(1, accessor.get(1022));\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n+      assertEquals(0, vector.get(100));\n+      assertEquals(1, vector.get(1022));\n \n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n Review comment:\n   For migration purpose, should me provide an alternative method to provide the old behavior? Something like `getNullAndUnsetCount()`. Seems like a weird API though.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T15:26:58.784+0000",
                    "updated": "2017-11-22T15:26:58.784+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16262792",
                    "id": "16262792",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152597645\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n ##########\n @@ -526,15 +505,17 @@ private void validateRange(int length, int start, int count) {\n     try (BitVector bitVector = new BitVector(\"bits\", allocator)) {\n       bitVector.reset();\n       bitVector.allocateNew(length);\n-      bitVector.getMutator().setRangeToOne(start, count);\n+      for (int i = start; i < start + count; i++) {\n+        bitVector.set(i, 1);\n+      }\n \n Review comment:\n   Should we consider add `setRangeToOne` back in `BitVector`?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T15:30:03.805+0000",
                    "updated": "2017-11-22T15:30:03.805+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16262798",
                    "id": "16262798",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152598542\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestOversizedAllocationForValueVector.java\n ##########\n @@ -112,10 +112,10 @@ public void testVariableVectorReallocation() {\n     try {\n       vector.allocateNew(expectedAllocationInBytes, 10);\n       assertTrue(expectedOffsetSize <= vector.getValueCapacity());\n-      assertTrue(expectedAllocationInBytes <= vector.getBuffer().capacity());\n+      assertTrue(expectedAllocationInBytes <= vector.getDataBuffer().capacity());\n \n Review comment:\n   Why this is checking DataBuffer and the check after reAlloc is checking OffsetBuffer?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T15:32:59.793+0000",
                    "updated": "2017-11-22T15:32:59.793+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16262803",
                    "id": "16262803",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-346386518\n \n \n   @BryanCutler High level looks good to me. Two major comments:\r\n   * Do we want to port the missing function (`getNullCount()` and `setRangeToOne`) to the new bit vector?\r\n   * Can we remove `NonNullableMapVector` altogether? (git rid of the `MapVector extends NonNullableMapVector` inherence and roll them into a single class )\r\n   \r\n   Happy thanksgiving!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T15:36:26.342+0000",
                    "updated": "2017-11-22T15:36:26.342+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16262948",
                    "id": "16262948",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152630603\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\n ##########\n @@ -18,342 +18,469 @@\n \n package org.apache.arrow.vector;\n \n+import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.memory.BaseAllocator;\n-import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.vector.complex.impl.BitReaderImpl;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.BitHolder;\n import org.apache.arrow.vector.holders.NullableBitHolder;\n-import org.apache.arrow.vector.schema.ArrowFieldNode;\n-import org.apache.arrow.vector.types.Types.MinorType;\n-import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n-import io.netty.buffer.ArrowBuf;\n-\n /**\n- * Bit implements a vector of bit-width values. Elements in the vector are accessed by position from the logical start\n- * of the vector. The width of each element is 1 bit. The equivalent Java primitive is an int containing the value '0'\n- * or '1'.\n+ * BitVector implements a fixed width (1 bit) vector of\n+ * boolean values which could be null. Each value in the vector corresponds\n+ * to a single bit in the underlying data stream backing the vector.\n  */\n-public final class BitVector extends BaseDataValueVector implements FixedWidthVector {\n-  static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(BitVector.class);\n-\n-  private final Accessor accessor = new Accessor();\n-  private final Mutator mutator = new Mutator();\n-\n-  int valueCount;\n-  private int allocationSizeInBytes = getSizeFromCount(INITIAL_VALUE_ALLOCATION);\n-  private int allocationMonitor = 0;\n+public class BitVector extends BaseFixedWidthVector {\n+  private final FieldReader reader;\n \n+  /**\n+   * Instantiate a BitVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n   public BitVector(String name, BufferAllocator allocator) {\n-    super(name, allocator);\n+    this(name, FieldType.nullable(Types.MinorType.BIT.getType()),\n+            allocator);\n   }\n \n-  @Override\n-  public void load(ArrowFieldNode fieldNode, ArrowBuf data) {\n-    // When the vector is all nulls or all defined, the content of the buffer can be omitted\n-    if (data.readableBytes() == 0 && fieldNode.getLength() != 0) {\n-      int count = fieldNode.getLength();\n-      allocateNew(count);\n-      int n = getSizeFromCount(count);\n-      if (fieldNode.getNullCount() == 0) {\n-        // all defined\n-        // create an all 1s buffer\n-        // set full bytes\n-        int fullBytesCount = count / 8;\n-        for (int i = 0; i < fullBytesCount; ++i) {\n-          this.data.setByte(i, 0xFF);\n-        }\n-        int remainder = count % 8;\n-        // set remaining bits\n-        if (remainder > 0) {\n-          byte bitMask = (byte) (0xFFL >>> ((8 - remainder) & 7));\n-          this.data.setByte(fullBytesCount, bitMask);\n-        }\n-      } else if (fieldNode.getNullCount() == fieldNode.getLength()) {\n-        // all null\n-        // create an all 0s buffer\n-        zeroVector();\n-      } else {\n-        throw new IllegalArgumentException(\"The buffer can be empty only if there's no data or it's all null or all defined\");\n-      }\n-      this.data.writerIndex(n);\n-    } else {\n-      super.load(fieldNode, data);\n-    }\n-    this.valueCount = fieldNode.getLength();\n+  /**\n+   * Instantiate a BitVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public BitVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, (byte) 0);\n+    reader = new BitReaderImpl(BitVector.this);\n   }\n \n+  /**\n+   * Get a reader that supports reading values from this vector\n+   *\n+   * @return Field Reader for this vector\n+   */\n   @Override\n-  public Field getField() {\n-    throw new UnsupportedOperationException(\"internal vector\");\n+  public FieldReader getReader() {\n+    return reader;\n   }\n \n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   *\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n   @Override\n-  public MinorType getMinorType() {\n-    return MinorType.BIT;\n+  public Types.MinorType getMinorType() {\n \n Review comment:\n   Hmm, I think this must have been auto-corrected, let me check on it\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T17:22:01.456+0000",
                    "updated": "2017-11-22T17:22:01.456+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16262971",
                    "id": "16262971",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-346422375\n \n \n   > Do we want to port the missing function (getNullCount() and setRangeToOne) to the new bit vector?\r\n   The new vector has `getNullCount()` just that it only counts nulls, maybe the equivalent would be `getZeroCount()` but I'm not sure how useful that really is.  I think I saw there was also a `setRangeToOne` and I'm ok with adding those.\r\n   \r\n   > Can we remove NonNullableMapVector altogether? (git rid of the MapVector extends NonNullableMapVector inherence and roll them into a single class )\r\n   \r\n   I was thinking this is what we were going to do, maybe as a followup though, so +1 for me.  One thing I'm not sure of is ullability useful for this vector?  For example, Spark StructType doesn't have a nullable param, it's up to the child type definitions.  But maybe it's different in the Arrow sense, I'll have to think about that..\r\n   \r\n   Happy Thanksgiving to you all too!  You guys work too hard, I don't want to see any PRs coming through for a couple days :)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T17:35:05.726+0000",
                    "updated": "2017-11-22T17:35:05.726+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16263322",
                    "id": "16263322",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-346469505\n \n \n   > I was thinking this is what we were going to do, maybe as a followup though, so +1 for me. One thing I'm not sure of is ullability useful for this vector? For example, Spark StructType doesn't have a nullable param, it's up to the child type definitions. But maybe it's different in the Arrow sense, I'll have to think about that..\r\n   I think in Spark, nullable ability is part of `StructField` not `DataType`, so a nullable struct column in Spark would be:\r\n   ```\r\n   StructField(\"struct\", StructType(Seq(StructField(\"a\", IntergerType) ...)), nullable=true)\r\n   ```\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T20:50:55.441+0000",
                    "updated": "2017-11-22T20:50:55.441+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16263323",
                    "id": "16263323",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-346469505\n \n \n   > I was thinking this is what we were going to do, maybe as a followup though, so +1 for me. One thing I'm not sure of is ullability useful for this vector? For example, Spark StructType doesn't have a nullable param, it's up to the child type definitions. But maybe it's different in the Arrow sense, I'll have to think about that..\r\n   \r\n   I think in Spark, nullable ability is part of `StructField` not `DataType`, so a nullable struct column in Spark would be:\r\n   ```\r\n   StructField(\"struct\", StructType(Seq(StructField(\"a\", IntergerType) ...)), nullable=true)\r\n   ```\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T20:51:07.428+0000",
                    "updated": "2017-11-22T20:51:07.428+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16263473",
                    "id": "16263473",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-346491035\n \n \n   Needs rebase\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-22T22:33:58.036+0000",
                    "updated": "2017-11-22T22:33:58.036+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16263812",
                    "id": "16263812",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-346531472\n \n \n   Oh yeah, you're right about Spark struct, duh!  So should I change the naming of `MapVector` back to `NullableMapVector` <- `MapVector` then and we can discuss combing to 1 class in another JIRA?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-23T04:48:11.665+0000",
                    "updated": "2017-11-23T04:48:11.665+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16263820",
                    "id": "16263820",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r152724007\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\n ##########\n @@ -18,342 +18,469 @@\n \n package org.apache.arrow.vector;\n \n+import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.memory.BaseAllocator;\n-import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.vector.complex.impl.BitReaderImpl;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.BitHolder;\n import org.apache.arrow.vector.holders.NullableBitHolder;\n-import org.apache.arrow.vector.schema.ArrowFieldNode;\n-import org.apache.arrow.vector.types.Types.MinorType;\n-import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n-import io.netty.buffer.ArrowBuf;\n-\n /**\n- * Bit implements a vector of bit-width values. Elements in the vector are accessed by position from the logical start\n- * of the vector. The width of each element is 1 bit. The equivalent Java primitive is an int containing the value '0'\n- * or '1'.\n+ * BitVector implements a fixed width (1 bit) vector of\n+ * boolean values which could be null. Each value in the vector corresponds\n+ * to a single bit in the underlying data stream backing the vector.\n  */\n-public final class BitVector extends BaseDataValueVector implements FixedWidthVector {\n-  static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(BitVector.class);\n-\n-  private final Accessor accessor = new Accessor();\n-  private final Mutator mutator = new Mutator();\n-\n-  int valueCount;\n-  private int allocationSizeInBytes = getSizeFromCount(INITIAL_VALUE_ALLOCATION);\n-  private int allocationMonitor = 0;\n+public class BitVector extends BaseFixedWidthVector {\n+  private final FieldReader reader;\n \n+  /**\n+   * Instantiate a BitVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n   public BitVector(String name, BufferAllocator allocator) {\n-    super(name, allocator);\n+    this(name, FieldType.nullable(Types.MinorType.BIT.getType()),\n+            allocator);\n   }\n \n-  @Override\n-  public void load(ArrowFieldNode fieldNode, ArrowBuf data) {\n-    // When the vector is all nulls or all defined, the content of the buffer can be omitted\n-    if (data.readableBytes() == 0 && fieldNode.getLength() != 0) {\n-      int count = fieldNode.getLength();\n-      allocateNew(count);\n-      int n = getSizeFromCount(count);\n-      if (fieldNode.getNullCount() == 0) {\n-        // all defined\n-        // create an all 1s buffer\n-        // set full bytes\n-        int fullBytesCount = count / 8;\n-        for (int i = 0; i < fullBytesCount; ++i) {\n-          this.data.setByte(i, 0xFF);\n-        }\n-        int remainder = count % 8;\n-        // set remaining bits\n-        if (remainder > 0) {\n-          byte bitMask = (byte) (0xFFL >>> ((8 - remainder) & 7));\n-          this.data.setByte(fullBytesCount, bitMask);\n-        }\n-      } else if (fieldNode.getNullCount() == fieldNode.getLength()) {\n-        // all null\n-        // create an all 0s buffer\n-        zeroVector();\n-      } else {\n-        throw new IllegalArgumentException(\"The buffer can be empty only if there's no data or it's all null or all defined\");\n-      }\n-      this.data.writerIndex(n);\n-    } else {\n-      super.load(fieldNode, data);\n-    }\n-    this.valueCount = fieldNode.getLength();\n+  /**\n+   * Instantiate a BitVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public BitVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, (byte) 0);\n+    reader = new BitReaderImpl(BitVector.this);\n   }\n \n+  /**\n+   * Get a reader that supports reading values from this vector\n+   *\n+   * @return Field Reader for this vector\n+   */\n   @Override\n-  public Field getField() {\n-    throw new UnsupportedOperationException(\"internal vector\");\n+  public FieldReader getReader() {\n+    return reader;\n   }\n \n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   *\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n   @Override\n-  public MinorType getMinorType() {\n-    return MinorType.BIT;\n+  public Types.MinorType getMinorType() {\n \n Review comment:\n   It looks like the other vector classes also use `Types.MinorType`.  I agree, it would be better to just say `MinorType`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-23T05:00:46.012+0000",
                    "updated": "2017-11-23T05:00:46.012+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16264457",
                    "id": "16264457",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-346643347\n \n \n   I am still not sure why do we need both nullable and non-nullable map vectors. @siddharthteotia can you elaborate? If this is the only thing blocking the PR. Maybe we can merge this and address it later.\r\n   \r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-23T15:14:17.939+0000",
                    "updated": "2017-11-23T15:14:17.939+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16267271",
                    "id": "16267271",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on a change in pull request #1341: [WIP] ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r153291474\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestOversizedAllocationForValueVector.java\n ##########\n @@ -112,10 +112,10 @@ public void testVariableVectorReallocation() {\n     try {\n       vector.allocateNew(expectedAllocationInBytes, 10);\n       assertTrue(expectedOffsetSize <= vector.getValueCapacity());\n-      assertTrue(expectedAllocationInBytes <= vector.getBuffer().capacity());\n+      assertTrue(expectedAllocationInBytes <= vector.getDataBuffer().capacity());\n \n Review comment:\n   I think checking the offset buffer was a typo on my part, this should be checking the data buffer capacity - fixed now\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T19:04:48.434+0000",
                    "updated": "2017-11-27T19:04:48.434+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16267278",
                    "id": "16267278",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-347291746\n \n \n   I removed the WIP tag because I think this is ok to merge unless @siddharthteotia objects to the changes of `MapVector`. Otherwise I can make a follow up to merge the 2 map vector classes.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T19:09:45.183+0000",
                    "updated": "2017-11-27T19:09:45.183+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16267666",
                    "id": "16267666",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-347343406\n \n \n   This build is passing, @jacques-n @siddharthteotia ?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T22:01:54.953+0000",
                    "updated": "2017-11-27T22:01:54.953+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16267678",
                    "id": "16267678",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r153338418\n \n \n\n ##########\n File path: java/vector/src/test/java/org/apache/arrow/vector/TestOversizedAllocationForValueVector.java\n ##########\n @@ -112,10 +112,10 @@ public void testVariableVectorReallocation() {\n     try {\n       vector.allocateNew(expectedAllocationInBytes, 10);\n       assertTrue(expectedOffsetSize <= vector.getValueCapacity());\n-      assertTrue(expectedAllocationInBytes <= vector.getBuffer().capacity());\n+      assertTrue(expectedAllocationInBytes <= vector.getDataBuffer().capacity());\n \n Review comment:\n   Cool. Thanks\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T22:07:28.875+0000",
                    "updated": "2017-11-27T22:07:28.875+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16267679",
                    "id": "16267679",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on a change in pull request #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#discussion_r153338884\n \n \n\n ##########\n File path: java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\n ##########\n @@ -18,342 +18,469 @@\n \n package org.apache.arrow.vector;\n \n+import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.memory.BaseAllocator;\n-import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.vector.complex.impl.BitReaderImpl;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.BitHolder;\n import org.apache.arrow.vector.holders.NullableBitHolder;\n-import org.apache.arrow.vector.schema.ArrowFieldNode;\n-import org.apache.arrow.vector.types.Types.MinorType;\n-import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n-import io.netty.buffer.ArrowBuf;\n-\n /**\n- * Bit implements a vector of bit-width values. Elements in the vector are accessed by position from the logical start\n- * of the vector. The width of each element is 1 bit. The equivalent Java primitive is an int containing the value '0'\n- * or '1'.\n+ * BitVector implements a fixed width (1 bit) vector of\n+ * boolean values which could be null. Each value in the vector corresponds\n+ * to a single bit in the underlying data stream backing the vector.\n  */\n-public final class BitVector extends BaseDataValueVector implements FixedWidthVector {\n-  static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(BitVector.class);\n-\n-  private final Accessor accessor = new Accessor();\n-  private final Mutator mutator = new Mutator();\n-\n-  int valueCount;\n-  private int allocationSizeInBytes = getSizeFromCount(INITIAL_VALUE_ALLOCATION);\n-  private int allocationMonitor = 0;\n+public class BitVector extends BaseFixedWidthVector {\n+  private final FieldReader reader;\n \n+  /**\n+   * Instantiate a BitVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n   public BitVector(String name, BufferAllocator allocator) {\n-    super(name, allocator);\n+    this(name, FieldType.nullable(Types.MinorType.BIT.getType()),\n+            allocator);\n   }\n \n-  @Override\n-  public void load(ArrowFieldNode fieldNode, ArrowBuf data) {\n-    // When the vector is all nulls or all defined, the content of the buffer can be omitted\n-    if (data.readableBytes() == 0 && fieldNode.getLength() != 0) {\n-      int count = fieldNode.getLength();\n-      allocateNew(count);\n-      int n = getSizeFromCount(count);\n-      if (fieldNode.getNullCount() == 0) {\n-        // all defined\n-        // create an all 1s buffer\n-        // set full bytes\n-        int fullBytesCount = count / 8;\n-        for (int i = 0; i < fullBytesCount; ++i) {\n-          this.data.setByte(i, 0xFF);\n-        }\n-        int remainder = count % 8;\n-        // set remaining bits\n-        if (remainder > 0) {\n-          byte bitMask = (byte) (0xFFL >>> ((8 - remainder) & 7));\n-          this.data.setByte(fullBytesCount, bitMask);\n-        }\n-      } else if (fieldNode.getNullCount() == fieldNode.getLength()) {\n-        // all null\n-        // create an all 0s buffer\n-        zeroVector();\n-      } else {\n-        throw new IllegalArgumentException(\"The buffer can be empty only if there's no data or it's all null or all defined\");\n-      }\n-      this.data.writerIndex(n);\n-    } else {\n-      super.load(fieldNode, data);\n-    }\n-    this.valueCount = fieldNode.getLength();\n+  /**\n+   * Instantiate a BitVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public BitVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, (byte) 0);\n+    reader = new BitReaderImpl(BitVector.this);\n   }\n \n+  /**\n+   * Get a reader that supports reading values from this vector\n+   *\n+   * @return Field Reader for this vector\n+   */\n   @Override\n-  public Field getField() {\n-    throw new UnsupportedOperationException(\"internal vector\");\n+  public FieldReader getReader() {\n+    return reader;\n   }\n \n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   *\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n   @Override\n-  public MinorType getMinorType() {\n-    return MinorType.BIT;\n+  public Types.MinorType getMinorType() {\n \n Review comment:\n   @BryanCutler I think this is missed. Can you please fix this?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T22:09:37.068+0000",
                    "updated": "2017-11-27T22:09:37.068+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16267687",
                    "id": "16267687",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-347346130\n \n \n   LGTM except for changing `Types.MinorType` -> `MinorType`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T22:12:37.780+0000",
                    "updated": "2017-11-27T22:12:37.780+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16267698",
                    "id": "16267698",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-347349292\n \n \n   > LGTM except for changing Types.MinorType -> MinorType\r\n   \r\n   This wasn't added by me and it's the same for the other vector classes, maybe change all in a followup?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T22:25:06.339+0000",
                    "updated": "2017-11-27T22:25:06.339+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16267712",
                    "id": "16267712",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "icexelloss commented on issue #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-347351326\n \n \n   > This wasn't added by me and it's the same for the other vector classes, maybe change all in a followup?\r\n   \r\n   I see. Yeah this is fine.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T22:33:13.572+0000",
                    "updated": "2017-11-27T22:33:13.572+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16267721",
                    "id": "16267721",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-347352719\n \n \n   What are we doing with NonNullableMapVector, MapVector?\r\n   \r\n   (1) Either we leave MapVector and NullableMapVector as is where the latter is a subclass. In this case, there are no code changes needed in these two modules.\r\n   \r\n   OR \r\n   \r\n   (2) We can combine them and just have a MapVector with a validity buffer.\r\n   \r\n   I don't think there is a need to introduce a new class NonNullableMapVector in the hierarchy.\r\n   \r\n   My assumption with this patch was all nullables will become non-nullables and we will get rid of FixedValueVectors.java template -- this is for scalars.\r\n   \r\n   The only complex vector that has 2 different versions is MapVector and I feel we can handle them in either of the two ways mentioned above.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T22:38:52.875+0000",
                    "updated": "2017-11-27T22:38:52.875+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16267730",
                    "id": "16267730",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-347354189\n \n \n   @siddharthteotia , I will do (2) in a followup and remove `NonNullableMapVector` (soon, probably tomorrow).  The only reason I kept `NonNullableMapVector` here is because there were a couple usages of it that might need a closer look and I didn't want to further complicate this PR.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-27T22:45:10.015+0000",
                    "updated": "2017-11-27T22:45:10.015+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16268049",
                    "id": "16268049",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-347404955\n \n \n   Merging tomorrow morning if no objections\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-28T03:45:35.527+0000",
                    "updated": "2017-11-28T03:45:35.527+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16269095",
                    "id": "16269095",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-347600716\n \n \n   +1. Is there a JIRA already for the follow up work?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-28T17:32:25.903+0000",
                    "updated": "2017-11-28T17:32:25.903+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16269096",
                    "id": "16269096",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 1341\n[https://github.com/apache/arrow/pull/1341]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2017-11-28T17:32:50.924+0000",
                    "updated": "2017-11-28T17:32:50.924+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16269097",
                    "id": "16269097",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm closed pull request #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/java/tools/src/test/java/org/apache/arrow/tools/EchoServerTest.java b/java/tools/src/test/java/org/apache/arrow/tools/EchoServerTest.java\nindex d8693c596..47b5541d1 100644\n--- a/java/tools/src/test/java/org/apache/arrow/tools/EchoServerTest.java\n+++ b/java/tools/src/test/java/org/apache/arrow/tools/EchoServerTest.java\n@@ -35,9 +35,9 @@\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.RootAllocator;\n import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.NullableIntVector;\n-import org.apache.arrow.vector.NullableTinyIntVector;\n-import org.apache.arrow.vector.NullableVarCharVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarCharVector;\n import org.apache.arrow.vector.VectorSchemaRoot;\n import org.apache.arrow.vector.complex.ListVector;\n import org.apache.arrow.vector.complex.impl.UnionListWriter;\n@@ -92,7 +92,7 @@ public static void stopEchoServer() throws IOException, InterruptedException {\n \n   private void testEchoServer(int serverPort,\n                               Field field,\n-                              NullableTinyIntVector vector,\n+                              TinyIntVector vector,\n                               int batches)\n       throws UnknownHostException, IOException {\n     VectorSchemaRoot root = new VectorSchemaRoot(asList(field), asList((FieldVector) vector), 0);\n@@ -115,7 +115,7 @@ private void testEchoServer(int serverPort,\n \n       assertEquals(new Schema(asList(field)), reader.getVectorSchemaRoot().getSchema());\n \n-      NullableTinyIntVector readVector = (NullableTinyIntVector) reader.getVectorSchemaRoot()\n+      TinyIntVector readVector = (TinyIntVector) reader.getVectorSchemaRoot()\n           .getFieldVectors().get(0);\n       for (int i = 0; i < batches; i++) {\n         Assert.assertTrue(reader.loadNextBatch());\n@@ -140,8 +140,8 @@ public void basicTest() throws InterruptedException, IOException {\n         \"testField\",\n         new FieldType(true, new ArrowType.Int(8, true), null, null),\n         Collections.<Field>emptyList());\n-    NullableTinyIntVector vector =\n-        new NullableTinyIntVector(\"testField\", FieldType.nullable(TINYINT.getType()), alloc);\n+    TinyIntVector vector =\n+        new TinyIntVector(\"testField\", FieldType.nullable(TINYINT.getType()), alloc);\n     Schema schema = new Schema(asList(field));\n \n     // Try an empty stream, just the header.\n@@ -158,13 +158,13 @@ public void basicTest() throws InterruptedException, IOException {\n   public void testFlatDictionary() throws IOException {\n     DictionaryEncoding writeEncoding = new DictionaryEncoding(1L, false, null);\n     try (BufferAllocator allocator = new RootAllocator(Long.MAX_VALUE);\n-         NullableIntVector writeVector =\n-             new NullableIntVector(\n+         IntVector writeVector =\n+             new IntVector(\n                  \"varchar\",\n                  new FieldType(true, MinorType.INT.getType(), writeEncoding, null),\n                  allocator);\n-         NullableVarCharVector writeDictionaryVector =\n-             new NullableVarCharVector(\n+         VarCharVector writeDictionaryVector =\n+             new VarCharVector(\n                  \"dict\",\n                  FieldType.nullable(VARCHAR.getType()),\n                  allocator)) {\n@@ -218,7 +218,7 @@ public void testFlatDictionary() throws IOException {\n \n         Dictionary dictionary = reader.lookup(1L);\n         Assert.assertNotNull(dictionary);\n-        NullableVarCharVector dictionaryVector = ((NullableVarCharVector) dictionary.getVector());\n+        VarCharVector dictionaryVector = ((VarCharVector) dictionary.getVector());\n         Assert.assertEquals(3, dictionaryVector.getValueCount());\n         Assert.assertEquals(new Text(\"foo\"), dictionaryVector.getObject(0));\n         Assert.assertEquals(new Text(\"bar\"), dictionaryVector.getObject(1));\n@@ -231,8 +231,8 @@ public void testFlatDictionary() throws IOException {\n   public void testNestedDictionary() throws IOException {\n     DictionaryEncoding writeEncoding = new DictionaryEncoding(2L, false, null);\n     try (BufferAllocator allocator = new RootAllocator(Long.MAX_VALUE);\n-         NullableVarCharVector writeDictionaryVector =\n-             new NullableVarCharVector(\"dictionary\", FieldType.nullable(VARCHAR.getType()), allocator);\n+         VarCharVector writeDictionaryVector =\n+             new VarCharVector(\"dictionary\", FieldType.nullable(VARCHAR.getType()), allocator);\n          ListVector writeVector = ListVector.empty(\"list\", allocator)) {\n \n       // data being written:\n@@ -300,7 +300,7 @@ public void testNestedDictionary() throws IOException {\n \n         Dictionary readDictionary = reader.lookup(2L);\n         Assert.assertNotNull(readDictionary);\n-        NullableVarCharVector dictionaryVector = ((NullableVarCharVector) readDictionary.getVector());\n+        VarCharVector dictionaryVector = ((VarCharVector) readDictionary.getVector());\n         Assert.assertEquals(2, dictionaryVector.getValueCount());\n         Assert.assertEquals(new Text(\"foo\"), dictionaryVector.getObject(0));\n         Assert.assertEquals(new Text(\"bar\"), dictionaryVector.getObject(1));\ndiff --git a/java/vector/src/main/codegen/templates/CaseSensitiveMapWriters.java b/java/vector/src/main/codegen/templates/CaseSensitiveMapWriters.java\nindex 5357f9b8a..7c652902e 100644\n--- a/java/vector/src/main/codegen/templates/CaseSensitiveMapWriters.java\n+++ b/java/vector/src/main/codegen/templates/CaseSensitiveMapWriters.java\n@@ -23,7 +23,7 @@\n <#if mode == \"Single\">\n <#assign containerClass = \"MapVector\" />\n <#else>\n-<#assign containerClass = \"NullableMapVector\" />\n+<#assign containerClass = \"MapVector\" />\n </#if>\n \n <#include \"/@includes/license.ftl\" />\ndiff --git a/java/vector/src/main/codegen/templates/ComplexReaders.java b/java/vector/src/main/codegen/templates/ComplexReaders.java\nindex 60347a2fc..4863ecdb6 100644\n--- a/java/vector/src/main/codegen/templates/ComplexReaders.java\n+++ b/java/vector/src/main/codegen/templates/ComplexReaders.java\n@@ -53,9 +53,9 @@\n @SuppressWarnings(\"unused\")\n public class ${name}ReaderImpl extends AbstractFieldReader {\n   \n-  private final ${nullMode}${name}Vector vector;\n+  private final ${name}Vector vector;\n   \n-  public ${name}ReaderImpl(${nullMode}${name}Vector vector){\n+  public ${name}ReaderImpl(${name}Vector vector){\n     super();\n     this.vector = vector;\n   }\n@@ -69,11 +69,7 @@ public Field getField(){\n   }\n   \n   public boolean isSet(){\n-    <#if nullMode == \"Nullable\">\n-        return !vector.isNull(idx());\n-    <#else>\n-    return true;\n-    </#if>\n+    return !vector.isNull(idx());\n   }\n \n   public void copyAsValue(${minor.class?cap_first}Writer writer){\n@@ -88,7 +84,7 @@ public void copyAsField(String name, MapWriter writer){\n \n   <#if nullMode != \"Nullable\">\n   public void read(${minor.class?cap_first}Holder h){\n-    vector.getAccessor().get(idx(), h);\n+    vector.get(idx(), h);\n   }\n   </#if>\n \ndiff --git a/java/vector/src/main/codegen/templates/ComplexWriters.java b/java/vector/src/main/codegen/templates/ComplexWriters.java\nindex 406bbb39c..98672d54c 100644\n--- a/java/vector/src/main/codegen/templates/ComplexWriters.java\n+++ b/java/vector/src/main/codegen/templates/ComplexWriters.java\n@@ -39,9 +39,9 @@\n @SuppressWarnings(\"unused\")\n public class ${eName}WriterImpl extends AbstractFieldWriter {\n \n-  final Nullable${name}Vector vector;\n+  final ${name}Vector vector;\n \n-  public ${eName}WriterImpl(Nullable${name}Vector vector) {\n+  public ${eName}WriterImpl(${name}Vector vector) {\n     this.vector = vector;\n   }\n \n@@ -82,7 +82,7 @@ public void write(${minor.class?cap_first}Holder h) {\n     vector.getMutator().setValueCount(idx()+1);\n   }\n \n-  public void write(Nullable${minor.class?cap_first}Holder h) {\n+  public void write(${minor.class?cap_first}Holder h) {\n     mutator.addSafe(idx(), h);\n     vector.getMutator().setValueCount(idx()+1);\n   }\n@@ -111,7 +111,7 @@ public void write(Nullable${minor.class}Holder h) {\n   }\n \n   public void write${minor.class}(<#list fields as field>${field.type} ${field.name}<#if field_has_next>, </#if></#list>) {\n-    vector.setSafe(idx()<#if mode == \"Nullable\">, 1</#if><#list fields as field><#if field.include!true >, ${field.name}</#if></#list>);\n+    vector.setSafe(idx(), 1<#list fields as field><#if field.include!true >, ${field.name}</#if></#list>);\n     vector.setValueCount(idx()+1);\n   }\n \n@@ -122,13 +122,11 @@ public void write(Nullable${minor.class}Holder h) {\n   }\n   </#if>\n \n-  <#if mode == \"Nullable\">\n   public void writeNull() {\n     vector.setNull(idx());\n     vector.setValueCount(idx()+1);\n   }\n   </#if>\n-  </#if>\n }\n \n <@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/writer/${eName}Writer.java\" />\ndiff --git a/java/vector/src/main/codegen/templates/FixedValueVectors.java b/java/vector/src/main/codegen/templates/FixedValueVectors.java\ndeleted file mode 100644\nindex e07416ba9..000000000\n--- a/java/vector/src/main/codegen/templates/FixedValueVectors.java\n+++ /dev/null\n@@ -1,765 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-import org.apache.arrow.vector.util.DecimalUtility;\n-\n-import java.lang.Override;\n-import java.util.concurrent.TimeUnit;\n-\n-<@pp.dropOutputFile />\n-<#list vv.types as type>\n-<#list type.minor as minor>\n-<#assign friendlyType = (minor.friendlyType!minor.boxedType!type.boxedType) />\n-<#assign className = \"${minor.class}Vector\" />\n-\n-<#if type.major == \"Fixed\">\n-<@pp.changeOutputFile name=\"/org/apache/arrow/vector/${className}.java\" />\n-<#include \"/@includes/license.ftl\" />\n-\n-package org.apache.arrow.vector;\n-\n-<#include \"/@includes/vv_imports.ftl\" />\n-\n-/**\n- * ${minor.class} implements a vector of fixed width values.  Elements in the vector are accessed\n- * by position, starting from the logical start of the vector.  Values should be pushed onto the\n- * vector sequentially, but may be randomly accessed.\n- *   The width of each element is ${type.width} byte(s)\n- *   The equivalent Java primitive is '${minor.javaType!type.javaType}'\n- *\n- * NB: this class is automatically generated from ${.template_name} and ValueVectorTypes.tdd using FreeMarker.\n- */\n-public final class ${className} extends BaseDataValueVector implements FixedWidthVector{\n-  private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(${className}.class);\n-\n-  public static final int TYPE_WIDTH = ${type.width};\n-\n-  private final Accessor accessor = new Accessor();\n-  private final Mutator mutator = new Mutator();\n-\n-  private int allocationSizeInBytes = INITIAL_VALUE_ALLOCATION * ${type.width};\n-  private int allocationMonitor = 0;\n-  <#if minor.typeParams??>\n-\n-    <#assign typeParams = minor.typeParams?reverse />\n-    <#list typeParams as typeParam>\n-  private final ${typeParam.type} ${typeParam.name};\n-    </#list>\n-\n-  public ${className}(String name, BufferAllocator allocator<#list typeParams as typeParam>, ${typeParam.type} ${typeParam.name}</#list>) {\n-    super(name, allocator);\n-    <#list typeParams as typeParam>\n-    this.${typeParam.name} = ${typeParam.name};\n-    </#list>\n-  }\n-  <#else>\n-  public ${className}(String name, BufferAllocator allocator) {\n-    super(name, allocator);\n-  }\n-  </#if>\n-\n-  @Override\n-  public MinorType getMinorType() {\n-    return MinorType.${minor.class?upper_case};\n-  }\n-\n-  @Override\n-  public Field getField() {\n-        throw new UnsupportedOperationException(\"internal vector\");\n-  }\n-\n-  @Override\n-  public FieldReader getReader(){\n-        throw new UnsupportedOperationException(\"non-nullable vectors cannot be used in readers\");\n-  }\n-\n-  @Override\n-  public int getBufferSizeFor(final int valueCount) {\n-    if (valueCount == 0) {\n-      return 0;\n-    }\n-    return valueCount * ${type.width};\n-  }\n-\n-  @Override\n-  public ArrowBuf getValidityBuffer() {\n-    /* this operation is not supported for non-nullable vectors */\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public ArrowBuf getDataBuffer() {\n-    /* we are not throwing away getBuffer() of BaseDataValueVector so use it wherever applicable */\n-    return getBuffer();\n-  }\n-\n-  @Override\n-  public ArrowBuf getOffsetBuffer() {\n-    /* this operation is not supported for fixed-width vectors */\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public int getValueCapacity(){\n-    return (int) (data.capacity() *1.0 / ${type.width});\n-  }\n-\n-  @Override\n-  public Accessor getAccessor(){\n-    return accessor;\n-  }\n-\n-  @Override\n-  public Mutator getMutator(){\n-    return mutator;\n-  }\n-\n-  int getAllocationSize() {\n-    return allocationSizeInBytes;\n-  }\n-\n-  @Override\n-  public void setInitialCapacity(final int valueCount) {\n-    final long size = 1L * valueCount * ${type.width};\n-    if (size > MAX_ALLOCATION_SIZE) {\n-      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed allocation size\");\n-    }\n-    allocationSizeInBytes = (int)size;\n-  }\n-\n-  @Override\n-  public void allocateNew() {\n-    if(!allocateNewSafe()){\n-      throw new OutOfMemoryException(\"Failure while allocating buffer.\");\n-    }\n-  }\n-\n-  @Override\n-  public boolean allocateNewSafe() {\n-    long curAllocationSize = allocationSizeInBytes;\n-    if (allocationMonitor > 10) {\n-      curAllocationSize = Math.max(8, curAllocationSize / 2);\n-      allocationMonitor = 0;\n-    } else if (allocationMonitor < -2) {\n-      curAllocationSize = allocationSizeInBytes * 2L;\n-      allocationMonitor = 0;\n-    }\n-\n-    try{\n-      allocateBytes(curAllocationSize);\n-    } catch (RuntimeException ex) {\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  /**\n-   * Allocate a new buffer that supports setting at least the provided number of values. May actually be sized bigger\n-   * depending on underlying buffer rounding size. Must be called prior to using the ValueVector.\n-   *\n-   * Note that the maximum number of values a vector can allocate is Integer.MAX_VALUE / value width.\n-   *\n-   * @param valueCount the number of values to allocate for\n-   * @throws org.apache.arrow.memory.OutOfMemoryException if it can't allocate the new buffer\n-   */\n-  @Override\n-  public void allocateNew(final int valueCount) {\n-    allocateBytes(valueCount * ${type.width});\n-  }\n-\n-  @Override\n-  public void reset() {\n-    allocationSizeInBytes = INITIAL_VALUE_ALLOCATION * ${type.width};\n-    allocationMonitor = 0;\n-    zeroVector();\n-    super.reset();\n-  }\n-\n-  private void allocateBytes(final long size) {\n-    if (size > MAX_ALLOCATION_SIZE) {\n-      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed allocation size\");\n-    }\n-\n-    final int curSize = (int)size;\n-    clear();\n-    data = allocator.buffer(curSize);\n-    data.readerIndex(0);\n-    allocationSizeInBytes = curSize;\n-  }\n-\n-  /**\n-   * Allocate new buffer with double capacity, and copy data into the new buffer. Replace vector's buffer with new buffer, and release old one\n-   *\n-   * @throws org.apache.arrow.memory.OutOfMemoryException if it can't allocate the new buffer\n-   */\n-  public void reAlloc() {\n-    long baseSize  = allocationSizeInBytes;\n-    final int currentBufferCapacity = data.capacity();\n-    if (baseSize < (long)currentBufferCapacity) {\n-        baseSize = (long)currentBufferCapacity;\n-    }\n-    long newAllocationSize = baseSize * 2L;\n-    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n-\n-    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n-      throw new OversizedAllocationException(\"Unable to expand the buffer. Max allowed buffer size is reached.\");\n-    }\n-\n-    logger.debug(\"Reallocating vector [{}]. # of bytes: [{}] -> [{}]\", name, allocationSizeInBytes, newAllocationSize);\n-    final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n-    newBuf.setBytes(0, data, 0, currentBufferCapacity);\n-    final int halfNewCapacity = newBuf.capacity() / 2;\n-    newBuf.setZero(halfNewCapacity, halfNewCapacity);\n-    newBuf.writerIndex(data.writerIndex());\n-    data.release(1);\n-    data = newBuf;\n-    allocationSizeInBytes = (int)newAllocationSize;\n-  }\n-\n-  /**\n-   * {@inheritDoc}\n-   */\n-  @Override\n-  public void zeroVector() {\n-    data.setZero(0, data.capacity());\n-  }\n-\n-  public TransferPair getTransferPair(BufferAllocator allocator){\n-    return new TransferImpl(name, allocator);\n-  }\n-\n-  @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n-    return new TransferImpl(ref, allocator);\n-  }\n-\n-  @Override\n-  public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((${className}) to);\n-  }\n-\n-  public void transferTo(${className} target){\n-    target.clear();\n-    target.data = data.transferOwnership(target.allocator).buffer;\n-    target.data.writerIndex(data.writerIndex());\n-    clear();\n-  }\n-\n-  public void splitAndTransferTo(int startIndex, int length, ${className} target) {\n-    final int startPoint = startIndex * ${type.width};\n-    final int sliceLength = length * ${type.width};\n-    target.clear();\n-    target.data = data.slice(startPoint, sliceLength).transferOwnership(target.allocator).buffer;\n-    target.data.writerIndex(sliceLength);\n-  }\n-\n-  private class TransferImpl implements TransferPair{\n-    private ${className} to;\n-\n-    public TransferImpl(String name, BufferAllocator allocator){\n-      to = new ${className}(name, allocator<#if minor.typeParams??><#list typeParams as typeParam>,  ${className}.this.${typeParam.name}</#list></#if>);\n-    }\n-\n-    public TransferImpl(${className} to) {\n-      this.to = to;\n-    }\n-\n-    @Override\n-    public ${className} getTo(){\n-      return to;\n-    }\n-\n-    @Override\n-    public void transfer(){\n-      transferTo(to);\n-    }\n-\n-    @Override\n-    public void splitAndTransfer(int startIndex, int length) {\n-      splitAndTransferTo(startIndex, length, to);\n-    }\n-\n-    @Override\n-    public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, ${className}.this);\n-    }\n-  }\n-\n-  public void copyFrom(int fromIndex, int thisIndex, ${className} from){\n-    <#if (type.width > 8 || minor.class == \"IntervalDay\")>\n-    from.data.getBytes(fromIndex * ${type.width}, data, thisIndex * ${type.width}, ${type.width});\n-    <#else> <#-- type.width <= 8 -->\n-    data.set${(minor.javaType!type.javaType)?cap_first}(thisIndex * ${type.width},\n-        from.data.get${(minor.javaType!type.javaType)?cap_first}(fromIndex * ${type.width})\n-    );\n-    </#if> <#-- type.width -->\n-  }\n-\n-  public void copyFromSafe(int fromIndex, int thisIndex, ${className} from){\n-    while(thisIndex >= getValueCapacity()) {\n-        reAlloc();\n-    }\n-    copyFrom(fromIndex, thisIndex, from);\n-  }\n-\n-  public void decrementAllocationMonitor() {\n-    if (allocationMonitor > 0) {\n-      allocationMonitor = 0;\n-    }\n-    --allocationMonitor;\n-  }\n-\n-  private void incrementAllocationMonitor() {\n-    ++allocationMonitor;\n-  }\n-\n-  public final class Accessor extends BaseDataValueVector.BaseAccessor {\n-    @Override\n-    public int getValueCount() {\n-      return data.writerIndex() / ${type.width};\n-    }\n-\n-    @Override\n-    public boolean isNull(int index){\n-      return false;\n-    }\n-\n-    <#if (type.width > 8 || minor.class == \"IntervalDay\")>\n-    public ${minor.javaType!type.javaType} get(int index) {\n-      return data.slice(index * ${type.width}, ${type.width});\n-    }\n-\n-      <#if (minor.class == \"IntervalDay\")>\n-    public void get(int index, ${minor.class}Holder holder){\n-      final int offsetIndex = index * ${type.width};\n-      holder.days = data.getInt(offsetIndex);\n-      holder.milliseconds = data.getInt(offsetIndex + ${minor.millisecondsOffset});\n-    }\n-\n-    public void get(int index, Nullable${minor.class}Holder holder){\n-      final int offsetIndex = index * ${type.width};\n-      holder.isSet = 1;\n-      holder.days = data.getInt(offsetIndex);\n-      holder.milliseconds = data.getInt(offsetIndex + ${minor.millisecondsOffset});\n-    }\n-\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      final int offsetIndex = index * ${type.width};\n-      final int millis = data.getInt(offsetIndex + ${minor.millisecondsOffset});\n-      final int  days   = data.getInt(offsetIndex);\n-      final Period p = new Period();\n-      return p.plusDays(days).plusMillis(millis);\n-    }\n-\n-    public StringBuilder getAsStringBuilder(int index) {\n-      final int offsetIndex = index * ${type.width};\n-\n-      int millis = data.getInt(offsetIndex + ${minor.millisecondsOffset});\n-      final int  days   = data.getInt(offsetIndex);\n-\n-      final int hours  = millis / (org.apache.arrow.vector.util.DateUtility.hoursToMillis);\n-      millis     = millis % (org.apache.arrow.vector.util.DateUtility.hoursToMillis);\n-\n-      final int minutes = millis / (org.apache.arrow.vector.util.DateUtility.minutesToMillis);\n-      millis      = millis % (org.apache.arrow.vector.util.DateUtility.minutesToMillis);\n-\n-      final int seconds = millis / (org.apache.arrow.vector.util.DateUtility.secondsToMillis);\n-      millis      = millis % (org.apache.arrow.vector.util.DateUtility.secondsToMillis);\n-\n-      final String dayString = (Math.abs(days) == 1) ? \" day \" : \" days \";\n-\n-      return(new StringBuilder().\n-              append(days).append(dayString).\n-              append(hours).append(\":\").\n-              append(minutes).append(\":\").\n-              append(seconds).append(\".\").\n-              append(millis));\n-    }\n-\n-      <#elseif minor.class == \"Decimal\">\n-    public void get(int index, ${minor.class}Holder holder) {\n-        holder.start = index * ${type.width};\n-        holder.buffer = data;\n-        holder.scale = scale;\n-        holder.precision = precision;\n-    }\n-\n-    public void get(int index, Nullable${minor.class}Holder holder) {\n-        holder.isSet = 1;\n-        holder.start = index * ${type.width};\n-        holder.buffer = data;\n-        holder.scale = scale;\n-        holder.precision = precision;\n-    }\n-\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      return DecimalUtility.getBigDecimalFromArrowBuf(data, index, scale);\n-    }\n-\n-      <#else>\n-    public void get(int index, ${minor.class}Holder holder){\n-      holder.buffer = data;\n-      holder.start = index * ${type.width};\n-    }\n-\n-    public void get(int index, Nullable${minor.class}Holder holder){\n-      holder.isSet = 1;\n-      holder.buffer = data;\n-      holder.start = index * ${type.width};\n-    }\n-\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      return data.slice(index * ${type.width}, ${type.width})\n-    }\n-\n-      </#if>\n-    <#else> <#-- type.width <= 8 -->\n-\n-    public ${minor.javaType!type.javaType} get(int index) {\n-      return data.get${(minor.javaType!type.javaType)?cap_first}(index * ${type.width});\n-    }\n-      <#if type.width == 4>\n-    public long getTwoAsLong(int index) {\n-      return data.getLong(index * ${type.width});\n-    }\n-\n-      </#if>\n-      <#if minor.class == \"DateDay\" ||\n-           minor.class == \"TimeSec\" ||\n-           minor.class == \"TimeMicro\" ||\n-           minor.class == \"TimeNano\">\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      return get(index);\n-    }\n-\n-      <#elseif minor.class == \"DateMilli\" || minor.class == \"TimeMilli\" || minor.class == \"TimeStampMilli\">\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      org.joda.time.LocalDateTime ldt = new org.joda.time.LocalDateTime(get(index), org.joda.time.DateTimeZone.UTC);\n-      return ldt;\n-    }\n-\n-      <#elseif minor.class == \"TimeStampSec\">\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      long secs = java.util.concurrent.TimeUnit.SECONDS.toMillis(get(index));\n-      org.joda.time.LocalDateTime date = new org.joda.time.LocalDateTime(secs, org.joda.time.DateTimeZone.UTC);\n-      return date;\n-    }\n-\n-      <#elseif minor.class == \"TimeStampMicro\">\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      // value is truncated when converting microseconds to milliseconds in order to use DateTime type\n-      long micros = java.util.concurrent.TimeUnit.MICROSECONDS.toMillis(get(index));\n-      org.joda.time.LocalDateTime date = new org.joda.time.LocalDateTime(micros, org.joda.time.DateTimeZone.UTC);\n-      return date;\n-    }\n-\n-      <#elseif minor.class == \"TimeStampNano\">\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      // value is truncated when converting nanoseconds to milliseconds in order to use DateTime type\n-      long millis = java.util.concurrent.TimeUnit.NANOSECONDS.toMillis(get(index));\n-      org.joda.time.LocalDateTime date = new org.joda.time.LocalDateTime(millis, org.joda.time.DateTimeZone.UTC);\n-      return date;\n-    }\n-\n-      <#elseif minor.class == \"IntervalYear\">\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-\n-      final int value = get(index);\n-\n-      final int years  = (value / org.apache.arrow.vector.util.DateUtility.yearsToMonths);\n-      final int months = (value % org.apache.arrow.vector.util.DateUtility.yearsToMonths);\n-      final Period p = new Period();\n-      return p.plusYears(years).plusMonths(months);\n-    }\n-\n-    public StringBuilder getAsStringBuilder(int index) {\n-      int months  = data.getInt(index);\n-\n-      final int years  = (months / org.apache.arrow.vector.util.DateUtility.yearsToMonths);\n-      months = (months % org.apache.arrow.vector.util.DateUtility.yearsToMonths);\n-\n-      final String yearString = (Math.abs(years) == 1) ? \" year \" : \" years \";\n-      final String monthString = (Math.abs(months) == 1) ? \" month \" : \" months \";\n-\n-      return(new StringBuilder().\n-             append(years).append(yearString).\n-             append(months).append(monthString));\n-    }\n-\n-      <#else>\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      return get(index);\n-    }\n-    public ${minor.javaType!type.javaType} getPrimitiveObject(int index) {\n-      return get(index);\n-    }\n-\n-      </#if>\n-    public void get(int index, ${minor.class}Holder holder){\n-      holder.value = data.get${(minor.javaType!type.javaType)?cap_first}(index * ${type.width});\n-    }\n-\n-    public void get(int index, Nullable${minor.class}Holder holder){\n-      holder.isSet = 1;\n-      holder.value = data.get${(minor.javaType!type.javaType)?cap_first}(index * ${type.width});\n-    }\n-\n-    </#if> <#-- type.width -->\n-  }\n-\n-  /**\n-   * ${minor.class}.Mutator implements a mutable vector of fixed width values.  Elements in the\n-   * vector are accessed by position from the logical start of the vector.  Values should be pushed\n-   * onto the vector sequentially, but may be randomly accessed.\n-   *   The width of each element is ${type.width} byte(s)\n-   *   The equivalent Java primitive is '${minor.javaType!type.javaType}'\n-   *\n-   * NB: this class is automatically generated from FixedValueVectorTypes.tdd using FreeMarker.\n-   */\n-  public final class Mutator extends BaseDataValueVector.BaseMutator {\n-\n-    private Mutator(){};\n-\n-   /**\n-    * Set the element at the given index to the given value.  Note that widths smaller than\n-    * 32 bits are handled by the ArrowBuf interface.\n-    *\n-    * @param index   position of the bit to set\n-    * @param value   value to set\n-    */\n-    <#if (type.width > 8) || minor.class == \"IntervalDay\">\n-   public void set(int index, <#if (type.width > 4)>${minor.javaType!type.javaType}<#else>int</#if> value) {\n-     data.setBytes(index * ${type.width}, value, 0, ${type.width});\n-   }\n-\n-   public void setSafe(int index, <#if (type.width > 4)>${minor.javaType!type.javaType}<#else>int</#if> value) {\n-     while(index >= getValueCapacity()) {\n-       reAlloc();\n-     }\n-     data.setBytes(index * ${type.width}, value, 0, ${type.width});\n-   }\n-\n-      <#if (minor.class == \"IntervalDay\")>\n-   public void set(int index, int days, int milliseconds){\n-     final int offsetIndex = index * ${type.width};\n-     data.setInt(offsetIndex, days);\n-     data.setInt((offsetIndex + ${minor.millisecondsOffset}), milliseconds);\n-   }\n-\n-   protected void set(int index, ${minor.class}Holder holder){\n-     set(index, holder.days, holder.milliseconds);\n-   }\n-\n-   protected void set(int index, Nullable${minor.class}Holder holder){\n-     set(index, holder.days, holder.milliseconds);\n-   }\n-\n-   public void setSafe(int index, int days, int milliseconds){\n-     while(index >= getValueCapacity()) {\n-       reAlloc();\n-     }\n-     set(index, days, milliseconds);\n-   }\n-\n-   public void setSafe(int index, ${minor.class}Holder holder){\n-     setSafe(index, holder.days, holder.milliseconds);\n-   }\n-\n-   public void setSafe(int index, Nullable${minor.class}Holder holder){\n-     setSafe(index, holder.days, holder.milliseconds);\n-   }\n-\n-       <#elseif minor.class == \"Decimal\">\n-   public void set(int index, ${minor.class}Holder holder){\n-     set(index, holder.start, holder.buffer);\n-   }\n-\n-   void set(int index, Nullable${minor.class}Holder holder){\n-     set(index, holder.start, holder.buffer);\n-   }\n-\n-   public void setSafe(int index, Nullable${minor.class}Holder holder){\n-     setSafe(index, holder.start, holder.buffer);\n-   }\n-   public void setSafe(int index, ${minor.class}Holder holder){\n-     setSafe(index, holder.start, holder.buffer);\n-   }\n-\n-   public void setSafe(int index, int start, ArrowBuf buffer){\n-     while(index >= getValueCapacity()) {\n-       reAlloc();\n-     }\n-     set(index, start, buffer);\n-   }\n-\n-   public void set(int index, int start, ArrowBuf buffer){\n-     data.setBytes(index * ${type.width}, buffer, start, ${type.width});\n-   }\n-\n-   public void set(int index, ${friendlyType} value){\n-     DecimalUtility.checkPrecisionAndScale(value, precision, scale);\n-     DecimalUtility.writeBigDecimalToArrowBuf(value, data, index);\n-   }\n-\n-   public void setSafe(int index, ${friendlyType} value){\n-     while(index >= getValueCapacity()) {\n-       reAlloc();\n-     }\n-     set(index, value);\n-   }\n-\n-       <#else>\n-   protected void set(int index, ${minor.class}Holder holder){\n-     set(index, holder.start, holder.buffer);\n-   }\n-\n-   public void set(int index, Nullable${minor.class}Holder holder){\n-     set(index, holder.start, holder.buffer);\n-   }\n-\n-   public void set(int index, int start, ArrowBuf buffer){\n-     data.setBytes(index * ${type.width}, buffer, start, ${type.width});\n-   }\n-\n-   public void setSafe(int index, ${minor.class}Holder holder){\n-     setSafe(index, holder.start, holder.buffer);\n-   }\n-\n-   public void setSafe(int index, Nullable${minor.class}Holder holder){\n-     setSafe(index, holder.start, holder.buffer);\n-   }\n-\n-   public void setSafe(int index, int start, ArrowBuf buffer){\n-     while(index >= getValueCapacity()) {\n-       reAlloc();\n-     }\n-     set(index, holder);\n-   }\n-\n-   public void set(int index, Nullable${minor.class}Holder holder){\n-     data.setBytes(index * ${type.width}, holder.buffer, holder.start, ${type.width});\n-   }\n-       </#if>\n-\n-   @Override\n-   public void generateTestData(int count) {\n-     setValueCount(count);\n-     boolean even = true;\n-     final int valueCount = getAccessor().getValueCount();\n-     for(int i = 0; i < valueCount; i++, even = !even) {\n-       final byte b = even ? Byte.MIN_VALUE : Byte.MAX_VALUE;\n-       for(int w = 0; w < ${type.width}; w++){\n-         data.setByte(i + w, b);\n-       }\n-     }\n-   }\n-\n-     <#else> <#-- type.width <= 8 -->\n-   public void set(int index, <#if (type.width >= 4)>${minor.javaType!type.javaType}<#else>int</#if> value) {\n-     data.set${(minor.javaType!type.javaType)?cap_first}(index * ${type.width}, value);\n-   }\n-\n-   public void setSafe(int index, <#if (type.width >= 4)>${minor.javaType!type.javaType}<#else>int</#if> value) {\n-     while(index >= getValueCapacity()) {\n-       reAlloc();\n-     }\n-     set(index, value);\n-   }\n-\n-   protected void set(int index, ${minor.class}Holder holder){\n-     data.set${(minor.javaType!type.javaType)?cap_first}(index * ${type.width}, holder.value);\n-   }\n-\n-   public void setSafe(int index, ${minor.class}Holder holder){\n-     while(index >= getValueCapacity()) {\n-       reAlloc();\n-     }\n-     set(index, holder);\n-   }\n-\n-   protected void set(int index, Nullable${minor.class}Holder holder){\n-     data.set${(minor.javaType!type.javaType)?cap_first}(index * ${type.width}, holder.value);\n-   }\n-\n-   public void setSafe(int index, Nullable${minor.class}Holder holder){\n-     while(index >= getValueCapacity()) {\n-       reAlloc();\n-     }\n-     set(index, holder);\n-   }\n-\n-   @Override\n-   public void generateTestData(int size) {\n-     setValueCount(size);\n-     boolean even = true;\n-     final int valueCount = getAccessor().getValueCount();\n-     for(int i = 0; i < valueCount; i++, even = !even) {\n-       if(even){\n-         set(i, ${minor.boxedType!type.boxedType}.MIN_VALUE);\n-       }else{\n-         set(i, ${minor.boxedType!type.boxedType}.MAX_VALUE);\n-       }\n-     }\n-   }\n-\n-   public void generateTestDataAlt(int size) {\n-     setValueCount(size);\n-     boolean even = true;\n-     final int valueCount = getAccessor().getValueCount();\n-     for(int i = 0; i < valueCount; i++, even = !even) {\n-       if(even){\n-         set(i, (${(minor.javaType!type.javaType)}) 1);\n-       }else{\n-         set(i, (${(minor.javaType!type.javaType)}) 0);\n-       }\n-     }\n-   }\n-\n-    </#if> <#-- type.width -->\n-\n-   @Override\n-   public void setValueCount(int valueCount) {\n-     final int currentValueCapacity = getValueCapacity();\n-     final int idx = (${type.width} * valueCount);\n-     while(valueCount > getValueCapacity()) {\n-       reAlloc();\n-     }\n-     if (valueCount > 0 && currentValueCapacity > valueCount * 2) {\n-       incrementAllocationMonitor();\n-     } else if (allocationMonitor > 0) {\n-       allocationMonitor = 0;\n-     }\n-     VectorTrimmer.trim(data, idx);\n-     data.writerIndex(valueCount * ${type.width});\n-   }\n- }\n-}\n-\n-  </#if> <#-- type.major -->\n-</#list>\n-</#list>\ndiff --git a/java/vector/src/main/codegen/templates/MapWriters.java b/java/vector/src/main/codegen/templates/MapWriters.java\nindex 6afd508e6..a5ac1b717 100644\n--- a/java/vector/src/main/codegen/templates/MapWriters.java\n+++ b/java/vector/src/main/codegen/templates/MapWriters.java\n@@ -21,9 +21,9 @@\n <@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/${mode}MapWriter.java\" />\n <#assign index = \"idx()\">\n <#if mode == \"Single\">\n-<#assign containerClass = \"MapVector\" />\n+<#assign containerClass = \"NonNullableMapVector\" />\n <#else>\n-<#assign containerClass = \"NullableMapVector\" />\n+<#assign containerClass = \"MapVector\" />\n </#if>\n \n <#include \"/@includes/license.ftl\" />\n@@ -51,7 +51,7 @@\n   private final Map<String, FieldWriter> fields = Maps.newHashMap();\n   public ${mode}MapWriter(${containerClass} container) {\n     <#if mode == \"Single\">\n-    if (container instanceof NullableMapVector) {\n+    if (container instanceof MapVector) {\n       throw new IllegalArgumentException(\"Invalid container: \" + container);\n     }\n     </#if>\n@@ -124,7 +124,7 @@ public MapWriter map(String name) {\n     FieldWriter writer = fields.get(finalName);\n     if(writer == null){\n       int vectorCount=container.size();\n-      NullableMapVector vector = container.addOrGet(name, FieldType.nullable(MinorType.MAP.getType()), NullableMapVector.class);\n+      MapVector vector = container.addOrGet(name, FieldType.nullable(MinorType.MAP.getType()), MapVector.class);\n       writer = new PromotableWriter(vector, container, getNullableMapWriterFactory());\n       if(vectorCount != container.size()) {\n         writer.allocate();\n@@ -214,7 +214,6 @@ public void end() {\n   <#assign upperName = minor.class?upper_case />\n   <#assign capName = minor.class?cap_first />\n   <#assign vectName = capName />\n-  <#assign vectName = \"Nullable${capName}\" />\n \n   <#if minor.typeParams?? >\n   @Override\ndiff --git a/java/vector/src/main/codegen/templates/UnionVector.java b/java/vector/src/main/codegen/templates/UnionVector.java\nindex 73165315e..501933f8f 100644\n--- a/java/vector/src/main/codegen/templates/UnionVector.java\n+++ b/java/vector/src/main/codegen/templates/UnionVector.java\n@@ -65,7 +65,7 @@\n   MapVector internalMap;\n   protected ArrowBuf typeBuffer;\n \n-  private NullableMapVector mapVector;\n+  private MapVector mapVector;\n   private ListVector listVector;\n \n   private FieldReader reader;\n@@ -174,10 +174,10 @@ public long getOffsetBufferAddress() {\n   @Override\n   public ArrowBuf getOffsetBuffer() { throw new UnsupportedOperationException(); }\n \n-  public NullableMapVector getMap() {\n+  public MapVector getMap() {\n     if (mapVector == null) {\n       int vectorCount = internalMap.size();\n-      mapVector = addOrGet(MinorType.MAP, NullableMapVector.class);\n+      mapVector = addOrGet(MinorType.MAP, MapVector.class);\n       if (internalMap.size() > vectorCount) {\n         mapVector.allocateNew();\n         if (callBack != null) {\n@@ -195,12 +195,12 @@ public NullableMapVector getMap() {\n       <#assign lowerCaseName = name?lower_case/>\n       <#if !minor.typeParams?? >\n \n-  private Nullable${name}Vector ${uncappedName}Vector;\n+  private ${name}Vector ${uncappedName}Vector;\n \n-  public Nullable${name}Vector get${name}Vector() {\n+  public ${name}Vector get${name}Vector() {\n     if (${uncappedName}Vector == null) {\n       int vectorCount = internalMap.size();\n-      ${uncappedName}Vector = addOrGet(MinorType.${name?upper_case}, Nullable${name}Vector.class);\n+      ${uncappedName}Vector = addOrGet(MinorType.${name?upper_case}, ${name}Vector.class);\n       if (internalMap.size() > vectorCount) {\n         ${uncappedName}Vector.allocateNew();\n         if (callBack != null) {\ndiff --git a/java/vector/src/main/codegen/templates/VariableLengthVectors.java b/java/vector/src/main/codegen/templates/VariableLengthVectors.java\ndeleted file mode 100644\nindex 3934e74f1..000000000\n--- a/java/vector/src/main/codegen/templates/VariableLengthVectors.java\n+++ /dev/null\n@@ -1,677 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-import java.lang.Override;\n-\n-import org.apache.drill.exec.exception.OutOfMemoryException;\n-import org.apache.drill.exec.vector.BaseDataValueVector;\n-import org.apache.drill.exec.vector.BaseValueVector;\n-import org.apache.drill.exec.vector.VariableWidthVector;\n-\n-<@pp.dropOutputFile />\n-<#list vv.types as type>\n-<#list type.minor as minor>\n-\n-<#assign friendlyType = (minor.friendlyType!minor.boxedType!type.boxedType) />\n-<#assign className = \"${minor.class}Vector\" />\n-\n-<#if type.major == \"VarLen\">\n-<@pp.changeOutputFile name=\"/org/apache/arrow/vector/${minor.class}Vector.java\" />\n-\n-<#include \"/@includes/license.ftl\" />\n-\n-package org.apache.arrow.vector;\n-\n-<#include \"/@includes/vv_imports.ftl\" />\n-\n-/**\n- * ${minor.class}Vector implements a vector of variable width values.  Elements in the vector\n- * are accessed by position from the logical start of the vector.  A fixed width offsetVector\n- * is used to convert an element's position to it's offset from the start of the (0-based)\n- * ArrowBuf.  Size is inferred by adjacent elements.\n- *   The width of each element is ${type.width} byte(s)\n- *   The equivalent Java primitive is '${minor.javaType!type.javaType}'\n- *\n- * NB: this class is automatically generated from ${.template_name} and ValueVectorTypes.tdd using FreeMarker.\n- */\n-public final class ${className} extends BaseDataValueVector implements VariableWidthVector{\n-  private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(${className}.class);\n-\n-  private static final int DEFAULT_RECORD_BYTE_COUNT = 8;\n-  private static final int INITIAL_BYTE_COUNT = 4096 * DEFAULT_RECORD_BYTE_COUNT;\n-  private static final int MIN_BYTE_COUNT = 4096;\n-\n-  public final static String OFFSETS_VECTOR_NAME = \"$offsets$\";\n-  final UInt${type.width}Vector offsetVector = new UInt${type.width}Vector(OFFSETS_VECTOR_NAME, allocator);\n-\n-  private final Accessor accessor;\n-  private final Mutator mutator;\n-\n-  private final UInt${type.width}Vector.Accessor oAccessor;\n-\n-  private int allocationSizeInBytes = INITIAL_BYTE_COUNT;\n-  private int allocationMonitor = 0;\n-\n-  <#if minor.typeParams??>\n-     <#list minor.typeParams as typeParam>\n-  private final ${typeParam.type} ${typeParam.name};\n-    </#list>\n-\n-  public ${className}(String name, BufferAllocator allocator<#list minor.typeParams as typeParam>, ${typeParam.type} ${typeParam.name}</#list>) {\n-    super(name, allocator);\n-    this.oAccessor = offsetVector.getAccessor();\n-    this.accessor = new Accessor();\n-    this.mutator = new Mutator();\n-    <#list minor.typeParams as typeParam>\n-    this.${typeParam.name} = ${typeParam.name};\n-    </#list>\n-  }\n-  <#else>\n-  public ${className}(String name, BufferAllocator allocator) {\n-    super(name, allocator);\n-    this.oAccessor = offsetVector.getAccessor();\n-    this.accessor = new Accessor();\n-    this.mutator = new Mutator();\n-  }\n-  </#if>\n-\n-  @Override\n-  public Field getField() {\n-    throw new UnsupportedOperationException(\"internal vector\");\n-  }\n-\n-  @Override\n-  public MinorType getMinorType() {\n-    return MinorType.${minor.class?upper_case};\n-  }\n-\n-  @Override\n-  public FieldReader getReader(){\n-    throw new UnsupportedOperationException(\"internal vector\");\n-  }\n-\n-  @Override\n-  public int getBufferSize(){\n-    if (getAccessor().getValueCount() == 0) {\n-      return 0;\n-    }\n-    return offsetVector.getBufferSize() + data.writerIndex();\n-  }\n-\n-  @Override\n-  public int getBufferSizeFor(final int valueCount) {\n-    if (valueCount == 0) {\n-      return 0;\n-    }\n-\n-    final int idx = offsetVector.getAccessor().get(valueCount);\n-    return offsetVector.getBufferSizeFor(valueCount + 1) + idx;\n-  }\n-\n-  @Override\n-  public ArrowBuf getValidityBuffer() {\n-    /* this operation is not supported for non-nullable vectors */\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public ArrowBuf getDataBuffer() {\n-    /* we are not throwing away getBuffer() of BaseDataValueVector so use it wherever applicable */\n-    return getBuffer();\n-  }\n-\n-  @Override\n-  public ArrowBuf getOffsetBuffer() {\n-    /* dataBuffer associated with the underlying offsetVector */\n-    return offsetVector.getDataBuffer();\n-  }\n-\n-  @Override\n-  public int getValueCapacity(){\n-    return Math.max(offsetVector.getValueCapacity() - 1, 0);\n-  }\n-\n-  @Override\n-  public int getByteCapacity(){\n-    return data.capacity();\n-  }\n-\n-  @Override\n-  public int getCurrentSizeInBytes() {\n-    return offsetVector.getAccessor().get(getAccessor().getValueCount());\n-  }\n-\n-  /**\n-   * Return the number of bytes contained in the current var len byte vector.\n-   * @return the number of bytes contained in the current var len byte vector\n-   */\n-  public int getVarByteLength(){\n-    final int valueCount = getAccessor().getValueCount();\n-    if(valueCount == 0) {\n-      return 0;\n-    }\n-    return offsetVector.getAccessor().get(valueCount);\n-  }\n-\n-  @Override\n-  public void clear() {\n-    super.clear();\n-    offsetVector.clear();\n-  }\n-\n-  @Override\n-  public ArrowBuf[] getBuffers(boolean clear) {\n-    final ArrowBuf[] buffers = ObjectArrays.concat(offsetVector.getBuffers(false), super.getBuffers(false), ArrowBuf.class);\n-    if (clear) {\n-      // does not make much sense but we have to retain buffers even when clear is set. refactor this interface.\n-      for (final ArrowBuf buffer:buffers) {\n-        buffer.retain(1);\n-      }\n-      clear();\n-    }\n-    return buffers;\n-  }\n-\n-  public long getOffsetAddr(){\n-    return offsetVector.getDataBuffer().memoryAddress();\n-  }\n-\n-  public UInt${type.width}Vector getOffsetVector(){\n-    return offsetVector;\n-  }\n-\n-  @Override\n-  public TransferPair getTransferPair(BufferAllocator allocator){\n-        return new TransferImpl(name, allocator);\n-  }\n-\n-  @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator){\n-    return new TransferImpl(ref, allocator);\n-  }\n-\n-  @Override\n-  public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((${className}) to);\n-  }\n-\n-  public void transferTo(${className} target){\n-    target.clear();\n-    this.offsetVector.transferTo(target.offsetVector);\n-    target.data = data.transferOwnership(target.allocator).buffer;\n-    target.data.writerIndex(data.writerIndex());\n-    clear();\n-  }\n-\n-  public void splitAndTransferTo(int startIndex, int length, ${className} target) {\n-    UInt${type.width}Vector.Accessor offsetVectorAccessor = this.offsetVector.getAccessor();\n-    final int startPoint = offsetVectorAccessor.get(startIndex);\n-    final int sliceLength = offsetVectorAccessor.get(startIndex + length) - startPoint;\n-    target.clear();\n-    target.offsetVector.allocateNew(length + 1);\n-    offsetVectorAccessor = this.offsetVector.getAccessor();\n-    final UInt4Vector.Mutator targetOffsetVectorMutator = target.offsetVector.getMutator();\n-    for (int i = 0; i < length + 1; i++) {\n-      targetOffsetVectorMutator.set(i, offsetVectorAccessor.get(startIndex + i) - startPoint);\n-    }\n-    target.data = data.slice(startPoint, sliceLength).transferOwnership(target.allocator).buffer;\n-    target.getMutator().setValueCount(length);\n-}\n-\n-  protected void copyFrom(int fromIndex, int thisIndex, ${className} from){\n-    final UInt4Vector.Accessor fromOffsetVectorAccessor = from.offsetVector.getAccessor();\n-    final int start = fromOffsetVectorAccessor.get(fromIndex);\n-    final int end = fromOffsetVectorAccessor.get(fromIndex + 1);\n-    final int len = end - start;\n-\n-    final int outputStart = offsetVector.data.get${(minor.javaType!type.javaType)?cap_first}(thisIndex * ${type.width});\n-    from.data.getBytes(start, data, outputStart, len);\n-    offsetVector.data.set${(minor.javaType!type.javaType)?cap_first}( (thisIndex+1) * ${type.width}, outputStart + len);\n-  }\n-\n-  public boolean copyFromSafe(int fromIndex, int thisIndex, ${className} from){\n-    final UInt${type.width}Vector.Accessor fromOffsetVectorAccessor = from.offsetVector.getAccessor();\n-    final int start = fromOffsetVectorAccessor.get(fromIndex);\n-    final int end =   fromOffsetVectorAccessor.get(fromIndex + 1);\n-    final int len = end - start;\n-    final int outputStart = offsetVector.data.get${(minor.javaType!type.javaType)?cap_first}(thisIndex * ${type.width});\n-\n-    while(data.capacity() < outputStart + len) {\n-        reAlloc();\n-    }\n-\n-    offsetVector.getMutator().setSafe(thisIndex + 1, outputStart + len);\n-    from.data.getBytes(start, data, outputStart, len);\n-    return true;\n-  }\n-\n-  private class TransferImpl implements TransferPair{\n-    ${className} to;\n-\n-    public TransferImpl(String name, BufferAllocator allocator){\n-      to = new ${className}(name, allocator<#if minor.typeParams??><#list minor.typeParams as typeParam>,  ${className}.this.${typeParam.name}</#list></#if>);\n-    }\n-\n-    public TransferImpl(${className} to){\n-      this.to = to;\n-    }\n-\n-    @Override\n-    public ${className} getTo(){\n-      return to;\n-    }\n-\n-    @Override\n-    public void transfer(){\n-      transferTo(to);\n-    }\n-\n-    @Override\n-    public void splitAndTransfer(int startIndex, int length) {\n-      splitAndTransferTo(startIndex, length, to);\n-    }\n-\n-    @Override\n-    public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, ${className}.this);\n-    }\n-  }\n-\n-  @Override\n-  public void setInitialCapacity(final int valueCount) {\n-    final long size = 1L * valueCount * ${type.width};\n-    if (size > MAX_ALLOCATION_SIZE) {\n-      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed allocation size\");\n-    }\n-    allocationSizeInBytes = (int)size;\n-    offsetVector.setInitialCapacity(valueCount + 1);\n-  }\n-\n-  @Override\n-  public void allocateNew() {\n-    if(!allocateNewSafe()){\n-      throw new OutOfMemoryException(\"Failure while allocating buffer.\");\n-    }\n-  }\n-\n-  @Override\n-  public boolean allocateNewSafe() {\n-    long curAllocationSize = allocationSizeInBytes;\n-    if (allocationMonitor > 10) {\n-      curAllocationSize = Math.max(MIN_BYTE_COUNT, curAllocationSize / 2);\n-      allocationMonitor = 0;\n-    } else if (allocationMonitor < -2) {\n-      curAllocationSize = curAllocationSize * 2L;\n-      allocationMonitor = 0;\n-    }\n-\n-    if (curAllocationSize > MAX_ALLOCATION_SIZE) {\n-      return false;\n-    }\n-\n-    clear();\n-    /* Boolean to keep track if all the memory allocations were successful\n-     * Used in the case of composite vectors when we need to allocate multiple\n-     * buffers for multiple vectors. If one of the allocations failed we need to\n-     * clear all the memory that we allocated\n-     */\n-    try {\n-      final int requestedSize = (int)curAllocationSize;\n-      data = allocator.buffer(requestedSize);\n-      allocationSizeInBytes = requestedSize;\n-      offsetVector.allocateNew();\n-    } catch (OutOfMemoryException e) {\n-      clear();\n-      return false;\n-    }\n-    data.readerIndex(0);\n-    offsetVector.zeroVector();\n-    return true;\n-  }\n-\n-  @Override\n-  public void allocateNew(int totalBytes, int valueCount) {\n-    clear();\n-    assert totalBytes >= 0;\n-    try {\n-      data = allocator.buffer(totalBytes);\n-      offsetVector.allocateNew(valueCount + 1);\n-    } catch (RuntimeException e) {\n-      clear();\n-      throw e;\n-    }\n-    data.readerIndex(0);\n-    allocationSizeInBytes = totalBytes;\n-    offsetVector.zeroVector();\n-  }\n-\n-  @Override\n-  public void reset() {\n-    allocationSizeInBytes = INITIAL_BYTE_COUNT;\n-    allocationMonitor = 0;\n-    data.readerIndex(0);\n-    offsetVector.zeroVector();\n-    super.reset();\n-  }\n-\n-  public void reAlloc() {\n-    long baseSize = allocationSizeInBytes;\n-    final int currentBufferCapacity = data.capacity();\n-    if (baseSize < (long)currentBufferCapacity) {\n-      baseSize = (long)currentBufferCapacity;\n-    }\n-    long newAllocationSize = baseSize * 2L;\n-    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n-\n-    if (newAllocationSize > MAX_ALLOCATION_SIZE)  {\n-      throw new OversizedAllocationException(\"Unable to expand the buffer. Max allowed buffer size is reached.\");\n-    }\n-\n-    final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n-    newBuf.setBytes(0, data, 0, currentBufferCapacity);\n-    data.release();\n-    data = newBuf;\n-    allocationSizeInBytes = (int)newAllocationSize;\n-  }\n-\n-  public void decrementAllocationMonitor() {\n-    if (allocationMonitor > 0) {\n-      allocationMonitor = 0;\n-    }\n-    --allocationMonitor;\n-  }\n-\n-  private void incrementAllocationMonitor() {\n-    ++allocationMonitor;\n-  }\n-\n-  @Override\n-  public Accessor getAccessor(){\n-    return accessor;\n-  }\n-\n-  @Override\n-  public Mutator getMutator() {\n-    return mutator;\n-  }\n-\n-  public final class Accessor extends BaseValueVector.BaseAccessor implements VariableWidthAccessor {\n-    final UInt${type.width}Vector.Accessor oAccessor = offsetVector.getAccessor();\n-    public long getStartEnd(int index){\n-      return oAccessor.getTwoAsLong(index);\n-    }\n-\n-    public byte[] get(int index) {\n-      assert index >= 0;\n-      final int startIdx = oAccessor.get(index);\n-      final int length = oAccessor.get(index + 1) - startIdx;\n-      assert length >= 0;\n-      final byte[] dst = new byte[length];\n-      data.getBytes(startIdx, dst, 0, length);\n-      return dst;\n-    }\n-\n-    @Override\n-    public int getValueLength(int index) {\n-      final UInt${type.width}Vector.Accessor offsetVectorAccessor = offsetVector.getAccessor();\n-      return offsetVectorAccessor.get(index + 1) - offsetVectorAccessor.get(index);\n-    }\n-\n-    public void get(int index, ${minor.class}Holder holder){\n-      holder.start = oAccessor.get(index);\n-      holder.end = oAccessor.get(index + 1);\n-      holder.buffer = data;\n-    }\n-\n-    public void get(int index, Nullable${minor.class}Holder holder){\n-      holder.isSet = 1;\n-      holder.start = oAccessor.get(index);\n-      holder.end = oAccessor.get(index + 1);\n-      holder.buffer = data;\n-    }\n-\n-    <#switch minor.class>\n-      <#case \"VarChar\">\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      Text text = new Text();\n-      text.set(get(index));\n-      return text;\n-    }\n-      <#break>\n-      <#case \"Decimal\">\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      return new BigDecimal(new BigInteger(get(index)), scale);\n-    }\n-      <#break>\n-      <#default>\n-    @Override\n-    public ${friendlyType} getObject(int index) {\n-      return get(index);\n-    }\n-    </#switch>\n-\n-    @Override\n-    public int getValueCount() {\n-      return Math.max(offsetVector.getAccessor().getValueCount()-1, 0);\n-    }\n-\n-    @Override\n-    public boolean isNull(int index){\n-      return false;\n-    }\n-\n-    public UInt${type.width}Vector getOffsetVector(){\n-      return offsetVector;\n-    }\n-  }\n-\n-  /**\n-   * Mutable${minor.class} implements a vector of variable width values.  Elements in the vector\n-   * are accessed by position from the logical start of the vector.  A fixed width offsetVector\n-   * is used to convert an element's position to it's offset from the start of the (0-based)\n-   * ArrowBuf.  Size is inferred by adjacent elements.\n-   *   The width of each element is ${type.width} byte(s)\n-   *   The equivalent Java primitive is '${minor.javaType!type.javaType}'\n-   *\n-   * NB: this class is automatically generated from ValueVectorTypes.tdd using FreeMarker.\n-   */\n-  public final class Mutator extends BaseValueVector.BaseMutator implements VariableWidthVector.VariableWidthMutator {\n-\n-    /**\n-     * Set the variable length element at the specified index to the supplied byte array.\n-     *\n-     * @param index   position of the bit to set\n-     * @param bytes   array of bytes to write\n-     */\n-    protected void set(int index, byte[] bytes) {\n-      assert index >= 0;\n-      final int currentOffset = offsetVector.getAccessor().get(index);\n-      offsetVector.getMutator().set(index + 1, currentOffset + bytes.length);\n-      data.setBytes(currentOffset, bytes, 0, bytes.length);\n-    }\n-\n-    public void setSafe(int index, byte[] bytes) {\n-      assert index >= 0;\n-\n-      final int currentOffset = offsetVector.getAccessor().get(index);\n-      while (data.capacity() < currentOffset + bytes.length) {\n-        reAlloc();\n-      }\n-      offsetVector.getMutator().setSafe(index + 1, currentOffset + bytes.length);\n-      data.setBytes(currentOffset, bytes, 0, bytes.length);\n-    }\n-\n-    /**\n-     * Set the variable length element at the specified index to the supplied byte array.\n-     *\n-     * @param index   position of the bit to set\n-     * @param bytes   array of bytes to write\n-     * @param start   start index of bytes to write\n-     * @param length  length of bytes to write\n-     */\n-    protected void set(int index, byte[] bytes, int start, int length) {\n-      assert index >= 0;\n-      final int currentOffset = offsetVector.getAccessor().get(index);\n-      offsetVector.getMutator().set(index + 1, currentOffset + length);\n-      data.setBytes(currentOffset, bytes, start, length);\n-    }\n-\n-    public void setSafe(int index, ByteBuffer bytes, int start, int length) {\n-      assert index >= 0;\n-\n-      int currentOffset = offsetVector.getAccessor().get(index);\n-\n-      while (data.capacity() < currentOffset + length) {\n-        reAlloc();\n-      }\n-      offsetVector.getMutator().setSafe(index + 1, currentOffset + length);\n-      data.setBytes(currentOffset, bytes, start, length);\n-    }\n-\n-    public void setSafe(int index, byte[] bytes, int start, int length) {\n-      assert index >= 0;\n-\n-      final int currentOffset = offsetVector.getAccessor().get(index);\n-\n-      while (data.capacity() < currentOffset + length) {\n-        reAlloc();\n-      }\n-      offsetVector.getMutator().setSafe(index + 1, currentOffset + length);\n-      data.setBytes(currentOffset, bytes, start, length);\n-    }\n-\n-    @Override\n-    public void setValueLengthSafe(int index, int length) {\n-      final int offset = offsetVector.getAccessor().get(index);\n-      while(data.capacity() < offset + length ) {\n-        reAlloc();\n-      }\n-      offsetVector.getMutator().setSafe(index + 1, offsetVector.getAccessor().get(index) + length);\n-    }\n-\n-\n-    public void setSafe(int index, int start, int end, ArrowBuf buffer){\n-      final int len = end - start;\n-      final int outputStart = offsetVector.data.get${(minor.javaType!type.javaType)?cap_first}(index * ${type.width});\n-\n-      while(data.capacity() < outputStart + len) {\n-        reAlloc();\n-      }\n-\n-      offsetVector.getMutator().setSafe( index+1,  outputStart + len);\n-      buffer.getBytes(start, data, outputStart, len);\n-    }\n-\n-    public void setSafe(int index, Nullable${minor.class}Holder holder){\n-      assert holder.isSet == 1;\n-\n-      final int start = holder.start;\n-      final int end =   holder.end;\n-      final int len = end - start;\n-\n-      int outputStart = offsetVector.data.get${(minor.javaType!type.javaType)?cap_first}(index * ${type.width});\n-\n-      while(data.capacity() < outputStart + len) {\n-        reAlloc();\n-      }\n-\n-      holder.buffer.getBytes(start, data, outputStart, len);\n-      offsetVector.getMutator().setSafe( index+1,  outputStart + len);\n-    }\n-\n-    public void setSafe(int index, ${minor.class}Holder holder){\n-      final int start = holder.start;\n-      final int end =   holder.end;\n-      final int len = end - start;\n-      final int outputStart = offsetVector.data.get${(minor.javaType!type.javaType)?cap_first}(index * ${type.width});\n-\n-      while(data.capacity() < outputStart + len) {\n-        reAlloc();\n-      }\n-\n-      holder.buffer.getBytes(start, data, outputStart, len);\n-      offsetVector.getMutator().setSafe( index+1,  outputStart + len);\n-    }\n-\n-    protected void set(int index, int start, int length, ArrowBuf buffer){\n-      assert index >= 0;\n-      final int currentOffset = offsetVector.getAccessor().get(index);\n-      offsetVector.getMutator().set(index + 1, currentOffset + length);\n-      final ArrowBuf bb = buffer.slice(start, length);\n-      data.setBytes(currentOffset, bb);\n-    }\n-\n-    protected void set(int index, Nullable${minor.class}Holder holder){\n-      final int length = holder.end - holder.start;\n-      final int currentOffset = offsetVector.getAccessor().get(index);\n-      offsetVector.getMutator().set(index + 1, currentOffset + length);\n-      data.setBytes(currentOffset, holder.buffer, holder.start, length);\n-    }\n-\n-    protected void set(int index, ${minor.class}Holder holder){\n-      final int length = holder.end - holder.start;\n-      final int currentOffset = offsetVector.getAccessor().get(index);\n-      offsetVector.getMutator().set(index + 1, currentOffset + length);\n-      data.setBytes(currentOffset, holder.buffer, holder.start, length);\n-    }\n-\n-    @Override\n-    public void setValueCount(int valueCount) {\n-      if (valueCount == 0) {\n-        // if no values in vector, don't try to retrieve the current value count.\n-        offsetVector.getMutator().setValueCount(0);\n-      } else {\n-        final int currentByteCapacity = getByteCapacity();\n-        final int idx = offsetVector.getAccessor().get(valueCount);\n-        data.writerIndex(idx);\n-        if (currentByteCapacity > idx * 2) {\n-          incrementAllocationMonitor();\n-        } else if (allocationMonitor > 0) {\n-          allocationMonitor = 0;\n-        }\n-        VectorTrimmer.trim(data, idx);\n-        offsetVector.getMutator().setValueCount(valueCount+1);\n-      }\n-    }\n-\n-    @Override\n-    public void generateTestData(int size){\n-      boolean even = true;\n-      <#switch minor.class>\n-      <#case \"Var16Char\">\n-      final java.nio.charset.Charset charset = Charsets.UTF_16;\n-      <#break>\n-      <#case \"VarChar\">\n-      <#default>\n-      final java.nio.charset.Charset charset = Charsets.UTF_8;\n-      </#switch>\n-      final byte[] evenValue = new String(\"aaaaa\").getBytes(charset);\n-      final byte[] oddValue = new String(\"bbbbbbbbbb\").getBytes(charset);\n-      for(int i =0; i < size; i++, even = !even){\n-        set(i, even ? evenValue : oddValue);\n-        }\n-      setValueCount(size);\n-    }\n-  }\n-}\n-\n-</#if> <#-- type.major -->\n-</#list>\n-</#list>\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseFixedWidthVector.java\nsimilarity index 97%\nrename from java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/BaseFixedWidthVector.java\nindex f82077f69..cc056904a 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableFixedWidthVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseFixedWidthVector.java\n@@ -36,12 +36,12 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * BaseNullableFixedWidthVector provides an abstract interface for\n+ * BaseFixedWidthVector provides an abstract interface for\n  * implementing vectors of fixed width values. The vectors are nullable\n  * implying that zero or more elements in the vector could be NULL.\n  */\n-public abstract class BaseNullableFixedWidthVector extends BaseValueVector\n-        implements FixedWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+public abstract class BaseFixedWidthVector extends BaseValueVector\n+        implements FixedWidthVector, FieldVector, VectorDefinitionSetter {\n   private final byte typeWidth;\n \n   protected int valueAllocationSizeInBytes;\n@@ -53,7 +53,7 @@\n   protected ArrowBuf valueBuffer;\n   protected int valueCount;\n \n-  public BaseNullableFixedWidthVector(final String name, final BufferAllocator allocator,\n+  public BaseFixedWidthVector(final String name, final BufferAllocator allocator,\n                                       FieldType fieldType, final byte typeWidth) {\n     super(name, allocator);\n     this.typeWidth = typeWidth;\n@@ -66,7 +66,7 @@ public BaseNullableFixedWidthVector(final String name, final BufferAllocator all\n       valueAllocationSizeInBytes = INITIAL_VALUE_ALLOCATION * typeWidth;\n       validityAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n     } else {\n-      /* specialized handling for NullableBitVector */\n+      /* specialized handling for BitVector */\n       valueAllocationSizeInBytes = getValidityBufferSizeFromCount(INITIAL_VALUE_ALLOCATION);\n       validityAllocationSizeInBytes = valueAllocationSizeInBytes;\n     }\n@@ -311,7 +311,7 @@ public void allocateNew(int valueCount) {\n     long valueBufferSize = valueCount * typeWidth;\n     long validityBufferSize = getValidityBufferSizeFromCount(valueCount);\n     if (typeWidth == 0) {\n-      /* specialized handling for NullableBitVector */\n+      /* specialized handling for BitVector */\n       valueBufferSize = validityBufferSize;\n     }\n \n@@ -556,7 +556,7 @@ private void setReaderAndWriterIndex() {\n     } else {\n       validityBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n       if (typeWidth == 0) {\n-        /* specialized handling for NullableBitVector */\n+        /* specialized handling for BitVector */\n         valueBuffer.writerIndex(getValidityBufferSizeFromCount(valueCount));\n       } else {\n         valueBuffer.writerIndex(valueCount * typeWidth);\n@@ -600,7 +600,7 @@ public TransferPair getTransferPair(BufferAllocator allocator) {\n    * for accounting and management purposes.\n    * @param target destination vector for transfer\n    */\n-  public void transferTo(BaseNullableFixedWidthVector target) {\n+  public void transferTo(BaseFixedWidthVector target) {\n     compareTypes(target, \"transferTo\");\n     target.clear();\n     target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n@@ -617,7 +617,7 @@ public void transferTo(BaseNullableFixedWidthVector target) {\n    * @param target destination vector\n    */\n   public void splitAndTransferTo(int startIndex, int length,\n-                                 BaseNullableFixedWidthVector target) {\n+                                 BaseFixedWidthVector target) {\n     compareTypes(target, \"splitAndTransferTo\");\n     target.clear();\n     splitAndTransferValidityBuffer(startIndex, length, target);\n@@ -629,7 +629,7 @@ public void splitAndTransferTo(int startIndex, int length,\n    * Data buffer can always be split and transferred using slicing.\n    */\n   private void splitAndTransferValueBuffer(int startIndex, int length,\n-                                           BaseNullableFixedWidthVector target) {\n+                                           BaseFixedWidthVector target) {\n     final int startPoint = startIndex * typeWidth;\n     final int sliceLength = length * typeWidth;\n     target.valueBuffer = valueBuffer.slice(startPoint, sliceLength).transferOwnership(target.allocator).buffer;\n@@ -640,7 +640,7 @@ private void splitAndTransferValueBuffer(int startIndex, int length,\n    * the starting position of the source index.\n    */\n   private void splitAndTransferValidityBuffer(int startIndex, int length,\n-                                              BaseNullableFixedWidthVector target) {\n+                                              BaseFixedWidthVector target) {\n     assert startIndex + length <= valueCount;\n     int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n     int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BaseVariableWidthVector.java\nsimilarity index 98%\nrename from java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/BaseVariableWidthVector.java\nindex b9e5442ec..b515586bc 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BaseNullableVariableWidthVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BaseVariableWidthVector.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.memory.OutOfMemoryException;\n import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.MapVector;\n import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.types.pojo.FieldType;\n@@ -37,8 +37,8 @@\n import java.util.Collections;\n import java.util.List;\n \n-public abstract class BaseNullableVariableWidthVector extends BaseValueVector\n-        implements VariableWidthVector, FieldVector, NullableVectorDefinitionSetter {\n+public abstract class BaseVariableWidthVector extends BaseValueVector\n+        implements VariableWidthVector, FieldVector, VectorDefinitionSetter {\n   private static final int DEFAULT_RECORD_BYTE_COUNT = 8;\n   private static final int INITIAL_BYTE_COUNT = INITIAL_VALUE_ALLOCATION * DEFAULT_RECORD_BYTE_COUNT;\n \n@@ -57,7 +57,7 @@\n   protected final Field field;\n   private boolean cleared;\n \n-  public BaseNullableVariableWidthVector(final String name, final BufferAllocator allocator,\n+  public BaseVariableWidthVector(final String name, final BufferAllocator allocator,\n                                          FieldType fieldType) {\n     super(name, allocator);\n     valueAllocationSizeInBytes = INITIAL_BYTE_COUNT;\n@@ -657,7 +657,7 @@ public TransferPair getTransferPair(BufferAllocator allocator) {\n    * for accounting and management purposes.\n    * @param target destination vector for transfer\n    */\n-  public void transferTo(BaseNullableVariableWidthVector target) {\n+  public void transferTo(BaseVariableWidthVector target) {\n     compareTypes(target, \"transferTo\");\n     target.clear();\n     target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n@@ -678,7 +678,7 @@ public void transferTo(BaseNullableVariableWidthVector target) {\n    * @param target destination vector\n    */\n   public void splitAndTransferTo(int startIndex, int length,\n-                                 BaseNullableVariableWidthVector target) {\n+                                 BaseVariableWidthVector target) {\n     compareTypes(target, \"splitAndTransferTo\");\n     target.clear();\n     splitAndTransferValidityBuffer(startIndex, length, target);\n@@ -697,7 +697,7 @@ public void splitAndTransferTo(int startIndex, int length,\n    * need to explicitly allocate the offset buffer and set the adjusted offsets\n    * in the target vector.\n    */\n-  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseNullableVariableWidthVector target) {\n+  private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseVariableWidthVector target) {\n     final int start = offsetBuffer.getInt(startIndex * OFFSET_WIDTH);\n     final int end = offsetBuffer.getInt((startIndex + length) * OFFSET_WIDTH);\n     final int dataLength = end - start;\n@@ -713,7 +713,7 @@ private void splitAndTransferOffsetBuffer(int startIndex, int length, BaseNullab\n    * Transfer the validity.\n    */\n   private void splitAndTransferValidityBuffer(int startIndex, int length,\n-                                              BaseNullableVariableWidthVector target) {\n+                                              BaseVariableWidthVector target) {\n     assert startIndex + length <= valueCount;\n     int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n     int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableBigIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BigIntVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableBigIntVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/BigIntVector.java\nindex 8d44c92e4..ccf0c3067 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableBigIntVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BigIntVector.java\n@@ -29,35 +29,35 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableBigIntVector implements a fixed width vector (8 bytes) of\n+ * BigIntVector implements a fixed width vector (8 bytes) of\n  * integer values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableBigIntVector extends BaseNullableFixedWidthVector {\n+public class BigIntVector extends BaseFixedWidthVector {\n   public static final byte TYPE_WIDTH = 8;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableBigIntVector. This doesn't allocate any memory for\n+   * Instantiate a BigIntVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableBigIntVector(String name, BufferAllocator allocator) {\n+  public BigIntVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.BIGINT.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableBigIntVector. This doesn't allocate any memory for\n+   * Instantiate a BigIntVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableBigIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public BigIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new BigIntReaderImpl(NullableBigIntVector.this);\n+    reader = new BigIntReaderImpl(BigIntVector.this);\n   }\n \n   /**\n@@ -136,21 +136,21 @@ public Long getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableBigIntVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, BigIntVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final long value = from.valueBuffer.getLong(fromIndex * TYPE_WIDTH);\n     valueBuffer.setLong(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableBigIntVector)} except that\n+   * Same as {@link #copyFrom(int, int, BigIntVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableBigIntVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, BigIntVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -329,22 +329,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableBigIntVector) to);\n+    return new TransferImpl((BigIntVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableBigIntVector to;\n+    BigIntVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableBigIntVector(ref, field.getFieldType(), allocator);\n+      to = new BigIntVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableBigIntVector to) {\n+    public TransferImpl(BigIntVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableBigIntVector getTo() {\n+    public BigIntVector getTo() {\n       return to;\n     }\n \n@@ -360,7 +360,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableBigIntVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, BigIntVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java b/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\nindex 26c817008..b6f7323a7 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/BitVector.java\n@@ -18,342 +18,469 @@\n \n package org.apache.arrow.vector;\n \n+import io.netty.buffer.ArrowBuf;\n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.memory.BaseAllocator;\n-import org.apache.arrow.memory.OutOfMemoryException;\n+import org.apache.arrow.vector.complex.impl.BitReaderImpl;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.holders.BitHolder;\n import org.apache.arrow.vector.holders.NullableBitHolder;\n-import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n-import org.apache.arrow.vector.types.Types.MinorType;\n-import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n-import io.netty.buffer.ArrowBuf;\n-\n /**\n- * Bit implements a vector of bit-width values. Elements in the vector are accessed by position from the logical start\n- * of the vector. The width of each element is 1 bit. The equivalent Java primitive is an int containing the value '0'\n- * or '1'.\n+ * BitVector implements a fixed width (1 bit) vector of\n+ * boolean values which could be null. Each value in the vector corresponds\n+ * to a single bit in the underlying data stream backing the vector.\n  */\n-public final class BitVector extends BaseDataValueVector implements FixedWidthVector {\n-  static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(BitVector.class);\n-\n-  private final Accessor accessor = new Accessor();\n-  private final Mutator mutator = new Mutator();\n-\n-  int valueCount;\n-  private int allocationSizeInBytes = getSizeFromCount(INITIAL_VALUE_ALLOCATION);\n-  private int allocationMonitor = 0;\n+public class BitVector extends BaseFixedWidthVector {\n+  private final FieldReader reader;\n \n+  /**\n+   * Instantiate a BitVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param allocator allocator for memory management.\n+   */\n   public BitVector(String name, BufferAllocator allocator) {\n-    super(name, allocator);\n+    this(name, FieldType.nullable(Types.MinorType.BIT.getType()),\n+            allocator);\n   }\n \n-  @Override\n-  public void load(ArrowFieldNode fieldNode, ArrowBuf data) {\n-    // When the vector is all nulls or all defined, the content of the buffer can be omitted\n-    if (data.readableBytes() == 0 && fieldNode.getLength() != 0) {\n-      int count = fieldNode.getLength();\n-      allocateNew(count);\n-      int n = getSizeFromCount(count);\n-      if (fieldNode.getNullCount() == 0) {\n-        // all defined\n-        // create an all 1s buffer\n-        // set full bytes\n-        int fullBytesCount = count / 8;\n-        for (int i = 0; i < fullBytesCount; ++i) {\n-          this.data.setByte(i, 0xFF);\n-        }\n-        int remainder = count % 8;\n-        // set remaining bits\n-        if (remainder > 0) {\n-          byte bitMask = (byte) (0xFFL >>> ((8 - remainder) & 7));\n-          this.data.setByte(fullBytesCount, bitMask);\n-        }\n-      } else if (fieldNode.getNullCount() == fieldNode.getLength()) {\n-        // all null\n-        // create an all 0s buffer\n-        zeroVector();\n-      } else {\n-        throw new IllegalArgumentException(\"The buffer can be empty only if there's no data or it's all null or all defined\");\n-      }\n-      this.data.writerIndex(n);\n-    } else {\n-      super.load(fieldNode, data);\n-    }\n-    this.valueCount = fieldNode.getLength();\n+  /**\n+   * Instantiate a BitVector. This doesn't allocate any memory for\n+   * the data in vector.\n+   *\n+   * @param name      name of the vector\n+   * @param fieldType type of Field materialized by this vector\n+   * @param allocator allocator for memory management.\n+   */\n+  public BitVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+    super(name, allocator, fieldType, (byte) 0);\n+    reader = new BitReaderImpl(BitVector.this);\n   }\n \n+  /**\n+   * Get a reader that supports reading values from this vector\n+   *\n+   * @return Field Reader for this vector\n+   */\n   @Override\n-  public Field getField() {\n-    throw new UnsupportedOperationException(\"internal vector\");\n+  public FieldReader getReader() {\n+    return reader;\n   }\n \n+  /**\n+   * Get minor type for this vector. The vector holds values belonging\n+   * to a particular type.\n+   *\n+   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n+   */\n   @Override\n-  public MinorType getMinorType() {\n-    return MinorType.BIT;\n+  public Types.MinorType getMinorType() {\n+    return Types.MinorType.BIT;\n   }\n \n+  /**\n+   * Sets the desired value capacity for the vector. This function doesn't\n+   * allocate any memory for the vector.\n+   *\n+   * @param valueCount desired number of elements in the vector\n+   */\n   @Override\n-  public FieldReader getReader() {\n-    throw new UnsupportedOperationException(\"internal vector\");\n+  public void setInitialCapacity(int valueCount) {\n+    final int size = getValidityBufferSizeFromCount(valueCount);\n+    if (size > MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n+    }\n+    valueAllocationSizeInBytes = size;\n+    validityAllocationSizeInBytes = size;\n   }\n \n+  /**\n+   * Get the current value capacity for the vector\n+   *\n+   * @return number of elements that vector can hold.\n+   */\n   @Override\n-  public int getBufferSize() {\n-    return getSizeFromCount(valueCount);\n+  public int getValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n   }\n \n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   *\n+   * @param count desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   * a given number of elements\n+   */\n   @Override\n-  public int getBufferSizeFor(final int valueCount) {\n-    return getSizeFromCount(valueCount);\n+  public int getBufferSizeFor(final int count) {\n+    if (count == 0) {\n+      return 0;\n+    }\n+    return 2 * getValidityBufferSizeFromCount(count);\n   }\n \n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   *\n+   * @return size of underlying buffers.\n+   */\n   @Override\n-  public ArrowBuf getValidityBuffer() {\n-    /* this operation is not supported for non-nullable vectors */\n-    throw new  UnsupportedOperationException();\n+  public int getBufferSize() {\n+    return getBufferSizeFor(valueCount);\n   }\n \n-  @Override\n-  public ArrowBuf getDataBuffer() {\n-    /* we are not throwing away getBuffer() of BaseDataValueVector so use it wherever applicable */\n-    return getBuffer();\n-  }\n+  /**\n+   * Slice this vector at desired index and length and transfer the\n+   * corresponding data to the target vector.\n+   *\n+   * @param startIndex start position of the split in source vector.\n+   * @param length     length of the split.\n+   * @param target     destination vector\n+   */\n+  public void splitAndTransferTo(int startIndex, int length,\n+                                 BaseFixedWidthVector target) {\n+    compareTypes(target, \"splitAndTransferTo\");\n+    target.clear();\n+    target.validityBuffer = splitAndTransferBuffer(startIndex, length, target,\n+            validityBuffer, target.validityBuffer);\n+    target.valueBuffer = splitAndTransferBuffer(startIndex, length, target,\n+            valueBuffer, target.valueBuffer);\n \n-  @Override\n-  public ArrowBuf getOffsetBuffer() {\n-    /* this operation is not supported for fixed-width vectors */\n-    throw new UnsupportedOperationException();\n+    target.setValueCount(length);\n   }\n \n-  int getSizeFromCount(int valueCount) {\n-    return (int) Math.ceil(valueCount / 8.0);\n-  }\n+  private ArrowBuf splitAndTransferBuffer(int startIndex, int length,\n+                                          BaseFixedWidthVector target,\n+                                          ArrowBuf sourceBuffer, ArrowBuf destBuffer) {\n+    assert startIndex + length <= valueCount;\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n+    int offset = startIndex % 8;\n \n-  @Override\n-  public int getValueCapacity() {\n-    return (int) Math.min((long) Integer.MAX_VALUE, data.capacity() * 8L);\n-  }\n+    if (length > 0) {\n+      if (offset == 0) {\n+            /* slice */\n+        if (destBuffer != null) {\n+          destBuffer.release();\n+        }\n+        destBuffer = sourceBuffer.slice(firstByteSource, byteSizeTarget);\n+        destBuffer.retain(1);\n+      } else {\n+            /* Copy data\n+             * When the first bit starts from the middle of a byte (offset != 0),\n+             * copy data from src BitVector.\n+             * Each byte in the target is composed by a part in i-th byte,\n+             * another part in (i+1)-th byte.\n+             */\n+        destBuffer = allocator.buffer(byteSizeTarget);\n+        destBuffer.readerIndex(0);\n+        destBuffer.setZero(0, destBuffer.capacity());\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(sourceBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(sourceBuffer, firstByteSource + i + 1, offset);\n+\n+          destBuffer.setByte(i, (b1 + b2));\n+        }\n \n-  private int getByteIndex(int index) {\n-    return (int) Math.floor(index / 8.0);\n+            /* Copying the last piece is done in the following manner:\n+             * if the source vector has 1 or more bytes remaining, we copy\n+             * the last piece as a byte formed by shifting data\n+             * from the current byte and the next byte.\n+             *\n+             * if the source vector has no more bytes remaining\n+             * (we are at the last byte), we copy the last piece as a byte\n+             * by shifting data from the current byte.\n+             */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(sourceBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(sourceBuffer,\n+                  firstByteSource + byteSizeTarget, offset);\n+\n+          destBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(sourceBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          destBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n+      }\n+    }\n+\n+    return destBuffer;\n   }\n \n-  @Override\n-  public void setInitialCapacity(final int valueCount) {\n-    allocationSizeInBytes = getSizeFromCount(valueCount);\n+\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value retrieval methods                        *\n+   *                                                                *\n+   ******************************************************************/\n+\n+  private int getBit(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = valueBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n   }\n \n-  @Override\n-  public void allocateNew() {\n-    if (!allocateNewSafe()) {\n-      throw new OutOfMemoryException();\n+  /**\n+   * Get the element at the given index from the vector.\n+   *\n+   * @param index position of element\n+   * @return element at given index\n+   */\n+  public int get(int index) throws IllegalStateException {\n+    if (isSet(index) == 0) {\n+      throw new IllegalStateException(\"Value at index is null\");\n     }\n+    return getBit(index);\n   }\n \n-  @Override\n-  public boolean allocateNewSafe() {\n-    long curAllocationSize = allocationSizeInBytes;\n-    if (allocationMonitor > 10) {\n-      curAllocationSize = Math.max(8, allocationSizeInBytes / 2);\n-      allocationMonitor = 0;\n-    } else if (allocationMonitor < -2) {\n-      curAllocationSize = allocationSizeInBytes * 2L;\n-      allocationMonitor = 0;\n+  /**\n+   * Get the element at the given index from the vector and\n+   * sets the state in holder. If element at given index\n+   * is null, holder.isSet will be zero.\n+   *\n+   * @param index position of element\n+   */\n+  public void get(int index, NullableBitHolder holder) {\n+    if (isSet(index) == 0) {\n+      holder.isSet = 0;\n+      return;\n     }\n+    holder.isSet = 1;\n+    holder.value = getBit(index);\n+  }\n \n-    try {\n-      allocateBytes(curAllocationSize);\n-    } catch (OutOfMemoryException ex) {\n-      return false;\n+  /**\n+   * Same as {@link #get(int)}.\n+   *\n+   * @param index position of element\n+   * @return element at given index\n+   */\n+  public Boolean getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return new Boolean(getBit(index) != 0);\n     }\n-    return true;\n   }\n \n-  @Override\n-  public void reset() {\n-    valueCount = 0;\n-    allocationSizeInBytes = getSizeFromCount(INITIAL_VALUE_ALLOCATION);\n-    allocationMonitor = 0;\n-    zeroVector();\n-    super.reset();\n+  /**\n+   * Copy a cell value from a particular index in source vector to a particular\n+   * position in this vector\n+   *\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from      source vector\n+   */\n+  public void copyFrom(int fromIndex, int thisIndex, BitVector from) {\n+    BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n+    BitVectorHelper.setValidityBit(valueBuffer, thisIndex, from.getBit(fromIndex));\n   }\n \n   /**\n-   * Allocate a new memory space for this vector. Must be called prior to using the ValueVector.\n+   * Same as {@link #copyFrom(int, int, BitVector)} except that\n+   * it handles the case when the capacity of the vector needs to be expanded\n+   * before copy.\n    *\n-   * @param valueCount The number of values which can be contained within this vector.\n+   * @param fromIndex position to copy from in source vector\n+   * @param thisIndex position to copy to in this vector\n+   * @param from      source vector\n    */\n-  @Override\n-  public void allocateNew(int valueCount) {\n-    final int size = getSizeFromCount(valueCount);\n-    allocateBytes(size);\n+  public void copyFromSafe(int fromIndex, int thisIndex, BitVector from) {\n+    handleSafe(thisIndex);\n+    copyFrom(fromIndex, thisIndex, from);\n   }\n \n-  private void allocateBytes(final long size) {\n-    if (size > MAX_ALLOCATION_SIZE) {\n-      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed allocation size\");\n-    }\n \n-    final int curSize = (int) size;\n-    clear();\n-    data = allocator.buffer(curSize);\n-    zeroVector();\n-    allocationSizeInBytes = curSize;\n-  }\n+  /******************************************************************\n+   *                                                                *\n+   *          vector value setter methods                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n \n   /**\n-   * Allocate new buffer with double capacity, and copy data into the new buffer. Replace vector's buffer with new buffer, and release old one\n+   * Set the element at the given index to the given value.\n+   *\n+   * @param index position of element\n+   * @param value value of element\n    */\n-  public void reAlloc() {\n-    long baseSize  = allocationSizeInBytes;\n-    final int currentBufferCapacity = data.capacity();\n-    if (baseSize < (long)currentBufferCapacity) {\n-      baseSize = (long)currentBufferCapacity;\n+  public void set(int index, int value) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    if (value != 0) {\n+      BitVectorHelper.setValidityBitToOne(valueBuffer, index);\n+    } else {\n+      BitVectorHelper.setValidityBit(valueBuffer, index, 0);\n     }\n-    long newAllocationSize = baseSize * 2L;\n-    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+  }\n \n-    if (newAllocationSize > MAX_ALLOCATION_SIZE) {\n-      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed allocation size\");\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   * If the value in holder is not indicated as set, element in the\n+   * at the given index will be null.\n+   *\n+   * @param index  position of element\n+   * @param holder nullable data holder for value of element\n+   */\n+  public void set(int index, NullableBitHolder holder) throws IllegalArgumentException {\n+    if (holder.isSet < 0) {\n+      throw new IllegalArgumentException();\n+    } else if (holder.isSet > 0) {\n+      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+      if (holder.value != 0) {\n+        BitVectorHelper.setValidityBitToOne(valueBuffer, index);\n+      } else {\n+        BitVectorHelper.setValidityBit(valueBuffer, index, 0);\n+      }\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n     }\n+  }\n \n-    final int curSize = (int) newAllocationSize;\n-    final ArrowBuf newBuf = allocator.buffer(curSize);\n-    newBuf.setZero(0, newBuf.capacity());\n-    newBuf.setBytes(0, data, 0, currentBufferCapacity);\n-    data.release();\n-    data = newBuf;\n-    allocationSizeInBytes = curSize;\n+  /**\n+   * Set the element at the given index to the value set in data holder.\n+   *\n+   * @param index  position of element\n+   * @param holder data holder for value of element\n+   */\n+  public void set(int index, BitHolder holder) {\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+    if (holder.value != 0) {\n+      BitVectorHelper.setValidityBitToOne(valueBuffer, index);\n+    } else {\n+      BitVectorHelper.setValidityBit(valueBuffer, index, 0);\n+    }\n   }\n \n   /**\n-   * {@inheritDoc}\n+   * Same as {@link #set(int, int)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index position of element\n+   * @param value value of element\n    */\n-  @Override\n-  public void zeroVector() {\n-    data.setZero(0, data.capacity());\n+  public void setSafe(int index, int value) {\n+    handleSafe(index);\n+    set(index, value);\n   }\n \n-  public void copyFrom(int inIndex, int outIndex, BitVector from) {\n-    this.mutator.set(outIndex, from.accessor.get(inIndex));\n+  /**\n+   * Same as {@link #set(int, NullableBitHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index  position of element\n+   * @param holder nullable data holder for value of element\n+   */\n+  public void setSafe(int index, NullableBitHolder holder) throws IllegalArgumentException {\n+    handleSafe(index);\n+    set(index, holder);\n   }\n \n-  public void copyFromSafe(int inIndex, int outIndex, BitVector from) {\n-    if (outIndex >= this.getValueCapacity()) {\n-      reAlloc();\n-    }\n-    copyFrom(inIndex, outIndex, from);\n+  /**\n+   * Same as {@link #set(int, BitHolder)} except that it handles the\n+   * case when index is greater than or equal to existing\n+   * value capacity {@link #getValueCapacity()}.\n+   *\n+   * @param index  position of element\n+   * @param holder data holder for value of element\n+   */\n+  public void setSafe(int index, BitHolder holder) {\n+    handleSafe(index);\n+    set(index, holder);\n   }\n \n-  @Override\n-  public Mutator getMutator() {\n-    return mutator;\n+  /**\n+   * Set the element at the given index to null.\n+   *\n+   * @param index position of element\n+   */\n+  public void setNull(int index) {\n+    handleSafe(index);\n+      /* not really needed to set the bit to 0 as long as\n+       * the buffer always starts from 0.\n+       */\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n   }\n \n-  @Override\n-  public Accessor getAccessor() {\n-    return accessor;\n+  /**\n+   * Store the given value at a particular position in the vector. isSet indicates\n+   * whether the value is NULL or not.\n+   *\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void set(int index, int isSet, int value) {\n+    if (isSet > 0) {\n+      set(index, value);\n+    } else {\n+      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n+    }\n   }\n \n-  @Override\n-  public TransferPair getTransferPair(BufferAllocator allocator) {\n-    return new TransferImpl(name, allocator);\n+  /**\n+   * Same as {@link #set(int, int, int)} except that it handles the case\n+   * when index is greater than or equal to current value capacity of the\n+   * vector.\n+   *\n+   * @param index position of the new value\n+   * @param isSet 0 for NULL value, 1 otherwise\n+   * @param value element value\n+   */\n+  public void setSafe(int index, int isSet, int value) {\n+    handleSafe(index);\n+    set(index, isSet, value);\n   }\n \n+\n+  /******************************************************************\n+   *                                                                *\n+   *                      vector transfer                           *\n+   *                                                                *\n+   ******************************************************************/\n+\n+\n+  /**\n+   * Construct a TransferPair comprising of this and and a target vector of\n+   * the same type.\n+   *\n+   * @param ref       name of the target vector\n+   * @param allocator allocator for the target vector\n+   * @return {@link TransferPair}\n+   */\n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n     return new TransferImpl(ref, allocator);\n   }\n \n+  /**\n+   * Construct a TransferPair with a desired target vector of the same type.\n+   *\n+   * @param to target vector\n+   * @return {@link TransferPair}\n+   */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n     return new TransferImpl((BitVector) to);\n   }\n \n-\n-  public void transferTo(BitVector target) {\n-    target.clear();\n-    target.data = data.transferOwnership(target.allocator).buffer;\n-    target.valueCount = valueCount;\n-    clear();\n-  }\n-\n-  public void splitAndTransferTo(int startIndex, int length, BitVector target) {\n-    assert startIndex + length <= valueCount;\n-    int firstByteSource = getByteIndex(startIndex);\n-    int lastByteSource = getByteIndex(valueCount - 1);\n-    int byteSizeTarget = getSizeFromCount(length);\n-    int offset = startIndex % 8;\n-\n-    if (length > 0) {\n-      if (offset == 0) {\n-        target.clear();\n-        // slice\n-        if (target.data != null) {\n-          target.data.release();\n-        }\n-        target.data = data.slice(firstByteSource, byteSizeTarget);\n-        target.data.retain(1);\n-      }\n-      else {\n-        // Copy data\n-        // When the first bit starts from the middle of a byte (offset != 0), copy data from src BitVector.\n-        // Each byte in the target is composed by a part in i-th byte, another part in (i+1)-th byte.\n-\n-        target.clear();\n-        target.allocateNew(byteSizeTarget * 8);\n-\n-        // TODO maybe do this one word at a time, rather than byte?\n-\n-        for (int i = 0; i < byteSizeTarget - 1; i++) {\n-          byte b1 = getBitsFromCurrentByte(this.data, firstByteSource + i, offset);\n-          byte b2 = getBitsFromNextByte(this.data, firstByteSource + i + 1, offset);\n-\n-          target.data.setByte(i, (b1 + b2));\n-        }\n-\n-        /* Copying the last piece is done in the following manner:\n-         * if the source vector has 1 or more bytes remaining, we copy\n-         * the last piece as a byte formed by shifting data\n-         * from the current byte and the next byte.\n-         *\n-         * if the source vector has no more bytes remaining\n-         * (we are at the last byte), we copy the last piece as a byte\n-         * by shifting data from the current byte.\n-         */\n-        if((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n-          byte b1 = getBitsFromCurrentByte(this.data, firstByteSource + byteSizeTarget - 1, offset);\n-          byte b2 = getBitsFromNextByte(this.data, firstByteSource + byteSizeTarget, offset);\n-\n-          target.data.setByte(byteSizeTarget - 1, b1 + b2);\n-        }\n-        else {\n-          byte b1 = getBitsFromCurrentByte(this.data, firstByteSource + byteSizeTarget - 1, offset);\n-\n-          target.data.setByte(byteSizeTarget - 1, b1);\n-        }\n-      }\n-    }\n-    target.getMutator().setValueCount(length);\n-  }\n-\n-  private static byte getBitsFromCurrentByte(ArrowBuf data, int index, int offset) {\n-    return (byte)((data.getByte(index) & 0xFF) >>> offset);\n-  }\n-\n-  private static byte getBitsFromNextByte(ArrowBuf data, int index, int offset) {\n-    return (byte)((data.getByte(index) << (8 - offset)));\n-  }\n-\n   private class TransferImpl implements TransferPair {\n     BitVector to;\n \n-    public TransferImpl(String name, BufferAllocator allocator) {\n-      this.to = new BitVector(name, allocator);\n+    public TransferImpl(String ref, BufferAllocator allocator) {\n+      to = new BitVector(ref, field.getFieldType(), allocator);\n     }\n \n     public TransferImpl(BitVector to) {\n@@ -380,269 +507,4 @@ public void copyValueSafe(int fromIndex, int toIndex) {\n       to.copyFromSafe(fromIndex, toIndex, BitVector.this);\n     }\n   }\n-\n-  private void decrementAllocationMonitor() {\n-    if (allocationMonitor > 0) {\n-      allocationMonitor = 0;\n-    }\n-    --allocationMonitor;\n-  }\n-\n-  private void incrementAllocationMonitor() {\n-    ++allocationMonitor;\n-  }\n-\n-  public class Accessor extends BaseAccessor {\n-\n-    /**\n-     * Get the byte holding the desired bit, then mask all other bits. Iff the result is 0, the bit was not set.\n-     *\n-     * @param index position of the bit in the vector\n-     * @return 1 if set, otherwise 0\n-     */\n-    public final int get(int index) {\n-      int byteIndex = index >> 3;\n-      byte b = data.getByte(byteIndex);\n-      int bitIndex = index & 7;\n-      return Long.bitCount(b & (1L << bitIndex));\n-    }\n-\n-    @Override\n-    public boolean isNull(int index) {\n-      return false;\n-    }\n-\n-    @Override\n-    public final Boolean getObject(int index) {\n-      return new Boolean(get(index) != 0);\n-    }\n-\n-    @Override\n-    public final int getValueCount() {\n-      return valueCount;\n-    }\n-\n-    public final void get(int index, BitHolder holder) {\n-      holder.value = get(index);\n-    }\n-\n-    public final void get(int index, NullableBitHolder holder) {\n-      holder.isSet = 1;\n-      holder.value = get(index);\n-    }\n-\n-    /**\n-     * Get the number nulls, this correspond to the number of bits set to 0 in the vector\n-     *\n-     * @return the number of bits set to 0\n-     */\n-    @Override\n-    public final int getNullCount() {\n-      int count = 0;\n-      int sizeInBytes = getSizeFromCount(valueCount);\n-\n-      for (int i = 0; i < sizeInBytes; ++i) {\n-        byte byteValue = data.getByte(i);\n-        // Java uses two's complement binary representation, hence 11111111_b which is -1 when converted to Int\n-        // will have 32bits set to 1. Masking the MSB and then adding it back solves the issue.\n-        count += Integer.bitCount(byteValue & 0x7F) - (byteValue >> 7);\n-      }\n-      int nullCount = (sizeInBytes * 8) - count;\n-      // if the valueCount is not a multiple of 8, the bits on the right were counted as null bits\n-      int remainder = valueCount % 8;\n-      nullCount -= remainder == 0 ? 0 : 8 - remainder;\n-      return nullCount;\n-    }\n-  }\n-\n-  /**\n-   * MutableBit implements a vector of bit-width values. Elements in the vector are accessed by position from the\n-   * logical start of the vector. Values should be pushed onto the vector sequentially, but may be randomly accessed.\n-   *\n-   * NB: this class is automatically generated from ValueVectorTypes.tdd using FreeMarker.\n-   */\n-  public class Mutator extends BaseMutator {\n-\n-    private Mutator() {\n-    }\n-\n-    /**\n-     * Set the bit at the given index to the specified value.\n-     *\n-     * @param index position of the bit to set\n-     * @param value value to set (either 1 or 0)\n-     */\n-    public final void set(int index, int value) {\n-      int byteIndex = byteIndex(index);\n-      int bitIndex = bitIndex(index);\n-      byte currentByte = data.getByte(byteIndex);\n-      byte bitMask = (byte) (1L << bitIndex);\n-      if (value != 0) {\n-        currentByte |= bitMask;\n-      } else {\n-        currentByte -= (bitMask & currentByte);\n-      }\n-      data.setByte(byteIndex, currentByte);\n-    }\n-\n-    /**\n-     * Set the bit at the given index to 1.\n-     *\n-     * @param index position of the bit to set\n-     */\n-    public final void setToOne(int index) {\n-      int byteIndex = byteIndex(index);\n-      int bitIndex = bitIndex(index);\n-      byte currentByte = data.getByte(byteIndex);\n-      byte bitMask = (byte) (1L << bitIndex);\n-      currentByte |= bitMask;\n-      data.setByte(byteIndex, currentByte);\n-    }\n-\n-    /**\n-     * set count bits to 1 in data starting at firstBitIndex\n-     *\n-     * @param firstBitIndex the index of the first bit to set\n-     * @param count         the number of bits to set\n-     */\n-    public void setRangeToOne(int firstBitIndex, int count) {\n-      int starByteIndex = byteIndex(firstBitIndex);\n-      final int lastBitIndex = firstBitIndex + count;\n-      final int endByteIndex = byteIndex(lastBitIndex);\n-      final int startByteBitIndex = bitIndex(firstBitIndex);\n-      final int endBytebitIndex = bitIndex(lastBitIndex);\n-      if (count < 8 && starByteIndex == endByteIndex) {\n-        // handles the case where we don't have a first and a last byte\n-        byte bitMask = 0;\n-        for (int i = startByteBitIndex; i < endBytebitIndex; ++i) {\n-          bitMask |= (byte) (1L << i);\n-        }\n-        byte currentByte = data.getByte(starByteIndex);\n-        currentByte |= bitMask;\n-        data.setByte(starByteIndex, currentByte);\n-      } else {\n-        // fill in first byte (if it's not full)\n-        if (startByteBitIndex != 0) {\n-          byte currentByte = data.getByte(starByteIndex);\n-          final byte bitMask = (byte) (0xFFL << startByteBitIndex);\n-          currentByte |= bitMask;\n-          data.setByte(starByteIndex, currentByte);\n-          ++starByteIndex;\n-        }\n-\n-        // fill in one full byte at a time\n-        for (int i = starByteIndex; i < endByteIndex; i++) {\n-          data.setByte(i, 0xFF);\n-        }\n-\n-        // fill in the last byte (if it's not full)\n-        if (endBytebitIndex != 0) {\n-          final int byteIndex = byteIndex(lastBitIndex - endBytebitIndex);\n-          byte currentByte = data.getByte(byteIndex);\n-          final byte bitMask = (byte) (0xFFL >>> ((8 - endBytebitIndex) & 7));\n-          currentByte |= bitMask;\n-          data.setByte(byteIndex, currentByte);\n-        }\n-\n-      }\n-    }\n-\n-    /**\n-     * @param absoluteBitIndex the index of the bit in the buffer\n-     * @return the index of the byte containing that bit\n-     */\n-    private int byteIndex(int absoluteBitIndex) {\n-      return absoluteBitIndex >> 3;\n-    }\n-\n-    /**\n-     * @param absoluteBitIndex the index of the bit in the buffer\n-     * @return the index of the bit inside the byte\n-     */\n-    private int bitIndex(int absoluteBitIndex) {\n-      return absoluteBitIndex & 7;\n-    }\n-\n-    public final void set(int index, BitHolder holder) {\n-      set(index, holder.value);\n-    }\n-\n-    final void set(int index, NullableBitHolder holder) {\n-      set(index, holder.value);\n-    }\n-\n-    public void setSafe(int index, int value) {\n-      while (index >= getValueCapacity()) {\n-        reAlloc();\n-      }\n-      set(index, value);\n-    }\n-\n-    public void setSafeToOne(int index) {\n-      while (index >= getValueCapacity()) {\n-        reAlloc();\n-      }\n-      setToOne(index);\n-    }\n-\n-    public void setSafe(int index, BitHolder holder) {\n-      while (index >= getValueCapacity()) {\n-        reAlloc();\n-      }\n-      set(index, holder.value);\n-    }\n-\n-    public void setSafe(int index, NullableBitHolder holder) {\n-      while (index >= getValueCapacity()) {\n-        reAlloc();\n-      }\n-      set(index, holder.value);\n-    }\n-\n-    @Override\n-    public final void setValueCount(int valueCount) {\n-      int currentValueCapacity = getValueCapacity();\n-      BitVector.this.valueCount = valueCount;\n-      int idx = getSizeFromCount(valueCount);\n-      while (valueCount > getValueCapacity()) {\n-        reAlloc();\n-      }\n-      if (valueCount > 0 && currentValueCapacity > valueCount * 2) {\n-        incrementAllocationMonitor();\n-      } else if (allocationMonitor > 0) {\n-        allocationMonitor = 0;\n-      }\n-      VectorTrimmer.trim(data, idx);\n-    }\n-\n-    @Override\n-    public final void generateTestData(int values) {\n-      boolean even = true;\n-      for (int i = 0; i < values; i++, even = !even) {\n-        if (even) {\n-          set(i, 1);\n-        }\n-      }\n-      setValueCount(values);\n-    }\n-\n-    public void generateTestDataAlt(int size) {\n-      setValueCount(size);\n-      boolean even = true;\n-      final int valueCount = getAccessor().getValueCount();\n-      for (int i = 0; i < valueCount; i++, even = !even) {\n-        if (even) {\n-          set(i, (byte) 1);\n-        } else {\n-          set(i, (byte) 0);\n-        }\n-      }\n-    }\n-  }\n-\n-  @Override\n-  public void clear() {\n-    this.valueCount = 0;\n-    super.clear();\n-  }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableDateDayVector.java b/java/vector/src/main/java/org/apache/arrow/vector/DateDayVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableDateDayVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/DateDayVector.java\nindex bb14d1ac0..ed8956c1e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableDateDayVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/DateDayVector.java\n@@ -30,35 +30,35 @@\n import org.slf4j.Logger;\n \n /**\n- * NullableDateDayVector implements a fixed width (4 bytes) vector of\n+ * DateDayVector implements a fixed width (4 bytes) vector of\n  * date values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableDateDayVector extends BaseNullableFixedWidthVector {\n+public class DateDayVector extends BaseFixedWidthVector {\n   private static final byte TYPE_WIDTH = 4;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableDateDayVector. This doesn't allocate any memory for\n+   * Instantiate a DateDayVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableDateDayVector(String name, BufferAllocator allocator) {\n+  public DateDayVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.DATEDAY.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableDateDayVector. This doesn't allocate any memory for\n+   * Instantiate a DateDayVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableDateDayVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public DateDayVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new DateDayReaderImpl(NullableDateDayVector.this);\n+    reader = new DateDayReaderImpl(DateDayVector.this);\n   }\n \n   /**\n@@ -138,21 +138,21 @@ public Integer getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableDateDayVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, DateDayVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final int value = from.valueBuffer.getInt(fromIndex * TYPE_WIDTH);\n     valueBuffer.setInt(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableDateDayVector)} except that\n+   * Same as {@link #copyFrom(int, int, DateDayVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableDateDayVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, DateDayVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -331,22 +331,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableDateDayVector) to);\n+    return new TransferImpl((DateDayVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableDateDayVector to;\n+    DateDayVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableDateDayVector(ref, field.getFieldType(), allocator);\n+      to = new DateDayVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableDateDayVector to) {\n+    public TransferImpl(DateDayVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableDateDayVector getTo() {\n+    public DateDayVector getTo() {\n       return to;\n     }\n \n@@ -362,7 +362,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableDateDayVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, DateDayVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableDateMilliVector.java b/java/vector/src/main/java/org/apache/arrow/vector/DateMilliVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableDateMilliVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/DateMilliVector.java\nindex 97205c318..f21b58f85 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableDateMilliVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/DateMilliVector.java\n@@ -32,35 +32,35 @@\n import org.slf4j.Logger;\n \n /**\n- * NullableDateMilliVector implements a fixed width vector (8 bytes) of\n+ * DateMilliVector implements a fixed width vector (8 bytes) of\n  * date values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableDateMilliVector extends BaseNullableFixedWidthVector {\n+public class DateMilliVector extends BaseFixedWidthVector {\n   private static final byte TYPE_WIDTH = 8;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableDateMilliVector. This doesn't allocate any memory for\n+   * Instantiate a DateMilliVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableDateMilliVector(String name, BufferAllocator allocator) {\n+  public DateMilliVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.DATEMILLI.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableDateMilliVector. This doesn't allocate any memory for\n+   * Instantiate a DateMilliVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableDateMilliVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public DateMilliVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new DateMilliReaderImpl(NullableDateMilliVector.this);\n+    reader = new DateMilliReaderImpl(DateMilliVector.this);\n   }\n \n   /**\n@@ -143,21 +143,21 @@ public LocalDateTime getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableDateMilliVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, DateMilliVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final long value = from.valueBuffer.getLong(fromIndex * TYPE_WIDTH);\n     valueBuffer.setLong(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableDateMilliVector)} except that\n+   * Same as {@link #copyFrom(int, int, DateMilliVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableDateMilliVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, DateMilliVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -336,22 +336,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableDateMilliVector) to);\n+    return new TransferImpl((DateMilliVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableDateMilliVector to;\n+    DateMilliVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableDateMilliVector(ref, field.getFieldType(), allocator);\n+      to = new DateMilliVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableDateMilliVector to) {\n+    public TransferImpl(DateMilliVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableDateMilliVector getTo() {\n+    public DateMilliVector getTo() {\n       return to;\n     }\n \n@@ -367,7 +367,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableDateMilliVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, DateMilliVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableDecimalVector.java b/java/vector/src/main/java/org/apache/arrow/vector/DecimalVector.java\nsimilarity index 91%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableDecimalVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/DecimalVector.java\nindex 5d2782a4c..71a74cb9f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableDecimalVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/DecimalVector.java\n@@ -32,11 +32,11 @@\n import java.math.BigDecimal;\n \n /**\n- * NullableDecimalVector implements a fixed width vector (16 bytes) of\n+ * DecimalVector implements a fixed width vector (16 bytes) of\n  * decimal values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableDecimalVector extends BaseNullableFixedWidthVector {\n+public class DecimalVector extends BaseFixedWidthVector {\n   public static final byte TYPE_WIDTH = 16;\n   private final FieldReader reader;\n \n@@ -44,28 +44,28 @@\n   private final int scale;\n \n   /**\n-   * Instantiate a NullableDecimalVector. This doesn't allocate any memory for\n+   * Instantiate a DecimalVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableDecimalVector(String name, BufferAllocator allocator,\n+  public DecimalVector(String name, BufferAllocator allocator,\n                                int precision, int scale) {\n     this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Decimal(precision, scale)),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableDecimalVector. This doesn't allocate any memory for\n+   * Instantiate a DecimalVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableDecimalVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public DecimalVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n     org.apache.arrow.vector.types.pojo.ArrowType.Decimal arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Decimal) fieldType.getType();\n-    reader = new DecimalReaderImpl(NullableDecimalVector.this);\n+    reader = new DecimalReaderImpl(DecimalVector.this);\n     this.precision = arrowType.getPrecision();\n     this.scale = arrowType.getScale();\n   }\n@@ -150,21 +150,21 @@ public BigDecimal getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableDecimalVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, DecimalVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     from.valueBuffer.getBytes(fromIndex * TYPE_WIDTH, valueBuffer,\n             thisIndex * TYPE_WIDTH, TYPE_WIDTH);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableDecimalVector)} except that\n+   * Same as {@link #copyFrom(int, int, DecimalVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableDecimalVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, DecimalVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -385,23 +385,23 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableDecimalVector) to);\n+    return new TransferImpl((DecimalVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableDecimalVector to;\n+    DecimalVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableDecimalVector(ref, allocator, NullableDecimalVector.this.precision,\n-              NullableDecimalVector.this.scale);\n+      to = new DecimalVector(ref, allocator, DecimalVector.this.precision,\n+              DecimalVector.this.scale);\n     }\n \n-    public TransferImpl(NullableDecimalVector to) {\n+    public TransferImpl(DecimalVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableDecimalVector getTo() {\n+    public DecimalVector getTo() {\n       return to;\n     }\n \n@@ -417,7 +417,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableDecimalVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, DecimalVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat4Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/Float4Vector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableFloat4Vector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/Float4Vector.java\nindex 5d7128d2b..dc78bfde2 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat4Vector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/Float4Vector.java\n@@ -29,35 +29,35 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableFloat4Vector implements a fixed width vector (4 bytes) of\n+ * Float4Vector implements a fixed width vector (4 bytes) of\n  * float values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableFloat4Vector extends BaseNullableFixedWidthVector {\n+public class Float4Vector extends BaseFixedWidthVector {\n   public static final byte TYPE_WIDTH = 4;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableFloat4Vector. This doesn't allocate any memory for\n+   * Instantiate a Float4Vector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableFloat4Vector(String name, BufferAllocator allocator) {\n+  public Float4Vector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.FLOAT4.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableFloat4Vector. This doesn't allocate any memory for\n+   * Instantiate a Float4Vector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableFloat4Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public Float4Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new Float4ReaderImpl(NullableFloat4Vector.this);\n+    reader = new Float4ReaderImpl(Float4Vector.this);\n   }\n \n   /**\n@@ -137,21 +137,21 @@ public Float getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableFloat4Vector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, Float4Vector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final float value = from.valueBuffer.getFloat(fromIndex * TYPE_WIDTH);\n     valueBuffer.setFloat(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableFloat4Vector)} except that\n+   * Same as {@link #copyFrom(int, int, Float4Vector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableFloat4Vector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, Float4Vector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -330,22 +330,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableFloat4Vector) to);\n+    return new TransferImpl((Float4Vector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableFloat4Vector to;\n+    Float4Vector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableFloat4Vector(ref, field.getFieldType(), allocator);\n+      to = new Float4Vector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableFloat4Vector to) {\n+    public TransferImpl(Float4Vector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableFloat4Vector getTo() {\n+    public Float4Vector getTo() {\n       return to;\n     }\n \n@@ -361,7 +361,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableFloat4Vector.this);\n+      to.copyFromSafe(fromIndex, toIndex, Float4Vector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat8Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/Float8Vector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableFloat8Vector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/Float8Vector.java\nindex 7aa546150..1b410b868 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableFloat8Vector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/Float8Vector.java\n@@ -29,35 +29,35 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableFloat8Vector implements a fixed width vector (8 bytes) of\n+ * Float8Vector implements a fixed width vector (8 bytes) of\n  * double values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableFloat8Vector extends BaseNullableFixedWidthVector {\n+public class Float8Vector extends BaseFixedWidthVector {\n   public static final byte TYPE_WIDTH = 8;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableFloat8Vector. This doesn't allocate any memory for\n+   * Instantiate a Float8Vector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableFloat8Vector(String name, BufferAllocator allocator) {\n+  public Float8Vector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.FLOAT8.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableFloat8Vector. This doesn't allocate any memory for\n+   * Instantiate a Float8Vector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableFloat8Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public Float8Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new Float8ReaderImpl(NullableFloat8Vector.this);\n+    reader = new Float8ReaderImpl(Float8Vector.this);\n   }\n \n   /**\n@@ -137,21 +137,21 @@ public Double getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableFloat8Vector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, Float8Vector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final double value = from.valueBuffer.getDouble(fromIndex * TYPE_WIDTH);\n     valueBuffer.setDouble(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableFloat8Vector)} except that\n+   * Same as {@link #copyFrom(int, int, Float8Vector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableFloat8Vector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, Float8Vector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -330,22 +330,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableFloat8Vector) to);\n+    return new TransferImpl((Float8Vector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableFloat8Vector to;\n+    Float8Vector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableFloat8Vector(ref, field.getFieldType(), allocator);\n+      to = new Float8Vector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableFloat8Vector to) {\n+    public TransferImpl(Float8Vector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableFloat8Vector getTo() {\n+    public Float8Vector getTo() {\n       return to;\n     }\n \n@@ -361,7 +361,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableFloat8Vector.this);\n+      to.copyFromSafe(fromIndex, toIndex, Float8Vector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java b/java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\nindex 806beb5f8..89e2a02f6 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/GenerateSampleData.java\n@@ -30,62 +30,62 @@\n public class GenerateSampleData {\n \n   public static void generateTestData(final ValueVector vector, final int valueCount) {\n-    if (vector instanceof NullableIntVector) {\n-      writeIntData((NullableIntVector) vector, valueCount);\n-    } else if (vector instanceof NullableDecimalVector) {\n-      writeDecimalData((NullableDecimalVector) vector, valueCount);\n-    } else if (vector instanceof NullableBitVector) {\n-      writeBooleanData((NullableBitVector) vector, valueCount);\n-    } else if (vector instanceof NullableVarCharVector) {\n-      writeVarCharData((NullableVarCharVector) vector, valueCount);\n-    } else if (vector instanceof NullableVarBinaryVector) {\n-      writeVarBinaryData((NullableVarBinaryVector) vector, valueCount);\n-    } else if (vector instanceof NullableBigIntVector) {\n-      writeBigIntData((NullableBigIntVector) vector, valueCount);\n-    } else if (vector instanceof NullableFloat4Vector) {\n-      writeFloatData((NullableFloat4Vector) vector, valueCount);\n-    } else if (vector instanceof NullableFloat8Vector) {\n-      writeDoubleData((NullableFloat8Vector) vector, valueCount);\n-    } else if (vector instanceof NullableDateDayVector) {\n-      writeDateDayData((NullableDateDayVector) vector, valueCount);\n-    } else if (vector instanceof NullableDateMilliVector) {\n-      writeDateMilliData((NullableDateMilliVector) vector, valueCount);\n-    } else if (vector instanceof NullableIntervalDayVector) {\n-      writeIntervalDayData((NullableIntervalDayVector) vector, valueCount);\n-    } else if (vector instanceof NullableIntervalYearVector) {\n-      writeIntervalYearData((NullableIntervalYearVector) vector, valueCount);\n-    } else if (vector instanceof NullableSmallIntVector) {\n-      writeSmallIntData((NullableSmallIntVector) vector, valueCount);\n-    } else if (vector instanceof NullableTinyIntVector) {\n-      writeTinyIntData((NullableTinyIntVector) vector, valueCount);\n-    } else if (vector instanceof NullableTimeMicroVector) {\n-      writeTimeMicroData((NullableTimeMicroVector) vector, valueCount);\n-    } else if (vector instanceof NullableTimeMilliVector) {\n-      writeTimeMilliData((NullableTimeMilliVector) vector, valueCount);\n-    } else if (vector instanceof NullableTimeNanoVector) {\n-      writeTimeNanoData((NullableTimeNanoVector) vector, valueCount);\n-    } else if (vector instanceof NullableTimeSecVector) {\n-      writeTimeSecData((NullableTimeSecVector) vector, valueCount);\n-    } else if (vector instanceof NullableTimeStampSecVector) {\n-      writeTimeStampData((NullableTimeStampSecVector) vector, valueCount);\n-    } else if (vector instanceof NullableTimeStampMicroVector) {\n-      writeTimeStampData((NullableTimeStampMicroVector) vector, valueCount);\n-    } else if (vector instanceof NullableTimeStampMilliVector) {\n-      writeTimeStampData((NullableTimeStampMilliVector) vector, valueCount);\n-    } else if (vector instanceof NullableTimeStampNanoVector) {\n-      writeTimeStampData((NullableTimeStampNanoVector) vector, valueCount);\n-    } else if (vector instanceof NullableTimeStampSecTZVector) {\n-      writeTimeStampData((NullableTimeStampSecTZVector) vector, valueCount);\n-    } else if (vector instanceof NullableTimeStampMicroTZVector) {\n-      writeTimeStampData((NullableTimeStampMicroTZVector) vector, valueCount);\n-    } else if (vector instanceof NullableTimeStampMilliTZVector) {\n-      writeTimeStampData((NullableTimeStampMilliTZVector) vector, valueCount);\n-    } else if (vector instanceof NullableTimeStampNanoTZVector) {\n-      writeTimeStampData((NullableTimeStampNanoTZVector) vector, valueCount);\n+    if (vector instanceof IntVector) {\n+      writeIntData((IntVector) vector, valueCount);\n+    } else if (vector instanceof DecimalVector) {\n+      writeDecimalData((DecimalVector) vector, valueCount);\n+    } else if (vector instanceof BitVector) {\n+      writeBooleanData((BitVector) vector, valueCount);\n+    } else if (vector instanceof VarCharVector) {\n+      writeVarCharData((VarCharVector) vector, valueCount);\n+    } else if (vector instanceof VarBinaryVector) {\n+      writeVarBinaryData((VarBinaryVector) vector, valueCount);\n+    } else if (vector instanceof BigIntVector) {\n+      writeBigIntData((BigIntVector) vector, valueCount);\n+    } else if (vector instanceof Float4Vector) {\n+      writeFloatData((Float4Vector) vector, valueCount);\n+    } else if (vector instanceof Float8Vector) {\n+      writeDoubleData((Float8Vector) vector, valueCount);\n+    } else if (vector instanceof DateDayVector) {\n+      writeDateDayData((DateDayVector) vector, valueCount);\n+    } else if (vector instanceof DateMilliVector) {\n+      writeDateMilliData((DateMilliVector) vector, valueCount);\n+    } else if (vector instanceof IntervalDayVector) {\n+      writeIntervalDayData((IntervalDayVector) vector, valueCount);\n+    } else if (vector instanceof IntervalYearVector) {\n+      writeIntervalYearData((IntervalYearVector) vector, valueCount);\n+    } else if (vector instanceof SmallIntVector) {\n+      writeSmallIntData((SmallIntVector) vector, valueCount);\n+    } else if (vector instanceof TinyIntVector) {\n+      writeTinyIntData((TinyIntVector) vector, valueCount);\n+    } else if (vector instanceof TimeMicroVector) {\n+      writeTimeMicroData((TimeMicroVector) vector, valueCount);\n+    } else if (vector instanceof TimeMilliVector) {\n+      writeTimeMilliData((TimeMilliVector) vector, valueCount);\n+    } else if (vector instanceof TimeNanoVector) {\n+      writeTimeNanoData((TimeNanoVector) vector, valueCount);\n+    } else if (vector instanceof TimeSecVector) {\n+      writeTimeSecData((TimeSecVector) vector, valueCount);\n+    } else if (vector instanceof TimeStampSecVector) {\n+      writeTimeStampData((TimeStampSecVector) vector, valueCount);\n+    } else if (vector instanceof TimeStampMicroVector) {\n+      writeTimeStampData((TimeStampMicroVector) vector, valueCount);\n+    } else if (vector instanceof TimeStampMilliVector) {\n+      writeTimeStampData((TimeStampMilliVector) vector, valueCount);\n+    } else if (vector instanceof TimeStampNanoVector) {\n+      writeTimeStampData((TimeStampNanoVector) vector, valueCount);\n+    } else if (vector instanceof TimeStampSecTZVector) {\n+      writeTimeStampData((TimeStampSecTZVector) vector, valueCount);\n+    } else if (vector instanceof TimeStampMicroTZVector) {\n+      writeTimeStampData((TimeStampMicroTZVector) vector, valueCount);\n+    } else if (vector instanceof TimeStampMilliTZVector) {\n+      writeTimeStampData((TimeStampMilliTZVector) vector, valueCount);\n+    } else if (vector instanceof TimeStampNanoTZVector) {\n+      writeTimeStampData((TimeStampNanoTZVector) vector, valueCount);\n     }\n   }\n \n-  private static void writeTimeStampData(NullableTimeStampVector vector, int valueCount) {\n+  private static void writeTimeStampData(TimeStampVector vector, int valueCount) {\n     final long even = 100000;\n     final long odd = 200000;\n     for (int i = 0; i < valueCount; i++) {\n@@ -98,7 +98,7 @@ private static void writeTimeStampData(NullableTimeStampVector vector, int value\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeDecimalData(NullableDecimalVector vector, int valueCount) {\n+  private static void writeDecimalData(DecimalVector vector, int valueCount) {\n     final BigDecimal even = new BigDecimal(0.0543278923);\n     final BigDecimal odd = new BigDecimal(2.0543278923);\n     for (int i = 0; i < valueCount; i++) {\n@@ -111,7 +111,7 @@ private static void writeDecimalData(NullableDecimalVector vector, int valueCoun\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeIntData(NullableIntVector vector, int valueCount) {\n+  private static void writeIntData(IntVector vector, int valueCount) {\n     final int even = 1000;\n     final int odd = 2000;\n     for (int i = 0; i < valueCount; i++) {\n@@ -124,7 +124,7 @@ private static void writeIntData(NullableIntVector vector, int valueCount) {\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeBooleanData(NullableBitVector vector, int valueCount) {\n+  private static void writeBooleanData(BitVector vector, int valueCount) {\n     final int even = 0;\n     final int odd = 1;\n     for (int i = 0; i < valueCount; i++) {\n@@ -137,7 +137,7 @@ private static void writeBooleanData(NullableBitVector vector, int valueCount) {\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeIntervalYearData(NullableIntervalYearVector vector, int valueCount) {\n+  private static void writeIntervalYearData(IntervalYearVector vector, int valueCount) {\n     final int even = 1;\n     final int odd = 2;\n     for (int i = 0; i < valueCount; i++) {\n@@ -150,7 +150,7 @@ private static void writeIntervalYearData(NullableIntervalYearVector vector, int\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeIntervalDayData(NullableIntervalDayVector vector, int valueCount) {\n+  private static void writeIntervalDayData(IntervalDayVector vector, int valueCount) {\n     for (int i = 0; i < valueCount; i++) {\n       if (i % 2 == 0) {\n         vector.setSafe(i, 1, 50);\n@@ -161,7 +161,7 @@ private static void writeIntervalDayData(NullableIntervalDayVector vector, int v\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeTimeSecData(NullableTimeSecVector vector, int valueCount) {\n+  private static void writeTimeSecData(TimeSecVector vector, int valueCount) {\n     final int even = 500;\n     final int odd = 900;\n     for (int i = 0; i < valueCount; i++) {\n@@ -174,7 +174,7 @@ private static void writeTimeSecData(NullableTimeSecVector vector, int valueCoun\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeTimeMilliData(NullableTimeMilliVector vector, int valueCount) {\n+  private static void writeTimeMilliData(TimeMilliVector vector, int valueCount) {\n     final int even = 1000;\n     final int odd = 2000;\n     for (int i = 0; i < valueCount; i++) {\n@@ -187,7 +187,7 @@ private static void writeTimeMilliData(NullableTimeMilliVector vector, int value\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeTimeMicroData(NullableTimeMicroVector vector, int valueCount) {\n+  private static void writeTimeMicroData(TimeMicroVector vector, int valueCount) {\n     final long even = 1000000000;\n     final long odd = 2000000000;\n     for (int i = 0; i < valueCount; i++) {\n@@ -201,7 +201,7 @@ private static void writeTimeMicroData(NullableTimeMicroVector vector, int value\n \n   }\n \n-  private static void writeTimeNanoData(NullableTimeNanoVector vector, int valueCount) {\n+  private static void writeTimeNanoData(TimeNanoVector vector, int valueCount) {\n     final long even = 1000000000;\n     final long odd = 2000000000;\n     for (int i = 0; i < valueCount; i++) {\n@@ -214,7 +214,7 @@ private static void writeTimeNanoData(NullableTimeNanoVector vector, int valueCo\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeDateDayData(NullableDateDayVector vector, int valueCount) {\n+  private static void writeDateDayData(DateDayVector vector, int valueCount) {\n     final int even = 1000;\n     final int odd = 2000;\n     for (int i = 0; i < valueCount; i++) {\n@@ -227,7 +227,7 @@ private static void writeDateDayData(NullableDateDayVector vector, int valueCoun\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeDateMilliData(NullableDateMilliVector vector, int valueCount) {\n+  private static void writeDateMilliData(DateMilliVector vector, int valueCount) {\n     final long even = 1000000000;\n     final long odd = 2000000000;\n     for (int i = 0; i < valueCount; i++) {\n@@ -240,7 +240,7 @@ private static void writeDateMilliData(NullableDateMilliVector vector, int value\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeSmallIntData(NullableSmallIntVector vector, int valueCount) {\n+  private static void writeSmallIntData(SmallIntVector vector, int valueCount) {\n     final short even = 10;\n     final short odd = 20;\n     for (int i = 0; i < valueCount; i++) {\n@@ -253,7 +253,7 @@ private static void writeSmallIntData(NullableSmallIntVector vector, int valueCo\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeTinyIntData(NullableTinyIntVector vector, int valueCount) {\n+  private static void writeTinyIntData(TinyIntVector vector, int valueCount) {\n     final byte even = 1;\n     final byte odd = 2;\n     for (int i = 0; i < valueCount; i++) {\n@@ -266,7 +266,7 @@ private static void writeTinyIntData(NullableTinyIntVector vector, int valueCoun\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeBigIntData(NullableBigIntVector vector, int valueCount) {\n+  private static void writeBigIntData(BigIntVector vector, int valueCount) {\n     final long even = 1000000000;\n     final long odd = 2000000000;\n     for (int i = 0; i < valueCount; i++) {\n@@ -279,7 +279,7 @@ private static void writeBigIntData(NullableBigIntVector vector, int valueCount)\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeFloatData(NullableFloat4Vector vector, int valueCount) {\n+  private static void writeFloatData(Float4Vector vector, int valueCount) {\n     final float even = 20.3f;\n     final float odd = 40.2f;\n     for (int i = 0; i < valueCount; i++) {\n@@ -292,7 +292,7 @@ private static void writeFloatData(NullableFloat4Vector vector, int valueCount)\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeDoubleData(NullableFloat8Vector vector, int valueCount) {\n+  private static void writeDoubleData(Float8Vector vector, int valueCount) {\n     final double even = 20.2373;\n     final double odd = 40.2378;\n     for (int i = 0; i < valueCount; i++) {\n@@ -305,7 +305,7 @@ private static void writeDoubleData(NullableFloat8Vector vector, int valueCount)\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeVarBinaryData(NullableVarBinaryVector vector, int valueCount) {\n+  private static void writeVarBinaryData(VarBinaryVector vector, int valueCount) {\n     Charset utf8Charset = Charset.forName(\"UTF-8\");\n     final byte[] even = \"AAAAA1\".getBytes(utf8Charset);\n     final byte[] odd = \"BBBBBBBBB2\".getBytes(utf8Charset);\n@@ -319,7 +319,7 @@ private static void writeVarBinaryData(NullableVarBinaryVector vector, int value\n     vector.setValueCount(valueCount);\n   }\n \n-  private static void writeVarCharData(NullableVarCharVector vector, int valueCount) {\n+  private static void writeVarCharData(VarCharVector vector, int valueCount) {\n     Charset utf8Charset = Charset.forName(\"UTF-8\");\n     final byte[] even = \"AAAAA1\".getBytes(utf8Charset);\n     final byte[] odd = \"BBBBBBBBB2\".getBytes(utf8Charset);\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/IntVector.java\nsimilarity index 91%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/IntVector.java\nindex 7c6f29ad7..2364310e6 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/IntVector.java\n@@ -29,37 +29,37 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableIntVector implements a fixed width (4 bytes) vector of\n+ * IntVector implements a fixed width (4 bytes) vector of\n  * integer values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableIntVector extends BaseNullableFixedWidthVector {\n+public class IntVector extends BaseFixedWidthVector {\n   public static final byte TYPE_WIDTH = 4;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableIntVector. This doesn't allocate any memory for\n+   * Instantiate a IntVector. This doesn't allocate any memory for\n    * the data in vector.\n    *\n    * @param name      name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableIntVector(String name, BufferAllocator allocator) {\n+  public IntVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.INT.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableIntVector. This doesn't allocate any memory for\n+   * Instantiate a IntVector. This doesn't allocate any memory for\n    * the data in vector.\n    *\n    * @param name      name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public IntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new IntReaderImpl(NullableIntVector.this);\n+    reader = new IntReaderImpl(IntVector.this);\n   }\n \n   /**\n@@ -142,14 +142,14 @@ public Integer getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from      source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableIntVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, IntVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final int value = from.valueBuffer.getInt(fromIndex * TYPE_WIDTH);\n     valueBuffer.setInt(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableIntVector)} except that\n+   * Same as {@link #copyFrom(int, int, IntVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    *\n@@ -157,7 +157,7 @@ public void copyFrom(int fromIndex, int thisIndex, NullableIntVector from) {\n    * @param thisIndex position to copy to in this vector\n    * @param from      source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableIntVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, IntVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -340,22 +340,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableIntVector) to);\n+    return new TransferImpl((IntVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableIntVector to;\n+    IntVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableIntVector(ref, field.getFieldType(), allocator);\n+      to = new IntVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableIntVector to) {\n+    public TransferImpl(IntVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableIntVector getTo() {\n+    public IntVector getTo() {\n       return to;\n     }\n \n@@ -371,7 +371,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableIntVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, IntVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalDayVector.java b/java/vector/src/main/java/org/apache/arrow/vector/IntervalDayVector.java\nsimilarity index 91%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalDayVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/IntervalDayVector.java\nindex 862f6429c..481a66f4e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalDayVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/IntervalDayVector.java\n@@ -30,37 +30,37 @@\n import org.joda.time.Period;\n \n /**\n- * NullableIntervalDayVector implements a fixed width vector (8 bytes) of\n+ * IntervalDayVector implements a fixed width vector (8 bytes) of\n  * interval (days and milliseconds) values which could be null.\n  * A validity buffer (bit vector) is maintained to track which elements in the\n  * vector are null.\n  */\n-public class NullableIntervalDayVector extends BaseNullableFixedWidthVector {\n+public class IntervalDayVector extends BaseFixedWidthVector {\n   private static final byte TYPE_WIDTH = 8;\n   private static final byte MILLISECOND_OFFSET = 4;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableIntervalDayVector. This doesn't allocate any memory for\n+   * Instantiate a IntervalDayVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableIntervalDayVector(String name, BufferAllocator allocator) {\n+  public IntervalDayVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.INTERVALDAY.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableIntervalDayVector. This doesn't allocate any memory for\n+   * Instantiate a IntervalDayVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableIntervalDayVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public IntervalDayVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new IntervalDayReaderImpl(NullableIntervalDayVector.this);\n+    reader = new IntervalDayReaderImpl(IntervalDayVector.this);\n   }\n \n   /**\n@@ -185,21 +185,21 @@ private StringBuilder getAsStringBuilderHelper(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableIntervalDayVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, IntervalDayVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     from.valueBuffer.getBytes(fromIndex * TYPE_WIDTH, this.valueBuffer,\n               thisIndex * TYPE_WIDTH, TYPE_WIDTH);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableIntervalDayVector)} except that\n+   * Same as {@link #copyFrom(int, int, IntervalDayVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableIntervalDayVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, IntervalDayVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -388,22 +388,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableIntervalDayVector) to);\n+    return new TransferImpl((IntervalDayVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableIntervalDayVector to;\n+    IntervalDayVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableIntervalDayVector(ref, field.getFieldType(), allocator);\n+      to = new IntervalDayVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableIntervalDayVector to) {\n+    public TransferImpl(IntervalDayVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableIntervalDayVector getTo() {\n+    public IntervalDayVector getTo() {\n       return to;\n     }\n \n@@ -419,7 +419,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableIntervalDayVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, IntervalDayVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalYearVector.java b/java/vector/src/main/java/org/apache/arrow/vector/IntervalYearVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalYearVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/IntervalYearVector.java\nindex 3fba5bfee..2aa728f3d 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableIntervalYearVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/IntervalYearVector.java\n@@ -29,35 +29,35 @@\n import org.joda.time.Period;\n \n /**\n- * NullableIntervalYearVector implements a fixed width (4 bytes) vector of\n+ * IntervalYearVector implements a fixed width (4 bytes) vector of\n  * interval (years and months) values which could be null. A validity buffer\n  * (bit vector) is maintained to track which elements in the vector are null.\n  */\n-public class NullableIntervalYearVector extends BaseNullableFixedWidthVector {\n+public class IntervalYearVector extends BaseFixedWidthVector {\n   private static final byte TYPE_WIDTH = 4;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableIntervalYearVector. This doesn't allocate any memory for\n+   * Instantiate a IntervalYearVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableIntervalYearVector(String name, BufferAllocator allocator) {\n+  public IntervalYearVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.INTERVALYEAR.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableIntervalYearVector. This doesn't allocate any memory for\n+   * Instantiate a IntervalYearVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableIntervalYearVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public IntervalYearVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new IntervalYearReaderImpl(NullableIntervalYearVector.this);\n+    reader = new IntervalYearReaderImpl(IntervalYearVector.this);\n   }\n \n   /**\n@@ -169,21 +169,21 @@ private StringBuilder getAsStringBuilderHelper(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableIntervalYearVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, IntervalYearVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final int value = from.valueBuffer.getInt(fromIndex * TYPE_WIDTH);\n     valueBuffer.setInt(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableIntervalYearVector)} except that\n+   * Same as {@link #copyFrom(int, int, IntervalYearVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableIntervalYearVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, IntervalYearVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -348,22 +348,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableIntervalYearVector) to);\n+    return new TransferImpl((IntervalYearVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableIntervalYearVector to;\n+    IntervalYearVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableIntervalYearVector(ref, field.getFieldType(), allocator);\n+      to = new IntervalYearVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableIntervalYearVector to) {\n+    public TransferImpl(IntervalYearVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableIntervalYearVector getTo() {\n+    public IntervalYearVector getTo() {\n       return to;\n     }\n \n@@ -379,7 +379,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableIntervalYearVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, IntervalYearVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\ndeleted file mode 100644\nindex 086331e13..000000000\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableBitVector.java\n+++ /dev/null\n@@ -1,513 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- * <p>\n- * http://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.arrow.vector;\n-\n-import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.complex.impl.BitReaderImpl;\n-import org.apache.arrow.vector.complex.reader.FieldReader;\n-import org.apache.arrow.vector.holders.BitHolder;\n-import org.apache.arrow.vector.holders.NullableBitHolder;\n-import org.apache.arrow.vector.types.Types;\n-import org.apache.arrow.vector.types.pojo.FieldType;\n-import org.apache.arrow.vector.util.OversizedAllocationException;\n-import org.apache.arrow.vector.util.TransferPair;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * NullableBitVector implements a fixed width (1 bit) vector of\n- * boolean values which could be null. Each value in the vector corresponds\n- * to a single bit in the underlying data stream backing the vector.\n- */\n-public class NullableBitVector extends BaseNullableFixedWidthVector {\n-  private final FieldReader reader;\n-\n-  /**\n-   * Instantiate a NullableBitVector. This doesn't allocate any memory for\n-   * the data in vector.\n-   *\n-   * @param name      name of the vector\n-   * @param allocator allocator for memory management.\n-   */\n-  public NullableBitVector(String name, BufferAllocator allocator) {\n-    this(name, FieldType.nullable(Types.MinorType.BIT.getType()),\n-            allocator);\n-  }\n-\n-  /**\n-   * Instantiate a NullableBitVector. This doesn't allocate any memory for\n-   * the data in vector.\n-   *\n-   * @param name      name of the vector\n-   * @param fieldType type of Field materialized by this vector\n-   * @param allocator allocator for memory management.\n-   */\n-  public NullableBitVector(String name, FieldType fieldType, BufferAllocator allocator) {\n-    super(name, allocator, fieldType, (byte) 0);\n-    reader = new BitReaderImpl(NullableBitVector.this);\n-  }\n-\n-  /**\n-   * Get a reader that supports reading values from this vector\n-   *\n-   * @return Field Reader for this vector\n-   */\n-  @Override\n-  public FieldReader getReader() {\n-    return reader;\n-  }\n-\n-  /**\n-   * Get minor type for this vector. The vector holds values belonging\n-   * to a particular type.\n-   *\n-   * @return {@link org.apache.arrow.vector.types.Types.MinorType}\n-   */\n-  @Override\n-  public Types.MinorType getMinorType() {\n-    return Types.MinorType.BIT;\n-  }\n-\n-  /**\n-   * Sets the desired value capacity for the vector. This function doesn't\n-   * allocate any memory for the vector.\n-   *\n-   * @param valueCount desired number of elements in the vector\n-   */\n-  @Override\n-  public void setInitialCapacity(int valueCount) {\n-    final int size = getValidityBufferSizeFromCount(valueCount);\n-    if (size > MAX_ALLOCATION_SIZE) {\n-      throw new OversizedAllocationException(\"Requested amount of memory is more than max allowed\");\n-    }\n-    valueAllocationSizeInBytes = size;\n-    validityAllocationSizeInBytes = size;\n-  }\n-\n-  /**\n-   * Get the current value capacity for the vector\n-   *\n-   * @return number of elements that vector can hold.\n-   */\n-  @Override\n-  public int getValueCapacity() {\n-    return (int) (validityBuffer.capacity() * 8L);\n-  }\n-\n-  /**\n-   * Get the potential buffer size for a particular number of records.\n-   *\n-   * @param count desired number of elements in the vector\n-   * @return estimated size of underlying buffers if the vector holds\n-   * a given number of elements\n-   */\n-  @Override\n-  public int getBufferSizeFor(final int count) {\n-    if (count == 0) {\n-      return 0;\n-    }\n-    return 2 * getValidityBufferSizeFromCount(count);\n-  }\n-\n-  /**\n-   * Get the size (number of bytes) of underlying buffers used by this\n-   * vector\n-   *\n-   * @return size of underlying buffers.\n-   */\n-  @Override\n-  public int getBufferSize() {\n-    return getBufferSizeFor(valueCount);\n-  }\n-\n-  /**\n-   * Slice this vector at desired index and length and transfer the\n-   * corresponding data to the target vector.\n-   *\n-   * @param startIndex start position of the split in source vector.\n-   * @param length     length of the split.\n-   * @param target     destination vector\n-   */\n-  public void splitAndTransferTo(int startIndex, int length,\n-                                 BaseNullableFixedWidthVector target) {\n-    compareTypes(target, \"splitAndTransferTo\");\n-    target.clear();\n-    target.validityBuffer = splitAndTransferBuffer(startIndex, length, target,\n-            validityBuffer, target.validityBuffer);\n-    target.valueBuffer = splitAndTransferBuffer(startIndex, length, target,\n-            valueBuffer, target.valueBuffer);\n-\n-    target.setValueCount(length);\n-  }\n-\n-  private ArrowBuf splitAndTransferBuffer(int startIndex, int length,\n-                                          BaseNullableFixedWidthVector target,\n-                                          ArrowBuf sourceBuffer, ArrowBuf destBuffer) {\n-    assert startIndex + length <= valueCount;\n-    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n-    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n-    int byteSizeTarget = getValidityBufferSizeFromCount(length);\n-    int offset = startIndex % 8;\n-\n-    if (length > 0) {\n-      if (offset == 0) {\n-            /* slice */\n-        if (destBuffer != null) {\n-          destBuffer.release();\n-        }\n-        destBuffer = sourceBuffer.slice(firstByteSource, byteSizeTarget);\n-        destBuffer.retain(1);\n-      } else {\n-            /* Copy data\n-             * When the first bit starts from the middle of a byte (offset != 0),\n-             * copy data from src BitVector.\n-             * Each byte in the target is composed by a part in i-th byte,\n-             * another part in (i+1)-th byte.\n-             */\n-        destBuffer = allocator.buffer(byteSizeTarget);\n-        destBuffer.readerIndex(0);\n-        destBuffer.setZero(0, destBuffer.capacity());\n-\n-        for (int i = 0; i < byteSizeTarget - 1; i++) {\n-          byte b1 = BitVectorHelper.getBitsFromCurrentByte(sourceBuffer, firstByteSource + i, offset);\n-          byte b2 = BitVectorHelper.getBitsFromNextByte(sourceBuffer, firstByteSource + i + 1, offset);\n-\n-          destBuffer.setByte(i, (b1 + b2));\n-        }\n-\n-            /* Copying the last piece is done in the following manner:\n-             * if the source vector has 1 or more bytes remaining, we copy\n-             * the last piece as a byte formed by shifting data\n-             * from the current byte and the next byte.\n-             *\n-             * if the source vector has no more bytes remaining\n-             * (we are at the last byte), we copy the last piece as a byte\n-             * by shifting data from the current byte.\n-             */\n-        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n-          byte b1 = BitVectorHelper.getBitsFromCurrentByte(sourceBuffer,\n-                  firstByteSource + byteSizeTarget - 1, offset);\n-          byte b2 = BitVectorHelper.getBitsFromNextByte(sourceBuffer,\n-                  firstByteSource + byteSizeTarget, offset);\n-\n-          destBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n-        } else {\n-          byte b1 = BitVectorHelper.getBitsFromCurrentByte(sourceBuffer,\n-                  firstByteSource + byteSizeTarget - 1, offset);\n-          destBuffer.setByte(byteSizeTarget - 1, b1);\n-        }\n-      }\n-    }\n-\n-    return destBuffer;\n-  }\n-\n-\n-  /******************************************************************\n-   *                                                                *\n-   *          vector value retrieval methods                        *\n-   *                                                                *\n-   ******************************************************************/\n-\n-  private int getBit(int index) {\n-    final int byteIndex = index >> 3;\n-    final byte b = valueBuffer.getByte(byteIndex);\n-    final int bitIndex = index & 7;\n-    return Long.bitCount(b & (1L << bitIndex));\n-  }\n-\n-  /**\n-   * Get the element at the given index from the vector.\n-   *\n-   * @param index position of element\n-   * @return element at given index\n-   */\n-  public int get(int index) throws IllegalStateException {\n-    if (isSet(index) == 0) {\n-      throw new IllegalStateException(\"Value at index is null\");\n-    }\n-    return getBit(index);\n-  }\n-\n-  /**\n-   * Get the element at the given index from the vector and\n-   * sets the state in holder. If element at given index\n-   * is null, holder.isSet will be zero.\n-   *\n-   * @param index position of element\n-   */\n-  public void get(int index, NullableBitHolder holder) {\n-    if (isSet(index) == 0) {\n-      holder.isSet = 0;\n-      return;\n-    }\n-    holder.isSet = 1;\n-    holder.value = getBit(index);\n-  }\n-\n-  /**\n-   * Same as {@link #get(int)}.\n-   *\n-   * @param index position of element\n-   * @return element at given index\n-   */\n-  public Boolean getObject(int index) {\n-    if (isSet(index) == 0) {\n-      return null;\n-    } else {\n-      return new Boolean(getBit(index) != 0);\n-    }\n-  }\n-\n-  /**\n-   * Copy a cell value from a particular index in source vector to a particular\n-   * position in this vector\n-   *\n-   * @param fromIndex position to copy from in source vector\n-   * @param thisIndex position to copy to in this vector\n-   * @param from      source vector\n-   */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableBitVector from) {\n-    BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n-    BitVectorHelper.setValidityBit(valueBuffer, thisIndex, from.getBit(fromIndex));\n-  }\n-\n-  /**\n-   * Same as {@link #copyFrom(int, int, NullableBitVector)} except that\n-   * it handles the case when the capacity of the vector needs to be expanded\n-   * before copy.\n-   *\n-   * @param fromIndex position to copy from in source vector\n-   * @param thisIndex position to copy to in this vector\n-   * @param from      source vector\n-   */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableBitVector from) {\n-    handleSafe(thisIndex);\n-    copyFrom(fromIndex, thisIndex, from);\n-  }\n-\n-\n-  /******************************************************************\n-   *                                                                *\n-   *          vector value setter methods                           *\n-   *                                                                *\n-   ******************************************************************/\n-\n-\n-  /**\n-   * Set the element at the given index to the given value.\n-   *\n-   * @param index position of element\n-   * @param value value of element\n-   */\n-  public void set(int index, int value) {\n-    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n-    if (value != 0) {\n-      BitVectorHelper.setValidityBitToOne(valueBuffer, index);\n-    } else {\n-      BitVectorHelper.setValidityBit(valueBuffer, index, 0);\n-    }\n-  }\n-\n-  /**\n-   * Set the element at the given index to the value set in data holder.\n-   * If the value in holder is not indicated as set, element in the\n-   * at the given index will be null.\n-   *\n-   * @param index  position of element\n-   * @param holder nullable data holder for value of element\n-   */\n-  public void set(int index, NullableBitHolder holder) throws IllegalArgumentException {\n-    if (holder.isSet < 0) {\n-      throw new IllegalArgumentException();\n-    } else if (holder.isSet > 0) {\n-      BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n-      if (holder.value != 0) {\n-        BitVectorHelper.setValidityBitToOne(valueBuffer, index);\n-      } else {\n-        BitVectorHelper.setValidityBit(valueBuffer, index, 0);\n-      }\n-    } else {\n-      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n-    }\n-  }\n-\n-  /**\n-   * Set the element at the given index to the value set in data holder.\n-   *\n-   * @param index  position of element\n-   * @param holder data holder for value of element\n-   */\n-  public void set(int index, BitHolder holder) {\n-    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n-    if (holder.value != 0) {\n-      BitVectorHelper.setValidityBitToOne(valueBuffer, index);\n-    } else {\n-      BitVectorHelper.setValidityBit(valueBuffer, index, 0);\n-    }\n-  }\n-\n-  /**\n-   * Same as {@link #set(int, int)} except that it handles the\n-   * case when index is greater than or equal to existing\n-   * value capacity {@link #getValueCapacity()}.\n-   *\n-   * @param index position of element\n-   * @param value value of element\n-   */\n-  public void setSafe(int index, int value) {\n-    handleSafe(index);\n-    set(index, value);\n-  }\n-\n-  /**\n-   * Same as {@link #set(int, NullableBitHolder)} except that it handles the\n-   * case when index is greater than or equal to existing\n-   * value capacity {@link #getValueCapacity()}.\n-   *\n-   * @param index  position of element\n-   * @param holder nullable data holder for value of element\n-   */\n-  public void setSafe(int index, NullableBitHolder holder) throws IllegalArgumentException {\n-    handleSafe(index);\n-    set(index, holder);\n-  }\n-\n-  /**\n-   * Same as {@link #set(int, BitHolder)} except that it handles the\n-   * case when index is greater than or equal to existing\n-   * value capacity {@link #getValueCapacity()}.\n-   *\n-   * @param index  position of element\n-   * @param holder data holder for value of element\n-   */\n-  public void setSafe(int index, BitHolder holder) {\n-    handleSafe(index);\n-    set(index, holder);\n-  }\n-\n-  /**\n-   * Set the element at the given index to null.\n-   *\n-   * @param index position of element\n-   */\n-  public void setNull(int index) {\n-    handleSafe(index);\n-      /* not really needed to set the bit to 0 as long as\n-       * the buffer always starts from 0.\n-       */\n-    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n-  }\n-\n-  /**\n-   * Store the given value at a particular position in the vector. isSet indicates\n-   * whether the value is NULL or not.\n-   *\n-   * @param index position of the new value\n-   * @param isSet 0 for NULL value, 1 otherwise\n-   * @param value element value\n-   */\n-  public void set(int index, int isSet, int value) {\n-    if (isSet > 0) {\n-      set(index, value);\n-    } else {\n-      BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n-    }\n-  }\n-\n-  /**\n-   * Same as {@link #set(int, int, int)} except that it handles the case\n-   * when index is greater than or equal to current value capacity of the\n-   * vector.\n-   *\n-   * @param index position of the new value\n-   * @param isSet 0 for NULL value, 1 otherwise\n-   * @param value element value\n-   */\n-  public void setSafe(int index, int isSet, int value) {\n-    handleSafe(index);\n-    set(index, isSet, value);\n-  }\n-\n-\n-  /******************************************************************\n-   *                                                                *\n-   *                      vector transfer                           *\n-   *                                                                *\n-   ******************************************************************/\n-\n-\n-  /**\n-   * Construct a TransferPair comprising of this and and a target vector of\n-   * the same type.\n-   *\n-   * @param ref       name of the target vector\n-   * @param allocator allocator for the target vector\n-   * @return {@link TransferPair}\n-   */\n-  @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    return new TransferImpl(ref, allocator);\n-  }\n-\n-  /**\n-   * Construct a TransferPair with a desired target vector of the same type.\n-   *\n-   * @param to target vector\n-   * @return {@link TransferPair}\n-   */\n-  @Override\n-  public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableBitVector) to);\n-  }\n-\n-  private class TransferImpl implements TransferPair {\n-    NullableBitVector to;\n-\n-    public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableBitVector(ref, field.getFieldType(), allocator);\n-    }\n-\n-    public TransferImpl(NullableBitVector to) {\n-      this.to = to;\n-    }\n-\n-    @Override\n-    public NullableBitVector getTo() {\n-      return to;\n-    }\n-\n-    @Override\n-    public void transfer() {\n-      transferTo(to);\n-    }\n-\n-    @Override\n-    public void splitAndTransfer(int startIndex, int length) {\n-      splitAndTransferTo(startIndex, length, to);\n-    }\n-\n-    @Override\n-    public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableBitVector.this);\n-    }\n-  }\n-}\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableVector.java b/java/vector/src/main/java/org/apache/arrow/vector/NullableVector.java\ndeleted file mode 100644\nindex b2455e9e4..000000000\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableVector.java\n+++ /dev/null\n@@ -1,26 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.arrow.vector;\n-\n-public interface NullableVector extends ValueVector {\n-\n-  BitVector getValidityVector();\n-\n-  ValueVector getValuesVector();\n-}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableSmallIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/SmallIntVector.java\nsimilarity index 91%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableSmallIntVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/SmallIntVector.java\nindex d5c66b115..859e62dbb 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableSmallIntVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/SmallIntVector.java\n@@ -29,35 +29,35 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableSmallIntVector implements a fixed width (2 bytes) vector of\n+ * SmallIntVector implements a fixed width (2 bytes) vector of\n  * short values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableSmallIntVector extends BaseNullableFixedWidthVector {\n+public class SmallIntVector extends BaseFixedWidthVector {\n   public static final byte TYPE_WIDTH = 2;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableSmallIntVector. This doesn't allocate any memory for\n+   * Instantiate a SmallIntVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableSmallIntVector(String name, BufferAllocator allocator) {\n+  public SmallIntVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.SMALLINT.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableSmallIntVector. This doesn't allocate any memory for\n+   * Instantiate a SmallIntVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableSmallIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public SmallIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new SmallIntReaderImpl(NullableSmallIntVector.this);\n+    reader = new SmallIntReaderImpl(SmallIntVector.this);\n   }\n \n   /**\n@@ -137,21 +137,21 @@ public Short getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableSmallIntVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, SmallIntVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final short value = from.valueBuffer.getShort(fromIndex * TYPE_WIDTH);\n     valueBuffer.setShort(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableSmallIntVector)} except that\n+   * Same as {@link #copyFrom(int, int, SmallIntVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableSmallIntVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, SmallIntVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -357,22 +357,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableSmallIntVector) to);\n+    return new TransferImpl((SmallIntVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableSmallIntVector to;\n+    SmallIntVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableSmallIntVector(ref, field.getFieldType(), allocator);\n+      to = new SmallIntVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableSmallIntVector to) {\n+    public TransferImpl(SmallIntVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableSmallIntVector getTo() {\n+    public SmallIntVector getTo() {\n       return to;\n     }\n \n@@ -388,7 +388,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableSmallIntVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, SmallIntVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMicroVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeMicroVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMicroVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeMicroVector.java\nindex ca8e1aacf..604cedffd 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMicroVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeMicroVector.java\n@@ -30,36 +30,36 @@\n import org.slf4j.Logger;\n \n /**\n- * NullableTimeMicroVector implements a fixed width vector (8 bytes) of\n+ * TimeMicroVector implements a fixed width vector (8 bytes) of\n  * time (microsecond resolution) values which could be null.\n  * A validity buffer (bit vector) is maintained to track which elements in the\n  * vector are null.\n  */\n-public class NullableTimeMicroVector extends BaseNullableFixedWidthVector {\n+public class TimeMicroVector extends BaseFixedWidthVector {\n   private static final byte TYPE_WIDTH = 8;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableTimeMicroVector. This doesn't allocate any memory for\n+   * Instantiate a TimeMicroVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeMicroVector(String name, BufferAllocator allocator) {\n+  public TimeMicroVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.TIMEMICRO.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTimeMicroVector. This doesn't allocate any memory for\n+   * Instantiate a TimeMicroVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeMicroVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeMicroVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new TimeMicroReaderImpl(NullableTimeMicroVector.this);\n+    reader = new TimeMicroReaderImpl(TimeMicroVector.this);\n   }\n \n   /**\n@@ -138,21 +138,21 @@ public Long getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableTimeMicroVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, TimeMicroVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final long value = from.valueBuffer.getLong(fromIndex * TYPE_WIDTH);\n     valueBuffer.setLong(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableTimeMicroVector)} except that\n+   * Same as {@link #copyFrom(int, int, TimeMicroVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeMicroVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, TimeMicroVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -331,22 +331,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTimeMicroVector) to);\n+    return new TransferImpl((TimeMicroVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableTimeMicroVector to;\n+    TimeMicroVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableTimeMicroVector(ref, field.getFieldType(), allocator);\n+      to = new TimeMicroVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableTimeMicroVector to) {\n+    public TransferImpl(TimeMicroVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableTimeMicroVector getTo() {\n+    public TimeMicroVector getTo() {\n       return to;\n     }\n \n@@ -362,7 +362,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableTimeMicroVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, TimeMicroVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMilliVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeMilliVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMilliVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeMilliVector.java\nindex a28ccfe00..c3d100c5b 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeMilliVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeMilliVector.java\n@@ -31,35 +31,35 @@\n import org.slf4j.Logger;\n \n /**\n- * NullableTimeMilliVector implements a fixed width (4 bytes) vector of\n+ * TimeMilliVector implements a fixed width (4 bytes) vector of\n  * time (millisecond resolution) values which could be null. A validity buffer\n  * (bit vector) is maintained to track which elements in the vector are null.\n  */\n-public class NullableTimeMilliVector extends BaseNullableFixedWidthVector {\n+public class TimeMilliVector extends BaseFixedWidthVector {\n   private static final byte TYPE_WIDTH = 4;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableTimeMilliVector. This doesn't allocate any memory for\n+   * Instantiate a TimeMilliVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeMilliVector(String name, BufferAllocator allocator) {\n+  public TimeMilliVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.TIMEMILLI.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTimeMilliVector. This doesn't allocate any memory for\n+   * Instantiate a TimeMilliVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeMilliVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeMilliVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new TimeMilliReaderImpl(NullableTimeMilliVector.this);\n+    reader = new TimeMilliReaderImpl(TimeMilliVector.this);\n   }\n \n   /**\n@@ -139,21 +139,21 @@ public LocalDateTime getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableTimeMilliVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, TimeMilliVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final int value = from.valueBuffer.getInt(fromIndex * TYPE_WIDTH);\n     valueBuffer.setInt(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableTimeMilliVector)} except that\n+   * Same as {@link #copyFrom(int, int, TimeMilliVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeMilliVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, TimeMilliVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -332,22 +332,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTimeMilliVector) to);\n+    return new TransferImpl((TimeMilliVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableTimeMilliVector to;\n+    TimeMilliVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableTimeMilliVector(ref, field.getFieldType(), allocator);\n+      to = new TimeMilliVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableTimeMilliVector to) {\n+    public TransferImpl(TimeMilliVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableTimeMilliVector getTo() {\n+    public TimeMilliVector getTo() {\n       return to;\n     }\n \n@@ -363,7 +363,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableTimeMilliVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, TimeMilliVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeNanoVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeNanoVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeNanoVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeNanoVector.java\nindex e6903c011..97401ec8a 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeNanoVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeNanoVector.java\n@@ -29,35 +29,35 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableTimeNanoVector implements a fixed width vector (8 bytes) of\n+ * TimeNanoVector implements a fixed width vector (8 bytes) of\n  * time (nanosecond resolution) values which could be null. A validity buffer\n  * (bit vector) is maintained to track which elements in the vector are null.\n  */\n-public class NullableTimeNanoVector extends BaseNullableFixedWidthVector {\n+public class TimeNanoVector extends BaseFixedWidthVector {\n   private static final byte TYPE_WIDTH = 8;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableTimeNanoVector. This doesn't allocate any memory for\n+   * Instantiate a TimeNanoVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeNanoVector(String name, BufferAllocator allocator) {\n+  public TimeNanoVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.TIMENANO.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTimeNanoVector. This doesn't allocate any memory for\n+   * Instantiate a TimeNanoVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeNanoVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeNanoVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new TimeNanoReaderImpl(NullableTimeNanoVector.this);\n+    reader = new TimeNanoReaderImpl(TimeNanoVector.this);\n   }\n \n   /**\n@@ -137,21 +137,21 @@ public Long getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableTimeNanoVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, TimeNanoVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final long value = from.valueBuffer.getLong(fromIndex * TYPE_WIDTH);\n     valueBuffer.setLong(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableTimeNanoVector)} except that\n+   * Same as {@link #copyFrom(int, int, TimeNanoVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeNanoVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, TimeNanoVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -329,22 +329,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTimeNanoVector) to);\n+    return new TransferImpl((TimeNanoVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableTimeNanoVector to;\n+    TimeNanoVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableTimeNanoVector(ref, field.getFieldType(), allocator);\n+      to = new TimeNanoVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableTimeNanoVector to) {\n+    public TransferImpl(TimeNanoVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableTimeNanoVector getTo() {\n+    public TimeNanoVector getTo() {\n       return to;\n     }\n \n@@ -360,7 +360,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableTimeNanoVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, TimeNanoVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeSecVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeSecVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeSecVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeSecVector.java\nindex 85426a369..a7823a916 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeSecVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeSecVector.java\n@@ -29,35 +29,35 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableTimeSecVector implements a fixed width (4 bytes) vector of\n+ * TimeSecVector implements a fixed width (4 bytes) vector of\n  * time (seconds resolution) values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableTimeSecVector extends BaseNullableFixedWidthVector {\n+public class TimeSecVector extends BaseFixedWidthVector {\n   private static final byte TYPE_WIDTH = 4;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableTimeSecVector. This doesn't allocate any memory for\n+   * Instantiate a TimeSecVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeSecVector(String name, BufferAllocator allocator) {\n+  public TimeSecVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.TIMESEC.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTimeSecVector. This doesn't allocate any memory for\n+   * Instantiate a TimeSecVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeSecVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeSecVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new TimeSecReaderImpl(NullableTimeSecVector.this);\n+    reader = new TimeSecReaderImpl(TimeSecVector.this);\n   }\n \n   /**\n@@ -137,21 +137,21 @@ public Integer getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableTimeSecVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, TimeSecVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final int value = from.valueBuffer.getInt(fromIndex * TYPE_WIDTH);\n     valueBuffer.setInt(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableTimeSecVector)} except that\n+   * Same as {@link #copyFrom(int, int, TimeSecVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeSecVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, TimeSecVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -330,22 +330,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTimeSecVector) to);\n+    return new TransferImpl((TimeSecVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableTimeSecVector to;\n+    TimeSecVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableTimeSecVector(ref, field.getFieldType(), allocator);\n+      to = new TimeSecVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableTimeSecVector to) {\n+    public TransferImpl(TimeSecVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableTimeSecVector getTo() {\n+    public TimeSecVector getTo() {\n       return to;\n     }\n \n@@ -361,7 +361,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableTimeSecVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, TimeSecVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroTZVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroTZVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroTZVector.java\nindex c7ad14154..bfe330a1e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroTZVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroTZVector.java\n@@ -29,37 +29,37 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableTimeStampMicroTZVector implements a fixed width vector (8 bytes) of\n+ * TimeStampMicroTZVector implements a fixed width vector (8 bytes) of\n  * timestamp (microsecond resolution) values which could be null. A validity buffer\n  * (bit vector) is maintained to track which elements in the vector are null.\n  */\n-public class NullableTimeStampMicroTZVector extends NullableTimeStampVector {\n+public class TimeStampMicroTZVector extends TimeStampVector {\n   private final FieldReader reader;\n   private final String timeZone;\n \n   /**\n-   * Instantiate a NullableTimeStampMicroTZVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampMicroTZVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampMicroTZVector(String name, BufferAllocator allocator, String timeZone) {\n+  public TimeStampMicroTZVector(String name, BufferAllocator allocator, String timeZone) {\n     this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Timestamp(TimeUnit.MICROSECOND, timeZone)),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTimeStampMicroTZVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampMicroTZVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampMicroTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeStampMicroTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, fieldType, allocator);\n     org.apache.arrow.vector.types.pojo.ArrowType.Timestamp arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Timestamp) fieldType.getType();\n     timeZone = arrowType.getTimezone();\n-    reader = new TimeStampMicroTZReaderImpl(NullableTimeStampMicroTZVector.this);\n+    reader = new TimeStampMicroTZReaderImpl(TimeStampMicroTZVector.this);\n   }\n \n   /**\n@@ -200,7 +200,7 @@ public void setSafe(int index, TimeStampMicroTZHolder holder) {\n    */\n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    NullableTimeStampMicroTZVector to = new NullableTimeStampMicroTZVector(ref,\n+    TimeStampMicroTZVector to = new TimeStampMicroTZVector(ref,\n             field.getFieldType(), allocator);\n     return new TransferImpl(to);\n   }\n@@ -212,6 +212,6 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTimeStampMicroTZVector) to);\n+    return new TransferImpl((TimeStampMicroTZVector) to);\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroVector.java\nindex 5a34b194c..85b615d8f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMicroVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMicroVector.java\n@@ -29,34 +29,34 @@\n import org.joda.time.LocalDateTime;\n \n /**\n- * NullableTimeStampMicroVector implements a fixed width vector (8 bytes) of\n+ * TimeStampMicroVector implements a fixed width vector (8 bytes) of\n  * timestamp (microsecond resolution) values which could be null. A validity buffer\n  * (bit vector) is maintained to track which elements in the vector are null.\n  */\n-public class NullableTimeStampMicroVector extends NullableTimeStampVector {\n+public class TimeStampMicroVector extends TimeStampVector {\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableTimeStampMicroVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampMicroVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampMicroVector(String name, BufferAllocator allocator) {\n+  public TimeStampMicroVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.TIMESTAMPMICRO.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTimeStampMicroVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampMicroVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampMicroVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeStampMicroVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, fieldType, allocator);\n-    reader = new TimeStampMicroReaderImpl(NullableTimeStampMicroVector.this);\n+    reader = new TimeStampMicroReaderImpl(TimeStampMicroVector.this);\n   }\n \n   /**\n@@ -202,7 +202,7 @@ public void setSafe(int index, TimeStampMicroHolder holder) {\n    */\n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    NullableTimeStampMicroVector to = new NullableTimeStampMicroVector(ref,\n+    TimeStampMicroVector to = new TimeStampMicroVector(ref,\n             field.getFieldType(), allocator);\n     return new TransferImpl(to);\n   }\n@@ -214,6 +214,6 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTimeStampMicroVector) to);\n+    return new TransferImpl((TimeStampMicroVector) to);\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliTZVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliTZVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliTZVector.java\nindex f9736aed7..9d68b5644 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliTZVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliTZVector.java\n@@ -29,37 +29,37 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableTimeStampMilliTZVector implements a fixed width vector (8 bytes) of\n+ * TimeStampMilliTZVector implements a fixed width vector (8 bytes) of\n  * timestamp (millisecond resolution) values which could be null. A validity buffer\n  * (bit vector) is maintained to track which elements in the vector are null.\n  */\n-public class NullableTimeStampMilliTZVector extends NullableTimeStampVector {\n+public class TimeStampMilliTZVector extends TimeStampVector {\n   private final FieldReader reader;\n   private final String timeZone;\n \n   /**\n-   * Instantiate a NullableTimeStampMilliTZVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampMilliTZVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampMilliTZVector(String name, BufferAllocator allocator, String timeZone) {\n+  public TimeStampMilliTZVector(String name, BufferAllocator allocator, String timeZone) {\n     this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Timestamp(TimeUnit.MILLISECOND, timeZone)),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTimeStampMilliTZVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampMilliTZVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampMilliTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeStampMilliTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, fieldType, allocator);\n     org.apache.arrow.vector.types.pojo.ArrowType.Timestamp arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Timestamp) fieldType.getType();\n     timeZone = arrowType.getTimezone();\n-    reader = new TimeStampMilliTZReaderImpl(NullableTimeStampMilliTZVector.this);\n+    reader = new TimeStampMilliTZReaderImpl(TimeStampMilliTZVector.this);\n   }\n \n   /**\n@@ -199,7 +199,7 @@ public void setSafe(int index, TimeStampMilliTZHolder holder) {\n    */\n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    NullableTimeStampMilliTZVector to = new NullableTimeStampMilliTZVector(ref,\n+    TimeStampMilliTZVector to = new TimeStampMilliTZVector(ref,\n             field.getFieldType(), allocator);\n     return new TransferImpl(to);\n   }\n@@ -211,6 +211,6 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTimeStampMilliTZVector) to);\n+    return new TransferImpl((TimeStampMilliTZVector) to);\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliVector.java\nindex fc38a6bd5..7e8a1d0e2 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampMilliVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampMilliVector.java\n@@ -29,34 +29,34 @@\n import org.joda.time.LocalDateTime;\n \n /**\n- * NullableTimeStampMilliVector implements a fixed width vector (8 bytes) of\n+ * TimeStampMilliVector implements a fixed width vector (8 bytes) of\n  * timestamp (millisecond resolution) values which could be null. A validity buffer\n  * (bit vector) is maintained to track which elements in the vector are null.\n  */\n-public class NullableTimeStampMilliVector extends NullableTimeStampVector {\n+public class TimeStampMilliVector extends TimeStampVector {\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableTimeStampMilliVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampMilliVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampMilliVector(String name, BufferAllocator allocator) {\n+  public TimeStampMilliVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.TIMESTAMPMILLI.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTimeStampMilliVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampMilliVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampMilliVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeStampMilliVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, fieldType, allocator);\n-    reader = new TimeStampMilliReaderImpl(NullableTimeStampMilliVector.this);\n+    reader = new TimeStampMilliReaderImpl(TimeStampMilliVector.this);\n   }\n \n   /**\n@@ -200,7 +200,7 @@ public void setSafe(int index, TimeStampMilliHolder holder) {\n    */\n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    NullableTimeStampMilliVector to = new NullableTimeStampMilliVector(ref,\n+    TimeStampMilliVector to = new TimeStampMilliVector(ref,\n             field.getFieldType(), allocator);\n     return new TransferImpl(to);\n   }\n@@ -212,6 +212,6 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTimeStampMilliVector) to);\n+    return new TransferImpl((TimeStampMilliVector) to);\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoTZVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoTZVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoTZVector.java\nindex 8eb48462c..e03618201 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoTZVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoTZVector.java\n@@ -29,37 +29,37 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableTimeStampNanoTZVector implements a fixed width vector (8 bytes) of\n+ * TimeStampNanoTZVector implements a fixed width vector (8 bytes) of\n  * timestamp (nanosecond resolution) values which could be null. A validity buffer\n  * (bit vector) is maintained to track which elements in the vector are null.\n  */\n-public class NullableTimeStampNanoTZVector extends NullableTimeStampVector {\n+public class TimeStampNanoTZVector extends TimeStampVector {\n   private final FieldReader reader;\n   private final String timeZone;\n \n   /**\n-   * Instantiate a NullableTimeStampNanoTZVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampNanoTZVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampNanoTZVector(String name, BufferAllocator allocator, String timeZone) {\n+  public TimeStampNanoTZVector(String name, BufferAllocator allocator, String timeZone) {\n     this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Timestamp(TimeUnit.NANOSECOND, timeZone)),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTimeStampNanoTZVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampNanoTZVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampNanoTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeStampNanoTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, fieldType, allocator);\n     org.apache.arrow.vector.types.pojo.ArrowType.Timestamp arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Timestamp) fieldType.getType();\n     timeZone = arrowType.getTimezone();\n-    reader = new TimeStampNanoTZReaderImpl(NullableTimeStampNanoTZVector.this);\n+    reader = new TimeStampNanoTZReaderImpl(TimeStampNanoTZVector.this);\n   }\n \n   /**\n@@ -200,7 +200,7 @@ public void setSafe(int index, TimeStampNanoTZHolder holder) {\n    */\n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    NullableTimeStampNanoTZVector to = new NullableTimeStampNanoTZVector(ref,\n+    TimeStampNanoTZVector to = new TimeStampNanoTZVector(ref,\n             field.getFieldType(), allocator);\n     return new TransferImpl(to);\n   }\n@@ -212,6 +212,6 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTimeStampNanoTZVector) to);\n+    return new TransferImpl((TimeStampNanoTZVector) to);\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoVector.java\nindex 6cc5c9057..fdf5d2694 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampNanoVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampNanoVector.java\n@@ -29,34 +29,34 @@\n import org.joda.time.LocalDateTime;\n \n /**\n- * NullableTimeStampNanoVector implements a fixed width vector (8 bytes) of\n+ * TimeStampNanoVector implements a fixed width vector (8 bytes) of\n  * timestamp (nanosecond resolution) values which could be null. A validity buffer\n  * (bit vector) is maintained to track which elements in the vector are null.\n  */\n-public class NullableTimeStampNanoVector extends NullableTimeStampVector {\n+public class TimeStampNanoVector extends TimeStampVector {\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableTimeStampNanoVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampNanoVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampNanoVector(String name, BufferAllocator allocator) {\n+  public TimeStampNanoVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.TIMESTAMPNANO.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTimeStampNanoVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampNanoVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampNanoVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeStampNanoVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, fieldType, allocator);\n-    reader = new TimeStampNanoReaderImpl(NullableTimeStampNanoVector.this);\n+    reader = new TimeStampNanoReaderImpl(TimeStampNanoVector.this);\n   }\n \n   /**\n@@ -201,7 +201,7 @@ public void setSafe(int index, TimeStampNanoHolder holder) {\n    */\n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    NullableTimeStampNanoVector to = new NullableTimeStampNanoVector(ref,\n+    TimeStampNanoVector to = new TimeStampNanoVector(ref,\n             field.getFieldType(), allocator);\n     return new TransferImpl(to);\n   }\n@@ -213,6 +213,6 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTimeStampNanoVector) to);\n+    return new TransferImpl((TimeStampNanoVector) to);\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecTZVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecTZVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecTZVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecTZVector.java\nindex 0593ac76d..201f1c317 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecTZVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecTZVector.java\n@@ -28,37 +28,37 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableTimeStampSecTZVector implements a fixed width vector (8 bytes) of\n+ * TimeStampSecTZVector implements a fixed width vector (8 bytes) of\n  * timestamp (seconds resolution) values which could be null. A validity buffer\n  * (bit vector) is maintained to track which elements in the vector are null.\n  */\n-public class NullableTimeStampSecTZVector extends NullableTimeStampVector {\n+public class TimeStampSecTZVector extends TimeStampVector {\n   private final FieldReader reader;\n   private final String timeZone;\n \n   /**\n-   * Instantiate a NullableTimeStampSecTZVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampSecTZVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampSecTZVector(String name, BufferAllocator allocator, String timeZone) {\n+  public TimeStampSecTZVector(String name, BufferAllocator allocator, String timeZone) {\n     this(name, FieldType.nullable(new org.apache.arrow.vector.types.pojo.ArrowType.Timestamp(org.apache.arrow.vector.types.TimeUnit.SECOND, timeZone)),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTimeStampSecTZVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampSecTZVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampSecTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeStampSecTZVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, fieldType, allocator);\n     org.apache.arrow.vector.types.pojo.ArrowType.Timestamp arrowType = (org.apache.arrow.vector.types.pojo.ArrowType.Timestamp) fieldType.getType();\n     timeZone = arrowType.getTimezone();\n-    reader = new TimeStampSecTZReaderImpl(NullableTimeStampSecTZVector.this);\n+    reader = new TimeStampSecTZReaderImpl(TimeStampSecTZVector.this);\n   }\n \n   /**\n@@ -198,7 +198,7 @@ public void setSafe(int index, TimeStampSecTZHolder holder) {\n    */\n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    NullableTimeStampSecTZVector to = new NullableTimeStampSecTZVector(ref,\n+    TimeStampSecTZVector to = new TimeStampSecTZVector(ref,\n             field.getFieldType(), allocator);\n     return new TransferImpl(to);\n   }\n@@ -210,6 +210,6 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTimeStampSecTZVector) to);\n+    return new TransferImpl((TimeStampSecTZVector) to);\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecVector.java\nindex 1afdb30d0..4bcd4f7bf 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampSecVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampSecVector.java\n@@ -29,34 +29,34 @@\n import org.joda.time.LocalDateTime;\n \n /**\n- * NullableTimeStampSecVector implements a fixed width vector (8 bytes) of\n+ * TimeStampSecVector implements a fixed width vector (8 bytes) of\n  * timestamp (seconds resolution) values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableTimeStampSecVector extends NullableTimeStampVector {\n+public class TimeStampSecVector extends TimeStampVector {\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableTimeStampSecVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampSecVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampSecVector(String name, BufferAllocator allocator) {\n+  public TimeStampSecVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.TIMESTAMPSEC.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTimeStampSecVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampSecVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampSecVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeStampSecVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, fieldType, allocator);\n-    reader = new TimeStampSecReaderImpl(NullableTimeStampSecVector.this);\n+    reader = new TimeStampSecReaderImpl(TimeStampSecVector.this);\n   }\n \n   /**\n@@ -201,7 +201,7 @@ public void setSafe(int index, TimeStampSecHolder holder) {\n    */\n   @Override\n   public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    NullableTimeStampSecVector to = new NullableTimeStampSecVector(ref,\n+    TimeStampSecVector to = new TimeStampSecVector(ref,\n             field.getFieldType(), allocator);\n     return new TransferImpl(to);\n   }\n@@ -213,6 +213,6 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTimeStampSecVector) to);\n+    return new TransferImpl((TimeStampSecVector) to);\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampVector.java\nsimilarity index 88%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TimeStampVector.java\nindex e1b719f66..4c70b819c 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTimeStampVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TimeStampVector.java\n@@ -24,21 +24,21 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableTimeStampVector is an abstract interface for fixed width vector (8 bytes)\n+ * TimeStampVector is an abstract interface for fixed width vector (8 bytes)\n  * of timestamp values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public abstract class NullableTimeStampVector extends BaseNullableFixedWidthVector {\n+public abstract class TimeStampVector extends BaseFixedWidthVector {\n   protected static final byte TYPE_WIDTH = 8;\n \n   /**\n-   * Instantiate a NullableTimeStampVector. This doesn't allocate any memory for\n+   * Instantiate a TimeStampVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTimeStampVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TimeStampVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n   }\n \n@@ -69,21 +69,21 @@ public long get(int index) throws IllegalStateException {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableTimeStampVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, TimeStampVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final long value = from.valueBuffer.getLong(fromIndex * TYPE_WIDTH);\n     valueBuffer.setLong(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFromSafe(int, int, NullableTimeStampVector)} except that\n+   * Same as {@link #copyFromSafe(int, int, TimeStampVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableTimeStampVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, TimeStampVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -188,14 +188,14 @@ public static long get(final ArrowBuf buffer, final int index) {\n \n \n   public class TransferImpl implements TransferPair {\n-    NullableTimeStampVector to;\n+    TimeStampVector to;\n \n-    public TransferImpl(NullableTimeStampVector to) {\n+    public TransferImpl(TimeStampVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableTimeStampVector getTo() {\n+    public TimeStampVector getTo() {\n       return to;\n     }\n \n@@ -211,7 +211,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableTimeStampVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, TimeStampVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableTinyIntVector.java b/java/vector/src/main/java/org/apache/arrow/vector/TinyIntVector.java\nsimilarity index 91%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableTinyIntVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/TinyIntVector.java\nindex cadfe6085..306437f0f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableTinyIntVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/TinyIntVector.java\n@@ -29,35 +29,35 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableTinyIntVector implements a fixed width (1 bytes) vector of\n+ * TinyIntVector implements a fixed width (1 bytes) vector of\n  * byte values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableTinyIntVector extends BaseNullableFixedWidthVector {\n+public class TinyIntVector extends BaseFixedWidthVector {\n   public static final byte TYPE_WIDTH = 1;\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableTinyIntVector. This doesn't allocate any memory for\n+   * Instantiate a TinyIntVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTinyIntVector(String name, BufferAllocator allocator) {\n+  public TinyIntVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.TINYINT.getType()),\n             allocator);\n   }\n \n   /**\n-   * Instantiate a NullableTinyIntVector. This doesn't allocate any memory for\n+   * Instantiate a TinyIntVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableTinyIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public TinyIntVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new TinyIntReaderImpl(NullableTinyIntVector.this);\n+    reader = new TinyIntReaderImpl(TinyIntVector.this);\n   }\n \n   /**\n@@ -137,21 +137,21 @@ public Byte getObject(int index) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableTinyIntVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, TinyIntVector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final byte value = from.valueBuffer.getByte(fromIndex * TYPE_WIDTH);\n     valueBuffer.setByte(thisIndex * TYPE_WIDTH, value);\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableTinyIntVector)} except that\n+   * Same as {@link #copyFrom(int, int, TinyIntVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableTinyIntVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, TinyIntVector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -357,22 +357,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableTinyIntVector) to);\n+    return new TransferImpl((TinyIntVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableTinyIntVector to;\n+    TinyIntVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableTinyIntVector(ref, field.getFieldType(), allocator);\n+      to = new TinyIntVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableTinyIntVector to) {\n+    public TransferImpl(TinyIntVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableTinyIntVector getTo() {\n+    public TinyIntVector getTo() {\n       return to;\n     }\n \n@@ -388,7 +388,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableTinyIntVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, TinyIntVector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt1Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/UInt1Vector.java\nsimilarity index 91%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableUInt1Vector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/UInt1Vector.java\nindex ebd9b5699..6901a889a 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt1Vector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/UInt1Vector.java\n@@ -28,22 +28,22 @@\n import org.apache.arrow.vector.util.TransferPair;\n \n /**\n- * NullableUInt1Vector implements a fixed width (1 bytes) vector of\n+ * UInt1Vector implements a fixed width (1 bytes) vector of\n  * integer values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableUInt1Vector extends BaseNullableFixedWidthVector {\n+public class UInt1Vector extends BaseFixedWidthVector {\n   private static final byte TYPE_WIDTH = 1;\n   private final FieldReader reader;\n \n-  public NullableUInt1Vector(String name, BufferAllocator allocator) {\n+  public UInt1Vector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.UINT1.getType()),\n             allocator);\n   }\n \n-  public NullableUInt1Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public UInt1Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new UInt1ReaderImpl(NullableUInt1Vector.this);\n+    reader = new UInt1ReaderImpl(UInt1Vector.this);\n   }\n \n   @Override\n@@ -107,13 +107,13 @@ public Byte getObject(int index) {\n     }\n   }\n \n-  public void copyFrom(int fromIndex, int thisIndex, NullableUInt1Vector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, UInt1Vector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final byte value = from.valueBuffer.getByte(fromIndex * TYPE_WIDTH);\n     valueBuffer.setByte(thisIndex * TYPE_WIDTH, value);\n   }\n \n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableUInt1Vector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, UInt1Vector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -279,22 +279,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n \n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableUInt1Vector) to);\n+    return new TransferImpl((UInt1Vector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableUInt1Vector to;\n+    UInt1Vector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableUInt1Vector(ref, field.getFieldType(), allocator);\n+      to = new UInt1Vector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableUInt1Vector to) {\n+    public TransferImpl(UInt1Vector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableUInt1Vector getTo() {\n+    public UInt1Vector getTo() {\n       return to;\n     }\n \n@@ -310,7 +310,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableUInt1Vector.this);\n+      to.copyFromSafe(fromIndex, toIndex, UInt1Vector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt2Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/UInt2Vector.java\nsimilarity index 91%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableUInt2Vector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/UInt2Vector.java\nindex bedb3f35e..968ce9151 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt2Vector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/UInt2Vector.java\n@@ -29,22 +29,22 @@\n import org.slf4j.Logger;\n \n /**\n- * NullableUInt2Vector implements a fixed width (2 bytes) vector of\n+ * UInt2Vector implements a fixed width (2 bytes) vector of\n  * integer values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableUInt2Vector extends BaseNullableFixedWidthVector {\n+public class UInt2Vector extends BaseFixedWidthVector {\n   private static final byte TYPE_WIDTH = 2;\n   private final FieldReader reader;\n \n-  public NullableUInt2Vector(String name, BufferAllocator allocator) {\n+  public UInt2Vector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.UINT2.getType()),\n             allocator);\n   }\n \n-  public NullableUInt2Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public UInt2Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new UInt2ReaderImpl(NullableUInt2Vector.this);\n+    reader = new UInt2ReaderImpl(UInt2Vector.this);\n   }\n \n   @Override\n@@ -108,13 +108,13 @@ public Character getObject(int index) {\n     }\n   }\n \n-  public void copyFrom(int fromIndex, int thisIndex, NullableUInt2Vector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, UInt2Vector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final char value = from.valueBuffer.getChar(fromIndex * TYPE_WIDTH);\n     valueBuffer.setChar(thisIndex * TYPE_WIDTH, value);\n   }\n \n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableUInt2Vector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, UInt2Vector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -280,22 +280,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n \n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableUInt2Vector) to);\n+    return new TransferImpl((UInt2Vector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableUInt2Vector to;\n+    UInt2Vector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableUInt2Vector(ref, field.getFieldType(), allocator);\n+      to = new UInt2Vector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableUInt2Vector to) {\n+    public TransferImpl(UInt2Vector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableUInt2Vector getTo() {\n+    public UInt2Vector getTo() {\n       return to;\n     }\n \n@@ -311,7 +311,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableUInt2Vector.this);\n+      to.copyFromSafe(fromIndex, toIndex, UInt2Vector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt4Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/UInt4Vector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableUInt4Vector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/UInt4Vector.java\nindex 99b547ca4..af219cb06 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt4Vector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/UInt4Vector.java\n@@ -29,22 +29,22 @@\n import org.slf4j.Logger;\n \n /**\n- * NullableUInt4Vector implements a fixed width (4 bytes) vector of\n+ * UInt4Vector implements a fixed width (4 bytes) vector of\n  * integer values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableUInt4Vector extends BaseNullableFixedWidthVector {\n+public class UInt4Vector extends BaseFixedWidthVector {\n   private static final byte TYPE_WIDTH = 4;\n   private final FieldReader reader;\n \n-  public NullableUInt4Vector(String name, BufferAllocator allocator) {\n+  public UInt4Vector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.UINT4.getType()),\n             allocator);\n   }\n \n-  public NullableUInt4Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public UInt4Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new UInt4ReaderImpl(NullableUInt4Vector.this);\n+    reader = new UInt4ReaderImpl(UInt4Vector.this);\n   }\n \n   @Override\n@@ -108,13 +108,13 @@ public Integer getObject(int index) {\n     }\n   }\n \n-  public void copyFrom(int fromIndex, int thisIndex, NullableUInt4Vector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, UInt4Vector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final int value = from.valueBuffer.getInt(fromIndex * TYPE_WIDTH);\n     valueBuffer.setInt(thisIndex * TYPE_WIDTH, value);\n   }\n \n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableUInt4Vector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, UInt4Vector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -252,22 +252,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n \n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableUInt4Vector) to);\n+    return new TransferImpl((UInt4Vector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableUInt4Vector to;\n+    UInt4Vector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableUInt4Vector(ref, field.getFieldType(), allocator);\n+      to = new UInt4Vector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableUInt4Vector to) {\n+    public TransferImpl(UInt4Vector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableUInt4Vector getTo() {\n+    public UInt4Vector getTo() {\n       return to;\n     }\n \n@@ -283,7 +283,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableUInt4Vector.this);\n+      to.copyFromSafe(fromIndex, toIndex, UInt4Vector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt8Vector.java b/java/vector/src/main/java/org/apache/arrow/vector/UInt8Vector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableUInt8Vector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/UInt8Vector.java\nindex e6664a092..eae4a3172 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableUInt8Vector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/UInt8Vector.java\n@@ -29,22 +29,22 @@\n import org.slf4j.Logger;\n \n /**\n- * NullableUInt8Vector implements a fixed width vector (8 bytes) of\n+ * UInt8Vector implements a fixed width vector (8 bytes) of\n  * integer values which could be null. A validity buffer (bit vector) is\n  * maintained to track which elements in the vector are null.\n  */\n-public class NullableUInt8Vector extends BaseNullableFixedWidthVector {\n+public class UInt8Vector extends BaseFixedWidthVector {\n   private static final byte TYPE_WIDTH = 8;\n   private final FieldReader reader;\n \n-  public NullableUInt8Vector(String name, BufferAllocator allocator) {\n+  public UInt8Vector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.UINT8.getType()),\n             allocator);\n   }\n \n-  public NullableUInt8Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public UInt8Vector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType, TYPE_WIDTH);\n-    reader = new UInt8ReaderImpl(NullableUInt8Vector.this);\n+    reader = new UInt8ReaderImpl(UInt8Vector.this);\n   }\n \n   @Override\n@@ -108,13 +108,13 @@ public Long getObject(int index) {\n     }\n   }\n \n-  public void copyFrom(int fromIndex, int thisIndex, NullableUInt8Vector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, UInt8Vector from) {\n     BitVectorHelper.setValidityBit(validityBuffer, thisIndex, from.isSet(fromIndex));\n     final long value = from.valueBuffer.getLong(fromIndex * TYPE_WIDTH);\n     valueBuffer.setLong(thisIndex * TYPE_WIDTH, value);\n   }\n \n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableUInt8Vector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, UInt8Vector from) {\n     handleSafe(thisIndex);\n     copyFrom(fromIndex, thisIndex, from);\n   }\n@@ -252,22 +252,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n \n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableUInt8Vector) to);\n+    return new TransferImpl((UInt8Vector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableUInt8Vector to;\n+    UInt8Vector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableUInt8Vector(ref, field.getFieldType(), allocator);\n+      to = new UInt8Vector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableUInt8Vector to) {\n+    public TransferImpl(UInt8Vector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableUInt8Vector getTo() {\n+    public UInt8Vector getTo() {\n       return to;\n     }\n \n@@ -283,7 +283,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableUInt8Vector.this);\n+      to.copyFromSafe(fromIndex, toIndex, UInt8Vector.this);\n     }\n   }\n }\n\\ No newline at end of file\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java b/java/vector/src/main/java/org/apache/arrow/vector/VarBinaryVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/VarBinaryVector.java\nindex 1dfe8912c..893ad7cb5 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableVarBinaryVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/VarBinaryVector.java\n@@ -31,33 +31,33 @@\n import java.nio.ByteBuffer;\n \n /**\n- * NullableVarBinaryVector implements a variable width vector of binary\n+ * VarBinaryVector implements a variable width vector of binary\n  * values which could be NULL. A validity buffer (bit vector) is maintained\n  * to track which elements in the vector are null.\n  */\n-public class NullableVarBinaryVector extends BaseNullableVariableWidthVector {\n+public class VarBinaryVector extends BaseVariableWidthVector {\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableVarBinaryVector. This doesn't allocate any memory for\n+   * Instantiate a VarBinaryVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableVarBinaryVector(String name, BufferAllocator allocator) {\n+  public VarBinaryVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(Types.MinorType.VARBINARY.getType()), allocator);\n   }\n \n   /**\n-   * Instantiate a NullableVarBinaryVector. This doesn't allocate any memory for\n+   * Instantiate a VarBinaryVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableVarBinaryVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public VarBinaryVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType);\n-    reader = new VarBinaryReaderImpl(NullableVarBinaryVector.this);\n+    reader = new VarBinaryReaderImpl(VarBinaryVector.this);\n   }\n \n   /**\n@@ -156,7 +156,7 @@ public void get(int index, NullableVarBinaryHolder holder) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableVarBinaryVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, VarBinaryVector from) {\n     final int start = from.offsetBuffer.getInt(fromIndex * OFFSET_WIDTH);\n     final int end = from.offsetBuffer.getInt((fromIndex + 1) * OFFSET_WIDTH);\n     final int length = end - start;\n@@ -169,14 +169,14 @@ public void copyFrom(int fromIndex, int thisIndex, NullableVarBinaryVector from)\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableVarBinaryVector)} except that\n+   * Same as {@link #copyFrom(int, int, VarBinaryVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableVarBinaryVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, VarBinaryVector from) {\n     final int start = from.offsetBuffer.getInt(fromIndex * OFFSET_WIDTH);\n     final int end = from.offsetBuffer.getInt((fromIndex + 1) * OFFSET_WIDTH);\n     final int length = end - start;\n@@ -291,22 +291,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableVarBinaryVector) to);\n+    return new TransferImpl((VarBinaryVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableVarBinaryVector to;\n+    VarBinaryVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableVarBinaryVector(ref, field.getFieldType(), allocator);\n+      to = new VarBinaryVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableVarBinaryVector to) {\n+    public TransferImpl(VarBinaryVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableVarBinaryVector getTo() {\n+    public VarBinaryVector getTo() {\n       return to;\n     }\n \n@@ -322,7 +322,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableVarBinaryVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, VarBinaryVector.this);\n     }\n   }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java b/java/vector/src/main/java/org/apache/arrow/vector/VarCharVector.java\nsimilarity index 90%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/VarCharVector.java\nindex 31e409cc6..8a38b1d45 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableVarCharVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/VarCharVector.java\n@@ -32,33 +32,33 @@\n import java.nio.ByteBuffer;\n \n /**\n- * NullableVarCharVector implements a variable width vector of VARCHAR\n+ * VarCharVector implements a variable width vector of VARCHAR\n  * values which could be NULL. A validity buffer (bit vector) is maintained\n  * to track which elements in the vector are null.\n  */\n-public class NullableVarCharVector extends BaseNullableVariableWidthVector {\n+public class VarCharVector extends BaseVariableWidthVector {\n   private final FieldReader reader;\n \n   /**\n-   * Instantiate a NullableVarCharVector. This doesn't allocate any memory for\n+   * Instantiate a VarCharVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableVarCharVector(String name, BufferAllocator allocator) {\n+  public VarCharVector(String name, BufferAllocator allocator) {\n     this(name, FieldType.nullable(org.apache.arrow.vector.types.Types.MinorType.VARCHAR.getType()), allocator);\n   }\n \n   /**\n-   * Instantiate a NullableVarCharVector. This doesn't allocate any memory for\n+   * Instantiate a VarCharVector. This doesn't allocate any memory for\n    * the data in vector.\n    * @param name name of the vector\n    * @param fieldType type of Field materialized by this vector\n    * @param allocator allocator for memory management.\n    */\n-  public NullableVarCharVector(String name, FieldType fieldType, BufferAllocator allocator) {\n+  public VarCharVector(String name, FieldType fieldType, BufferAllocator allocator) {\n     super(name, allocator, fieldType);\n-    reader = new VarCharReaderImpl(NullableVarCharVector.this);\n+    reader = new VarCharReaderImpl(VarCharVector.this);\n   }\n \n   /**\n@@ -159,7 +159,7 @@ public void get(int index, NullableVarCharHolder holder) {\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFrom(int fromIndex, int thisIndex, NullableVarCharVector from) {\n+  public void copyFrom(int fromIndex, int thisIndex, VarCharVector from) {\n     final int start = from.offsetBuffer.getInt(fromIndex * OFFSET_WIDTH);\n     final int end = from.offsetBuffer.getInt((fromIndex + 1) * OFFSET_WIDTH);\n     final int length = end - start;\n@@ -172,14 +172,14 @@ public void copyFrom(int fromIndex, int thisIndex, NullableVarCharVector from) {\n   }\n \n   /**\n-   * Same as {@link #copyFrom(int, int, NullableVarCharVector)} except that\n+   * Same as {@link #copyFrom(int, int, VarCharVector)} except that\n    * it handles the case when the capacity of the vector needs to be expanded\n    * before copy.\n    * @param fromIndex position to copy from in source vector\n    * @param thisIndex position to copy to in this vector\n    * @param from source vector\n    */\n-  public void copyFromSafe(int fromIndex, int thisIndex, NullableVarCharVector from) {\n+  public void copyFromSafe(int fromIndex, int thisIndex, VarCharVector from) {\n     final int start = from.offsetBuffer.getInt(fromIndex * OFFSET_WIDTH);\n     final int end = from.offsetBuffer.getInt((fromIndex + 1) * OFFSET_WIDTH);\n     final int length = end - start;\n@@ -294,22 +294,22 @@ public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n    */\n   @Override\n   public TransferPair makeTransferPair(ValueVector to) {\n-    return new TransferImpl((NullableVarCharVector) to);\n+    return new TransferImpl((VarCharVector) to);\n   }\n \n   private class TransferImpl implements TransferPair {\n-    NullableVarCharVector to;\n+    VarCharVector to;\n \n     public TransferImpl(String ref, BufferAllocator allocator) {\n-      to = new NullableVarCharVector(ref, field.getFieldType(), allocator);\n+      to = new VarCharVector(ref, field.getFieldType(), allocator);\n     }\n \n-    public TransferImpl(NullableVarCharVector to) {\n+    public TransferImpl(VarCharVector to) {\n       this.to = to;\n     }\n \n     @Override\n-    public NullableVarCharVector getTo() {\n+    public VarCharVector getTo() {\n       return to;\n     }\n \n@@ -325,7 +325,7 @@ public void splitAndTransfer(int startIndex, int length) {\n \n     @Override\n     public void copyValueSafe(int fromIndex, int toIndex) {\n-      to.copyFromSafe(fromIndex, toIndex, NullableVarCharVector.this);\n+      to.copyFromSafe(fromIndex, toIndex, VarCharVector.this);\n     }\n   }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/NullableVectorDefinitionSetter.java b/java/vector/src/main/java/org/apache/arrow/vector/VectorDefinitionSetter.java\nsimilarity index 94%\nrename from java/vector/src/main/java/org/apache/arrow/vector/NullableVectorDefinitionSetter.java\nrename to java/vector/src/main/java/org/apache/arrow/vector/VectorDefinitionSetter.java\nindex 1e0746aab..2f45d3a5b 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/NullableVectorDefinitionSetter.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/VectorDefinitionSetter.java\n@@ -18,7 +18,7 @@\n \n package org.apache.arrow.vector;\n \n-public interface NullableVectorDefinitionSetter {\n+public interface VectorDefinitionSetter {\n \n   public void setIndexDefined(int index);\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractContainerVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractContainerVector.java\nindex db0ff86df..5ded1cc6f 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractContainerVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/AbstractContainerVector.java\n@@ -100,8 +100,8 @@ protected boolean supportsDirectRead() {\n   // return the child vector's ordinal in the composite container\n   public abstract VectorWithOrdinal getChildVectorWithOrdinal(String name);\n \n-  public NullableMapVector addOrGetMap(String name) {\n-    return addOrGet(name, FieldType.nullable(new Struct()), NullableMapVector.class);\n+  public MapVector addOrGetMap(String name) {\n+    return addOrGet(name, FieldType.nullable(new Struct()), MapVector.class);\n   }\n \n   public ListVector addOrGetList(String name) {\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/EmptyValuePopulator.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/EmptyValuePopulator.java\nindex a76fbbe11..cd3a2ae9e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/EmptyValuePopulator.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/EmptyValuePopulator.java\n@@ -42,14 +42,12 @@ public void populate(int lastIndex) {\n     if (lastIndex < 0) {\n       throw new IndexOutOfBoundsException(\"index cannot be negative\");\n     }\n-    final UInt4Vector.Accessor accessor = offsets.getAccessor();\n-    final UInt4Vector.Mutator mutator = offsets.getMutator();\n-    final int lastSet = Math.max(accessor.getValueCount() - 1, 0);\n-    final int previousEnd = accessor.get(lastSet);//0 ? 0 : accessor.get(lastSet);\n+    final int lastSet = Math.max(offsets.getValueCount() - 1, 0);\n+    final int previousEnd = offsets.get(lastSet);//0 ? 0 : accessor.get(lastSet);\n     for (int i = lastSet; i < lastIndex; i++) {\n-      mutator.setSafe(i + 1, previousEnd);\n+      offsets.setSafe(i + 1, previousEnd);\n     }\n-    mutator.setValueCount(lastIndex + 1);\n+    offsets.setValueCount(lastIndex + 1);\n   }\n \n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\nindex 6089a6792..075ae83ea 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/MapVector.java\n@@ -6,9 +6,9 @@\n  * to you under the Apache License, Version 2.0 (the\n  * \"License\"); you may not use this file except in compliance\n  * with the License.  You may obtain a copy of the License at\n- *\n+ * <p>\n  * http://www.apache.org/licenses/LICENSE-2.0\n- *\n+ * <p>\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n@@ -21,332 +21,492 @@\n import static com.google.common.base.Preconditions.checkNotNull;\n \n import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Iterator;\n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Map;\n \n-import javax.annotation.Nullable;\n-\n-import com.google.common.base.Preconditions;\n-import com.google.common.collect.Ordering;\n-import com.google.common.primitives.Ints;\n+import com.google.common.collect.ObjectArrays;\n \n import io.netty.buffer.ArrowBuf;\n-\n+import org.apache.arrow.memory.BaseAllocator;\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n-import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n+import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n+import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Field;\n import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.JsonStringHashMap;\n+import org.apache.arrow.vector.util.OversizedAllocationException;\n import org.apache.arrow.vector.util.TransferPair;\n \n-public class MapVector extends AbstractMapVector {\n-  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MapVector.class);\n+public class MapVector extends NonNullableMapVector implements FieldVector {\n \n   public static MapVector empty(String name, BufferAllocator allocator) {\n-    FieldType fieldType = new FieldType(false, ArrowType.Struct.INSTANCE, null, null);\n+    FieldType fieldType = FieldType.nullable(Struct.INSTANCE);\n     return new MapVector(name, allocator, fieldType, null);\n   }\n \n-  private final SingleMapReaderImpl reader = new SingleMapReaderImpl(this);\n-  protected final FieldType fieldType;\n-  public int valueCount;\n+  private final NullableMapReaderImpl reader = new NullableMapReaderImpl(this);\n+  private final NullableMapWriter writer = new NullableMapWriter(this);\n+\n+  protected ArrowBuf validityBuffer;\n+  private int validityAllocationSizeInBytes;\n \n   // deprecated, use FieldType or static constructor instead\n   @Deprecated\n   public MapVector(String name, BufferAllocator allocator, CallBack callBack) {\n-    this(name, allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n+    this(name, allocator, FieldType.nullable(ArrowType.Struct.INSTANCE), callBack);\n   }\n \n-  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n-    super(name, allocator, callBack);\n-    this.fieldType = checkNotNull(fieldType);\n-    this.valueCount = 0;\n-  }\n-\n-  @Override\n-  public FieldReader getReader() {\n-    return reader;\n+  // deprecated, use FieldType or static constructor instead\n+  @Deprecated\n+  public MapVector(String name, BufferAllocator allocator, DictionaryEncoding dictionary, CallBack callBack) {\n+    this(name, allocator, new FieldType(true, ArrowType.Struct.INSTANCE, dictionary, null), callBack);\n   }\n \n-  transient private MapTransferPair ephPair;\n-\n-  public void copyFromSafe(int fromIndex, int thisIndex, MapVector from) {\n-    if (ephPair == null || ephPair.from != from) {\n-      ephPair = (MapTransferPair) from.makeTransferPair(this);\n-    }\n-    ephPair.copyValueSafe(fromIndex, thisIndex);\n+  public MapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(name, checkNotNull(allocator), fieldType, callBack);\n+    this.validityBuffer = allocator.getEmpty();\n+    this.validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(BaseValueVector.INITIAL_VALUE_ALLOCATION);\n   }\n \n   @Override\n-  protected boolean supportsDirectRead() {\n-    return true;\n-  }\n-\n-  public Iterator<String> fieldNameIterator() {\n-    return getChildFieldNames().iterator();\n+  public Field getField() {\n+    Field f = super.getField();\n+    FieldType type = new FieldType(true, f.getType(), f.getFieldType().getDictionary(), f.getFieldType().getMetadata());\n+    return new Field(f.getName(), type, f.getChildren());\n   }\n \n   @Override\n-  public void setInitialCapacity(int numRecords) {\n-    for (final ValueVector v : (Iterable<ValueVector>) this) {\n-      v.setInitialCapacity(numRecords);\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 1) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 1 + \", got: \" + ownBuffers.size());\n     }\n-  }\n \n-  @Override\n-  public int getBufferSize() {\n-    if (valueCount == 0 || size() == 0) {\n-      return 0;\n-    }\n-    long buffer = 0;\n-    for (final ValueVector v : (Iterable<ValueVector>) this) {\n-      buffer += v.getBufferSize();\n-    }\n+    ArrowBuf bitBuffer = ownBuffers.get(0);\n \n-    return (int) buffer;\n+    validityBuffer.release();\n+    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n+    valueCount = fieldNode.getLength();\n+    validityAllocationSizeInBytes = validityBuffer.capacity();\n   }\n \n   @Override\n-  public int getBufferSizeFor(final int valueCount) {\n-    if (valueCount == 0) {\n-      return 0;\n-    }\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+    setReaderAndWriterIndex();\n+    result.add(validityBuffer);\n \n-    long bufferSize = 0;\n-    for (final ValueVector v : (Iterable<ValueVector>) this) {\n-      bufferSize += v.getBufferSizeFor(valueCount);\n-    }\n+    return result;\n+  }\n \n-    return (int) bufferSize;\n+  private void setReaderAndWriterIndex() {\n+    validityBuffer.readerIndex(0);\n+    validityBuffer.writerIndex(BitVectorHelper.getValidityBufferSize(valueCount));\n   }\n \n   @Override\n-  public ArrowBuf getValidityBuffer() {\n-    throw new UnsupportedOperationException();\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n   }\n \n   @Override\n-  public ArrowBuf getDataBuffer() {\n-    throw new UnsupportedOperationException();\n+  public NullableMapReaderImpl getReader() {\n+    return reader;\n   }\n \n-  @Override\n-  public ArrowBuf getOffsetBuffer() {\n-    throw new UnsupportedOperationException();\n+  public NullableMapWriter getWriter() {\n+    return writer;\n   }\n \n   @Override\n   public TransferPair getTransferPair(BufferAllocator allocator) {\n-    return getTransferPair(name, allocator, null);\n+    return new NullableMapTransferPair(this, new MapVector(name, allocator, fieldType, null), false);\n   }\n \n   @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n-    return new MapTransferPair(this, new MapVector(name, allocator, fieldType, callBack), false);\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new NullableMapTransferPair(this, (MapVector) to, true);\n   }\n \n   @Override\n-  public TransferPair makeTransferPair(ValueVector to) {\n-    return new MapTransferPair(this, (MapVector) to);\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new NullableMapTransferPair(this, new MapVector(ref, allocator, fieldType, null), false);\n   }\n \n   @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    return new MapTransferPair(this, new MapVector(ref, allocator, fieldType, callBack), false);\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new NullableMapTransferPair(this, new MapVector(ref, allocator, fieldType, callBack), false);\n   }\n \n-  protected static class MapTransferPair implements TransferPair {\n-    private final TransferPair[] pairs;\n-    private final MapVector from;\n-    private final MapVector to;\n+  protected class NullableMapTransferPair extends MapTransferPair {\n \n-    public MapTransferPair(MapVector from, MapVector to) {\n-      this(from, to, true);\n-    }\n+    private MapVector target;\n \n-    protected MapTransferPair(MapVector from, MapVector to, boolean allocate) {\n-      this.from = from;\n-      this.to = to;\n-      this.pairs = new TransferPair[from.size()];\n-      this.to.ephPair = null;\n-\n-      int i = 0;\n-      FieldVector vector;\n-      for (String child : from.getChildFieldNames()) {\n-        int preSize = to.size();\n-        vector = from.getChild(child);\n-        if (vector == null) {\n-          continue;\n-        }\n-        //DRILL-1872: we add the child fields for the vector, looking up the field by name. For a map vector,\n-        // the child fields may be nested fields of the top level child. For example if the structure\n-        // of a child field is oa.oab.oabc then we add oa, then add oab to oa then oabc to oab.\n-        // But the children member of a Materialized field is a HashSet. If the fields are added in the\n-        // children HashSet, and the hashCode of the Materialized field includes the hash code of the\n-        // children, the hashCode value of oa changes *after* the field has been added to the HashSet.\n-        // (This is similar to what happens in ScanBatch where the children cannot be added till they are\n-        // read). To take care of this, we ensure that the hashCode of the MaterializedField does not\n-        // include the hashCode of the children but is based only on MaterializedField$key.\n-        final FieldVector newVector = to.addOrGet(child, vector.getField().getFieldType(), vector.getClass());\n-        if (allocate && to.size() != preSize) {\n-          newVector.allocateNew();\n-        }\n-        pairs[i++] = vector.makeTransferPair(newVector);\n-      }\n+    protected NullableMapTransferPair(MapVector from, MapVector to, boolean allocate) {\n+      super(from, to, allocate);\n+      this.target = to;\n     }\n \n     @Override\n     public void transfer() {\n-      for (final TransferPair p : pairs) {\n-        p.transfer();\n-      }\n-      to.valueCount = from.valueCount;\n-      from.clear();\n-    }\n-\n-    @Override\n-    public ValueVector getTo() {\n-      return to;\n+      target.clear();\n+      target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n+      super.transfer();\n+      clear();\n     }\n \n     @Override\n-    public void copyValueSafe(int from, int to) {\n-      for (TransferPair p : pairs) {\n-        p.copyValueSafe(from, to);\n+    public void copyValueSafe(int fromIndex, int toIndex) {\n+      while (toIndex >= target.getValidityBufferValueCapacity()) {\n+        target.reallocValidityBuffer();\n       }\n+      BitVectorHelper.setValidityBit(target.validityBuffer, toIndex, isSet(fromIndex));\n+      super.copyValueSafe(fromIndex, toIndex);\n     }\n \n     @Override\n     public void splitAndTransfer(int startIndex, int length) {\n-      for (TransferPair p : pairs) {\n-        p.splitAndTransfer(startIndex, length);\n+      target.clear();\n+      splitAndTransferValidityBuffer(startIndex, length, target);\n+      super.splitAndTransfer(startIndex, length);\n+    }\n+  }\n+\n+  /*\n+   * transfer the validity.\n+   */\n+  private void splitAndTransferValidityBuffer(int startIndex, int length, MapVector target) {\n+    assert startIndex + length <= valueCount;\n+    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n+    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n+    int byteSizeTarget = BitVectorHelper.getValidityBufferSize(length);\n+    int offset = startIndex % 8;\n+\n+    if (length > 0) {\n+      if (offset == 0) {\n+        // slice\n+        if (target.validityBuffer != null) {\n+          target.validityBuffer.release();\n+        }\n+        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n+        target.validityBuffer.retain(1);\n+      } else {\n+        /* Copy data\n+         * When the first bit starts from the middle of a byte (offset != 0),\n+         * copy data from src BitVector.\n+         * Each byte in the target is composed by a part in i-th byte,\n+         * another part in (i+1)-th byte.\n+         */\n+        target.allocateValidityBuffer(byteSizeTarget);\n+\n+        for (int i = 0; i < byteSizeTarget - 1; i++) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n+\n+          target.validityBuffer.setByte(i, (b1 + b2));\n+        }\n+\n+        /* Copying the last piece is done in the following manner:\n+         * if the source vector has 1 or more bytes remaining, we copy\n+         * the last piece as a byte formed by shifting data\n+         * from the current byte and the next byte.\n+         *\n+         * if the source vector has no more bytes remaining\n+         * (we are at the last byte), we copy the last piece as a byte\n+         * by shifting data from the current byte.\n+         */\n+        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n+                  firstByteSource + byteSizeTarget, offset);\n+\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n+        } else {\n+          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n+                  firstByteSource + byteSizeTarget - 1, offset);\n+          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n+        }\n       }\n-      to.setValueCount(length);\n     }\n   }\n \n+  /**\n+   * Get the value capacity of the internal validity buffer.\n+   * @return number of elements that validity buffer can hold\n+   */\n+  private int getValidityBufferValueCapacity() {\n+    return (int) (validityBuffer.capacity() * 8L);\n+  }\n+\n+  /**\n+   * Get the current value capacity for the vector\n+   * @return number of elements that vector can hold.\n+   */\n   @Override\n   public int getValueCapacity() {\n-    if (size() == 0) {\n-      return 0;\n-    }\n+    return Math.min(getValidityBufferValueCapacity(),\n+            super.getValueCapacity());\n+  }\n \n-    final Ordering<ValueVector> natural = new Ordering<ValueVector>() {\n-      @Override\n-      public int compare(@Nullable ValueVector left, @Nullable ValueVector right) {\n-        return Ints.compare(\n-            checkNotNull(left).getValueCapacity(),\n-            checkNotNull(right).getValueCapacity()\n-        );\n+  /**\n+   * Return the underlying buffers associated with this vector. Note that this doesn't\n+   * impact the reference counts for this buffer so it only should be used for in-context\n+   * access. Also note that this buffer changes regularly thus\n+   * external classes shouldn't hold a reference to it (unless they change it).\n+   *\n+   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n+   *              but the returned array will be the only reference to them\n+   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n+   *         vector instance.\n+   */\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    setReaderAndWriterIndex();\n+    final ArrowBuf[] buffers;\n+    if (getBufferSize() == 0) {\n+      buffers = new ArrowBuf[0];\n+    } else {\n+      buffers = ObjectArrays.concat(new ArrowBuf[]{validityBuffer}, super.getBuffers(false),\n+              ArrowBuf.class);\n+    }\n+    if (clear) {\n+      for (ArrowBuf buffer : buffers) {\n+        buffer.retain();\n       }\n-    };\n+      clear();\n+    }\n \n-    return natural.min(getChildren()).getValueCapacity();\n+    return buffers;\n   }\n \n+  /**\n+   * Close the vector and release the associated buffers.\n+   */\n   @Override\n-  public Accessor getAccessor() {\n-    throw new UnsupportedOperationException(\"accessor is not needed for MAP\");\n+  public void close() {\n+    clearValidityBuffer();\n+    super.close();\n   }\n \n+  /**\n+   * Same as {@link #close()}\n+   */\n   @Override\n-  public Mutator getMutator() {\n-    throw new UnsupportedOperationException(\"mutator is not needed for MAP\");\n+  public void clear() {\n+    clearValidityBuffer();\n+    super.clear();\n+  }\n+\n+  /**\n+   * Release the validity buffer\n+   */\n+  private void clearValidityBuffer() {\n+    validityBuffer.release();\n+    validityBuffer = allocator.getEmpty();\n   }\n \n+  /**\n+   * Get the size (number of bytes) of underlying buffers used by this\n+   * vector\n+   * @return size of underlying buffers.\n+   */\n   @Override\n-  public Object getObject(int index) {\n-    Map<String, Object> vv = new JsonStringHashMap<>();\n-    for (String child : getChildFieldNames()) {\n-      ValueVector v = getChild(child);\n-      if (v != null && index < v.getValueCount()) {\n-        Object value = v.getObject(index);\n-        if (value != null) {\n-          vv.put(child, value);\n-        }\n+  public int getBufferSize() {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return super.getBufferSize() +\n+            BitVectorHelper.getValidityBufferSize(valueCount);\n+  }\n+\n+  /**\n+   * Get the potential buffer size for a particular number of records.\n+   * @param valueCount desired number of elements in the vector\n+   * @return estimated size of underlying buffers if the vector holds\n+   *         a given number of elements\n+   */\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+    return super.getBufferSizeFor(valueCount)\n+            + BitVectorHelper.getValidityBufferSize(valueCount);\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(numRecords);\n+    super.setInitialCapacity(numRecords);\n+  }\n+\n+  @Override\n+  public boolean allocateNewSafe() {\n+    /* Boolean to keep track if all the memory allocations were successful\n+     * Used in the case of composite vectors when we need to allocate multiple\n+     * buffers for multiple vectors. If one of the allocations failed we need to\n+     * clear all the memory that we allocated\n+     */\n+    boolean success = false;\n+    try {\n+      clear();\n+      allocateValidityBuffer(validityAllocationSizeInBytes);\n+      success = super.allocateNewSafe();\n+    } finally {\n+      if (!success) {\n+        clear();\n+        return false;\n       }\n     }\n-    return vv;\n+    return true;\n+  }\n+\n+  private void allocateValidityBuffer(final long size) {\n+    final int curSize = (int) size;\n+    validityBuffer = allocator.buffer(curSize);\n+    validityBuffer.readerIndex(0);\n+    validityAllocationSizeInBytes = curSize;\n+    validityBuffer.setZero(0, validityBuffer.capacity());\n   }\n \n   @Override\n-  public boolean isNull(int index) { return false; }\n+  public void reAlloc() {\n+    /* reallocate the validity buffer */\n+    reallocValidityBuffer();\n+    super.reAlloc();\n+  }\n+\n+  private void reallocValidityBuffer() {\n+    final int currentBufferCapacity = validityBuffer.capacity();\n+    long baseSize = validityAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setZero(0, newBuf.capacity());\n+    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n+    validityBuffer.release(1);\n+    validityBuffer = newBuf;\n+    validityAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n   @Override\n-  public int getNullCount() { return 0; }\n+  public long getValidityBufferAddress() {\n+    return validityBuffer.memoryAddress();\n+  }\n \n-  public void get(int index, ComplexHolder holder) {\n-    reader.setPosition(index);\n-    holder.reader = reader;\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n   }\n \n   @Override\n-  public int getValueCount() {\n-    return valueCount;\n+  public long getOffsetBufferAddress() {\n+    throw new UnsupportedOperationException();\n   }\n \n-  public ValueVector getVectorById(int id) {\n-  return getChildByOrdinal(id);\n-}\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    return validityBuffer;\n+  }\n \n   @Override\n-  public void setValueCount(int valueCount) {\n-    for (final ValueVector v : getChildren()) {\n-      v.setValueCount(valueCount);\n-    }\n-    MapVector.this.valueCount = valueCount;\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n   }\n \n   @Override\n-  public void clear() {\n-    for (final ValueVector v : getChildren()) {\n-      v.clear();\n-    }\n-    valueCount = 0;\n+  public ArrowBuf getOffsetBuffer() {\n+    throw new UnsupportedOperationException();\n   }\n \n   @Override\n-  public Field getField() {\n-    List<Field> children = new ArrayList<>();\n-    for (ValueVector child : getChildren()) {\n-      children.add(child.getField());\n+  public Object getObject(int index) {\n+    if (isSet(index) == 0) {\n+      return null;\n+    } else {\n+      return super.getObject(index);\n     }\n-    return new Field(name, fieldType, children);\n   }\n \n   @Override\n-  public MinorType getMinorType() {\n-    return MinorType.MAP;\n+  public void get(int index, ComplexHolder holder) {\n+    holder.isSet = isSet(index);\n+    super.get(index, holder);\n+  }\n+\n+  public int getNullCount() {\n+    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n+  }\n+\n+  public boolean isNull(int index) {\n+    return isSet(index) == 0;\n+  }\n+\n+  public int isSet(int index) {\n+    final int byteIndex = index >> 3;\n+    final byte b = validityBuffer.getByte(byteIndex);\n+    final int bitIndex = index & 7;\n+    return Long.bitCount(b & (1L << bitIndex));\n+  }\n+\n+  public void setIndexDefined(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      /* realloc the inner buffers if needed */\n+      reallocValidityBuffer();\n+    }\n+    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n+  }\n+\n+  public void setNull(int index) {\n+    while (index >= getValidityBufferValueCapacity()) {\n+      /* realloc the inner buffers if needed */\n+      reallocValidityBuffer();\n+    }\n+    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n   }\n \n   @Override\n-  public void close() {\n-    final Collection<FieldVector> vectors = getChildren();\n-    for (final FieldVector v : vectors) {\n-      v.close();\n+  public void setValueCount(int valueCount) {\n+    assert valueCount >= 0;\n+    while (valueCount > getValidityBufferValueCapacity()) {\n+      /* realloc the inner buffers if needed */\n+      reallocValidityBuffer();\n     }\n-    vectors.clear();\n+    super.setValueCount(valueCount);\n+    this.valueCount = valueCount;\n+  }\n \n+  public void reset() {\n     valueCount = 0;\n-\n-    super.close();\n   }\n \n-  public void initializeChildrenFromFields(List<Field> children) {\n-    for (Field field : children) {\n-      FieldVector vector = (FieldVector) this.add(field.getName(), field.getFieldType());\n-      vector.initializeChildrenFromFields(field.getChildren());\n-    }\n+  @Override\n+  @Deprecated\n+  public Accessor getAccessor() {\n+    throw new UnsupportedOperationException(\"Accessor is not supported for reading from Nullable MAP\");\n   }\n \n-  public List<FieldVector> getChildrenFromFields() {\n-    return getChildren();\n+  @Override\n+  @Deprecated\n+  public Mutator getMutator() {\n+    throw new UnsupportedOperationException(\"Mutator is not supported for writing to Nullable MAP\");\n   }\n }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/NonNullableMapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/NonNullableMapVector.java\nnew file mode 100644\nindex 000000000..cc3ac4148\n--- /dev/null\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/NonNullableMapVector.java\n@@ -0,0 +1,352 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.vector.complex;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Ordering;\n+import com.google.common.primitives.Ints;\n+\n+import io.netty.buffer.ArrowBuf;\n+\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n+import org.apache.arrow.vector.complex.reader.FieldReader;\n+import org.apache.arrow.vector.holders.ComplexHolder;\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.JsonStringHashMap;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+public class NonNullableMapVector extends AbstractMapVector {\n+  //private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(NonNullableMapVector.class);\n+\n+  public static NonNullableMapVector empty(String name, BufferAllocator allocator) {\n+    FieldType fieldType = new FieldType(false, ArrowType.Struct.INSTANCE, null, null);\n+    return new NonNullableMapVector(name, allocator, fieldType, null);\n+  }\n+\n+  private final SingleMapReaderImpl reader = new SingleMapReaderImpl(this);\n+  protected final FieldType fieldType;\n+  public int valueCount;\n+\n+  // deprecated, use FieldType or static constructor instead\n+  @Deprecated\n+  public NonNullableMapVector(String name, BufferAllocator allocator, CallBack callBack) {\n+    this(name, allocator, new FieldType(false, ArrowType.Struct.INSTANCE, null, null), callBack);\n+  }\n+\n+  public NonNullableMapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(name, allocator, callBack);\n+    this.fieldType = checkNotNull(fieldType);\n+    this.valueCount = 0;\n+  }\n+\n+  @Override\n+  public FieldReader getReader() {\n+    return reader;\n+  }\n+\n+  transient private MapTransferPair ephPair;\n+\n+  public void copyFromSafe(int fromIndex, int thisIndex, NonNullableMapVector from) {\n+    if (ephPair == null || ephPair.from != from) {\n+      ephPair = (MapTransferPair) from.makeTransferPair(this);\n+    }\n+    ephPair.copyValueSafe(fromIndex, thisIndex);\n+  }\n+\n+  @Override\n+  protected boolean supportsDirectRead() {\n+    return true;\n+  }\n+\n+  public Iterator<String> fieldNameIterator() {\n+    return getChildFieldNames().iterator();\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) {\n+    for (final ValueVector v : (Iterable<ValueVector>) this) {\n+      v.setInitialCapacity(numRecords);\n+    }\n+  }\n+\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0 || size() == 0) {\n+      return 0;\n+    }\n+    long buffer = 0;\n+    for (final ValueVector v : (Iterable<ValueVector>) this) {\n+      buffer += v.getBufferSize();\n+    }\n+\n+    return (int) buffer;\n+  }\n+\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    long bufferSize = 0;\n+    for (final ValueVector v : (Iterable<ValueVector>) this) {\n+      bufferSize += v.getBufferSizeFor(valueCount);\n+    }\n+\n+    return (int) bufferSize;\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(name, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new MapTransferPair(this, new NonNullableMapVector(name, allocator, fieldType, callBack), false);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector to) {\n+    return new MapTransferPair(this, (NonNullableMapVector) to);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return new MapTransferPair(this, new NonNullableMapVector(ref, allocator, fieldType, callBack), false);\n+  }\n+\n+  protected static class MapTransferPair implements TransferPair {\n+    private final TransferPair[] pairs;\n+    private final NonNullableMapVector from;\n+    private final NonNullableMapVector to;\n+\n+    public MapTransferPair(NonNullableMapVector from, NonNullableMapVector to) {\n+      this(from, to, true);\n+    }\n+\n+    protected MapTransferPair(NonNullableMapVector from, NonNullableMapVector to, boolean allocate) {\n+      this.from = from;\n+      this.to = to;\n+      this.pairs = new TransferPair[from.size()];\n+      this.to.ephPair = null;\n+\n+      int i = 0;\n+      FieldVector vector;\n+      for (String child : from.getChildFieldNames()) {\n+        int preSize = to.size();\n+        vector = from.getChild(child);\n+        if (vector == null) {\n+          continue;\n+        }\n+        //DRILL-1872: we add the child fields for the vector, looking up the field by name. For a map vector,\n+        // the child fields may be nested fields of the top level child. For example if the structure\n+        // of a child field is oa.oab.oabc then we add oa, then add oab to oa then oabc to oab.\n+        // But the children member of a Materialized field is a HashSet. If the fields are added in the\n+        // children HashSet, and the hashCode of the Materialized field includes the hash code of the\n+        // children, the hashCode value of oa changes *after* the field has been added to the HashSet.\n+        // (This is similar to what happens in ScanBatch where the children cannot be added till they are\n+        // read). To take care of this, we ensure that the hashCode of the MaterializedField does not\n+        // include the hashCode of the children but is based only on MaterializedField$key.\n+        final FieldVector newVector = to.addOrGet(child, vector.getField().getFieldType(), vector.getClass());\n+        if (allocate && to.size() != preSize) {\n+          newVector.allocateNew();\n+        }\n+        pairs[i++] = vector.makeTransferPair(newVector);\n+      }\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      for (final TransferPair p : pairs) {\n+        p.transfer();\n+      }\n+      to.valueCount = from.valueCount;\n+      from.clear();\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      for (TransferPair p : pairs) {\n+        p.copyValueSafe(from, to);\n+      }\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      for (TransferPair p : pairs) {\n+        p.splitAndTransfer(startIndex, length);\n+      }\n+      to.setValueCount(length);\n+    }\n+  }\n+\n+  @Override\n+  public int getValueCapacity() {\n+    if (size() == 0) {\n+      return 0;\n+    }\n+\n+    final Ordering<ValueVector> natural = new Ordering<ValueVector>() {\n+      @Override\n+      public int compare(@Nullable ValueVector left, @Nullable ValueVector right) {\n+        return Ints.compare(\n+            checkNotNull(left).getValueCapacity(),\n+            checkNotNull(right).getValueCapacity()\n+        );\n+      }\n+    };\n+\n+    return natural.min(getChildren()).getValueCapacity();\n+  }\n+\n+  @Override\n+  public Accessor getAccessor() {\n+    throw new UnsupportedOperationException(\"accessor is not needed for MAP\");\n+  }\n+\n+  @Override\n+  public Mutator getMutator() {\n+    throw new UnsupportedOperationException(\"mutator is not needed for MAP\");\n+  }\n+\n+  @Override\n+  public Object getObject(int index) {\n+    Map<String, Object> vv = new JsonStringHashMap<>();\n+    for (String child : getChildFieldNames()) {\n+      ValueVector v = getChild(child);\n+      if (v != null && index < v.getValueCount()) {\n+        Object value = v.getObject(index);\n+        if (value != null) {\n+          vv.put(child, value);\n+        }\n+      }\n+    }\n+    return vv;\n+  }\n+\n+  @Override\n+  public boolean isNull(int index) { return false; }\n+  @Override\n+  public int getNullCount() { return 0; }\n+\n+  public void get(int index, ComplexHolder holder) {\n+    reader.setPosition(index);\n+    holder.reader = reader;\n+  }\n+\n+  @Override\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  public ValueVector getVectorById(int id) {\n+  return getChildByOrdinal(id);\n+}\n+\n+  @Override\n+  public void setValueCount(int valueCount) {\n+    for (final ValueVector v : getChildren()) {\n+      v.setValueCount(valueCount);\n+    }\n+    NonNullableMapVector.this.valueCount = valueCount;\n+  }\n+\n+  @Override\n+  public void clear() {\n+    for (final ValueVector v : getChildren()) {\n+      v.clear();\n+    }\n+    valueCount = 0;\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    List<Field> children = new ArrayList<>();\n+    for (ValueVector child : getChildren()) {\n+      children.add(child.getField());\n+    }\n+    return new Field(name, fieldType, children);\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.MAP;\n+  }\n+\n+  @Override\n+  public void close() {\n+    final Collection<FieldVector> vectors = getChildren();\n+    for (final FieldVector v : vectors) {\n+      v.close();\n+    }\n+    vectors.clear();\n+\n+    valueCount = 0;\n+\n+    super.close();\n+  }\n+\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    for (Field field : children) {\n+      FieldVector vector = (FieldVector) this.add(field.getName(), field.getFieldType());\n+      vector.initializeChildrenFromFields(field.getChildren());\n+    }\n+  }\n+\n+  public List<FieldVector> getChildrenFromFields() {\n+    return getChildren();\n+  }\n+}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java\ndeleted file mode 100644\nindex e223d1ce6..000000000\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/NullableMapVector.java\n+++ /dev/null\n@@ -1,512 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- * <p>\n- * http://www.apache.org/licenses/LICENSE-2.0\n- * <p>\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.arrow.vector.complex;\n-\n-import static com.google.common.base.Preconditions.checkNotNull;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import com.google.common.collect.ObjectArrays;\n-\n-import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.memory.BaseAllocator;\n-import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.*;\n-import org.apache.arrow.vector.complex.impl.NullableMapReaderImpl;\n-import org.apache.arrow.vector.complex.impl.NullableMapWriter;\n-import org.apache.arrow.vector.holders.ComplexHolder;\n-import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n-import org.apache.arrow.vector.types.pojo.ArrowType;\n-import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n-import org.apache.arrow.vector.types.pojo.DictionaryEncoding;\n-import org.apache.arrow.vector.types.pojo.FieldType;\n-import org.apache.arrow.vector.types.pojo.Field;\n-import org.apache.arrow.vector.util.CallBack;\n-import org.apache.arrow.vector.util.OversizedAllocationException;\n-import org.apache.arrow.vector.util.TransferPair;\n-\n-public class NullableMapVector extends MapVector implements FieldVector {\n-\n-  public static NullableMapVector empty(String name, BufferAllocator allocator) {\n-    FieldType fieldType = FieldType.nullable(Struct.INSTANCE);\n-    return new NullableMapVector(name, allocator, fieldType, null);\n-  }\n-\n-  private final NullableMapReaderImpl reader = new NullableMapReaderImpl(this);\n-  private final NullableMapWriter writer = new NullableMapWriter(this);\n-\n-  protected ArrowBuf validityBuffer;\n-  private int validityAllocationSizeInBytes;\n-\n-  // deprecated, use FieldType or static constructor instead\n-  @Deprecated\n-  public NullableMapVector(String name, BufferAllocator allocator, CallBack callBack) {\n-    this(name, allocator, FieldType.nullable(ArrowType.Struct.INSTANCE), callBack);\n-  }\n-\n-  // deprecated, use FieldType or static constructor instead\n-  @Deprecated\n-  public NullableMapVector(String name, BufferAllocator allocator, DictionaryEncoding dictionary, CallBack callBack) {\n-    this(name, allocator, new FieldType(true, ArrowType.Struct.INSTANCE, dictionary, null), callBack);\n-  }\n-\n-  public NullableMapVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n-    super(name, checkNotNull(allocator), fieldType, callBack);\n-    this.validityBuffer = allocator.getEmpty();\n-    this.validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(BaseValueVector.INITIAL_VALUE_ALLOCATION);\n-  }\n-\n-  @Override\n-  public Field getField() {\n-    Field f = super.getField();\n-    FieldType type = new FieldType(true, f.getType(), f.getFieldType().getDictionary(), f.getFieldType().getMetadata());\n-    return new Field(f.getName(), type, f.getChildren());\n-  }\n-\n-  @Override\n-  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n-    if (ownBuffers.size() != 1) {\n-      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 1 + \", got: \" + ownBuffers.size());\n-    }\n-\n-    ArrowBuf bitBuffer = ownBuffers.get(0);\n-\n-    validityBuffer.release();\n-    validityBuffer = BitVectorHelper.loadValidityBuffer(fieldNode, bitBuffer, allocator);\n-    valueCount = fieldNode.getLength();\n-    validityAllocationSizeInBytes = validityBuffer.capacity();\n-  }\n-\n-  @Override\n-  public List<ArrowBuf> getFieldBuffers() {\n-    List<ArrowBuf> result = new ArrayList<>(1);\n-    setReaderAndWriterIndex();\n-    result.add(validityBuffer);\n-\n-    return result;\n-  }\n-\n-  private void setReaderAndWriterIndex() {\n-    validityBuffer.readerIndex(0);\n-    validityBuffer.writerIndex(BitVectorHelper.getValidityBufferSize(valueCount));\n-  }\n-\n-  @Override\n-  @Deprecated\n-  public List<BufferBacked> getFieldInnerVectors() {\n-    throw new UnsupportedOperationException(\"There are no inner vectors. Use getFieldBuffers\");\n-  }\n-\n-  @Override\n-  public NullableMapReaderImpl getReader() {\n-    return reader;\n-  }\n-\n-  public NullableMapWriter getWriter() {\n-    return writer;\n-  }\n-\n-  @Override\n-  public TransferPair getTransferPair(BufferAllocator allocator) {\n-    return new NullableMapTransferPair(this, new NullableMapVector(name, allocator, fieldType, null), false);\n-  }\n-\n-  @Override\n-  public TransferPair makeTransferPair(ValueVector to) {\n-    return new NullableMapTransferPair(this, (NullableMapVector) to, true);\n-  }\n-\n-  @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n-    return new NullableMapTransferPair(this, new NullableMapVector(ref, allocator, fieldType, null), false);\n-  }\n-\n-  @Override\n-  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n-    return new NullableMapTransferPair(this, new NullableMapVector(ref, allocator, fieldType, callBack), false);\n-  }\n-\n-  protected class NullableMapTransferPair extends MapTransferPair {\n-\n-    private NullableMapVector target;\n-\n-    protected NullableMapTransferPair(NullableMapVector from, NullableMapVector to, boolean allocate) {\n-      super(from, to, allocate);\n-      this.target = to;\n-    }\n-\n-    @Override\n-    public void transfer() {\n-      target.clear();\n-      target.validityBuffer = validityBuffer.transferOwnership(target.allocator).buffer;\n-      super.transfer();\n-      clear();\n-    }\n-\n-    @Override\n-    public void copyValueSafe(int fromIndex, int toIndex) {\n-      while (toIndex >= target.getValidityBufferValueCapacity()) {\n-        target.reallocValidityBuffer();\n-      }\n-      BitVectorHelper.setValidityBit(target.validityBuffer, toIndex, isSet(fromIndex));\n-      super.copyValueSafe(fromIndex, toIndex);\n-    }\n-\n-    @Override\n-    public void splitAndTransfer(int startIndex, int length) {\n-      target.clear();\n-      splitAndTransferValidityBuffer(startIndex, length, target);\n-      super.splitAndTransfer(startIndex, length);\n-    }\n-  }\n-\n-  /*\n-   * transfer the validity.\n-   */\n-  private void splitAndTransferValidityBuffer(int startIndex, int length, NullableMapVector target) {\n-    assert startIndex + length <= valueCount;\n-    int firstByteSource = BitVectorHelper.byteIndex(startIndex);\n-    int lastByteSource = BitVectorHelper.byteIndex(valueCount - 1);\n-    int byteSizeTarget = BitVectorHelper.getValidityBufferSize(length);\n-    int offset = startIndex % 8;\n-\n-    if (length > 0) {\n-      if (offset == 0) {\n-        // slice\n-        if (target.validityBuffer != null) {\n-          target.validityBuffer.release();\n-        }\n-        target.validityBuffer = validityBuffer.slice(firstByteSource, byteSizeTarget);\n-        target.validityBuffer.retain(1);\n-      } else {\n-        /* Copy data\n-         * When the first bit starts from the middle of a byte (offset != 0),\n-         * copy data from src BitVector.\n-         * Each byte in the target is composed by a part in i-th byte,\n-         * another part in (i+1)-th byte.\n-         */\n-        target.allocateValidityBuffer(byteSizeTarget);\n-\n-        for (int i = 0; i < byteSizeTarget - 1; i++) {\n-          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer, firstByteSource + i, offset);\n-          byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer, firstByteSource + i + 1, offset);\n-\n-          target.validityBuffer.setByte(i, (b1 + b2));\n-        }\n-\n-        /* Copying the last piece is done in the following manner:\n-         * if the source vector has 1 or more bytes remaining, we copy\n-         * the last piece as a byte formed by shifting data\n-         * from the current byte and the next byte.\n-         *\n-         * if the source vector has no more bytes remaining\n-         * (we are at the last byte), we copy the last piece as a byte\n-         * by shifting data from the current byte.\n-         */\n-        if ((firstByteSource + byteSizeTarget - 1) < lastByteSource) {\n-          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n-                  firstByteSource + byteSizeTarget - 1, offset);\n-          byte b2 = BitVectorHelper.getBitsFromNextByte(validityBuffer,\n-                  firstByteSource + byteSizeTarget, offset);\n-\n-          target.validityBuffer.setByte(byteSizeTarget - 1, b1 + b2);\n-        } else {\n-          byte b1 = BitVectorHelper.getBitsFromCurrentByte(validityBuffer,\n-                  firstByteSource + byteSizeTarget - 1, offset);\n-          target.validityBuffer.setByte(byteSizeTarget - 1, b1);\n-        }\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Get the value capacity of the internal validity buffer.\n-   * @return number of elements that validity buffer can hold\n-   */\n-  private int getValidityBufferValueCapacity() {\n-    return (int) (validityBuffer.capacity() * 8L);\n-  }\n-\n-  /**\n-   * Get the current value capacity for the vector\n-   * @return number of elements that vector can hold.\n-   */\n-  @Override\n-  public int getValueCapacity() {\n-    return Math.min(getValidityBufferValueCapacity(),\n-            super.getValueCapacity());\n-  }\n-\n-  /**\n-   * Return the underlying buffers associated with this vector. Note that this doesn't\n-   * impact the reference counts for this buffer so it only should be used for in-context\n-   * access. Also note that this buffer changes regularly thus\n-   * external classes shouldn't hold a reference to it (unless they change it).\n-   *\n-   * @param clear Whether to clear vector before returning; the buffers will still be refcounted\n-   *              but the returned array will be the only reference to them\n-   * @return The underlying {@link io.netty.buffer.ArrowBuf buffers} that is used by this\n-   *         vector instance.\n-   */\n-  @Override\n-  public ArrowBuf[] getBuffers(boolean clear) {\n-    setReaderAndWriterIndex();\n-    final ArrowBuf[] buffers;\n-    if (getBufferSize() == 0) {\n-      buffers = new ArrowBuf[0];\n-    } else {\n-      buffers = ObjectArrays.concat(new ArrowBuf[]{validityBuffer}, super.getBuffers(false),\n-              ArrowBuf.class);\n-    }\n-    if (clear) {\n-      for (ArrowBuf buffer : buffers) {\n-        buffer.retain();\n-      }\n-      clear();\n-    }\n-\n-    return buffers;\n-  }\n-\n-  /**\n-   * Close the vector and release the associated buffers.\n-   */\n-  @Override\n-  public void close() {\n-    clearValidityBuffer();\n-    super.close();\n-  }\n-\n-  /**\n-   * Same as {@link #close()}\n-   */\n-  @Override\n-  public void clear() {\n-    clearValidityBuffer();\n-    super.clear();\n-  }\n-\n-  /**\n-   * Release the validity buffer\n-   */\n-  private void clearValidityBuffer() {\n-    validityBuffer.release();\n-    validityBuffer = allocator.getEmpty();\n-  }\n-\n-  /**\n-   * Get the size (number of bytes) of underlying buffers used by this\n-   * vector\n-   * @return size of underlying buffers.\n-   */\n-  @Override\n-  public int getBufferSize() {\n-    if (valueCount == 0) {\n-      return 0;\n-    }\n-    return super.getBufferSize() +\n-            BitVectorHelper.getValidityBufferSize(valueCount);\n-  }\n-\n-  /**\n-   * Get the potential buffer size for a particular number of records.\n-   * @param valueCount desired number of elements in the vector\n-   * @return estimated size of underlying buffers if the vector holds\n-   *         a given number of elements\n-   */\n-  @Override\n-  public int getBufferSizeFor(final int valueCount) {\n-    if (valueCount == 0) {\n-      return 0;\n-    }\n-    return super.getBufferSizeFor(valueCount)\n-            + BitVectorHelper.getValidityBufferSize(valueCount);\n-  }\n-\n-  @Override\n-  public void setInitialCapacity(int numRecords) {\n-    validityAllocationSizeInBytes = BitVectorHelper.getValidityBufferSize(numRecords);\n-    super.setInitialCapacity(numRecords);\n-  }\n-\n-  @Override\n-  public boolean allocateNewSafe() {\n-    /* Boolean to keep track if all the memory allocations were successful\n-     * Used in the case of composite vectors when we need to allocate multiple\n-     * buffers for multiple vectors. If one of the allocations failed we need to\n-     * clear all the memory that we allocated\n-     */\n-    boolean success = false;\n-    try {\n-      clear();\n-      allocateValidityBuffer(validityAllocationSizeInBytes);\n-      success = super.allocateNewSafe();\n-    } finally {\n-      if (!success) {\n-        clear();\n-        return false;\n-      }\n-    }\n-    return true;\n-  }\n-\n-  private void allocateValidityBuffer(final long size) {\n-    final int curSize = (int) size;\n-    validityBuffer = allocator.buffer(curSize);\n-    validityBuffer.readerIndex(0);\n-    validityAllocationSizeInBytes = curSize;\n-    validityBuffer.setZero(0, validityBuffer.capacity());\n-  }\n-\n-  @Override\n-  public void reAlloc() {\n-    /* reallocate the validity buffer */\n-    reallocValidityBuffer();\n-    super.reAlloc();\n-  }\n-\n-  private void reallocValidityBuffer() {\n-    final int currentBufferCapacity = validityBuffer.capacity();\n-    long baseSize = validityAllocationSizeInBytes;\n-\n-    if (baseSize < (long) currentBufferCapacity) {\n-      baseSize = (long) currentBufferCapacity;\n-    }\n-\n-    long newAllocationSize = baseSize * 2L;\n-    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n-\n-    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n-      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n-    }\n-\n-    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n-    newBuf.setZero(0, newBuf.capacity());\n-    newBuf.setBytes(0, validityBuffer, 0, currentBufferCapacity);\n-    validityBuffer.release(1);\n-    validityBuffer = newBuf;\n-    validityAllocationSizeInBytes = (int) newAllocationSize;\n-  }\n-\n-  @Override\n-  public long getValidityBufferAddress() {\n-    return validityBuffer.memoryAddress();\n-  }\n-\n-  @Override\n-  public long getDataBufferAddress() {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public long getOffsetBufferAddress() {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public ArrowBuf getValidityBuffer() {\n-    return validityBuffer;\n-  }\n-\n-  @Override\n-  public ArrowBuf getDataBuffer() {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public ArrowBuf getOffsetBuffer() {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public Object getObject(int index) {\n-    if (isSet(index) == 0) {\n-      return null;\n-    } else {\n-      return super.getObject(index);\n-    }\n-  }\n-\n-  @Override\n-  public void get(int index, ComplexHolder holder) {\n-    holder.isSet = isSet(index);\n-    super.get(index, holder);\n-  }\n-\n-  public int getNullCount() {\n-    return BitVectorHelper.getNullCount(validityBuffer, valueCount);\n-  }\n-\n-  public boolean isNull(int index) {\n-    return isSet(index) == 0;\n-  }\n-\n-  public int isSet(int index) {\n-    final int byteIndex = index >> 3;\n-    final byte b = validityBuffer.getByte(byteIndex);\n-    final int bitIndex = index & 7;\n-    return Long.bitCount(b & (1L << bitIndex));\n-  }\n-\n-  public void setIndexDefined(int index) {\n-    while (index >= getValidityBufferValueCapacity()) {\n-      /* realloc the inner buffers if needed */\n-      reallocValidityBuffer();\n-    }\n-    BitVectorHelper.setValidityBitToOne(validityBuffer, index);\n-  }\n-\n-  public void setNull(int index) {\n-    while (index >= getValidityBufferValueCapacity()) {\n-      /* realloc the inner buffers if needed */\n-      reallocValidityBuffer();\n-    }\n-    BitVectorHelper.setValidityBit(validityBuffer, index, 0);\n-  }\n-\n-  @Override\n-  public void setValueCount(int valueCount) {\n-    assert valueCount >= 0;\n-    while (valueCount > getValidityBufferValueCapacity()) {\n-      /* realloc the inner buffers if needed */\n-      reallocValidityBuffer();\n-    }\n-    super.setValueCount(valueCount);\n-    this.valueCount = valueCount;\n-  }\n-\n-  public void reset() {\n-    valueCount = 0;\n-  }\n-\n-  @Override\n-  @Deprecated\n-  public Accessor getAccessor() {\n-    throw new UnsupportedOperationException(\"Accessor is not supported for reading from Nullable MAP\");\n-  }\n-\n-  @Override\n-  @Deprecated\n-  public Mutator getMutator() {\n-    throw new UnsupportedOperationException(\"Mutator is not supported for writing to Nullable MAP\");\n-  }\n-}\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/ComplexWriterImpl.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/ComplexWriterImpl.java\nindex a6960238b..970b90ef5 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/ComplexWriterImpl.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/ComplexWriterImpl.java\n@@ -20,7 +20,7 @@\n \n import org.apache.arrow.vector.complex.ListVector;\n import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.MapVector;\n import org.apache.arrow.vector.complex.StateTool;\n import org.apache.arrow.vector.complex.writer.BaseWriter.ComplexWriter;\n import org.apache.arrow.vector.types.pojo.Field;\n@@ -131,7 +131,7 @@ public MapWriter directMap() {\n     switch (mode) {\n \n       case INIT:\n-        mapRoot = nullableMapWriterFactory.build((NullableMapVector) container);\n+        mapRoot = nullableMapWriterFactory.build((MapVector) container);\n         mapRoot.setPosition(idx());\n         mode = Mode.MAP;\n         break;\n@@ -152,7 +152,7 @@ public MapWriter rootAsMap() {\n \n       case INIT:\n         // TODO allow dictionaries in complex types\n-        NullableMapVector map = container.addOrGetMap(name);\n+        MapVector map = container.addOrGetMap(name);\n         mapRoot = nullableMapWriterFactory.build(map);\n         mapRoot.setPosition(idx());\n         mode = Mode.MAP;\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java\nindex 06b0f4d43..acf155af7 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapReaderImpl.java\n@@ -20,17 +20,17 @@\n package org.apache.arrow.vector.complex.impl;\n \n import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.MapVector;\n import org.apache.arrow.vector.complex.writer.BaseWriter.MapWriter;\n import org.apache.arrow.vector.types.pojo.Field;\n \n public class NullableMapReaderImpl extends SingleMapReaderImpl {\n \n-  private NullableMapVector nullableMapVector;\n+  private MapVector nullableMapVector;\n \n   public NullableMapReaderImpl(MapVector vector) {\n-    super((NullableMapVector) vector);\n-    this.nullableMapVector = (NullableMapVector) vector;\n+    super((MapVector) vector);\n+    this.nullableMapVector = (MapVector) vector;\n   }\n \n   @Override\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapWriterFactory.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapWriterFactory.java\nindex d2dcb2374..06dbf784b 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapWriterFactory.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/NullableMapWriterFactory.java\n@@ -18,7 +18,7 @@\n \n package org.apache.arrow.vector.complex.impl;\n \n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.MapVector;\n \n public class NullableMapWriterFactory {\n   private final boolean caseSensitive;\n@@ -29,7 +29,7 @@ public NullableMapWriterFactory(boolean caseSensitive) {\n     this.caseSensitive = caseSensitive;\n   }\n \n-  public NullableMapWriter build(NullableMapVector container) {\n+  public NullableMapWriter build(MapVector container) {\n     return this.caseSensitive ? new NullableCaseSensitiveMapWriter(container) : new NullableMapWriter(container);\n   }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java\nindex 5bd439cac..9abd38d20 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/PromotableWriter.java\n@@ -23,7 +23,7 @@\n import org.apache.arrow.vector.ZeroVector;\n import org.apache.arrow.vector.complex.AbstractMapVector;\n import org.apache.arrow.vector.complex.ListVector;\n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.MapVector;\n import org.apache.arrow.vector.complex.UnionVector;\n import org.apache.arrow.vector.complex.writer.FieldWriter;\n import org.apache.arrow.vector.types.Types.MinorType;\n@@ -94,7 +94,7 @@ private void setWriter(ValueVector v) {\n     type = v.getMinorType();\n     switch (type) {\n       case MAP:\n-        writer = nullableMapWriterFactory.build((NullableMapVector) vector);\n+        writer = nullableMapWriterFactory.build((MapVector) vector);\n         break;\n       case LIST:\n         writer = new UnionListWriter((ListVector) vector, nullableMapWriterFactory);\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java\nindex c77ca4e8f..0341b622e 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/SingleMapReaderImpl.java\n@@ -24,6 +24,7 @@\n \n import org.apache.arrow.vector.ValueVector;\n import org.apache.arrow.vector.complex.MapVector;\n+import org.apache.arrow.vector.complex.NonNullableMapVector;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n import org.apache.arrow.vector.complex.writer.BaseWriter.MapWriter;\n import org.apache.arrow.vector.types.Types.MinorType;\n@@ -34,10 +35,10 @@\n @SuppressWarnings(\"unused\")\n public class SingleMapReaderImpl extends AbstractFieldReader {\n \n-  private final MapVector vector;\n+  private final NonNullableMapVector vector;\n   private final Map<String, FieldReader> fields = Maps.newHashMap();\n \n-  public SingleMapReaderImpl(MapVector vector) {\n+  public SingleMapReaderImpl(NonNullableMapVector vector) {\n     this.vector = vector;\n   }\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java\nindex 6243a2833..62bc27125 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/complex/impl/UnionListReader.java\n@@ -20,7 +20,6 @@\n package org.apache.arrow.vector.complex.impl;\n \n import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.vector.UInt4Vector;\n import org.apache.arrow.vector.ValueVector;\n import org.apache.arrow.vector.complex.ListVector;\n import org.apache.arrow.vector.complex.reader.FieldReader;\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileReader.java b/java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileReader.java\nindex cb11a2530..04d50331b 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileReader.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileReader.java\n@@ -222,7 +222,7 @@ protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException\n     BufferReader INT1 = new BufferReader() {\n       @Override\n       protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n-        final int size = count * NullableTinyIntVector.TYPE_WIDTH;\n+        final int size = count * TinyIntVector.TYPE_WIDTH;\n         ArrowBuf buf = allocator.buffer(size);\n \n         for (int i = 0; i < count; i++) {\n@@ -237,7 +237,7 @@ protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException\n     BufferReader INT2 = new BufferReader() {\n       @Override\n       protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n-        final int size = count * NullableSmallIntVector.TYPE_WIDTH;\n+        final int size = count * SmallIntVector.TYPE_WIDTH;\n         ArrowBuf buf = allocator.buffer(size);\n \n         for (int i = 0; i < count; i++) {\n@@ -252,7 +252,7 @@ protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException\n     BufferReader INT4 = new BufferReader() {\n       @Override\n       protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n-        final int size = count * NullableIntVector.TYPE_WIDTH;\n+        final int size = count * IntVector.TYPE_WIDTH;\n         ArrowBuf buf = allocator.buffer(size);\n \n         for (int i = 0; i < count; i++) {\n@@ -267,7 +267,7 @@ protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException\n     BufferReader INT8 = new BufferReader() {\n       @Override\n       protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n-        final int size = count * NullableBigIntVector.TYPE_WIDTH;\n+        final int size = count * BigIntVector.TYPE_WIDTH;\n         ArrowBuf buf = allocator.buffer(size);\n \n         for (int i = 0; i < count; i++) {\n@@ -282,7 +282,7 @@ protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException\n     BufferReader FLOAT4 = new BufferReader() {\n       @Override\n       protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n-        final int size = count * NullableFloat4Vector.TYPE_WIDTH;\n+        final int size = count * Float4Vector.TYPE_WIDTH;\n         ArrowBuf buf = allocator.buffer(size);\n \n         for (int i = 0; i < count; i++) {\n@@ -297,7 +297,7 @@ protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException\n     BufferReader FLOAT8 = new BufferReader() {\n       @Override\n       protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n-        final int size = count * NullableFloat8Vector.TYPE_WIDTH;\n+        final int size = count * Float8Vector.TYPE_WIDTH;\n         ArrowBuf buf = allocator.buffer(size);\n \n         for (int i = 0; i < count; i++) {\n@@ -312,7 +312,7 @@ protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException\n     BufferReader DECIMAL = new BufferReader() {\n       @Override\n       protected ArrowBuf read(BufferAllocator allocator, int count) throws IOException {\n-        final int size = count * NullableDecimalVector.TYPE_WIDTH;\n+        final int size = count * DecimalVector.TYPE_WIDTH;\n         ArrowBuf buf = allocator.buffer(size);\n \n         for (int i = 0; i < count; i++) {\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileWriter.java b/java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileWriter.java\nindex 22423b844..067fb25b8 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileWriter.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/ipc/JsonFileWriter.java\n@@ -160,8 +160,8 @@ private void writeFromVectorIntoJson(Field field, FieldVector vector) throws IOE\n       generator.writeObjectField(\"name\", field.getName());\n       int valueCount = vector.getValueCount();\n       generator.writeObjectField(\"count\", valueCount);\n-      final int scale = (vector instanceof NullableDecimalVector) ?\n-                            ((NullableDecimalVector) vector).getScale() : 0;\n+      final int scale = (vector instanceof DecimalVector) ?\n+                            ((DecimalVector) vector).getScale() : 0;\n       for (int v = 0; v < vectorTypes.size(); v++) {\n         ArrowVectorType vectorType = vectorTypes.get(v);\n         ArrowBuf vectorBuffer = vectorBuffers.get(v);\n@@ -199,86 +199,86 @@ private void writeValueToGenerator(ArrowVectorType bufferType, ArrowBuf buffer,\n                                      ArrowBuf offsetBuffer, FieldVector vector,\n                                      final int index, final int scale) throws IOException {\n     if (bufferType.equals(TYPE)) {\n-      generator.writeNumber(buffer.getByte(index * NullableTinyIntVector.TYPE_WIDTH));\n+      generator.writeNumber(buffer.getByte(index * TinyIntVector.TYPE_WIDTH));\n     } else if (bufferType.equals(OFFSET)) {\n-      generator.writeNumber(buffer.getInt(index * BaseNullableVariableWidthVector.OFFSET_WIDTH));\n+      generator.writeNumber(buffer.getInt(index * BaseVariableWidthVector.OFFSET_WIDTH));\n     } else if(bufferType.equals(VALIDITY)) {\n       generator.writeNumber(vector.isNull(index) ? 0 : 1);\n     } else if (bufferType.equals(DATA)) {\n       switch (vector.getMinorType()) {\n         case TINYINT:\n-          generator.writeNumber(NullableTinyIntVector.get(buffer, index));\n+          generator.writeNumber(TinyIntVector.get(buffer, index));\n           break;\n         case SMALLINT:\n-          generator.writeNumber(NullableSmallIntVector.get(buffer, index));\n+          generator.writeNumber(SmallIntVector.get(buffer, index));\n           break;\n         case INT:\n-          generator.writeNumber(NullableIntVector.get(buffer, index));\n+          generator.writeNumber(IntVector.get(buffer, index));\n           break;\n         case BIGINT:\n-          generator.writeNumber(NullableBigIntVector.get(buffer, index));\n+          generator.writeNumber(BigIntVector.get(buffer, index));\n           break;\n         case FLOAT4:\n-          generator.writeNumber(NullableFloat4Vector.get(buffer, index));\n+          generator.writeNumber(Float4Vector.get(buffer, index));\n           break;\n         case FLOAT8:\n-          generator.writeNumber(NullableFloat8Vector.get(buffer, index));\n+          generator.writeNumber(Float8Vector.get(buffer, index));\n           break;\n         case DATEDAY:\n-          generator.writeNumber(NullableDateDayVector.get(buffer, index));\n+          generator.writeNumber(DateDayVector.get(buffer, index));\n           break;\n         case DATEMILLI:\n-          generator.writeNumber(NullableDateMilliVector.get(buffer, index));\n+          generator.writeNumber(DateMilliVector.get(buffer, index));\n           break;\n         case TIMESEC:\n-          generator.writeNumber(NullableTimeSecVector.get(buffer, index));\n+          generator.writeNumber(TimeSecVector.get(buffer, index));\n           break;\n         case TIMEMILLI:\n-          generator.writeNumber(NullableTimeMilliVector.get(buffer, index));\n+          generator.writeNumber(TimeMilliVector.get(buffer, index));\n           break;\n         case TIMEMICRO:\n-          generator.writeNumber(NullableTimeMicroVector.get(buffer, index));\n+          generator.writeNumber(TimeMicroVector.get(buffer, index));\n           break;\n         case TIMENANO:\n-          generator.writeNumber(NullableTimeNanoVector.get(buffer, index));\n+          generator.writeNumber(TimeNanoVector.get(buffer, index));\n           break;\n         case TIMESTAMPSEC:\n-          generator.writeNumber(NullableTimeStampSecVector.get(buffer, index));\n+          generator.writeNumber(TimeStampSecVector.get(buffer, index));\n           break;\n         case TIMESTAMPMILLI:\n-          generator.writeNumber(NullableTimeStampMilliVector.get(buffer, index));\n+          generator.writeNumber(TimeStampMilliVector.get(buffer, index));\n           break;\n         case TIMESTAMPMICRO:\n-          generator.writeNumber(NullableTimeStampMicroVector.get(buffer, index));\n+          generator.writeNumber(TimeStampMicroVector.get(buffer, index));\n           break;\n         case TIMESTAMPNANO:\n-          generator.writeNumber(NullableTimeStampNanoVector.get(buffer, index));\n+          generator.writeNumber(TimeStampNanoVector.get(buffer, index));\n           break;\n         case TIMESTAMPSECTZ:\n-          generator.writeNumber(NullableTimeStampSecTZVector.get(buffer, index));\n+          generator.writeNumber(TimeStampSecTZVector.get(buffer, index));\n           break;\n         case TIMESTAMPMILLITZ:\n-          generator.writeNumber(NullableTimeStampMilliTZVector.get(buffer, index));\n+          generator.writeNumber(TimeStampMilliTZVector.get(buffer, index));\n           break;\n         case TIMESTAMPMICROTZ:\n-          generator.writeNumber(NullableTimeStampMicroTZVector.get(buffer, index));\n+          generator.writeNumber(TimeStampMicroTZVector.get(buffer, index));\n           break;\n         case TIMESTAMPNANOTZ:\n-          generator.writeNumber(NullableTimeStampNanoTZVector.get(buffer, index));\n+          generator.writeNumber(TimeStampNanoTZVector.get(buffer, index));\n           break;\n         case BIT:\n           generator.writeNumber(BitVectorHelper.get(buffer, index));\n           break;\n         case VARBINARY: {\n           assert offsetBuffer != null;\n-          String hexString = Hex.encodeHexString(BaseNullableVariableWidthVector.get(buffer,\n+          String hexString = Hex.encodeHexString(BaseVariableWidthVector.get(buffer,\n                   offsetBuffer, index));\n           generator.writeObject(hexString);\n           break;\n         }\n         case VARCHAR: {\n           assert offsetBuffer != null;\n-          byte[] b = (BaseNullableVariableWidthVector.get(buffer, offsetBuffer, index));\n+          byte[] b = (BaseVariableWidthVector.get(buffer, offsetBuffer, index));\n           generator.writeString(new String(b, \"UTF-8\"));\n           break;\n         }\ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/types/Types.java b/java/vector/src/main/java/org/apache/arrow/vector/types/Types.java\nindex c57dd6daf..7834845aa 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/types/Types.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/types/Types.java\n@@ -24,41 +24,41 @@\n \n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.NullableBigIntVector;\n-import org.apache.arrow.vector.NullableBitVector;\n-import org.apache.arrow.vector.NullableDateDayVector;\n-import org.apache.arrow.vector.NullableDateMilliVector;\n-import org.apache.arrow.vector.NullableDecimalVector;\n-import org.apache.arrow.vector.NullableFloat4Vector;\n-import org.apache.arrow.vector.NullableFloat8Vector;\n-import org.apache.arrow.vector.NullableIntVector;\n-import org.apache.arrow.vector.NullableIntervalDayVector;\n-import org.apache.arrow.vector.NullableIntervalYearVector;\n-import org.apache.arrow.vector.NullableSmallIntVector;\n-import org.apache.arrow.vector.NullableTimeMicroVector;\n-import org.apache.arrow.vector.NullableTimeMilliVector;\n-import org.apache.arrow.vector.NullableTimeNanoVector;\n-import org.apache.arrow.vector.NullableTimeSecVector;\n-import org.apache.arrow.vector.NullableTimeStampMicroTZVector;\n-import org.apache.arrow.vector.NullableTimeStampMicroVector;\n-import org.apache.arrow.vector.NullableTimeStampMilliTZVector;\n-import org.apache.arrow.vector.NullableTimeStampMilliVector;\n-import org.apache.arrow.vector.NullableTimeStampNanoTZVector;\n-import org.apache.arrow.vector.NullableTimeStampNanoVector;\n-import org.apache.arrow.vector.NullableTimeStampSecTZVector;\n-import org.apache.arrow.vector.NullableTimeStampSecVector;\n-import org.apache.arrow.vector.NullableTinyIntVector;\n-import org.apache.arrow.vector.NullableUInt1Vector;\n-import org.apache.arrow.vector.NullableUInt2Vector;\n-import org.apache.arrow.vector.NullableUInt4Vector;\n-import org.apache.arrow.vector.NullableUInt8Vector;\n-import org.apache.arrow.vector.NullableVarBinaryVector;\n-import org.apache.arrow.vector.NullableVarCharVector;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateDayVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.IntervalDayVector;\n+import org.apache.arrow.vector.IntervalYearVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMicroVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeNanoVector;\n+import org.apache.arrow.vector.TimeSecVector;\n+import org.apache.arrow.vector.TimeStampMicroTZVector;\n+import org.apache.arrow.vector.TimeStampMicroVector;\n+import org.apache.arrow.vector.TimeStampMilliTZVector;\n+import org.apache.arrow.vector.TimeStampMilliVector;\n+import org.apache.arrow.vector.TimeStampNanoTZVector;\n+import org.apache.arrow.vector.TimeStampNanoVector;\n+import org.apache.arrow.vector.TimeStampSecTZVector;\n+import org.apache.arrow.vector.TimeStampSecVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.UInt1Vector;\n+import org.apache.arrow.vector.UInt2Vector;\n+import org.apache.arrow.vector.UInt4Vector;\n+import org.apache.arrow.vector.UInt8Vector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n import org.apache.arrow.vector.ValueVector;\n import org.apache.arrow.vector.ZeroVector;\n import org.apache.arrow.vector.complex.FixedSizeListVector;\n import org.apache.arrow.vector.complex.ListVector;\n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.MapVector;\n import org.apache.arrow.vector.complex.UnionVector;\n import org.apache.arrow.vector.complex.impl.BigIntWriterImpl;\n import org.apache.arrow.vector.complex.impl.BitWriterImpl;\n@@ -131,304 +131,304 @@ public FieldWriter getNewFieldWriter(ValueVector vector) {\n     MAP(Struct.INSTANCE) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableMapVector(name, allocator, fieldType, schemaChangeCallback);\n+        return new MapVector(name, allocator, fieldType, schemaChangeCallback);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new NullableMapWriter((NullableMapVector) vector);\n+        return new NullableMapWriter((MapVector) vector);\n       }\n     },\n     TINYINT(new Int(8, true)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTinyIntVector(name, fieldType, allocator);\n+        return new TinyIntVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TinyIntWriterImpl((NullableTinyIntVector) vector);\n+        return new TinyIntWriterImpl((TinyIntVector) vector);\n       }\n     },\n     SMALLINT(new Int(16, true)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableSmallIntVector(name, fieldType, allocator);\n+        return new SmallIntVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new SmallIntWriterImpl((NullableSmallIntVector) vector);\n+        return new SmallIntWriterImpl((SmallIntVector) vector);\n       }\n     },\n     INT(new Int(32, true)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableIntVector(name, fieldType, allocator);\n+        return new IntVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new IntWriterImpl((NullableIntVector) vector);\n+        return new IntWriterImpl((IntVector) vector);\n       }\n     },\n     BIGINT(new Int(64, true)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableBigIntVector(name, fieldType, allocator);\n+        return new BigIntVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new BigIntWriterImpl((NullableBigIntVector) vector);\n+        return new BigIntWriterImpl((BigIntVector) vector);\n       }\n     },\n     DATEDAY(new Date(DateUnit.DAY)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableDateDayVector(name, fieldType, allocator);\n+        return new DateDayVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new DateDayWriterImpl((NullableDateDayVector) vector);\n+        return new DateDayWriterImpl((DateDayVector) vector);\n       }\n     },\n     DATEMILLI(new Date(DateUnit.MILLISECOND)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableDateMilliVector(name, fieldType, allocator);\n+        return new DateMilliVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new DateMilliWriterImpl((NullableDateMilliVector) vector);\n+        return new DateMilliWriterImpl((DateMilliVector) vector);\n       }\n     },\n     TIMESEC(new Time(TimeUnit.SECOND, 32)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTimeSecVector(name, fieldType, allocator);\n+        return new TimeSecVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TimeSecWriterImpl((NullableTimeSecVector) vector);\n+        return new TimeSecWriterImpl((TimeSecVector) vector);\n       }\n     },\n     TIMEMILLI(new Time(TimeUnit.MILLISECOND, 32)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTimeMilliVector(name, fieldType, allocator);\n+        return new TimeMilliVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TimeMilliWriterImpl((NullableTimeMilliVector) vector);\n+        return new TimeMilliWriterImpl((TimeMilliVector) vector);\n       }\n     },\n     TIMEMICRO(new Time(TimeUnit.MICROSECOND, 64)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTimeMicroVector(name, fieldType, allocator);\n+        return new TimeMicroVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TimeMicroWriterImpl((NullableTimeMicroVector) vector);\n+        return new TimeMicroWriterImpl((TimeMicroVector) vector);\n       }\n     },\n     TIMENANO(new Time(TimeUnit.NANOSECOND, 64)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTimeNanoVector(name, fieldType, allocator);\n+        return new TimeNanoVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TimeNanoWriterImpl((NullableTimeNanoVector) vector);\n+        return new TimeNanoWriterImpl((TimeNanoVector) vector);\n       }\n     },\n     // time in second from the Unix epoch, 00:00:00.000000 on 1 January 1970, UTC.\n     TIMESTAMPSEC(new Timestamp(org.apache.arrow.vector.types.TimeUnit.SECOND, null)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTimeStampSecVector(name, fieldType, allocator);\n+        return new TimeStampSecVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TimeStampSecWriterImpl((NullableTimeStampSecVector) vector);\n+        return new TimeStampSecWriterImpl((TimeStampSecVector) vector);\n       }\n     },\n     // time in millis from the Unix epoch, 00:00:00.000 on 1 January 1970, UTC.\n     TIMESTAMPMILLI(new Timestamp(org.apache.arrow.vector.types.TimeUnit.MILLISECOND, null)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTimeStampMilliVector(name, fieldType, allocator);\n+        return new TimeStampMilliVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TimeStampMilliWriterImpl((NullableTimeStampMilliVector) vector);\n+        return new TimeStampMilliWriterImpl((TimeStampMilliVector) vector);\n       }\n     },\n     // time in microsecond from the Unix epoch, 00:00:00.000000 on 1 January 1970, UTC.\n     TIMESTAMPMICRO(new Timestamp(org.apache.arrow.vector.types.TimeUnit.MICROSECOND, null)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTimeStampMicroVector(name, fieldType, allocator);\n+        return new TimeStampMicroVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TimeStampMicroWriterImpl((NullableTimeStampMicroVector) vector);\n+        return new TimeStampMicroWriterImpl((TimeStampMicroVector) vector);\n       }\n     },\n     // time in nanosecond from the Unix epoch, 00:00:00.000000000 on 1 January 1970, UTC.\n     TIMESTAMPNANO(new Timestamp(org.apache.arrow.vector.types.TimeUnit.NANOSECOND, null)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTimeStampNanoVector(name, fieldType, allocator);\n+        return new TimeStampNanoVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TimeStampNanoWriterImpl((NullableTimeStampNanoVector) vector);\n+        return new TimeStampNanoWriterImpl((TimeStampNanoVector) vector);\n       }\n     },\n     INTERVALDAY(new Interval(IntervalUnit.DAY_TIME)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableIntervalDayVector(name, fieldType, allocator);\n+        return new IntervalDayVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new IntervalDayWriterImpl((NullableIntervalDayVector) vector);\n+        return new IntervalDayWriterImpl((IntervalDayVector) vector);\n       }\n     },\n     INTERVALYEAR(new Interval(IntervalUnit.YEAR_MONTH)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableIntervalYearVector(name, fieldType, allocator);\n+        return new IntervalYearVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new IntervalYearWriterImpl((NullableIntervalYearVector) vector);\n+        return new IntervalYearWriterImpl((IntervalYearVector) vector);\n       }\n     },\n     //  4 byte ieee 754\n     FLOAT4(new FloatingPoint(SINGLE)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableFloat4Vector(name, fieldType, allocator);\n+        return new Float4Vector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new Float4WriterImpl((NullableFloat4Vector) vector);\n+        return new Float4WriterImpl((Float4Vector) vector);\n       }\n     },\n     //  8 byte ieee 754\n     FLOAT8(new FloatingPoint(DOUBLE)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableFloat8Vector(name, fieldType, allocator);\n+        return new Float8Vector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new Float8WriterImpl((NullableFloat8Vector) vector);\n+        return new Float8WriterImpl((Float8Vector) vector);\n       }\n     },\n     BIT(Bool.INSTANCE) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableBitVector(name, fieldType, allocator);\n+        return new BitVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new BitWriterImpl((NullableBitVector) vector);\n+        return new BitWriterImpl((BitVector) vector);\n       }\n     },\n     VARCHAR(Utf8.INSTANCE) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableVarCharVector(name, fieldType, allocator);\n+        return new VarCharVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new VarCharWriterImpl((NullableVarCharVector) vector);\n+        return new VarCharWriterImpl((VarCharVector) vector);\n       }\n     },\n     VARBINARY(Binary.INSTANCE) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableVarBinaryVector(name, fieldType, allocator);\n+        return new VarBinaryVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new VarBinaryWriterImpl((NullableVarBinaryVector) vector);\n+        return new VarBinaryWriterImpl((VarBinaryVector) vector);\n       }\n     },\n     DECIMAL(null) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableDecimalVector(name, fieldType, allocator);\n+        return new DecimalVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new DecimalWriterImpl((NullableDecimalVector) vector);\n+        return new DecimalWriterImpl((DecimalVector) vector);\n       }\n     },\n     UINT1(new Int(8, false)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableUInt1Vector(name, fieldType, allocator);\n+        return new UInt1Vector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new UInt1WriterImpl((NullableUInt1Vector) vector);\n+        return new UInt1WriterImpl((UInt1Vector) vector);\n       }\n     },\n     UINT2(new Int(16, false)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableUInt2Vector(name, fieldType, allocator);\n+        return new UInt2Vector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new UInt2WriterImpl((NullableUInt2Vector) vector);\n+        return new UInt2WriterImpl((UInt2Vector) vector);\n       }\n     },\n     UINT4(new Int(32, false)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableUInt4Vector(name, fieldType, allocator);\n+        return new UInt4Vector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new UInt4WriterImpl((NullableUInt4Vector) vector);\n+        return new UInt4WriterImpl((UInt4Vector) vector);\n       }\n     },\n     UINT8(new Int(64, false)) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableUInt8Vector(name, fieldType, allocator);\n+        return new UInt8Vector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new UInt8WriterImpl((NullableUInt8Vector) vector);\n+        return new UInt8WriterImpl((UInt8Vector) vector);\n       }\n     },\n     LIST(List.INSTANCE) {\n@@ -470,45 +470,45 @@ public FieldWriter getNewFieldWriter(ValueVector vector) {\n     TIMESTAMPSECTZ(null) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTimeStampSecTZVector(name, fieldType, allocator);\n+        return new TimeStampSecTZVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TimeStampSecTZWriterImpl((NullableTimeStampSecTZVector) vector);\n+        return new TimeStampSecTZWriterImpl((TimeStampSecTZVector) vector);\n       }\n     },\n     TIMESTAMPMILLITZ(null) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTimeStampMilliTZVector(name, fieldType, allocator);\n+        return new TimeStampMilliTZVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TimeStampMilliTZWriterImpl((NullableTimeStampMilliTZVector) vector);\n+        return new TimeStampMilliTZWriterImpl((TimeStampMilliTZVector) vector);\n       }\n     },\n     TIMESTAMPMICROTZ(null) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTimeStampMicroTZVector(name, fieldType, allocator);\n+        return new TimeStampMicroTZVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TimeStampMicroTZWriterImpl((NullableTimeStampMicroTZVector) vector);\n+        return new TimeStampMicroTZWriterImpl((TimeStampMicroTZVector) vector);\n       }\n     },\n     TIMESTAMPNANOTZ(null) {\n       @Override\n       public FieldVector getNewVector(String name, FieldType fieldType, BufferAllocator allocator, CallBack schemaChangeCallback) {\n-        return new NullableTimeStampNanoTZVector(name, fieldType, allocator);\n+        return new TimeStampNanoTZVector(name, fieldType, allocator);\n       }\n \n       @Override\n       public FieldWriter getNewFieldWriter(ValueVector vector) {\n-        return new TimeStampNanoTZWriterImpl((NullableTimeStampNanoTZVector) vector);\n+        return new TimeStampNanoTZWriterImpl((TimeStampNanoTZVector) vector);\n       }\n     };\n \ndiff --git a/java/vector/src/main/java/org/apache/arrow/vector/util/DecimalUtility.java b/java/vector/src/main/java/org/apache/arrow/vector/util/DecimalUtility.java\nindex acf7c58a1..c6d734d18 100644\n--- a/java/vector/src/main/java/org/apache/arrow/vector/util/DecimalUtility.java\n+++ b/java/vector/src/main/java/org/apache/arrow/vector/util/DecimalUtility.java\n@@ -19,7 +19,6 @@\n package org.apache.arrow.vector.util;\n \n import io.netty.buffer.ArrowBuf;\n-import org.apache.arrow.vector.DecimalVector;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n \n import java.math.BigDecimal;\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\nindex ada341497..36365fa9d 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestBitVector.java\n@@ -55,17 +55,17 @@ public void testBitVectorCopyFromSafe() {\n       dst.allocateNew(10);\n \n       for (int i = 0; i < size; i++) {\n-        src.getMutator().set(i, i % 2);\n+        src.set(i, i % 2);\n       }\n-      src.getMutator().setValueCount(size);\n+      src.setValueCount(size);\n \n       for (int i = 0; i < size; i++) {\n         dst.copyFromSafe(i, i, src);\n       }\n-      dst.getMutator().setValueCount(size);\n+      dst.setValueCount(size);\n \n       for (int i = 0; i < size; i++) {\n-        assertEquals(src.getAccessor().getObject(i), dst.getAccessor().getObject(i));\n+        assertEquals(src.getObject(i), dst.getObject(i));\n       }\n     }\n   }\n@@ -74,25 +74,23 @@ public void testBitVectorCopyFromSafe() {\n   public void testSplitAndTransfer() throws Exception {\n \n     try (final BitVector sourceVector = new BitVector(\"bitvector\", allocator)) {\n-      final BitVector.Mutator sourceMutator = sourceVector.getMutator();\n-      final BitVector.Accessor sourceAccessor = sourceVector.getAccessor();\n \n       sourceVector.allocateNew(40);\n \n       /* populate the bitvector -- 010101010101010101010101..... */\n       for (int i = 0; i < 40; i++) {\n         if ((i & 1) == 1) {\n-          sourceMutator.set(i, 1);\n+          sourceVector.set(i, 1);\n         } else {\n-          sourceMutator.set(i, 0);\n+          sourceVector.set(i, 0);\n         }\n       }\n \n-      sourceMutator.setValueCount(40);\n+      sourceVector.setValueCount(40);\n \n       /* check the vector output */\n       for (int i = 0; i < 40; i++) {\n-        int result = sourceAccessor.get(i);\n+        int result = sourceVector.get(i);\n         if ((i & 1) == 1) {\n           assertEquals(Integer.toString(1), Integer.toString(result));\n         } else {\n@@ -102,8 +100,6 @@ public void testSplitAndTransfer() throws Exception {\n \n       try (final BitVector toVector = new BitVector(\"toVector\", allocator)) {\n         final TransferPair transferPair = sourceVector.makeTransferPair(toVector);\n-        final BitVector.Accessor toAccessor = toVector.getAccessor();\n-        final BitVector.Mutator toMutator = toVector.getMutator();\n \n         /*\n          * form test cases such that we cover:\n@@ -123,8 +119,8 @@ public void testSplitAndTransfer() throws Exception {\n \n           /* check the toVector output after doing splitAndTransfer */\n           for (int i = 0; i < length; i++) {\n-            int actual = toAccessor.get(i);\n-            int expected = sourceAccessor.get(start + i);\n+            int actual = toVector.get(i);\n+            int expected = sourceVector.get(start + i);\n             assertEquals(\"different data values not expected --> sourceVector index: \" + (start + i) + \" toVector index: \" + i,\n                     expected, actual);\n           }\n@@ -137,28 +133,24 @@ public void testSplitAndTransfer() throws Exception {\n   public void testSplitAndTransfer1() throws Exception {\n \n     try (final BitVector sourceVector = new BitVector(\"bitvector\", allocator)) {\n-      final BitVector.Mutator sourceMutator = sourceVector.getMutator();\n-      final BitVector.Accessor sourceAccessor = sourceVector.getAccessor();\n \n       sourceVector.allocateNew(8190);\n \n       /* populate the bitvector */\n       for (int i = 0; i < 8190; i++) {\n-        sourceMutator.set(i, 1);\n+        sourceVector.set(i, 1);\n       }\n \n-      sourceMutator.setValueCount(8190);\n+      sourceVector.setValueCount(8190);\n \n       /* check the vector output */\n       for (int i = 0; i < 8190; i++) {\n-        int result = sourceAccessor.get(i);\n+        int result = sourceVector.get(i);\n         assertEquals(Integer.toString(1), Integer.toString(result));\n       }\n \n       try (final BitVector toVector = new BitVector(\"toVector\", allocator)) {\n         final TransferPair transferPair = sourceVector.makeTransferPair(toVector);\n-        final BitVector.Accessor toAccessor = toVector.getAccessor();\n-        final BitVector.Mutator toMutator = toVector.getMutator();\n \n         final int[][] transferLengths = {{0, 4095}, {4095, 4095}};\n \n@@ -170,8 +162,8 @@ public void testSplitAndTransfer1() throws Exception {\n \n           /* check the toVector output after doing splitAndTransfer */\n           for (int i = 0; i < length; i++) {\n-            int actual = toAccessor.get(i);\n-            int expected = sourceAccessor.get(start + i);\n+            int actual = toVector.get(i);\n+            int expected = sourceVector.get(start + i);\n             assertEquals(\"different data values not expected --> sourceVector index: \" + (start + i) + \" toVector index: \" + i,\n                     expected, actual);\n           }\n@@ -184,25 +176,23 @@ public void testSplitAndTransfer1() throws Exception {\n   public void testSplitAndTransfer2() throws Exception {\n \n     try (final BitVector sourceVector = new BitVector(\"bitvector\", allocator)) {\n-      final BitVector.Mutator sourceMutator = sourceVector.getMutator();\n-      final BitVector.Accessor sourceAccessor = sourceVector.getAccessor();\n \n       sourceVector.allocateNew(32);\n \n       /* populate the bitvector */\n       for (int i = 0; i < 32; i++) {\n         if ((i & 1) == 1) {\n-          sourceMutator.set(i, 1);\n+          sourceVector.set(i, 1);\n         } else {\n-          sourceMutator.set(i, 0);\n+          sourceVector.set(i, 0);\n         }\n       }\n \n-      sourceMutator.setValueCount(32);\n+      sourceVector.setValueCount(32);\n \n       /* check the vector output */\n       for (int i = 0; i < 32; i++) {\n-        int result = sourceAccessor.get(i);\n+        int result = sourceVector.get(i);\n         if ((i & 1) == 1) {\n           assertEquals(Integer.toString(1), Integer.toString(result));\n         } else {\n@@ -212,8 +202,6 @@ public void testSplitAndTransfer2() throws Exception {\n \n       try (final BitVector toVector = new BitVector(\"toVector\", allocator)) {\n         final TransferPair transferPair = sourceVector.makeTransferPair(toVector);\n-        final BitVector.Accessor toAccessor = toVector.getAccessor();\n-        final BitVector.Mutator toMutator = toVector.getMutator();\n \n         final int[][] transferLengths = {{5,22}, {5,24}, {5,25}, {5,27}, {0,31}, {5,7}, {2,3}};\n \n@@ -225,8 +213,8 @@ public void testSplitAndTransfer2() throws Exception {\n \n           /* check the toVector output after doing splitAndTransfer */\n           for (int i = 0; i < length; i++) {\n-            int actual = toAccessor.get(i);\n-            int expected = sourceAccessor.get(start + i);\n+            int actual = toVector.get(i);\n+            int expected = sourceVector.get(start + i);\n             assertEquals(\"different data values not expected --> sourceVector index: \" + (start + i) + \" toVector index: \" + i,\n                     expected, actual);\n           }\n@@ -242,62 +230,56 @@ public void testReallocAfterVectorTransfer1() {\n       int valueCapacity = vector.getValueCapacity();\n       assertEquals(4096, valueCapacity);\n \n-      final BitVector.Mutator mutator = vector.getMutator();\n-      final BitVector.Accessor accessor = vector.getAccessor();\n-\n       for (int i = 0; i < valueCapacity; i++) {\n         if ((i & 1) == 1) {\n-          mutator.setToOne(i);\n+          vector.set(i, 1);\n         }\n       }\n \n       for (int i = 0; i < valueCapacity; i++) {\n-        int val = accessor.get(i);\n         if ((i & 1) == 1) {\n-          assertEquals(\"unexpected cleared bit at index: \" + i, 1, val);\n+          assertEquals(\"unexpected cleared bit at index: \" + i, 1, vector.get(i));\n         }\n         else {\n-          assertEquals(\"unexpected set bit at index: \" + i, 0, val);\n+          assertTrue(\"unexpected set bit at index: \" + i, vector.isNull(i));\n         }\n       }\n \n       /* trigger first realloc */\n-      mutator.setSafeToOne(valueCapacity);\n+      vector.setSafe(valueCapacity, 1);\n       assertEquals(valueCapacity * 2, vector.getValueCapacity());\n \n       for (int i = valueCapacity; i < valueCapacity*2; i++) {\n         if ((i & 1) == 1) {\n-          mutator.setToOne(i);\n+          vector.set(i, 1);\n         }\n       }\n \n       for (int i = 0; i < valueCapacity*2; i++) {\n-        int val = accessor.get(i);\n         if (((i & 1) == 1) || (i == valueCapacity)) {\n-          assertEquals(\"unexpected cleared bit at index: \" + i, 1, val);\n+          assertEquals(\"unexpected cleared bit at index: \" + i, 1, vector.get(i));\n         }\n         else {\n-          assertEquals(\"unexpected set bit at index: \" + i, 0, val);\n+          assertTrue(\"unexpected set bit at index: \" + i, vector.isNull(i));\n         }\n       }\n \n       /* trigger second realloc */\n-      mutator.setSafeToOne(valueCapacity*2);\n+      vector.setSafe(valueCapacity*2, 1);\n       assertEquals(valueCapacity * 4, vector.getValueCapacity());\n \n       for (int i = valueCapacity*2; i < valueCapacity*4; i++) {\n         if ((i & 1) == 1) {\n-          mutator.setToOne(i);\n+          vector.set(i, 1);\n         }\n       }\n \n       for (int i = 0; i < valueCapacity*4; i++) {\n-        int val = accessor.get(i);\n         if (((i & 1) == 1) || (i == valueCapacity) || (i == valueCapacity*2)) {\n-          assertEquals(\"unexpected cleared bit at index: \" + i, 1, val);\n+          assertEquals(\"unexpected cleared bit at index: \" + i, 1, vector.get(i));\n         }\n         else {\n-          assertEquals(\"unexpected set bit at index: \" + i, 0, val);\n+          assertTrue(\"unexpected set bit at index: \" + i, vector.isNull(i));\n         }\n       }\n \n@@ -305,27 +287,24 @@ public void testReallocAfterVectorTransfer1() {\n       TransferPair transferPair = vector.getTransferPair(allocator);\n       transferPair.transfer();\n       final BitVector toVector = (BitVector)transferPair.getTo();\n-      final BitVector.Accessor toAccessor = toVector.getAccessor();\n-      final BitVector.Mutator toMutator = toVector.getMutator();\n \n       assertEquals(valueCapacity * 4, toVector.getValueCapacity());\n \n       /* realloc the toVector */\n-      toMutator.setSafeToOne(valueCapacity * 4);\n+      toVector.setSafe(valueCapacity * 4, 1);\n \n       for (int i = 0; i < toVector.getValueCapacity(); i++) {\n-        int val = toAccessor.get(i);\n         if (i <= valueCapacity * 4) {\n           if (((i & 1) == 1) || (i == valueCapacity) ||\n                   (i == valueCapacity*2) || (i == valueCapacity*4)) {\n-            assertEquals(\"unexpected cleared bit at index: \" + i, 1, val);\n+            assertEquals(\"unexpected cleared bit at index: \" + i, 1, toVector.get(i));\n           }\n           else {\n-            assertEquals(\"unexpected set bit at index: \" + i, 0, val);\n+            assertTrue(\"unexpected set bit at index: \" + i, toVector.isNull(i));\n           }\n         }\n         else {\n-          assertEquals(\"unexpected set bit at index: \" + i, 0, val);\n+          assertTrue(\"unexpected set bit at index: \" + i, toVector.isNull(i));\n         }\n       }\n \n@@ -335,7 +314,7 @@ public void testReallocAfterVectorTransfer1() {\n \n   @Test\n   public void testReallocAfterVectorTransfer2() {\n-    try (final NullableBitVector vector = new NullableBitVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final BitVector vector = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n       vector.allocateNew(4096);\n       int valueCapacity = vector.getValueCapacity();\n       assertEquals(4096, valueCapacity);\n@@ -396,7 +375,7 @@ public void testReallocAfterVectorTransfer2() {\n       /* now transfer the vector */\n       TransferPair transferPair = vector.getTransferPair(allocator);\n       transferPair.transfer();\n-      final NullableBitVector toVector = (NullableBitVector)transferPair.getTo();\n+      final BitVector toVector = (BitVector)transferPair.getTo();\n \n       assertEquals(valueCapacity * 4, toVector.getValueCapacity());\n \n@@ -426,81 +405,81 @@ public void testReallocAfterVectorTransfer2() {\n   public void testBitVector() {\n     // Create a new value vector for 1024 integers\n     try (final BitVector vector = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final BitVector.Mutator m = vector.getMutator();\n       vector.allocateNew(1024);\n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n       // Put and set a few values\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(100, 0);\n-      m.set(1022, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(100, 0);\n+      vector.set(1022, 1);\n \n-      m.setValueCount(1024);\n+      vector.setValueCount(1024);\n \n-      final BitVector.Accessor accessor = vector.getAccessor();\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n-      assertEquals(0, accessor.get(100));\n-      assertEquals(1, accessor.get(1022));\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n+      assertEquals(0, vector.get(100));\n+      assertEquals(1, vector.get(1022));\n \n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n       // test setting the same value twice\n-      m.set(0, 1);\n-      m.set(0, 1);\n-      m.set(1, 0);\n-      m.set(1, 0);\n-      assertEquals(1, accessor.get(0));\n-      assertEquals(0, accessor.get(1));\n+      vector.set(0, 1);\n+      vector.set(0, 1);\n+      vector.set(1, 0);\n+      vector.set(1, 0);\n+      assertEquals(1, vector.get(0));\n+      assertEquals(0, vector.get(1));\n \n       // test toggling the values\n-      m.set(0, 0);\n-      m.set(1, 1);\n-      assertEquals(0, accessor.get(0));\n-      assertEquals(1, accessor.get(1));\n+      vector.set(0, 0);\n+      vector.set(1, 1);\n+      assertEquals(0, vector.get(0));\n+      assertEquals(1, vector.get(1));\n \n       // should not change\n-      assertEquals(1022, accessor.getNullCount());\n+      assertEquals(1020, vector.getNullCount());\n \n-      // Ensure unallocated space returns 0\n-      assertEquals(0, accessor.get(3));\n+      // Ensure null value\n+      assertTrue(vector.isNull(3));\n \n       // unset the previously set bits\n-      m.set(1, 0);\n-      m.set(1022, 0);\n+      vector.setNull(0);\n+      vector.setNull(1);\n+      vector.setNull(100);\n+      vector.setNull(1022);\n       // this should set all the array to 0\n-      assertEquals(1024, accessor.getNullCount());\n+      assertEquals(1024, vector.getNullCount());\n \n       // set all the array to 1\n       for (int i = 0; i < 1024; ++i) {\n-        assertEquals(1024 - i, accessor.getNullCount());\n-        m.set(i, 1);\n+        assertEquals(1024 - i, vector.getNullCount());\n+        vector.set(i, 1);\n       }\n \n-      assertEquals(0, accessor.getNullCount());\n+      assertEquals(0, vector.getNullCount());\n \n       vector.allocateNew(1015);\n-      m.setValueCount(1015);\n+      vector.setValueCount(1015);\n \n       // ensure it has been zeroed\n-      assertEquals(1015, accessor.getNullCount());\n+      assertEquals(1015, vector.getNullCount());\n \n-      m.set(0, 1);\n-      m.set(1014, 1); // ensure that the last item of the last byte is allocated\n+      vector.set(0, 1);\n+      vector.set(1014, 1); // ensure that the last item of the last byte is allocated\n \n-      assertEquals(1013, accessor.getNullCount());\n+      assertEquals(1013, vector.getNullCount());\n \n       vector.zeroVector();\n-      assertEquals(1015, accessor.getNullCount());\n+      assertEquals(1015, vector.getNullCount());\n \n       // set all the array to 1\n       for (int i = 0; i < 1015; ++i) {\n-        assertEquals(1015 - i, accessor.getNullCount());\n-        m.set(i, 1);\n+        assertEquals(1015 - i, vector.getNullCount());\n+        vector.set(i, 1);\n       }\n \n-      assertEquals(0, accessor.getNullCount());\n+      assertEquals(0, vector.getNullCount());\n     }\n   }\n \n@@ -526,15 +505,17 @@ private void validateRange(int length, int start, int count) {\n     try (BitVector bitVector = new BitVector(\"bits\", allocator)) {\n       bitVector.reset();\n       bitVector.allocateNew(length);\n-      bitVector.getMutator().setRangeToOne(start, count);\n+      for (int i = start; i < start + count; i++) {\n+        bitVector.set(i, 1);\n+      }\n       for (int i = 0; i < start; i++) {\n-        Assert.assertEquals(desc + i, 0, bitVector.getAccessor().get(i));\n+        Assert.assertTrue(desc + i, bitVector.isNull(i));\n       }\n       for (int i = start; i < start + count; i++) {\n-        Assert.assertEquals(desc + i, 1, bitVector.getAccessor().get(i));\n+        Assert.assertEquals(desc + i, 1, bitVector.get(i));\n       }\n       for (int i = start + count; i < length; i++) {\n-        Assert.assertEquals(desc + i, 0, bitVector.getAccessor().get(i));\n+        Assert.assertTrue(desc + i, bitVector.isNull(i));\n       }\n     }\n   }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestBufferOwnershipTransfer.java b/java/vector/src/test/java/org/apache/arrow/vector/TestBufferOwnershipTransfer.java\nindex 4fe286145..20f6754be 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestBufferOwnershipTransfer.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestBufferOwnershipTransfer.java\n@@ -38,11 +38,11 @@ public void testTransferFixedWidth() {\n     BufferAllocator childAllocator1 = allocator.newChildAllocator(\"child1\", 100000, 100000);\n     BufferAllocator childAllocator2 = allocator.newChildAllocator(\"child2\", 100000, 100000);\n \n-    NullableIntVector v1 = new NullableIntVector(\"v1\", childAllocator1);\n+    IntVector v1 = new IntVector(\"v1\", childAllocator1);\n     v1.allocateNew();\n     v1.setValueCount(4095);\n \n-    NullableIntVector v2 = new NullableIntVector(\"v2\", childAllocator2);\n+    IntVector v2 = new IntVector(\"v2\", childAllocator2);\n \n     v1.makeTransferPair(v2).transfer();\n \n@@ -58,12 +58,12 @@ public void testTransferVariableidth() {\n     BufferAllocator childAllocator1 = allocator.newChildAllocator(\"child1\", 100000, 100000);\n     BufferAllocator childAllocator2 = allocator.newChildAllocator(\"child2\", 100000, 100000);\n \n-    NullableVarCharVector v1 = new NullableVarCharVector(\"v1\", childAllocator1);\n+    VarCharVector v1 = new VarCharVector(\"v1\", childAllocator1);\n     v1.allocateNew();\n     v1.setSafe(4094, \"hello world\".getBytes(), 0, 11);\n     v1.setValueCount(4001);\n \n-    NullableVarCharVector v2 = new NullableVarCharVector(\"v2\", childAllocator2);\n+    VarCharVector v2 = new VarCharVector(\"v2\", childAllocator2);\n \n     v1.makeTransferPair(v2).transfer();\n \ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestCopyFrom.java b/java/vector/src/test/java/org/apache/arrow/vector/TestCopyFrom.java\nindex 7cdfbdf45..87ffcafec 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestCopyFrom.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestCopyFrom.java\n@@ -70,8 +70,8 @@ public void terminate() throws Exception {\n \n   @Test /* NullableVarChar */\n   public void testCopyFromWithNulls() {\n-    try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, Types.MinorType.VARCHAR, allocator);\n-         final NullableVarCharVector vector2 = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, Types.MinorType.VARCHAR, allocator)) {\n+    try (final VarCharVector vector = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, Types.MinorType.VARCHAR, allocator);\n+         final VarCharVector vector2 = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, Types.MinorType.VARCHAR, allocator)) {\n \n       vector.allocateNew();\n       int capacity = vector.getValueCapacity();\n@@ -130,8 +130,8 @@ public void testCopyFromWithNulls() {\n \n   @Test /* NullableVarChar */\n   public void testCopyFromWithNulls1() {\n-    try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, Types.MinorType.VARCHAR, allocator);\n-         final NullableVarCharVector vector2 = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, Types.MinorType.VARCHAR, allocator)) {\n+    try (final VarCharVector vector = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, Types.MinorType.VARCHAR, allocator);\n+         final VarCharVector vector2 = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, Types.MinorType.VARCHAR, allocator)) {\n \n       vector.allocateNew();\n       int capacity = vector.getValueCapacity();\n@@ -192,10 +192,10 @@ public void testCopyFromWithNulls1() {\n     }\n   }\n \n-  @Test /* NullableIntVector */\n+  @Test /* IntVector */\n   public void testCopyFromWithNulls2() {\n-    try (final NullableIntVector vector1 = new NullableIntVector(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableIntVector vector2 = new NullableIntVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final IntVector vector1 = new IntVector(EMPTY_SCHEMA_PATH, allocator);\n+         final IntVector vector2 = new IntVector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\n@@ -252,10 +252,10 @@ public void testCopyFromWithNulls2() {\n     }\n   }\n \n-  @Test /* NullableBigIntVector */\n+  @Test /* BigIntVector */\n   public void testCopyFromWithNulls3() {\n-    try (final NullableBigIntVector vector1 = new NullableBigIntVector(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableBigIntVector vector2 = new NullableBigIntVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final BigIntVector vector1 = new BigIntVector(EMPTY_SCHEMA_PATH, allocator);\n+         final BigIntVector vector2 = new BigIntVector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\n@@ -314,10 +314,10 @@ public void testCopyFromWithNulls3() {\n     }\n   }\n \n-  @Test /* NullableBitVector */\n+  @Test /* BitVector */\n   public void testCopyFromWithNulls4() {\n-    try (final NullableBitVector vector1 = new NullableBitVector(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableBitVector vector2 = new NullableBitVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final BitVector vector1 = new BitVector(EMPTY_SCHEMA_PATH, allocator);\n+         final BitVector vector2 = new BitVector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\n@@ -392,10 +392,10 @@ public void testCopyFromWithNulls4() {\n     }\n   }\n \n-  @Test /* NullableFloat4Vector */\n+  @Test /* Float4Vector */\n   public void testCopyFromWithNulls5() {\n-    try (final NullableFloat4Vector vector1 = new NullableFloat4Vector(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableFloat4Vector vector2 = new NullableFloat4Vector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final Float4Vector vector1 = new Float4Vector(EMPTY_SCHEMA_PATH, allocator);\n+         final Float4Vector vector2 = new Float4Vector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\n@@ -454,10 +454,10 @@ public void testCopyFromWithNulls5() {\n     }\n   }\n \n-  @Test /* NullableFloat8Vector */\n+  @Test /* Float8Vector */\n   public void testCopyFromWithNulls6() {\n-    try (final NullableFloat8Vector vector1 = new NullableFloat8Vector(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableFloat8Vector vector2 = new NullableFloat8Vector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final Float8Vector vector1 = new Float8Vector(EMPTY_SCHEMA_PATH, allocator);\n+         final Float8Vector vector2 = new Float8Vector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\n@@ -516,10 +516,10 @@ public void testCopyFromWithNulls6() {\n     }\n   }\n \n-  @Test /* NullableIntervalDayVector */\n+  @Test /* IntervalDayVector */\n   public void testCopyFromWithNulls7() {\n-    try (final NullableIntervalDayVector vector1 = new NullableIntervalDayVector(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableIntervalDayVector vector2 = new NullableIntervalDayVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final IntervalDayVector vector1 = new IntervalDayVector(EMPTY_SCHEMA_PATH, allocator);\n+         final IntervalDayVector vector2 = new IntervalDayVector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\n@@ -582,10 +582,10 @@ public void testCopyFromWithNulls7() {\n     }\n   }\n \n-  @Test /* NullableIntervalYearVector */\n+  @Test /* IntervalYearVector */\n   public void testCopyFromWithNulls8() {\n-    try (final NullableIntervalYearVector vector1 = new NullableIntervalYearVector(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableIntervalYearVector vector2 = new NullableIntervalYearVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final IntervalYearVector vector1 = new IntervalYearVector(EMPTY_SCHEMA_PATH, allocator);\n+         final IntervalYearVector vector2 = new IntervalYearVector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\n@@ -651,10 +651,10 @@ public void testCopyFromWithNulls8() {\n     }\n   }\n \n-  @Test /* NullableSmallIntVector */\n+  @Test /* SmallIntVector */\n   public void testCopyFromWithNulls9() {\n-    try (final NullableSmallIntVector vector1 = new NullableSmallIntVector(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableSmallIntVector vector2 = new NullableSmallIntVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final SmallIntVector vector1 = new SmallIntVector(EMPTY_SCHEMA_PATH, allocator);\n+         final SmallIntVector vector2 = new SmallIntVector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\n@@ -714,10 +714,10 @@ public void testCopyFromWithNulls9() {\n     }\n   }\n \n-  @Test /* NullableTimeMicroVector */\n+  @Test /* TimeMicroVector */\n   public void testCopyFromWithNulls10() {\n-    try (final NullableTimeMicroVector vector1 = new NullableTimeMicroVector(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableTimeMicroVector vector2 = new NullableTimeMicroVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final TimeMicroVector vector1 = new TimeMicroVector(EMPTY_SCHEMA_PATH, allocator);\n+         final TimeMicroVector vector2 = new TimeMicroVector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\n@@ -777,10 +777,10 @@ public void testCopyFromWithNulls10() {\n     }\n   }\n \n-  @Test /* NullableTimeMilliVector */\n+  @Test /* TimeMilliVector */\n   public void testCopyFromWithNulls11() {\n-    try (final NullableTimeMilliVector vector1 = new NullableTimeMilliVector(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableTimeMilliVector vector2 = new NullableTimeMilliVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final TimeMilliVector vector1 = new TimeMilliVector(EMPTY_SCHEMA_PATH, allocator);\n+         final TimeMilliVector vector2 = new TimeMilliVector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\n@@ -840,10 +840,10 @@ public void testCopyFromWithNulls11() {\n     }\n   }\n \n-  @Test /* NullableTinyIntVector */\n+  @Test /* TinyIntVector */\n   public void testCopyFromWithNulls12() {\n-    try (final NullableTinyIntVector vector1 = new NullableTinyIntVector(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableTinyIntVector vector2 = new NullableTinyIntVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final TinyIntVector vector1 = new TinyIntVector(EMPTY_SCHEMA_PATH, allocator);\n+         final TinyIntVector vector2 = new TinyIntVector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\n@@ -906,10 +906,10 @@ public void testCopyFromWithNulls12() {\n     }\n   }\n \n-  @Test /* NullableDecimalVector */\n+  @Test /* DecimalVector */\n   public void testCopyFromWithNulls13() {\n-    try (final NullableDecimalVector vector1 = new NullableDecimalVector(EMPTY_SCHEMA_PATH, allocator, 30, 16);\n-         final NullableDecimalVector vector2 = new NullableDecimalVector(EMPTY_SCHEMA_PATH, allocator, 30, 16)) {\n+    try (final DecimalVector vector1 = new DecimalVector(EMPTY_SCHEMA_PATH, allocator, 30, 16);\n+         final DecimalVector vector2 = new DecimalVector(EMPTY_SCHEMA_PATH, allocator, 30, 16)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\n@@ -972,10 +972,10 @@ public void testCopyFromWithNulls13() {\n     }\n   }\n \n-  @Test /* NullableTimeStampVector */\n+  @Test /* TimeStampVector */\n   public void testCopyFromWithNulls14() {\n-    try (final NullableTimeStampVector vector1 = new NullableTimeStampMicroVector(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableTimeStampVector vector2 = new NullableTimeStampMicroVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final TimeStampVector vector1 = new TimeStampMicroVector(EMPTY_SCHEMA_PATH, allocator);\n+         final TimeStampVector vector2 = new TimeStampMicroVector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       vector1.allocateNew();\n       assertEquals(4096, vector1.getValueCapacity());\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestDecimalVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestDecimalVector.java\nindex 4d844d6d3..a48c03571 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestDecimalVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestDecimalVector.java\n@@ -60,9 +60,9 @@ public void terminate() throws Exception {\n \n   @Test\n   public void testValuesWriteRead() {\n-    try (NullableDecimalVector decimalVector = TestUtils.newVector(NullableDecimalVector.class, \"decimal\", new ArrowType.Decimal(10, scale), allocator);) {\n+    try (DecimalVector decimalVector = TestUtils.newVector(DecimalVector.class, \"decimal\", new ArrowType.Decimal(10, scale), allocator);) {\n \n-      try (NullableDecimalVector oldConstructor = new NullableDecimalVector(\"decimal\", allocator, 10, scale);) {\n+      try (DecimalVector oldConstructor = new DecimalVector(\"decimal\", allocator, 10, scale);) {\n         assertEquals(decimalVector.getField().getType(), oldConstructor.getField().getType());\n       }\n \n@@ -85,7 +85,7 @@ public void testValuesWriteRead() {\n \n   @Test\n   public void testBigDecimalDifferentScaleAndPrecision() {\n-    try (NullableDecimalVector decimalVector = TestUtils.newVector(NullableDecimalVector.class, \"decimal\", new ArrowType.Decimal(4, 2), allocator);) {\n+    try (DecimalVector decimalVector = TestUtils.newVector(DecimalVector.class, \"decimal\", new ArrowType.Decimal(4, 2), allocator);) {\n       decimalVector.allocateNew();\n \n       // test BigDecimal with different scale\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java\nindex 46a2bafa0..ba149bcb8 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestDictionaryVector.java\n@@ -18,7 +18,7 @@\n \n package org.apache.arrow.vector;\n \n-import static org.apache.arrow.vector.TestUtils.newNullableVarCharVector;\n+import static org.apache.arrow.vector.TestUtils.newVarCharVector;\n import static org.junit.Assert.assertEquals;\n \n import java.nio.charset.StandardCharsets;\n@@ -54,8 +54,8 @@ public void terminate() throws Exception {\n   @Test\n   public void testEncodeStrings() {\n     // Create a new value vector\n-    try (final NullableVarCharVector vector = newNullableVarCharVector(\"foo\", allocator);\n-         final NullableVarCharVector dictionaryVector = newNullableVarCharVector(\"dict\", allocator);) {\n+    try (final VarCharVector vector = newVarCharVector(\"foo\", allocator);\n+         final VarCharVector dictionaryVector = newVarCharVector(\"dict\", allocator);) {\n       vector.allocateNew(512, 5);\n \n       // set some values\n@@ -77,9 +77,9 @@ public void testEncodeStrings() {\n \n       try (final ValueVector encoded = (FieldVector) DictionaryEncoder.encode(vector, dictionary)) {\n         // verify indices\n-        assertEquals(NullableIntVector.class, encoded.getClass());\n+        assertEquals(IntVector.class, encoded.getClass());\n \n-        NullableIntVector index = ((NullableIntVector)encoded);\n+        IntVector index = ((IntVector)encoded);\n         assertEquals(5, index.getValueCount());\n         assertEquals(0, index.get(0));\n         assertEquals(1, index.get(1));\n@@ -90,9 +90,9 @@ public void testEncodeStrings() {\n         // now run through the decoder and verify we get the original back\n         try (ValueVector decoded = DictionaryEncoder.decode(encoded, dictionary)) {\n           assertEquals(vector.getClass(), decoded.getClass());\n-          assertEquals(vector.getValueCount(), ((NullableVarCharVector)decoded).getValueCount());\n+          assertEquals(vector.getValueCount(), ((VarCharVector)decoded).getValueCount());\n           for (int i = 0; i < 5; i++) {\n-            assertEquals(vector.getObject(i), ((NullableVarCharVector)decoded).getObject(i));\n+            assertEquals(vector.getObject(i), ((VarCharVector)decoded).getObject(i));\n           }\n         }\n       }\n@@ -102,8 +102,8 @@ public void testEncodeStrings() {\n   @Test\n   public void testEncodeLargeVector() {\n     // Create a new value vector\n-    try (final NullableVarCharVector vector = newNullableVarCharVector(\"foo\", allocator);\n-         final NullableVarCharVector dictionaryVector = newNullableVarCharVector(\"dict\", allocator);) {\n+    try (final VarCharVector vector = newVarCharVector(\"foo\", allocator);\n+         final VarCharVector dictionaryVector = newVarCharVector(\"dict\", allocator);) {\n       vector.allocateNew();\n \n       int count = 10000;\n@@ -124,9 +124,9 @@ public void testEncodeLargeVector() {\n \n       try (final ValueVector encoded = (FieldVector) DictionaryEncoder.encode(vector, dictionary)) {\n         // verify indices\n-        assertEquals(NullableIntVector.class, encoded.getClass());\n+        assertEquals(IntVector.class, encoded.getClass());\n \n-        NullableIntVector index = ((NullableIntVector) encoded);\n+        IntVector index = ((IntVector) encoded);\n         assertEquals(count, index.getValueCount());\n         for (int i = 0; i < count; ++i) {\n           assertEquals(i % 3, index.get(i));\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\nindex 2af6cd53a..50438ce11 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestFixedSizeListVector.java\n@@ -53,7 +53,7 @@ public void terminate() throws Exception {\n   @Test\n   public void testIntType() {\n     try (FixedSizeListVector vector = FixedSizeListVector.empty(\"list\", 2, allocator)) {\n-      NullableIntVector nested = (NullableIntVector) vector.addOrGetVector(FieldType.nullable(MinorType.INT.getType())).getVector();\n+      IntVector nested = (IntVector) vector.addOrGetVector(FieldType.nullable(MinorType.INT.getType())).getVector();\n       vector.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n@@ -80,7 +80,7 @@ public void testIntType() {\n   @Test\n   public void testFloatTypeNullable() {\n     try (FixedSizeListVector vector = FixedSizeListVector.empty(\"list\", 2, allocator)) {\n-      NullableFloat4Vector nested = (NullableFloat4Vector) vector.addOrGetVector(FieldType.nullable(MinorType.FLOAT4.getType())).getVector();\n+      Float4Vector nested = (Float4Vector) vector.addOrGetVector(FieldType.nullable(MinorType.FLOAT4.getType())).getVector();\n       vector.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n@@ -115,7 +115,7 @@ public void testFloatTypeNullable() {\n   public void testNestedInList() {\n     try (ListVector vector = ListVector.empty(\"list\", allocator)) {\n       FixedSizeListVector tuples = (FixedSizeListVector) vector.addOrGetVector(FieldType.nullable(new ArrowType.FixedSizeList(2))).getVector();\n-      NullableIntVector innerVector = (NullableIntVector) tuples.addOrGetVector(FieldType.nullable(MinorType.INT.getType())).getVector();\n+      IntVector innerVector = (IntVector) tuples.addOrGetVector(FieldType.nullable(MinorType.INT.getType())).getVector();\n       vector.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n@@ -157,7 +157,7 @@ public void testNestedInList() {\n   public void testTransferPair() {\n     try (FixedSizeListVector from = new FixedSizeListVector(\"from\", allocator, 2, null, null);\n          FixedSizeListVector to = new FixedSizeListVector(\"to\", allocator, 2, null, null)) {\n-      NullableFloat4Vector nested = (NullableFloat4Vector) from.addOrGetVector(FieldType.nullable(MinorType.FLOAT4.getType())).getVector();\n+      Float4Vector nested = (Float4Vector) from.addOrGetVector(FieldType.nullable(MinorType.FLOAT4.getType())).getVector();\n       from.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java\nindex f6aa86a30..1cff7fa88 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestListVector.java\n@@ -131,8 +131,8 @@ public void testSetLastSetUsage() throws Exception {\n       ArrowBuf validityBuffer = listVector.getValidityBuffer();\n       ArrowBuf offsetBuffer = listVector.getOffsetBuffer();\n \n-      /* get the underlying data vector -- NullableBigIntVector */\n-      NullableBigIntVector dataVector = (NullableBigIntVector) listVector.getDataVector();\n+      /* get the underlying data vector -- BigIntVector */\n+      BigIntVector dataVector = (BigIntVector) listVector.getDataVector();\n \n       /* check current lastSet */\n       assertEquals(Integer.toString(0), Integer.toString(listVector.getLastSet()));\n@@ -310,7 +310,7 @@ public void testSplitAndTransfer() throws Exception {\n       final ArrowBuf offsetBuffer = listVector.getOffsetBuffer();\n \n       /* get dataVector */\n-      NullableBigIntVector dataVector = (NullableBigIntVector) listVector.getDataVector();\n+      BigIntVector dataVector = (BigIntVector) listVector.getDataVector();\n \n       /* check the vector output */\n \n@@ -418,7 +418,7 @@ public void testSplitAndTransfer() throws Exception {\n           final ArrowBuf toOffsetBuffer = toVector.getOffsetBuffer();\n \n           /* get dataVector of toVector */\n-          NullableBigIntVector dataVector1 = (NullableBigIntVector) toVector.getDataVector();\n+          BigIntVector dataVector1 = (BigIntVector) toVector.getDataVector();\n \n           for (int i = 0; i < splitLength; i++) {\n             dataLength1 = offsetBuffer.getInt((start + i + 1) * ListVector.OFFSET_WIDTH) -\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestMapVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestMapVector.java\nindex 357df96aa..e5682955b 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestMapVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestMapVector.java\n@@ -22,7 +22,7 @@\n import java.util.Map;\n \n import org.apache.arrow.memory.BufferAllocator;\n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.MapVector;\n import org.apache.arrow.vector.types.pojo.ArrowType.Struct;\n import org.apache.arrow.vector.types.pojo.FieldType;\n import org.junit.After;\n@@ -50,7 +50,7 @@ public void testFieldMetadata() throws Exception {\n     Map<String, String> metadata = new HashMap<>();\n     metadata.put(\"k1\", \"v1\");\n     FieldType type = new FieldType(true, Struct.INSTANCE, null, metadata);\n-    try (NullableMapVector vector = new NullableMapVector(\"map\", allocator, type, null)) {\n+    try (MapVector vector = new MapVector(\"map\", allocator, type, null)) {\n       Assert.assertEquals(vector.getField().getMetadata(), type.getMetadata());\n     }\n   }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestOversizedAllocationForValueVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestOversizedAllocationForValueVector.java\nindex ba2ebbf05..f14dbd663 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestOversizedAllocationForValueVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestOversizedAllocationForValueVector.java\n@@ -112,10 +112,10 @@ public void testVariableVectorReallocation() {\n     try {\n       vector.allocateNew(expectedAllocationInBytes, 10);\n       assertTrue(expectedOffsetSize <= vector.getValueCapacity());\n-      assertTrue(expectedAllocationInBytes <= vector.getBuffer().capacity());\n+      assertTrue(expectedAllocationInBytes <= vector.getDataBuffer().capacity());\n       vector.reAlloc();\n       assertTrue(expectedOffsetSize * 2 <= vector.getValueCapacity());\n-      assertTrue(expectedAllocationInBytes * 2 <= vector.getBuffer().capacity());\n+      assertTrue(expectedAllocationInBytes * 2 <= vector.getDataBuffer().capacity());\n     } finally {\n       vector.close();\n     }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestSplitAndTransfer.java b/java/vector/src/test/java/org/apache/arrow/vector/TestSplitAndTransfer.java\nindex 7de3bcb33..80d5fe197 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestSplitAndTransfer.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestSplitAndTransfer.java\n@@ -24,7 +24,7 @@\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.RootAllocator;\n \n-import org.apache.arrow.vector.NullableVarCharVector;\n+import org.apache.arrow.vector.VarCharVector;\n import org.apache.arrow.vector.util.TransferPair;\n \n import org.junit.After;\n@@ -45,9 +45,9 @@ public void terminate() throws Exception {\n         allocator.close();\n     }\n \n-    @Test /* NullableVarCharVector */\n+    @Test /* VarCharVector */\n     public void test() throws Exception {\n-        try(final NullableVarCharVector varCharVector = new NullableVarCharVector(\"myvector\", allocator)) {\n+        try(final VarCharVector varCharVector = new VarCharVector(\"myvector\", allocator)) {\n             varCharVector.allocateNew(10000, 1000);\n \n             final int valueCount = 500;\n@@ -61,7 +61,7 @@ public void test() throws Exception {\n             varCharVector.setValueCount(valueCount);\n \n             final TransferPair tp = varCharVector.getTransferPair(allocator);\n-            final NullableVarCharVector newVarCharVector = (NullableVarCharVector) tp.getTo();\n+            final VarCharVector newVarCharVector = (VarCharVector) tp.getTo();\n             final int[][] startLengths = {{0, 201}, {201, 200}, {401, 99}};\n \n             for (final int[] startLength : startLengths) {\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestUtils.java b/java/vector/src/test/java/org/apache/arrow/vector/TestUtils.java\nindex a14881309..99a1d8907 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestUtils.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestUtils.java\n@@ -25,13 +25,13 @@\n \n public class TestUtils {\n \n-  public static NullableVarCharVector newNullableVarCharVector(String name, BufferAllocator allocator) {\n-    return (NullableVarCharVector)\n+  public static VarCharVector newVarCharVector(String name, BufferAllocator allocator) {\n+    return (VarCharVector)\n         FieldType.nullable(new ArrowType.Utf8()).createNewSingleVector(name, allocator, null);\n   }\n \n-  public static NullableVarBinaryVector newNullableVarBinaryVector(String name, BufferAllocator allocator) {\n-    return (NullableVarBinaryVector)\n+  public static VarBinaryVector newVarBinaryVector(String name, BufferAllocator allocator) {\n+    return (VarBinaryVector)\n         FieldType.nullable(new ArrowType.Binary()).createNewSingleVector(name, allocator, null);\n   }\n \ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java b/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java\nindex f51a87436..336ae1c7a 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestValueVector.java\n@@ -19,8 +19,8 @@\n package org.apache.arrow.vector;\n import org.apache.arrow.vector.util.OversizedAllocationException;\n \n-import static org.apache.arrow.vector.TestUtils.newNullableVarBinaryVector;\n-import static org.apache.arrow.vector.TestUtils.newNullableVarCharVector;\n+import static org.apache.arrow.vector.TestUtils.newVarBinaryVector;\n+import static org.apache.arrow.vector.TestUtils.newVarCharVector;\n import static org.apache.arrow.vector.TestUtils.newVector;\n import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n@@ -88,9 +88,9 @@ public void terminate() throws Exception {\n    *  -- Float4Vector\n    *  -- Float8Vector\n    *\n-   *  -- NullableUInt4Vector\n-   *  -- NullableIntVector\n-   *  -- NullableFloat4Vector\n+   *  -- UInt4Vector\n+   *  -- IntVector\n+   *  -- Float4Vector\n    *\n    * TODO:\n    *\n@@ -107,28 +107,26 @@ public void testFixedType1() {\n \n       boolean error = false;\n       int initialCapacity = 0;\n-      final UInt4Vector.Mutator mutator = vector.getMutator();\n-      final UInt4Vector.Accessor accessor = vector.getAccessor();\n \n       vector.allocateNew(1024);\n       initialCapacity = vector.getValueCapacity();\n       assertEquals(1024, initialCapacity);\n \n       // Put and set a few values\n-      mutator.setSafe(0, 100);\n-      mutator.setSafe(1, 101);\n-      mutator.setSafe(100, 102);\n-      mutator.setSafe(1022, 103);\n-      mutator.setSafe(1023, 104);\n-\n-      assertEquals(100, accessor.get(0));\n-      assertEquals(101, accessor.get(1));\n-      assertEquals(102, accessor.get(100));\n-      assertEquals(103, accessor.get(1022));\n-      assertEquals(104, accessor.get(1023));\n+      vector.setSafe(0, 100);\n+      vector.setSafe(1, 101);\n+      vector.setSafe(100, 102);\n+      vector.setSafe(1022, 103);\n+      vector.setSafe(1023, 104);\n+\n+      assertEquals(100, vector.get(0));\n+      assertEquals(101, vector.get(1));\n+      assertEquals(102, vector.get(100));\n+      assertEquals(103, vector.get(1022));\n+      assertEquals(104, vector.get(1023));\n \n       try {\n-        mutator.set(1024, 10000);\n+        vector.set(1024, 10000);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -139,7 +137,7 @@ public void testFixedType1() {\n       }\n \n       try {\n-        accessor.get(1024);\n+        vector.get(1024);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -150,18 +148,18 @@ public void testFixedType1() {\n       }\n \n       /* this should trigger a realloc() */\n-      mutator.setSafe(1024, 10000);\n+      vector.setSafe(1024, 10000);\n \n       /* underlying buffer should now be able to store double the number of values */\n       assertEquals(initialCapacity * 2, vector.getValueCapacity());\n \n       /* check vector data after realloc */\n-      assertEquals(100, accessor.get(0));\n-      assertEquals(101, accessor.get(1));\n-      assertEquals(102, accessor.get(100));\n-      assertEquals(103, accessor.get(1022));\n-      assertEquals(104, accessor.get(1023));\n-      assertEquals(10000, accessor.get(1024));\n+      assertEquals(100, vector.get(0));\n+      assertEquals(101, vector.get(1));\n+      assertEquals(102, vector.get(100));\n+      assertEquals(103, vector.get(1022));\n+      assertEquals(104, vector.get(1023));\n+      assertEquals(10000, vector.get(1024));\n \n       /* reset the vector */\n       vector.reset();\n@@ -171,7 +169,8 @@ public void testFixedType1() {\n \n       /* vector data should have been zeroed out */\n       for(int i = 0; i < (initialCapacity * 2); i++) {\n-        assertEquals(\"non-zero data not expected at index: \" + i, 0, accessor.get(i));\n+        // TODO: test vector.get(i) is 0 after unsafe get added\n+        assertEquals(\"non-zero data not expected at index: \" + i, true, vector.isNull(i));\n       }\n     }\n   }\n@@ -179,8 +178,6 @@ public void testFixedType1() {\n   @Test /* IntVector */\n   public void testFixedType2() {\n     try (final IntVector intVector = new IntVector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final IntVector.Mutator mutator = intVector.getMutator();\n-      final IntVector.Accessor accessor = intVector.getAccessor();\n       boolean error = false;\n       int initialCapacity = 16;\n \n@@ -211,12 +208,12 @@ public void testFixedType2() {\n       /* populate the vector */\n       int j = 1;\n       for(int i = 0; i < 16; i += 2) {\n-        mutator.set(i, j);\n+        intVector.set(i, j);\n         j++;\n       }\n \n       try {\n-        mutator.set(16, 9);\n+        intVector.set(16, 9);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -229,12 +226,12 @@ public void testFixedType2() {\n       /* check vector contents */\n       j = 1;\n       for(int i = 0; i < 16; i += 2) {\n-        assertEquals(\"unexpected value at index: \" + i, j, accessor.get(i));\n+        assertEquals(\"unexpected value at index: \" + i, j, intVector.get(i));\n         j++;\n       }\n \n       try {\n-        accessor.get(16);\n+        intVector.get(16);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -245,7 +242,7 @@ public void testFixedType2() {\n       }\n \n       /* this should trigger a realloc() */\n-      mutator.setSafe(16, 9);\n+      intVector.setSafe(16, 9);\n \n       /* underlying buffer should now be able to store double the number of values */\n       assertEquals(initialCapacity * 2, intVector.getValueCapacity());\n@@ -253,7 +250,7 @@ public void testFixedType2() {\n       /* vector data should still be intact after realloc */\n       j = 1;\n       for(int i = 0; i <= 16; i += 2) {\n-        assertEquals(\"unexpected value at index: \" + i, j, accessor.get(i));\n+        assertEquals(\"unexpected value at index: \" + i, j, intVector.get(i));\n         j++;\n       }\n \n@@ -265,7 +262,7 @@ public void testFixedType2() {\n \n       /* vector data should have been zeroed out */\n       for(int i = 0; i < (initialCapacity * 2); i++) {\n-        assertEquals(\"non-zero data not expected at index: \" + i, 0, accessor.get(i));\n+        assertEquals(\"non-zero data not expected at index: \" + i, true, intVector.isNull(i));\n       }\n     }\n   }\n@@ -273,8 +270,6 @@ public void testFixedType2() {\n   @Test /* Float4Vector */\n   public void testFixedType3() {\n     try (final Float4Vector floatVector = new Float4Vector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final Float4Vector.Mutator mutator = floatVector.getMutator();\n-      final Float4Vector.Accessor accessor = floatVector.getAccessor();\n       boolean error = false;\n       int initialCapacity = 16;\n \n@@ -304,18 +299,18 @@ public void testFixedType3() {\n \n       floatVector.zeroVector();\n \n-      /* populate the vector */\n-      mutator.set(0, 1.5f);\n-      mutator.set(2, 2.5f);\n-      mutator.set(4, 3.3f);\n-      mutator.set(6, 4.8f);\n-      mutator.set(8, 5.6f);\n-      mutator.set(10, 6.6f);\n-      mutator.set(12, 7.8f);\n-      mutator.set(14, 8.5f);\n+      /* populate the floatVector */\n+      floatVector.set(0, 1.5f);\n+      floatVector.set(2, 2.5f);\n+      floatVector.set(4, 3.3f);\n+      floatVector.set(6, 4.8f);\n+      floatVector.set(8, 5.6f);\n+      floatVector.set(10, 6.6f);\n+      floatVector.set(12, 7.8f);\n+      floatVector.set(14, 8.5f);\n \n       try {\n-        mutator.set(16, 9.5f);\n+        floatVector.set(16, 9.5f);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -326,17 +321,17 @@ public void testFixedType3() {\n       }\n \n       /* check vector contents */\n-      assertEquals(1.5f, accessor.get(0), 0);\n-      assertEquals(2.5f, accessor.get(2), 0);\n-      assertEquals(3.3f, accessor.get(4), 0);\n-      assertEquals(4.8f, accessor.get(6), 0);\n-      assertEquals(5.6f, accessor.get(8), 0);\n-      assertEquals(6.6f, accessor.get(10), 0);\n-      assertEquals(7.8f, accessor.get(12), 0);\n-      assertEquals(8.5f, accessor.get(14), 0);\n+      assertEquals(1.5f, floatVector.get(0), 0);\n+      assertEquals(2.5f, floatVector.get(2), 0);\n+      assertEquals(3.3f, floatVector.get(4), 0);\n+      assertEquals(4.8f, floatVector.get(6), 0);\n+      assertEquals(5.6f, floatVector.get(8), 0);\n+      assertEquals(6.6f, floatVector.get(10), 0);\n+      assertEquals(7.8f, floatVector.get(12), 0);\n+      assertEquals(8.5f, floatVector.get(14), 0);\n \n       try {\n-        accessor.get(16);\n+        floatVector.get(16);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -347,21 +342,21 @@ public void testFixedType3() {\n       }\n \n       /* this should trigger a realloc() */\n-      mutator.setSafe(16, 9.5f);\n+      floatVector.setSafe(16, 9.5f);\n \n       /* underlying buffer should now be able to store double the number of values */\n       assertEquals(initialCapacity * 2, floatVector.getValueCapacity());\n \n       /* vector data should still be intact after realloc */\n-      assertEquals(1.5f, accessor.get(0), 0);\n-      assertEquals(2.5f, accessor.get(2), 0);\n-      assertEquals(3.3f, accessor.get(4), 0);\n-      assertEquals(4.8f, accessor.get(6), 0);\n-      assertEquals(5.6f, accessor.get(8), 0);\n-      assertEquals(6.6f, accessor.get(10), 0);\n-      assertEquals(7.8f, accessor.get(12), 0);\n-      assertEquals(8.5f, accessor.get(14), 0);\n-      assertEquals(9.5f, accessor.get(16), 0);\n+      assertEquals(1.5f, floatVector.get(0), 0);\n+      assertEquals(2.5f, floatVector.get(2), 0);\n+      assertEquals(3.3f, floatVector.get(4), 0);\n+      assertEquals(4.8f, floatVector.get(6), 0);\n+      assertEquals(5.6f, floatVector.get(8), 0);\n+      assertEquals(6.6f, floatVector.get(10), 0);\n+      assertEquals(7.8f, floatVector.get(12), 0);\n+      assertEquals(8.5f, floatVector.get(14), 0);\n+      assertEquals(9.5f, floatVector.get(16), 0);\n \n       /* reset the vector */\n       floatVector.reset();\n@@ -371,7 +366,7 @@ public void testFixedType3() {\n \n       /* vector data should be zeroed out */\n       for(int i = 0; i < (initialCapacity * 2); i++) {\n-        assertEquals(\"non-zero data not expected at index: \" + i, 0, accessor.get(i), 0);\n+        assertEquals(\"non-zero data not expected at index: \" + i, true, floatVector.isNull(i));\n       }\n     }\n   }\n@@ -379,8 +374,6 @@ public void testFixedType3() {\n   @Test /* Float8Vector */\n   public void testFixedType4() {\n     try (final Float8Vector floatVector = new Float8Vector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final Float8Vector.Mutator mutator = floatVector.getMutator();\n-      final Float8Vector.Accessor accessor = floatVector.getAccessor();\n       boolean error = false;\n       int initialCapacity = 16;\n \n@@ -409,17 +402,17 @@ public void testFixedType4() {\n       assertEquals(initialCapacity, floatVector.getValueCapacity());\n \n       /* populate the vector */\n-      mutator.set(0, 1.55);\n-      mutator.set(2, 2.53);\n-      mutator.set(4, 3.36);\n-      mutator.set(6, 4.82);\n-      mutator.set(8, 5.67);\n-      mutator.set(10, 6.67);\n-      mutator.set(12, 7.87);\n-      mutator.set(14, 8.56);\n+      floatVector.set(0, 1.55);\n+      floatVector.set(2, 2.53);\n+      floatVector.set(4, 3.36);\n+      floatVector.set(6, 4.82);\n+      floatVector.set(8, 5.67);\n+      floatVector.set(10, 6.67);\n+      floatVector.set(12, 7.87);\n+      floatVector.set(14, 8.56);\n \n       try {\n-        mutator.set(16, 9.53);\n+        floatVector.set(16, 9.53);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -429,18 +422,18 @@ public void testFixedType4() {\n         error = false;\n       }\n \n-      /* check vector contents */\n-      assertEquals(1.55, accessor.get(0), 0);\n-      assertEquals(2.53, accessor.get(2), 0);\n-      assertEquals(3.36, accessor.get(4), 0);\n-      assertEquals(4.82, accessor.get(6), 0);\n-      assertEquals(5.67, accessor.get(8), 0);\n-      assertEquals(6.67, accessor.get(10), 0);\n-      assertEquals(7.87, accessor.get(12), 0);\n-      assertEquals(8.56, accessor.get(14), 0);\n+      /* check floatVector contents */\n+      assertEquals(1.55, floatVector.get(0), 0);\n+      assertEquals(2.53, floatVector.get(2), 0);\n+      assertEquals(3.36, floatVector.get(4), 0);\n+      assertEquals(4.82, floatVector.get(6), 0);\n+      assertEquals(5.67, floatVector.get(8), 0);\n+      assertEquals(6.67, floatVector.get(10), 0);\n+      assertEquals(7.87, floatVector.get(12), 0);\n+      assertEquals(8.56, floatVector.get(14), 0);\n \n       try {\n-        accessor.get(16);\n+        floatVector.get(16);\n       }\n       catch (IndexOutOfBoundsException ie) {\n         error = true;\n@@ -451,21 +444,21 @@ public void testFixedType4() {\n       }\n \n       /* this should trigger a realloc() */\n-      mutator.setSafe(16, 9.53);\n+      floatVector.setSafe(16, 9.53);\n \n       /* underlying buffer should now be able to store double the number of values */\n       assertEquals(initialCapacity * 2, floatVector.getValueCapacity());\n \n       /* vector data should still be intact after realloc */\n-      assertEquals(1.55, accessor.get(0), 0);\n-      assertEquals(2.53, accessor.get(2), 0);\n-      assertEquals(3.36, accessor.get(4), 0);\n-      assertEquals(4.82, accessor.get(6), 0);\n-      assertEquals(5.67, accessor.get(8), 0);\n-      assertEquals(6.67, accessor.get(10), 0);\n-      assertEquals(7.87, accessor.get(12), 0);\n-      assertEquals(8.56, accessor.get(14), 0);\n-      assertEquals(9.53, accessor.get(16), 0);\n+      assertEquals(1.55, floatVector.get(0), 0);\n+      assertEquals(2.53, floatVector.get(2), 0);\n+      assertEquals(3.36, floatVector.get(4), 0);\n+      assertEquals(4.82, floatVector.get(6), 0);\n+      assertEquals(5.67, floatVector.get(8), 0);\n+      assertEquals(6.67, floatVector.get(10), 0);\n+      assertEquals(7.87, floatVector.get(12), 0);\n+      assertEquals(8.56, floatVector.get(14), 0);\n+      assertEquals(9.53, floatVector.get(16), 0);\n \n       /* reset the vector */\n       floatVector.reset();\n@@ -475,16 +468,16 @@ public void testFixedType4() {\n \n       /* vector data should be zeroed out */\n       for(int i = 0; i < (initialCapacity * 2); i++) {\n-        assertEquals(\"non-zero data not expected at index: \" + i, 0, accessor.get(i), 0);\n+        assertEquals(\"non-zero data not expected at index: \" + i, true, floatVector.isNull(i));\n       }\n     }\n   }\n \n-  @Test /* NullableUInt4Vector */\n+  @Test /* UInt4Vector */\n   public void testNullableFixedType1() {\n \n     // Create a new value vector for 1024 integers.\n-    try (final NullableUInt4Vector vector = newVector(NullableUInt4Vector.class, EMPTY_SCHEMA_PATH, new ArrowType.Int(32, false), allocator);) {\n+    try (final UInt4Vector vector = newVector(UInt4Vector.class, EMPTY_SCHEMA_PATH, new ArrowType.Int(32, false), allocator);) {\n       boolean error = false;\n       int initialCapacity = 1024;\n \n@@ -582,10 +575,10 @@ public void testNullableFixedType1() {\n     }\n   }\n \n-  @Test /* NullableFloat4Vector */\n+  @Test /* Float4Vector */\n   public void testNullableFixedType2() {\n     // Create a new value vector for 1024 integers\n-    try (final NullableFloat4Vector vector = newVector(NullableFloat4Vector.class, EMPTY_SCHEMA_PATH, MinorType.FLOAT4, allocator);) {\n+    try (final Float4Vector vector = newVector(Float4Vector.class, EMPTY_SCHEMA_PATH, MinorType.FLOAT4, allocator);) {\n       boolean error = false;\n       int initialCapacity = 16;\n \n@@ -683,10 +676,10 @@ public void testNullableFixedType2() {\n     }\n   }\n \n-  @Test /* NullableIntVector */\n+  @Test /* IntVector */\n   public void testNullableFixedType3() {\n     // Create a new value vector for 1024 integers\n-    try (final NullableIntVector vector = newVector(NullableIntVector.class, EMPTY_SCHEMA_PATH, MinorType.INT, allocator)) {\n+    try (final IntVector vector = newVector(IntVector.class, EMPTY_SCHEMA_PATH, MinorType.INT, allocator)) {\n       boolean error = false;\n       int initialCapacity = 1024;\n \n@@ -777,9 +770,9 @@ public void testNullableFixedType3() {\n     }\n   }\n \n-  @Test /* NullableIntVector */\n+  @Test /* IntVector */\n   public void testNullableFixedType4() {\n-    try (final NullableIntVector vector = newVector(NullableIntVector.class, EMPTY_SCHEMA_PATH, MinorType.INT, allocator)) {\n+    try (final IntVector vector = newVector(IntVector.class, EMPTY_SCHEMA_PATH, MinorType.INT, allocator)) {\n \n       /* no memory allocation has happened yet */\n       assertEquals(0, vector.getValueCapacity());\n@@ -870,8 +863,8 @@ public void testNullableFixedType4() {\n    *\n    * Covered types as of now\n    *\n-   *  -- NullableVarCharVector\n-   *  -- NullableVarBinaryVector\n+   *  -- VarCharVector\n+   *  -- VarBinaryVector\n    *\n    * TODO:\n    *\n@@ -879,11 +872,11 @@ public void testNullableFixedType4() {\n    *  -- VarBinaryVector\n    */\n \n-  @Test /* NullableVarCharVector */\n+  @Test /* VarCharVector */\n   public void testNullableVarType1() {\n \n     // Create a new value vector for 1024 integers.\n-    try (final NullableVarCharVector vector = newNullableVarCharVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final VarCharVector vector = newVarCharVector(EMPTY_SCHEMA_PATH, allocator)) {\n       vector.allocateNew(1024 * 10, 1024);\n \n       vector.set(0, STR1);\n@@ -916,11 +909,11 @@ public void testNullableVarType1() {\n     }\n   }\n \n-  @Test /* NullableVarBinaryVector */\n+  @Test /* VarBinaryVector */\n   public void testNullableVarType2() {\n \n     // Create a new value vector for 1024 integers.\n-    try (final NullableVarBinaryVector vector = newNullableVarBinaryVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final VarBinaryVector vector = newVarBinaryVector(EMPTY_SCHEMA_PATH, allocator)) {\n       vector.allocateNew(1024 * 10, 1024);\n \n       vector.set(0, STR1);\n@@ -971,8 +964,6 @@ public void testNullableVarType2() {\n   @Test /* Float8Vector */\n   public void testReallocAfterVectorTransfer1() {\n     try (final Float8Vector vector = new Float8Vector(EMPTY_SCHEMA_PATH, allocator)) {\n-      final Float8Vector.Mutator mutator = vector.getMutator();\n-      final Float8Vector.Accessor accessor = vector.getAccessor();\n       final int initialDefaultCapacity = 4096;\n       boolean error = false;\n \n@@ -984,7 +975,7 @@ public void testReallocAfterVectorTransfer1() {\n       double baseValue = 100.375;\n \n       for (int i = 0; i < initialDefaultCapacity; i++) {\n-        mutator.setSafe(i, baseValue + (double)i);\n+        vector.setSafe(i, baseValue + (double)i);\n       }\n \n       /* the above setSafe calls should not have triggered a realloc as\n@@ -993,33 +984,33 @@ public void testReallocAfterVectorTransfer1() {\n       assertEquals(initialDefaultCapacity, vector.getValueCapacity());\n \n       for (int i = 0; i < initialDefaultCapacity; i++) {\n-        double value = accessor.get(i);\n+        double value = vector.get(i);\n         assertEquals(baseValue + (double)i, value, 0);\n       }\n \n       /* this should trigger a realloc */\n-      mutator.setSafe(initialDefaultCapacity, baseValue + (double)initialDefaultCapacity);\n+      vector.setSafe(initialDefaultCapacity, baseValue + (double)initialDefaultCapacity);\n       assertEquals(initialDefaultCapacity * 2, vector.getValueCapacity());\n \n       for (int i = initialDefaultCapacity + 1; i < (initialDefaultCapacity * 2); i++) {\n-        mutator.setSafe(i, baseValue + (double)i);\n+        vector.setSafe(i, baseValue + (double)i);\n       }\n \n       for (int i = 0; i < (initialDefaultCapacity * 2); i++) {\n-        double value = accessor.get(i);\n+        double value = vector.get(i);\n         assertEquals(baseValue + (double)i, value, 0);\n       }\n \n       /* this should trigger a realloc */\n-      mutator.setSafe(initialDefaultCapacity * 2, baseValue + (double)(initialDefaultCapacity * 2));\n+      vector.setSafe(initialDefaultCapacity * 2, baseValue + (double)(initialDefaultCapacity * 2));\n       assertEquals(initialDefaultCapacity * 4, vector.getValueCapacity());\n \n       for (int i = (initialDefaultCapacity * 2) + 1; i < (initialDefaultCapacity * 4); i++) {\n-        mutator.setSafe(i, baseValue + (double)i);\n+        vector.setSafe(i, baseValue + (double)i);\n       }\n \n       for (int i = 0; i < (initialDefaultCapacity * 4); i++) {\n-        double value = accessor.get(i);\n+        double value = vector.get(i);\n         assertEquals(baseValue + (double)i, value, 0);\n       }\n \n@@ -1036,15 +1027,12 @@ public void testReallocAfterVectorTransfer1() {\n       toVector.reAlloc();\n       assertEquals(initialDefaultCapacity * 8, toVector.getValueCapacity());\n \n-      final Float8Vector.Accessor toAccessor = toVector.getAccessor();\n-\n       for (int i = 0; i < (initialDefaultCapacity * 8); i++) {\n-        double value = toAccessor.get(i);\n         if (i < (initialDefaultCapacity * 4)) {\n-          assertEquals(baseValue + (double)i, value, 0);\n+          assertEquals(baseValue + (double)i, toVector.get(i), 0);\n         }\n         else {\n-          assertEquals(0, value, 0);\n+          assertTrue(toVector.isNull(i));\n         }\n       }\n \n@@ -1052,9 +1040,9 @@ public void testReallocAfterVectorTransfer1() {\n     }\n   }\n \n-  @Test /* NullableFloat8Vector */\n+  @Test /* Float8Vector */\n   public void testReallocAfterVectorTransfer2() {\n-    try (final NullableFloat8Vector vector = new NullableFloat8Vector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final Float8Vector vector = new Float8Vector(EMPTY_SCHEMA_PATH, allocator)) {\n       final int initialDefaultCapacity = 4096;\n       boolean error = false;\n \n@@ -1111,7 +1099,7 @@ public void testReallocAfterVectorTransfer2() {\n       TransferPair transferPair = vector.getTransferPair(allocator);\n       transferPair.transfer();\n \n-      NullableFloat8Vector toVector = (NullableFloat8Vector)transferPair.getTo();\n+      Float8Vector toVector = (Float8Vector)transferPair.getTo();\n \n       /* check toVector contents before realloc */\n       for (int i = 0; i < (initialDefaultCapacity * 4); i++) {\n@@ -1139,9 +1127,9 @@ public void testReallocAfterVectorTransfer2() {\n     }\n   }\n \n-  @Test /* NullableVarCharVector */\n+  @Test /* VarCharVector */\n   public void testReallocAfterVectorTransfer3() {\n-    try (final NullableVarCharVector vector = new NullableVarCharVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final VarCharVector vector = new VarCharVector(EMPTY_SCHEMA_PATH, allocator)) {\n       /* 4096 values with 10 byte per record */\n       vector.allocateNew(4096 * 10, 4096);\n       int valueCapacity = vector.getValueCapacity();\n@@ -1223,7 +1211,7 @@ public void testReallocAfterVectorTransfer3() {\n \n       TransferPair transferPair = vector.getTransferPair(allocator);\n       transferPair.transfer();\n-      NullableVarCharVector toVector = (NullableVarCharVector)transferPair.getTo();\n+      VarCharVector toVector = (VarCharVector)transferPair.getTo();\n       valueCapacity = toVector.getValueCapacity();\n \n       for (int i = 0; i < valueCapacity; i++) {\n@@ -1239,9 +1227,9 @@ public void testReallocAfterVectorTransfer3() {\n     }\n   }\n \n-  @Test /* NullableIntVector */\n+  @Test /* IntVector */\n   public void testReallocAfterVectorTransfer4() {\n-    try (final NullableIntVector vector = new NullableIntVector(EMPTY_SCHEMA_PATH, allocator)) {\n+    try (final IntVector vector = new IntVector(EMPTY_SCHEMA_PATH, allocator)) {\n \n       /* 4096 values  */\n       vector.allocateNew(4096);\n@@ -1316,7 +1304,7 @@ public void testReallocAfterVectorTransfer4() {\n \n       TransferPair transferPair = vector.getTransferPair(allocator);\n       transferPair.transfer();\n-      NullableIntVector toVector = (NullableIntVector)transferPair.getTo();\n+      IntVector toVector = (IntVector)transferPair.getTo();\n       /* value capacity of source and target vectors should be same after\n        * the transfer.\n        */\n@@ -1336,9 +1324,9 @@ public void testReallocAfterVectorTransfer4() {\n   }\n \n   @Test\n-  public void testReAllocNullableFixedWidthVector() {\n+  public void testReAllocFixedWidthVector() {\n     // Create a new value vector for 1024 integers\n-    try (final NullableFloat4Vector vector = newVector(NullableFloat4Vector.class, EMPTY_SCHEMA_PATH, MinorType.FLOAT4, allocator)) {\n+    try (final Float4Vector vector = newVector(Float4Vector.class, EMPTY_SCHEMA_PATH, MinorType.FLOAT4, allocator)) {\n       vector.allocateNew(1024);\n \n       assertEquals(1024, vector.getValueCapacity());\n@@ -1359,7 +1347,7 @@ public void testReAllocNullableFixedWidthVector() {\n       assertEquals(104.5f, vector.get(1023), 0);\n       assertEquals(105.5f, vector.get(2000), 0);\n \n-      // Set the valueCount to be more than valueCapacity of current allocation. This is possible for NullableValueVectors\n+      // Set the valueCount to be more than valueCapacity of current allocation. This is possible for ValueVectors\n       // as we don't call setSafe for null values, but we do call setValueCount when all values are inserted into the\n       // vector\n       vector.setValueCount(vector.getValueCapacity() + 200);\n@@ -1367,8 +1355,8 @@ public void testReAllocNullableFixedWidthVector() {\n   }\n \n   @Test\n-  public void testReAllocNullableVariableWidthVector() {\n-    try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n+  public void testReAllocVariableWidthVector() {\n+    try (final VarCharVector vector = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n       vector.allocateNew();\n \n       int initialCapacity = vector.getValueCapacity();\n@@ -1392,7 +1380,7 @@ public void testReAllocNullableVariableWidthVector() {\n       assertArrayEquals(STR2, vector.get(initialCapacity - 1));\n       assertArrayEquals(STR3, vector.get(initialCapacity + 200));\n \n-      // Set the valueCount to be more than valueCapacity of current allocation. This is possible for NullableValueVectors\n+      // Set the valueCount to be more than valueCapacity of current allocation. This is possible for ValueVectors\n       // as we don't call setSafe for null values, but we do call setValueCount when the current batch is processed.\n       vector.setValueCount(vector.getValueCapacity() + 200);\n     }\n@@ -1400,7 +1388,7 @@ public void testReAllocNullableVariableWidthVector() {\n \n   @Test\n   public void testFillEmptiesNotOverfill() {\n-    try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n+    try (final VarCharVector vector = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n       vector.allocateNew();\n \n       int initialCapacity = vector.getValueCapacity();\n@@ -1420,8 +1408,8 @@ public void testFillEmptiesNotOverfill() {\n \n   @Test\n   public void testCopyFromWithNulls() {\n-    try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator);\n-         final NullableVarCharVector vector2 = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n+    try (final VarCharVector vector = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator);\n+         final VarCharVector vector2 = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n \n       vector.allocateNew();\n       int capacity = vector.getValueCapacity();\n@@ -1480,8 +1468,8 @@ public void testCopyFromWithNulls() {\n \n   @Test\n   public void testCopyFromWithNulls1() {\n-    try (final NullableVarCharVector vector = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator);\n-         final NullableVarCharVector vector2 = newVector(NullableVarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n+    try (final VarCharVector vector = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator);\n+         final VarCharVector vector2 = newVector(VarCharVector.class, EMPTY_SCHEMA_PATH, MinorType.VARCHAR, allocator)) {\n \n       vector.allocateNew();\n       int capacity = vector.getValueCapacity();\n@@ -1544,7 +1532,7 @@ public void testCopyFromWithNulls1() {\n \n   @Test\n   public void testSetLastSetUsage() {\n-    try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n+    try (final VarCharVector vector = new VarCharVector(\"myvector\", allocator)) {\n       vector.allocateNew(1024 * 10, 1024);\n \n       setBytes(0, STR1, vector);\n@@ -1657,7 +1645,7 @@ public void testSetLastSetUsage() {\n   @Test\n   public void testVectorLoadUnload() {\n \n-    try (final NullableVarCharVector vector1 = new NullableVarCharVector(\"myvector\", allocator)) {\n+    try (final VarCharVector vector1 = new VarCharVector(\"myvector\", allocator)) {\n       vector1.allocateNew(1024 * 10, 1024);\n \n       vector1.set(0, STR1);\n@@ -1701,7 +1689,7 @@ public void testVectorLoadUnload() {\n         VectorLoader vectorLoader = new VectorLoader(schemaRoot2);\n         vectorLoader.load(recordBatch);\n \n-        NullableVarCharVector vector2 = (NullableVarCharVector) schemaRoot2.getVector(fieldName);\n+        VarCharVector vector2 = (VarCharVector) schemaRoot2.getVector(fieldName);\n         /*\n          * lastSet would have internally been set by VectorLoader.load() when it invokes\n          * loadFieldBuffers.\n@@ -1723,7 +1711,7 @@ public void testVectorLoadUnload() {\n \n   @Test\n   public void testFillEmptiesUsage() {\n-    try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n+    try (final VarCharVector vector = new VarCharVector(\"myvector\", allocator)) {\n \n       vector.allocateNew(1024 * 10, 1024);\n \n@@ -1830,10 +1818,10 @@ public void testFillEmptiesUsage() {\n     }\n   }\n \n-  @Test /* NullableVarCharVector */\n+  @Test /* VarCharVector */\n   public void testGetBufferAddress1() {\n \n-    try (final NullableVarCharVector vector = new NullableVarCharVector(\"myvector\", allocator)) {\n+    try (final VarCharVector vector = new VarCharVector(\"myvector\", allocator)) {\n       vector.allocateNew(1024 * 10, 1024);\n \n       /* populate the vector */\n@@ -1866,9 +1854,9 @@ public void testGetBufferAddress1() {\n     }\n   }\n \n-  @Test /* NullableIntVector */\n+  @Test /* IntVector */\n   public void testGetBufferAddress2() {\n-    try (final NullableIntVector vector = new NullableIntVector(\"myvector\", allocator)) {\n+    try (final IntVector vector = new IntVector(\"myvector\", allocator)) {\n       boolean error = false;\n       vector.allocateNew(16);\n \n@@ -1905,7 +1893,7 @@ public void testGetBufferAddress2() {\n   @Test\n   public void testMultipleClose() {\n     BufferAllocator vectorAllocator = allocator.newChildAllocator(\"vector_allocator\", 0, Long.MAX_VALUE);\n-    NullableIntVector vector = newVector(NullableIntVector.class, EMPTY_SCHEMA_PATH, MinorType.INT, vectorAllocator);\n+    IntVector vector = newVector(IntVector.class, EMPTY_SCHEMA_PATH, MinorType.INT, vectorAllocator);\n     vector.close();\n     vectorAllocator.close();\n     vector.close();\n@@ -1916,7 +1904,7 @@ public void testMultipleClose() {\n    * lastSet. The method is to test the lastSet property and that's why we load the vector\n    * in a way that lastSet is not set automatically.\n    */\n-  public static void setBytes(int index, byte[] bytes, NullableVarCharVector vector) {\n+  public static void setBytes(int index, byte[] bytes, VarCharVector vector) {\n     final int currentOffset = vector.offsetBuffer.getInt(index * vector.OFFSET_WIDTH);\n \n     BitVectorHelper.setValidityBitToOne(vector.validityBuffer, index);\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\nindex 293ffbfe1..c0df4881f 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReAlloc.java\n@@ -26,7 +26,7 @@\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.RootAllocator;\n import org.apache.arrow.vector.complex.ListVector;\n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.MapVector;\n import org.apache.arrow.vector.types.Types.MinorType;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n import org.apache.arrow.vector.types.pojo.FieldType;\n@@ -53,14 +53,13 @@ public void terminate() throws Exception {\n   @Test\n   public void testFixedType() {\n     try (final UInt4Vector vector = new UInt4Vector(\"\", allocator)) {\n-      final UInt4Vector.Mutator m = vector.getMutator();\n       vector.setInitialCapacity(512);\n       vector.allocateNew();\n \n       assertEquals(512, vector.getValueCapacity());\n \n       try {\n-        m.set(512, 0);\n+        vector.set(512, 0);\n         Assert.fail(\"Expected out of bounds exception\");\n       } catch (Exception e) {\n         // ok\n@@ -69,14 +68,14 @@ public void testFixedType() {\n       vector.reAlloc();\n       assertEquals(1024, vector.getValueCapacity());\n \n-      m.set(512, 100);\n-      assertEquals(100, vector.getAccessor().get(512));\n+      vector.set(512, 100);\n+      assertEquals(100, vector.get(512));\n     }\n   }\n \n   @Test\n   public void testNullableType() {\n-    try (final NullableVarCharVector vector = new NullableVarCharVector(\"\", allocator)) {\n+    try (final VarCharVector vector = new VarCharVector(\"\", allocator)) {\n       vector.setInitialCapacity(512);\n       vector.allocateNew();\n \n@@ -108,7 +107,7 @@ public void testListType() {\n       assertEquals(1023, vector.getValueCapacity());\n \n       try {\n-        vector.getOffsetVector().getAccessor().get(2014);\n+        vector.getInnerValueCountAt(2014);\n         Assert.fail(\"Expected out of bounds exception\");\n       } catch (Exception e) {\n         // ok\n@@ -122,8 +121,8 @@ public void testListType() {\n \n   @Test\n   public void testMapType() {\n-    try (final NullableMapVector vector = NullableMapVector.empty(\"\", allocator)) {\n-      vector.addOrGet(\"\", FieldType.nullable(MinorType.INT.getType()), NullableIntVector.class);\n+    try (final MapVector vector = MapVector.empty(\"\", allocator)) {\n+      vector.addOrGet(\"\", FieldType.nullable(MinorType.INT.getType()), IntVector.class);\n \n       vector.setInitialCapacity(512);\n       vector.allocateNew();\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReset.java b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReset.java\nindex d53f69489..28903b117 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReset.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorReset.java\n@@ -43,12 +43,11 @@ public void terminate() throws Exception {\n   @Test\n   public void testFixedTypeReset() {\n     try (final UInt4Vector vector = new UInt4Vector(\"\", allocator)) {\n-      final UInt4Vector.Mutator m = vector.getMutator();\n       vector.allocateNew();\n-      final int sizeBefore = vector.getAllocationSize();\n+      final int sizeBefore = vector.getBufferSize();\n       vector.reAlloc();\n       vector.reset();\n-      final int sizeAfter = vector.getAllocationSize();\n+      final int sizeAfter = vector.getBufferSize();\n       assertEquals(sizeBefore, sizeAfter);\n     }\n   }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java\nindex e61dbecf4..439a62725 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/TestVectorUnloadLoad.java\n@@ -236,8 +236,8 @@ public void testLoadValidityBuffer() throws IOException {\n \n       vectorLoader.load(recordBatch);\n \n-      NullableIntVector intDefinedVector = (NullableIntVector) newRoot.getVector(\"intDefined\");\n-      NullableIntVector intNullVector = (NullableIntVector) newRoot.getVector(\"intNull\");\n+      IntVector intDefinedVector = (IntVector) newRoot.getVector(\"intDefined\");\n+      IntVector intNullVector = (IntVector) newRoot.getVector(\"intNull\");\n       for (int i = 0; i < count; i++) {\n         assertFalse(\"#\" + i, intDefinedVector.isNull(i));\n         assertEquals(\"#\" + i, i, intDefinedVector.get(i));\n@@ -283,7 +283,7 @@ public void testUnloadLoadDuplicates() throws IOException {\n         FieldVector vector = field.createVector(originalVectorsAllocator);\n         vector.allocateNew();\n         sources.add(vector);\n-        NullableIntVector intVector = (NullableIntVector)vector;\n+        IntVector intVector = (IntVector)vector;\n         for (int i = 0; i < count; i++) {\n           intVector.set(i, i);\n         }\n@@ -302,8 +302,8 @@ public void testUnloadLoadDuplicates() throws IOException {\n           List<FieldVector> targets = newRoot.getFieldVectors();\n           Assert.assertEquals(sources.size(), targets.size());\n           for (int k = 0; k < sources.size(); k++) {\n-            NullableIntVector src = (NullableIntVector) sources.get(k);\n-            NullableIntVector tgt = (NullableIntVector) targets.get(k);\n+            IntVector src = (IntVector) sources.get(k);\n+            IntVector tgt = (IntVector) targets.get(k);\n             Assert.assertEquals(src.getValueCount(), tgt.getValueCount());\n             for (int i = 0; i < count; i++) {\n               Assert.assertEquals(src.get(i), tgt.get(i));\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java b/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java\nindex b0d6cf555..38b78424d 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/complex/impl/TestPromotableWriter.java\n@@ -25,7 +25,7 @@\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.DirtyRootAllocator;\n import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.MapVector;\n import org.apache.arrow.vector.complex.UnionVector;\n import org.apache.arrow.vector.complex.writer.BaseWriter.MapWriter;\n import org.apache.arrow.vector.types.pojo.ArrowType;\n@@ -55,7 +55,7 @@ public void terminate() throws Exception {\n   public void testPromoteToUnion() throws Exception {\n \n     try (final MapVector container = MapVector.empty(EMPTY_SCHEMA_PATH, allocator);\n-         final NullableMapVector v = container.addOrGetMap(\"test\");\n+         final MapVector v = container.addOrGetMap(\"test\");\n          final PromotableWriter writer = new PromotableWriter(v, container)) {\n \n       container.allocateNew();\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java b/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java\nindex 52defdc2e..bd8489eb2 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/complex/writer/TestComplexWriter.java\n@@ -28,13 +28,13 @@\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.RootAllocator;\n import org.apache.arrow.vector.SchemaChangeCallBack;\n-import org.apache.arrow.vector.NullableFloat8Vector;\n-import org.apache.arrow.vector.NullableFloat4Vector;\n-import org.apache.arrow.vector.NullableBigIntVector;\n-import org.apache.arrow.vector.NullableIntVector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.IntVector;\n import org.apache.arrow.vector.complex.ListVector;\n import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.NonNullableMapVector;\n import org.apache.arrow.vector.complex.UnionVector;\n import org.apache.arrow.vector.complex.impl.ComplexWriterImpl;\n import org.apache.arrow.vector.complex.impl.SingleMapReaderImpl;\n@@ -830,7 +830,7 @@ public void complexCopierWithList() {\n     rootWriter.end();\n     writer.setValueCount(1);\n \n-    NullableMapVector mapVector = (NullableMapVector) parent.getChild(\"root\");\n+    MapVector mapVector = (MapVector) parent.getChild(\"root\");\n     TransferPair tp = mapVector.getTransferPair(allocator);\n     tp.splitAndTransfer(0, 1);\n     MapVector toMapVector = (MapVector) tp.getTo();\n@@ -849,7 +849,7 @@ public void testSingleMapWriter1() {\n     /* initialize a SingleMapWriter with empty MapVector and then lazily\n      * create all vectors with expected initialCapacity.\n      */\n-    MapVector parent = MapVector.empty(\"parent\", allocator);\n+    NonNullableMapVector parent = NonNullableMapVector.empty(\"parent\", allocator);\n     SingleMapWriter singleMapWriter = new SingleMapWriter(parent);\n \n     int initialCapacity = 1024;\n@@ -885,10 +885,10 @@ public void testSingleMapWriter1() {\n       singleMapWriter.end();\n     }\n \n-    NullableIntVector intVector = (NullableIntVector)parent.getChild(\"intField\");\n-    NullableBigIntVector bigIntVector = (NullableBigIntVector)parent.getChild(\"bigIntField\");\n-    NullableFloat4Vector float4Vector = (NullableFloat4Vector)parent.getChild(\"float4Field\");\n-    NullableFloat8Vector float8Vector = (NullableFloat8Vector)parent.getChild(\"float8Field\");\n+    IntVector intVector = (IntVector)parent.getChild(\"intField\");\n+    BigIntVector bigIntVector = (BigIntVector)parent.getChild(\"bigIntField\");\n+    Float4Vector float4Vector = (Float4Vector)parent.getChild(\"float4Field\");\n+    Float8Vector float8Vector = (Float8Vector)parent.getChild(\"float8Field\");\n \n     assertEquals(initialCapacity, singleMapWriter.getValueCapacity());\n     assertEquals(initialCapacity, intVector.getValueCapacity());\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/ipc/BaseFileTest.java b/java/vector/src/test/java/org/apache/arrow/vector/ipc/BaseFileTest.java\nindex 233b682c9..3514acaa2 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/ipc/BaseFileTest.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/ipc/BaseFileTest.java\n@@ -28,17 +28,17 @@\n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.RootAllocator;\n import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.NullableDateMilliVector;\n-import org.apache.arrow.vector.NullableDecimalVector;\n-import org.apache.arrow.vector.NullableIntVector;\n-import org.apache.arrow.vector.NullableTimeMilliVector;\n-import org.apache.arrow.vector.NullableVarBinaryVector;\n-import org.apache.arrow.vector.NullableVarCharVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n import org.apache.arrow.vector.ValueVector.Accessor;\n import org.apache.arrow.vector.VectorSchemaRoot;\n import org.apache.arrow.vector.complex.ListVector;\n import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.MapVector;\n import org.apache.arrow.vector.complex.impl.ComplexWriterImpl;\n import org.apache.arrow.vector.complex.impl.UnionListWriter;\n import org.apache.arrow.vector.complex.reader.FieldReader;\n@@ -71,7 +71,7 @@\n \n import io.netty.buffer.ArrowBuf;\n \n-import static org.apache.arrow.vector.TestUtils.newNullableVarCharVector;\n+import static org.apache.arrow.vector.TestUtils.newVarCharVector;\n \n /**\n  * Helps testing the file formats\n@@ -172,7 +172,7 @@ private LocalDateTime makeDateTimeFromCount(int i) {\n     return new LocalDateTime(2000 + i, 1 + i, 1 + i, i, i, i, i);\n   }\n \n-  protected void writeDateTimeData(int count, NullableMapVector parent) {\n+  protected void writeDateTimeData(int count, MapVector parent) {\n     Assert.assertTrue(count < 100);\n     ComplexWriter writer = new ComplexWriterImpl(\"root\", parent);\n     MapWriter rootWriter = writer.rootAsMap();\n@@ -202,11 +202,11 @@ protected void validateDateTimeContent(int count, VectorSchemaRoot root) {\n     Assert.assertEquals(count, root.getRowCount());\n     printVectors(root.getFieldVectors());\n     for (int i = 0; i < count; i++) {\n-      long dateVal = ((NullableDateMilliVector) root.getVector(\"date\")).get(i);\n+      long dateVal = ((DateMilliVector) root.getVector(\"date\")).get(i);\n       LocalDateTime dt = makeDateTimeFromCount(i);\n       LocalDateTime dateExpected = dt.minusMillis(dt.getMillisOfDay());\n       Assert.assertEquals(DateUtility.toMillis(dateExpected), dateVal);\n-      long timeVal = ((NullableTimeMilliVector) root.getVector(\"time\")).get(i);\n+      long timeVal = ((TimeMilliVector) root.getVector(\"time\")).get(i);\n       Assert.assertEquals(dt.getMillisOfDay(), timeVal);\n       Object timestampMilliVal = root.getVector(\"timestamp-milli\").getObject(i);\n       Assert.assertEquals(dt, timestampMilliVal);\n@@ -218,7 +218,7 @@ protected void validateDateTimeContent(int count, VectorSchemaRoot root) {\n   protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocator, DictionaryProvider.MapDictionaryProvider provider) {\n \n     // Define dictionaries and add to provider\n-    NullableVarCharVector dictionary1Vector = newNullableVarCharVector(\"D1\", bufferAllocator);\n+    VarCharVector dictionary1Vector = newVarCharVector(\"D1\", bufferAllocator);\n     dictionary1Vector.allocateNewSafe();\n     dictionary1Vector.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n     dictionary1Vector.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n@@ -228,7 +228,7 @@ protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocat\n     Dictionary dictionary1 = new Dictionary(dictionary1Vector, new DictionaryEncoding(1L, false, null));\n     provider.put(dictionary1);\n \n-    NullableVarCharVector dictionary2Vector = newNullableVarCharVector(\"D2\", bufferAllocator);\n+    VarCharVector dictionary2Vector = newVarCharVector(\"D2\", bufferAllocator);\n     dictionary2Vector.allocateNewSafe();\n     dictionary2Vector.set(0, \"micro\".getBytes(StandardCharsets.UTF_8));\n     dictionary2Vector.set(1, \"small\".getBytes(StandardCharsets.UTF_8));\n@@ -239,7 +239,7 @@ protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocat\n     provider.put(dictionary2);\n \n     // Populate the vectors\n-    NullableVarCharVector vector1A = newNullableVarCharVector(\"varcharA\", bufferAllocator);\n+    VarCharVector vector1A = newVarCharVector(\"varcharA\", bufferAllocator);\n     vector1A.allocateNewSafe();\n     vector1A.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n     vector1A.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n@@ -252,7 +252,7 @@ protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocat\n     vector1A.close();  // Done with this vector after encoding\n \n     // Write this vector using indices instead of encoding\n-    NullableIntVector encodedVector1B = new NullableIntVector(\"varcharB\", bufferAllocator);\n+    IntVector encodedVector1B = new IntVector(\"varcharB\", bufferAllocator);\n     encodedVector1B.allocateNewSafe();\n     encodedVector1B.set(0, 2);  // \"baz\"\n     encodedVector1B.set(1, 1);  // \"bar\"\n@@ -261,7 +261,7 @@ protected VectorSchemaRoot writeFlatDictionaryData(BufferAllocator bufferAllocat\n     encodedVector1B.set(5, 0);  // \"foo\"\n     encodedVector1B.setValueCount(6);\n \n-    NullableVarCharVector vector2 = newNullableVarCharVector(\"sizes\", bufferAllocator);\n+    VarCharVector vector2 = newVarCharVector(\"sizes\", bufferAllocator);\n     vector2.allocateNewSafe();\n     vector2.set(1, \"large\".getBytes(StandardCharsets.UTF_8));\n     vector2.set(2, \"small\".getBytes(StandardCharsets.UTF_8));\n@@ -327,7 +327,7 @@ protected void validateFlatDictionary(VectorSchemaRoot root, DictionaryProvider\n \n     Dictionary dictionary1 = provider.lookup(1L);\n     Assert.assertNotNull(dictionary1);\n-    NullableVarCharVector dictionaryVector = ((NullableVarCharVector) dictionary1.getVector());\n+    VarCharVector dictionaryVector = ((VarCharVector) dictionary1.getVector());\n     Assert.assertEquals(3, dictionaryVector.getValueCount());\n     Assert.assertEquals(new Text(\"foo\"), dictionaryVector.getObject(0));\n     Assert.assertEquals(new Text(\"bar\"), dictionaryVector.getObject(1));\n@@ -335,7 +335,7 @@ protected void validateFlatDictionary(VectorSchemaRoot root, DictionaryProvider\n \n     Dictionary dictionary2 = provider.lookup(2L);\n     Assert.assertNotNull(dictionary2);\n-    dictionaryVector = ((NullableVarCharVector) dictionary2.getVector());\n+    dictionaryVector = ((VarCharVector) dictionary2.getVector());\n     Assert.assertEquals(3, dictionaryVector.getValueCount());\n     Assert.assertEquals(new Text(\"micro\"), dictionaryVector.getObject(0));\n     Assert.assertEquals(new Text(\"small\"), dictionaryVector.getObject(1));\n@@ -345,7 +345,7 @@ protected void validateFlatDictionary(VectorSchemaRoot root, DictionaryProvider\n   protected VectorSchemaRoot writeNestedDictionaryData(BufferAllocator bufferAllocator, DictionaryProvider.MapDictionaryProvider provider) {\n \n     // Define the dictionary and add to the provider\n-    NullableVarCharVector dictionaryVector = newNullableVarCharVector(\"D2\", bufferAllocator);\n+    VarCharVector dictionaryVector = newVarCharVector(\"D2\", bufferAllocator);\n     dictionaryVector.allocateNewSafe();\n     dictionaryVector.set(0, \"foo\".getBytes(StandardCharsets.UTF_8));\n     dictionaryVector.set(1, \"bar\".getBytes(StandardCharsets.UTF_8));\n@@ -395,16 +395,16 @@ protected void validateNestedDictionary(VectorSchemaRoot root, DictionaryProvide\n \n     Dictionary dictionary = provider.lookup(2L);\n     Assert.assertNotNull(dictionary);\n-    NullableVarCharVector dictionaryVector = ((NullableVarCharVector) dictionary.getVector());\n+    VarCharVector dictionaryVector = ((VarCharVector) dictionary.getVector());\n     Assert.assertEquals(2, dictionaryVector.getValueCount());\n     Assert.assertEquals(new Text(\"foo\"), dictionaryVector.getObject(0));\n     Assert.assertEquals(new Text(\"bar\"), dictionaryVector.getObject(1));\n   }\n \n   protected VectorSchemaRoot writeDecimalData(BufferAllocator bufferAllocator) {\n-    NullableDecimalVector decimalVector1 = new NullableDecimalVector(\"decimal1\", bufferAllocator, 10, 3);\n-    NullableDecimalVector decimalVector2 = new NullableDecimalVector(\"decimal2\", bufferAllocator, 4, 2);\n-    NullableDecimalVector decimalVector3 = new NullableDecimalVector(\"decimal3\", bufferAllocator, 16, 8);\n+    DecimalVector decimalVector1 = new DecimalVector(\"decimal1\", bufferAllocator, 10, 3);\n+    DecimalVector decimalVector2 = new DecimalVector(\"decimal2\", bufferAllocator, 4, 2);\n+    DecimalVector decimalVector3 = new DecimalVector(\"decimal3\", bufferAllocator, 16, 8);\n \n     int count = 10;\n     decimalVector1.allocateNew(count);\n@@ -427,9 +427,9 @@ protected VectorSchemaRoot writeDecimalData(BufferAllocator bufferAllocator) {\n   }\n \n   protected void validateDecimalData(VectorSchemaRoot root) {\n-    NullableDecimalVector decimalVector1 = (NullableDecimalVector) root.getVector(\"decimal1\");\n-    NullableDecimalVector decimalVector2 = (NullableDecimalVector) root.getVector(\"decimal2\");\n-    NullableDecimalVector decimalVector3 = (NullableDecimalVector) root.getVector(\"decimal3\");\n+    DecimalVector decimalVector1 = (DecimalVector) root.getVector(\"decimal1\");\n+    DecimalVector decimalVector2 = (DecimalVector) root.getVector(\"decimal2\");\n+    DecimalVector decimalVector3 = (DecimalVector) root.getVector(\"decimal3\");\n     int count = 10;\n     Assert.assertEquals(count, root.getRowCount());\n \n@@ -491,7 +491,7 @@ public void validateUnionData(int count, VectorSchemaRoot root) {\n     }\n   }\n \n-  public void writeUnionData(int count, NullableMapVector parent) {\n+  public void writeUnionData(int count, MapVector parent) {\n     ArrowBuf varchar = allocator.buffer(3);\n     varchar.readerIndex(0);\n     varchar.setByte(0, 'a');\n@@ -534,7 +534,7 @@ public void writeUnionData(int count, NullableMapVector parent) {\n     varchar.release();\n   }\n \n-  protected void writeVarBinaryData(int count, NullableMapVector parent) {\n+  protected void writeVarBinaryData(int count, MapVector parent) {\n     Assert.assertTrue(count < 100);\n     ComplexWriter writer = new ComplexWriterImpl(\"root\", parent);\n     MapWriter rootWriter = writer.rootAsMap();\n@@ -577,8 +577,8 @@ protected void validateVarBinary(int count, VectorSchemaRoot root) {\n     // ListVector lastSet should be the index of last value + 1\n     Assert.assertEquals(listVector.getLastSet(), count);\n \n-    // NullableVarBinaryVector lastSet should be the index of last value\n-    NullableVarBinaryVector binaryVector = (NullableVarBinaryVector) listVector.getChildrenFromFields().get(0);\n+    // VarBinaryVector lastSet should be the index of last value\n+    VarBinaryVector binaryVector = (VarBinaryVector) listVector.getChildrenFromFields().get(0);\n     Assert.assertEquals(binaryVector.getLastSet(), numVarBinaryValues - 1);\n   }\n }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowFile.java b/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowFile.java\nindex 4387db036..0cfc9ba91 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowFile.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowFile.java\n@@ -36,14 +36,14 @@\n \n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.vector.FieldVector;\n-import org.apache.arrow.vector.NullableFloat4Vector;\n-import org.apache.arrow.vector.NullableIntVector;\n-import org.apache.arrow.vector.NullableTinyIntVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.TinyIntVector;\n import org.apache.arrow.vector.VectorSchemaRoot;\n import org.apache.arrow.vector.VectorUnloader;\n import org.apache.arrow.vector.complex.FixedSizeListVector;\n import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.MapVector;\n import org.apache.arrow.vector.dictionary.DictionaryProvider.MapDictionaryProvider;\n import org.apache.arrow.vector.ipc.message.ArrowBlock;\n import org.apache.arrow.vector.ipc.message.ArrowBuffer;\n@@ -82,7 +82,7 @@ public void testWriteComplex() throws IOException {\n     int count = COUNT;\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n+        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n       writeComplexData(count, parent);\n       FieldVector root = parent.getChild(\"root\");\n       validateComplexContent(count, new VectorSchemaRoot(root));\n@@ -268,7 +268,7 @@ public void testWriteReadUnion() throws IOException {\n \n     // write\n     try (BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-         NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n+         MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n       writeUnionData(count, parent);\n       validateUnionData(count, new VectorSchemaRoot(parent.getChild(\"root\")));\n       write(parent.getChild(\"root\"), file, stream);\n@@ -304,7 +304,7 @@ public void testWriteReadTiny() throws IOException {\n \n     try (VectorSchemaRoot root = VectorSchemaRoot.create(MessageSerializerTest.testSchema(), allocator)) {\n       root.getFieldVectors().get(0).allocateNew();\n-      NullableTinyIntVector vector = (NullableTinyIntVector) root.getFieldVectors().get(0);\n+      TinyIntVector vector = (TinyIntVector) root.getFieldVectors().get(0);\n       for (int i = 0; i < 16; i++) {\n         vector.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n       }\n@@ -352,7 +352,7 @@ public void testWriteReadTiny() throws IOException {\n \n   private void validateTinyData(VectorSchemaRoot root) {\n     Assert.assertEquals(16, root.getRowCount());\n-    NullableTinyIntVector vector = (NullableTinyIntVector) root.getFieldVectors().get(0);\n+    TinyIntVector vector = (TinyIntVector) root.getFieldVectors().get(0);\n     for (int i = 0; i < 16; i++) {\n       if (i < 8) {\n         Assert.assertEquals((byte) (i + 1), vector.get(i));\n@@ -382,7 +382,7 @@ public void testWriteReadMetadata() throws IOException {\n \n     // write\n     try (BufferAllocator originalVectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-         NullableMapVector vector = (NullableMapVector) field.createVector(originalVectorAllocator)) {\n+         MapVector vector = (MapVector) field.createVector(originalVectorAllocator)) {\n       vector.allocateNewSafe();\n       vector.setValueCount(0);\n \n@@ -558,10 +558,10 @@ public void testWriteReadFixedSizeList() throws IOException {\n \n     // write\n     try (BufferAllocator originalVectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-         NullableMapVector parent = NullableMapVector.empty(\"parent\", originalVectorAllocator)) {\n+         MapVector parent = MapVector.empty(\"parent\", originalVectorAllocator)) {\n       FixedSizeListVector tuples = parent.addOrGet(\"float-pairs\", FieldType.nullable(new FixedSizeList(2)), FixedSizeListVector.class);\n-      NullableFloat4Vector floats = (NullableFloat4Vector) tuples.addOrGetVector(FieldType.nullable(MinorType.FLOAT4.getType())).getVector();\n-      NullableIntVector ints = parent.addOrGet(\"ints\", FieldType.nullable(new Int(32, true)), NullableIntVector.class);\n+      Float4Vector floats = (Float4Vector) tuples.addOrGetVector(FieldType.nullable(MinorType.FLOAT4.getType())).getVector();\n+      IntVector ints = parent.addOrGet(\"ints\", FieldType.nullable(new Int(32, true)), IntVector.class);\n       parent.allocateNew();\n \n       for (int i = 0; i < 10; i++) {\n@@ -618,7 +618,7 @@ public void testWriteReadVarBin() throws IOException {\n     // write\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n+        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n       writeVarBinaryData(count, parent);\n       VectorSchemaRoot root = new VectorSchemaRoot(parent.getChild(\"root\"));\n       validateVarBinary(count, root);\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowStream.java b/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowStream.java\nindex 7a8586a9e..f87a0ebd5 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowStream.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowStream.java\n@@ -26,7 +26,9 @@\n import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n \n-import org.apache.arrow.vector.NullableTinyIntVector;\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.TinyIntVector;\n import org.apache.arrow.vector.VectorSchemaRoot;\n import org.apache.arrow.vector.ipc.ArrowStreamReader;\n import org.apache.arrow.vector.ipc.ArrowStreamWriter;\n@@ -65,7 +67,7 @@ public void testReadWrite() throws IOException {\n       int numBatches = 1;\n \n       root.getFieldVectors().get(0).allocateNew();\n-      NullableTinyIntVector vector = (NullableTinyIntVector)root.getFieldVectors().get(0);\n+      TinyIntVector vector = (TinyIntVector)root.getFieldVectors().get(0);\n       for (int i = 0; i < 16; i++) {\n         vector.set(i, i < 8 ? 1 : 0, (byte) (i + 1));\n       }\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowStreamPipe.java b/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowStreamPipe.java\nindex 65e6cea2e..bd1ec94c8 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowStreamPipe.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestArrowStreamPipe.java\n@@ -28,7 +28,7 @@\n \n import org.apache.arrow.memory.BufferAllocator;\n import org.apache.arrow.memory.RootAllocator;\n-import org.apache.arrow.vector.NullableTinyIntVector;\n+import org.apache.arrow.vector.TinyIntVector;\n import org.apache.arrow.vector.VectorSchemaRoot;\n import org.apache.arrow.vector.ipc.ArrowStreamReader;\n import org.apache.arrow.vector.ipc.ArrowStreamWriter;\n@@ -61,7 +61,7 @@ public void run() {\n         writer.start();\n         for (int j = 0; j < numBatches; j++) {\n           root.getFieldVectors().get(0).allocateNew();\n-          NullableTinyIntVector vector = (NullableTinyIntVector) root.getFieldVectors().get(0);\n+          TinyIntVector vector = (TinyIntVector) root.getFieldVectors().get(0);\n           // Send a changing batch id first\n           vector.set(0, j);\n           for (int i = 1; i < 16; i++) {\n@@ -103,10 +103,9 @@ public boolean loadNextBatch() throws IOException {\n             done = true;\n             return false;\n           }\n-\n           VectorSchemaRoot root = getVectorSchemaRoot();\n           Assert.assertEquals(16, root.getRowCount());\n-          NullableTinyIntVector vector = (NullableTinyIntVector) root.getFieldVectors().get(0);\n+          TinyIntVector vector = (TinyIntVector) root.getFieldVectors().get(0);\n           Assert.assertEquals((byte) (batchesRead - 1), vector.get(0));\n           for (int i = 1; i < 16; i++) {\n             if (i < 8) {\ndiff --git a/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestJSONFile.java b/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestJSONFile.java\nindex c3e0b7951..625717048 100644\n--- a/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestJSONFile.java\n+++ b/java/vector/src/test/java/org/apache/arrow/vector/ipc/TestJSONFile.java\n@@ -25,7 +25,7 @@\n import org.apache.arrow.vector.FieldVector;\n import org.apache.arrow.vector.VectorSchemaRoot;\n import org.apache.arrow.vector.complex.MapVector;\n-import org.apache.arrow.vector.complex.NullableMapVector;\n+import org.apache.arrow.vector.complex.MapVector;\n import org.apache.arrow.vector.dictionary.DictionaryProvider;\n import org.apache.arrow.vector.dictionary.DictionaryProvider.MapDictionaryProvider;\n import org.apache.arrow.vector.types.pojo.Schema;\n@@ -73,7 +73,7 @@ public void testWriteComplexJSON() throws IOException {\n     int count = COUNT;\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n+        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n       writeComplexData(count, parent);\n       VectorSchemaRoot root = new VectorSchemaRoot(parent.getChild(\"root\"));\n       validateComplexContent(root.getRowCount(), root);\n@@ -95,7 +95,7 @@ public void testWriteReadUnionJSON() throws IOException {\n     int count = COUNT;\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n+        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n       writeUnionData(count, parent);\n       printVectors(parent.getChildrenFromFields());\n \n@@ -127,7 +127,7 @@ public void testWriteReadDateTimeJSON() throws IOException {\n     // write\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n+        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n \n       writeDateTimeData(count, parent);\n \n@@ -292,7 +292,7 @@ public void testWriteReadVarBinJSON() throws IOException {\n     // write\n     try (\n         BufferAllocator vectorAllocator = allocator.newChildAllocator(\"original vectors\", 0, Integer.MAX_VALUE);\n-        NullableMapVector parent = NullableMapVector.empty(\"parent\", vectorAllocator)) {\n+        MapVector parent = MapVector.empty(\"parent\", vectorAllocator)) {\n       writeVarBinaryData(count, parent);\n       VectorSchemaRoot root = new VectorSchemaRoot(parent.getChild(\"root\"));\n       validateVarBinary(count, root);\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-28T17:32:52.385+0000",
                    "updated": "2017-11-28T17:32:52.385+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16269110",
                    "id": "16269110",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-347602246\n \n \n   Thanks all!  I will make the follow up JIRAs now\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-28T17:36:46.475+0000",
                    "updated": "2017-11-28T17:36:46.475+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13111269/comment/16269147",
                    "id": "16269147",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1341: ARROW-1710: [Java] Remove Non-Nullable Vectors\nURL: https://github.com/apache/arrow/pull/1341#issuecomment-347607278\n \n \n   Ok I made these for followup:\r\n   \r\n   * [ARROW-1866](https://issues.apache.org/jira/browse/ARROW-1866) to merge the MapVector classes\r\n   * [ARROW-1867](https://issues.apache.org/jira/browse/ARROW-1867) for the missing BitVector APIs\r\n   * [ARROW-1868](https://issues.apache.org/jira/browse/ARROW-1868) for `Types.MinorType` -> `MinorType`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2017-11-28T17:52:06.156+0000",
                    "updated": "2017-11-28T17:52:06.156+0000"
                }
            ],
            "maxResults": 66,
            "total": 66,
            "startAt": 0
        },
        "customfield_12311820": "0|i3lkfb:",
        "customfield_12314139": null
    }
}