{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13117051",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051",
    "key": "ARROW-1780",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12342562",
                "id": "12342562",
                "description": "",
                "name": "0.10.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-08-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
            "name": "atul_dambalkar",
            "key": "atul_dambalkar",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Atul Dambalkar",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
            "name": "atul_dambalkar",
            "key": "atul_dambalkar",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Atul Dambalkar",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
            "name": "atul_dambalkar",
            "key": "atul_dambalkar",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Atul Dambalkar",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 16200,
            "total": 16200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 16200,
            "total": 16200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1780/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 33,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/95737",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "atuldambalkar commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-384794551\n \n \n   Hi @laurentgo ,\r\n   It will be great if you can take a look at the Java code that's committed so far. We are still working on getting the @Parametrized test cases working. But meanwhile if you can review the changes that will be good. Mainly two classes - JdbcToArrow.java and JdbcToArrowUtils.java. \r\n   Thanks.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-26T21:28:03.394+0000",
                    "updated": "2018-04-26T21:28:03.394+0000",
                    "started": "2018-04-26T21:28:03.394+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "95737",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/100976",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "atuldambalkar commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-388258074\n \n \n   Hi @laurentgo We are done with pretty much all the changes you had suggested. Can you please take a look and let me know your review comments? \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-11T04:42:47.097+0000",
                    "updated": "2018-05-11T04:42:47.097+0000",
                    "started": "2018-05-11T04:42:47.096+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "100976",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106976",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r188364263\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,179 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import com.google.common.base.Preconditions;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.ResultSet;\n+import java.util.Calendar;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * TODO: At this time, SQL Data type java.sql.Types.ARRAY is still not supported.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     * This method uses the default Calendar instance with default TimeZone and Locale as returned by the JVM.\n+     * If you wish to use specific TimeZone or Locale for any Date, Time and Timestamp datasets, you may want use\n+     * overloaded API that taken Calendar object instance.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @param allocator Memory allocator\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statement objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query, BaseAllocator allocator) throws SQLException, IOException {\n+        Preconditions.checkNotNull(connection, \"JDBC connection object can not be null\");\n+        Preconditions.checkArgument(query != null && query.length() > 0, \"SQL query can not be null or empty\");\n+        Preconditions.checkNotNull(allocator, \"Memory allocator object can not be null\");\n+\n+        return sqlToArrow(connection, query, allocator, Calendar.getInstance());\n+    }\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @param allocator Memory allocator\n+     * @param calendar Calendar object to use to handle Date, Time and Timestamp datasets.\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statement objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query, BaseAllocator allocator, Calendar calendar) throws SQLException, IOException {\n+        Preconditions.checkNotNull(connection, \"JDBC connection object can not be null\");\n+        Preconditions.checkArgument(query != null && query.length() > 0, \"SQL query can not be null or empty\");\n+        Preconditions.checkNotNull(allocator, \"Memory allocator object can not be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can not be null\");\n+\n+        try (Statement stmt = connection.createStatement()) {\n+            return sqlToArrow(stmt.executeQuery(query), allocator, calendar);\n+        }\n+    }\n+\n+    /**\n+     * For the given JDBC {@link ResultSet}, fetch the data from Relational DB and convert it to Arrow objects. This method\n+     * uses the default RootAllocator and Calendar object.\n+     *\n+     * @param resultSet\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException\n+     */\n+    public static VectorSchemaRoot sqlToArrow(ResultSet resultSet) throws SQLException, IOException {\n+        Preconditions.checkNotNull(resultSet, \"JDBC ResultSet object can not be null\");\n+\n+        return sqlToArrow(resultSet, Calendar.getInstance());\n+    }\n+\n+    /**\n+     * For the given JDBC {@link ResultSet}, fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param resultSet\n+     * @param allocator Memory allocator\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException\n+     */\n+    public static VectorSchemaRoot sqlToArrow(ResultSet resultSet, BaseAllocator allocator) throws SQLException, IOException {\n+        Preconditions.checkNotNull(resultSet, \"JDBC ResultSet object can not be null\");\n+        Preconditions.checkNotNull(allocator, \"Memory Allocator object can not be null\");\n+\n+        return sqlToArrow(resultSet, allocator, Calendar.getInstance());\n+    }\n+\n+    /**\n+     * For the given JDBC {@link ResultSet}, fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param resultSet\n+     * @param calendar Calendar instance to use for Date, Time and Timestamp datasets.\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException\n+     */\n+    public static VectorSchemaRoot sqlToArrow(ResultSet resultSet, Calendar calendar) throws SQLException, IOException {\n+        Preconditions.checkNotNull(resultSet, \"JDBC ResultSet object can not be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can not be null\");\n+\n+        RootAllocator rootAllocator = new RootAllocator(Integer.MAX_VALUE);\n+        VectorSchemaRoot root = sqlToArrow(resultSet, rootAllocator, calendar);\n+        rootAllocator.close();\n \n Review comment:\n   if the allocator is closed, I guess it means data is invalidated? You might prefer not to provide this method...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:36.839+0000",
                    "updated": "2018-05-30T02:56:36.839+0000",
                    "started": "2018-05-30T02:56:36.839+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106976",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106977",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r188363890\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,179 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import com.google.common.base.Preconditions;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.ResultSet;\n+import java.util.Calendar;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * TODO: At this time, SQL Data type java.sql.Types.ARRAY is still not supported.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     * This method uses the default Calendar instance with default TimeZone and Locale as returned by the JVM.\n+     * If you wish to use specific TimeZone or Locale for any Date, Time and Timestamp datasets, you may want use\n+     * overloaded API that taken Calendar object instance.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @param allocator Memory allocator\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statement objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query, BaseAllocator allocator) throws SQLException, IOException {\n+        Preconditions.checkNotNull(connection, \"JDBC connection object can not be null\");\n+        Preconditions.checkArgument(query != null && query.length() > 0, \"SQL query can not be null or empty\");\n+        Preconditions.checkNotNull(allocator, \"Memory allocator object can not be null\");\n+\n+        return sqlToArrow(connection, query, allocator, Calendar.getInstance());\n+    }\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @param allocator Memory allocator\n+     * @param calendar Calendar object to use to handle Date, Time and Timestamp datasets.\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statement objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query, BaseAllocator allocator, Calendar calendar) throws SQLException, IOException {\n+        Preconditions.checkNotNull(connection, \"JDBC connection object can not be null\");\n+        Preconditions.checkArgument(query != null && query.length() > 0, \"SQL query can not be null or empty\");\n+        Preconditions.checkNotNull(allocator, \"Memory allocator object can not be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can not be null\");\n+\n+        try (Statement stmt = connection.createStatement()) {\n+            return sqlToArrow(stmt.executeQuery(query), allocator, calendar);\n+        }\n+    }\n+\n+    /**\n+     * For the given JDBC {@link ResultSet}, fetch the data from Relational DB and convert it to Arrow objects. This method\n+     * uses the default RootAllocator and Calendar object.\n+     *\n+     * @param resultSet\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException\n+     */\n+    public static VectorSchemaRoot sqlToArrow(ResultSet resultSet) throws SQLException, IOException {\n+        Preconditions.checkNotNull(resultSet, \"JDBC ResultSet object can not be null\");\n+\n+        return sqlToArrow(resultSet, Calendar.getInstance());\n \n Review comment:\n   Timezone/Locale should always be specified (UTC, Locale.ROOT)?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.191+0000",
                    "updated": "2018-05-30T02:56:37.191+0000",
                    "started": "2018-05-30T02:56:37.191+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106977",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106978",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r188365374\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.holders.NullableBigIntHolder;\n+import org.apache.arrow.vector.holders.NullableBitHolder;\n+import org.apache.arrow.vector.holders.NullableDateMilliHolder;\n+import org.apache.arrow.vector.holders.NullableDecimalHolder;\n+import org.apache.arrow.vector.holders.NullableFloat4Holder;\n+import org.apache.arrow.vector.holders.NullableFloat8Holder;\n+import org.apache.arrow.vector.holders.NullableIntHolder;\n+import org.apache.arrow.vector.holders.NullableSmallIntHolder;\n+import org.apache.arrow.vector.holders.NullableTimeMilliHolder;\n+import org.apache.arrow.vector.holders.NullableTinyIntHolder;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.arrow.vector.holders.VarBinaryHolder;\n+import org.apache.arrow.vector.holders.VarCharHolder;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.apache.arrow.vector.util.DecimalUtility;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.math.BigDecimal;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+    private static final int DEFAULT_STREAM_BUFFER_SIZE = 1024;\n+    private static final int DEFAULT_CLOB_SUBSTRING_READ_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd ResultSetMetaData\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd, Calendar calendar) throws SQLException {\n+\n+        Preconditions.checkNotNull(rsmd, \"JDBC ResultSetMetaData object can't be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can't be null\");\n+\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, calendar.getTimeZone().getID())), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // TODO Need to handle this type\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op, shouldn't get here\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws SQLException\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root, Calendar calendar) throws SQLException, IOException {\n+\n+        Preconditions.checkNotNull(rs, \"JDBC ResultSet object can't be null\");\n+        Preconditions.checkNotNull(root, \"JDBC ResultSet object can't be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can't be null\");\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        updateVector((BitVector)root.getVector(columnName),\n+                                rs.getBoolean(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.TINYINT:\n+                        updateVector((TinyIntVector)root.getVector(columnName),\n+                                rs.getInt(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.SMALLINT:\n+                        updateVector((SmallIntVector)root.getVector(columnName),\n+                                rs.getInt(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.INTEGER:\n+                        updateVector((IntVector)root.getVector(columnName),\n+                                rs.getInt(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.BIGINT:\n+                        updateVector((BigIntVector)root.getVector(columnName),\n+                                rs.getLong(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        updateVector((DecimalVector)root.getVector(columnName),\n+                                rs.getBigDecimal(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        updateVector((Float4Vector)root.getVector(columnName),\n+                                rs.getFloat(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.DOUBLE:\n+                        updateVector((Float8Vector)root.getVector(columnName),\n+                                rs.getDouble(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                                rs.getString(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.DATE:\n+                        updateVector((DateMilliVector) root.getVector(columnName),\n+                                rs.getDate(i, calendar), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.TIME:\n+                        updateVector((TimeMilliVector) root.getVector(columnName),\n+                                rs.getTime(i, calendar), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        // TODO: Need to handle precision such as milli, micro, nano\n+                        updateVector((TimeStampVector)root.getVector(columnName),\n+                                rs.getTimestamp(i, calendar), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+//                                rs.getBytes(i), !rs.wasNull(), rowCount);\n \n Review comment:\n   to be removed?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.196+0000",
                    "updated": "2018-05-30T02:56:37.196+0000",
                    "started": "2018-05-30T02:56:37.196+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106978",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106979",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r188366121\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/AbstractJdbcToArrowTest.java\n ##########\n @@ -0,0 +1,66 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.Statement;\n+\n+/**\n+ * Class to abstract out some common test functionality for testing JDBC to Arrow.\n+ */\n+public abstract class AbstractJdbcToArrowTest {\n+\n+    protected void createTestData(Connection conn, Table table) throws Exception {\n+\n+        Statement stmt = null;\n+        try {\n+            //create the table and insert the data and once done drop the table\n+            stmt = conn.createStatement();\n+            stmt.executeUpdate(table.getCreate());\n+\n+            for (String insert: table.getData()) {\n+                stmt.executeUpdate(insert);\n+            }\n+\n+        } catch (Exception e) {\n+            e.printStackTrace();\n \n Review comment:\n   It should probably left as-is if you want the test framework to fail properly?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.217+0000",
                    "updated": "2018-05-30T02:56:37.217+0000",
                    "started": "2018-05-30T02:56:37.217+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106979",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106980",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r191630175\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/resources/h2/test1_all_datatypes_h2.yml\n ##########\n @@ -0,0 +1,120 @@\n+#Licensed to the Apache Software Foundation (ASF) under one or more contributor\n+#license agreements. See the NOTICE file distributed with this work for additional\n+#information regarding copyright ownership. The ASF licenses this file to\n+#You under the Apache License, Version 2.0 (the \"License\"); you may not use\n+#this file except in compliance with the License. You may obtain a copy of\n+#the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required\n+#by applicable law or agreed to in writing, software distributed under the\n+#License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n+#OF ANY KIND, either express or implied. See the License for the specific\n+#language governing permissions and limitations under the License.\n+\n+name: 'table1'\n+\n+create: 'CREATE TABLE table1 (int_field1 INT, bool_field2 BOOLEAN, tinyint_field3 TINYINT, smallint_field4 SMALLINT, bigint_field5 BIGINT,\n+    decimal_field6 DECIMAL(20,2), double_field7 DOUBLE, real_field8 REAL, time_field9 TIME, date_field10 DATE, timestamp_field11 TIMESTAMP,\n+    binary_field12 BINARY(100), varchar_field13 VARCHAR(256), blob_field14 BLOB, clob_field15 CLOB, char_field16 CHAR(16), bit_field17 BIT);'\n+\n+data:\n+  - 'INSERT INTO table1 VALUES (101, 1, 45, 12000, 92233720, 17345667789.23, 56478356785.345, 56478356785.345, PARSEDATETIME(''12:45:35 GMT'', ''HH:mm:ss z''),\n \n Review comment:\n   I noticed that all the rows are basically the same for all the tests? is there any specific reason for it? (compared to only have one row for example...)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.269+0000",
                    "updated": "2018-05-30T02:56:37.269+0000",
                    "started": "2018-05-30T02:56:37.269+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106980",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106981",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r188366441\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/JdbcToArrowTestHelper.java\n ##########\n @@ -0,0 +1,178 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertNotNull;\n+/**\n+ * This is a Helper class which has functionalities to read and assert the values from the given FieldVector object\n+ *\n+ */\n+public class JdbcToArrowTestHelper {\n+\n+    public static void assertIntVectorValues(IntVector intVector, int rowCount, Integer[] values) {\n+        assertEquals(rowCount, intVector.getValueCount());\n+\n+        for(int j = 0; j < intVector.getValueCount(); j++) {\n+        \tassertEquals(values[j].intValue(), intVector.get(j));\n \n Review comment:\n   (style) indentation mismatch...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.294+0000",
                    "updated": "2018-05-30T02:56:37.294+0000",
                    "started": "2018-05-30T02:56:37.293+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106981",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106982",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r191624737\n \n \n\n ##########\n File path: java/adapter/jdbc/pom.xml\n ##########\n @@ -0,0 +1,138 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor\n+  license agreements. See the NOTICE file distributed with this work for additional\n+  information regarding copyright ownership. The ASF licenses this file to\n+  You under the Apache License, Version 2.0 (the \"License\"); you may not use\n+  this file except in compliance with the License. You may obtain a copy of\n+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required\n+  by applicable law or agreed to in writing, software distributed under the\n+  License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n+  OF ANY KIND, either express or implied. See the License for the specific\n+  language governing permissions and limitations under the License. -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>org.apache.arrow</groupId>\n+        <artifactId>arrow-java-root</artifactId>\n+        <version>0.10.0-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>arrow-jdbc</artifactId>\n+    <name>Arrow JDBC Adapter</name>\n+    <url>http://maven.apache.org</url>\n+    <dependencies>\n+\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-memory -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-memory</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-vector -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-vector</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.google.guava</groupId>\n+            <artifactId>guava</artifactId>\n+            <version>${dep.guava.version}</version>\n+        </dependency>\n+\n+        <!-- Test -->\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>${dep.junit.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <!-- https://mvnrepository.com/artifact/com.h2database/h2 -->\n+        <dependency>\n+            <groupId>com.h2database</groupId>\n+            <artifactId>h2</artifactId>\n+            <version>1.4.196</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.dataformat</groupId>\n+            <artifactId>jackson-dataformat-yaml</artifactId>\n+            <version>${dep.jackson.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.core</groupId>\n+            <artifactId>jackson-databind</artifactId>\n+            <version>${dep.jackson.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.core</groupId>\n+            <artifactId>jackson-core</artifactId>\n+            <version>${dep.jackson.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.core</groupId>\n+            <artifactId>jackson-annotations</artifactId>\n+            <version>${dep.jackson.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+    </dependencies>\n+\n+\t<build>\t\n+\t\t<plugins>\n+\t\t    <plugin>\n+\t\t\t    <groupId>org.jacoco</groupId>\n \n Review comment:\n   code coverage is great but maybe it should be in a separate jira/review:\r\n   - let's make sure everybody is onboard with the tool used for code review\r\n   - it might be better to configure for all modules instead of just one\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.294+0000",
                    "updated": "2018-05-30T02:56:37.294+0000",
                    "started": "2018-05-30T02:56:37.294+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106982",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106983",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r191624779\n \n \n\n ##########\n File path: java/adapter/jdbc/pom.xml\n ##########\n @@ -0,0 +1,138 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor\n+  license agreements. See the NOTICE file distributed with this work for additional\n+  information regarding copyright ownership. The ASF licenses this file to\n+  You under the Apache License, Version 2.0 (the \"License\"); you may not use\n+  this file except in compliance with the License. You may obtain a copy of\n+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required\n+  by applicable law or agreed to in writing, software distributed under the\n+  License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n+  OF ANY KIND, either express or implied. See the License for the specific\n+  language governing permissions and limitations under the License. -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>org.apache.arrow</groupId>\n+        <artifactId>arrow-java-root</artifactId>\n+        <version>0.10.0-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>arrow-jdbc</artifactId>\n+    <name>Arrow JDBC Adapter</name>\n+    <url>http://maven.apache.org</url>\n+    <dependencies>\n+\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-memory -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-memory</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-vector -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-vector</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.google.guava</groupId>\n+            <artifactId>guava</artifactId>\n+            <version>${dep.guava.version}</version>\n+        </dependency>\n+\n+        <!-- Test -->\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>${dep.junit.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+        <!-- https://mvnrepository.com/artifact/com.h2database/h2 -->\n+        <dependency>\n+            <groupId>com.h2database</groupId>\n+            <artifactId>h2</artifactId>\n+            <version>1.4.196</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.dataformat</groupId>\n+            <artifactId>jackson-dataformat-yaml</artifactId>\n+            <version>${dep.jackson.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.core</groupId>\n+            <artifactId>jackson-databind</artifactId>\n+            <version>${dep.jackson.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.core</groupId>\n+            <artifactId>jackson-core</artifactId>\n+            <version>${dep.jackson.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.core</groupId>\n+            <artifactId>jackson-annotations</artifactId>\n+            <version>${dep.jackson.version}</version>\n+            <scope>test</scope>\n+        </dependency>\n+\n+    </dependencies>\n+\n+\t<build>\t\n \n Review comment:\n   can you check/fix the indentation?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.300+0000",
                    "updated": "2018-05-30T02:56:37.300+0000",
                    "started": "2018-05-30T02:56:37.299+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106983",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106984",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r191627678\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.holders.NullableBigIntHolder;\n+import org.apache.arrow.vector.holders.NullableBitHolder;\n+import org.apache.arrow.vector.holders.NullableDateMilliHolder;\n+import org.apache.arrow.vector.holders.NullableDecimalHolder;\n+import org.apache.arrow.vector.holders.NullableFloat4Holder;\n+import org.apache.arrow.vector.holders.NullableFloat8Holder;\n+import org.apache.arrow.vector.holders.NullableIntHolder;\n+import org.apache.arrow.vector.holders.NullableSmallIntHolder;\n+import org.apache.arrow.vector.holders.NullableTimeMilliHolder;\n+import org.apache.arrow.vector.holders.NullableTinyIntHolder;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.arrow.vector.holders.VarBinaryHolder;\n+import org.apache.arrow.vector.holders.VarCharHolder;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.apache.arrow.vector.util.DecimalUtility;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.math.BigDecimal;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+    private static final int DEFAULT_STREAM_BUFFER_SIZE = 1024;\n+    private static final int DEFAULT_CLOB_SUBSTRING_READ_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd ResultSetMetaData\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd, Calendar calendar) throws SQLException {\n+\n+        Preconditions.checkNotNull(rsmd, \"JDBC ResultSetMetaData object can't be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can't be null\");\n+\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, calendar.getTimeZone().getID())), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // TODO Need to handle this type\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op, shouldn't get here\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws SQLException\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root, Calendar calendar) throws SQLException, IOException {\n+\n+        Preconditions.checkNotNull(rs, \"JDBC ResultSet object can't be null\");\n+        Preconditions.checkNotNull(root, \"JDBC ResultSet object can't be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can't be null\");\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        updateVector((BitVector)root.getVector(columnName),\n+                                rs.getBoolean(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.TINYINT:\n+                        updateVector((TinyIntVector)root.getVector(columnName),\n+                                rs.getInt(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.SMALLINT:\n+                        updateVector((SmallIntVector)root.getVector(columnName),\n+                                rs.getInt(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.INTEGER:\n+                        updateVector((IntVector)root.getVector(columnName),\n+                                rs.getInt(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.BIGINT:\n+                        updateVector((BigIntVector)root.getVector(columnName),\n+                                rs.getLong(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        updateVector((DecimalVector)root.getVector(columnName),\n+                                rs.getBigDecimal(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        updateVector((Float4Vector)root.getVector(columnName),\n+                                rs.getFloat(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.DOUBLE:\n+                        updateVector((Float8Vector)root.getVector(columnName),\n+                                rs.getDouble(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                                rs.getString(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.DATE:\n+                        updateVector((DateMilliVector) root.getVector(columnName),\n+                                rs.getDate(i, calendar), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.TIME:\n+                        updateVector((TimeMilliVector) root.getVector(columnName),\n+                                rs.getTime(i, calendar), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        // TODO: Need to handle precision such as milli, micro, nano\n+                        updateVector((TimeStampVector)root.getVector(columnName),\n+                                rs.getTimestamp(i, calendar), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+//                                rs.getBytes(i), !rs.wasNull(), rowCount);\n+                                rs.getBinaryStream(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.ARRAY:\n+                        // TODO Need to handle this type\n+                    \t// fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                        break;\n+                    case Types.CLOB:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                            rs.getClob(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.BLOB:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                            rs.getBlob(i), !rs.wasNull(), rowCount);\n+                        break;\n+\n+                    default:\n+                        // no-op, shouldn't get here\n+                        break;\n+                }\n+            }\n+            rowCount++;\n+        }\n+        root.setRowCount(rowCount);\n+    }\n+\n+    private static void updateVector(BitVector bitVector, boolean value, boolean isNonNull, int rowCount) {\n+        NullableBitHolder holder = new NullableBitHolder();\n \n Review comment:\n   is it better to use the holder vs calling directly `bitVector.setSafe(rowCount, isNonNull ? 1 : 0, value ? 1: 0)` (cc @siddharthteotia )\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.303+0000",
                    "updated": "2018-05-30T02:56:37.303+0000",
                    "started": "2018-05-30T02:56:37.302+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106984",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106985",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r188366710\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/Table.java\n ##########\n @@ -0,0 +1,233 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+\n+/**\n+ * POJO to handle the YAML data from the test YAML file.\n+ */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class Table {\n+\n+    private String name;\n+    private String type;\n+    private String vector;\n+    private String timezone;\n+    private String create;\n+    private String[] data;\n+    private String query;\n+    private String drop;\n+    private String[] values;\n+    private String[] vectors;\n+    private int rowCount;\n+\n+    public Table() {\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public void setType(String type) {\n+        this.type = type;\n+    }\n+\n+    public String getVector() {\n+        return vector;\n+    }\n+\n+    public void setVector(String vector) {\n+        this.vector = vector;\n+    }\n+\n+    public String[] getValues() {\n+        return values;\n+    }\n+\n+    public void setValues(String[] values) {\n+        this.values = values;\n+    }\n+\n+    public Long[] getLongValues() {\n+        Long[] arr = new Long[values.length];\n+        int i = 0;\n+        for (String str: values) {\n+            arr[i++] = Long.parseLong(str);\n+        }\n+        return arr;\n+    }\n+\n+    public Integer[] getIntValues() {\n+        Integer[] arr = new Integer[values.length];\n+        int i = 0;\n+        for (String str: values) {\n+            arr[i++] = Integer.parseInt(str);\n+        }\n+        return arr;\n+    }\n+    public Boolean[] getBoolValues() {\n+        Boolean[] arr = new Boolean[values.length];\n+        int i = 0;\n+        for (String str: values) {\n+            arr[i++] = Boolean.parseBoolean(str);\n+        }\n+        return arr;\n+    }\n+    public BigDecimal[] getBigDecimalValues() {\n+        BigDecimal[] arr = new BigDecimal[values.length];\n+        int i = 0;\n+        for (String str: values) {\n+            arr[i++] = new BigDecimal(str);\n+        }\n+        return arr;\n+    }\n+    public Double[] getDoubleValues() {\n+        Double[] arr = new Double[values.length];\n+        int i = 0;\n+        for (String str: values) {\n+            arr[i++] = Double.parseDouble(str);\n+        }\n+        return arr;\n+    }\n+\n+    public Float[] getFloatValues() {\n+        Float[] arr = new Float[values.length];\n+        int i = 0;\n+        for (String str: values) {\n+            arr[i++] = Float.parseFloat(str);\n+        }\n+        return arr;\n+    }\n+\n+    public byte[][] getBinaryValues() {\n+        return getHexToByteArray(values);\n+    }\n+\n+    public byte[][] getVarCharValues() {\n+        return getByteArray(values);\n+    }\n+\n+    public byte[][] getBlobValues() {\n+        return getBinaryValues();\n+    }\n+\n+    public byte[][] getClobValues() {\n+        return getByteArray(values);\n+    }\n+\n+    public byte[][] getCharValues() {\n+        return getByteArray(values);\n+    }\n+\n+    public String getCreate() {\n+        return create;\n+    }\n+\n+    public void setCreate(String create) {\n+        this.create = create;\n+    }\n+\n+    public String[] getData() {\n+        return data;\n+    }\n+\n+    public void setData(String[] data) {\n+        this.data = data;\n+    }\n+\n+    public String getQuery() {\n+        return query;\n+    }\n+\n+    public void setQuery(String query) {\n+        this.query = query;\n+    }\n+\n+    public String getDrop() {\n+        return drop;\n+    }\n+\n+    public void setDrop(String drop) {\n+        this.drop = drop;\n+    }\n+\n+    public String getTimezone() {\n+\t\treturn timezone;\n+\t}\n \n Review comment:\n   (style) indentation is also inconsistent...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.304+0000",
                    "updated": "2018-05-30T02:56:37.304+0000",
                    "started": "2018-05-30T02:56:37.304+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106985",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106986",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r188366310\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/AbstractJdbcToArrowTest.java\n ##########\n @@ -0,0 +1,66 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.Statement;\n+\n+/**\n+ * Class to abstract out some common test functionality for testing JDBC to Arrow.\n+ */\n+public abstract class AbstractJdbcToArrowTest {\n+\n+    protected void createTestData(Connection conn, Table table) throws Exception {\n+\n+        Statement stmt = null;\n+        try {\n+            //create the table and insert the data and once done drop the table\n+            stmt = conn.createStatement();\n+            stmt.executeUpdate(table.getCreate());\n+\n+            for (String insert: table.getData()) {\n+                stmt.executeUpdate(insert);\n+            }\n+\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        } finally {\n \n Review comment:\n   what about using `try(with-resources)` pattern?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.311+0000",
                    "updated": "2018-05-30T02:56:37.311+0000",
                    "started": "2018-05-30T02:56:37.310+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106986",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106987",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r191629641\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/JdbcToArrowTestHelper.java\n ##########\n @@ -0,0 +1,280 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.math.BigDecimal;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertNotNull;\n+/**\n+ * This is a Helper class which has functionalities to read and assert the values from the given FieldVector object\n+ *\n+ */\n+public class JdbcToArrowTestHelper {\n+\n+    public static void assertIntVectorValues(IntVector intVector, int rowCount, Integer[] values) {\n+        assertEquals(rowCount, intVector.getValueCount());\n+\n+        for(int j = 0; j < intVector.getValueCount(); j++) {\n+        \tassertEquals(values[j].intValue(), intVector.get(j));\n+        } \n+    }\n+\n+    public static void assertBooleanVectorValues(BitVector bitVector, int rowCount, Boolean[] values){\n+        assertEquals(rowCount, bitVector.getValueCount());\n+        \n+        for(int j = 0; j < bitVector.getValueCount(); j++){\n+            assertEquals(values[j].booleanValue(), bitVector.get(j) == 1);\n+        }\n+    }\n+\n+    public static void assertBitVectorValues(BitVector bitVector, int rowCount, Integer[] values){\n+        assertEquals(rowCount, bitVector.getValueCount());\n+\n+        for(int j = 0; j < bitVector.getValueCount(); j++){\n+            assertEquals(values[j].intValue(), bitVector.get(j));\n+        }\n+    }\n+\n+    public static void assertTinyIntVectorValues(TinyIntVector tinyIntVector, int rowCount, Integer[] values){\n+        assertEquals(rowCount, tinyIntVector.getValueCount());\n+\n+        for(int j = 0; j < tinyIntVector.getValueCount(); j++){\n+            assertEquals(values[j].intValue(), tinyIntVector.get(j));\n+        }\n+    }\n+\n+    public static void assertSmallIntVectorValues(SmallIntVector smallIntVector, int rowCount, Integer[] values){\n+        assertEquals(rowCount, smallIntVector.getValueCount());\n+\n+        for(int j = 0; j < smallIntVector.getValueCount(); j++){\n+            assertEquals(values[j].intValue(), smallIntVector.get(j));\n+        }\n+    }\n+\n+    public static void assertBigIntVectorValues(BigIntVector bigIntVector, int rowCount, Long[] values){\n+        assertEquals(rowCount, bigIntVector.getValueCount());\n+\n+        for(int j = 0; j < bigIntVector.getValueCount(); j++){\n+            assertEquals(values[j].longValue(), bigIntVector.get(j));\n+        }\n+    }\n+\n+    public static void assertDecimalVectorValues(DecimalVector decimalVector, int rowCount, BigDecimal[] values){\n+        assertEquals(rowCount, decimalVector.getValueCount());\n+\n+        for(int j = 0; j < decimalVector.getValueCount(); j++){\n+        \tassertNotNull(decimalVector.getObject(j));\n+            assertEquals(values[j].doubleValue(), decimalVector.getObject(j).doubleValue(), 0);\n+        }\n+    }\n+\n+    public static void assertFloat8VectorValues(Float8Vector float8Vector, int rowCount, Double[] values){\n+        assertEquals(rowCount, float8Vector.getValueCount());\n+\n+        for(int j = 0; j < float8Vector.getValueCount(); j++){\n+            assertEquals(values[j], float8Vector.get(j), 0.01);\n+        }\n+    }\n+\n+    public static void assertFloat4VectorValues(Float4Vector float4Vector, int rowCount, Float[] values){\n+        assertEquals(rowCount, float4Vector.getValueCount());\n+\n+        for(int j = 0; j < float4Vector.getValueCount(); j++){\n+            assertEquals(values[j], float4Vector.get(j), 0.01);\n+        }\n+    }\n+\n+    public static void assertTimeVectorValues(TimeMilliVector timeMilliVector, int rowCount, Long[] values){\n+        assertEquals(rowCount, timeMilliVector.getValueCount());\n+\n+        for(int j = 0; j < timeMilliVector.getValueCount(); j++){\n+                assertEquals(values[j].longValue(), timeMilliVector.get(j));\n+        }\n+    }\n+\n+    public static void assertDateVectorValues(DateMilliVector dateMilliVector, int rowCount, Long[] values){\n+        assertEquals(rowCount, dateMilliVector.getValueCount());\n+\n+        for(int j = 0; j < dateMilliVector.getValueCount(); j++){\n+            assertEquals(values[j].longValue(), dateMilliVector.get(j));\n+        }\n+    }\n+\n+    public static void assertTimeStampVectorValues(TimeStampVector timeStampVector, int rowCount, Long[] values){\n+        assertEquals(rowCount, timeStampVector.getValueCount());\n+\n+        for(int j = 0; j < timeStampVector.getValueCount(); j++){\n+            assertEquals(values[j].longValue(), timeStampVector.get(j));\n+        }\n+    }\n+\n+    public static void assertVarBinaryVectorValues (VarBinaryVector varBinaryVector, int rowCount, byte[][] values) {\n+        assertEquals(rowCount, varBinaryVector.getValueCount());\n+\n+        for(int j = 0; j < varBinaryVector.getValueCount(); j++){\n+            assertEquals(Arrays.hashCode(values[j]), Arrays.hashCode(varBinaryVector.get(j)));\n \n Review comment:\n   why not checking for array equality using `assertArrayEquals`?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.418+0000",
                    "updated": "2018-05-30T02:56:37.418+0000",
                    "started": "2018-05-30T02:56:37.417+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106987",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106988",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r191628186\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.holders.NullableBigIntHolder;\n+import org.apache.arrow.vector.holders.NullableBitHolder;\n+import org.apache.arrow.vector.holders.NullableDateMilliHolder;\n+import org.apache.arrow.vector.holders.NullableDecimalHolder;\n+import org.apache.arrow.vector.holders.NullableFloat4Holder;\n+import org.apache.arrow.vector.holders.NullableFloat8Holder;\n+import org.apache.arrow.vector.holders.NullableIntHolder;\n+import org.apache.arrow.vector.holders.NullableSmallIntHolder;\n+import org.apache.arrow.vector.holders.NullableTimeMilliHolder;\n+import org.apache.arrow.vector.holders.NullableTinyIntHolder;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.arrow.vector.holders.VarBinaryHolder;\n+import org.apache.arrow.vector.holders.VarCharHolder;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.apache.arrow.vector.util.DecimalUtility;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.math.BigDecimal;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+    private static final int DEFAULT_STREAM_BUFFER_SIZE = 1024;\n+    private static final int DEFAULT_CLOB_SUBSTRING_READ_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd ResultSetMetaData\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd, Calendar calendar) throws SQLException {\n+\n+        Preconditions.checkNotNull(rsmd, \"JDBC ResultSetMetaData object can't be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can't be null\");\n+\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, calendar.getTimeZone().getID())), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // TODO Need to handle this type\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op, shouldn't get here\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws SQLException\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root, Calendar calendar) throws SQLException, IOException {\n+\n+        Preconditions.checkNotNull(rs, \"JDBC ResultSet object can't be null\");\n+        Preconditions.checkNotNull(root, \"JDBC ResultSet object can't be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can't be null\");\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        updateVector((BitVector)root.getVector(columnName),\n+                                rs.getBoolean(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.TINYINT:\n+                        updateVector((TinyIntVector)root.getVector(columnName),\n+                                rs.getInt(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.SMALLINT:\n+                        updateVector((SmallIntVector)root.getVector(columnName),\n+                                rs.getInt(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.INTEGER:\n+                        updateVector((IntVector)root.getVector(columnName),\n+                                rs.getInt(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.BIGINT:\n+                        updateVector((BigIntVector)root.getVector(columnName),\n+                                rs.getLong(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        updateVector((DecimalVector)root.getVector(columnName),\n+                                rs.getBigDecimal(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        updateVector((Float4Vector)root.getVector(columnName),\n+                                rs.getFloat(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.DOUBLE:\n+                        updateVector((Float8Vector)root.getVector(columnName),\n+                                rs.getDouble(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                                rs.getString(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.DATE:\n+                        updateVector((DateMilliVector) root.getVector(columnName),\n+                                rs.getDate(i, calendar), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.TIME:\n+                        updateVector((TimeMilliVector) root.getVector(columnName),\n+                                rs.getTime(i, calendar), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        // TODO: Need to handle precision such as milli, micro, nano\n+                        updateVector((TimeStampVector)root.getVector(columnName),\n+                                rs.getTimestamp(i, calendar), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+//                                rs.getBytes(i), !rs.wasNull(), rowCount);\n+                                rs.getBinaryStream(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.ARRAY:\n+                        // TODO Need to handle this type\n+                    \t// fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                        break;\n+                    case Types.CLOB:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                            rs.getClob(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.BLOB:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                            rs.getBlob(i), !rs.wasNull(), rowCount);\n+                        break;\n+\n+                    default:\n+                        // no-op, shouldn't get here\n+                        break;\n+                }\n+            }\n+            rowCount++;\n+        }\n+        root.setRowCount(rowCount);\n+    }\n+\n+    private static void updateVector(BitVector bitVector, boolean value, boolean isNonNull, int rowCount) {\n+        NullableBitHolder holder = new NullableBitHolder();\n+        holder.isSet = isNonNull? 1: 0;\n+        if (isNonNull) {\n+            holder.value = value ? 1 : 0;\n+        }\n+        bitVector.setSafe(rowCount, holder);\n+        bitVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(TinyIntVector tinyIntVector, int value, boolean isNonNull, int rowCount) {\n+        NullableTinyIntHolder holder = new NullableTinyIntHolder();\n+        holder.isSet = isNonNull? 1: 0;\n+        if (isNonNull) {\n+            holder.value = (byte) value;\n+        }\n+        tinyIntVector.setSafe(rowCount, holder);\n+        tinyIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(SmallIntVector smallIntVector, int value, boolean isNonNull, int rowCount) {\n+        NullableSmallIntHolder holder = new NullableSmallIntHolder();\n+        holder.isSet = isNonNull? 1: 0;\n+        if (isNonNull) {\n+            holder.value = (short) value;\n+        }\n+        smallIntVector.setSafe(rowCount, holder);\n+        smallIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(IntVector intVector, int value, boolean isNonNull, int rowCount) {\n+        NullableIntHolder holder = new NullableIntHolder();\n+        holder.isSet = isNonNull? 1: 0;\n+        if (isNonNull) {\n+            holder.value = value;\n+        }\n+        intVector.setSafe(rowCount, holder);\n+        intVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(BigIntVector bigIntVector, long value, boolean isNonNull, int rowCount) {\n+        NullableBigIntHolder holder = new NullableBigIntHolder();\n+        holder.isSet = isNonNull? 1: 0;\n+        if (isNonNull) {\n+            holder.value = value;\n+        }\n+        bigIntVector.setSafe(rowCount, holder);\n+        bigIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(DecimalVector decimalVector, BigDecimal value, boolean isNonNull, int rowCount) {\n+        NullableDecimalHolder holder = new NullableDecimalHolder();\n+        holder.isSet = isNonNull? 1: 0;\n+        if (isNonNull) {\n+            holder.precision = value.precision();\n+            holder.scale = value.scale();\n+            holder.buffer = decimalVector.getAllocator().buffer(DEFAULT_BUFFER_SIZE);\n+            holder.start = 0;\n+            DecimalUtility.writeBigDecimalToArrowBuf(value, holder.buffer, holder.start);\n+        }\n+        decimalVector.setSafe(rowCount, holder);\n+        decimalVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(Float4Vector float4Vector, float value, boolean isNonNull, int rowCount) {\n+        NullableFloat4Holder holder = new NullableFloat4Holder();\n+        holder.isSet = isNonNull? 1: 0;\n+        if (isNonNull) {\n+            holder.value = value;\n+        }\n+        float4Vector.setSafe(rowCount, holder);\n+        float4Vector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(Float8Vector float8Vector, double value, boolean isNonNull, int rowCount) {\n+        NullableFloat8Holder holder = new NullableFloat8Holder();\n+        holder.isSet = isNonNull? 1: 0;\n+        if (isNonNull) {\n+            holder.value = value;\n+        }\n+        float8Vector.setSafe(rowCount, holder);\n+        float8Vector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(VarCharVector varcharVector, String value, boolean isNonNull, int rowCount) {\n+        NullableVarCharHolder holder = new NullableVarCharHolder();\n+        holder.isSet = isNonNull? 1: 0;\n+        varcharVector.setIndexDefined(rowCount);\n+        if (isNonNull) {\n+            byte[] bytes = value.getBytes(StandardCharsets.UTF_8);\n+            holder.buffer = varcharVector.getAllocator().buffer(bytes.length);\n+            holder.buffer.setBytes(0, bytes, 0, bytes.length);\n+            holder.start = 0;\n+            holder.end = bytes.length;\n+        } else {\n+        \tholder.buffer = varcharVector.getAllocator().buffer(0);\n+        }\n+        varcharVector.setSafe(rowCount, holder);\n+        varcharVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(DateMilliVector dateMilliVector, Date date, boolean isNonNull, int rowCount) {\n+        NullableDateMilliHolder holder = new NullableDateMilliHolder();\n+        holder.isSet = isNonNull? 1: 0;\n+        if (isNonNull) {\n+            holder.value = date.getTime();\n+        }\n+        dateMilliVector.setSafe(rowCount, holder);\n+        dateMilliVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(TimeMilliVector timeMilliVector, Time time, boolean isNonNull, int rowCount) {\n+        NullableTimeMilliHolder holder = new NullableTimeMilliHolder();\n+        holder.isSet = isNonNull? 1: 0;\n+        if (isNonNull && time != null) {\n+            holder.value = (int)time.getTime();\n+        }\n+        timeMilliVector.setSafe(rowCount, holder);\n+        timeMilliVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(TimeStampVector timeStampVector, Timestamp timestamp, boolean isNonNull, int rowCount) {\n+        //TODO: Need to handle precision such as milli, micro, nano\n+        timeStampVector.setValueCount(rowCount + 1);\n+        if (timestamp != null) {\n+            timeStampVector.setSafe(rowCount, timestamp.getTime());\n+        } else {\n+            timeStampVector.setNull(rowCount);\n+        }\n+    }\n+\n+    private static void updateVector(VarBinaryVector varBinaryVector, InputStream is, boolean isNonNull, int rowCount) throws IOException {\n+        varBinaryVector.setValueCount(rowCount + 1);\n+        if (isNonNull && is != null) {\n+            VarBinaryHolder holder = new VarBinaryHolder();\n+            ArrowBuf arrowBuf = varBinaryVector.getDataBuffer();\n+            holder.start = 0;\n+            byte[] bytes = new byte[DEFAULT_STREAM_BUFFER_SIZE];\n+            int total = 0;\n+            while (true) {\n+                int read = is.read(bytes, 0, DEFAULT_STREAM_BUFFER_SIZE);\n+                if (read == -1) {\n+                    break;\n+                }\n+                arrowBuf.setBytes(total, new ByteArrayInputStream(bytes, 0, read), read);\n \n Review comment:\n   I think you don't need to wrap to a stream and that there's a method accepting an byte[] argument directly\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.420+0000",
                    "updated": "2018-05-30T02:56:37.420+0000",
                    "started": "2018-05-30T02:56:37.420+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106988",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/106989",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r188367067\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/h2/JdbcToArrowDataTypesTest.java\n ##########\n @@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.arrow.adapter.jdbc.h2;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+\n+import org.apache.arrow.adapter.jdbc.AbstractJdbcToArrowTest;\n+import org.apache.arrow.adapter.jdbc.JdbcToArrow;\n+import org.apache.arrow.adapter.jdbc.Table;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collection;\n+\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertBigIntVectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertBitVectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertBooleanVectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertDateVectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertDecimalVectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertFloat4VectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertFloat8VectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertIntVectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertSmallIntVectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertTimeStampVectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertTimeVectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertTinyIntVectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertVarBinaryVectorValues;\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.assertVarcharVectorValues;\n+\n+/**\n+ * \n+ * JUnit Test class to test various datatypes converted into Arrow vector for H2 database\n+ *\n+ */\n+@RunWith(Parameterized.class)\n+public class JdbcToArrowDataTypesTest {\n+\tprivate Connection conn = null;\n+\tprivate Table table;\n+\t\n+    private static final String BIGINT = \"big_int\";\n+    private static final String BINARY = \"binary\";\n+    private static final String BIT = \"bit\";\n+    private static final String BLOB = \"blob\";\n+    private static final String BOOL = \"bool\";\n+    private static final String CHAR = \"char\";\n+    private static final String CLOB = \"clob\";\n+    private static final String DATE = \"date\";\n+    private static final String DECIMAL = \"decimal\";\n+    private static final String DOUBLE = \"double\";\n+    private static final String INT = \"int\";\n+    private static final String REAL = \"real\";\n+    private static final String SMALLINT = \"small_int\";\n+    private static final String TIME = \"time\";\n+    private static final String TIMESTAMP = \"timestamp\";\n+    private static final String TINYINT = \"tiny_int\";\n+    private static final String VARCHAR = \"varchar\";\n+    \n+    private static final String[] testFiles = {\n+        \"h2/test1_bigint_h2.yml\",\n+        \"h2/test1_binary_h2.yml\",\n+        \"h2/test1_bit_h2.yml\",\n+        \"h2/test1_blob_h2.yml\",\n+        \"h2/test1_bool_h2.yml\",\n+        \"h2/test1_char_h2.yml\",\n+        \"h2/test1_clob_h2.yml\",\n+        \"h2/test1_date_h2.yml\",\n+        \"h2/test1_decimal_h2.yml\",\n+        \"h2/test1_double_h2.yml\",\n+        \"h2/test1_int_h2.yml\",\n+        \"h2/test1_real_h2.yml\",\n+        \"h2/test1_smallint_h2.yml\",\n+        \"h2/test1_time_h2.yml\",\n+        \"h2/test1_timestamp_h2.yml\",\n+        \"h2/test1_tinyint_h2.yml\",\n+        \"h2/test1_varchar_h2.yml\"\n+    };\n+    \n+    /**\n+     * Constructor which populate table object for each test iteration\n+     * @param table\n+     */\n+    public JdbcToArrowDataTypesTest(Table table) {\n+        this.table = table;\n+    }\n+     \n+    /**\n+     * This method creates Table object after reading YAML file\n+     * @param ymlFilePath\n+     * @return\n+     * @throws IOException\n+     */\n+    private static Table getTable(String ymlFilePath) throws IOException {\n+        return new ObjectMapper(new YAMLFactory()).readValue(\n \n Review comment:\n   the ObjectMapper can be reused (it's a bit costly to construct each time although probably fine in a test context)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-05-30T02:56:37.683+0000",
                    "updated": "2018-05-30T02:56:37.683+0000",
                    "started": "2018-05-30T02:56:37.682+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "106989",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/107985",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r192300853\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,519 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.holders.NullableBigIntHolder;\n+import org.apache.arrow.vector.holders.NullableBitHolder;\n+import org.apache.arrow.vector.holders.NullableDateMilliHolder;\n+import org.apache.arrow.vector.holders.NullableDecimalHolder;\n+import org.apache.arrow.vector.holders.NullableFloat4Holder;\n+import org.apache.arrow.vector.holders.NullableFloat8Holder;\n+import org.apache.arrow.vector.holders.NullableIntHolder;\n+import org.apache.arrow.vector.holders.NullableSmallIntHolder;\n+import org.apache.arrow.vector.holders.NullableTimeMilliHolder;\n+import org.apache.arrow.vector.holders.NullableTinyIntHolder;\n+import org.apache.arrow.vector.holders.NullableVarCharHolder;\n+import org.apache.arrow.vector.holders.VarBinaryHolder;\n+import org.apache.arrow.vector.holders.VarCharHolder;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+import org.apache.arrow.vector.util.DecimalUtility;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.math.BigDecimal;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+    private static final int DEFAULT_STREAM_BUFFER_SIZE = 1024;\n+    private static final int DEFAULT_CLOB_SUBSTRING_READ_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd ResultSetMetaData\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd, Calendar calendar) throws SQLException {\n+\n+        Preconditions.checkNotNull(rsmd, \"JDBC ResultSetMetaData object can't be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can't be null\");\n+\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, calendar.getTimeZone().getID())), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // TODO Need to handle this type\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op, shouldn't get here\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws SQLException\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root, Calendar calendar) throws SQLException, IOException {\n+\n+        Preconditions.checkNotNull(rs, \"JDBC ResultSet object can't be null\");\n+        Preconditions.checkNotNull(root, \"JDBC ResultSet object can't be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can't be null\");\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        updateVector((BitVector)root.getVector(columnName),\n+                                rs.getBoolean(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.TINYINT:\n+                        updateVector((TinyIntVector)root.getVector(columnName),\n+                                rs.getInt(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.SMALLINT:\n+                        updateVector((SmallIntVector)root.getVector(columnName),\n+                                rs.getInt(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.INTEGER:\n+                        updateVector((IntVector)root.getVector(columnName),\n+                                rs.getInt(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.BIGINT:\n+                        updateVector((BigIntVector)root.getVector(columnName),\n+                                rs.getLong(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        updateVector((DecimalVector)root.getVector(columnName),\n+                                rs.getBigDecimal(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        updateVector((Float4Vector)root.getVector(columnName),\n+                                rs.getFloat(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.DOUBLE:\n+                        updateVector((Float8Vector)root.getVector(columnName),\n+                                rs.getDouble(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                                rs.getString(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.DATE:\n+                        updateVector((DateMilliVector) root.getVector(columnName),\n+                                rs.getDate(i, calendar), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.TIME:\n+                        updateVector((TimeMilliVector) root.getVector(columnName),\n+                                rs.getTime(i, calendar), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        // TODO: Need to handle precision such as milli, micro, nano\n+                        updateVector((TimeStampVector)root.getVector(columnName),\n+                                rs.getTimestamp(i, calendar), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+//                                rs.getBytes(i), !rs.wasNull(), rowCount);\n+                                rs.getBinaryStream(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.ARRAY:\n+                        // TODO Need to handle this type\n+                    \t// fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                        break;\n+                    case Types.CLOB:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                            rs.getClob(i), !rs.wasNull(), rowCount);\n+                        break;\n+                    case Types.BLOB:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                            rs.getBlob(i), !rs.wasNull(), rowCount);\n+                        break;\n+\n+                    default:\n+                        // no-op, shouldn't get here\n+                        break;\n+                }\n+            }\n+            rowCount++;\n+        }\n+        root.setRowCount(rowCount);\n+    }\n+\n+    private static void updateVector(BitVector bitVector, boolean value, boolean isNonNull, int rowCount) {\n+        NullableBitHolder holder = new NullableBitHolder();\n \n Review comment:\n   I think we can continue to use holder so as to be consistent with other parts of the code. What do you think?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-06-01T05:26:25.934+0000",
                    "updated": "2018-06-01T05:26:25.934+0000",
                    "started": "2018-06-01T05:26:25.933+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "107985",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/107986",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r192300931\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/resources/h2/test1_all_datatypes_h2.yml\n ##########\n @@ -0,0 +1,120 @@\n+#Licensed to the Apache Software Foundation (ASF) under one or more contributor\n+#license agreements. See the NOTICE file distributed with this work for additional\n+#information regarding copyright ownership. The ASF licenses this file to\n+#You under the Apache License, Version 2.0 (the \"License\"); you may not use\n+#this file except in compliance with the License. You may obtain a copy of\n+#the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required\n+#by applicable law or agreed to in writing, software distributed under the\n+#License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n+#OF ANY KIND, either express or implied. See the License for the specific\n+#language governing permissions and limitations under the License.\n+\n+name: 'table1'\n+\n+create: 'CREATE TABLE table1 (int_field1 INT, bool_field2 BOOLEAN, tinyint_field3 TINYINT, smallint_field4 SMALLINT, bigint_field5 BIGINT,\n+    decimal_field6 DECIMAL(20,2), double_field7 DOUBLE, real_field8 REAL, time_field9 TIME, date_field10 DATE, timestamp_field11 TIMESTAMP,\n+    binary_field12 BINARY(100), varchar_field13 VARCHAR(256), blob_field14 BLOB, clob_field15 CLOB, char_field16 CHAR(16), bit_field17 BIT);'\n+\n+data:\n+  - 'INSERT INTO table1 VALUES (101, 1, 45, 12000, 92233720, 17345667789.23, 56478356785.345, 56478356785.345, PARSEDATETIME(''12:45:35 GMT'', ''HH:mm:ss z''),\n \n Review comment:\n   There is no particular reason for that. It's just give you more number of rows.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-06-01T05:27:23.070+0000",
                    "updated": "2018-06-01T05:27:23.070+0000",
                    "started": "2018-06-01T05:27:23.070+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "107986",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/107987",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r192300931\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/resources/h2/test1_all_datatypes_h2.yml\n ##########\n @@ -0,0 +1,120 @@\n+#Licensed to the Apache Software Foundation (ASF) under one or more contributor\n+#license agreements. See the NOTICE file distributed with this work for additional\n+#information regarding copyright ownership. The ASF licenses this file to\n+#You under the Apache License, Version 2.0 (the \"License\"); you may not use\n+#this file except in compliance with the License. You may obtain a copy of\n+#the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required\n+#by applicable law or agreed to in writing, software distributed under the\n+#License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n+#OF ANY KIND, either express or implied. See the License for the specific\n+#language governing permissions and limitations under the License.\n+\n+name: 'table1'\n+\n+create: 'CREATE TABLE table1 (int_field1 INT, bool_field2 BOOLEAN, tinyint_field3 TINYINT, smallint_field4 SMALLINT, bigint_field5 BIGINT,\n+    decimal_field6 DECIMAL(20,2), double_field7 DOUBLE, real_field8 REAL, time_field9 TIME, date_field10 DATE, timestamp_field11 TIMESTAMP,\n+    binary_field12 BINARY(100), varchar_field13 VARCHAR(256), blob_field14 BLOB, clob_field15 CLOB, char_field16 CHAR(16), bit_field17 BIT);'\n+\n+data:\n+  - 'INSERT INTO table1 VALUES (101, 1, 45, 12000, 92233720, 17345667789.23, 56478356785.345, 56478356785.345, PARSEDATETIME(''12:45:35 GMT'', ''HH:mm:ss z''),\n \n Review comment:\n   There is no particular reason for that. It just gives you more number of rows.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-06-01T05:27:37.491+0000",
                    "updated": "2018-06-01T05:27:37.491+0000",
                    "started": "2018-06-01T05:27:37.491+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "107987",
                    "issueId": "13117051"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/worklog/107991",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r192303005\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,179 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.BaseAllocator;\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import com.google.common.base.Preconditions;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.sql.ResultSet;\n+import java.util.Calendar;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * TODO: At this time, SQL Data type java.sql.Types.ARRAY is still not supported.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     * This method uses the default Calendar instance with default TimeZone and Locale as returned by the JVM.\n+     * If you wish to use specific TimeZone or Locale for any Date, Time and Timestamp datasets, you may want use\n+     * overloaded API that taken Calendar object instance.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @param allocator Memory allocator\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statement objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query, BaseAllocator allocator) throws SQLException, IOException {\n+        Preconditions.checkNotNull(connection, \"JDBC connection object can not be null\");\n+        Preconditions.checkArgument(query != null && query.length() > 0, \"SQL query can not be null or empty\");\n+        Preconditions.checkNotNull(allocator, \"Memory allocator object can not be null\");\n+\n+        return sqlToArrow(connection, query, allocator, Calendar.getInstance());\n+    }\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @param allocator Memory allocator\n+     * @param calendar Calendar object to use to handle Date, Time and Timestamp datasets.\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statement objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query, BaseAllocator allocator, Calendar calendar) throws SQLException, IOException {\n+        Preconditions.checkNotNull(connection, \"JDBC connection object can not be null\");\n+        Preconditions.checkArgument(query != null && query.length() > 0, \"SQL query can not be null or empty\");\n+        Preconditions.checkNotNull(allocator, \"Memory allocator object can not be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can not be null\");\n+\n+        try (Statement stmt = connection.createStatement()) {\n+            return sqlToArrow(stmt.executeQuery(query), allocator, calendar);\n+        }\n+    }\n+\n+    /**\n+     * For the given JDBC {@link ResultSet}, fetch the data from Relational DB and convert it to Arrow objects. This method\n+     * uses the default RootAllocator and Calendar object.\n+     *\n+     * @param resultSet\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException\n+     */\n+    public static VectorSchemaRoot sqlToArrow(ResultSet resultSet) throws SQLException, IOException {\n+        Preconditions.checkNotNull(resultSet, \"JDBC ResultSet object can not be null\");\n+\n+        return sqlToArrow(resultSet, Calendar.getInstance());\n+    }\n+\n+    /**\n+     * For the given JDBC {@link ResultSet}, fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param resultSet\n+     * @param allocator Memory allocator\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException\n+     */\n+    public static VectorSchemaRoot sqlToArrow(ResultSet resultSet, BaseAllocator allocator) throws SQLException, IOException {\n+        Preconditions.checkNotNull(resultSet, \"JDBC ResultSet object can not be null\");\n+        Preconditions.checkNotNull(allocator, \"Memory Allocator object can not be null\");\n+\n+        return sqlToArrow(resultSet, allocator, Calendar.getInstance());\n+    }\n+\n+    /**\n+     * For the given JDBC {@link ResultSet}, fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param resultSet\n+     * @param calendar Calendar instance to use for Date, Time and Timestamp datasets.\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException\n+     */\n+    public static VectorSchemaRoot sqlToArrow(ResultSet resultSet, Calendar calendar) throws SQLException, IOException {\n+        Preconditions.checkNotNull(resultSet, \"JDBC ResultSet object can not be null\");\n+        Preconditions.checkNotNull(calendar, \"Calendar object can not be null\");\n+\n+        RootAllocator rootAllocator = new RootAllocator(Integer.MAX_VALUE);\n+        VectorSchemaRoot root = sqlToArrow(resultSet, rootAllocator, calendar);\n+        rootAllocator.close();\n \n Review comment:\n   This (rootAllocator.close()) was already removed and probably is referring to earlier code. So, we should be okay now.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-06-01T05:48:09.490+0000",
                    "updated": "2018-06-01T05:48:09.490+0000",
                    "started": "2018-06-01T05:48:09.489+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "107991",
                    "issueId": "13117051"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 16200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@152a5840[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4f5b2192[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7e1c5602[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@685dbfe2[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@713d9fa2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@57a13aa8[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4b91da18[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@4eb6ce27[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@53eb88dc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@dc19c73[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@48c5d6c9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@30fafe00[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 16200,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Jun 21 03:58:40 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-06-21T03:58:40.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-1780/watchers",
            "watchCount": 5,
            "isWatching": false
        },
        "created": "2017-11-08T17:50:19.000+0000",
        "updated": "2018-07-27T15:32:17.000+0000",
        "timeoriginalestimate": null,
        "description": "At a high level the JDBC Adapter will allow upstream apps to query RDBMS data over JDBC and get the JDBC objects converted to Arrow objects/structures. The upstream utility can then work with Arrow objects/structures with usual performance benefits. The utility will be very much similar to C++ implementation of \"Convert a vector of row-wise data into an Arrow table\" as described here - https://arrow.apache.org/docs/cpp/md_tutorials_row_wise_conversion.html\r\n\r\nThe utility will read data from RDBMS and covert the data into Arrow objects/structures. So from that perspective this will Read data from RDBMS, If the utility can push Arrow objects to RDBMS is something need to be discussed and will be out of scope for this utility for now. ",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 16200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Java] JDBC Adapter for Apache Arrow",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16369457",
                    "id": "16369457",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
                        "name": "atul_dambalkar",
                        "key": "atul_dambalkar",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Atul Dambalkar",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Comments from Uwe Korn on Slack channel -\u00a0\r\n\r\nMy main plan was to make JDBC drivers accessible very fast from Python / Pandas programs. Currently, you either have the option for most DBs to either use ODBC/python-native drivers that are quite often awful or use JDBC ones but have a high cost of serialization between the JVM and the Python objects. By using Arrow, we should be able to use the good JDBC drivers from Python without the normal serialization overhead.\r\n\r\nWe\u2019re looking at SQL-engines that work on distributed filesystem in general at the moment (Apache Drill and Presto are two best candidates at the moment) and the common pattern is that they have good JDBC drivers but the other connectors are not so well maintained or really slow.\u00a0Currently, Presto is the one of biggest interest for me.\r\n\r\nFor me it seems that having a JDBC<->Arrow adapter already yields a significant performance impact in comparison to the current situation. And it will also give the speedup independent of the underlying DB.\r\n\r\n\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
                        "name": "atul_dambalkar",
                        "key": "atul_dambalkar",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Atul Dambalkar",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2018-02-19T19:49:21.036+0000",
                    "updated": "2018-02-19T19:51:12.049+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16369458",
                    "id": "16369458",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
                        "name": "atul_dambalkar",
                        "key": "atul_dambalkar",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Atul Dambalkar",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "I have put together some very basic interface for the JDBC Adapter - so far by forking Arrow (https://github.com/atuldambalkar/arrow/tree/master/java/adapter/jdbc). I had a brief discussion with Uwe earlier on this on Slack, so wanted to get some more views on this and also not to redo or overstep. At this time, I have one API in the adapter which can return Arrow Vector objects after executing SQL query on the given JDBC connection object - VectorSchemaRoot sqlToArrow(Connection connection, String query).\r\n\r\nOne more possible interface could be to fetch a certain number of records from all the tables from the SQL database and build Arrow objects for that. The API can of-course be implemented lazily and only when the data for a particular table is requested.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
                        "name": "atul_dambalkar",
                        "key": "atul_dambalkar",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Atul Dambalkar",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2018-02-19T19:50:46.824+0000",
                    "updated": "2018-02-19T19:50:46.824+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16369459",
                    "id": "16369459",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
                        "name": "atul_dambalkar",
                        "key": "atul_dambalkar",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Atul Dambalkar",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Comment from Jacques Nadeau on Slack channel -\r\n\r\nNice start @atul_dambalkar.\u00a0It would be good to add the ability to set the amount to return per call as opposed to trying to deplete the whole dataset in one call.\r\n\r\n\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
                        "name": "atul_dambalkar",
                        "key": "atul_dambalkar",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Atul Dambalkar",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2018-02-19T19:51:55.436+0000",
                    "updated": "2018-02-19T19:51:55.436+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16369612",
                    "id": "16369612",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
                        "name": "atul_dambalkar",
                        "key": "atul_dambalkar",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Atul Dambalkar",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Based on above comments, I will update the API with necessary parameters. It will be more or less like pagination.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
                        "name": "atul_dambalkar",
                        "key": "atul_dambalkar",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Atul Dambalkar",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2018-02-20T00:26:30.306+0000",
                    "updated": "2018-02-20T00:26:30.306+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16401077",
                    "id": "16401077",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar opened a new pull request #1759: ARROW-1780 - (WIP) JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759\n \n \n   This code enhancement is for converting JDBC ResultSet Relational objects to Arrow columnar data Vector objects. Code is under director \"java/adapter/jdbc/src/main\".\r\n   \r\n   The API has following static methods in the \r\n   \r\n   class org.apache.arrow.adapter.jdbc.JdbcToArrow -\r\n   \r\n   public static VectorSchemaRoot sqlToArrow(Connection connection, String query)\r\n   public static ArrowDataFetcher jdbcArrowDataFetcher(Connection connection, String tableName) \r\n   \r\n   Utility uses following data mapping to convert JDBC/SQL data types to Arrow data types -\r\n   CHAR\t--> ArrowType.Utf8\r\n   NCHAR\t--> ArrowType.Utf8\r\n   VARCHAR --> ArrowType.Utf8\r\n   NVARCHAR --> ArrowType.Utf8\r\n   LONGVARCHAR --> ArrowType.Utf8\r\n   LONGNVARCHAR --> ArrowType.Utf8\r\n   NUMERIC --> ArrowType.Decimal(precision, scale)\r\n   DECIMAL --> ArrowType.Decimal(precision, scale)\r\n   BIT --> ArrowType.Bool\r\n   TINYINT --> ArrowType.Int(8, signed)\r\n   SMALLINT --> ArrowType.Int(16, signed)\r\n   INTEGER --> ArrowType.Int(32, signed)\r\n   BIGINT --> ArrowType.Int(64, signed)\r\n   REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\r\n   FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\r\n   DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\r\n   BINARY --> ArrowType.Binary\r\n   VARBINARY --> ArrowType.Binary\r\n   LONGVARBINARY --> ArrowType.Binary\r\n   DATE --> ArrowType.Date(DateUnit.MILLISECOND)\r\n   TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\r\n   TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\r\n   CLOB --> ArrowType.Utf8\r\n   BLOB --> ArrowType.Binary\r\n   \r\n   JUnit test cases under java/adapter/jdbc/src/test. Test cases uses H2 in-memory database. \r\n   \r\n   I am still working on adding and automating additional test cases. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-15T20:35:10.551+0000",
                    "updated": "2018-03-15T20:35:10.551+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16409958",
                    "id": "16409958",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "xhochy commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r175906418\n \n \n\n ##########\n File path: dev/release/rat_exclude_files.txt\n ##########\n @@ -74,3 +74,5 @@ c_glib/doc/reference/gtk-doc.make\n *.svg\n *.devhelp2\n *.scss\n+*.yml\n \n Review comment:\n   Don't exclude these files but add a license header to them\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-22T17:40:51.942+0000",
                    "updated": "2018-03-22T17:40:51.942+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16409959",
                    "id": "16409959",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "xhochy commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r175906922\n \n \n\n ##########\n File path: java/adapter/jdbc/pom.xml\n ##########\n @@ -0,0 +1,76 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor\n+  license agreements. See the NOTICE file distributed with this work for additional\n+  information regarding copyright ownership. The ASF licenses this file to\n+  You under the Apache License, Version 2.0 (the \"License\"); you may not use\n+  this file except in compliance with the License. You may obtain a copy of\n+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required\n+  by applicable law or agreed to in writing, software distributed under the\n+  License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n+  OF ANY KIND, either express or implied. See the License for the specific\n+  language governing permissions and limitations under the License. -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.apache.arrow.adapter.jdbc</groupId>\n+    <artifactId>arrow-jdbc</artifactId>\n+    <packaging>jar</packaging>\n+    <version>0.10.0-SNAPSHOT</version>\n+    <name>Arrow JDBC Adapter</name>\n+    <url>http://maven.apache.org</url>\n+    <dependencies>\n+\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-memory -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-memory</artifactId>\n+            <version>0.9.0-SNAPSHOT</version>\n \n Review comment:\n   Use `${project.version}` here instead of `0.9.0-SNAPSHOT`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-22T17:40:51.951+0000",
                    "updated": "2018-03-22T17:40:51.951+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16409960",
                    "id": "16409960",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "xhochy commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r175906985\n \n \n\n ##########\n File path: java/adapter/jdbc/pom.xml\n ##########\n @@ -0,0 +1,76 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor\n+  license agreements. See the NOTICE file distributed with this work for additional\n+  information regarding copyright ownership. The ASF licenses this file to\n+  You under the Apache License, Version 2.0 (the \"License\"); you may not use\n+  this file except in compliance with the License. You may obtain a copy of\n+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required\n+  by applicable law or agreed to in writing, software distributed under the\n+  License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n+  OF ANY KIND, either express or implied. See the License for the specific\n+  language governing permissions and limitations under the License. -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>org.apache.arrow.adapter.jdbc</groupId>\n+    <artifactId>arrow-jdbc</artifactId>\n+    <packaging>jar</packaging>\n+    <version>0.10.0-SNAPSHOT</version>\n+    <name>Arrow JDBC Adapter</name>\n+    <url>http://maven.apache.org</url>\n+    <dependencies>\n+\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-memory -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-memory</artifactId>\n+            <version>0.9.0-SNAPSHOT</version>\n+        </dependency>\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-vector -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-vector</artifactId>\n+            <version>0.9.0-SNAPSHOT</version>\n \n Review comment:\n   See above\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-22T17:40:52.078+0000",
                    "updated": "2018-03-22T17:40:52.078+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16412260",
                    "id": "16412260",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-375825688\n \n \n   Uwe, \r\n   I have updated the code based on your comments. Also merged with latest 0.10.0-SNAPSHOT.  Let's wait if someone from Java side can review this. I will send a message on Slack. Thanks.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-23T23:39:35.137+0000",
                    "updated": "2018-03-23T23:39:35.137+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16415991",
                    "id": "16415991",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-376613506\n \n \n   Any update on this PR? I would be interested to know if there any further review comments.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T17:44:48.795+0000",
                    "updated": "2018-03-27T17:44:48.795+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416005",
                    "id": "16416005",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-376617996\n \n \n   @atuldambalkar since this is a large PR, and we haven't had deep feedback from anyone focused on the Java implementation yet, it may be a little while for some review to come through. I would suggest bumping the mailing list thread about JDBC to draw more attention to this PR\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T17:58:02.890+0000",
                    "updated": "2018-03-27T17:58:02.890+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416006",
                    "id": "16416006",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-376618019\n \n \n   It would be good to add (or point to) simple example pieces of code to show the usage of JDBC adapter code. This would help users on how to go about writing an application that converts JDBC result sets to Arrow column vectors.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T17:58:06.434+0000",
                    "updated": "2018-03-27T17:58:06.434+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416019",
                    "id": "16416019",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177517745\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/Table.java\n ##########\n @@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+/**\n+ *\n \n Review comment:\n   I think class description is missing.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T18:03:30.609+0000",
                    "updated": "2018-03-27T18:03:30.609+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416020",
                    "id": "16416020",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "siddharthteotia commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-376620084\n \n \n   Going through the changes. Will finish reviewing soon.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T18:04:24.446+0000",
                    "updated": "2018-03-27T18:04:24.446+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416318",
                    "id": "16416318",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177587078\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.*;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * @since 0.10.0\n+ * @see ArrowDataFetcher\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @return\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n+\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n \n Review comment:\n   typo...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:06:36.750+0000",
                    "updated": "2018-03-27T22:06:36.750+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416319",
                    "id": "16416319",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177587078\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.*;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * @since 0.10.0\n+ * @see ArrowDataFetcher\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @return\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n+\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n \n Review comment:\n   typo in the assert message\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:06:46.461+0000",
                    "updated": "2018-03-27T22:06:46.461+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416386",
                    "id": "16416386",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177587483\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n+    private static final String custom_columns_query = \"select %s from %s limit %d offset %d\";\n+    private Connection connection;\n+    private String tableName;\n+\n+    /**\n+     * Constructor\n+     * @param connection\n+     * @param tableName\n+     */\n+    public ArrowDataFetcher(Connection connection, String tableName) {\n+        this.connection = connection;\n+        this.tableName = tableName;\n+    }\n+\n+    /**\n+     * Fetch the data from underlying table with the given limit and offset and for passed column names.\n+     *\n+     * @param offset\n+     * @param limit\n+     * @param columns\n+     * @return\n+     * @throws Exception\n+     */\n+    public VectorSchemaRoot fetch(int offset, int limit, String... columns) throws Exception {\n \n Review comment:\n   Exception is very broad, should we try to be more specific?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:56.658+0000",
                    "updated": "2018-03-27T22:59:56.658+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416387",
                    "id": "16416387",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177588356\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n+    private static final String custom_columns_query = \"select %s from %s limit %d offset %d\";\n+    private Connection connection;\n+    private String tableName;\n+\n+    /**\n+     * Constructor\n+     * @param connection\n+     * @param tableName\n+     */\n+    public ArrowDataFetcher(Connection connection, String tableName) {\n+        this.connection = connection;\n+        this.tableName = tableName;\n+    }\n+\n+    /**\n+     * Fetch the data from underlying table with the given limit and offset and for passed column names.\n+     *\n+     * @param offset\n+     * @param limit\n+     * @param columns\n+     * @return\n+     * @throws Exception\n+     */\n+    public VectorSchemaRoot fetch(int offset, int limit, String... columns) throws Exception {\n+        assert columns != null && columns.length > 0 : \"columns can't be empty!\";\n \n Review comment:\n   shouldn't `Preconditions` be used instead? it's not an internal assertion but an API contract, isn't it?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:56.900+0000",
                    "updated": "2018-03-27T22:59:56.900+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416388",
                    "id": "16416388",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177588025\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n \n Review comment:\n   that's assuming that this is supported by all SQL dialects (which is not the case).\r\n   Also convention for constants is to use `SNAKE_CASE`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:56.986+0000",
                    "updated": "2018-03-27T22:59:56.986+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416389",
                    "id": "16416389",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177587817\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n+    private static final String custom_columns_query = \"select %s from %s limit %d offset %d\";\n+    private Connection connection;\n+    private String tableName;\n+\n+    /**\n+     * Constructor\n+     * @param connection\n+     * @param tableName\n+     */\n+    public ArrowDataFetcher(Connection connection, String tableName) {\n \n Review comment:\n   Why not wrapping a ResultSet instead?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:57.236+0000",
                    "updated": "2018-03-27T22:59:57.236+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416390",
                    "id": "16416390",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177588748\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.*;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * @since 0.10.0\n+ * @see ArrowDataFetcher\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @return\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n+\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n+        assert query != null && query.length() > 0: \"SQL query can not be null or empty\";\n+\n+        RootAllocator rootAllocator = new RootAllocator(Integer.MAX_VALUE);\n+\n+        Statement stmt = null;\n \n Review comment:\n   it should be possible to use `try(resource initializations) { }` and get rid of the finally clause\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:57.306+0000",
                    "updated": "2018-03-27T22:59:57.306+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416391",
                    "id": "16416391",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177589483\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n \n Review comment:\n   same issue about unknown types?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:57.545+0000",
                    "updated": "2018-03-27T22:59:57.545+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416392",
                    "id": "16416392",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177589405\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n \n Review comment:\n   field is ignored, so doesn't that mess up with the resulting schema? (number of fields different between JDBC and Arrow)?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:57.565+0000",
                    "updated": "2018-03-27T22:59:57.565+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416393",
                    "id": "16416393",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177589848\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n \n Review comment:\n   to avoid too much code for each case (and dealing with issue about variables being reused or not), I would suggest to create helper methods...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:57.672+0000",
                    "updated": "2018-03-27T22:59:57.672+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416394",
                    "id": "16416394",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177588568\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.*;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * @since 0.10.0\n+ * @see ArrowDataFetcher\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @return\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n+\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n+        assert query != null && query.length() > 0: \"SQL query can not be null or empty\";\n+\n+        RootAllocator rootAllocator = new RootAllocator(Integer.MAX_VALUE);\n \n Review comment:\n   Shouldn't the allocate be provided, so that the caller has control over it? as of now, it cannot be closed once you're done with the buffers...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:57.745+0000",
                    "updated": "2018-03-27T22:59:57.745+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416395",
                    "id": "16416395",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177589044\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.*;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * @since 0.10.0\n+ * @see ArrowDataFetcher\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @return\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n+\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n+        assert query != null && query.length() > 0: \"SQL query can not be null or empty\";\n+\n+        RootAllocator rootAllocator = new RootAllocator(Integer.MAX_VALUE);\n+\n+        Statement stmt = null;\n+        ResultSet rs = null;\n+        try {\n+            stmt = connection.createStatement();\n+            rs = stmt.executeQuery(query);\n+            ResultSetMetaData rsmd = rs.getMetaData();\n+            VectorSchemaRoot root = VectorSchemaRoot.create(\n+                    JdbcToArrowUtils.jdbcToArrowSchema(rsmd), rootAllocator);\n+            JdbcToArrowUtils.jdbcToArrowVectors(rs, root);\n+            return root;\n+        } catch (Exception exc) {\n+            // just throw it out after logging\n+            throw exc;\n+        } finally {\n+            if (rs != null) {\n+                rs.close();\n+            }\n+            if (stmt != null) {\n+                stmt.close(); // test\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method returns ArrowDataFetcher Object that can be used to fetch and iterate on the data in the given\n \n Review comment:\n   Object -> object (same in the argument description)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:57.749+0000",
                    "updated": "2018-03-27T22:59:57.749+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416396",
                    "id": "16416396",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177589268\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n \n Review comment:\n   java good practices is to not use a wildcard import (at least not for static imports). The IDE should be able to expand automatically.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:57.750+0000",
                    "updated": "2018-03-27T22:59:57.750+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416397",
                    "id": "16416397",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177591421\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n+                        varcharVector.setIndexDefined(rowCount);\n+                        varcharVector.setValueLengthSafe(rowCount, value.length());\n+                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n \n Review comment:\n   `Charset.forName(\"UTF-8\")` can be replaced by `java.nio.charsets.StandardCharsets.UTF_8`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:57.926+0000",
                    "updated": "2018-03-27T22:59:57.926+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416398",
                    "id": "16416398",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177591507\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n \n Review comment:\n   why a null value would be replaced by an empty string?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:57.939+0000",
                    "updated": "2018-03-27T22:59:57.939+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416399",
                    "id": "16416399",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177591754\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n \n Review comment:\n   note how a vector is fetched for a given column, and valueCount is increased each time...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:57.958+0000",
                    "updated": "2018-03-27T22:59:57.958+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416400",
                    "id": "16416400",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177592922\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/JdbcToArrowTestHelper.java\n ##########\n @@ -0,0 +1,250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.math.BigDecimal;\n+\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+\n+import static org.junit.Assert.*;\n+\n+\n+/**\n+ * This is a Helper class which has functionalities to read and assert the values from teh given FieldVector object\n \n Review comment:\n   typo: teh -> the\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:57.998+0000",
                    "updated": "2018-03-27T22:59:57.998+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416401",
                    "id": "16416401",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177593874\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/JdbcToArrowTestHelper.java\n ##########\n @@ -0,0 +1,250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.math.BigDecimal;\n+\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+\n+import static org.junit.Assert.*;\n+\n+\n+/**\n+ * This is a Helper class which has functionalities to read and assert the values from teh given FieldVector object\n+ *\n+ */\n+public class JdbcToArrowTestHelper {\n+\n+    public static boolean assertIntVectorValues(FieldVector fx, int rowCount, int[] values) {\n+        IntVector intVector = ((IntVector) fx);\n+\n+        assertEquals(rowCount, intVector.getValueCount());\n+\n+        for(int j = 0; j < intVector.getValueCount(); j++) {\n+            if(!intVector.isNull(j)) {\n \n Review comment:\n   if `intVector.isNull()` returns true, shouldn't we fail the assertion? (or maybe take an Integer[] array instead?)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.017+0000",
                    "updated": "2018-03-27T22:59:58.017+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416402",
                    "id": "16416402",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177595348\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/h2/ArrowDataFetcherTest.java\n ##########\n @@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc.h2;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import org.apache.arrow.adapter.jdbc.*;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Test class for {@link ArrowDataFetcher}.\n+ */\n+public class ArrowDataFetcherTest extends AbstractJdbcToArrowTest {\n+\n+    private Connection conn = null;\n+    private ObjectMapper mapper = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        String url = \"jdbc:h2:mem:ArrowDataFetcherTest\";\n+        String driver = \"org.h2.Driver\";\n+\n+        mapper = new ObjectMapper(new YAMLFactory());\n+\n+        Class.forName(driver);\n+\n+        conn = DriverManager.getConnection(url);\n+    }\n+\n+    @After\n+    public void destroy() throws Exception {\n+        if (conn != null) {\n+            conn.close();\n+            conn = null;\n+        }\n+    }\n+\n+    @Test\n+    public void commaSeparatedQueryColumnsTest() {\n \n Review comment:\n   suggestion for all the test comparing results...\r\n   - put the data in the yaml file (instead of SQL statements)\r\n   - generate the h2 schema + load data automatically into the db\r\n   - refactor the test class to use `@Parameterized` with the list of YAML files to load\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.091+0000",
                    "updated": "2018-03-27T22:59:58.091+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416403",
                    "id": "16416403",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177593622\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/JdbcToArrowTestHelper.java\n ##########\n @@ -0,0 +1,250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.math.BigDecimal;\n+\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+\n+import static org.junit.Assert.*;\n+\n+\n+/**\n+ * This is a Helper class which has functionalities to read and assert the values from teh given FieldVector object\n+ *\n+ */\n+public class JdbcToArrowTestHelper {\n+\n+    public static boolean assertIntVectorValues(FieldVector fx, int rowCount, int[] values) {\n+        IntVector intVector = ((IntVector) fx);\n+\n+        assertEquals(rowCount, intVector.getValueCount());\n+\n+        for(int j = 0; j < intVector.getValueCount(); j++) {\n+            if(!intVector.isNull(j)) {\n+                assertEquals(values[j], intVector.get(j));\n+            }\n+        }\n+        return true;\n \n Review comment:\n   not sure what the boolean return value is for, since it's always `true`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.116+0000",
                    "updated": "2018-03-27T22:59:58.116+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416404",
                    "id": "16416404",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177590101\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n \n Review comment:\n   what about null values? (current code will throw NPE I guess...)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.119+0000",
                    "updated": "2018-03-27T22:59:58.119+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416405",
                    "id": "16416405",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177591258\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n+                        varcharVector.setIndexDefined(rowCount);\n+                        varcharVector.setValueLengthSafe(rowCount, value.length());\n+                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n+                        varcharVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DATE:\n+                        Date date = rs.getDate(i);\n+                        DateMilliVector dateMilliVector = (DateMilliVector) root.getVector(columnName);\n+                        dateMilliVector.setValueCount(rowCount + 1);\n+                        if (date != null) {\n+                            dateMilliVector.setSafe(rowCount, rs.getDate(i).getTime());\n \n Review comment:\n   There might be a potential issue with timezones. I'm not sure if there's a sane semantic (Java8/JDBC 4.2 has LocalDate...)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.121+0000",
                    "updated": "2018-03-27T22:59:58.121+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416406",
                    "id": "16416406",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177594286\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/JdbcToArrowTestHelper.java\n ##########\n @@ -0,0 +1,250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.math.BigDecimal;\n+\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+\n+import static org.junit.Assert.*;\n+\n+\n+/**\n+ * This is a Helper class which has functionalities to read and assert the values from teh given FieldVector object\n+ *\n+ */\n+public class JdbcToArrowTestHelper {\n+\n+    public static boolean assertIntVectorValues(FieldVector fx, int rowCount, int[] values) {\n+        IntVector intVector = ((IntVector) fx);\n+\n+        assertEquals(rowCount, intVector.getValueCount());\n+\n+        for(int j = 0; j < intVector.getValueCount(); j++) {\n+            if(!intVector.isNull(j)) {\n+                assertEquals(values[j], intVector.get(j));\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static boolean assertBitBooleanVectorValues(FieldVector fx, int rowCount, int[] values){\n+        BitVector bitVector = ((BitVector)fx);\n+        assertEquals(rowCount, bitVector.getValueCount());\n+        for(int j = 0; j < bitVector.getValueCount(); j++){\n+            if(!bitVector.isNull(j)) {\n+                assertEquals(values[j], bitVector.get(j));\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static boolean assertTinyIntVectorValues(FieldVector fx, int rowCount, int[] values){\n+        TinyIntVector tinyIntVector = ((TinyIntVector)fx);\n+\n+        assertEquals(rowCount, tinyIntVector.getValueCount());\n+\n+        for(int j = 0; j < tinyIntVector.getValueCount(); j++){\n+            if(!tinyIntVector.isNull(j)) {\n+                assertEquals(values[j], tinyIntVector.get(j));\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static boolean assertSmallIntVectorValues(FieldVector fx, int rowCount, int[] values){\n+        SmallIntVector smallIntVector = ((SmallIntVector)fx);\n+\n+        assertEquals(rowCount, smallIntVector.getValueCount());\n+\n+        for(int j = 0; j < smallIntVector.getValueCount(); j++){\n+            if(!smallIntVector.isNull(j)){\n+                assertEquals(values[j], smallIntVector.get(j));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertBigIntVectorValues(FieldVector fx, int rowCount, int[] values){\n+        BigIntVector bigIntVector = ((BigIntVector)fx);\n+\n+        assertEquals(rowCount, bigIntVector.getValueCount());\n+\n+        for(int j = 0; j < bigIntVector.getValueCount(); j++){\n+            if(!bigIntVector.isNull(j)) {\n+                assertEquals(values[j], bigIntVector.get(j));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertDecimalVectorValues(FieldVector fx, int rowCount, BigDecimal[] values){\n+        DecimalVector decimalVector = ((DecimalVector)fx);\n+\n+        assertEquals(rowCount, decimalVector.getValueCount());\n+\n+        for(int j = 0; j < decimalVector.getValueCount(); j++){\n+            if(!decimalVector.isNull(j)){\n+                assertEquals(values[j].doubleValue(), decimalVector.getObject(j).doubleValue(), 0);\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertFloat8VectorValues(FieldVector fx, int rowCount, double[] values){\n+        Float8Vector float8Vector = ((Float8Vector)fx);\n+\n+        assertEquals(rowCount, float8Vector.getValueCount());\n+\n+        for(int j = 0; j < float8Vector.getValueCount(); j++){\n+            if(!float8Vector.isNull(j)) {\n+                assertEquals(values[j], float8Vector.get(j), 0.01);\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertFloat4VectorValues(FieldVector fx, int rowCount, float[] values){\n+        Float4Vector float4Vector = ((Float4Vector)fx);\n+\n+        assertEquals(rowCount, float4Vector.getValueCount());\n+\n+        for(int j = 0; j < float4Vector.getValueCount(); j++){\n+            if(!float4Vector.isNull(j)){\n+                assertEquals(values[j], float4Vector.get(j), 0.01);\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertTimeVectorValues(FieldVector fx, int rowCount, long[] values){\n+        TimeMilliVector timeMilliVector = ((TimeMilliVector)fx);\n+\n+        assertEquals(rowCount, timeMilliVector.getValueCount());\n+\n+        for(int j = 0; j < timeMilliVector.getValueCount(); j++){\n+            if(!timeMilliVector.isNull(j)){\n+                assertEquals(values[j], timeMilliVector.get(j));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertDateVectorValues(FieldVector fx, int rowCount, long[] values){\n+        DateMilliVector dateMilliVector = ((DateMilliVector)fx);\n+\n+        assertEquals(rowCount, dateMilliVector.getValueCount());\n+\n+        for(int j = 0; j < dateMilliVector.getValueCount(); j++){\n+            if(!dateMilliVector.isNull(j)){\n+                assertEquals(values[j], dateMilliVector.get(j));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertTimeStampVectorValues(FieldVector fx, int rowCount, long[] values){\n+        TimeStampVector timeStampVector = ((TimeStampVector)fx);\n+\n+        assertEquals(rowCount, timeStampVector.getValueCount());\n+\n+        for(int j = 0; j < timeStampVector.getValueCount(); j++){\n+            if(!timeStampVector.isNull(j)){\n+                assertEquals(values[j], timeStampVector.get(j));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertVarBinaryVectorValues(FieldVector fx, int rowCount, byte[][] values){\n+        VarBinaryVector varBinaryVector =((VarBinaryVector) fx);\n+\n+        assertEquals(rowCount, varBinaryVector.getValueCount());\n+\n+        for(int j = 0; j < varBinaryVector.getValueCount(); j++){\n+            if(!varBinaryVector.isNull(j)){\n+                assertEquals(hashArray(values[j]), hashArray(varBinaryVector.get(j)));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertVarcharVectorValues(FieldVector fx, int rowCount, byte[][] values) {\n+        VarCharVector varCharVector = ((VarCharVector)fx);\n+\n+        assertEquals(rowCount, varCharVector.getValueCount());\n+\n+        for(int j = 0; j < varCharVector.getValueCount(); j++){\n+            if(!varCharVector.isNull(j)){\n+                assertEquals(hashArray(values[j]), hashArray(varCharVector.get(j)));\n \n Review comment:\n   why comparing the hash instead of the array content? (since the hash is based on the array content anyway...)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.121+0000",
                    "updated": "2018-03-27T22:59:58.121+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416407",
                    "id": "16416407",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177597188\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/h2/ArrowDataFetcherTest.java\n ##########\n @@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc.h2;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import org.apache.arrow.adapter.jdbc.*;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Test class for {@link ArrowDataFetcher}.\n+ */\n+public class ArrowDataFetcherTest extends AbstractJdbcToArrowTest {\n+\n+    private Connection conn = null;\n+    private ObjectMapper mapper = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        String url = \"jdbc:h2:mem:ArrowDataFetcherTest\";\n+        String driver = \"org.h2.Driver\";\n+\n+        mapper = new ObjectMapper(new YAMLFactory());\n+\n+        Class.forName(driver);\n+\n+        conn = DriverManager.getConnection(url);\n+    }\n+\n+    @After\n+    public void destroy() throws Exception {\n+        if (conn != null) {\n+            conn.close();\n+            conn = null;\n+        }\n+    }\n+\n+    @Test\n+    public void commaSeparatedQueryColumnsTest() {\n+        try {\n+            ArrowDataFetcher.commaSeparatedQueryColumns(null);\n+        } catch (AssertionError error) {\n+            assertTrue(true);\n+        }\n+        assertEquals(\" one \", ArrowDataFetcher.commaSeparatedQueryColumns(\"one\"));\n+        assertEquals(\" one, two \", ArrowDataFetcher.commaSeparatedQueryColumns(\"one\", \"two\"));\n+        assertEquals(\" one, two, three \", ArrowDataFetcher.commaSeparatedQueryColumns(\"one\", \"two\", \"three\"));\n+    }\n+\n+    @Test\n+    public void arrowFetcherAllColumnsLimitOffsetTest() throws Exception {\n+\n+        Table table =\n+                mapper.readValue(\n+                        this.getClass().getClassLoader().getResourceAsStream(\"h2/test1_int_h2.yml\"),\n+                        Table.class);\n+\n+        try {\n+            createTestData(conn, table);\n+\n+            ArrowDataFetcher arrowDataFetcher = JdbcToArrow.jdbcArrowDataFetcher(conn, \"table1\");\n+\n+            VectorSchemaRoot root = arrowDataFetcher.fetch(0, 10);\n+\n+            int[] values = {\n+                    101, 101, 101, 101, 101, 101, 101, 101, 101, 101\n+            };\n+            JdbcToArrowTestHelper.assertIntVectorValues(root.getVector(\"INT_FIELD1\"), 10, values);\n+\n+            root = arrowDataFetcher.fetch(5, 5);\n+\n+            JdbcToArrowTestHelper.assertIntVectorValues(root.getVector(\"INT_FIELD1\"), 5, values);\n+\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        } finally {\n+            deleteTestData(conn, table);\n \n Review comment:\n   since the connection is closed, that should trigger the in-memory db to be cleaned up (and not requiring a drop table...)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.125+0000",
                    "updated": "2018-03-27T22:59:58.125+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416408",
                    "id": "16416408",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177592278\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n+                        varcharVector.setIndexDefined(rowCount);\n+                        varcharVector.setValueLengthSafe(rowCount, value.length());\n+                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n+                        varcharVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DATE:\n+                        Date date = rs.getDate(i);\n+                        DateMilliVector dateMilliVector = (DateMilliVector) root.getVector(columnName);\n+                        dateMilliVector.setValueCount(rowCount + 1);\n+                        if (date != null) {\n+                            dateMilliVector.setSafe(rowCount, rs.getDate(i).getTime());\n+                        } else {\n+                            dateMilliVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.TIME:\n+                        Time time = rs.getTime(i);\n+                        TimeMilliVector timeMilliVector = (TimeMilliVector)root.getVector(columnName);\n+                        timeMilliVector.setValueCount(rowCount + 1);\n+                        if (time != null) {\n+                            timeMilliVector.setSafe(rowCount, (int) rs.getTime(i).getTime());\n+                        } else {\n+                            timeMilliVector.setNull(rowCount);\n+                        }\n+\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        // timezone is null\n+                        Timestamp timestamp = rs.getTimestamp(i);\n+                        TimeStampVector timeStampVector = (TimeStampVector)root.getVector(columnName);\n+                        timeStampVector.setValueCount(rowCount + 1);\n+                        if (timestamp != null) {\n+                            timeStampVector.setSafe(rowCount, timestamp.getTime());\n+                        } else {\n+                            timeStampVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        VarBinaryVector varBinaryVector = (VarBinaryVector)root.getVector(columnName);;\n+                        varBinaryVector.setValueCount(rowCount + 1);\n+                        byte[] bytes = rs.getBytes(i);\n+                        if (bytes != null) {\n+                            varBinaryVector.setIndexDefined(rowCount);\n+                            varBinaryVector.setValueLengthSafe(rowCount, bytes.length);\n+                            varBinaryVector.setSafe(rowCount, bytes);\n+                        } else {\n+                            varBinaryVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.ARRAY:\n+                        // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                        break;\n+                    case Types.CLOB:\n+                        VarCharVector varcharVector1 = (VarCharVector)root.getVector(columnName);\n+                        varcharVector1.setValueCount(rowCount + 1);\n+                        Clob clob = rs.getClob(i);\n+                        if (clob != null) {\n+                            int length = (int) clob.length();\n \n Review comment:\n   if the value is bigger than `Integer.MAX_VALUE`, might cause to return an invalid value, with an exception if the value is negative, or truncated if the value is positive...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.125+0000",
                    "updated": "2018-03-27T22:59:58.125+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416409",
                    "id": "16416409",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177588989\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.*;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * @since 0.10.0\n+ * @see ArrowDataFetcher\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @return\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n+\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n+        assert query != null && query.length() > 0: \"SQL query can not be null or empty\";\n+\n+        RootAllocator rootAllocator = new RootAllocator(Integer.MAX_VALUE);\n+\n+        Statement stmt = null;\n+        ResultSet rs = null;\n+        try {\n+            stmt = connection.createStatement();\n+            rs = stmt.executeQuery(query);\n+            ResultSetMetaData rsmd = rs.getMetaData();\n+            VectorSchemaRoot root = VectorSchemaRoot.create(\n+                    JdbcToArrowUtils.jdbcToArrowSchema(rsmd), rootAllocator);\n+            JdbcToArrowUtils.jdbcToArrowVectors(rs, root);\n+            return root;\n+        } catch (Exception exc) {\n+            // just throw it out after logging\n+            throw exc;\n+        } finally {\n+            if (rs != null) {\n+                rs.close();\n+            }\n+            if (stmt != null) {\n+                stmt.close(); // test\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method returns ArrowDataFetcher Object that can be used to fetch and iterate on the data in the given\n+     * database table.\n+     *\n+     * @param connection - Database connection Object\n+     * @param tableName - Table name from which records will be fetched\n+     *\n+     * @return ArrowDataFetcher - Instance of ArrowDataFetcher which can be used to get Arrow Vector obejcts by calling its functionality\n+     */\n+    public static ArrowDataFetcher jdbcArrowDataFetcher(Connection connection, String tableName) {\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n \n Review comment:\n   same typo\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.131+0000",
                    "updated": "2018-03-27T22:59:58.131+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416410",
                    "id": "16416410",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177594176\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/JdbcToArrowTestHelper.java\n ##########\n @@ -0,0 +1,250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.math.BigDecimal;\n+\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+\n+import static org.junit.Assert.*;\n+\n+\n+/**\n+ * This is a Helper class which has functionalities to read and assert the values from teh given FieldVector object\n+ *\n+ */\n+public class JdbcToArrowTestHelper {\n+\n+    public static boolean assertIntVectorValues(FieldVector fx, int rowCount, int[] values) {\n+        IntVector intVector = ((IntVector) fx);\n \n Review comment:\n   (style) superfluous parenthesis. (Also you might want to manage the cast by the caller, not the callee?)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.136+0000",
                    "updated": "2018-03-27T22:59:58.136+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416411",
                    "id": "16416411",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177594750\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/h2/ArrowDataFetcherTest.java\n ##########\n @@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc.h2;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import org.apache.arrow.adapter.jdbc.*;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Test class for {@link ArrowDataFetcher}.\n+ */\n+public class ArrowDataFetcherTest extends AbstractJdbcToArrowTest {\n+\n+    private Connection conn = null;\n+    private ObjectMapper mapper = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        String url = \"jdbc:h2:mem:ArrowDataFetcherTest\";\n+        String driver = \"org.h2.Driver\";\n+\n+        mapper = new ObjectMapper(new YAMLFactory());\n+\n+        Class.forName(driver);\n \n Review comment:\n   not sure that's necessary (h2 should have the right service metadata file)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.148+0000",
                    "updated": "2018-03-27T22:59:58.148+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416412",
                    "id": "16416412",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177593417\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/JdbcToArrowTestHelper.java\n ##########\n @@ -0,0 +1,250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.math.BigDecimal;\n+\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+\n+import static org.junit.Assert.*;\n+\n+\n+/**\n+ * This is a Helper class which has functionalities to read and assert the values from teh given FieldVector object\n+ *\n+ */\n+public class JdbcToArrowTestHelper {\n+\n+    public static boolean assertIntVectorValues(FieldVector fx, int rowCount, int[] values) {\n+        IntVector intVector = ((IntVector) fx);\n+\n+        assertEquals(rowCount, intVector.getValueCount());\n+\n+        for(int j = 0; j < intVector.getValueCount(); j++) {\n+            if(!intVector.isNull(j)) {\n+                assertEquals(values[j], intVector.get(j));\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static boolean assertBitBooleanVectorValues(FieldVector fx, int rowCount, int[] values){\n+        BitVector bitVector = ((BitVector)fx);\n+        assertEquals(rowCount, bitVector.getValueCount());\n+        for(int j = 0; j < bitVector.getValueCount(); j++){\n+            if(!bitVector.isNull(j)) {\n+                assertEquals(values[j], bitVector.get(j));\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static boolean assertTinyIntVectorValues(FieldVector fx, int rowCount, int[] values){\n+        TinyIntVector tinyIntVector = ((TinyIntVector)fx);\n+\n+        assertEquals(rowCount, tinyIntVector.getValueCount());\n+\n+        for(int j = 0; j < tinyIntVector.getValueCount(); j++){\n+            if(!tinyIntVector.isNull(j)) {\n+                assertEquals(values[j], tinyIntVector.get(j));\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static boolean assertSmallIntVectorValues(FieldVector fx, int rowCount, int[] values){\n+        SmallIntVector smallIntVector = ((SmallIntVector)fx);\n+\n+        assertEquals(rowCount, smallIntVector.getValueCount());\n+\n+        for(int j = 0; j < smallIntVector.getValueCount(); j++){\n+            if(!smallIntVector.isNull(j)){\n+                assertEquals(values[j], smallIntVector.get(j));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertBigIntVectorValues(FieldVector fx, int rowCount, int[] values){\n+        BigIntVector bigIntVector = ((BigIntVector)fx);\n+\n+        assertEquals(rowCount, bigIntVector.getValueCount());\n+\n+        for(int j = 0; j < bigIntVector.getValueCount(); j++){\n+            if(!bigIntVector.isNull(j)) {\n+                assertEquals(values[j], bigIntVector.get(j));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertDecimalVectorValues(FieldVector fx, int rowCount, BigDecimal[] values){\n+        DecimalVector decimalVector = ((DecimalVector)fx);\n+\n+        assertEquals(rowCount, decimalVector.getValueCount());\n+\n+        for(int j = 0; j < decimalVector.getValueCount(); j++){\n+            if(!decimalVector.isNull(j)){\n+                assertEquals(values[j].doubleValue(), decimalVector.getObject(j).doubleValue(), 0);\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertFloat8VectorValues(FieldVector fx, int rowCount, double[] values){\n+        Float8Vector float8Vector = ((Float8Vector)fx);\n+\n+        assertEquals(rowCount, float8Vector.getValueCount());\n+\n+        for(int j = 0; j < float8Vector.getValueCount(); j++){\n+            if(!float8Vector.isNull(j)) {\n+                assertEquals(values[j], float8Vector.get(j), 0.01);\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertFloat4VectorValues(FieldVector fx, int rowCount, float[] values){\n+        Float4Vector float4Vector = ((Float4Vector)fx);\n+\n+        assertEquals(rowCount, float4Vector.getValueCount());\n+\n+        for(int j = 0; j < float4Vector.getValueCount(); j++){\n+            if(!float4Vector.isNull(j)){\n+                assertEquals(values[j], float4Vector.get(j), 0.01);\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertTimeVectorValues(FieldVector fx, int rowCount, long[] values){\n+        TimeMilliVector timeMilliVector = ((TimeMilliVector)fx);\n+\n+        assertEquals(rowCount, timeMilliVector.getValueCount());\n+\n+        for(int j = 0; j < timeMilliVector.getValueCount(); j++){\n+            if(!timeMilliVector.isNull(j)){\n+                assertEquals(values[j], timeMilliVector.get(j));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertDateVectorValues(FieldVector fx, int rowCount, long[] values){\n+        DateMilliVector dateMilliVector = ((DateMilliVector)fx);\n+\n+        assertEquals(rowCount, dateMilliVector.getValueCount());\n+\n+        for(int j = 0; j < dateMilliVector.getValueCount(); j++){\n+            if(!dateMilliVector.isNull(j)){\n+                assertEquals(values[j], dateMilliVector.get(j));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertTimeStampVectorValues(FieldVector fx, int rowCount, long[] values){\n+        TimeStampVector timeStampVector = ((TimeStampVector)fx);\n+\n+        assertEquals(rowCount, timeStampVector.getValueCount());\n+\n+        for(int j = 0; j < timeStampVector.getValueCount(); j++){\n+            if(!timeStampVector.isNull(j)){\n+                assertEquals(values[j], timeStampVector.get(j));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertVarBinaryVectorValues(FieldVector fx, int rowCount, byte[][] values){\n+        VarBinaryVector varBinaryVector =((VarBinaryVector) fx);\n+\n+        assertEquals(rowCount, varBinaryVector.getValueCount());\n+\n+        for(int j = 0; j < varBinaryVector.getValueCount(); j++){\n+            if(!varBinaryVector.isNull(j)){\n+                assertEquals(hashArray(values[j]), hashArray(varBinaryVector.get(j)));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static boolean assertVarcharVectorValues(FieldVector fx, int rowCount, byte[][] values) {\n+        VarCharVector varCharVector = ((VarCharVector)fx);\n+\n+        assertEquals(rowCount, varCharVector.getValueCount());\n+\n+        for(int j = 0; j < varCharVector.getValueCount(); j++){\n+            if(!varCharVector.isNull(j)){\n+                assertEquals(hashArray(values[j]), hashArray(varCharVector.get(j)));\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    public static long hashArray(byte[] data){\n \n Review comment:\n   use `Arrays.hashCode(byte[] instead)`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.151+0000",
                    "updated": "2018-03-27T22:59:58.151+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416413",
                    "id": "16416413",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177592633\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n+                        varcharVector.setIndexDefined(rowCount);\n+                        varcharVector.setValueLengthSafe(rowCount, value.length());\n+                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n+                        varcharVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DATE:\n+                        Date date = rs.getDate(i);\n+                        DateMilliVector dateMilliVector = (DateMilliVector) root.getVector(columnName);\n+                        dateMilliVector.setValueCount(rowCount + 1);\n+                        if (date != null) {\n+                            dateMilliVector.setSafe(rowCount, rs.getDate(i).getTime());\n+                        } else {\n+                            dateMilliVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.TIME:\n+                        Time time = rs.getTime(i);\n+                        TimeMilliVector timeMilliVector = (TimeMilliVector)root.getVector(columnName);\n+                        timeMilliVector.setValueCount(rowCount + 1);\n+                        if (time != null) {\n+                            timeMilliVector.setSafe(rowCount, (int) rs.getTime(i).getTime());\n+                        } else {\n+                            timeMilliVector.setNull(rowCount);\n+                        }\n+\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        // timezone is null\n+                        Timestamp timestamp = rs.getTimestamp(i);\n+                        TimeStampVector timeStampVector = (TimeStampVector)root.getVector(columnName);\n+                        timeStampVector.setValueCount(rowCount + 1);\n+                        if (timestamp != null) {\n+                            timeStampVector.setSafe(rowCount, timestamp.getTime());\n+                        } else {\n+                            timeStampVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        VarBinaryVector varBinaryVector = (VarBinaryVector)root.getVector(columnName);;\n+                        varBinaryVector.setValueCount(rowCount + 1);\n+                        byte[] bytes = rs.getBytes(i);\n+                        if (bytes != null) {\n+                            varBinaryVector.setIndexDefined(rowCount);\n+                            varBinaryVector.setValueLengthSafe(rowCount, bytes.length);\n+                            varBinaryVector.setSafe(rowCount, bytes);\n+                        } else {\n+                            varBinaryVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.ARRAY:\n+                        // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                        break;\n+                    case Types.CLOB:\n+                        VarCharVector varcharVector1 = (VarCharVector)root.getVector(columnName);\n+                        varcharVector1.setValueCount(rowCount + 1);\n+                        Clob clob = rs.getClob(i);\n+                        if (clob != null) {\n+                            int length = (int) clob.length();\n+                            varcharVector1.setIndexDefined(rowCount);\n+                            varcharVector1.setValueLengthSafe(rowCount, length);\n+                            varcharVector1.setSafe(rowCount, clob.getSubString(1, length).getBytes(), 0, length);\n \n Review comment:\n   - better use a streaming API\r\n   - an encoding should be specified for `getBytes()`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.164+0000",
                    "updated": "2018-03-27T22:59:58.164+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416414",
                    "id": "16416414",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177593055\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n \n Review comment:\n   not sure that BIGINT can be converted into an int (maybe a long?)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.198+0000",
                    "updated": "2018-03-27T22:59:58.198+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416415",
                    "id": "16416415",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177595960\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/h2/JdbcToArrowTest.java\n ##########\n @@ -0,0 +1,325 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc.h2;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import org.apache.arrow.adapter.jdbc.AbstractJdbcToArrowTest;\n+import org.apache.arrow.adapter.jdbc.JdbcToArrow;\n+import org.apache.arrow.adapter.jdbc.Table;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.Properties;\n+\n+import static org.apache.arrow.adapter.jdbc.JdbcToArrowTestHelper.*;\n+\n+/**\n+ *\n+ */\n+public class JdbcToArrowTest extends AbstractJdbcToArrowTest {\n+\n+    private Connection conn = null;\n+    private ObjectMapper mapper = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        String url = \"jdbc:h2:mem:JdbcToArrowTest\";\n+        String driver = \"org.h2.Driver\";\n+\n+        mapper = new ObjectMapper(new YAMLFactory());\n+\n+        Class.forName(driver);\n+\n+        conn = DriverManager.getConnection(url);\n+    }\n+\n+    @After\n+    public void destroy() throws Exception {\n+        if (conn != null) {\n+            conn.close();\n+            conn = null;\n+        }\n+    }\n+\n+    @Test\n+    public void sqlToArrowTestInt() throws Exception {\n \n Review comment:\n   suggestion for all the test comparing results...\r\n   - put the type/data in the yaml file (instead of SQL statements)\r\n   - generate the h2 schema + load data automatically into the db\r\n   - refactor the test class to use `@Parameterized` with the list of YAML files to load\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.223+0000",
                    "updated": "2018-03-27T22:59:58.223+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416416",
                    "id": "16416416",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177596733\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/h2/ArrowDataFetcherTest.java\n ##########\n @@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc.h2;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import org.apache.arrow.adapter.jdbc.*;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Test class for {@link ArrowDataFetcher}.\n+ */\n+public class ArrowDataFetcherTest extends AbstractJdbcToArrowTest {\n+\n+    private Connection conn = null;\n+    private ObjectMapper mapper = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        String url = \"jdbc:h2:mem:ArrowDataFetcherTest\";\n+        String driver = \"org.h2.Driver\";\n+\n+        mapper = new ObjectMapper(new YAMLFactory());\n+\n+        Class.forName(driver);\n+\n+        conn = DriverManager.getConnection(url);\n+    }\n+\n+    @After\n+    public void destroy() throws Exception {\n+        if (conn != null) {\n+            conn.close();\n+            conn = null;\n+        }\n+    }\n+\n+    @Test\n+    public void commaSeparatedQueryColumnsTest() {\n+        try {\n+            ArrowDataFetcher.commaSeparatedQueryColumns(null);\n+        } catch (AssertionError error) {\n+            assertTrue(true);\n \n Review comment:\n   why this check? (it seems that basically it ignores the fact that the statement throws AssertionError, but it's not checking that it always fails either...)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.224+0000",
                    "updated": "2018-03-27T22:59:58.224+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416417",
                    "id": "16416417",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177592821\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n+                        varcharVector.setIndexDefined(rowCount);\n+                        varcharVector.setValueLengthSafe(rowCount, value.length());\n+                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n+                        varcharVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DATE:\n+                        Date date = rs.getDate(i);\n+                        DateMilliVector dateMilliVector = (DateMilliVector) root.getVector(columnName);\n+                        dateMilliVector.setValueCount(rowCount + 1);\n+                        if (date != null) {\n+                            dateMilliVector.setSafe(rowCount, rs.getDate(i).getTime());\n+                        } else {\n+                            dateMilliVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.TIME:\n+                        Time time = rs.getTime(i);\n+                        TimeMilliVector timeMilliVector = (TimeMilliVector)root.getVector(columnName);\n+                        timeMilliVector.setValueCount(rowCount + 1);\n+                        if (time != null) {\n+                            timeMilliVector.setSafe(rowCount, (int) rs.getTime(i).getTime());\n+                        } else {\n+                            timeMilliVector.setNull(rowCount);\n+                        }\n+\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        // timezone is null\n+                        Timestamp timestamp = rs.getTimestamp(i);\n+                        TimeStampVector timeStampVector = (TimeStampVector)root.getVector(columnName);\n+                        timeStampVector.setValueCount(rowCount + 1);\n+                        if (timestamp != null) {\n+                            timeStampVector.setSafe(rowCount, timestamp.getTime());\n+                        } else {\n+                            timeStampVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        VarBinaryVector varBinaryVector = (VarBinaryVector)root.getVector(columnName);;\n+                        varBinaryVector.setValueCount(rowCount + 1);\n+                        byte[] bytes = rs.getBytes(i);\n+                        if (bytes != null) {\n+                            varBinaryVector.setIndexDefined(rowCount);\n+                            varBinaryVector.setValueLengthSafe(rowCount, bytes.length);\n+                            varBinaryVector.setSafe(rowCount, bytes);\n+                        } else {\n+                            varBinaryVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.ARRAY:\n+                        // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                        break;\n+                    case Types.CLOB:\n+                        VarCharVector varcharVector1 = (VarCharVector)root.getVector(columnName);\n+                        varcharVector1.setValueCount(rowCount + 1);\n+                        Clob clob = rs.getClob(i);\n+                        if (clob != null) {\n+                            int length = (int) clob.length();\n+                            varcharVector1.setIndexDefined(rowCount);\n+                            varcharVector1.setValueLengthSafe(rowCount, length);\n+                            varcharVector1.setSafe(rowCount, clob.getSubString(1, length).getBytes(), 0, length);\n+                        } else {\n+                            varcharVector1.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.BLOB:\n+                        VarBinaryVector varBinaryVector1 = (VarBinaryVector)root.getVector(columnName);;\n+                        varBinaryVector1.setValueCount(rowCount + 1);\n+                        Blob blob = rs.getBlob(i);\n+                        if (blob != null) {\n+                            byte[] data = blob.getBytes(0, (int) blob.length());\n \n Review comment:\n   same as clob, a streaming api to access data might be a better choice to not pressure JVM heap too much...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.241+0000",
                    "updated": "2018-03-27T22:59:58.241+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416418",
                    "id": "16416418",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177596898\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/h2/ArrowDataFetcherTest.java\n ##########\n @@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc.h2;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import org.apache.arrow.adapter.jdbc.*;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Test class for {@link ArrowDataFetcher}.\n+ */\n+public class ArrowDataFetcherTest extends AbstractJdbcToArrowTest {\n+\n+    private Connection conn = null;\n+    private ObjectMapper mapper = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        String url = \"jdbc:h2:mem:ArrowDataFetcherTest\";\n+        String driver = \"org.h2.Driver\";\n+\n+        mapper = new ObjectMapper(new YAMLFactory());\n+\n+        Class.forName(driver);\n+\n+        conn = DriverManager.getConnection(url);\n+    }\n+\n+    @After\n+    public void destroy() throws Exception {\n+        if (conn != null) {\n+            conn.close();\n+            conn = null;\n+        }\n+    }\n+\n+    @Test\n+    public void commaSeparatedQueryColumnsTest() {\n \n Review comment:\n   since this is not using any connection, it might be moved in a separate test class with no setup required?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.250+0000",
                    "updated": "2018-03-27T22:59:58.250+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416419",
                    "id": "16416419",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177594008\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/JdbcToArrowTestHelper.java\n ##########\n @@ -0,0 +1,250 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.math.BigDecimal;\n+\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+\n+import static org.junit.Assert.*;\n+\n+\n+/**\n+ * This is a Helper class which has functionalities to read and assert the values from teh given FieldVector object\n+ *\n+ */\n+public class JdbcToArrowTestHelper {\n+\n+    public static boolean assertIntVectorValues(FieldVector fx, int rowCount, int[] values) {\n+        IntVector intVector = ((IntVector) fx);\n+\n+        assertEquals(rowCount, intVector.getValueCount());\n+\n+        for(int j = 0; j < intVector.getValueCount(); j++) {\n \n Review comment:\n   what if `values.length` doesn't match `rowCount`?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.265+0000",
                    "updated": "2018-03-27T22:59:58.265+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416420",
                    "id": "16416420",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177595647\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/h2/ArrowDataFetcherTest.java\n ##########\n @@ -0,0 +1,139 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc.h2;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import org.apache.arrow.adapter.jdbc.*;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Test class for {@link ArrowDataFetcher}.\n+ */\n+public class ArrowDataFetcherTest extends AbstractJdbcToArrowTest {\n+\n+    private Connection conn = null;\n+    private ObjectMapper mapper = null;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        String url = \"jdbc:h2:mem:ArrowDataFetcherTest\";\n+        String driver = \"org.h2.Driver\";\n+\n+        mapper = new ObjectMapper(new YAMLFactory());\n+\n+        Class.forName(driver);\n+\n+        conn = DriverManager.getConnection(url);\n+    }\n+\n+    @After\n+    public void destroy() throws Exception {\n+        if (conn != null) {\n+            conn.close();\n+            conn = null;\n+        }\n+    }\n+\n+    @Test\n+    public void commaSeparatedQueryColumnsTest() {\n+        try {\n+            ArrowDataFetcher.commaSeparatedQueryColumns(null);\n+        } catch (AssertionError error) {\n+            assertTrue(true);\n+        }\n+        assertEquals(\" one \", ArrowDataFetcher.commaSeparatedQueryColumns(\"one\"));\n+        assertEquals(\" one, two \", ArrowDataFetcher.commaSeparatedQueryColumns(\"one\", \"two\"));\n+        assertEquals(\" one, two, three \", ArrowDataFetcher.commaSeparatedQueryColumns(\"one\", \"two\", \"three\"));\n+    }\n+\n+    @Test\n+    public void arrowFetcherAllColumnsLimitOffsetTest() throws Exception {\n+\n+        Table table =\n+                mapper.readValue(\n+                        this.getClass().getClassLoader().getResourceAsStream(\"h2/test1_int_h2.yml\"),\n+                        Table.class);\n+\n+        try {\n+            createTestData(conn, table);\n+\n+            ArrowDataFetcher arrowDataFetcher = JdbcToArrow.jdbcArrowDataFetcher(conn, \"table1\");\n+\n+            VectorSchemaRoot root = arrowDataFetcher.fetch(0, 10);\n+\n+            int[] values = {\n+                    101, 101, 101, 101, 101, 101, 101, 101, 101, 101\n+            };\n+            JdbcToArrowTestHelper.assertIntVectorValues(root.getVector(\"INT_FIELD1\"), 10, values);\n+\n+            root = arrowDataFetcher.fetch(5, 5);\n+\n+            JdbcToArrowTestHelper.assertIntVectorValues(root.getVector(\"INT_FIELD1\"), 5, values);\n+\n+        } catch (Exception e) {\n+            e.printStackTrace();\n \n Review comment:\n   this test will not error out in case of exception...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.329+0000",
                    "updated": "2018-03-27T22:59:58.329+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416421",
                    "id": "16416421",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r177591823\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n+                        varcharVector.setIndexDefined(rowCount);\n+                        varcharVector.setValueLengthSafe(rowCount, value.length());\n+                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n+                        varcharVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DATE:\n+                        Date date = rs.getDate(i);\n+                        DateMilliVector dateMilliVector = (DateMilliVector) root.getVector(columnName);\n+                        dateMilliVector.setValueCount(rowCount + 1);\n+                        if (date != null) {\n+                            dateMilliVector.setSafe(rowCount, rs.getDate(i).getTime());\n+                        } else {\n+                            dateMilliVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.TIME:\n+                        Time time = rs.getTime(i);\n+                        TimeMilliVector timeMilliVector = (TimeMilliVector)root.getVector(columnName);\n+                        timeMilliVector.setValueCount(rowCount + 1);\n+                        if (time != null) {\n+                            timeMilliVector.setSafe(rowCount, (int) rs.getTime(i).getTime());\n+                        } else {\n+                            timeMilliVector.setNull(rowCount);\n+                        }\n+\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        // timezone is null\n \n Review comment:\n   is it?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T22:59:58.365+0000",
                    "updated": "2018-03-27T22:59:58.365+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16416450",
                    "id": "16416450",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-376706778\n \n \n   Thanks @laurentgo and @siddharthteotia for all the review comments so far. Let me work on this and revert with my comments as I start working on the changes.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-27T23:18:51.290+0000",
                    "updated": "2018-03-27T23:18:51.290+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16418166",
                    "id": "16418166",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-377045969\n \n \n   Hi @laurentgo, now I do have a handful of review comments to work on. As I work on each one of those, some may need short discussion with you. I hope that's okay. Thanks.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-28T21:38:17.213+0000",
                    "updated": "2018-03-28T21:38:17.213+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423015",
                    "id": "16423015",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178625435\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n+    private static final String custom_columns_query = \"select %s from %s limit %d offset %d\";\n+    private Connection connection;\n+    private String tableName;\n+\n+    /**\n+     * Constructor\n+     * @param connection\n+     * @param tableName\n+     */\n+    public ArrowDataFetcher(Connection connection, String tableName) {\n \n Review comment:\n   @laurentgo Can you elaborate it a bit - what do you mean by wrapping a ResultSet?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T19:21:39.012+0000",
                    "updated": "2018-04-02T19:21:39.012+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423019",
                    "id": "16423019",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178626181\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n \n Review comment:\n   Yes, this is true. I was aware of this and should have thought through before implementing this. What I am thinking here now is to come up with a Java enum for all the databases and maintain a map or constant string with (limit/offset) query specific to each database. This way I can support - ORACLE_12C,\tMYSQL,\tDB2,\tSQL_SERVER_2012,\tSQL_SERVER_2008,\tPOSTGRESQL,\tH2, \tSQLDB, \tINGRES,\tDERBY,  \tSQLITE,\tCUBRID,\tSYBASE_ASE,\tSYBASE_SQL_ANYWHERE,\tFIREBIRD.  But the only problem here is in writing test cases. What do you think about this approach and if this is okay, how we can go about testing the code for each database?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T19:25:04.015+0000",
                    "updated": "2018-04-02T19:25:04.015+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423021",
                    "id": "16423021",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178626181\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n \n Review comment:\n   Yes, this is true, my bad! I was aware of this and should have thought through before implementing this. What I am thinking here now is to come up with a Java enum for all the databases and maintain a map or constant string with (limit/offset) query specific to each database. This way I can support - ORACLE_12C,\tMYSQL,\tDB2,\tSQL_SERVER_2012,\tSQL_SERVER_2008,\tPOSTGRESQL,\tH2, \tSQLDB, \tINGRES,\tDERBY,  \tSQLITE,\tCUBRID,\tSYBASE_ASE,\tSYBASE_SQL_ANYWHERE,\tFIREBIRD.  But the only problem here is in writing test cases. What do you think about this approach and if this is okay, how we can go about testing the code for each database?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T19:25:38.089+0000",
                    "updated": "2018-04-02T19:25:38.089+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423029",
                    "id": "16423029",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178628383\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n+    private static final String custom_columns_query = \"select %s from %s limit %d offset %d\";\n+    private Connection connection;\n+    private String tableName;\n+\n+    /**\n+     * Constructor\n+     * @param connection\n+     * @param tableName\n+     */\n+    public ArrowDataFetcher(Connection connection, String tableName) {\n+        this.connection = connection;\n+        this.tableName = tableName;\n+    }\n+\n+    /**\n+     * Fetch the data from underlying table with the given limit and offset and for passed column names.\n+     *\n+     * @param offset\n+     * @param limit\n+     * @param columns\n+     * @return\n+     * @throws Exception\n+     */\n+    public VectorSchemaRoot fetch(int offset, int limit, String... columns) throws Exception {\n+        assert columns != null && columns.length > 0 : \"columns can't be empty!\";\n \n Review comment:\n   Do you want me to use any particular Preconditions API such Guava's com.google.common.base.Preconditions? As \"assert\" is doing pretty much the same thing except it throws AssertionError as opposed to IllegalArgumentException.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T19:35:03.512+0000",
                    "updated": "2018-04-02T19:35:03.512+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423035",
                    "id": "16423035",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178629345\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.*;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * @since 0.10.0\n+ * @see ArrowDataFetcher\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @return\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n+\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n+        assert query != null && query.length() > 0: \"SQL query can not be null or empty\";\n+\n+        RootAllocator rootAllocator = new RootAllocator(Integer.MAX_VALUE);\n \n Review comment:\n   Do you think it would be good to provide another overloaded API with RootAlocator as argument - \r\n   public static VectorSchemaRoot sqlToArrow(Connection connection, String query, RootAllocator)\r\n   or should I just modify the existing one?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T19:39:26.311+0000",
                    "updated": "2018-04-02T19:39:26.311+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423057",
                    "id": "16423057",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178635650\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n+    private static final String custom_columns_query = \"select %s from %s limit %d offset %d\";\n+    private Connection connection;\n+    private String tableName;\n+\n+    /**\n+     * Constructor\n+     * @param connection\n+     * @param tableName\n+     */\n+    public ArrowDataFetcher(Connection connection, String tableName) {\n \n Review comment:\n   My suggestion is to let the user do the query thing (get a connection, create the statement and execute it), and use the resulting {{ResultSet}} to do the Arrow conversation (and hopefully no need to deal with different dialects and other stuff)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T20:06:30.643+0000",
                    "updated": "2018-04-02T20:06:30.643+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423060",
                    "id": "16423060",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178635982\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.*;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * @since 0.10.0\n+ * @see ArrowDataFetcher\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @return\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n+\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n+        assert query != null && query.length() > 0: \"SQL query can not be null or empty\";\n+\n+        RootAllocator rootAllocator = new RootAllocator(Integer.MAX_VALUE);\n \n Review comment:\n   If there's no way to automatically free buffers/close the allocator, you probably want to modify the existing function to take one as an input.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T20:08:00.497+0000",
                    "updated": "2018-04-02T20:08:00.497+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423062",
                    "id": "16423062",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178636322\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n+    private static final String custom_columns_query = \"select %s from %s limit %d offset %d\";\n+    private Connection connection;\n+    private String tableName;\n+\n+    /**\n+     * Constructor\n+     * @param connection\n+     * @param tableName\n+     */\n+    public ArrowDataFetcher(Connection connection, String tableName) {\n+        this.connection = connection;\n+        this.tableName = tableName;\n+    }\n+\n+    /**\n+     * Fetch the data from underlying table with the given limit and offset and for passed column names.\n+     *\n+     * @param offset\n+     * @param limit\n+     * @param columns\n+     * @return\n+     * @throws Exception\n+     */\n+    public VectorSchemaRoot fetch(int offset, int limit, String... columns) throws Exception {\n+        assert columns != null && columns.length > 0 : \"columns can't be empty!\";\n \n Review comment:\n   Apart from the semantic difference (assertion are usually internal precondition of how the class behave, to help debugging), asserts are only turned on if enabled at the JDK level (using the -ea flag). Whereas preconditions are always checked.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T20:09:26.684+0000",
                    "updated": "2018-04-02T20:09:26.684+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423063",
                    "id": "16423063",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178636342\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n+    private static final String custom_columns_query = \"select %s from %s limit %d offset %d\";\n+    private Connection connection;\n+    private String tableName;\n+\n+    /**\n+     * Constructor\n+     * @param connection\n+     * @param tableName\n+     */\n+    public ArrowDataFetcher(Connection connection, String tableName) {\n \n Review comment:\n   Aah, okay, that makes sense. I think in that case, we don't even need to worry about various databases and also testing against each of those.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T20:09:28.993+0000",
                    "updated": "2018-04-02T20:09:28.993+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423125",
                    "id": "16423125",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178648346\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n+    private static final String custom_columns_query = \"select %s from %s limit %d offset %d\";\n+    private Connection connection;\n+    private String tableName;\n+\n+    /**\n+     * Constructor\n+     * @param connection\n+     * @param tableName\n+     */\n+    public ArrowDataFetcher(Connection connection, String tableName) {\n \n Review comment:\n   That's my belief too...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T20:56:58.353+0000",
                    "updated": "2018-04-02T20:56:58.353+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423141",
                    "id": "16423141",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178651658\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n+                        varcharVector.setIndexDefined(rowCount);\n+                        varcharVector.setValueLengthSafe(rowCount, value.length());\n+                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n+                        varcharVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DATE:\n+                        Date date = rs.getDate(i);\n+                        DateMilliVector dateMilliVector = (DateMilliVector) root.getVector(columnName);\n+                        dateMilliVector.setValueCount(rowCount + 1);\n+                        if (date != null) {\n+                            dateMilliVector.setSafe(rowCount, rs.getDate(i).getTime());\n+                        } else {\n+                            dateMilliVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.TIME:\n+                        Time time = rs.getTime(i);\n+                        TimeMilliVector timeMilliVector = (TimeMilliVector)root.getVector(columnName);\n+                        timeMilliVector.setValueCount(rowCount + 1);\n+                        if (time != null) {\n+                            timeMilliVector.setSafe(rowCount, (int) rs.getTime(i).getTime());\n+                        } else {\n+                            timeMilliVector.setNull(rowCount);\n+                        }\n+\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        // timezone is null\n+                        Timestamp timestamp = rs.getTimestamp(i);\n+                        TimeStampVector timeStampVector = (TimeStampVector)root.getVector(columnName);\n+                        timeStampVector.setValueCount(rowCount + 1);\n+                        if (timestamp != null) {\n+                            timeStampVector.setSafe(rowCount, timestamp.getTime());\n+                        } else {\n+                            timeStampVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        VarBinaryVector varBinaryVector = (VarBinaryVector)root.getVector(columnName);;\n+                        varBinaryVector.setValueCount(rowCount + 1);\n+                        byte[] bytes = rs.getBytes(i);\n+                        if (bytes != null) {\n+                            varBinaryVector.setIndexDefined(rowCount);\n+                            varBinaryVector.setValueLengthSafe(rowCount, bytes.length);\n+                            varBinaryVector.setSafe(rowCount, bytes);\n+                        } else {\n+                            varBinaryVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.ARRAY:\n+                        // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                        break;\n+                    case Types.CLOB:\n+                        VarCharVector varcharVector1 = (VarCharVector)root.getVector(columnName);\n+                        varcharVector1.setValueCount(rowCount + 1);\n+                        Clob clob = rs.getClob(i);\n+                        if (clob != null) {\n+                            int length = (int) clob.length();\n+                            varcharVector1.setIndexDefined(rowCount);\n+                            varcharVector1.setValueLengthSafe(rowCount, length);\n+                            varcharVector1.setSafe(rowCount, clob.getSubString(1, length).getBytes(), 0, length);\n \n Review comment:\n   What would be your suggestion for encoding? Should I take it as one of the API input parameters from the caller?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T21:10:30.262+0000",
                    "updated": "2018-04-02T21:10:30.262+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423149",
                    "id": "16423149",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178652242\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n+    private static final String custom_columns_query = \"select %s from %s limit %d offset %d\";\n+    private Connection connection;\n+    private String tableName;\n+\n+    /**\n+     * Constructor\n+     * @param connection\n+     * @param tableName\n+     */\n+    public ArrowDataFetcher(Connection connection, String tableName) {\n+        this.connection = connection;\n+        this.tableName = tableName;\n+    }\n+\n+    /**\n+     * Fetch the data from underlying table with the given limit and offset and for passed column names.\n+     *\n+     * @param offset\n+     * @param limit\n+     * @param columns\n+     * @return\n+     * @throws Exception\n+     */\n+    public VectorSchemaRoot fetch(int offset, int limit, String... columns) throws Exception {\n+        assert columns != null && columns.length > 0 : \"columns can't be empty!\";\n \n Review comment:\n   Yea, I here you!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T21:13:07.898+0000",
                    "updated": "2018-04-02T21:13:07.898+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16423151",
                    "id": "16423151",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178652817\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n+                        varcharVector.setIndexDefined(rowCount);\n+                        varcharVector.setValueLengthSafe(rowCount, value.length());\n+                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n+                        varcharVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DATE:\n+                        Date date = rs.getDate(i);\n+                        DateMilliVector dateMilliVector = (DateMilliVector) root.getVector(columnName);\n+                        dateMilliVector.setValueCount(rowCount + 1);\n+                        if (date != null) {\n+                            dateMilliVector.setSafe(rowCount, rs.getDate(i).getTime());\n+                        } else {\n+                            dateMilliVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.TIME:\n+                        Time time = rs.getTime(i);\n+                        TimeMilliVector timeMilliVector = (TimeMilliVector)root.getVector(columnName);\n+                        timeMilliVector.setValueCount(rowCount + 1);\n+                        if (time != null) {\n+                            timeMilliVector.setSafe(rowCount, (int) rs.getTime(i).getTime());\n+                        } else {\n+                            timeMilliVector.setNull(rowCount);\n+                        }\n+\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        // timezone is null\n+                        Timestamp timestamp = rs.getTimestamp(i);\n+                        TimeStampVector timeStampVector = (TimeStampVector)root.getVector(columnName);\n+                        timeStampVector.setValueCount(rowCount + 1);\n+                        if (timestamp != null) {\n+                            timeStampVector.setSafe(rowCount, timestamp.getTime());\n+                        } else {\n+                            timeStampVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        VarBinaryVector varBinaryVector = (VarBinaryVector)root.getVector(columnName);;\n+                        varBinaryVector.setValueCount(rowCount + 1);\n+                        byte[] bytes = rs.getBytes(i);\n+                        if (bytes != null) {\n+                            varBinaryVector.setIndexDefined(rowCount);\n+                            varBinaryVector.setValueLengthSafe(rowCount, bytes.length);\n+                            varBinaryVector.setSafe(rowCount, bytes);\n+                        } else {\n+                            varBinaryVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.ARRAY:\n+                        // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                        break;\n+                    case Types.CLOB:\n+                        VarCharVector varcharVector1 = (VarCharVector)root.getVector(columnName);\n+                        varcharVector1.setValueCount(rowCount + 1);\n+                        Clob clob = rs.getClob(i);\n+                        if (clob != null) {\n+                            int length = (int) clob.length();\n+                            varcharVector1.setIndexDefined(rowCount);\n+                            varcharVector1.setValueLengthSafe(rowCount, length);\n+                            varcharVector1.setSafe(rowCount, clob.getSubString(1, length).getBytes(), 0, length);\n \n Review comment:\n   UTF_8 is fine I think (since arrow varchar are UTF8 based). The issue is that getBytes() takes whatever the default encoding of the platform is...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-02T21:15:29.547+0000",
                    "updated": "2018-04-02T21:15:29.547+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424685",
                    "id": "16424685",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r178977178\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n \n Review comment:\n   In this case, Array type is ignored for the schema creation as well as Data creation. Let me spend some time on how I can model the Array data inside Arrow Vectors? Any clues?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-03T22:12:18.857+0000",
                    "updated": "2018-04-03T22:12:18.857+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424853",
                    "id": "16424853",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179009203\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/Table.java\n ##########\n @@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+/**\n+ *\n \n Review comment:\n   Will add a necessary comment.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T01:56:38.778+0000",
                    "updated": "2018-04-04T01:56:38.778+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424855",
                    "id": "16424855",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179009221\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.*;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * @since 0.10.0\n+ * @see ArrowDataFetcher\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @return\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n+\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n \n Review comment:\n   Sure, will fix this.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T01:56:50.817+0000",
                    "updated": "2018-04-04T01:56:50.817+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424861",
                    "id": "16424861",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179009426\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n \n Review comment:\n   For this, the control shouldn't reach here as the JDBC types are handled. Do you have any suggestion on how to handle this? Should I throw NotSupportedException or something?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T01:58:50.781+0000",
                    "updated": "2018-04-04T01:58:50.781+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424862",
                    "id": "16424862",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179009456\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n \n Review comment:\n   Yea, makes sense.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T01:59:10.541+0000",
                    "updated": "2018-04-04T01:59:10.541+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424865",
                    "id": "16424865",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179009588\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n \n Review comment:\n   In this case, which variable you are referring that can be 'null'. There are null checks before. Can you please elaborate?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T02:00:15.452+0000",
                    "updated": "2018-04-04T02:00:15.452+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424868",
                    "id": "16424868",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179009692\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n+                        varcharVector.setIndexDefined(rowCount);\n+                        varcharVector.setValueLengthSafe(rowCount, value.length());\n+                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n+                        varcharVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DATE:\n+                        Date date = rs.getDate(i);\n+                        DateMilliVector dateMilliVector = (DateMilliVector) root.getVector(columnName);\n+                        dateMilliVector.setValueCount(rowCount + 1);\n+                        if (date != null) {\n+                            dateMilliVector.setSafe(rowCount, rs.getDate(i).getTime());\n \n Review comment:\n   Yes, you are right. Let me think through on this and get back to you.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T02:01:27.093+0000",
                    "updated": "2018-04-04T02:01:27.093+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424870",
                    "id": "16424870",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179009787\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n \n Review comment:\n   I am not sure how I can set a null inside the VarCharVector. There is no API to set a NULL. Can you please suggest how this can be done?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T02:02:31.182+0000",
                    "updated": "2018-04-04T02:02:31.182+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424871",
                    "id": "16424871",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179009836\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n \n Review comment:\n   Can you please elaborate?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T02:02:53.451+0000",
                    "updated": "2018-04-04T02:02:53.451+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424872",
                    "id": "16424872",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179009875\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n+                        varcharVector.setIndexDefined(rowCount);\n+                        varcharVector.setValueLengthSafe(rowCount, value.length());\n+                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n+                        varcharVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DATE:\n+                        Date date = rs.getDate(i);\n+                        DateMilliVector dateMilliVector = (DateMilliVector) root.getVector(columnName);\n+                        dateMilliVector.setValueCount(rowCount + 1);\n+                        if (date != null) {\n+                            dateMilliVector.setSafe(rowCount, rs.getDate(i).getTime());\n+                        } else {\n+                            dateMilliVector.setNull(rowCount);\n+                        }\n+                        break;\n+                    case Types.TIME:\n+                        Time time = rs.getTime(i);\n+                        TimeMilliVector timeMilliVector = (TimeMilliVector)root.getVector(columnName);\n+                        timeMilliVector.setValueCount(rowCount + 1);\n+                        if (time != null) {\n+                            timeMilliVector.setSafe(rowCount, (int) rs.getTime(i).getTime());\n+                        } else {\n+                            timeMilliVector.setNull(rowCount);\n+                        }\n+\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        // timezone is null\n \n Review comment:\n   Yes, I agree this needs to be handled. I will give some more thought.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T02:03:15.740+0000",
                    "updated": "2018-04-04T02:03:15.740+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424903",
                    "id": "16424903",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-378461698\n \n \n   Hi @laurentgo  and @siddharthteotia I am still working on some of the code review changes. I have checked-in some code fixes. I will let you know once I am done with all the changes or if I need to have some discussion with you. Thanks.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T02:38:10.679+0000",
                    "updated": "2018-04-04T02:38:10.679+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424917",
                    "id": "16424917",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179015269\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/Table.java\n ##########\n @@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+/**\n+ *\n \n Review comment:\n   Added relevant doc comment.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T02:55:24.443+0000",
                    "updated": "2018-04-04T02:55:24.443+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424918",
                    "id": "16424918",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179015325\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.*;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * @since 0.10.0\n+ * @see ArrowDataFetcher\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @return\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n+\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n \n Review comment:\n   Fixed. Also changed this to use Preconditions.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T02:56:05.833+0000",
                    "updated": "2018-04-04T02:56:05.833+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424919",
                    "id": "16424919",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179015351\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n+    private static final String custom_columns_query = \"select %s from %s limit %d offset %d\";\n+    private Connection connection;\n+    private String tableName;\n+\n+    /**\n+     * Constructor\n+     * @param connection\n+     * @param tableName\n+     */\n+    public ArrowDataFetcher(Connection connection, String tableName) {\n+        this.connection = connection;\n+        this.tableName = tableName;\n+    }\n+\n+    /**\n+     * Fetch the data from underlying table with the given limit and offset and for passed column names.\n+     *\n+     * @param offset\n+     * @param limit\n+     * @param columns\n+     * @return\n+     * @throws Exception\n+     */\n+    public VectorSchemaRoot fetch(int offset, int limit, String... columns) throws Exception {\n \n Review comment:\n   Fixed.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T02:56:17.307+0000",
                    "updated": "2018-04-04T02:56:17.307+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424921",
                    "id": "16424921",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179015368\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/ArrowDataFetcher.java\n ##########\n @@ -0,0 +1,107 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.Connection;\n+\n+/**\n+ * Class to fetch data from a given database table where user can specify columns to fetch\n+ * along with limit and offset parameters.\n+ *\n+ * The object of this class is returned by invoking method jdbcArrowDataFetcher(Connection connection, String tableName)\n+ * from {@link JdbcToArrow} class. Caller can use this object to fetch data repetitively based on the\n+ * data fetch requirement and can implement pagination like functionality.\n+ *\n+ * This class doesn't hold any open connections to database but simply executes the \"select\" query everytime with\n+ * the necessary limit and offset parameters.\n+ *\n+ * @since 0.10.0\n+ * @see JdbcToArrow\n+ */\n+public class ArrowDataFetcher {\n+\n+    private static final String all_columns_query = \"select * from %s limit %d offset %d\";\n+    private static final String custom_columns_query = \"select %s from %s limit %d offset %d\";\n+    private Connection connection;\n+    private String tableName;\n+\n+    /**\n+     * Constructor\n+     * @param connection\n+     * @param tableName\n+     */\n+    public ArrowDataFetcher(Connection connection, String tableName) {\n+        this.connection = connection;\n+        this.tableName = tableName;\n+    }\n+\n+    /**\n+     * Fetch the data from underlying table with the given limit and offset and for passed column names.\n+     *\n+     * @param offset\n+     * @param limit\n+     * @param columns\n+     * @return\n+     * @throws Exception\n+     */\n+    public VectorSchemaRoot fetch(int offset, int limit, String... columns) throws Exception {\n+        assert columns != null && columns.length > 0 : \"columns can't be empty!\";\n \n Review comment:\n   Fixed.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T02:56:29.963+0000",
                    "updated": "2018-04-04T02:56:29.963+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424922",
                    "id": "16424922",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179015396\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.*;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * @since 0.10.0\n+ * @see ArrowDataFetcher\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @return\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n+\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n+        assert query != null && query.length() > 0: \"SQL query can not be null or empty\";\n+\n+        RootAllocator rootAllocator = new RootAllocator(Integer.MAX_VALUE);\n \n Review comment:\n   Fixed.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T02:56:41.942+0000",
                    "updated": "2018-04-04T02:56:41.942+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16424924",
                    "id": "16424924",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r179015462\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.memory.RootAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+\n+import java.sql.*;\n+\n+/**\n+ * Utility class to convert JDBC objects to columnar Arrow format objects.\n+ *\n+ * This utility uses following data mapping to map JDBC/SQL datatype to Arrow data types.\n+ *\n+ * CHAR\t--> ArrowType.Utf8\n+ * NCHAR\t--> ArrowType.Utf8\n+ * VARCHAR --> ArrowType.Utf8\n+ * NVARCHAR --> ArrowType.Utf8\n+ * LONGVARCHAR --> ArrowType.Utf8\n+ * LONGNVARCHAR --> ArrowType.Utf8\n+ * NUMERIC --> ArrowType.Decimal(precision, scale)\n+ * DECIMAL --> ArrowType.Decimal(precision, scale)\n+ * BIT --> ArrowType.Bool\n+ * TINYINT --> ArrowType.Int(8, signed)\n+ * SMALLINT --> ArrowType.Int(16, signed)\n+ * INTEGER --> ArrowType.Int(32, signed)\n+ * BIGINT --> ArrowType.Int(64, signed)\n+ * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+ * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+ * BINARY --> ArrowType.Binary\n+ * VARBINARY --> ArrowType.Binary\n+ * LONGVARBINARY --> ArrowType.Binary\n+ * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+ * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+ * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+ * CLOB --> ArrowType.Utf8\n+ * BLOB --> ArrowType.Binary\n+ *\n+ * @since 0.10.0\n+ * @see ArrowDataFetcher\n+ */\n+public class JdbcToArrow {\n+\n+    /**\n+     * For the given SQL query, execute and fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n+     *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n+     * @param query The DB Query to fetch the data.\n+     * @return\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     */\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n+\n+        assert connection != null: \"JDBC conncetion object can not be null\";\n+        assert query != null && query.length() > 0: \"SQL query can not be null or empty\";\n+\n+        RootAllocator rootAllocator = new RootAllocator(Integer.MAX_VALUE);\n+\n+        Statement stmt = null;\n \n Review comment:\n   Fixed.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T02:57:38.660+0000",
                    "updated": "2018-04-04T02:57:38.660+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16428410",
                    "id": "16428410",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "donderom commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-379276243\n \n \n   As I understand the idea is to convert `java.sql.ResultSet` to Arrow. The result set can be provided by 3-party lib what will make `sqlToArrow(Connection connection, String query)` API not usable. What about something like `sqlToArrow(ResultSet resultSet)`?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-06T14:47:14.415+0000",
                    "updated": "2018-04-06T14:47:14.415+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16428685",
                    "id": "16428685",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-379330225\n \n \n   @donderom I recently did that change based on some earlier comments from @laurentgo  I have added that as another interface. So we are good!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-06T17:59:47.667+0000",
                    "updated": "2018-04-06T17:59:47.667+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16431015",
                    "id": "16431015",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180185358\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n+                        varcharVector.setIndexDefined(rowCount);\n+                        varcharVector.setValueLengthSafe(rowCount, value.length());\n+                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n+                        varcharVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DATE:\n+                        Date date = rs.getDate(i);\n+                        DateMilliVector dateMilliVector = (DateMilliVector) root.getVector(columnName);\n+                        dateMilliVector.setValueCount(rowCount + 1);\n+                        if (date != null) {\n+                            dateMilliVector.setSafe(rowCount, rs.getDate(i).getTime());\n \n Review comment:\n   Hi @laurentgo Would you have some time to discuss the TimeZone issue. I gave some more thought on this and I am not entirely sure how to really handle issues surrounding this. As we have no control over the TimeZone setting for the running JVM and also the underlying Database. Is there a way I can reach you over the phone? I am based out of Cupertino, Bay Area, CA - 650 797 8289.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-09T18:20:21.757+0000",
                    "updated": "2018-04-09T18:20:21.757+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16431103",
                    "id": "16431103",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180205035\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws Exception {\n+\n+        assert rs != null;\n+        assert root != null;\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        BitVector bitVector = (BitVector) root.getVector(columnName);\n+                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n+                        bitVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.TINYINT:\n+                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n+                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n+                        tinyIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.SMALLINT:\n+                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n+                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n+                        smallIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.INTEGER:\n+                        IntVector intVector = (IntVector)root.getVector(columnName);\n+                        intVector.setSafe(rowCount, rs.getInt(i));\n+                        intVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.BIGINT:\n+                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n+                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n+                        bigIntVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n+                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n+                        decimalVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n+                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n+                        float4Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DOUBLE:\n+                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n+                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n+                        float8Vector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n+                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n+                        varcharVector.setIndexDefined(rowCount);\n+                        varcharVector.setValueLengthSafe(rowCount, value.length());\n+                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n+                        varcharVector.setValueCount(rowCount + 1);\n+                        break;\n+                    case Types.DATE:\n+                        Date date = rs.getDate(i);\n+                        DateMilliVector dateMilliVector = (DateMilliVector) root.getVector(columnName);\n+                        dateMilliVector.setValueCount(rowCount + 1);\n+                        if (date != null) {\n+                            dateMilliVector.setSafe(rowCount, rs.getDate(i).getTime());\n \n Review comment:\n   At this time, I am inclined to just have user provide another parameter such as Calendar so that we can handle the Timezone specific nuances. Many databases don't really consider and handle timezones, daylight savings time and rule changes correctly. Also, it's upto the user to insert the correct values based on the timezone or time related rules. So, what is your opinion on having one additional parameter such as Calendar from end caller?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-09T19:33:14.102+0000",
                    "updated": "2018-04-09T19:33:14.102+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434155",
                    "id": "16434155",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180249672\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrow.java\n ##########\n @@ -64,53 +68,48 @@\n      * @param connection Database connection to be used. This method will not close the passed connection object. Since hte caller has passed\n      *                   the connection object it's the responsibility of the caller to close or return the connection to the pool.\n      * @param query The DB Query to fetch the data.\n-     * @return\n-     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statment objects.\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws SQLException Propagate any SQL Exceptions to the caller after closing any resources opened such as ResultSet and Statement objects.\n      */\n-    public static VectorSchemaRoot sqlToArrow(Connection connection, String query) throws Exception {\n-\n-        assert connection != null: \"JDBC conncetion object can not be null\";\n-        assert query != null && query.length() > 0: \"SQL query can not be null or empty\";\n-\n-        RootAllocator rootAllocator = new RootAllocator(Integer.MAX_VALUE);\n+    public static VectorSchemaRoot sqlToArrow(Connection connection, String query, RootAllocator rootAllocator) throws SQLException {\n+        Preconditions.checkNotNull(connection, \"JDBC connection object can not be null\");\n+        Preconditions.checkArgument(query != null && query.length() > 0, \"SQL query can not be null or empty\");\n \n-        Statement stmt = null;\n-        ResultSet rs = null;\n-        try {\n-            stmt = connection.createStatement();\n-            rs = stmt.executeQuery(query);\n-            ResultSetMetaData rsmd = rs.getMetaData();\n-            VectorSchemaRoot root = VectorSchemaRoot.create(\n-                    JdbcToArrowUtils.jdbcToArrowSchema(rsmd), rootAllocator);\n-            JdbcToArrowUtils.jdbcToArrowVectors(rs, root);\n-            return root;\n-        } catch (Exception exc) {\n-            // just throw it out after logging\n-            throw exc;\n-        } finally {\n-            if (rs != null) {\n-                rs.close();\n-            }\n-            if (stmt != null) {\n-                stmt.close(); // test\n-            }\n+        try (Statement stmt = connection.createStatement()) {\n+            return sqlToArrow(stmt.executeQuery(query), rootAllocator);\n         }\n     }\n \n     /**\n-     * This method returns ArrowDataFetcher Object that can be used to fetch and iterate on the data in the given\n-     * database table.\n-     *\n-     * @param connection - Database connection Object\n-     * @param tableName - Table name from which records will be fetched\n+     * For the given JDBC {@link ResultSet}, fetch the data from Relational DB and convert it to Arrow objects.\n      *\n-     * @return ArrowDataFetcher - Instance of ArrowDataFetcher which can be used to get Arrow Vector obejcts by calling its functionality\n+     * @param resultSet\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws Exception\n      */\n-    public static ArrowDataFetcher jdbcArrowDataFetcher(Connection connection, String tableName) {\n-        assert connection != null: \"JDBC conncetion object can not be null\";\n-        assert tableName != null && tableName.length() > 0: \"Table name can not be null or empty\";\n+    public static VectorSchemaRoot sqlToArrow(ResultSet resultSet) throws SQLException {\n+        Preconditions.checkNotNull(resultSet, \"JDBC ResultSet object can not be null\");\n \n-        return new ArrowDataFetcher(connection, tableName);\n+        RootAllocator rootAllocator = new RootAllocator(Integer.MAX_VALUE);\n+        VectorSchemaRoot root = sqlToArrow(resultSet, rootAllocator);\n+        rootAllocator.close();\n+        return root;\n     }\n \n+    /**\n+     * For the given JDBC {@link ResultSet}, fetch the data from Relational DB and convert it to Arrow objects.\n+     *\n+     * @param resultSet\n+     * @return Arrow Data Objects {@link VectorSchemaRoot}\n+     * @throws Exception\n+     */\n+    public static VectorSchemaRoot sqlToArrow(ResultSet resultSet, RootAllocator rootAllocator) throws SQLException {\n \n Review comment:\n   I know I mentioned RootAllocator, but I guess BufferAllocator (which is the base interface) would work as well?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:20.736+0000",
                    "updated": "2018-04-11T16:31:20.736+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434156",
                    "id": "16434156",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180252798\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,343 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import org.apache.arrow.vector.*;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.nio.charset.Charset;\n+import java.sql.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        assert rsmd != null;\n+\n+//        ImmutableList.Builder<Field> fields = ImmutableList.builder();\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // timezone is null\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // not handled\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n \n Review comment:\n   the tricky part would be to get the actual subtype of the array, but that information doesn't seem to be accessible by just looking at metadata unfortunately. Since that would be the same for Struct, I would put everything under the \"default\" bucket, and maybe not do a no-op but throwing an `UnsupportedOperationException()`...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:20.836+0000",
                    "updated": "2018-04-11T16:31:20.836+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434157",
                    "id": "16434157",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180249387\n \n \n\n ##########\n File path: java/adapter/jdbc/pom.xml\n ##########\n @@ -62,10 +68,11 @@\n             <version>2.7.9</version>\n             <scope>test</scope>\n         </dependency>\n+        <!-- https://mvnrepository.com/artifact/com.google.collections/google-collections -->\n         <dependency>\n-            <groupId>com.google.guava</groupId>\n-            <artifactId>guava</artifactId>\n-            <version>18.0</version>\n+            <groupId>com.google.collections</groupId>\n \n Review comment:\n   isn't that deprecated in favor of guava? (last update is 2009...)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.106+0000",
                    "updated": "2018-04-11T16:31:21.106+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434158",
                    "id": "16434158",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180810672\n \n \n\n ##########\n File path: java/adapter/jdbc/pom.xml\n ##########\n @@ -0,0 +1,95 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor\n+  license agreements. See the NOTICE file distributed with this work for additional\n+  information regarding copyright ownership. The ASF licenses this file to\n+  You under the Apache License, Version 2.0 (the \"License\"); you may not use\n+  this file except in compliance with the License. You may obtain a copy of\n+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required\n+  by applicable law or agreed to in writing, software distributed under the\n+  License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n+  OF ANY KIND, either express or implied. See the License for the specific\n+  language governing permissions and limitations under the License. -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>org.apache.arrow</groupId>\n+        <artifactId>arrow-java-root</artifactId>\n+        <version>0.10.0-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>arrow-jdbc</artifactId>\n+    <name>Arrow JDBC Adapter</name>\n+    <url>http://maven.apache.org</url>\n+    <dependencies>\n+\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-memory -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-memory</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-vector -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-vector</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.google.guava</groupId>\n+            <artifactId>guava</artifactId>\n+            <version>18.0</version>\n \n Review comment:\n   replace with ${dep.guava.version}\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.198+0000",
                    "updated": "2018-04-11T16:31:21.198+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434159",
                    "id": "16434159",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180811074\n \n \n\n ##########\n File path: java/adapter/jdbc/pom.xml\n ##########\n @@ -0,0 +1,95 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor\n+  license agreements. See the NOTICE file distributed with this work for additional\n+  information regarding copyright ownership. The ASF licenses this file to\n+  You under the Apache License, Version 2.0 (the \"License\"); you may not use\n+  this file except in compliance with the License. You may obtain a copy of\n+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required\n+  by applicable law or agreed to in writing, software distributed under the\n+  License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n+  OF ANY KIND, either express or implied. See the License for the specific\n+  language governing permissions and limitations under the License. -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>org.apache.arrow</groupId>\n+        <artifactId>arrow-java-root</artifactId>\n+        <version>0.10.0-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>arrow-jdbc</artifactId>\n+    <name>Arrow JDBC Adapter</name>\n+    <url>http://maven.apache.org</url>\n+    <dependencies>\n+\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-memory -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-memory</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-vector -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-vector</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.google.guava</groupId>\n+            <artifactId>guava</artifactId>\n+            <version>18.0</version>\n+        </dependency>\n+\n+\n+        <!-- Test -->\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.11</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <!-- https://mvnrepository.com/artifact/com.h2database/h2 -->\n+        <dependency>\n+            <groupId>com.h2database</groupId>\n+            <artifactId>h2</artifactId>\n+            <version>1.4.196</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.dataformat</groupId>\n+            <artifactId>jackson-dataformat-yaml</artifactId>\n+            <version>2.7.9</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.core</groupId>\n+            <artifactId>jackson-databind</artifactId>\n+            <version>2.7.9</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <!-- https://mvnrepository.com/artifact/com.google.collections/google-collections -->\n+        <dependency>\n+            <groupId>com.google.collections</groupId>\n \n Review comment:\n   That seems like a legacy library, before Guava was created...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.264+0000",
                    "updated": "2018-04-11T16:31:21.264+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434160",
                    "id": "16434160",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180810807\n \n \n\n ##########\n File path: java/adapter/jdbc/pom.xml\n ##########\n @@ -0,0 +1,95 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor\n+  license agreements. See the NOTICE file distributed with this work for additional\n+  information regarding copyright ownership. The ASF licenses this file to\n+  You under the Apache License, Version 2.0 (the \"License\"); you may not use\n+  this file except in compliance with the License. You may obtain a copy of\n+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required\n+  by applicable law or agreed to in writing, software distributed under the\n+  License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n+  OF ANY KIND, either express or implied. See the License for the specific\n+  language governing permissions and limitations under the License. -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>org.apache.arrow</groupId>\n+        <artifactId>arrow-java-root</artifactId>\n+        <version>0.10.0-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>arrow-jdbc</artifactId>\n+    <name>Arrow JDBC Adapter</name>\n+    <url>http://maven.apache.org</url>\n+    <dependencies>\n+\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-memory -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-memory</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-vector -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-vector</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.google.guava</groupId>\n+            <artifactId>guava</artifactId>\n+            <version>18.0</version>\n+        </dependency>\n+\n+\n+        <!-- Test -->\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.11</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <!-- https://mvnrepository.com/artifact/com.h2database/h2 -->\n+        <dependency>\n+            <groupId>com.h2database</groupId>\n+            <artifactId>h2</artifactId>\n+            <version>1.4.196</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.dataformat</groupId>\n+            <artifactId>jackson-dataformat-yaml</artifactId>\n+            <version>2.7.9</version>\n \n Review comment:\n   replace with ${dep.jackson.version}\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.285+0000",
                    "updated": "2018-04-11T16:31:21.285+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434161",
                    "id": "16434161",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180253135\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -200,144 +226,206 @@ public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throw\n                 switch (rsmd.getColumnType(i)) {\n                     case Types.BOOLEAN:\n                     case Types.BIT:\n-                        BitVector bitVector = (BitVector) root.getVector(columnName);\n-                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n-                        bitVector.setValueCount(rowCount + 1);\n+                        updateVector((BitVector)root.getVector(columnName),\n+                                rs.getBoolean(i), rowCount);\n                         break;\n                     case Types.TINYINT:\n-                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n-                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n-                        tinyIntVector.setValueCount(rowCount + 1);\n+                        updateVector((TinyIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n                         break;\n                     case Types.SMALLINT:\n-                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n-                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n-                        smallIntVector.setValueCount(rowCount + 1);\n+                        updateVector((SmallIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n                         break;\n                     case Types.INTEGER:\n-                        IntVector intVector = (IntVector)root.getVector(columnName);\n-                        intVector.setSafe(rowCount, rs.getInt(i));\n-                        intVector.setValueCount(rowCount + 1);\n+                        updateVector((IntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n                         break;\n                     case Types.BIGINT:\n-                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n-                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n-                        bigIntVector.setValueCount(rowCount + 1);\n+                        updateVector((BigIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n \n Review comment:\n   if bigint is a 64bits integer, it should probably use rs.getLong() (maybe have unit tests with large values, both positive and negative?)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.329+0000",
                    "updated": "2018-04-11T16:31:21.329+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434162",
                    "id": "16434162",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180253328\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -200,144 +226,206 @@ public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throw\n                 switch (rsmd.getColumnType(i)) {\n                     case Types.BOOLEAN:\n                     case Types.BIT:\n-                        BitVector bitVector = (BitVector) root.getVector(columnName);\n-                        bitVector.setSafe(rowCount, rs.getBoolean(i)? 1: 0);\n-                        bitVector.setValueCount(rowCount + 1);\n+                        updateVector((BitVector)root.getVector(columnName),\n+                                rs.getBoolean(i), rowCount);\n                         break;\n                     case Types.TINYINT:\n-                        TinyIntVector tinyIntVector = (TinyIntVector)root.getVector(columnName);\n-                        tinyIntVector.setSafe(rowCount, rs.getInt(i));\n-                        tinyIntVector.setValueCount(rowCount + 1);\n+                        updateVector((TinyIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n                         break;\n                     case Types.SMALLINT:\n-                        SmallIntVector smallIntVector = (SmallIntVector)root.getVector(columnName);\n-                        smallIntVector.setSafe(rowCount, rs.getInt(i));\n-                        smallIntVector.setValueCount(rowCount + 1);\n+                        updateVector((SmallIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n                         break;\n                     case Types.INTEGER:\n-                        IntVector intVector = (IntVector)root.getVector(columnName);\n-                        intVector.setSafe(rowCount, rs.getInt(i));\n-                        intVector.setValueCount(rowCount + 1);\n+                        updateVector((IntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n                         break;\n                     case Types.BIGINT:\n-                        BigIntVector bigIntVector = (BigIntVector)root.getVector(columnName);\n-                        bigIntVector.setSafe(rowCount, rs.getInt(i));\n-                        bigIntVector.setValueCount(rowCount + 1);\n+                        updateVector((BigIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n                         break;\n                     case Types.NUMERIC:\n                     case Types.DECIMAL:\n-                        DecimalVector decimalVector = (DecimalVector)root.getVector(columnName);\n-                        decimalVector.setSafe(rowCount, rs.getBigDecimal(i));\n-                        decimalVector.setValueCount(rowCount + 1);\n+                        updateVector((DecimalVector)root.getVector(columnName),\n+                                rs.getBigDecimal(i), rowCount);\n                         break;\n                     case Types.REAL:\n                     case Types.FLOAT:\n-                        Float4Vector float4Vector = (Float4Vector)root.getVector(columnName);\n-                        float4Vector.setSafe(rowCount, rs.getFloat(i));\n-                        float4Vector.setValueCount(rowCount + 1);\n+                        updateVector((Float4Vector)root.getVector(columnName),\n+                                rs.getFloat(i), rowCount);\n                         break;\n                     case Types.DOUBLE:\n-                        Float8Vector float8Vector = (Float8Vector)root.getVector(columnName);\n-                        float8Vector.setSafe(rowCount, rs.getDouble(i));\n-                        float8Vector.setValueCount(rowCount + 1);\n+                        updateVector((Float8Vector)root.getVector(columnName),\n+                                rs.getDouble(i), rowCount);\n                         break;\n                     case Types.CHAR:\n                     case Types.NCHAR:\n                     case Types.VARCHAR:\n                     case Types.NVARCHAR:\n                     case Types.LONGVARCHAR:\n                     case Types.LONGNVARCHAR:\n-                        VarCharVector varcharVector = (VarCharVector)root.getVector(columnName);\n-                        String value = rs.getString(i) != null ? rs.getString(i) : \"\";\n-                        varcharVector.setIndexDefined(rowCount);\n-                        varcharVector.setValueLengthSafe(rowCount, value.length());\n-                        varcharVector.setSafe(rowCount, value.getBytes(Charset.forName(\"UTF-8\")), 0, value.length());\n-                        varcharVector.setValueCount(rowCount + 1);\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                                rs.getString(i), rowCount);\n                         break;\n                     case Types.DATE:\n-                        Date date = rs.getDate(i);\n-                        DateMilliVector dateMilliVector = (DateMilliVector) root.getVector(columnName);\n-                        dateMilliVector.setValueCount(rowCount + 1);\n-                        if (date != null) {\n-                            dateMilliVector.setSafe(rowCount, rs.getDate(i).getTime());\n-                        } else {\n-                            dateMilliVector.setNull(rowCount);\n-                        }\n+                        updateVector((DateMilliVector) root.getVector(columnName),\n+                                rs.getDate(i), rowCount);\n                         break;\n                     case Types.TIME:\n-                        Time time = rs.getTime(i);\n-                        TimeMilliVector timeMilliVector = (TimeMilliVector)root.getVector(columnName);\n-                        timeMilliVector.setValueCount(rowCount + 1);\n-                        if (time != null) {\n-                            timeMilliVector.setSafe(rowCount, (int) rs.getTime(i).getTime());\n-                        } else {\n-                            timeMilliVector.setNull(rowCount);\n-                        }\n-\n+                        updateVector((TimeMilliVector) root.getVector(columnName),\n+                                rs.getTime(i), rowCount);\n                         break;\n                     case Types.TIMESTAMP:\n-                        // timezone is null\n-                        Timestamp timestamp = rs.getTimestamp(i);\n-                        TimeStampVector timeStampVector = (TimeStampVector)root.getVector(columnName);\n-                        timeStampVector.setValueCount(rowCount + 1);\n-                        if (timestamp != null) {\n-                            timeStampVector.setSafe(rowCount, timestamp.getTime());\n-                        } else {\n-                            timeStampVector.setNull(rowCount);\n-                        }\n+                        updateVector((TimeStampVector)root.getVector(columnName),\n+                                rs.getTimestamp(i), rowCount);\n                         break;\n                     case Types.BINARY:\n                     case Types.VARBINARY:\n                     case Types.LONGVARBINARY:\n-                        VarBinaryVector varBinaryVector = (VarBinaryVector)root.getVector(columnName);;\n-                        varBinaryVector.setValueCount(rowCount + 1);\n-                        byte[] bytes = rs.getBytes(i);\n-                        if (bytes != null) {\n-                            varBinaryVector.setIndexDefined(rowCount);\n-                            varBinaryVector.setValueLengthSafe(rowCount, bytes.length);\n-                            varBinaryVector.setSafe(rowCount, bytes);\n-                        } else {\n-                            varBinaryVector.setNull(rowCount);\n-                        }\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                                rs.getBytes(i), rowCount);\n                         break;\n                     case Types.ARRAY:\n-                        // not handled\n+                        // TODO Need to handle this type\n //                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n                         break;\n                     case Types.CLOB:\n-                        VarCharVector varcharVector1 = (VarCharVector)root.getVector(columnName);\n-                        varcharVector1.setValueCount(rowCount + 1);\n-                        Clob clob = rs.getClob(i);\n-                        if (clob != null) {\n-                            int length = (int) clob.length();\n-                            varcharVector1.setIndexDefined(rowCount);\n-                            varcharVector1.setValueLengthSafe(rowCount, length);\n-                            varcharVector1.setSafe(rowCount, clob.getSubString(1, length).getBytes(), 0, length);\n-                        } else {\n-                            varcharVector1.setNull(rowCount);\n-                        }\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                            rs.getClob(i), rowCount);\n                         break;\n                     case Types.BLOB:\n-                        VarBinaryVector varBinaryVector1 = (VarBinaryVector)root.getVector(columnName);;\n-                        varBinaryVector1.setValueCount(rowCount + 1);\n-                        Blob blob = rs.getBlob(i);\n-                        if (blob != null) {\n-                            byte[] data = blob.getBytes(0, (int) blob.length());\n-                            varBinaryVector1.setIndexDefined(rowCount);\n-                            varBinaryVector1.setValueLengthSafe(rowCount, (int) blob.length());\n-                            varBinaryVector1.setSafe(rowCount, data);\n-                        } else {\n-                            varBinaryVector1.setNull(rowCount);}\n-\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                            rs.getBlob(i), rowCount);\n                         break;\n \n                     default:\n-                        // no-op\n+                        // no-op, shouldn't get here\n                         break;\n                 }\n             }\n             rowCount++;\n         }\n         root.setRowCount(rowCount);\n     }\n+\n+    private static void updateVector(BitVector bitVector, boolean value, int rowCount) {\n+        bitVector.setSafe(rowCount, value? 1: 0);\n+        bitVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(TinyIntVector tinyIntVector, int value, int rowCount) {\n+        tinyIntVector.setSafe(rowCount, value);\n+        tinyIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(SmallIntVector smallIntVector, int value, int rowCount) {\n+        smallIntVector.setSafe(rowCount, value);\n+        smallIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(IntVector intVector, int value, int rowCount) {\n+        intVector.setSafe(rowCount, value);\n+        intVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(BigIntVector bigIntVector, int value, int rowCount) {\n \n Review comment:\n   value should be a `long`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.386+0000",
                    "updated": "2018-04-11T16:31:21.386+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434163",
                    "id": "16434163",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180811190\n \n \n\n ##########\n File path: java/adapter/jdbc/pom.xml\n ##########\n @@ -0,0 +1,95 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor\n+  license agreements. See the NOTICE file distributed with this work for additional\n+  information regarding copyright ownership. The ASF licenses this file to\n+  You under the Apache License, Version 2.0 (the \"License\"); you may not use\n+  this file except in compliance with the License. You may obtain a copy of\n+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required\n+  by applicable law or agreed to in writing, software distributed under the\n+  License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n+  OF ANY KIND, either express or implied. See the License for the specific\n+  language governing permissions and limitations under the License. -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>org.apache.arrow</groupId>\n+        <artifactId>arrow-java-root</artifactId>\n+        <version>0.10.0-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>arrow-jdbc</artifactId>\n+    <name>Arrow JDBC Adapter</name>\n+    <url>http://maven.apache.org</url>\n+    <dependencies>\n+\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-memory -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-memory</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-vector -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-vector</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.google.guava</groupId>\n+            <artifactId>guava</artifactId>\n+            <version>18.0</version>\n+        </dependency>\n+\n+\n+        <!-- Test -->\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.11</version>\n \n Review comment:\n   replace with ${dep.junit.version}\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.473+0000",
                    "updated": "2018-04-11T16:31:21.473+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434164",
                    "id": "16434164",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180818360\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/AbstractJdbcToArrowTest.java\n ##########\n @@ -0,0 +1,66 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.Statement;\n+\n+/**\n+ * Class to abstract out some common test functionality for testing JDBC to Arrow.\n+ */\n+public abstract class AbstractJdbcToArrowTest {\n+\n+    protected void createTestData(Connection conn, Table table) throws Exception {\n+\n+        Statement stmt = null;\n+        try {\n+            //create the table and insert the data and once done drop the table\n+            stmt = conn.createStatement();\n+            stmt.executeUpdate(table.getCreate());\n+\n+            for (String insert: table.getData()) {\n+                stmt.executeUpdate(insert);\n+            }\n+\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        } finally {\n \n Review comment:\n   you should use `try(with-resources)` construct instead...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.495+0000",
                    "updated": "2018-04-11T16:31:21.495+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434165",
                    "id": "16434165",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180815032\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,431 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.math.BigDecimal;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        Preconditions.checkNotNull(rsmd, \"JDBC ResultSetMetaData object can't be null\");\n+\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // TODO Need to handle timezone\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // TODO Need to handle this type\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op, shouldn't get here\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws SQLException {\n+\n+        Preconditions.checkNotNull(rs, \"JDBC ResultSet object can't be null\");\n+        Preconditions.checkNotNull(root, \"JDBC ResultSet object can't be null\");\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        updateVector((BitVector)root.getVector(columnName),\n+                                rs.getBoolean(i), rowCount);\n+                        break;\n+                    case Types.TINYINT:\n+                        updateVector((TinyIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.SMALLINT:\n+                        updateVector((SmallIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.INTEGER:\n+                        updateVector((IntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.BIGINT:\n+                        updateVector((BigIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        updateVector((DecimalVector)root.getVector(columnName),\n+                                rs.getBigDecimal(i), rowCount);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        updateVector((Float4Vector)root.getVector(columnName),\n+                                rs.getFloat(i), rowCount);\n+                        break;\n+                    case Types.DOUBLE:\n+                        updateVector((Float8Vector)root.getVector(columnName),\n+                                rs.getDouble(i), rowCount);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                                rs.getString(i), rowCount);\n+                        break;\n+                    case Types.DATE:\n+                        updateVector((DateMilliVector) root.getVector(columnName),\n+                                rs.getDate(i), rowCount);\n+                        break;\n+                    case Types.TIME:\n+                        updateVector((TimeMilliVector) root.getVector(columnName),\n+                                rs.getTime(i), rowCount);\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        updateVector((TimeStampVector)root.getVector(columnName),\n+                                rs.getTimestamp(i), rowCount);\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                                rs.getBytes(i), rowCount);\n+                        break;\n+                    case Types.ARRAY:\n+                        // TODO Need to handle this type\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                        break;\n+                    case Types.CLOB:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                            rs.getClob(i), rowCount);\n+                        break;\n+                    case Types.BLOB:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                            rs.getBlob(i), rowCount);\n+                        break;\n+\n+                    default:\n+                        // no-op, shouldn't get here\n+                        break;\n+                }\n+            }\n+            rowCount++;\n+        }\n+        root.setRowCount(rowCount);\n+    }\n+\n+    private static void updateVector(BitVector bitVector, boolean value, int rowCount) {\n+        bitVector.setSafe(rowCount, value? 1: 0);\n+        bitVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(TinyIntVector tinyIntVector, int value, int rowCount) {\n+        tinyIntVector.setSafe(rowCount, value);\n+        tinyIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(SmallIntVector smallIntVector, int value, int rowCount) {\n+        smallIntVector.setSafe(rowCount, value);\n+        smallIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(IntVector intVector, int value, int rowCount) {\n+        intVector.setSafe(rowCount, value);\n+        intVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(BigIntVector bigIntVector, int value, int rowCount) {\n+        bigIntVector.setSafe(rowCount, value);\n+        bigIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(DecimalVector decimalVector, BigDecimal value, int rowCount) {\n+        decimalVector.setSafe(rowCount, value);\n+        decimalVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(Float4Vector float4Vector, float value, int rowCount) {\n+        float4Vector.setSafe(rowCount, value);\n+        float4Vector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(Float8Vector float8Vector, double value, int rowCount) {\n+        float8Vector.setSafe(rowCount, value);\n+        float8Vector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(VarCharVector varcharVector, String value, int rowCount) {\n+        if (value != null) {\n+            varcharVector.setIndexDefined(rowCount);\n+            varcharVector.setValueLengthSafe(rowCount, value.length());\n+            varcharVector.setSafe(rowCount, value.getBytes(StandardCharsets.UTF_8), 0, value.length());\n+            varcharVector.setValueCount(rowCount + 1);\n+        }\n+        // TODO: not sure how to handle null string value ???\n+    }\n+\n+    private static void updateVector(DateMilliVector dateMilliVector, Date date, int rowCount) {\n+        //TODO: Need to handle Timezone\n \n Review comment:\n   I think for java.sql.Date, it is safe to assume you can ignore timezone. According to jdbc spec/google searches, a JDBC driver would put the date as a Local date. Same for java.sql.Time...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.512+0000",
                    "updated": "2018-04-11T16:31:21.512+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434166",
                    "id": "16434166",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180810834\n \n \n\n ##########\n File path: java/adapter/jdbc/pom.xml\n ##########\n @@ -0,0 +1,95 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor\n+  license agreements. See the NOTICE file distributed with this work for additional\n+  information regarding copyright ownership. The ASF licenses this file to\n+  You under the Apache License, Version 2.0 (the \"License\"); you may not use\n+  this file except in compliance with the License. You may obtain a copy of\n+  the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required\n+  by applicable law or agreed to in writing, software distributed under the\n+  License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n+  OF ANY KIND, either express or implied. See the License for the specific\n+  language governing permissions and limitations under the License. -->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+    <parent>\n+        <groupId>org.apache.arrow</groupId>\n+        <artifactId>arrow-java-root</artifactId>\n+        <version>0.10.0-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>arrow-jdbc</artifactId>\n+    <name>Arrow JDBC Adapter</name>\n+    <url>http://maven.apache.org</url>\n+    <dependencies>\n+\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-memory -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-memory</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <!-- https://mvnrepository.com/artifact/org.apache.arrow/arrow-vector -->\n+        <dependency>\n+            <groupId>org.apache.arrow</groupId>\n+            <artifactId>arrow-vector</artifactId>\n+            <version>${project.version}</version>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.google.guava</groupId>\n+            <artifactId>guava</artifactId>\n+            <version>18.0</version>\n+        </dependency>\n+\n+\n+        <!-- Test -->\n+        <dependency>\n+            <groupId>junit</groupId>\n+            <artifactId>junit</artifactId>\n+            <version>4.11</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <!-- https://mvnrepository.com/artifact/com.h2database/h2 -->\n+        <dependency>\n+            <groupId>com.h2database</groupId>\n+            <artifactId>h2</artifactId>\n+            <version>1.4.196</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.dataformat</groupId>\n+            <artifactId>jackson-dataformat-yaml</artifactId>\n+            <version>2.7.9</version>\n+            <scope>test</scope>\n+        </dependency>\n+        <dependency>\n+            <groupId>com.fasterxml.jackson.core</groupId>\n+            <artifactId>jackson-databind</artifactId>\n+            <version>2.7.9</version>\n \n Review comment:\n   replace with ${dep.jackson.version}\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.516+0000",
                    "updated": "2018-04-11T16:31:21.516+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434167",
                    "id": "16434167",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180815237\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,431 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.math.BigDecimal;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        Preconditions.checkNotNull(rsmd, \"JDBC ResultSetMetaData object can't be null\");\n+\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // TODO Need to handle timezone\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // TODO Need to handle this type\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op, shouldn't get here\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws SQLException {\n+\n+        Preconditions.checkNotNull(rs, \"JDBC ResultSet object can't be null\");\n+        Preconditions.checkNotNull(root, \"JDBC ResultSet object can't be null\");\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        updateVector((BitVector)root.getVector(columnName),\n+                                rs.getBoolean(i), rowCount);\n+                        break;\n+                    case Types.TINYINT:\n+                        updateVector((TinyIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.SMALLINT:\n+                        updateVector((SmallIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.INTEGER:\n+                        updateVector((IntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.BIGINT:\n+                        updateVector((BigIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        updateVector((DecimalVector)root.getVector(columnName),\n+                                rs.getBigDecimal(i), rowCount);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        updateVector((Float4Vector)root.getVector(columnName),\n+                                rs.getFloat(i), rowCount);\n+                        break;\n+                    case Types.DOUBLE:\n+                        updateVector((Float8Vector)root.getVector(columnName),\n+                                rs.getDouble(i), rowCount);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                                rs.getString(i), rowCount);\n+                        break;\n+                    case Types.DATE:\n+                        updateVector((DateMilliVector) root.getVector(columnName),\n+                                rs.getDate(i), rowCount);\n+                        break;\n+                    case Types.TIME:\n+                        updateVector((TimeMilliVector) root.getVector(columnName),\n+                                rs.getTime(i), rowCount);\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        updateVector((TimeStampVector)root.getVector(columnName),\n+                                rs.getTimestamp(i), rowCount);\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                                rs.getBytes(i), rowCount);\n+                        break;\n+                    case Types.ARRAY:\n+                        // TODO Need to handle this type\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                        break;\n+                    case Types.CLOB:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                            rs.getClob(i), rowCount);\n+                        break;\n+                    case Types.BLOB:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                            rs.getBlob(i), rowCount);\n+                        break;\n+\n+                    default:\n+                        // no-op, shouldn't get here\n+                        break;\n+                }\n+            }\n+            rowCount++;\n+        }\n+        root.setRowCount(rowCount);\n+    }\n+\n+    private static void updateVector(BitVector bitVector, boolean value, int rowCount) {\n \n Review comment:\n   still not sure how null values are handled...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.588+0000",
                    "updated": "2018-04-11T16:31:21.588+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434168",
                    "id": "16434168",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180817457\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,431 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.math.BigDecimal;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        Preconditions.checkNotNull(rsmd, \"JDBC ResultSetMetaData object can't be null\");\n+\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // TODO Need to handle timezone\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // TODO Need to handle this type\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op, shouldn't get here\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws SQLException {\n+\n+        Preconditions.checkNotNull(rs, \"JDBC ResultSet object can't be null\");\n+        Preconditions.checkNotNull(root, \"JDBC ResultSet object can't be null\");\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        updateVector((BitVector)root.getVector(columnName),\n+                                rs.getBoolean(i), rowCount);\n+                        break;\n+                    case Types.TINYINT:\n+                        updateVector((TinyIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.SMALLINT:\n+                        updateVector((SmallIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.INTEGER:\n+                        updateVector((IntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.BIGINT:\n+                        updateVector((BigIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        updateVector((DecimalVector)root.getVector(columnName),\n+                                rs.getBigDecimal(i), rowCount);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        updateVector((Float4Vector)root.getVector(columnName),\n+                                rs.getFloat(i), rowCount);\n+                        break;\n+                    case Types.DOUBLE:\n+                        updateVector((Float8Vector)root.getVector(columnName),\n+                                rs.getDouble(i), rowCount);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                                rs.getString(i), rowCount);\n+                        break;\n+                    case Types.DATE:\n+                        updateVector((DateMilliVector) root.getVector(columnName),\n+                                rs.getDate(i), rowCount);\n+                        break;\n+                    case Types.TIME:\n+                        updateVector((TimeMilliVector) root.getVector(columnName),\n+                                rs.getTime(i), rowCount);\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        updateVector((TimeStampVector)root.getVector(columnName),\n+                                rs.getTimestamp(i), rowCount);\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                                rs.getBytes(i), rowCount);\n+                        break;\n+                    case Types.ARRAY:\n+                        // TODO Need to handle this type\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                        break;\n+                    case Types.CLOB:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                            rs.getClob(i), rowCount);\n+                        break;\n+                    case Types.BLOB:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                            rs.getBlob(i), rowCount);\n+                        break;\n+\n+                    default:\n+                        // no-op, shouldn't get here\n+                        break;\n+                }\n+            }\n+            rowCount++;\n+        }\n+        root.setRowCount(rowCount);\n+    }\n+\n+    private static void updateVector(BitVector bitVector, boolean value, int rowCount) {\n+        bitVector.setSafe(rowCount, value? 1: 0);\n+        bitVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(TinyIntVector tinyIntVector, int value, int rowCount) {\n+        tinyIntVector.setSafe(rowCount, value);\n+        tinyIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(SmallIntVector smallIntVector, int value, int rowCount) {\n+        smallIntVector.setSafe(rowCount, value);\n+        smallIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(IntVector intVector, int value, int rowCount) {\n+        intVector.setSafe(rowCount, value);\n+        intVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(BigIntVector bigIntVector, int value, int rowCount) {\n+        bigIntVector.setSafe(rowCount, value);\n+        bigIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(DecimalVector decimalVector, BigDecimal value, int rowCount) {\n+        decimalVector.setSafe(rowCount, value);\n+        decimalVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(Float4Vector float4Vector, float value, int rowCount) {\n+        float4Vector.setSafe(rowCount, value);\n+        float4Vector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(Float8Vector float8Vector, double value, int rowCount) {\n+        float8Vector.setSafe(rowCount, value);\n+        float8Vector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(VarCharVector varcharVector, String value, int rowCount) {\n+        if (value != null) {\n+            varcharVector.setIndexDefined(rowCount);\n+            varcharVector.setValueLengthSafe(rowCount, value.length());\n+            varcharVector.setSafe(rowCount, value.getBytes(StandardCharsets.UTF_8), 0, value.length());\n+            varcharVector.setValueCount(rowCount + 1);\n+        }\n+        // TODO: not sure how to handle null string value ???\n+    }\n+\n+    private static void updateVector(DateMilliVector dateMilliVector, Date date, int rowCount) {\n+        //TODO: Need to handle Timezone\n+        dateMilliVector.setValueCount(rowCount + 1);\n+        if (date != null) {\n+            dateMilliVector.setSafe(rowCount, date.getTime());\n+        } else {\n+            dateMilliVector.setNull(rowCount);\n+        }\n+    }\n+\n+    private static void updateVector(TimeMilliVector timeMilliVector, Time time, int rowCount) {\n+        timeMilliVector.setValueCount(rowCount + 1);\n+        if (time != null) {\n+            timeMilliVector.setSafe(rowCount, (int) time.getTime());\n+        } else {\n+            timeMilliVector.setNull(rowCount);\n+        }\n+    }\n+\n+    private static void updateVector(TimeStampVector timeStampVector, Timestamp timestamp, int rowCount) {\n+        //TODO Need to handle timezone ???\n \n Review comment:\n   After researching this, it seems that there's no guidance on the spec, and each driver handles this a bit differently. The only sane thing to do is assume that this represents a local timestamp and get the number of seconds as is...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.634+0000",
                    "updated": "2018-04-11T16:31:21.634+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434169",
                    "id": "16434169",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180818053\n \n \n\n ##########\n File path: java/adapter/jdbc/src/main/java/org/apache/arrow/adapter/jdbc/JdbcToArrowUtils.java\n ##########\n @@ -0,0 +1,431 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.arrow.vector.BaseFixedWidthVector;\n+import org.apache.arrow.vector.BigIntVector;\n+import org.apache.arrow.vector.BitVector;\n+import org.apache.arrow.vector.DateMilliVector;\n+import org.apache.arrow.vector.DecimalVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.Float4Vector;\n+import org.apache.arrow.vector.Float8Vector;\n+import org.apache.arrow.vector.IntVector;\n+import org.apache.arrow.vector.SmallIntVector;\n+import org.apache.arrow.vector.TimeMilliVector;\n+import org.apache.arrow.vector.TimeStampVector;\n+import org.apache.arrow.vector.TinyIntVector;\n+import org.apache.arrow.vector.VarBinaryVector;\n+import org.apache.arrow.vector.VarCharVector;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.DateUnit;\n+import org.apache.arrow.vector.types.TimeUnit;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import java.math.BigDecimal;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.DOUBLE;\n+import static org.apache.arrow.vector.types.FloatingPointPrecision.SINGLE;\n+\n+\n+/**\n+ * Class that does most of the work to convert JDBC ResultSet data into Arrow columnar format Vector objects.\n+ *\n+ * @since 0.10.0\n+ */\n+public class JdbcToArrowUtils {\n+\n+    private static final int DEFAULT_BUFFER_SIZE = 256;\n+\n+    /**\n+     * Create Arrow {@link Schema} object for the given JDBC {@link ResultSetMetaData}.\n+     *\n+     * This method currently performs following type mapping for JDBC SQL data types to corresponding Arrow data types.\n+     *\n+     * CHAR\t--> ArrowType.Utf8\n+     * NCHAR\t--> ArrowType.Utf8\n+     * VARCHAR --> ArrowType.Utf8\n+     * NVARCHAR --> ArrowType.Utf8\n+     * LONGVARCHAR --> ArrowType.Utf8\n+     * LONGNVARCHAR --> ArrowType.Utf8\n+     * NUMERIC --> ArrowType.Decimal(precision, scale)\n+     * DECIMAL --> ArrowType.Decimal(precision, scale)\n+     * BIT --> ArrowType.Bool\n+     * TINYINT --> ArrowType.Int(8, signed)\n+     * SMALLINT --> ArrowType.Int(16, signed)\n+     * INTEGER --> ArrowType.Int(32, signed)\n+     * BIGINT --> ArrowType.Int(64, signed)\n+     * REAL --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * FLOAT --> ArrowType.FloatingPoint(FloatingPointPrecision.SINGLE)\n+     * DOUBLE --> ArrowType.FloatingPoint(FloatingPointPrecision.DOUBLE)\n+     * BINARY --> ArrowType.Binary\n+     * VARBINARY --> ArrowType.Binary\n+     * LONGVARBINARY --> ArrowType.Binary\n+     * DATE --> ArrowType.Date(DateUnit.MILLISECOND)\n+     * TIME --> ArrowType.Time(TimeUnit.MILLISECOND, 32)\n+     * TIMESTAMP --> ArrowType.Timestamp(TimeUnit.MILLISECOND, timezone=null)\n+     * CLOB --> ArrowType.Utf8\n+     * BLOB --> ArrowType.Binary\n+     *\n+     * @param rsmd\n+     * @return {@link Schema}\n+     * @throws SQLException\n+     */\n+    public static Schema jdbcToArrowSchema(ResultSetMetaData rsmd) throws SQLException {\n+\n+        Preconditions.checkNotNull(rsmd, \"JDBC ResultSetMetaData object can't be null\");\n+\n+        List<Field> fields = new ArrayList<>();\n+        int columnCount = rsmd.getColumnCount();\n+        for (int i = 1; i <= columnCount; i++) {\n+            String columnName = rsmd.getColumnName(i);\n+            switch (rsmd.getColumnType(i)) {\n+                case Types.BOOLEAN:\n+                case Types.BIT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Bool()), null));\n+                    break;\n+                case Types.TINYINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(8, true)), null));\n+                    break;\n+                case Types.SMALLINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(16, true)), null));\n+                    break;\n+                case Types.INTEGER:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(32, true)), null));\n+                    break;\n+                case Types.BIGINT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Int(64, true)), null));\n+                    break;\n+                case Types.NUMERIC:\n+                case Types.DECIMAL:\n+                    int precision = rsmd.getPrecision(i);\n+                    int scale = rsmd.getScale(i);\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Decimal(precision, scale)), null));\n+                    break;\n+                case Types.REAL:\n+                case Types.FLOAT:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(SINGLE)), null));\n+                    break;\n+                case Types.DOUBLE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.FloatingPoint(DOUBLE)), null));\n+                    break;\n+                case Types.CHAR:\n+                case Types.NCHAR:\n+                case Types.VARCHAR:\n+                case Types.NVARCHAR:\n+                case Types.LONGVARCHAR:\n+                case Types.LONGNVARCHAR:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.DATE:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Date(DateUnit.MILLISECOND)), null));\n+                    break;\n+                case Types.TIME:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Time(TimeUnit.MILLISECOND, 32)), null));\n+                    break;\n+                case Types.TIMESTAMP:\n+                    // TODO Need to handle timezone\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Timestamp(TimeUnit.MILLISECOND, null)), null));\n+                    break;\n+                case Types.BINARY:\n+                case Types.VARBINARY:\n+                case Types.LONGVARBINARY:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+                case Types.ARRAY:\n+                    // TODO Need to handle this type\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                   break;\n+                case Types.CLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Utf8()), null));\n+                    break;\n+                case Types.BLOB:\n+                    fields.add(new Field(columnName, FieldType.nullable(new ArrowType.Binary()), null));\n+                    break;\n+\n+                default:\n+                    // no-op, shouldn't get here\n+                    break;\n+            }\n+        }\n+\n+        return new Schema(fields, null);\n+    }\n+\n+    private static void allocateVectors(VectorSchemaRoot root, int size) {\n+        List<FieldVector> vectors = root.getFieldVectors();\n+        for (FieldVector fieldVector: vectors) {\n+            if (fieldVector instanceof BaseFixedWidthVector) {\n+                ((BaseFixedWidthVector) fieldVector).allocateNew(size);\n+            } else {\n+                fieldVector.allocateNew();\n+            }\n+            fieldVector.setInitialCapacity(size);\n+        }\n+    }\n+\n+    /**\n+     * Iterate the given JDBC {@link ResultSet} object to fetch the data and transpose it to populate\n+     * the given Arrow Vector objects.\n+     *\n+     * @param rs ResultSet to use to fetch the data from underlying database\n+     * @param root Arrow {@link VectorSchemaRoot} object to populate\n+     * @throws Exception\n+     */\n+    public static void jdbcToArrowVectors(ResultSet rs, VectorSchemaRoot root) throws SQLException {\n+\n+        Preconditions.checkNotNull(rs, \"JDBC ResultSet object can't be null\");\n+        Preconditions.checkNotNull(root, \"JDBC ResultSet object can't be null\");\n+\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int columnCount = rsmd.getColumnCount();\n+\n+        allocateVectors(root, DEFAULT_BUFFER_SIZE);\n+\n+        int rowCount = 0;\n+        while (rs.next()) {\n+            // for each column get the value based on the type\n+\n+            // need to change this to build Java lists and then build Arrow vectors\n+            for (int i = 1; i <= columnCount; i++) {\n+                String columnName = rsmd.getColumnName(i);\n+                switch (rsmd.getColumnType(i)) {\n+                    case Types.BOOLEAN:\n+                    case Types.BIT:\n+                        updateVector((BitVector)root.getVector(columnName),\n+                                rs.getBoolean(i), rowCount);\n+                        break;\n+                    case Types.TINYINT:\n+                        updateVector((TinyIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.SMALLINT:\n+                        updateVector((SmallIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.INTEGER:\n+                        updateVector((IntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.BIGINT:\n+                        updateVector((BigIntVector)root.getVector(columnName),\n+                                rs.getInt(i), rowCount);\n+                        break;\n+                    case Types.NUMERIC:\n+                    case Types.DECIMAL:\n+                        updateVector((DecimalVector)root.getVector(columnName),\n+                                rs.getBigDecimal(i), rowCount);\n+                        break;\n+                    case Types.REAL:\n+                    case Types.FLOAT:\n+                        updateVector((Float4Vector)root.getVector(columnName),\n+                                rs.getFloat(i), rowCount);\n+                        break;\n+                    case Types.DOUBLE:\n+                        updateVector((Float8Vector)root.getVector(columnName),\n+                                rs.getDouble(i), rowCount);\n+                        break;\n+                    case Types.CHAR:\n+                    case Types.NCHAR:\n+                    case Types.VARCHAR:\n+                    case Types.NVARCHAR:\n+                    case Types.LONGVARCHAR:\n+                    case Types.LONGNVARCHAR:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                                rs.getString(i), rowCount);\n+                        break;\n+                    case Types.DATE:\n+                        updateVector((DateMilliVector) root.getVector(columnName),\n+                                rs.getDate(i), rowCount);\n+                        break;\n+                    case Types.TIME:\n+                        updateVector((TimeMilliVector) root.getVector(columnName),\n+                                rs.getTime(i), rowCount);\n+                        break;\n+                    case Types.TIMESTAMP:\n+                        updateVector((TimeStampVector)root.getVector(columnName),\n+                                rs.getTimestamp(i), rowCount);\n+                        break;\n+                    case Types.BINARY:\n+                    case Types.VARBINARY:\n+                    case Types.LONGVARBINARY:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                                rs.getBytes(i), rowCount);\n+                        break;\n+                    case Types.ARRAY:\n+                        // TODO Need to handle this type\n+//                    fields.add(new Field(\"list\", FieldType.nullable(new ArrowType.List()), null));\n+                        break;\n+                    case Types.CLOB:\n+                        updateVector((VarCharVector)root.getVector(columnName),\n+                            rs.getClob(i), rowCount);\n+                        break;\n+                    case Types.BLOB:\n+                        updateVector((VarBinaryVector)root.getVector(columnName),\n+                            rs.getBlob(i), rowCount);\n+                        break;\n+\n+                    default:\n+                        // no-op, shouldn't get here\n+                        break;\n+                }\n+            }\n+            rowCount++;\n+        }\n+        root.setRowCount(rowCount);\n+    }\n+\n+    private static void updateVector(BitVector bitVector, boolean value, int rowCount) {\n+        bitVector.setSafe(rowCount, value? 1: 0);\n+        bitVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(TinyIntVector tinyIntVector, int value, int rowCount) {\n+        tinyIntVector.setSafe(rowCount, value);\n+        tinyIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(SmallIntVector smallIntVector, int value, int rowCount) {\n+        smallIntVector.setSafe(rowCount, value);\n+        smallIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(IntVector intVector, int value, int rowCount) {\n+        intVector.setSafe(rowCount, value);\n+        intVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static  void updateVector(BigIntVector bigIntVector, int value, int rowCount) {\n+        bigIntVector.setSafe(rowCount, value);\n+        bigIntVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(DecimalVector decimalVector, BigDecimal value, int rowCount) {\n+        decimalVector.setSafe(rowCount, value);\n+        decimalVector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(Float4Vector float4Vector, float value, int rowCount) {\n+        float4Vector.setSafe(rowCount, value);\n+        float4Vector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(Float8Vector float8Vector, double value, int rowCount) {\n+        float8Vector.setSafe(rowCount, value);\n+        float8Vector.setValueCount(rowCount + 1);\n+    }\n+\n+    private static void updateVector(VarCharVector varcharVector, String value, int rowCount) {\n+        if (value != null) {\n+            varcharVector.setIndexDefined(rowCount);\n+            varcharVector.setValueLengthSafe(rowCount, value.length());\n+            varcharVector.setSafe(rowCount, value.getBytes(StandardCharsets.UTF_8), 0, value.length());\n+            varcharVector.setValueCount(rowCount + 1);\n+        }\n+        // TODO: not sure how to handle null string value ???\n+    }\n+\n+    private static void updateVector(DateMilliVector dateMilliVector, Date date, int rowCount) {\n+        //TODO: Need to handle Timezone\n+        dateMilliVector.setValueCount(rowCount + 1);\n+        if (date != null) {\n+            dateMilliVector.setSafe(rowCount, date.getTime());\n+        } else {\n+            dateMilliVector.setNull(rowCount);\n+        }\n+    }\n+\n+    private static void updateVector(TimeMilliVector timeMilliVector, Time time, int rowCount) {\n+        timeMilliVector.setValueCount(rowCount + 1);\n+        if (time != null) {\n+            timeMilliVector.setSafe(rowCount, (int) time.getTime());\n+        } else {\n+            timeMilliVector.setNull(rowCount);\n+        }\n+    }\n+\n+    private static void updateVector(TimeStampVector timeStampVector, Timestamp timestamp, int rowCount) {\n+        //TODO Need to handle timezone ???\n+        timeStampVector.setValueCount(rowCount + 1);\n+        if (timestamp != null) {\n+            timeStampVector.setSafe(rowCount, timestamp.getTime());\n \n Review comment:\n   depending on the precision, you might also want to check `getNanos()`\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:31:21.636+0000",
                    "updated": "2018-04-11T16:31:21.636+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434204",
                    "id": "16434204",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "laurentgo commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-380521328\n \n \n   @atuldambalkar I can be reached on slack if you need me\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T16:51:10.420+0000",
                    "updated": "2018-04-11T16:51:10.420+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16434383",
                    "id": "16434383",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on a change in pull request #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#discussion_r180855624\n \n \n\n ##########\n File path: java/adapter/jdbc/src/test/java/org/apache/arrow/adapter/jdbc/AbstractJdbcToArrowTest.java\n ##########\n @@ -0,0 +1,66 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.adapter.jdbc;\n+\n+import java.sql.Connection;\n+import java.sql.Statement;\n+\n+/**\n+ * Class to abstract out some common test functionality for testing JDBC to Arrow.\n+ */\n+public abstract class AbstractJdbcToArrowTest {\n+\n+    protected void createTestData(Connection conn, Table table) throws Exception {\n+\n+        Statement stmt = null;\n+        try {\n+            //create the table and insert the data and once done drop the table\n+            stmt = conn.createStatement();\n+            stmt.executeUpdate(table.getCreate());\n+\n+            for (String insert: table.getData()) {\n+                stmt.executeUpdate(insert);\n+            }\n+\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        } finally {\n \n Review comment:\n   Thanks @laurentgo for the comments. I should be able to revert soon with further changes. Still getting some work done from our India development team member on the test cases related changes. Let me ping you on Slack for any quick discussion.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-11T18:33:20.172+0000",
                    "updated": "2018-04-11T18:33:20.172+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16436765",
                    "id": "16436765",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-381014810\n \n \n   Hi @laurentgo ,\r\n   \r\n   I have taken care of your following review comments -\r\n   1. Used BaseAllocator instead of RootAllocator\r\n   2. Added Calendar object as another argument to the API so that it gets used for Date, Time and Timestamp data values\r\n   3. Handled NULL values for all the data types. I am basically using Nullable DataHolder objects as much as possible. Test cases need to be added though.\r\n   4. For BigDecimal data type used getLong() API instead of getInt().\r\n   5. Used StandardCharsets.UTF_8 as charset at places where we are doing string to bytes operation.\r\n   \r\n   Things that are still not done -\r\n   1. I am unable to use the streaming approach for Blob and Clob as I couldn't figure out a way to really populate the Destination ArrowBuffer in a streaming manner.  \r\n   2. I still need to take care of the precision of Timestamp values for Nano/Micro/Milli values.\r\n   3. Array data type is not yet supported.\r\n   4. For the \"default\" switch case, the control shouldn't get there. So I could throw Exception if that makes sense.\r\n   \r\n   Let me know your comments.\r\n   \r\n   Thanks. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-13T03:57:51.894+0000",
                    "updated": "2018-04-13T03:57:51.894+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16441684",
                    "id": "16441684",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "atuldambalkar commented on issue #1759: ARROW-1780 - [WIP] JDBC Adapter to convert Relational Data objects to Arrow Data Format Vector Objects\nURL: https://github.com/apache/arrow/pull/1759#issuecomment-382195795\n \n \n   Hi @laurentgo\r\n   \r\n   Please hold off until I push some additional code changes based on the test cases. You can continue the code review once that is done. \r\n   \r\n   Thanks.\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-17T23:56:04.921+0000",
                    "updated": "2018-04-17T23:56:04.921+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13117051/comment/16518882",
                    "id": "16518882",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
                        "name": "atul_dambalkar",
                        "key": "atul_dambalkar",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Atul Dambalkar",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Added the necessary components - [https://github.com/apache/arrow/pull/1759/]\r\n\r\nCode is under -\u00a0https://github.com/apache/arrow/tree/master/java/adapter/jdbc",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=atul_dambalkar",
                        "name": "atul_dambalkar",
                        "key": "atul_dambalkar",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Atul Dambalkar",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2018-06-21T03:58:40.518+0000",
                    "updated": "2018-06-21T03:58:40.518+0000"
                }
            ],
            "maxResults": 108,
            "total": 108,
            "startAt": 0
        },
        "customfield_12311820": "0|i3mk0v:",
        "customfield_12314139": null
    }
}