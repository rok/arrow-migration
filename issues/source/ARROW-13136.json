{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13384941",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941",
    "key": "ARROW-13136",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12619554",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12619554",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13390197",
                    "key": "ARROW-13368",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13390197",
                    "fields": {
                        "summary": "[C++][Doc] Rename project to make_struct in docs",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/1",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/blocker.svg",
                            "name": "Blocker",
                            "id": "1"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
                            "id": "1",
                            "description": "A problem which impairs or prevents the functions of the product.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
                            "name": "Bug",
                            "subtask": false,
                            "avatarId": 21133
                        }
                    }
                }
            },
            {
                "id": "12620763",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12620763",
                "type": {
                    "id": "12310000",
                    "name": "Duplicate",
                    "inward": "is duplicated by",
                    "outward": "duplicates",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310000"
                },
                "inwardIssue": {
                    "id": "13268606",
                    "key": "ARROW-7179",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13268606",
                    "fields": {
                        "summary": "[C++][Compute] Consolidate fill_null and coalesce",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12619561",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12619561",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13390776",
                    "key": "ARROW-13390",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13390776",
                    "fields": {
                        "summary": "[C++] Improve type support for 'coalesce' kernel",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12618271",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12618271",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13386335",
                    "key": "ARROW-13201",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13386335",
                    "fields": {
                        "summary": "[R] Add binding for coalesce()",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=icook",
            "name": "icook",
            "key": "icook",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=icook&avatarId=29388",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=icook&avatarId=29388",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=icook&avatarId=29388",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=icook&avatarId=29388"
            },
            "displayName": "Ian Cook",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=icook",
            "name": "icook",
            "key": "icook",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=icook&avatarId=29388",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=icook&avatarId=29388",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=icook&avatarId=29388",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=icook&avatarId=29388"
            },
            "displayName": "Ian Cook",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 13800,
            "total": 13800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 13800,
            "total": 13800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13136/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 23,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/615705",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm opened a new pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608\n\n\n   This is based on top of ARROW-13064 for now. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-28T17:40:37.869+0000",
                    "updated": "2021-06-28T17:40:37.869+0000",
                    "started": "2021-06-28T17:40:37.869+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "615705",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/615706",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-869882968\n\n\n   https://issues.apache.org/jira/browse/ARROW-13136\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-28T17:42:25.499+0000",
                    "updated": "2021-06-28T17:42:25.499+0000",
                    "started": "2021-06-28T17:42:25.499+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "615706",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/616170",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-869882968\n\n\n   https://issues.apache.org/jira/browse/ARROW-13136\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-29T13:21:25.147+0000",
                    "updated": "2021-06-29T13:21:25.147+0000",
                    "started": "2021-06-29T13:21:25.146+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "616170",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/616216",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm opened a new pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608\n\n\n   This is based on top of ARROW-13064 for now. \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-29T13:33:10.583+0000",
                    "updated": "2021-06-29T13:33:10.583+0000",
                    "started": "2021-06-29T13:33:10.582+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "616216",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/618118",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-873006662\n\n\n   Hmm, this has some Valgrind errors - taking a look.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-02T13:40:05.443+0000",
                    "updated": "2021-07-02T13:40:05.443+0000",
                    "started": "2021-07-02T13:40:05.443+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "618118",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/618125",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-873021575\n\n\n   @github-actions crossbow submit conda-cpp-valgrind\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-02T14:00:54.974+0000",
                    "updated": "2021-07-02T14:00:54.974+0000",
                    "started": "2021-07-02T14:00:54.973+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "618125",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/618126",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-873023441\n\n\n   @github-actions crossbow submit test-conda-cpp-valgrind\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-02T14:03:33.637+0000",
                    "updated": "2021-07-02T14:03:33.637+0000",
                    "started": "2021-07-02T14:03:33.637+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "618126",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/618127",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-873024058\n\n\n   Revision: 08c63756efc1d4d950b4d45a6b0cd6feb30cdd60\n   \n   Submitted crossbow builds: [ursacomputing/crossbow @ actions-560](https://github.com/ursacomputing/crossbow/branches/all?query=actions-560)\n   \n   |Task|Status|\n   |----|------|\n   |test-conda-cpp-valgrind|[![Github Actions](https://github.com/ursacomputing/crossbow/workflows/Crossbow/badge.svg?branch=actions-560-github-test-conda-cpp-valgrind)](https://github.com/ursacomputing/crossbow/actions?query=branch:actions-560-github-test-conda-cpp-valgrind)|\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-02T14:04:18.005+0000",
                    "updated": "2021-07-02T14:04:18.005+0000",
                    "started": "2021-07-02T14:04:18.004+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "618127",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/621611",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-878354546\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-12T19:58:01.277+0000",
                    "updated": "2021-07-12T19:58:01.277+0000",
                    "started": "2021-07-12T19:58:01.277+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "621611",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/621652",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#discussion_r668018470\n\n\n\n##########\nFile path: cpp/src/arrow/util/bit_block_counter.h\n##########\n@@ -266,6 +276,9 @@ class ARROW_EXPORT BinaryBitBlockCounter {\n   /// blocks in subsequent invocations.\n   BitBlockCount NextAndWord() { return NextWord<detail::BitBlockAnd>(); }\n \n+  /// \\brief Computes \"~x & y\" block for each available run of bits.\n+  BitBlockCount NextNotAndWord() { return NextWord<detail::BitBlockNotAnd>(); }\n\nReview comment:\n       Nit: this operation is usually spelled \"and not\"\n\n##########\nFile path: cpp/src/arrow/compute/kernels/codegen_internal.cc\n##########\n@@ -253,7 +255,7 @@ std::shared_ptr<DataType> CommonNumeric(const std::vector<ValueDescr>& descrs) {\n     if (max_width_unsigned == 32) return uint32();\n     if (max_width_unsigned == 16) return uint16();\n     DCHECK_EQ(max_width_unsigned, 8);\n-    return int8();\n+    return uint8();\n\nReview comment:\n       Nice catch\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,319 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n+    DCHECK_EQ(scalar.value->size(), width);\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, scalar.value->data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const ScalarType&>(values);\n+    const auto value = scalar.value.ToBytes();\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, value.data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+// Copy fixed-width values from a scalar/array datum into an output values buffer\n+template <typename Type>\n+void CopyValues(const Datum& values, uint8_t* out_valid, uint8_t* out_values,\n+                const int64_t offset, const int64_t length) {\n+  using Copier = CopyFixedWidth<Type>;\n+  if (values.is_scalar()) {\n+    const auto& scalar = *values.scalar();\n+    if (out_valid) {\n+      BitUtil::SetBitsTo(out_valid, offset, length, scalar.is_valid);\n+    }\n+    Copier::CopyScalar(scalar, out_values, offset, length);\n+  } else {\n+    const ArrayData& array = *values.array();\n+    if (out_valid) {\n+      if (array.MayHaveNulls()) {\n+        arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset + offset,\n+                                    length, out_valid, offset);\n+      } else {\n+        BitUtil::SetBitsTo(out_valid, offset, length, true);\n+      }\n+    }\n+    Copier::CopyArray(array, out_values, offset, length);\n+  }\n+}\n+\n+struct CoalesceFunction : ScalarFunction {\n+  using ScalarFunction::ScalarFunction;\n+\n+  Result<const Kernel*> DispatchBest(std::vector<ValueDescr>* values) const override {\n+    RETURN_NOT_OK(CheckArity(*values));\n+    using arrow::compute::detail::DispatchExactImpl;\n+    if (auto kernel = DispatchExactImpl(this, *values)) return kernel;\n+    EnsureDictionaryDecoded(values);\n+    if (auto type = CommonNumeric(*values)) {\n+      ReplaceTypes(type, values);\n+    }\n+    if (auto kernel = DispatchExactImpl(this, *values)) return kernel;\n+    return arrow::compute::detail::NoMatchingKernel(this, *values);\n+  }\n+};\n+\n+// Implement a 'coalesce' (SQL) operator for any number of scalar inputs\n+Status ExecScalarCoalesce(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  for (const auto& datum : batch.values) {\n+    if (datum.scalar()->is_valid) {\n+      *out = datum;\n+      break;\n+    }\n+  }\n+  return Status::OK();\n+}\n+\n+// Implement 'coalesce' for any mix of scalar/array arguments for any fixed-width type\n+template <typename Type>\n+Status ExecArrayCoalesce(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  ArrayData* output = out->mutable_array();\n+  ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(batch.length));\n+  // Use output validity buffer as mask to decide what values to copy\n+  uint8_t* out_valid = output->buffers[0]->mutable_data();\n+  // Clear output buffer - no values are set initially\n+  std::memset(out_valid, 0x00, output->buffers[0]->size());\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  for (const auto& datum : batch.values) {\n+    if ((datum.is_scalar() && datum.scalar()->is_valid) ||\n+        (datum.is_array() && !datum.array()->MayHaveNulls())) {\n+      BitBlockCounter counter(out_valid, /*start_offset=*/0, batch.length);\n+      int64_t offset = 0;\n+      while (offset < batch.length) {\n+        const auto block = counter.NextWord();\n+        if (block.NoneSet()) {\n+          CopyValues<Type>(datum, out_valid, out_values, offset, block.length);\n+        } else if (!block.AllSet()) {\n+          for (int64_t j = 0; j < block.length; ++j) {\n+            if (!BitUtil::GetBit(out_valid, offset + j)) {\n+              CopyValues<Type>(datum, out_valid, out_values, offset + j,\n+                               /*length=*/1);\n+            }\n+          }\n+        }\n+        offset += block.length;\n+      }\n+      break;\n+    } else if (datum.is_array()) {\n+      const ArrayData& arr = *datum.array();\n+      BinaryBitBlockCounter counter(out_valid, /*start_offset=*/0, arr.buffers[0]->data(),\n+                                    arr.offset, batch.length);\n+      int64_t offset = 0;\n+      while (offset < batch.length) {\n+        const auto block = counter.NextNotAndWord();\n+        if (block.AllSet()) {\n+          CopyValues<Type>(datum, out_valid, out_values, offset, block.length);\n+        } else if (block.popcount) {\n+          for (int64_t j = 0; j < block.length; ++j) {\n+            if (!BitUtil::GetBit(out_valid, offset + j)) {\n+              CopyValues<Type>(datum, out_valid, out_values, offset + j,\n+                               /*length=*/1);\n+            }\n+          }\n+        }\n+        offset += block.length;\n+      }\n+    }\n+  }\n+  // Need to initialize any remaining null slots (uninitialized memory)\n+  BitBlockCounter counter(out_valid, /*start_offset=*/0, batch.length);\n+  int64_t offset = 0;\n+  auto bit_width = checked_cast<const FixedWidthType&>(*out->type()).bit_width();\n+  auto byte_width = BitUtil::BytesForBits(bit_width);\n+  while (offset < batch.length) {\n+    const auto block = counter.NextWord();\n+    if (block.NoneSet()) {\n+      if (bit_width == 1) {\n+        BitUtil::SetBitsTo(out_values, offset, block.length, false);\n+      } else {\n+        std::memset(out_values + offset, 0x00, byte_width * block.length);\n+      }\n+    } else if (!block.AllSet()) {\n+      for (int64_t j = 0; j < block.length; ++j) {\n+        if (BitUtil::GetBit(out_valid, offset + j)) continue;\n+        if (bit_width == 1) {\n+          BitUtil::ClearBit(out_values, offset + j);\n+        } else {\n+          std::memset(out_values + offset + j, 0x00, byte_width);\n+        }\n+      }\n+    }\n+    offset += block.length;\n+  }\n+  return Status::OK();\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct CoalesceFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    for (const auto& datum : batch.values) {\n+      if (datum.is_array()) {\n+        return ExecArrayCoalesce<Type>(ctx, batch, out);\n+      }\n+    }\n+    return ExecScalarCoalesce(ctx, batch, out);\n+  }\n+};\n+\n+template <>\n+struct CoalesceFunctor<NullType> {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct CoalesceFunctor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    for (const auto& datum : batch.values) {\n+      if (datum.is_array()) {\n+        return ExecArray(ctx, batch, out);\n+      }\n+    }\n+    return ExecScalarCoalesce(ctx, batch, out);\n+  }\n+\n+  static Status ExecArray(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // Special case: grab any leading non-null scalar or array arguments\n+    for (const auto& datum : batch.values) {\n+      if (datum.is_scalar()) {\n+        if (!datum.scalar()->is_valid) continue;\n+        ARROW_ASSIGN_OR_RAISE(\n+            *out, MakeArrayFromScalar(*datum.scalar(), batch.length, ctx->memory_pool()));\n+        return Status::OK();\n+      } else if (datum.is_array() && !datum.array()->MayHaveNulls()) {\n+        *out = datum;\n+        return Status::OK();\n+      }\n+      break;\n+    }\n+    ArrayData* output = out->mutable_array();\n+    BuilderType builder(batch[0].type(), ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      bool set = false;\n+      for (const auto& datum : batch.values) {\n+        if (datum.is_scalar()) {\n+          if (datum.scalar()->is_valid) {\n+            // TODO(ARROW-11936): use AppendScalar\n\nReview comment:\n       Actually, AppendScalar woud pessimize performance here since we'd be performing a virtual call to disambiguate the scalar's type when we already know it at compile time through `Type`\r\n   ```suggestion\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,319 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n+    DCHECK_EQ(scalar.value->size(), width);\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, scalar.value->data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const ScalarType&>(values);\n+    const auto value = scalar.value.ToBytes();\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, value.data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+// Copy fixed-width values from a scalar/array datum into an output values buffer\n+template <typename Type>\n+void CopyValues(const Datum& values, uint8_t* out_valid, uint8_t* out_values,\n+                const int64_t offset, const int64_t length) {\n+  using Copier = CopyFixedWidth<Type>;\n+  if (values.is_scalar()) {\n+    const auto& scalar = *values.scalar();\n+    if (out_valid) {\n+      BitUtil::SetBitsTo(out_valid, offset, length, scalar.is_valid);\n+    }\n+    Copier::CopyScalar(scalar, out_values, offset, length);\n+  } else {\n+    const ArrayData& array = *values.array();\n+    if (out_valid) {\n+      if (array.MayHaveNulls()) {\n+        arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset + offset,\n+                                    length, out_valid, offset);\n+      } else {\n+        BitUtil::SetBitsTo(out_valid, offset, length, true);\n+      }\n+    }\n+    Copier::CopyArray(array, out_values, offset, length);\n+  }\n+}\n+\n+struct CoalesceFunction : ScalarFunction {\n+  using ScalarFunction::ScalarFunction;\n+\n+  Result<const Kernel*> DispatchBest(std::vector<ValueDescr>* values) const override {\n+    RETURN_NOT_OK(CheckArity(*values));\n+    using arrow::compute::detail::DispatchExactImpl;\n+    if (auto kernel = DispatchExactImpl(this, *values)) return kernel;\n+    EnsureDictionaryDecoded(values);\n+    if (auto type = CommonNumeric(*values)) {\n+      ReplaceTypes(type, values);\n+    }\n+    if (auto kernel = DispatchExactImpl(this, *values)) return kernel;\n+    return arrow::compute::detail::NoMatchingKernel(this, *values);\n+  }\n+};\n+\n+// Implement a 'coalesce' (SQL) operator for any number of scalar inputs\n+Status ExecScalarCoalesce(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  for (const auto& datum : batch.values) {\n+    if (datum.scalar()->is_valid) {\n+      *out = datum;\n+      break;\n+    }\n+  }\n+  return Status::OK();\n+}\n+\n+// Implement 'coalesce' for any mix of scalar/array arguments for any fixed-width type\n+template <typename Type>\n+Status ExecArrayCoalesce(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  ArrayData* output = out->mutable_array();\n+  ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(batch.length));\n+  // Use output validity buffer as mask to decide what values to copy\n+  uint8_t* out_valid = output->buffers[0]->mutable_data();\n+  // Clear output buffer - no values are set initially\n+  std::memset(out_valid, 0x00, output->buffers[0]->size());\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  for (const auto& datum : batch.values) {\n+    if ((datum.is_scalar() && datum.scalar()->is_valid) ||\n+        (datum.is_array() && !datum.array()->MayHaveNulls())) {\n+      BitBlockCounter counter(out_valid, /*start_offset=*/0, batch.length);\n+      int64_t offset = 0;\n+      while (offset < batch.length) {\n+        const auto block = counter.NextWord();\n+        if (block.NoneSet()) {\n+          CopyValues<Type>(datum, out_valid, out_values, offset, block.length);\n+        } else if (!block.AllSet()) {\n+          for (int64_t j = 0; j < block.length; ++j) {\n+            if (!BitUtil::GetBit(out_valid, offset + j)) {\n+              CopyValues<Type>(datum, out_valid, out_values, offset + j,\n+                               /*length=*/1);\n+            }\n+          }\n+        }\n+        offset += block.length;\n+      }\n+      break;\n+    } else if (datum.is_array()) {\n+      const ArrayData& arr = *datum.array();\n+      BinaryBitBlockCounter counter(out_valid, /*start_offset=*/0, arr.buffers[0]->data(),\n+                                    arr.offset, batch.length);\n+      int64_t offset = 0;\n+      while (offset < batch.length) {\n+        const auto block = counter.NextNotAndWord();\n+        if (block.AllSet()) {\n+          CopyValues<Type>(datum, out_valid, out_values, offset, block.length);\n+        } else if (block.popcount) {\n+          for (int64_t j = 0; j < block.length; ++j) {\n+            if (!BitUtil::GetBit(out_valid, offset + j)) {\n+              CopyValues<Type>(datum, out_valid, out_values, offset + j,\n+                               /*length=*/1);\n+            }\n+          }\n+        }\n+        offset += block.length;\n+      }\n+    }\n+  }\n+  // Need to initialize any remaining null slots (uninitialized memory)\n+  BitBlockCounter counter(out_valid, /*start_offset=*/0, batch.length);\n+  int64_t offset = 0;\n+  auto bit_width = checked_cast<const FixedWidthType&>(*out->type()).bit_width();\n+  auto byte_width = BitUtil::BytesForBits(bit_width);\n+  while (offset < batch.length) {\n+    const auto block = counter.NextWord();\n+    if (block.NoneSet()) {\n+      if (bit_width == 1) {\n+        BitUtil::SetBitsTo(out_values, offset, block.length, false);\n+      } else {\n+        std::memset(out_values + offset, 0x00, byte_width * block.length);\n+      }\n+    } else if (!block.AllSet()) {\n+      for (int64_t j = 0; j < block.length; ++j) {\n+        if (BitUtil::GetBit(out_valid, offset + j)) continue;\n+        if (bit_width == 1) {\n+          BitUtil::ClearBit(out_values, offset + j);\n+        } else {\n+          std::memset(out_values + offset + j, 0x00, byte_width);\n+        }\n+      }\n+    }\n+    offset += block.length;\n+  }\n+  return Status::OK();\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct CoalesceFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    for (const auto& datum : batch.values) {\n+      if (datum.is_array()) {\n+        return ExecArrayCoalesce<Type>(ctx, batch, out);\n+      }\n+    }\n+    return ExecScalarCoalesce(ctx, batch, out);\n+  }\n+};\n+\n+template <>\n+struct CoalesceFunctor<NullType> {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct CoalesceFunctor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    for (const auto& datum : batch.values) {\n+      if (datum.is_array()) {\n+        return ExecArray(ctx, batch, out);\n+      }\n+    }\n+    return ExecScalarCoalesce(ctx, batch, out);\n+  }\n+\n+  static Status ExecArray(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // Special case: grab any leading non-null scalar or array arguments\n+    for (const auto& datum : batch.values) {\n+      if (datum.is_scalar()) {\n+        if (!datum.scalar()->is_valid) continue;\n+        ARROW_ASSIGN_OR_RAISE(\n+            *out, MakeArrayFromScalar(*datum.scalar(), batch.length, ctx->memory_pool()));\n+        return Status::OK();\n+      } else if (datum.is_array() && !datum.array()->MayHaveNulls()) {\n+        *out = datum;\n+        return Status::OK();\n+      }\n+      break;\n+    }\n+    ArrayData* output = out->mutable_array();\n+    BuilderType builder(batch[0].type(), ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      bool set = false;\n+      for (const auto& datum : batch.values) {\n+        if (datum.is_scalar()) {\n+          if (datum.scalar()->is_valid) {\n+            // TODO(ARROW-11936): use AppendScalar\n+            RETURN_NOT_OK(builder.Append(UnboxScalar<Type>::Unbox(*datum.scalar())));\n+            set = true;\n+            break;\n+          }\n+        } else {\n+          const ArrayData& source = *datum.array();\n+          if (!source.MayHaveNulls() ||\n+              BitUtil::GetBit(source.buffers[0]->data(), source.offset + i)) {\n+            const uint8_t* data = source.buffers[2]->data();\n+            const offset_type* offsets = source.GetValues<offset_type>(1);\n+            const offset_type offset0 = offsets[i];\n+            const offset_type offset1 = offsets[i + 1];\n+            RETURN_NOT_OK(builder.Append(data + offset0, offset1 - offset0));\n+            set = true;\n+            break;\n+          }\n+        }\n+      }\n+      if (!set) RETURN_NOT_OK(builder.AppendNull());\n+    }\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n\nReview comment:\n       ```suggestion\r\n       ARROW_ASSIGN_OR_RAISE(auto temp_output, builder.Finish());\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,319 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(out_values, offset, length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    arrow::internal::CopyBitmap(array.buffers[1]->data(), array.offset + offset, length,\n+                                out_values, offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& values, uint8_t* raw_out_values,\n+                         const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(values);\n+    std::fill(out_values + offset, out_values + offset + length, value);\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* raw_out_values,\n+                        const int64_t offset, const int64_t length) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType* in_values = array.GetValues<CType>(1);\n+    std::copy(in_values + offset, in_values + offset + length, out_values + offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n+    DCHECK_EQ(scalar.value->size(), width);\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, scalar.value->data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  static void CopyScalar(const Scalar& values, uint8_t* out_values, const int64_t offset,\n+                         const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto& scalar = checked_cast<const ScalarType&>(values);\n+    const auto value = scalar.value.ToBytes();\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, value.data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const ArrayData& array, uint8_t* out_values, const int64_t offset,\n+                        const int64_t length) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*array.type).byte_width();\n+    uint8_t* next = out_values + (width * offset);\n+    const auto* in_values = array.GetValues<uint8_t>(1, (offset + array.offset) * width);\n+    std::memcpy(next, in_values, length * width);\n+  }\n+};\n+// Copy fixed-width values from a scalar/array datum into an output values buffer\n+template <typename Type>\n+void CopyValues(const Datum& values, uint8_t* out_valid, uint8_t* out_values,\n+                const int64_t offset, const int64_t length) {\n+  using Copier = CopyFixedWidth<Type>;\n+  if (values.is_scalar()) {\n+    const auto& scalar = *values.scalar();\n+    if (out_valid) {\n+      BitUtil::SetBitsTo(out_valid, offset, length, scalar.is_valid);\n+    }\n+    Copier::CopyScalar(scalar, out_values, offset, length);\n+  } else {\n+    const ArrayData& array = *values.array();\n+    if (out_valid) {\n+      if (array.MayHaveNulls()) {\n+        arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset + offset,\n+                                    length, out_valid, offset);\n+      } else {\n+        BitUtil::SetBitsTo(out_valid, offset, length, true);\n+      }\n+    }\n+    Copier::CopyArray(array, out_values, offset, length);\n+  }\n+}\n+\n+struct CoalesceFunction : ScalarFunction {\n+  using ScalarFunction::ScalarFunction;\n+\n+  Result<const Kernel*> DispatchBest(std::vector<ValueDescr>* values) const override {\n+    RETURN_NOT_OK(CheckArity(*values));\n+    using arrow::compute::detail::DispatchExactImpl;\n+    if (auto kernel = DispatchExactImpl(this, *values)) return kernel;\n+    EnsureDictionaryDecoded(values);\n+    if (auto type = CommonNumeric(*values)) {\n+      ReplaceTypes(type, values);\n+    }\n+    if (auto kernel = DispatchExactImpl(this, *values)) return kernel;\n+    return arrow::compute::detail::NoMatchingKernel(this, *values);\n+  }\n+};\n+\n+// Implement a 'coalesce' (SQL) operator for any number of scalar inputs\n+Status ExecScalarCoalesce(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  for (const auto& datum : batch.values) {\n+    if (datum.scalar()->is_valid) {\n+      *out = datum;\n+      break;\n+    }\n+  }\n+  return Status::OK();\n+}\n+\n+// Implement 'coalesce' for any mix of scalar/array arguments for any fixed-width type\n+template <typename Type>\n+Status ExecArrayCoalesce(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  ArrayData* output = out->mutable_array();\n+  ARROW_ASSIGN_OR_RAISE(output->buffers[0], ctx->AllocateBitmap(batch.length));\n+  // Use output validity buffer as mask to decide what values to copy\n+  uint8_t* out_valid = output->buffers[0]->mutable_data();\n+  // Clear output buffer - no values are set initially\n+  std::memset(out_valid, 0x00, output->buffers[0]->size());\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  for (const auto& datum : batch.values) {\n+    if ((datum.is_scalar() && datum.scalar()->is_valid) ||\n+        (datum.is_array() && !datum.array()->MayHaveNulls())) {\n+      BitBlockCounter counter(out_valid, /*start_offset=*/0, batch.length);\n+      int64_t offset = 0;\n+      while (offset < batch.length) {\n+        const auto block = counter.NextWord();\n+        if (block.NoneSet()) {\n+          CopyValues<Type>(datum, out_valid, out_values, offset, block.length);\n+        } else if (!block.AllSet()) {\n+          for (int64_t j = 0; j < block.length; ++j) {\n+            if (!BitUtil::GetBit(out_valid, offset + j)) {\n+              CopyValues<Type>(datum, out_valid, out_values, offset + j,\n+                               /*length=*/1);\n+            }\n+          }\n+        }\n+        offset += block.length;\n+      }\n+      break;\n+    } else if (datum.is_array()) {\n+      const ArrayData& arr = *datum.array();\n+      BinaryBitBlockCounter counter(out_valid, /*start_offset=*/0, arr.buffers[0]->data(),\n+                                    arr.offset, batch.length);\n+      int64_t offset = 0;\n+      while (offset < batch.length) {\n+        const auto block = counter.NextNotAndWord();\n+        if (block.AllSet()) {\n+          CopyValues<Type>(datum, out_valid, out_values, offset, block.length);\n+        } else if (block.popcount) {\n+          for (int64_t j = 0; j < block.length; ++j) {\n+            if (!BitUtil::GetBit(out_valid, offset + j)) {\n+              CopyValues<Type>(datum, out_valid, out_values, offset + j,\n+                               /*length=*/1);\n+            }\n+          }\n+        }\n+        offset += block.length;\n+      }\n+    }\n+  }\n+  // Need to initialize any remaining null slots (uninitialized memory)\n+  BitBlockCounter counter(out_valid, /*start_offset=*/0, batch.length);\n+  int64_t offset = 0;\n+  auto bit_width = checked_cast<const FixedWidthType&>(*out->type()).bit_width();\n+  auto byte_width = BitUtil::BytesForBits(bit_width);\n+  while (offset < batch.length) {\n+    const auto block = counter.NextWord();\n+    if (block.NoneSet()) {\n+      if (bit_width == 1) {\n+        BitUtil::SetBitsTo(out_values, offset, block.length, false);\n+      } else {\n+        std::memset(out_values + offset, 0x00, byte_width * block.length);\n+      }\n+    } else if (!block.AllSet()) {\n+      for (int64_t j = 0; j < block.length; ++j) {\n+        if (BitUtil::GetBit(out_valid, offset + j)) continue;\n+        if (bit_width == 1) {\n+          BitUtil::ClearBit(out_values, offset + j);\n+        } else {\n+          std::memset(out_values + offset + j, 0x00, byte_width);\n+        }\n+      }\n+    }\n+    offset += block.length;\n+  }\n+  return Status::OK();\n+}\n+\n+template <typename Type, typename Enable = void>\n+struct CoalesceFunctor {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    for (const auto& datum : batch.values) {\n+      if (datum.is_array()) {\n+        return ExecArrayCoalesce<Type>(ctx, batch, out);\n+      }\n+    }\n+    return ExecScalarCoalesce(ctx, batch, out);\n+  }\n+};\n+\n+template <>\n+struct CoalesceFunctor<NullType> {\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    return Status::OK();\n+  }\n+};\n+\n+template <typename Type>\n+struct CoalesceFunctor<Type, enable_if_base_binary<Type>> {\n+  using offset_type = typename Type::offset_type;\n+  using BuilderType = typename TypeTraits<Type>::BuilderType;\n+  static Status Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    for (const auto& datum : batch.values) {\n+      if (datum.is_array()) {\n+        return ExecArray(ctx, batch, out);\n+      }\n+    }\n+    return ExecScalarCoalesce(ctx, batch, out);\n+  }\n+\n+  static Status ExecArray(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    // Special case: grab any leading non-null scalar or array arguments\n+    for (const auto& datum : batch.values) {\n+      if (datum.is_scalar()) {\n+        if (!datum.scalar()->is_valid) continue;\n+        ARROW_ASSIGN_OR_RAISE(\n+            *out, MakeArrayFromScalar(*datum.scalar(), batch.length, ctx->memory_pool()));\n+        return Status::OK();\n+      } else if (datum.is_array() && !datum.array()->MayHaveNulls()) {\n+        *out = datum;\n+        return Status::OK();\n+      }\n+      break;\n+    }\n+    ArrayData* output = out->mutable_array();\n+    BuilderType builder(batch[0].type(), ctx->memory_pool());\n+    RETURN_NOT_OK(builder.Reserve(batch.length));\n+    for (int64_t i = 0; i < batch.length; i++) {\n+      bool set = false;\n+      for (const auto& datum : batch.values) {\n+        if (datum.is_scalar()) {\n+          if (datum.scalar()->is_valid) {\n+            // TODO(ARROW-11936): use AppendScalar\n+            RETURN_NOT_OK(builder.Append(UnboxScalar<Type>::Unbox(*datum.scalar())));\n+            set = true;\n+            break;\n+          }\n+        } else {\n+          const ArrayData& source = *datum.array();\n+          if (!source.MayHaveNulls() ||\n+              BitUtil::GetBit(source.buffers[0]->data(), source.offset + i)) {\n+            const uint8_t* data = source.buffers[2]->data();\n+            const offset_type* offsets = source.GetValues<offset_type>(1);\n+            const offset_type offset0 = offsets[i];\n+            const offset_type offset1 = offsets[i + 1];\n+            RETURN_NOT_OK(builder.Append(data + offset0, offset1 - offset0));\n+            set = true;\n+            break;\n+          }\n+        }\n+      }\n+      if (!set) RETURN_NOT_OK(builder.AppendNull());\n+    }\n+    std::shared_ptr<Array> temp_output;\n+    RETURN_NOT_OK(builder.Finish(&temp_output));\n+    *output = *temp_output->data();\n+    // Builder type != logical type due to GenerateTypeAgnosticVarBinaryBase\n+    output->type = batch[0].type();\n+    return Status::OK();\n+  }\n+};\n+\n+void AddCoalesceKernel(const std::shared_ptr<ScalarFunction>& scalar_function,\n+                       detail::GetTypeId get_id, ArrayKernelExec exec) {\n+  ScalarKernel kernel(KernelSignature::Make({InputType(get_id.id)}, OutputType(FirstType),\n+                                            /*is_varargs=*/true),\n+                      exec);\n+  kernel.null_handling = NullHandling::COMPUTED_NO_PREALLOCATE;\n+  kernel.mem_allocation = MemAllocation::PREALLOCATE;\n\nReview comment:\n       I think we should always be able to preallocate the validity bitmap in addition to the data/offsets buffer, which will enable the preallocate_contiguous_ optimization for fixed width types.\r\n   ```suggestion\r\n     kernel.null_handling = NullHandling::COMPUTED_PREALLOCATE;\r\n     kernel.mem_allocation = MemAllocation::PREALLOCATE;\r\n     if (var width type) {\r\n       kernel.can_write_into_slices = false;\r\n     }\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-12T20:02:46.205+0000",
                    "updated": "2021-07-12T20:02:46.205+0000",
                    "started": "2021-07-12T20:02:46.205+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "621652",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/622177",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-879342845\n\n\n   > Trying an approach based on VisitSetBitRunsVoid\r\n   \r\n   IIUC this would require a varargs version of `OptionalBitBlockCounter` or `Bitmap::VisitWords`, which would probably be generally useful as varargs compute functions continue to proliferate\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-13T19:27:41.852+0000",
                    "updated": "2021-07-13T19:27:41.852+0000",
                    "started": "2021-07-13T19:27:41.852+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "622177",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/622225",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-879390143\n\n\n   Basically, there was a lot of overhead from the fallback loop of \"for offset in range(block size), if bit is set, copy one element\" because 1) the 'copy one element' function used CopyBitmap which has a *ton* of overhead for copying one bit and 2) unboxing the array every time was costly when done in a loop like that (e.g. the profiler showed that even Buffer::data()'s check for whether the buffer is on-CPU was hot). But now I've specialized things to avoid most of that overhead. \r\n   \r\n   The reason why I wanted something like VisitSetBitRunsVoid was to go a step further and always try to perform block copies instead of falling back to one-element-at-a-time-copies. But yes, then it needs to be able to combine two bitmaps with AndNot (we want runs of bits where !output_valid & input_valid)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-13T20:45:25.494+0000",
                    "updated": "2021-07-13T20:45:25.494+0000",
                    "started": "2021-07-13T20:45:25.494+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "622225",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/622226",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-879390751\n\n\n   I would kind of prefer to get all these kernels merged and consolidated before I start trying to microoptimize them, though, given they've been around for a while and all use similar helper code (that's now starting to diverge slightly once I look at optimizing).\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-13T20:46:21.182+0000",
                    "updated": "2021-07-13T20:46:21.182+0000",
                    "started": "2021-07-13T20:46:21.182+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "622226",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/622547",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-879985810\n\n\n   @ursabot please benchmark lang=C++\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-14T15:22:49.443+0000",
                    "updated": "2021-07-14T15:22:49.443+0000",
                    "started": "2021-07-14T15:22:49.443+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "622547",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/622548",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-879986122\n\n\n   Benchmark runs are scheduled for baseline = 9c6d4179fefdf995fd0b940a292b81947fe68035 and contender = e32cf48c8f5f38ed5bbf69eb5d2ea8eda43d2b98. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Skipped :warning: Provided benchmark filters do not have any benchmark groups to be executed on ec2-t3-xlarge-us-east-2] [ec2-t3-xlarge-us-east-2 (mimalloc)](https://conbench.ursa.dev/compare/runs/d391a5e50d69453b8c1648f74e28b5e1...0b2618a2ff3f4c8e879c59938408b00f/)\n   [Skipped :warning: Only ['Python', 'R'] langs are supported on ursa-i9-9960x] [ursa-i9-9960x (mimalloc)](https://conbench.ursa.dev/compare/runs/158e7a4062ba424aa32aab6410f2675f...354ae9f639ba47928a0c6e4c3781d22c/)\n   [Scheduled] [ursa-thinkcentre-m75q (mimalloc)](https://conbench.ursa.dev/compare/runs/4df834022c414dd39486a4bbca516589...f2036834887e4b4b8c6ef3cf6b65c8f6/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-14T15:23:12.611+0000",
                    "updated": "2021-07-14T15:23:12.611+0000",
                    "started": "2021-07-14T15:23:12.610+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "622548",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/622568",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot edited a comment on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-879986122\n\n\n   Benchmark runs are scheduled for baseline = 9c6d4179fefdf995fd0b940a292b81947fe68035 and contender = e32cf48c8f5f38ed5bbf69eb5d2ea8eda43d2b98. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Skipped :warning: Provided benchmark filters do not have any benchmark groups to be executed on ec2-t3-xlarge-us-east-2] [ec2-t3-xlarge-us-east-2 (mimalloc)](https://conbench.ursa.dev/compare/runs/d391a5e50d69453b8c1648f74e28b5e1...0b2618a2ff3f4c8e879c59938408b00f/)\n   [Skipped :warning: Only ['Python', 'R'] langs are supported on ursa-i9-9960x] [ursa-i9-9960x (mimalloc)](https://conbench.ursa.dev/compare/runs/158e7a4062ba424aa32aab6410f2675f...354ae9f639ba47928a0c6e4c3781d22c/)\n   [Finished :arrow_down:0.53% :arrow_up:0.05%] [ursa-thinkcentre-m75q (mimalloc)](https://conbench.ursa.dev/compare/runs/4df834022c414dd39486a4bbca516589...f2036834887e4b4b8c6ef3cf6b65c8f6/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-14T16:15:29.356+0000",
                    "updated": "2021-07-14T16:15:29.356+0000",
                    "started": "2021-07-14T16:15:29.355+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "622568",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/622650",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#discussion_r669873043\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_if_else.cc\n##########\n@@ -676,7 +677,339 @@ void AddPrimitiveIfElseKernels(const std::shared_ptr<ScalarFunction>& scalar_fun\n   }\n }\n \n-}  // namespace\n+// Helper to copy or broadcast fixed-width values between buffers.\n+template <typename Type, typename Enable = void>\n+struct CopyFixedWidth {};\n+template <>\n+struct CopyFixedWidth<BooleanType> {\n+  static void CopyScalar(const Scalar& scalar, const int64_t length,\n+                         uint8_t* raw_out_values, const int64_t out_offset) {\n+    const bool value = UnboxScalar<BooleanType>::Unbox(scalar);\n+    BitUtil::SetBitsTo(raw_out_values, out_offset, length, value);\n+  }\n+  static void CopyArray(const DataType&, const uint8_t* in_values,\n+                        const int64_t in_offset, const int64_t length,\n+                        uint8_t* raw_out_values, const int64_t out_offset) {\n+    arrow::internal::CopyBitmap(in_values, in_offset, length, raw_out_values, out_offset);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_number<Type>> {\n+  using CType = typename TypeTraits<Type>::CType;\n+  static void CopyScalar(const Scalar& scalar, const int64_t length,\n+                         uint8_t* raw_out_values, const int64_t out_offset) {\n+    CType* out_values = reinterpret_cast<CType*>(raw_out_values);\n+    const CType value = UnboxScalar<Type>::Unbox(scalar);\n+    std::fill(out_values + out_offset, out_values + out_offset + length, value);\n+  }\n+  static void CopyArray(const DataType&, const uint8_t* in_values,\n+                        const int64_t in_offset, const int64_t length,\n+                        uint8_t* raw_out_values, const int64_t out_offset) {\n+    std::memcpy(raw_out_values + out_offset * sizeof(CType),\n+                in_values + in_offset * sizeof(CType), length * sizeof(CType));\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_same<Type, FixedSizeBinaryType>> {\n+  static void CopyScalar(const Scalar& values, const int64_t length,\n+                         uint8_t* raw_out_values, const int64_t out_offset) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = raw_out_values + (width * out_offset);\n+    const auto& scalar = checked_cast<const FixedSizeBinaryScalar&>(values);\n+    // Scalar may have null value buffer\n+    if (!scalar.value) return;\n+    DCHECK_EQ(scalar.value->size(), width);\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, scalar.value->data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const DataType& type, const uint8_t* in_values,\n+                        const int64_t in_offset, const int64_t length,\n+                        uint8_t* raw_out_values, const int64_t out_offset) {\n+    const int32_t width = checked_cast<const FixedSizeBinaryType&>(type).byte_width();\n+    uint8_t* next = raw_out_values + (width * out_offset);\n+    std::memcpy(next, in_values + in_offset * width, length * width);\n+  }\n+};\n+template <typename Type>\n+struct CopyFixedWidth<Type, enable_if_decimal<Type>> {\n+  using ScalarType = typename TypeTraits<Type>::ScalarType;\n+  static void CopyScalar(const Scalar& values, const int64_t length,\n+                         uint8_t* raw_out_values, const int64_t out_offset) {\n+    const int32_t width =\n+        checked_cast<const FixedSizeBinaryType&>(*values.type).byte_width();\n+    uint8_t* next = raw_out_values + (width * out_offset);\n+    const auto& scalar = checked_cast<const ScalarType&>(values);\n+    const auto value = scalar.value.ToBytes();\n+    for (int i = 0; i < length; i++) {\n+      std::memcpy(next, value.data(), width);\n+      next += width;\n+    }\n+  }\n+  static void CopyArray(const DataType& type, const uint8_t* in_values,\n+                        const int64_t in_offset, const int64_t length,\n+                        uint8_t* raw_out_values, const int64_t out_offset) {\n+    const int32_t width = checked_cast<const FixedSizeBinaryType&>(type).byte_width();\n+    uint8_t* next = raw_out_values + (width * out_offset);\n+    std::memcpy(next, in_values + in_offset * width, length * width);\n+  }\n+};\n+// Copy fixed-width values from a scalar/array datum into an output values buffer\n+template <typename Type>\n+void CopyValues(const Datum& in_values, const int64_t in_offset, const int64_t length,\n+                uint8_t* out_valid, uint8_t* out_values, const int64_t out_offset) {\n+  if (in_values.is_scalar()) {\n+    const auto& scalar = *in_values.scalar();\n+    if (out_valid) {\n+      BitUtil::SetBitsTo(out_valid, out_offset, length, scalar.is_valid);\n+    }\n+    CopyFixedWidth<Type>::CopyScalar(scalar, length, out_values, out_offset);\n+  } else {\n+    const ArrayData& array = *in_values.array();\n+    if (out_valid) {\n+      if (array.MayHaveNulls()) {\n+        arrow::internal::CopyBitmap(array.buffers[0]->data(), array.offset + in_offset,\n+                                    length, out_valid, out_offset);\n+      } else {\n+        BitUtil::SetBitsTo(out_valid, out_offset, length, true);\n+      }\n+    }\n+    CopyFixedWidth<Type>::CopyArray(*array.type, array.buffers[1]->data(),\n+                                    array.offset + in_offset, length, out_values,\n+                                    out_offset);\n+  }\n+}\n+template <typename Type>\n+void CopyOneArrayValue(const DataType& type, const uint8_t* in_valid,\n+                       const uint8_t* in_values, const int64_t in_offset,\n+                       uint8_t* out_valid, uint8_t* out_values,\n+                       const int64_t out_offset) {\n+  if (out_valid) {\n+    BitUtil::SetBitTo(out_valid, out_offset,\n+                      !in_valid || BitUtil::GetBit(in_valid, in_offset));\n+  }\n+  CopyFixedWidth<Type>::CopyArray(type, in_values, in_offset, /*length=*/1, out_values,\n+                                  out_offset);\n+}\n+\n+struct CoalesceFunction : ScalarFunction {\n+  using ScalarFunction::ScalarFunction;\n+\n+  Result<const Kernel*> DispatchBest(std::vector<ValueDescr>* values) const override {\n+    RETURN_NOT_OK(CheckArity(*values));\n+    using arrow::compute::detail::DispatchExactImpl;\n+    if (auto kernel = DispatchExactImpl(this, *values)) return kernel;\n+    EnsureDictionaryDecoded(values);\n+    if (auto type = CommonNumeric(*values)) {\n+      ReplaceTypes(type, values);\n+    }\n+    if (auto kernel = DispatchExactImpl(this, *values)) return kernel;\n+    return arrow::compute::detail::NoMatchingKernel(this, *values);\n+  }\n+};\n+\n+// Implement a 'coalesce' (SQL) operator for any number of scalar inputs\n+Status ExecScalarCoalesce(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  for (const auto& datum : batch.values) {\n+    if (datum.scalar()->is_valid) {\n+      *out = datum;\n+      break;\n+    }\n+  }\n+  return Status::OK();\n+}\n+\n+// Implement 'coalesce' for any mix of scalar/array arguments for any fixed-width type\n+template <typename Type>\n+Status ExecArrayCoalesce(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  ArrayData* output = out->mutable_array();\n+  const int64_t out_offset = output->offset;\n+  // Use output validity buffer as mask to decide what values to copy\n+  uint8_t* out_valid = output->buffers[0]->mutable_data();\n+  // Clear output buffer - no values are set initially\n+  BitUtil::SetBitsTo(out_valid, out_offset, batch.length, false);\n+  uint8_t* out_values = output->buffers[1]->mutable_data();\n+  for (const auto& datum : batch.values) {\n+    if ((datum.is_scalar() && datum.scalar()->is_valid) ||\n+        (datum.is_array() && !datum.array()->MayHaveNulls())) {\n+      BitBlockCounter counter(out_valid, out_offset, batch.length);\n+      int64_t offset = 0;\n+      while (offset < batch.length) {\n+        const auto block = counter.NextWord();\n+        if (block.NoneSet()) {\n+          CopyValues<Type>(datum, offset, block.length, out_valid, out_values,\n+                           out_offset + offset);\n+        } else if (!block.AllSet()) {\n+          for (int64_t j = 0; j < block.length; ++j) {\n+            if (!BitUtil::GetBit(out_valid, out_offset + offset + j)) {\n+              CopyValues<Type>(datum, offset + j, 1, out_valid, out_values,\n+                               out_offset + offset + j);\n+            }\n+          }\n+        }\n+        offset += block.length;\n+      }\n+      break;\n+    } else if (datum.is_array()) {\n\nReview comment:\n       Could you de-nest some of this branching by extracting some functions and intersperse some whitespace and comments? This is a little difficult to read. Something like:\r\n   \r\n   ```suggestion\r\n       if ((datum.is_scalar() && datum.scalar()->is_valid) ||\r\n           (datum.is_array() && !datum.array()->MayHaveNulls())) {\r\n         // all-valid scalar or array\r\n         CopyValuesAllValid<Type>(datum, batch.length, out_valid, out_values, out_offset);\r\n         break;\r\n       }\r\n   \r\n       // null scalar; skip\r\n       if (datum.is_scalar()) continue;\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-14T19:00:43.923+0000",
                    "updated": "2021-07-14T19:00:43.923+0000",
                    "started": "2021-07-14T19:00:43.923+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "622650",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/622729",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-880197573\n\n\n   Broke up the main function a bit.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-14T20:47:20.305+0000",
                    "updated": "2021-07-14T20:47:20.305+0000",
                    "started": "2021-07-14T20:47:20.305+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "622729",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/623264",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-880976597\n\n\n   Rebased (wow, that was more painful than I wanted it to be)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-15T20:02:49.407+0000",
                    "updated": "2021-07-15T20:02:49.407+0000",
                    "started": "2021-07-15T20:02:49.406+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "623264",
                    "issueId": "13384941"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/worklog/623629",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10608:\nURL: https://github.com/apache/arrow/pull/10608#issuecomment-881494328\n\n\n   Rebased again to fix the conflict with the make_struct change.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-07-16T14:31:52.169+0000",
                    "updated": "2021-07-16T14:31:52.169+0000",
                    "started": "2021-07-16T14:31:52.168+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "623629",
                    "issueId": "13384941"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 13800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3691ef19[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@b59ee86[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6d635ca7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@298aa253[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@540514b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@4d7b428c[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3a8ab9e0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@46ee0cd8[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@41a3c747[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@56db92dd[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3971745f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@fcf3765[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 13800,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Jul 19 21:39:09 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-07-19T17:45:19.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13136/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2021-06-21T15:53:43.000+0000",
        "updated": "2021-08-09T15:38:57.000+0000",
        "timeoriginalestimate": null,
        "description": "Add a variadic scalar compute kernel that works like the SQL {{coalesce}} function. It should take arbitrarily many inputs of the same or compatible types and process them row-wise, returning the first non-null value in each row, or returning\u00a0{{null}} if there are no non-null values in the row.\u00a0\r\n\r\nFor example, in the case of 3 integer-type input arrays, this would take inputs:\r\n{code:java}\r\nArray<int32>         Array<int32>         Array<int32>\r\n[                    [                    [\r\n  null,                2,                   3,\r\n  4,                   null,                6,\r\n  null,                null,                9,\r\n  null                 null                 null\r\n]                    ]                    ]\r\n{code}\r\nand return output:\r\n{code:java}\r\nArray<int32>\r\n[ \r\n  2,\r\n  4,\r\n  9,\r\n  null\r\n] \r\n{code}\r\nThis should accept scalars and recycle their values.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 13800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add a \"coalesce\" variadic scalar kernel",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/comment/17383482",
                    "id": "17383482",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 10608\n[https://github.com/apache/arrow/pull/10608]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-07-19T17:45:19.425+0000",
                    "updated": "2021-07-19T17:45:19.425+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/comment/17383603",
                    "id": "17383603",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=icook",
                        "name": "icook",
                        "key": "icook",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=icook&avatarId=29388",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=icook&avatarId=29388",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=icook&avatarId=29388",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=icook&avatarId=29388"
                        },
                        "displayName": "Ian Cook",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "This kernel currently converts dictionaries to strings. Are there any other type limitations to note?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=icook",
                        "name": "icook",
                        "key": "icook",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=icook&avatarId=29388",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=icook&avatarId=29388",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=icook&avatarId=29388",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=icook&avatarId=29388"
                        },
                        "displayName": "Ian Cook",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-07-19T21:18:40.627+0000",
                    "updated": "2021-07-19T21:18:40.627+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/comment/17383605",
                    "id": "17383605",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "It'll unpack any dictionary, and it only supports binary-like variable width types. It should have fairly complete support for fixed-width types (except fixed-width list). Let me file a JIRA for complete type support.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-07-19T21:21:16.591+0000",
                    "updated": "2021-07-19T21:21:16.591+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/comment/17383606",
                    "id": "17383606",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Filed ARROW-13390.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-07-19T21:22:32.175+0000",
                    "updated": "2021-07-19T21:22:32.175+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13384941/comment/17383617",
                    "id": "17383617",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=icook",
                        "name": "icook",
                        "key": "icook",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=icook&avatarId=29388",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=icook&avatarId=29388",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=icook&avatarId=29388",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=icook&avatarId=29388"
                        },
                        "displayName": "Ian Cook",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Thanks!",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=icook",
                        "name": "icook",
                        "key": "icook",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=icook&avatarId=29388",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=icook&avatarId=29388",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=icook&avatarId=29388",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=icook&avatarId=29388"
                        },
                        "displayName": "Ian Cook",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-07-19T21:39:09.287+0000",
                    "updated": "2021-07-19T21:39:09.287+0000"
                }
            ],
            "maxResults": 5,
            "total": 5,
            "startAt": 0
        },
        "customfield_12311820": "0|z0s55s:",
        "customfield_12314139": null
    }
}