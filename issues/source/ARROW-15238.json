{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13420453",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453",
    "key": "ARROW-15238",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351051",
                "id": "12351051",
                "description": "",
                "name": "8.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-05-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available",
            "query-engine"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12630252",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12630252",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13420903",
                    "key": "ARROW-15257",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420903",
                    "fields": {
                        "summary": "[C++] Simplify ExecPlan's C++ interface",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jvanstraten",
            "name": "jvanstraten",
            "key": "JIRAUSER282962",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER282962&avatarId=48950",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER282962&avatarId=48950",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER282962&avatarId=48950",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER282962&avatarId=48950"
            },
            "displayName": "Jeroen van Straten",
            "active": true,
            "timeZone": "Europe/Amsterdam"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 81000,
            "total": 81000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 81000,
            "total": 81000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15238/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 135,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/712925",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] removed a comment on pull request #11707:\nURL: https://github.com/apache/arrow/pull/11707#issuecomment-969195700\n\n\n   <!--\n     Licensed to the Apache Software Foundation (ASF) under one\n     or more contributor license agreements.  See the NOTICE file\n     distributed with this work for additional information\n     regarding copyright ownership.  The ASF licenses this file\n     to you under the Apache License, Version 2.0 (the\n     \"License\"); you may not use this file except in compliance\n     with the License.  You may obtain a copy of the License at\n   \n       http://www.apache.org/licenses/LICENSE-2.0\n   \n     Unless required by applicable law or agreed to in writing,\n     software distributed under the License is distributed on an\n     \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     KIND, either express or implied.  See the License for the\n     specific language governing permissions and limitations\n     under the License.\n   -->\n   \n   Thanks for opening a pull request!\n   \n   If this is not a [minor PR](https://github.com/apache/arrow/blob/master/CONTRIBUTING.md#Minor-Fixes). Could you open an issue for this pull request on JIRA? https://issues.apache.org/jira/browse/ARROW\n   \n   Opening JIRAs ahead of time contributes to the [Openness](http://theapacheway.com/open/#:~:text=Openness%20allows%20new%20users%20the,must%20happen%20in%20the%20open.) of the Apache Arrow project.\n   \n   Then could you also rename pull request title in the following format?\n   \n       ARROW-${JIRA_ID}: [${COMPONENT}] ${SUMMARY}\n   \n   or\n   \n       MINOR: [${COMPONENT}] ${SUMMARY}\n   \n   See also:\n   \n     * [Other pull requests](https://github.com/apache/arrow/pulls/)\n     * [Contribution Guidelines - How to contribute patches](https://arrow.apache.org/docs/developers/contributing.html#how-to-contribute-patches)\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-21T15:02:42.615+0000",
                    "updated": "2022-01-21T15:02:42.615+0000",
                    "started": "2022-01-21T15:02:42.615+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "712925",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/712930",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11707:\nURL: https://github.com/apache/arrow/pull/11707#issuecomment-1018594868\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-21T15:09:42.254+0000",
                    "updated": "2022-01-21T15:09:42.254+0000",
                    "started": "2022-01-21T15:09:42.253+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "712930",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/712947",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11707:\nURL: https://github.com/apache/arrow/pull/11707#discussion_r789778964\n\n\n\n##########\nFile path: cpp/src/arrow/CMakeLists.txt\n##########\n@@ -712,6 +712,10 @@ if(ARROW_COMPUTE)\n   add_subdirectory(compute)\n endif()\n \n+if(ARROW_ENGINE)\n\nReview comment:\n       `ARROW_ENGINE` does now depend on datasets, where a scan node is used to wrap `substrait::ReadRel`s\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-21T15:57:19.414+0000",
                    "updated": "2022-01-21T15:57:19.414+0000",
                    "started": "2022-01-21T15:57:19.414+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "712947",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/712966",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #11707:\nURL: https://github.com/apache/arrow/pull/11707#discussion_r789817420\n\n\n\n##########\nFile path: dev/archery/archery/lang/cpp.py\n##########\n@@ -42,7 +42,7 @@ def __init__(self,\n                  cc=None, cxx=None, cxx_flags=None,\n                  build_type=None, warn_level=None,\n                  cpp_package_prefix=None, install_prefix=None, use_conda=None,\n-                 build_static=False, build_shared=True, build_unity=True,\n+                 build_static=True, build_shared=True, build_unity=True,\n\nReview comment:\n       I only changed this for consistency with the cmake defaults, which these otherwise follow\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-21T16:38:27.185+0000",
                    "updated": "2022-01-21T16:38:27.185+0000",
                    "started": "2022-01-21T16:38:27.185+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "712966",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/716646",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten opened a new pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279\n\n\n   Continuation of https://github.com/apache/arrow/pull/11707. I'm taking over from @bkietz for now because he's unavailable right now for personal reasons.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-27T20:02:39.141+0000",
                    "updated": "2022-01-27T20:02:39.141+0000",
                    "started": "2022-01-27T20:02:39.141+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "716646",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/716647",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#issuecomment-1023592089\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-27T20:03:11.818+0000",
                    "updated": "2022-01-27T20:03:11.818+0000",
                    "started": "2022-01-27T20:03:11.818+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "716647",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/716648",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on pull request #11707:\nURL: https://github.com/apache/arrow/pull/11707#issuecomment-1023594199\n\n\n   This can be closed, see #12279 for continuation.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-27T20:05:46.043+0000",
                    "updated": "2022-01-27T20:05:46.043+0000",
                    "started": "2022-01-27T20:05:46.042+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "716648",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/716780",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace closed pull request #11707:\nURL: https://github.com/apache/arrow/pull/11707\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-27T23:44:23.226+0000",
                    "updated": "2022-01-27T23:44:23.226+0000",
                    "started": "2022-01-27T23:44:23.226+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "716780",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/718417",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#discussion_r796032104\n\n\n\n##########\nFile path: cpp/cmake_modules/DefineOptions.cmake\n##########\n@@ -478,6 +478,13 @@ advised that if this is enabled 'install' will fail silently on components;\\\n that have not been built\"\n                 OFF)\n \n+  set(ARROW_SUBSTRAIT_REPO_AND_TAG_DEFAULT\n+      \"https://github.com/substrait-io/substrait e1b4c04a1b518912f4c4065b16a1b2c0ac8e14cf\"\n+  )\n+  define_option_string(ARROW_SUBSTRAIT_REPO_AND_TAG\n+                       \"Custom 'repository_url tag' for generating substrait accessors\"\n+                       \"${ARROW_SUBSTRAIT_REPO_AND_TAG_DEFAULT}\")\n+\n\nReview comment:\n       Would this be better as two options?  I'd face a little anxiety setting this as there is a space in the option.  Also, I'm not sure what \"generating substrait accessors\" means.  Can we say something like \"for downloading substrait source\"?\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n+};\n+\n+int main(int argc, char** argv) {\n+  // Plans arrive at the consumer serialized in a substrait-formatted Buffer\n+  auto maybe_serialized_plan = GetSubstraitFromServer().result();\n+  ABORT_ON_FAILURE(maybe_serialized_plan.status());\n+  std::shared_ptr<arrow::Buffer> serialized_plan =\n+      std::move(maybe_serialized_plan).ValueOrDie();\n+\n+  // Print the received plan to stdout as JSON\n+  arrow::Result<std::string> maybe_plan_json =\n+      eng::internal::SubstraitToJSON(\"Plan\", *serialized_plan);\n+  ABORT_ON_FAILURE(maybe_plan_json.status());\n+  std::cout << std::string('#', 50) << \" received substrait::Plan:\" << std::endl;\n+  std::cout << maybe_plan_json.ValueOrDie() << std::endl;\n+\n+  // Deserializing a plan requires a factory for consumers: each time a sink node is\n+  // deserialized, a consumer is constructed into which its batches will be piped.\n+  std::vector<std::shared_ptr<cp::SinkNodeConsumer>> consumers;\n+  std::function<std::shared_ptr<cp::SinkNodeConsumer>()> consumer_factory = [&] {\n+    // All batches produced by the plan will be fed into IgnoringConsumers:\n+    auto tag = consumers.size();\n+    consumers.emplace_back(new IgnoringConsumer{tag});\n+    return consumers.back();\n+  };\n+\n+  // NOTE Although most of the Deserialize functions require a const ExtensionSet& to\n+  // resolve extension references, a Plan is what we use to construct that ExtensionSet.\n+  // (It should be an optional output later.) In particular, it does not need to be kept\n+  // alive nor does the serialized plan- none of the arrow:: objects in the output will\n+  // contain references to memory owned by either.\n\nReview comment:\n       This is something of an unsatisfactory explanation for me.\r\n   \r\n   First of all, I think many users of this example will be of the mindset: \"I have a thingy that generates substrait plans and I want to resolve those plans into data\".  These users don't actually know the details of substrait and they have no idea what an extension set could possible even be referring to.\r\n   \r\n   Honestly, even users who are roughly familiar with substrait as a protocol (but haven't had to write a producer or consumer) probably gloss over all the complex details of extension sets.\r\n   \r\n   Since this is an introductory example, and `extension_set_out` is optional, you could omit the discussion entirely, especially since we already call out that it is safe to drop the serialized_plan.\r\n   \n\n##########\nFile path: cpp/src/arrow/engine/simple_extension_type_internal.h\n##########\n@@ -0,0 +1,183 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/extension_type.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+template <const util::string_view& kExtensionName, typename Params,\n\nReview comment:\n       This is a very nifty bit of metaprogramming however it is going to be hard to understand at a glance.  Can we document this helper?\r\n   \r\n   For example, it appears that params can be an arbitrary struct but must it be a flat struct?  We should probably mention that we are encoding it as a simple pseduo-JSON object (I say pseduo-JSON because any string properties won't have their enclosing double quotes and it will encode booleans as numbers).  Also, at some point down the road, we will need to create Substrait YAML to publish for all these extension types.  In addition, these should probably all be candidates for @rok 's \"well-known extension types\" once that is off the ground.\r\n   \r\n   Also, what kind of data types can I put into my struct?  From a naive glance maybe anything that supports `std::stringstream >> value`\n\n##########\nFile path: format/substrait/extension_types.yaml\n##########\n@@ -0,0 +1,121 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+# substrait::{ExtensionTypeVariation, ExtensionType}s\n+# for wrapping types which appear in the arrow type system but\n+# are not first-class in substrait. These include:\n+# - null\n+# - unsigned integers\n+# - half-precision floating point numbers\n+# - 32 bit times and dates\n+# - timestamps with units other than microseconds\n+# - timestamps with timezones other than UTC\n+# - 256 bit decimals\n+# - sparse and dense unions\n+# - dictionary encoded types\n+# - durations\n+# - string and binary with 64 bit offsets\n+# - list with 64 bit offsets\n+# - interval<months: i32>\n+# - interval<days: i32, millis: i32>\n+# - interval<months: i32, days: i32, nanos: i64>\n+# - arrow::ExtensionTypes\n+\n+# FIXME these extension types are not parameterizable, which means among\n+# other things that we can't declare dictionary type here at all since\n+# we'd have to declare a different dictionary type for all encoded types\n+# (but that is an infinite space). Similarly, do we need to declare a\n+# timestamp variation for all possible timezone strings?\n+#\n+# Ultimately these declarations are a promise which needs to be backed by\n+# equivalent serde in c++. For example, consider u8: when serializing to\n+# substrait, we need to wrap instances of arrow::uint8 into the type\n+# variation listed below. It would be ideal if we could SinglePointOfTruth\n+# this correspondence; either generating c++ from the YAML or YAML from the\n+# c++.\n+#\n+# At present (AFAICT) it's not valid to make this user extensible because\n+# even if a user adds their custom scalar function to the registry *and*\n+# defines the mapping from that scalar function to a substrait::ExtensionFunction\n+# the corresponding YAML doesn't exist at any URI and so it can't be used in\n+# substrait. Perhaps we could still help that case by providing a tool to\n+# generate YAML from functions; that'd simplify the lives of people trying to\n+# write arrow::compute::Functions to \"define the function and if you want to\n+# reference it from substrait generate this YAML and put it at some URI\".\n+#\n+# In any case for the foreseeable future generation would be far too brittle;\n+# URIs will not be accessed by anything but humans and the YAML is effectively\n+# structured documentation. Thus extenders should pass the URI in the same way\n+# they pass a description string; it's opaque to anything in arrow.\n+#\n+# We'll need a global mapping which contains:\n+#  arrow::uint8 <-> {\n+#   uri: \"https://github.com/apache/arrow/blob//format/substrait/extension_types.yaml\",\n+#   name: \"u8\"\n+#  }\n+#\n+# And additionally convenient builders for subsets of that mapping during serde:\n+#  arrow::uint8 <-> reference to anchor\n+#\n+# Worth noting: it's valid to have multiple ExtensionFunctions with the same name,\n+# as long as all impls' mangled (\"compound\") names are unique.\n+# Also worth noting: Options may only be enumerations. This will get strange with\n+# functions like is_in, where we'll have to require that one argument is a literal\n+# list or something.\n+\n+type_variations:\n+  - parent: i8\n+    name: u8\n+    description: an unsigned 8 bit integer\n+    functions: SEPARATE\n+  - parent: i16\n+    name: u16\n+    description: an unsigned 16 bit integer\n+    functions: SEPARATE\n+  - parent: i32\n+    name: u32\n+    description: an unsigned 32 bit integer\n+    functions: SEPARATE\n+  - parent: i32\n+    name: u32\n+    description: an unsigned 32 bit integer\n+    functions: SEPARATE\n\nReview comment:\n       ```suggestion\r\n   ```\r\n   Looks like a duplicate entry\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n\nReview comment:\n       ```suggestion\r\n   ```\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n\nReview comment:\n       Can we put the main method at the bottom of the file so we don't need this?\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n+};\n+\n+int main(int argc, char** argv) {\n+  // Plans arrive at the consumer serialized in a substrait-formatted Buffer\n+  auto maybe_serialized_plan = GetSubstraitFromServer().result();\n+  ABORT_ON_FAILURE(maybe_serialized_plan.status());\n+  std::shared_ptr<arrow::Buffer> serialized_plan =\n+      std::move(maybe_serialized_plan).ValueOrDie();\n+\n+  // Print the received plan to stdout as JSON\n+  arrow::Result<std::string> maybe_plan_json =\n+      eng::internal::SubstraitToJSON(\"Plan\", *serialized_plan);\n+  ABORT_ON_FAILURE(maybe_plan_json.status());\n+  std::cout << std::string('#', 50) << \" received substrait::Plan:\" << std::endl;\n+  std::cout << maybe_plan_json.ValueOrDie() << std::endl;\n+\n+  // Deserializing a plan requires a factory for consumers: each time a sink node is\n+  // deserialized, a consumer is constructed into which its batches will be piped.\n+  std::vector<std::shared_ptr<cp::SinkNodeConsumer>> consumers;\n+  std::function<std::shared_ptr<cp::SinkNodeConsumer>()> consumer_factory = [&] {\n+    // All batches produced by the plan will be fed into IgnoringConsumers:\n+    auto tag = consumers.size();\n+    consumers.emplace_back(new IgnoringConsumer{tag});\n+    return consumers.back();\n+  };\n+\n+  // NOTE Although most of the Deserialize functions require a const ExtensionSet& to\n+  // resolve extension references, a Plan is what we use to construct that ExtensionSet.\n+  // (It should be an optional output later.) In particular, it does not need to be kept\n+  // alive nor does the serialized plan- none of the arrow:: objects in the output will\n+  // contain references to memory owned by either.\n+  auto maybe_decls = eng::DeserializePlan(*serialized_plan, consumer_factory);\n+  ABORT_ON_FAILURE(maybe_decls.status());\n+  std::vector<cp::Declaration> decls = std::move(maybe_decls).ValueOrDie();\n+\n+  // It's safe to drop the serialized plan; we don't leave references to its memory\n+  serialized_plan.reset();\n+\n+  // Construct an empty plan (note: configure Function registry and ThreadPool here)\n+  auto maybe_plan = cp::ExecPlan::Make();\n+  ABORT_ON_FAILURE(maybe_plan.status());\n+  std::shared_ptr<cp::ExecPlan> plan = std::move(maybe_plan).ValueOrDie();\n+\n+  for (const cp::Declaration& decl : decls) {\n+    // Add decl to plan (note: configure ExecNode registry here)\n+    ABORT_ON_FAILURE(decl.AddToPlan(plan.get()).status());\n+  }\n+\n+  // Validate the plan and print it to stdout\n+  ABORT_ON_FAILURE(plan->Validate());\n+  std::cout << std::string('#', 50) << \" produced arrow::ExecPlan:\" << std::endl;\n+  std::cout << plan->ToString() << std::endl;\n+\n+  // Start the plan...\n+  std::cout << std::string('#', 50) << \" consuming batches:\" << std::endl;\n+  ABORT_ON_FAILURE(plan->StartProducing());\n+\n+  // ... and wait for it to finish\n+  ABORT_ON_FAILURE(plan->finished().status());\n+  return EXIT_SUCCESS;\n+}\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer() {\n\nReview comment:\n       I don't see a sink?  How is this going to work?  Or does each relation have an implicit sink?\r\n   \r\n   If it is the latter (implicit sink) I feel we should mention that in the example when we are talking about the factory of consumers (and one could even name it `RelationConsumer` instead of `SinkNodeConsumer` maybe to avoid the overloaded terminology)\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n\nReview comment:\n       Can we document this a little, \"A unique label for instances to help distinguish logging output if a plan has multiple sinks\"\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n+};\n+\n+int main(int argc, char** argv) {\n+  // Plans arrive at the consumer serialized in a substrait-formatted Buffer\n+  auto maybe_serialized_plan = GetSubstraitFromServer().result();\n+  ABORT_ON_FAILURE(maybe_serialized_plan.status());\n+  std::shared_ptr<arrow::Buffer> serialized_plan =\n+      std::move(maybe_serialized_plan).ValueOrDie();\n+\n+  // Print the received plan to stdout as JSON\n+  arrow::Result<std::string> maybe_plan_json =\n+      eng::internal::SubstraitToJSON(\"Plan\", *serialized_plan);\n+  ABORT_ON_FAILURE(maybe_plan_json.status());\n+  std::cout << std::string('#', 50) << \" received substrait::Plan:\" << std::endl;\n+  std::cout << maybe_plan_json.ValueOrDie() << std::endl;\n+\n+  // Deserializing a plan requires a factory for consumers: each time a sink node is\n+  // deserialized, a consumer is constructed into which its batches will be piped.\n+  std::vector<std::shared_ptr<cp::SinkNodeConsumer>> consumers;\n+  std::function<std::shared_ptr<cp::SinkNodeConsumer>()> consumer_factory = [&] {\n+    // All batches produced by the plan will be fed into IgnoringConsumers:\n+    auto tag = consumers.size();\n+    consumers.emplace_back(new IgnoringConsumer{tag});\n+    return consumers.back();\n+  };\n+\n+  // NOTE Although most of the Deserialize functions require a const ExtensionSet& to\n+  // resolve extension references, a Plan is what we use to construct that ExtensionSet.\n+  // (It should be an optional output later.) In particular, it does not need to be kept\n+  // alive nor does the serialized plan- none of the arrow:: objects in the output will\n+  // contain references to memory owned by either.\n+  auto maybe_decls = eng::DeserializePlan(*serialized_plan, consumer_factory);\n\nReview comment:\n       For a code example we should avoid `auto` when calling our own methods as I think it is possible people may be scanning these without an IDE.\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n+};\n+\n+int main(int argc, char** argv) {\n+  // Plans arrive at the consumer serialized in a substrait-formatted Buffer\n+  auto maybe_serialized_plan = GetSubstraitFromServer().result();\n+  ABORT_ON_FAILURE(maybe_serialized_plan.status());\n+  std::shared_ptr<arrow::Buffer> serialized_plan =\n+      std::move(maybe_serialized_plan).ValueOrDie();\n\nReview comment:\n       One bonus of using `DoMain` is we can write all this as:\r\n   \r\n   ```\r\n   ARROW_ASSIGN_OR_RAISE(std::shared_ptr<arrow::Buffer> serialized_plan, GetSubstraitFromServer());\r\n   ```\n\n##########\nFile path: cpp/cmake_modules/DefineOptions.cmake\n##########\n@@ -225,7 +225,7 @@ if(\"${CMAKE_SOURCE_DIR}\" STREQUAL \"${CMAKE_CURRENT_SOURCE_DIR}\")\n \n   define_option(ARROW_DATASET \"Build the Arrow Dataset Modules\" OFF)\n \n-  define_option(ARROW_ENGINE \"Build the Arrow Execution Engine\" OFF)\n+  define_option(ARROW_ENGINE \"Build the Arrow Query Engine Module\" OFF)\n\nReview comment:\n       At the risk of bike shedding on names (apologies if this was in the previous PR), I have been liking the old name of \"streaming execution engine\".  Given that this module won't really process traditional \"queries\" directly (e.g. SQL) the name \"execution engine\" might help to distinguish things like \"there is no planner\" and \"you can't speak SQL to this\".\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n+};\n+\n+int main(int argc, char** argv) {\n+  // Plans arrive at the consumer serialized in a substrait-formatted Buffer\n+  auto maybe_serialized_plan = GetSubstraitFromServer().result();\n+  ABORT_ON_FAILURE(maybe_serialized_plan.status());\n+  std::shared_ptr<arrow::Buffer> serialized_plan =\n+      std::move(maybe_serialized_plan).ValueOrDie();\n+\n+  // Print the received plan to stdout as JSON\n+  arrow::Result<std::string> maybe_plan_json =\n+      eng::internal::SubstraitToJSON(\"Plan\", *serialized_plan);\n+  ABORT_ON_FAILURE(maybe_plan_json.status());\n+  std::cout << std::string('#', 50) << \" received substrait::Plan:\" << std::endl;\n+  std::cout << maybe_plan_json.ValueOrDie() << std::endl;\n+\n+  // Deserializing a plan requires a factory for consumers: each time a sink node is\n+  // deserialized, a consumer is constructed into which its batches will be piped.\n+  std::vector<std::shared_ptr<cp::SinkNodeConsumer>> consumers;\n+  std::function<std::shared_ptr<cp::SinkNodeConsumer>()> consumer_factory = [&] {\n+    // All batches produced by the plan will be fed into IgnoringConsumers:\n+    auto tag = consumers.size();\n+    consumers.emplace_back(new IgnoringConsumer{tag});\n+    return consumers.back();\n+  };\n+\n+  // NOTE Although most of the Deserialize functions require a const ExtensionSet& to\n+  // resolve extension references, a Plan is what we use to construct that ExtensionSet.\n+  // (It should be an optional output later.) In particular, it does not need to be kept\n+  // alive nor does the serialized plan- none of the arrow:: objects in the output will\n+  // contain references to memory owned by either.\n+  auto maybe_decls = eng::DeserializePlan(*serialized_plan, consumer_factory);\n+  ABORT_ON_FAILURE(maybe_decls.status());\n+  std::vector<cp::Declaration> decls = std::move(maybe_decls).ValueOrDie();\n+\n+  // It's safe to drop the serialized plan; we don't leave references to its memory\n+  serialized_plan.reset();\n+\n+  // Construct an empty plan (note: configure Function registry and ThreadPool here)\n\nReview comment:\n       It is a rather unfortunate (though maybe unavoidable) fact that both Substrait and Arrow have something called a \"plan\" but a Substrait \"plan\" does not deserialize into an Arrow \"plan\".  This \"create an empty plan\" step feels a little bit silly for the common use case.  Can we create two deserialization methods?\r\n   \r\n   `eng::DeserializePlan(...)` returns `Result<cp::ExecPlan>` while `eng::DeserializePlanAsFragment` returns `Result<std::vector<cp::Declaration>>`?\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n\nReview comment:\n       Minor nit: Another potential bike shedding topic but it just seems weird that:\r\n   \r\n   In order to use the \"consumer\" we need to create \"consumers\".\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n\nReview comment:\n       ```suggestion\r\n   namespace eng = arrow::engine;\r\n   namespace cp = arrow::compute;\r\n   ```\r\n   I'm pretty sure we can get away without the leading colons.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n\nReview comment:\n       Would it be more appropriate to add a constructor in `scalar.h`:\r\n   \r\n   ```\r\n   FixedSizeBinaryScalar::FixedSizeBinaryScalar(const std::string&);\r\n   ```\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n+};\n+\n+int main(int argc, char** argv) {\n+  // Plans arrive at the consumer serialized in a substrait-formatted Buffer\n\nReview comment:\n       Minor nit: \"substrait-formatted buffer\" is a little vague.  Maybe something like, \"The consumer accepts Substrait plans expressed with protobuf serialization.  The consumer accepts both the JSON protobuf format and the binary protobuf format.\"\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n\nReview comment:\n       Minor nit: When writing examples, rather than introducing a new macro I try and write my main method like this...\r\n   \r\n   ```\r\n   arrow::Status DoMain() {\r\n     /// ...\r\n   }\r\n   \r\n   int main() {\r\n     arrow::Status status = DoMain();\r\n     if (!status.ok()) {\r\n       std::cerr << \"An error occurred: \" << status.message() << std::endl;\r\n       return EXIT_FAILURE;\r\n     } else {\r\n       return EXIT_SUCCESS;\r\n     }\r\n   }\r\n   ```\r\n   \r\n   That being said, the abort has the advantage of informing a bit more precisely where the error happened.  I'm probably fine either way.\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n\nReview comment:\n       ```suggestion\r\n   #include <arrow/engine/api.h>\r\n   ```\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n+};\n+\n+int main(int argc, char** argv) {\n+  // Plans arrive at the consumer serialized in a substrait-formatted Buffer\n+  auto maybe_serialized_plan = GetSubstraitFromServer().result();\n+  ABORT_ON_FAILURE(maybe_serialized_plan.status());\n+  std::shared_ptr<arrow::Buffer> serialized_plan =\n+      std::move(maybe_serialized_plan).ValueOrDie();\n+\n+  // Print the received plan to stdout as JSON\n+  arrow::Result<std::string> maybe_plan_json =\n+      eng::internal::SubstraitToJSON(\"Plan\", *serialized_plan);\n+  ABORT_ON_FAILURE(maybe_plan_json.status());\n+  std::cout << std::string('#', 50) << \" received substrait::Plan:\" << std::endl;\n+  std::cout << maybe_plan_json.ValueOrDie() << std::endl;\n+\n+  // Deserializing a plan requires a factory for consumers: each time a sink node is\n+  // deserialized, a consumer is constructed into which its batches will be piped.\n+  std::vector<std::shared_ptr<cp::SinkNodeConsumer>> consumers;\n+  std::function<std::shared_ptr<cp::SinkNodeConsumer>()> consumer_factory = [&] {\n+    // All batches produced by the plan will be fed into IgnoringConsumers:\n+    auto tag = consumers.size();\n+    consumers.emplace_back(new IgnoringConsumer{tag});\n+    return consumers.back();\n+  };\n+\n+  // NOTE Although most of the Deserialize functions require a const ExtensionSet& to\n+  // resolve extension references, a Plan is what we use to construct that ExtensionSet.\n+  // (It should be an optional output later.) In particular, it does not need to be kept\n+  // alive nor does the serialized plan- none of the arrow:: objects in the output will\n+  // contain references to memory owned by either.\n+  auto maybe_decls = eng::DeserializePlan(*serialized_plan, consumer_factory);\n+  ABORT_ON_FAILURE(maybe_decls.status());\n+  std::vector<cp::Declaration> decls = std::move(maybe_decls).ValueOrDie();\n+\n+  // It's safe to drop the serialized plan; we don't leave references to its memory\n+  serialized_plan.reset();\n+\n+  // Construct an empty plan (note: configure Function registry and ThreadPool here)\n+  auto maybe_plan = cp::ExecPlan::Make();\n+  ABORT_ON_FAILURE(maybe_plan.status());\n+  std::shared_ptr<cp::ExecPlan> plan = std::move(maybe_plan).ValueOrDie();\n+\n+  for (const cp::Declaration& decl : decls) {\n+    // Add decl to plan (note: configure ExecNode registry here)\n+    ABORT_ON_FAILURE(decl.AddToPlan(plan.get()).status());\n+  }\n+\n+  // Validate the plan and print it to stdout\n+  ABORT_ON_FAILURE(plan->Validate());\n+  std::cout << std::string('#', 50) << \" produced arrow::ExecPlan:\" << std::endl;\n+  std::cout << plan->ToString() << std::endl;\n+\n+  // Start the plan...\n+  std::cout << std::string('#', 50) << \" consuming batches:\" << std::endl;\n+  ABORT_ON_FAILURE(plan->StartProducing());\n+\n+  // ... and wait for it to finish\n+  ABORT_ON_FAILURE(plan->finished().status());\n+  return EXIT_SUCCESS;\n+}\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer() {\n+  // Emulate server interaction by parsing hard coded JSON\n+  return eng::internal::SubstraitFromJSON(\"Plan\", R\"({\n+    \"relations\": [\n+      {\"rel\": {\n+        \"read\": {\n+          \"base_schema\": {\n+            \"struct\": {\n+              \"types\": [ {\"i64\": {}}, {\"bool\": {}} ]\n+            },\n+            \"names\": [\"i\", \"b\"]\n+          },\n+          \"filter\": {\n+            \"selection\": {\n+              \"directReference\": {\n+                \"structField\": {\n+                  \"field\": 1\n+                }\n+              }\n+            }\n+          },\n+          \"local_files\": {\n+            \"items\": [\n+              {\n+                \"uri_file\": \"file:///tmp/dat1.parquet\",\n+                \"format\": \"FILE_FORMAT_PARQUET\"\n+              },\n+              {\n+                \"uri_file\": \"file:///tmp/dat2.parquet\",\n+                \"format\": \"FILE_FORMAT_PARQUET\"\n+              }\n+            ]\n+          }\n+        }\n+      }}\n+    ],\n+    \"extension_uris\": [\n+      {\n+        \"extension_uri_anchor\": 7,\n+        \"uri\": \"https://github.com/apache/arrow/blob/master/format/substrait/extension_types.yaml\"\n+      }\n+    ],\n+    \"extensions\": [\n+      {\"extension_type\": {\n+        \"extension_uri_reference\": 7,\n+        \"type_anchor\": 42,\n+        \"name\": \"null\"\n+      }},\n+      {\"extension_type_variation\": {\n+        \"extension_uri_reference\": 7,\n+        \"type_variation_anchor\": 23,\n+        \"name\": \"u8\"\n+      }},\n+      {\"extension_function\": {\n+        \"extension_uri_reference\": 7,\n+        \"function_anchor\": 42,\n+        \"name\": \"add\"\n+      }}\n+    ]\n\nReview comment:\n       For an example plan this is a little confusing as we never reference `null`, `u8`, or `add` in our plan yet it also doesn't feel like this is the complete set of potential extension types / functions.\n\n##########\nFile path: cpp/src/arrow/array/builder_base.h\n##########\n@@ -286,13 +287,27 @@ ARROW_EXPORT\n Status MakeBuilder(MemoryPool* pool, const std::shared_ptr<DataType>& type,\n                    std::unique_ptr<ArrayBuilder>* out);\n \n+inline Result<std::unique_ptr<ArrayBuilder>> MakeBuilder(\n\nReview comment:\n       I don't think it's a problem by any means but I'm curious why the choice to inline here instead of using the .cc file.\n\n##########\nFile path: cpp/src/arrow/datum.h\n##########\n@@ -153,6 +153,13 @@ struct ARROW_EXPORT Datum {\n       : Datum(std::shared_ptr<typename std::conditional<IsArray, Array, Scalar>::type>(\n             value)) {}\n \n+  // Cast from subtypes of Array or Scalar to Datum\n+  template <typename T, bool IsArray = std::is_base_of<Array, T>::value,\n+            bool IsScalar = std::is_base_of<Scalar, T>::value,\n+            typename = enable_if_t<IsArray || IsScalar>>\n+  Datum(T&& value)  // NOLINT implicit conversion\n\nReview comment:\n       Very cool.  I needed this exact thing the other day when building a query plan by hand with literal scalars.\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n+};\n+\n+int main(int argc, char** argv) {\n+  // Plans arrive at the consumer serialized in a substrait-formatted Buffer\n+  auto maybe_serialized_plan = GetSubstraitFromServer().result();\n+  ABORT_ON_FAILURE(maybe_serialized_plan.status());\n+  std::shared_ptr<arrow::Buffer> serialized_plan =\n+      std::move(maybe_serialized_plan).ValueOrDie();\n+\n+  // Print the received plan to stdout as JSON\n+  arrow::Result<std::string> maybe_plan_json =\n+      eng::internal::SubstraitToJSON(\"Plan\", *serialized_plan);\n+  ABORT_ON_FAILURE(maybe_plan_json.status());\n+  std::cout << std::string('#', 50) << \" received substrait::Plan:\" << std::endl;\n+  std::cout << maybe_plan_json.ValueOrDie() << std::endl;\n+\n+  // Deserializing a plan requires a factory for consumers: each time a sink node is\n+  // deserialized, a consumer is constructed into which its batches will be piped.\n+  std::vector<std::shared_ptr<cp::SinkNodeConsumer>> consumers;\n+  std::function<std::shared_ptr<cp::SinkNodeConsumer>()> consumer_factory = [&] {\n+    // All batches produced by the plan will be fed into IgnoringConsumers:\n+    auto tag = consumers.size();\n+    consumers.emplace_back(new IgnoringConsumer{tag});\n+    return consumers.back();\n+  };\n+\n+  // NOTE Although most of the Deserialize functions require a const ExtensionSet& to\n+  // resolve extension references, a Plan is what we use to construct that ExtensionSet.\n+  // (It should be an optional output later.) In particular, it does not need to be kept\n+  // alive nor does the serialized plan- none of the arrow:: objects in the output will\n+  // contain references to memory owned by either.\n+  auto maybe_decls = eng::DeserializePlan(*serialized_plan, consumer_factory);\n+  ABORT_ON_FAILURE(maybe_decls.status());\n+  std::vector<cp::Declaration> decls = std::move(maybe_decls).ValueOrDie();\n+\n+  // It's safe to drop the serialized plan; we don't leave references to its memory\n+  serialized_plan.reset();\n+\n+  // Construct an empty plan (note: configure Function registry and ThreadPool here)\n+  auto maybe_plan = cp::ExecPlan::Make();\n+  ABORT_ON_FAILURE(maybe_plan.status());\n+  std::shared_ptr<cp::ExecPlan> plan = std::move(maybe_plan).ValueOrDie();\n+\n+  for (const cp::Declaration& decl : decls) {\n+    // Add decl to plan (note: configure ExecNode registry here)\n\nReview comment:\n       This seems like an odd place to configure the `ExecNode` registry.  I'll buy \"the ExecNode factory must be registered before this point.\"  I would guess that most users (and perhaps this example) will be configuring the exec node registry before they ever go out and fetch the plan from the server.\n\n##########\nFile path: cpp/src/arrow/engine/simple_extension_type_internal.h\n##########\n@@ -0,0 +1,183 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/extension_type.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+template <const util::string_view& kExtensionName, typename Params,\n+          typename ParamsProperties, const ParamsProperties* kProperties,\n+          std::shared_ptr<DataType> GetStorage(const Params&)>\n+class SimpleExtensionType : public ExtensionType {\n+ public:\n+  using ParamsType = Params;\n+\n+  explicit SimpleExtensionType(std::shared_ptr<DataType> storage_type, Params params = {})\n+      : ExtensionType(std::move(storage_type)), params_(std::move(params)) {}\n+\n+  static std::shared_ptr<DataType> Make(Params params) {\n+    auto storage_type = GetStorage(params);\n+    return std::make_shared<SimpleExtensionType>(std::move(storage_type),\n+                                                 std::move(params));\n+  }\n+\n+  static const Params* GetIf(const DataType& type) {\n+    if (type.id() != Type::EXTENSION) return nullptr;\n+\n+    const auto& ext_type = ::arrow::internal::checked_cast<const ExtensionType&>(type);\n+    if (ext_type.extension_name() != kExtensionName) return nullptr;\n+\n+    return &::arrow::internal::checked_cast<const SimpleExtensionType&>(type).params_;\n\nReview comment:\n       Would it be simpler to just `checked_cast` directly to `SimpleExtensionType`?\n\n##########\nFile path: cpp/src/arrow/type.cc\n##########\n@@ -1544,7 +1544,7 @@ Result<std::shared_ptr<Schema>> Schema::AddField(\n Result<std::shared_ptr<Schema>> Schema::SetField(\n     int i, const std::shared_ptr<Field>& field) const {\n   if (i < 0 || i > this->num_fields()) {\n-    return Status::Invalid(\"Invalid column index to set field.\");\n+    return Status::Invalid(\"Invalid column index to add field.\");\n\nReview comment:\n       The method is named `SetField` and it does appear to be replacing an existing field.  Why is `add` a better choice here?\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression_internal.h\n##########\n@@ -29,9 +29,6 @@\n #include \"arrow/util/logging.h\"\n \n namespace arrow {\n-\n-using internal::checked_cast;\n\nReview comment:\n       Are we moving away from this pattern?\n\n##########\nFile path: cpp/src/arrow/scalar.h\n##########\n@@ -345,8 +345,8 @@ struct ARROW_EXPORT TimestampScalar : public TemporalScalar<TimestampType> {\n   using TemporalScalar<TimestampType>::TemporalScalar;\n \n   TimestampScalar(typename TemporalScalar<TimestampType>::ValueType value,\n-                  TimeUnit::type unit)\n-      : TimestampScalar(std::move(value), timestamp(unit)) {}\n+                  TimeUnit::type unit, std::string tz = \"\")\n\nReview comment:\n       I'm not sure it makes sense for `tz` to have a default value but I suppose there is some precedent for it on the python side.\n\n##########\nFile path: format/substrait/extension_types.yaml\n##########\n@@ -0,0 +1,121 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+# substrait::{ExtensionTypeVariation, ExtensionType}s\n+# for wrapping types which appear in the arrow type system but\n+# are not first-class in substrait. These include:\n+# - null\n+# - unsigned integers\n+# - half-precision floating point numbers\n+# - 32 bit times and dates\n+# - timestamps with units other than microseconds\n+# - timestamps with timezones other than UTC\n+# - 256 bit decimals\n+# - sparse and dense unions\n+# - dictionary encoded types\n+# - durations\n+# - string and binary with 64 bit offsets\n+# - list with 64 bit offsets\n+# - interval<months: i32>\n+# - interval<days: i32, millis: i32>\n+# - interval<months: i32, days: i32, nanos: i64>\n+# - arrow::ExtensionTypes\n+\n+# FIXME these extension types are not parameterizable, which means among\n+# other things that we can't declare dictionary type here at all since\n+# we'd have to declare a different dictionary type for all encoded types\n+# (but that is an infinite space). Similarly, do we need to declare a\n+# timestamp variation for all possible timezone strings?\n+#\n+# Ultimately these declarations are a promise which needs to be backed by\n+# equivalent serde in c++. For example, consider u8: when serializing to\n+# substrait, we need to wrap instances of arrow::uint8 into the type\n+# variation listed below. It would be ideal if we could SinglePointOfTruth\n+# this correspondence; either generating c++ from the YAML or YAML from the\n+# c++.\n+#\n+# At present (AFAICT) it's not valid to make this user extensible because\n+# even if a user adds their custom scalar function to the registry *and*\n+# defines the mapping from that scalar function to a substrait::ExtensionFunction\n+# the corresponding YAML doesn't exist at any URI and so it can't be used in\n+# substrait. Perhaps we could still help that case by providing a tool to\n+# generate YAML from functions; that'd simplify the lives of people trying to\n+# write arrow::compute::Functions to \"define the function and if you want to\n+# reference it from substrait generate this YAML and put it at some URI\".\n+#\n+# In any case for the foreseeable future generation would be far too brittle;\n+# URIs will not be accessed by anything but humans and the YAML is effectively\n+# structured documentation. Thus extenders should pass the URI in the same way\n+# they pass a description string; it's opaque to anything in arrow.\n+#\n+# We'll need a global mapping which contains:\n+#  arrow::uint8 <-> {\n+#   uri: \"https://github.com/apache/arrow/blob//format/substrait/extension_types.yaml\",\n+#   name: \"u8\"\n+#  }\n\nReview comment:\n       Does this PR not include that mapping?\n\n##########\nFile path: format/substrait/extension_types.yaml\n##########\n@@ -0,0 +1,121 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+# substrait::{ExtensionTypeVariation, ExtensionType}s\n+# for wrapping types which appear in the arrow type system but\n+# are not first-class in substrait. These include:\n+# - null\n+# - unsigned integers\n+# - half-precision floating point numbers\n+# - 32 bit times and dates\n+# - timestamps with units other than microseconds\n+# - timestamps with timezones other than UTC\n+# - 256 bit decimals\n+# - sparse and dense unions\n+# - dictionary encoded types\n+# - durations\n+# - string and binary with 64 bit offsets\n+# - list with 64 bit offsets\n+# - interval<months: i32>\n+# - interval<days: i32, millis: i32>\n+# - interval<months: i32, days: i32, nanos: i64>\n+# - arrow::ExtensionTypes\n+\n+# FIXME these extension types are not parameterizable, which means among\n+# other things that we can't declare dictionary type here at all since\n+# we'd have to declare a different dictionary type for all encoded types\n+# (but that is an infinite space). Similarly, do we need to declare a\n+# timestamp variation for all possible timezone strings?\n+#\n+# Ultimately these declarations are a promise which needs to be backed by\n+# equivalent serde in c++. For example, consider u8: when serializing to\n+# substrait, we need to wrap instances of arrow::uint8 into the type\n+# variation listed below. It would be ideal if we could SinglePointOfTruth\n+# this correspondence; either generating c++ from the YAML or YAML from the\n+# c++.\n+#\n+# At present (AFAICT) it's not valid to make this user extensible because\n+# even if a user adds their custom scalar function to the registry *and*\n+# defines the mapping from that scalar function to a substrait::ExtensionFunction\n+# the corresponding YAML doesn't exist at any URI and so it can't be used in\n+# substrait. Perhaps we could still help that case by providing a tool to\n+# generate YAML from functions; that'd simplify the lives of people trying to\n+# write arrow::compute::Functions to \"define the function and if you want to\n+# reference it from substrait generate this YAML and put it at some URI\".\n+#\n+# In any case for the foreseeable future generation would be far too brittle;\n+# URIs will not be accessed by anything but humans and the YAML is effectively\n+# structured documentation. Thus extenders should pass the URI in the same way\n+# they pass a description string; it's opaque to anything in arrow.\n\nReview comment:\n       I'm not sure you can say both \"the corresponding YAML doesn't exist at any URI and so it can't be used in substrait\" AND \"URIs will not be accessed by anything but humans and the YAML is effectively structured documentation\".\r\n   \r\n   The URI is basically a namespace.  XML does this with xmlns.  I've written plenty of XML documents with custom URI namespaces that never actually resolved to anything.  Also, a URI is a name, it doesn't have to resolve to anything.  It's perfectly valid to use a URI and never actually host the thing.\n\n##########\nFile path: format/substrait/extension_types.yaml\n##########\n@@ -0,0 +1,121 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+# substrait::{ExtensionTypeVariation, ExtensionType}s\n+# for wrapping types which appear in the arrow type system but\n+# are not first-class in substrait. These include:\n+# - null\n+# - unsigned integers\n+# - half-precision floating point numbers\n+# - 32 bit times and dates\n+# - timestamps with units other than microseconds\n+# - timestamps with timezones other than UTC\n+# - 256 bit decimals\n+# - sparse and dense unions\n+# - dictionary encoded types\n+# - durations\n+# - string and binary with 64 bit offsets\n+# - list with 64 bit offsets\n+# - interval<months: i32>\n+# - interval<days: i32, millis: i32>\n+# - interval<months: i32, days: i32, nanos: i64>\n+# - arrow::ExtensionTypes\n+\n+# FIXME these extension types are not parameterizable, which means among\n+# other things that we can't declare dictionary type here at all since\n+# we'd have to declare a different dictionary type for all encoded types\n+# (but that is an infinite space). Similarly, do we need to declare a\n+# timestamp variation for all possible timezone strings?\n+#\n+# Ultimately these declarations are a promise which needs to be backed by\n+# equivalent serde in c++. For example, consider u8: when serializing to\n+# substrait, we need to wrap instances of arrow::uint8 into the type\n+# variation listed below. It would be ideal if we could SinglePointOfTruth\n+# this correspondence; either generating c++ from the YAML or YAML from the\n+# c++.\n+#\n+# At present (AFAICT) it's not valid to make this user extensible because\n+# even if a user adds their custom scalar function to the registry *and*\n+# defines the mapping from that scalar function to a substrait::ExtensionFunction\n+# the corresponding YAML doesn't exist at any URI and so it can't be used in\n+# substrait. Perhaps we could still help that case by providing a tool to\n+# generate YAML from functions; that'd simplify the lives of people trying to\n+# write arrow::compute::Functions to \"define the function and if you want to\n+# reference it from substrait generate this YAML and put it at some URI\".\n+#\n+# In any case for the foreseeable future generation would be far too brittle;\n+# URIs will not be accessed by anything but humans and the YAML is effectively\n+# structured documentation. Thus extenders should pass the URI in the same way\n+# they pass a description string; it's opaque to anything in arrow.\n+#\n+# We'll need a global mapping which contains:\n+#  arrow::uint8 <-> {\n+#   uri: \"https://github.com/apache/arrow/blob//format/substrait/extension_types.yaml\",\n+#   name: \"u8\"\n+#  }\n+#\n+# And additionally convenient builders for subsets of that mapping during serde:\n+#  arrow::uint8 <-> reference to anchor\n+#\n+# Worth noting: it's valid to have multiple ExtensionFunctions with the same name,\n+# as long as all impls' mangled (\"compound\") names are unique.\n+# Also worth noting: Options may only be enumerations. This will get strange with\n+# functions like is_in, where we'll have to require that one argument is a literal\n+# list or something.\n\nReview comment:\n       This feels like a comment that maybe belongs in a PR somewhere.\n\n##########\nFile path: format/substrait/extension_types.yaml\n##########\n@@ -0,0 +1,121 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+# substrait::{ExtensionTypeVariation, ExtensionType}s\n+# for wrapping types which appear in the arrow type system but\n+# are not first-class in substrait. These include:\n+# - null\n+# - unsigned integers\n+# - half-precision floating point numbers\n+# - 32 bit times and dates\n+# - timestamps with units other than microseconds\n+# - timestamps with timezones other than UTC\n+# - 256 bit decimals\n+# - sparse and dense unions\n+# - dictionary encoded types\n+# - durations\n+# - string and binary with 64 bit offsets\n+# - list with 64 bit offsets\n+# - interval<months: i32>\n+# - interval<days: i32, millis: i32>\n+# - interval<months: i32, days: i32, nanos: i64>\n+# - arrow::ExtensionTypes\n+\n+# FIXME these extension types are not parameterizable, which means among\n+# other things that we can't declare dictionary type here at all since\n+# we'd have to declare a different dictionary type for all encoded types\n+# (but that is an infinite space). Similarly, do we need to declare a\n+# timestamp variation for all possible timezone strings?\n+#\n+# Ultimately these declarations are a promise which needs to be backed by\n+# equivalent serde in c++. For example, consider u8: when serializing to\n+# substrait, we need to wrap instances of arrow::uint8 into the type\n+# variation listed below. It would be ideal if we could SinglePointOfTruth\n+# this correspondence; either generating c++ from the YAML or YAML from the\n+# c++.\n+#\n+# At present (AFAICT) it's not valid to make this user extensible because\n+# even if a user adds their custom scalar function to the registry *and*\n+# defines the mapping from that scalar function to a substrait::ExtensionFunction\n+# the corresponding YAML doesn't exist at any URI and so it can't be used in\n+# substrait. Perhaps we could still help that case by providing a tool to\n+# generate YAML from functions; that'd simplify the lives of people trying to\n+# write arrow::compute::Functions to \"define the function and if you want to\n+# reference it from substrait generate this YAML and put it at some URI\".\n+#\n+# In any case for the foreseeable future generation would be far too brittle;\n+# URIs will not be accessed by anything but humans and the YAML is effectively\n+# structured documentation. Thus extenders should pass the URI in the same way\n+# they pass a description string; it's opaque to anything in arrow.\n+#\n+# We'll need a global mapping which contains:\n+#  arrow::uint8 <-> {\n+#   uri: \"https://github.com/apache/arrow/blob//format/substrait/extension_types.yaml\",\n+#   name: \"u8\"\n+#  }\n+#\n+# And additionally convenient builders for subsets of that mapping during serde:\n+#  arrow::uint8 <-> reference to anchor\n\nReview comment:\n       I don't understand this point.\n\n##########\nFile path: format/substrait/extension_types.yaml\n##########\n@@ -0,0 +1,121 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+# substrait::{ExtensionTypeVariation, ExtensionType}s\n+# for wrapping types which appear in the arrow type system but\n+# are not first-class in substrait. These include:\n+# - null\n+# - unsigned integers\n+# - half-precision floating point numbers\n+# - 32 bit times and dates\n+# - timestamps with units other than microseconds\n+# - timestamps with timezones other than UTC\n+# - 256 bit decimals\n+# - sparse and dense unions\n+# - dictionary encoded types\n+# - durations\n+# - string and binary with 64 bit offsets\n+# - list with 64 bit offsets\n+# - interval<months: i32>\n+# - interval<days: i32, millis: i32>\n+# - interval<months: i32, days: i32, nanos: i64>\n+# - arrow::ExtensionTypes\n+\n+# FIXME these extension types are not parameterizable, which means among\n+# other things that we can't declare dictionary type here at all since\n+# we'd have to declare a different dictionary type for all encoded types\n+# (but that is an infinite space). Similarly, do we need to declare a\n+# timestamp variation for all possible timezone strings?\n+#\n+# Ultimately these declarations are a promise which needs to be backed by\n+# equivalent serde in c++. For example, consider u8: when serializing to\n+# substrait, we need to wrap instances of arrow::uint8 into the type\n+# variation listed below. It would be ideal if we could SinglePointOfTruth\n+# this correspondence; either generating c++ from the YAML or YAML from the\n+# c++.\n+#\n+# At present (AFAICT) it's not valid to make this user extensible because\n+# even if a user adds their custom scalar function to the registry *and*\n+# defines the mapping from that scalar function to a substrait::ExtensionFunction\n+# the corresponding YAML doesn't exist at any URI and so it can't be used in\n+# substrait. Perhaps we could still help that case by providing a tool to\n+# generate YAML from functions; that'd simplify the lives of people trying to\n+# write arrow::compute::Functions to \"define the function and if you want to\n+# reference it from substrait generate this YAML and put it at some URI\".\n+#\n+# In any case for the foreseeable future generation would be far too brittle;\n+# URIs will not be accessed by anything but humans and the YAML is effectively\n+# structured documentation. Thus extenders should pass the URI in the same way\n+# they pass a description string; it's opaque to anything in arrow.\n+#\n+# We'll need a global mapping which contains:\n+#  arrow::uint8 <-> {\n+#   uri: \"https://github.com/apache/arrow/blob//format/substrait/extension_types.yaml\",\n+#   name: \"u8\"\n+#  }\n+#\n+# And additionally convenient builders for subsets of that mapping during serde:\n+#  arrow::uint8 <-> reference to anchor\n+#\n+# Worth noting: it's valid to have multiple ExtensionFunctions with the same name,\n+# as long as all impls' mangled (\"compound\") names are unique.\n+# Also worth noting: Options may only be enumerations. This will get strange with\n+# functions like is_in, where we'll have to require that one argument is a literal\n+# list or something.\n+\n+type_variations:\n+  - parent: i8\n+    name: u8\n\nReview comment:\n       I'm not sure if an unsigned integer is a \"type variation\" or a separate type.\n\n##########\nFile path: format/substrait/extension_types.yaml\n##########\n@@ -0,0 +1,121 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+# substrait::{ExtensionTypeVariation, ExtensionType}s\n+# for wrapping types which appear in the arrow type system but\n+# are not first-class in substrait. These include:\n+# - null\n+# - unsigned integers\n+# - half-precision floating point numbers\n+# - 32 bit times and dates\n+# - timestamps with units other than microseconds\n+# - timestamps with timezones other than UTC\n+# - 256 bit decimals\n+# - sparse and dense unions\n+# - dictionary encoded types\n+# - durations\n+# - string and binary with 64 bit offsets\n+# - list with 64 bit offsets\n+# - interval<months: i32>\n+# - interval<days: i32, millis: i32>\n+# - interval<months: i32, days: i32, nanos: i64>\n+# - arrow::ExtensionTypes\n+\n+# FIXME these extension types are not parameterizable, which means among\n+# other things that we can't declare dictionary type here at all since\n+# we'd have to declare a different dictionary type for all encoded types\n+# (but that is an infinite space). Similarly, do we need to declare a\n+# timestamp variation for all possible timezone strings?\n+#\n+# Ultimately these declarations are a promise which needs to be backed by\n+# equivalent serde in c++. For example, consider u8: when serializing to\n+# substrait, we need to wrap instances of arrow::uint8 into the type\n+# variation listed below. It would be ideal if we could SinglePointOfTruth\n+# this correspondence; either generating c++ from the YAML or YAML from the\n+# c++.\n\nReview comment:\n       Rather than talk about this in user facing documentation can we create a JIRA to investigate a single source of truth for Substrait YAML?\n\n##########\nFile path: format/substrait/extension_types.yaml\n##########\n@@ -0,0 +1,121 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+# substrait::{ExtensionTypeVariation, ExtensionType}s\n+# for wrapping types which appear in the arrow type system but\n+# are not first-class in substrait. These include:\n+# - null\n+# - unsigned integers\n+# - half-precision floating point numbers\n+# - 32 bit times and dates\n+# - timestamps with units other than microseconds\n+# - timestamps with timezones other than UTC\n+# - 256 bit decimals\n+# - sparse and dense unions\n+# - dictionary encoded types\n+# - durations\n+# - string and binary with 64 bit offsets\n+# - list with 64 bit offsets\n+# - interval<months: i32>\n+# - interval<days: i32, millis: i32>\n+# - interval<months: i32, days: i32, nanos: i64>\n+# - arrow::ExtensionTypes\n+\n+# FIXME these extension types are not parameterizable, which means among\n+# other things that we can't declare dictionary type here at all since\n+# we'd have to declare a different dictionary type for all encoded types\n+# (but that is an infinite space). Similarly, do we need to declare a\n+# timestamp variation for all possible timezone strings?\n\nReview comment:\n       Let's create a JIRA to get to figure out the dictionary encoding.  At one point Substrait was considering a separate \"encoding\" or \"specialization\" property for types.  I think we backed out of that and decided those would just be custom types.  But I don't really remember where we landed.\r\n   \r\n   For timezone strings, I don't think we will ever need to bother with this.  In my mind, the timezone string should always be a function option and not a part of the data.  We can hash that out in a separate JIRA (i.e. separate from this PR and separate from a JIRA on figuring out dictionary encoding).\n\n##########\nFile path: format/substrait/extension_types.yaml\n##########\n@@ -0,0 +1,121 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+# substrait::{ExtensionTypeVariation, ExtensionType}s\n+# for wrapping types which appear in the arrow type system but\n+# are not first-class in substrait. These include:\n+# - null\n+# - unsigned integers\n+# - half-precision floating point numbers\n+# - 32 bit times and dates\n+# - timestamps with units other than microseconds\n+# - timestamps with timezones other than UTC\n+# - 256 bit decimals\n+# - sparse and dense unions\n+# - dictionary encoded types\n+# - durations\n+# - string and binary with 64 bit offsets\n+# - list with 64 bit offsets\n+# - interval<months: i32>\n+# - interval<days: i32, millis: i32>\n+# - interval<months: i32, days: i32, nanos: i64>\n+# - arrow::ExtensionTypes\n+\n+# FIXME these extension types are not parameterizable, which means among\n+# other things that we can't declare dictionary type here at all since\n+# we'd have to declare a different dictionary type for all encoded types\n+# (but that is an infinite space). Similarly, do we need to declare a\n+# timestamp variation for all possible timezone strings?\n+#\n+# Ultimately these declarations are a promise which needs to be backed by\n+# equivalent serde in c++. For example, consider u8: when serializing to\n+# substrait, we need to wrap instances of arrow::uint8 into the type\n+# variation listed below. It would be ideal if we could SinglePointOfTruth\n+# this correspondence; either generating c++ from the YAML or YAML from the\n+# c++.\n+#\n+# At present (AFAICT) it's not valid to make this user extensible because\n+# even if a user adds their custom scalar function to the registry *and*\n+# defines the mapping from that scalar function to a substrait::ExtensionFunction\n+# the corresponding YAML doesn't exist at any URI and so it can't be used in\n+# substrait. Perhaps we could still help that case by providing a tool to\n+# generate YAML from functions; that'd simplify the lives of people trying to\n+# write arrow::compute::Functions to \"define the function and if you want to\n+# reference it from substrait generate this YAML and put it at some URI\".\n+#\n+# In any case for the foreseeable future generation would be far too brittle;\n+# URIs will not be accessed by anything but humans and the YAML is effectively\n+# structured documentation. Thus extenders should pass the URI in the same way\n+# they pass a description string; it's opaque to anything in arrow.\n+#\n+# We'll need a global mapping which contains:\n+#  arrow::uint8 <-> {\n+#   uri: \"https://github.com/apache/arrow/blob//format/substrait/extension_types.yaml\",\n+#   name: \"u8\"\n+#  }\n+#\n+# And additionally convenient builders for subsets of that mapping during serde:\n+#  arrow::uint8 <-> reference to anchor\n+#\n+# Worth noting: it's valid to have multiple ExtensionFunctions with the same name,\n+# as long as all impls' mangled (\"compound\") names are unique.\n+# Also worth noting: Options may only be enumerations. This will get strange with\n+# functions like is_in, where we'll have to require that one argument is a literal\n+# list or something.\n+\n+type_variations:\n+  - parent: i8\n+    name: u8\n+    description: an unsigned 8 bit integer\n+    functions: SEPARATE\n+  - parent: i16\n+    name: u16\n+    description: an unsigned 16 bit integer\n+    functions: SEPARATE\n+  - parent: i32\n+    name: u32\n+    description: an unsigned 32 bit integer\n+    functions: SEPARATE\n+  - parent: i32\n+    name: u32\n+    description: an unsigned 32 bit integer\n+    functions: SEPARATE\n+  - parent: i64\n+    name: u64\n+    description: an unsigned 64 bit integer\n+    functions: SEPARATE\n+\n+  - parent: i16\n\nReview comment:\n       Is `i16` really the parent?  My understanding of \"parent\" is that it is a \"semantic\" parent although I don't get the point of specifying a parent at all if using `functions: SEPARATE` so... :shrug: \n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n+        ARROW_ASSIGN_OR_RAISE(auto compute_if, FromProto(if_.if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto compute_then, FromProto(if_.then(), ext_set));\n+        conditions.emplace_back(std::move(compute_if));\n+        args.emplace_back(std::move(compute_then));\n+        condition_names.emplace_back(\"cond\" + std::to_string(++name_counter));\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto compute_else, FromProto(if_then.else_(), ext_set));\n+      args.emplace_back(std::move(compute_else));\n+      args[0] = compute::call(\"make_struct\", std::move(conditions),\n+                              compute::MakeStructOptions(condition_names));\n+      return compute::call(\"case_when\", std::move(args));\n+    }\n+\n+    case substrait::Expression::kScalarFunction: {\n+      const auto& scalar_fn = expr.scalar_function();\n+\n+      auto id = ext_set.function_ids()[scalar_fn.function_reference()];\n+\n+      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n+      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n+      }\n+\n+      return compute::call(id.name.to_string(), std::move(arguments));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::compute::Expression from \",\n+                                expr.DebugString());\n+}\n+\n+Result<Datum> FromProto(const substrait::Expression::Literal& lit,\n+                        const ExtensionSet& ext_set) {\n+  if (lit.nullable()) {\n+    // FIXME not sure how this field should be interpreted and there's no way to round\n+    // trip it through arrow\n+    return Status::Invalid(\n+        \"Nullable Literals - Literal.nullable must be left at the default\");\n+  }\n+\n+  switch (lit.literal_type_case()) {\n+    case substrait::Expression::Literal::kBoolean:\n+      return Datum(lit.boolean());\n+\n+    case substrait::Expression::Literal::kI8:\n+      return Datum(static_cast<int8_t>(lit.i8()));\n+    case substrait::Expression::Literal::kI16:\n+      return Datum(static_cast<int16_t>(lit.i16()));\n+    case substrait::Expression::Literal::kI32:\n+      return Datum(static_cast<int32_t>(lit.i32()));\n+    case substrait::Expression::Literal::kI64:\n+      return Datum(static_cast<int64_t>(lit.i64()));\n+\n+    case substrait::Expression::Literal::kFp32:\n+      return Datum(lit.fp32());\n+    case substrait::Expression::Literal::kFp64:\n+      return Datum(lit.fp64());\n+\n+    case substrait::Expression::Literal::kString:\n+      return Datum(lit.string());\n+    case substrait::Expression::Literal::kBinary:\n+      return Datum(BinaryScalar(Buffer::FromString(lit.binary())));\n+\n+    case substrait::Expression::Literal::kTimestamp:\n+      return Datum(\n+          TimestampScalar(static_cast<int64_t>(lit.timestamp()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kTimestampTz:\n+      return Datum(TimestampScalar(static_cast<int64_t>(lit.timestamp_tz()),\n+                                   TimeUnit::MICRO, TimestampTzTimezoneString()));\n+\n+    case substrait::Expression::Literal::kDate:\n+      return Datum(Date64Scalar(static_cast<int64_t>(lit.date())));\n+    case substrait::Expression::Literal::kTime:\n+      return Datum(Time64Scalar(static_cast<int64_t>(lit.time()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kIntervalYearToMonth:\n+    case substrait::Expression::Literal::kIntervalDayToSecond: {\n+      Int32Builder builder;\n+      std::shared_ptr<DataType> type;\n+      if (lit.has_interval_year_to_month()) {\n+        RETURN_NOT_OK(builder.Append(lit.interval_year_to_month().years()));\n+        RETURN_NOT_OK(builder.Append(lit.interval_year_to_month().months()));\n+        type = interval_year();\n+      } else {\n+        RETURN_NOT_OK(builder.Append(lit.interval_day_to_second().days()));\n+        RETURN_NOT_OK(builder.Append(lit.interval_day_to_second().seconds()));\n+        type = interval_day();\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto array, builder.Finish());\n+      return Datum(\n+          ExtensionScalar(FixedSizeListScalar(std::move(array)), std::move(type)));\n+    }\n+\n+    case substrait::Expression::Literal::kUuid:\n+      return Datum(ExtensionScalar(FixedSizeBinaryScalarFromBytes(lit.uuid()), uuid()));\n+\n+    case substrait::Expression::Literal::kFixedChar:\n+      return Datum(\n+          ExtensionScalar(FixedSizeBinaryScalarFromBytes(lit.fixed_char()),\n+                          fixed_char(static_cast<int32_t>(lit.fixed_char().size()))));\n+\n+    case substrait::Expression::Literal::kVarChar:\n+      return Datum(\n+          ExtensionScalar(StringScalar(lit.var_char().value()),\n+                          varchar(static_cast<int32_t>(lit.var_char().length()))));\n+\n+    case substrait::Expression::Literal::kFixedBinary:\n+      return Datum(FixedSizeBinaryScalarFromBytes(lit.fixed_binary()));\n+\n+    case substrait::Expression::Literal::kDecimal: {\n+      if (lit.decimal().value().size() != sizeof(Decimal128)) {\n+        return Status::Invalid(\"Decimal literal had \", lit.decimal().value().size(),\n+                               \" bytes (expected \", sizeof(Decimal128), \")\");\n+      }\n+\n+      Decimal128 value;\n+      std::memcpy(value.mutable_native_endian_bytes(), lit.decimal().value().data(),\n+                  sizeof(Decimal128));\n+#if !ARROW_LITTLE_ENDIAN\n+      std::reverse(value.mutable_native_endian_bytes(),\n+                   value.mutable_native_endian_bytes() + sizeof(Decimal128));\n+#endif\n+      auto type = decimal128(lit.decimal().precision(), lit.decimal().scale());\n+      return Datum(Decimal128Scalar(value, std::move(type)));\n+    }\n+\n+    case substrait::Expression::Literal::kStruct: {\n+      const auto& struct_ = lit.struct_();\n+\n+      ScalarVector fields(struct_.fields_size());\n+      std::vector<std::string> field_names(fields.size(), \"\");\n+      for (int i = 0; i < struct_.fields_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(auto field, FromProto(struct_.fields(i), ext_set));\n+        DCHECK(field.is_scalar());\n+        fields[i] = field.scalar();\n+      }\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto scalar, StructScalar::Make(std::move(fields), std::move(field_names)));\n+      return Datum(std::move(scalar));\n\nReview comment:\n       This matches the templated \"Cast from subtypes of Array or Scalar to Datum\" constructor that takes `const std::shared_ptr<T>&`\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n+        ARROW_ASSIGN_OR_RAISE(auto compute_if, FromProto(if_.if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto compute_then, FromProto(if_.then(), ext_set));\n+        conditions.emplace_back(std::move(compute_if));\n+        args.emplace_back(std::move(compute_then));\n+        condition_names.emplace_back(\"cond\" + std::to_string(++name_counter));\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto compute_else, FromProto(if_then.else_(), ext_set));\n+      args.emplace_back(std::move(compute_else));\n+      args[0] = compute::call(\"make_struct\", std::move(conditions),\n+                              compute::MakeStructOptions(condition_names));\n+      return compute::call(\"case_when\", std::move(args));\n+    }\n+\n+    case substrait::Expression::kScalarFunction: {\n+      const auto& scalar_fn = expr.scalar_function();\n+\n+      auto id = ext_set.function_ids()[scalar_fn.function_reference()];\n+\n+      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n+      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n+      }\n+\n+      return compute::call(id.name.to_string(), std::move(arguments));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::compute::Expression from \",\n+                                expr.DebugString());\n+}\n+\n+Result<Datum> FromProto(const substrait::Expression::Literal& lit,\n+                        const ExtensionSet& ext_set) {\n+  if (lit.nullable()) {\n+    // FIXME not sure how this field should be interpreted and there's no way to round\n+    // trip it through arrow\n+    return Status::Invalid(\n+        \"Nullable Literals - Literal.nullable must be left at the default\");\n+  }\n\nReview comment:\n       What does round tripping mean in this context?  We don't have any way of going back to a Substrait plan and, even if we did, I think that would be more for debugging purposes than anything else.\r\n   \r\n   It seems to me that Substrait is giving us more information than we need so we should just ignore it either way.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n\nReview comment:\n       ```suggestion\r\n         for (const auto& if_ : if_then.ifs()) {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n\nReview comment:\n       ```suggestion\r\n   ```\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n+        ARROW_ASSIGN_OR_RAISE(auto compute_if, FromProto(if_.if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto compute_then, FromProto(if_.then(), ext_set));\n+        conditions.emplace_back(std::move(compute_if));\n+        args.emplace_back(std::move(compute_then));\n+        condition_names.emplace_back(\"cond\" + std::to_string(++name_counter));\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto compute_else, FromProto(if_then.else_(), ext_set));\n+      args.emplace_back(std::move(compute_else));\n+      args[0] = compute::call(\"make_struct\", std::move(conditions),\n+                              compute::MakeStructOptions(condition_names));\n+      return compute::call(\"case_when\", std::move(args));\n+    }\n+\n+    case substrait::Expression::kScalarFunction: {\n+      const auto& scalar_fn = expr.scalar_function();\n+\n+      auto id = ext_set.function_ids()[scalar_fn.function_reference()];\n+\n+      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n+      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n+      }\n+\n+      return compute::call(id.name.to_string(), std::move(arguments));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::compute::Expression from \",\n+                                expr.DebugString());\n+}\n+\n+Result<Datum> FromProto(const substrait::Expression::Literal& lit,\n+                        const ExtensionSet& ext_set) {\n+  if (lit.nullable()) {\n+    // FIXME not sure how this field should be interpreted and there's no way to round\n+    // trip it through arrow\n+    return Status::Invalid(\n+        \"Nullable Literals - Literal.nullable must be left at the default\");\n+  }\n+\n+  switch (lit.literal_type_case()) {\n+    case substrait::Expression::Literal::kBoolean:\n+      return Datum(lit.boolean());\n+\n+    case substrait::Expression::Literal::kI8:\n+      return Datum(static_cast<int8_t>(lit.i8()));\n+    case substrait::Expression::Literal::kI16:\n+      return Datum(static_cast<int16_t>(lit.i16()));\n+    case substrait::Expression::Literal::kI32:\n+      return Datum(static_cast<int32_t>(lit.i32()));\n+    case substrait::Expression::Literal::kI64:\n+      return Datum(static_cast<int64_t>(lit.i64()));\n+\n+    case substrait::Expression::Literal::kFp32:\n+      return Datum(lit.fp32());\n+    case substrait::Expression::Literal::kFp64:\n+      return Datum(lit.fp64());\n+\n+    case substrait::Expression::Literal::kString:\n+      return Datum(lit.string());\n+    case substrait::Expression::Literal::kBinary:\n+      return Datum(BinaryScalar(Buffer::FromString(lit.binary())));\n+\n+    case substrait::Expression::Literal::kTimestamp:\n+      return Datum(\n+          TimestampScalar(static_cast<int64_t>(lit.timestamp()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kTimestampTz:\n+      return Datum(TimestampScalar(static_cast<int64_t>(lit.timestamp_tz()),\n+                                   TimeUnit::MICRO, TimestampTzTimezoneString()));\n+\n+    case substrait::Expression::Literal::kDate:\n+      return Datum(Date64Scalar(static_cast<int64_t>(lit.date())));\n+    case substrait::Expression::Literal::kTime:\n+      return Datum(Time64Scalar(static_cast<int64_t>(lit.time()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kIntervalYearToMonth:\n+    case substrait::Expression::Literal::kIntervalDayToSecond: {\n+      Int32Builder builder;\n+      std::shared_ptr<DataType> type;\n+      if (lit.has_interval_year_to_month()) {\n+        RETURN_NOT_OK(builder.Append(lit.interval_year_to_month().years()));\n+        RETURN_NOT_OK(builder.Append(lit.interval_year_to_month().months()));\n+        type = interval_year();\n+      } else {\n+        RETURN_NOT_OK(builder.Append(lit.interval_day_to_second().days()));\n+        RETURN_NOT_OK(builder.Append(lit.interval_day_to_second().seconds()));\n+        type = interval_day();\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto array, builder.Finish());\n+      return Datum(\n+          ExtensionScalar(FixedSizeListScalar(std::move(array)), std::move(type)));\n+    }\n+\n+    case substrait::Expression::Literal::kUuid:\n+      return Datum(ExtensionScalar(FixedSizeBinaryScalarFromBytes(lit.uuid()), uuid()));\n+\n+    case substrait::Expression::Literal::kFixedChar:\n+      return Datum(\n+          ExtensionScalar(FixedSizeBinaryScalarFromBytes(lit.fixed_char()),\n+                          fixed_char(static_cast<int32_t>(lit.fixed_char().size()))));\n+\n+    case substrait::Expression::Literal::kVarChar:\n+      return Datum(\n+          ExtensionScalar(StringScalar(lit.var_char().value()),\n+                          varchar(static_cast<int32_t>(lit.var_char().length()))));\n+\n+    case substrait::Expression::Literal::kFixedBinary:\n+      return Datum(FixedSizeBinaryScalarFromBytes(lit.fixed_binary()));\n+\n+    case substrait::Expression::Literal::kDecimal: {\n+      if (lit.decimal().value().size() != sizeof(Decimal128)) {\n+        return Status::Invalid(\"Decimal literal had \", lit.decimal().value().size(),\n+                               \" bytes (expected \", sizeof(Decimal128), \")\");\n+      }\n+\n+      Decimal128 value;\n+      std::memcpy(value.mutable_native_endian_bytes(), lit.decimal().value().data(),\n+                  sizeof(Decimal128));\n+#if !ARROW_LITTLE_ENDIAN\n+      std::reverse(value.mutable_native_endian_bytes(),\n+                   value.mutable_native_endian_bytes() + sizeof(Decimal128));\n+#endif\n+      auto type = decimal128(lit.decimal().precision(), lit.decimal().scale());\n+      return Datum(Decimal128Scalar(value, std::move(type)));\n+    }\n+\n+    case substrait::Expression::Literal::kStruct: {\n+      const auto& struct_ = lit.struct_();\n+\n+      ScalarVector fields(struct_.fields_size());\n+      std::vector<std::string> field_names(fields.size(), \"\");\n+      for (int i = 0; i < struct_.fields_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(auto field, FromProto(struct_.fields(i), ext_set));\n+        DCHECK(field.is_scalar());\n+        fields[i] = field.scalar();\n+      }\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto scalar, StructScalar::Make(std::move(fields), std::move(field_names)));\n+      return Datum(std::move(scalar));\n+    }\n+\n+    case substrait::Expression::Literal::kList: {\n+      const auto& list = lit.list();\n+      if (list.values_size() == 0) {\n+        return Status::Invalid(\n+            \"substrait::Expression::Literal::List had no values; should have been an \"\n+            \"substrait::Expression::Literal::EmptyList\");\n+      }\n+\n+      std::shared_ptr<DataType> element_type;\n+\n+      ScalarVector values(list.values_size());\n+      for (int i = 0; i < list.values_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(auto value, FromProto(list.values(i), ext_set));\n+        DCHECK(value.is_scalar());\n+        values[i] = value.scalar();\n+        if (element_type) {\n+          if (!value.type()->Equals(*element_type)) {\n+            return Status::Invalid(\n+                list.DebugString(),\n+                \" has a value whose type doesn't match the other list values\");\n+          }\n+        } else {\n+          element_type = value.type();\n+        }\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto builder, MakeBuilder(std::move(element_type)));\n\nReview comment:\n       ```suggestion\r\n         ARROW_ASSIGN_OR_RAISE(auto builder, MakeBuilder(element_type));\r\n   ```\n\n##########\nFile path: cpp/src/arrow/datum.h\n##########\n@@ -153,6 +153,13 @@ struct ARROW_EXPORT Datum {\n       : Datum(std::shared_ptr<typename std::conditional<IsArray, Array, Scalar>::type>(\n\nReview comment:\n       Since we're nearby can you take a look at this?  Why are we using `const std::shared_ptr<T>&`?  Is it inevitable we must make a copy of the `shared_ptr`?\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n+        ARROW_ASSIGN_OR_RAISE(auto compute_if, FromProto(if_.if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto compute_then, FromProto(if_.then(), ext_set));\n+        conditions.emplace_back(std::move(compute_if));\n+        args.emplace_back(std::move(compute_then));\n+        condition_names.emplace_back(\"cond\" + std::to_string(++name_counter));\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto compute_else, FromProto(if_then.else_(), ext_set));\n+      args.emplace_back(std::move(compute_else));\n+      args[0] = compute::call(\"make_struct\", std::move(conditions),\n+                              compute::MakeStructOptions(condition_names));\n+      return compute::call(\"case_when\", std::move(args));\n+    }\n+\n+    case substrait::Expression::kScalarFunction: {\n+      const auto& scalar_fn = expr.scalar_function();\n+\n+      auto id = ext_set.function_ids()[scalar_fn.function_reference()];\n+\n+      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n+      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n+      }\n+\n+      return compute::call(id.name.to_string(), std::move(arguments));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::compute::Expression from \",\n+                                expr.DebugString());\n+}\n+\n+Result<Datum> FromProto(const substrait::Expression::Literal& lit,\n+                        const ExtensionSet& ext_set) {\n+  if (lit.nullable()) {\n+    // FIXME not sure how this field should be interpreted and there's no way to round\n+    // trip it through arrow\n+    return Status::Invalid(\n+        \"Nullable Literals - Literal.nullable must be left at the default\");\n+  }\n+\n+  switch (lit.literal_type_case()) {\n+    case substrait::Expression::Literal::kBoolean:\n+      return Datum(lit.boolean());\n+\n+    case substrait::Expression::Literal::kI8:\n+      return Datum(static_cast<int8_t>(lit.i8()));\n+    case substrait::Expression::Literal::kI16:\n+      return Datum(static_cast<int16_t>(lit.i16()));\n+    case substrait::Expression::Literal::kI32:\n+      return Datum(static_cast<int32_t>(lit.i32()));\n+    case substrait::Expression::Literal::kI64:\n+      return Datum(static_cast<int64_t>(lit.i64()));\n+\n+    case substrait::Expression::Literal::kFp32:\n+      return Datum(lit.fp32());\n+    case substrait::Expression::Literal::kFp64:\n+      return Datum(lit.fp64());\n+\n+    case substrait::Expression::Literal::kString:\n+      return Datum(lit.string());\n+    case substrait::Expression::Literal::kBinary:\n+      return Datum(BinaryScalar(Buffer::FromString(lit.binary())));\n+\n+    case substrait::Expression::Literal::kTimestamp:\n+      return Datum(\n+          TimestampScalar(static_cast<int64_t>(lit.timestamp()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kTimestampTz:\n+      return Datum(TimestampScalar(static_cast<int64_t>(lit.timestamp_tz()),\n+                                   TimeUnit::MICRO, TimestampTzTimezoneString()));\n+\n+    case substrait::Expression::Literal::kDate:\n+      return Datum(Date64Scalar(static_cast<int64_t>(lit.date())));\n+    case substrait::Expression::Literal::kTime:\n+      return Datum(Time64Scalar(static_cast<int64_t>(lit.time()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kIntervalYearToMonth:\n+    case substrait::Expression::Literal::kIntervalDayToSecond: {\n\nReview comment:\n       Arrow has interval types.  Why did we need extension types here?  `kIntervalYearToMonth` should map to https://github.com/apache/arrow/blob/40ac81087a9d6d97dae4b11c28a147176d22dc54/format/Schema.fbs#L361 and `kIntervalDayToSecond` should map to https://github.com/apache/arrow/blob/40ac81087a9d6d97dae4b11c28a147176d22dc54/format/Schema.fbs#L366\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n+        ARROW_ASSIGN_OR_RAISE(auto compute_if, FromProto(if_.if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto compute_then, FromProto(if_.then(), ext_set));\n+        conditions.emplace_back(std::move(compute_if));\n+        args.emplace_back(std::move(compute_then));\n+        condition_names.emplace_back(\"cond\" + std::to_string(++name_counter));\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto compute_else, FromProto(if_then.else_(), ext_set));\n+      args.emplace_back(std::move(compute_else));\n+      args[0] = compute::call(\"make_struct\", std::move(conditions),\n+                              compute::MakeStructOptions(condition_names));\n+      return compute::call(\"case_when\", std::move(args));\n+    }\n+\n+    case substrait::Expression::kScalarFunction: {\n+      const auto& scalar_fn = expr.scalar_function();\n+\n+      auto id = ext_set.function_ids()[scalar_fn.function_reference()];\n+\n+      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n+      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n+      }\n+\n+      return compute::call(id.name.to_string(), std::move(arguments));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::compute::Expression from \",\n+                                expr.DebugString());\n+}\n+\n+Result<Datum> FromProto(const substrait::Expression::Literal& lit,\n+                        const ExtensionSet& ext_set) {\n+  if (lit.nullable()) {\n+    // FIXME not sure how this field should be interpreted and there's no way to round\n+    // trip it through arrow\n+    return Status::Invalid(\n+        \"Nullable Literals - Literal.nullable must be left at the default\");\n+  }\n+\n+  switch (lit.literal_type_case()) {\n+    case substrait::Expression::Literal::kBoolean:\n+      return Datum(lit.boolean());\n+\n+    case substrait::Expression::Literal::kI8:\n+      return Datum(static_cast<int8_t>(lit.i8()));\n+    case substrait::Expression::Literal::kI16:\n+      return Datum(static_cast<int16_t>(lit.i16()));\n+    case substrait::Expression::Literal::kI32:\n+      return Datum(static_cast<int32_t>(lit.i32()));\n+    case substrait::Expression::Literal::kI64:\n+      return Datum(static_cast<int64_t>(lit.i64()));\n+\n+    case substrait::Expression::Literal::kFp32:\n+      return Datum(lit.fp32());\n+    case substrait::Expression::Literal::kFp64:\n+      return Datum(lit.fp64());\n+\n+    case substrait::Expression::Literal::kString:\n+      return Datum(lit.string());\n+    case substrait::Expression::Literal::kBinary:\n+      return Datum(BinaryScalar(Buffer::FromString(lit.binary())));\n+\n+    case substrait::Expression::Literal::kTimestamp:\n+      return Datum(\n+          TimestampScalar(static_cast<int64_t>(lit.timestamp()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kTimestampTz:\n+      return Datum(TimestampScalar(static_cast<int64_t>(lit.timestamp_tz()),\n+                                   TimeUnit::MICRO, TimestampTzTimezoneString()));\n+\n+    case substrait::Expression::Literal::kDate:\n+      return Datum(Date64Scalar(static_cast<int64_t>(lit.date())));\n\nReview comment:\n       I think a Substrait [Date](https://substrait.io/types/simple_logical_types/) maps to `Date<DAY>` which would be `Date32Scalar`.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n+        ARROW_ASSIGN_OR_RAISE(auto compute_if, FromProto(if_.if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto compute_then, FromProto(if_.then(), ext_set));\n+        conditions.emplace_back(std::move(compute_if));\n+        args.emplace_back(std::move(compute_then));\n+        condition_names.emplace_back(\"cond\" + std::to_string(++name_counter));\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto compute_else, FromProto(if_then.else_(), ext_set));\n+      args.emplace_back(std::move(compute_else));\n+      args[0] = compute::call(\"make_struct\", std::move(conditions),\n+                              compute::MakeStructOptions(condition_names));\n+      return compute::call(\"case_when\", std::move(args));\n+    }\n+\n+    case substrait::Expression::kScalarFunction: {\n+      const auto& scalar_fn = expr.scalar_function();\n+\n+      auto id = ext_set.function_ids()[scalar_fn.function_reference()];\n+\n+      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n+      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n+      }\n+\n+      return compute::call(id.name.to_string(), std::move(arguments));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::compute::Expression from \",\n+                                expr.DebugString());\n+}\n+\n+Result<Datum> FromProto(const substrait::Expression::Literal& lit,\n+                        const ExtensionSet& ext_set) {\n+  if (lit.nullable()) {\n+    // FIXME not sure how this field should be interpreted and there's no way to round\n+    // trip it through arrow\n+    return Status::Invalid(\n+        \"Nullable Literals - Literal.nullable must be left at the default\");\n+  }\n+\n+  switch (lit.literal_type_case()) {\n+    case substrait::Expression::Literal::kBoolean:\n+      return Datum(lit.boolean());\n+\n+    case substrait::Expression::Literal::kI8:\n+      return Datum(static_cast<int8_t>(lit.i8()));\n+    case substrait::Expression::Literal::kI16:\n+      return Datum(static_cast<int16_t>(lit.i16()));\n+    case substrait::Expression::Literal::kI32:\n+      return Datum(static_cast<int32_t>(lit.i32()));\n+    case substrait::Expression::Literal::kI64:\n+      return Datum(static_cast<int64_t>(lit.i64()));\n+\n+    case substrait::Expression::Literal::kFp32:\n+      return Datum(lit.fp32());\n+    case substrait::Expression::Literal::kFp64:\n+      return Datum(lit.fp64());\n+\n+    case substrait::Expression::Literal::kString:\n+      return Datum(lit.string());\n+    case substrait::Expression::Literal::kBinary:\n+      return Datum(BinaryScalar(Buffer::FromString(lit.binary())));\n\nReview comment:\n       Minor nit: for consistency's sake we could add a constructor:\r\n   \r\n   ```\r\n   BinaryScalar::BinaryScalar(const std::string&);\r\n   ```\r\n   \n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n+        ARROW_ASSIGN_OR_RAISE(auto compute_if, FromProto(if_.if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto compute_then, FromProto(if_.then(), ext_set));\n+        conditions.emplace_back(std::move(compute_if));\n+        args.emplace_back(std::move(compute_then));\n+        condition_names.emplace_back(\"cond\" + std::to_string(++name_counter));\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto compute_else, FromProto(if_then.else_(), ext_set));\n+      args.emplace_back(std::move(compute_else));\n+      args[0] = compute::call(\"make_struct\", std::move(conditions),\n+                              compute::MakeStructOptions(condition_names));\n+      return compute::call(\"case_when\", std::move(args));\n+    }\n+\n+    case substrait::Expression::kScalarFunction: {\n+      const auto& scalar_fn = expr.scalar_function();\n+\n+      auto id = ext_set.function_ids()[scalar_fn.function_reference()];\n+\n+      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n+      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n+      }\n+\n+      return compute::call(id.name.to_string(), std::move(arguments));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::compute::Expression from \",\n+                                expr.DebugString());\n+}\n+\n+Result<Datum> FromProto(const substrait::Expression::Literal& lit,\n+                        const ExtensionSet& ext_set) {\n+  if (lit.nullable()) {\n+    // FIXME not sure how this field should be interpreted and there's no way to round\n+    // trip it through arrow\n+    return Status::Invalid(\n+        \"Nullable Literals - Literal.nullable must be left at the default\");\n+  }\n+\n+  switch (lit.literal_type_case()) {\n+    case substrait::Expression::Literal::kBoolean:\n+      return Datum(lit.boolean());\n+\n+    case substrait::Expression::Literal::kI8:\n+      return Datum(static_cast<int8_t>(lit.i8()));\n+    case substrait::Expression::Literal::kI16:\n+      return Datum(static_cast<int16_t>(lit.i16()));\n+    case substrait::Expression::Literal::kI32:\n+      return Datum(static_cast<int32_t>(lit.i32()));\n+    case substrait::Expression::Literal::kI64:\n+      return Datum(static_cast<int64_t>(lit.i64()));\n+\n+    case substrait::Expression::Literal::kFp32:\n+      return Datum(lit.fp32());\n+    case substrait::Expression::Literal::kFp64:\n+      return Datum(lit.fp64());\n+\n+    case substrait::Expression::Literal::kString:\n+      return Datum(lit.string());\n+    case substrait::Expression::Literal::kBinary:\n+      return Datum(BinaryScalar(Buffer::FromString(lit.binary())));\n+\n+    case substrait::Expression::Literal::kTimestamp:\n+      return Datum(\n+          TimestampScalar(static_cast<int64_t>(lit.timestamp()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kTimestampTz:\n+      return Datum(TimestampScalar(static_cast<int64_t>(lit.timestamp_tz()),\n+                                   TimeUnit::MICRO, TimestampTzTimezoneString()));\n+\n+    case substrait::Expression::Literal::kDate:\n+      return Datum(Date64Scalar(static_cast<int64_t>(lit.date())));\n+    case substrait::Expression::Literal::kTime:\n+      return Datum(Time64Scalar(static_cast<int64_t>(lit.time()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kIntervalYearToMonth:\n+    case substrait::Expression::Literal::kIntervalDayToSecond: {\n+      Int32Builder builder;\n+      std::shared_ptr<DataType> type;\n+      if (lit.has_interval_year_to_month()) {\n+        RETURN_NOT_OK(builder.Append(lit.interval_year_to_month().years()));\n+        RETURN_NOT_OK(builder.Append(lit.interval_year_to_month().months()));\n+        type = interval_year();\n+      } else {\n+        RETURN_NOT_OK(builder.Append(lit.interval_day_to_second().days()));\n+        RETURN_NOT_OK(builder.Append(lit.interval_day_to_second().seconds()));\n+        type = interval_day();\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto array, builder.Finish());\n+      return Datum(\n+          ExtensionScalar(FixedSizeListScalar(std::move(array)), std::move(type)));\n+    }\n+\n+    case substrait::Expression::Literal::kUuid:\n+      return Datum(ExtensionScalar(FixedSizeBinaryScalarFromBytes(lit.uuid()), uuid()));\n+\n+    case substrait::Expression::Literal::kFixedChar:\n+      return Datum(\n+          ExtensionScalar(FixedSizeBinaryScalarFromBytes(lit.fixed_char()),\n+                          fixed_char(static_cast<int32_t>(lit.fixed_char().size()))));\n+\n+    case substrait::Expression::Literal::kVarChar:\n+      return Datum(\n+          ExtensionScalar(StringScalar(lit.var_char().value()),\n+                          varchar(static_cast<int32_t>(lit.var_char().length()))));\n+\n+    case substrait::Expression::Literal::kFixedBinary:\n+      return Datum(FixedSizeBinaryScalarFromBytes(lit.fixed_binary()));\n+\n+    case substrait::Expression::Literal::kDecimal: {\n+      if (lit.decimal().value().size() != sizeof(Decimal128)) {\n+        return Status::Invalid(\"Decimal literal had \", lit.decimal().value().size(),\n+                               \" bytes (expected \", sizeof(Decimal128), \")\");\n+      }\n+\n+      Decimal128 value;\n+      std::memcpy(value.mutable_native_endian_bytes(), lit.decimal().value().data(),\n+                  sizeof(Decimal128));\n+#if !ARROW_LITTLE_ENDIAN\n+      std::reverse(value.mutable_native_endian_bytes(),\n+                   value.mutable_native_endian_bytes() + sizeof(Decimal128));\n+#endif\n+      auto type = decimal128(lit.decimal().precision(), lit.decimal().scale());\n+      return Datum(Decimal128Scalar(value, std::move(type)));\n+    }\n+\n+    case substrait::Expression::Literal::kStruct: {\n+      const auto& struct_ = lit.struct_();\n+\n+      ScalarVector fields(struct_.fields_size());\n+      std::vector<std::string> field_names(fields.size(), \"\");\n\nReview comment:\n       Maybe worth a comment here pointing out that, in Substrait, a struct literal has no field names.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n+        ARROW_ASSIGN_OR_RAISE(auto compute_if, FromProto(if_.if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto compute_then, FromProto(if_.then(), ext_set));\n+        conditions.emplace_back(std::move(compute_if));\n+        args.emplace_back(std::move(compute_then));\n+        condition_names.emplace_back(\"cond\" + std::to_string(++name_counter));\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto compute_else, FromProto(if_then.else_(), ext_set));\n+      args.emplace_back(std::move(compute_else));\n+      args[0] = compute::call(\"make_struct\", std::move(conditions),\n+                              compute::MakeStructOptions(condition_names));\n+      return compute::call(\"case_when\", std::move(args));\n+    }\n+\n+    case substrait::Expression::kScalarFunction: {\n+      const auto& scalar_fn = expr.scalar_function();\n+\n+      auto id = ext_set.function_ids()[scalar_fn.function_reference()];\n+\n+      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n+      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n+      }\n+\n+      return compute::call(id.name.to_string(), std::move(arguments));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::compute::Expression from \",\n+                                expr.DebugString());\n+}\n+\n+Result<Datum> FromProto(const substrait::Expression::Literal& lit,\n+                        const ExtensionSet& ext_set) {\n+  if (lit.nullable()) {\n+    // FIXME not sure how this field should be interpreted and there's no way to round\n+    // trip it through arrow\n+    return Status::Invalid(\n+        \"Nullable Literals - Literal.nullable must be left at the default\");\n+  }\n+\n+  switch (lit.literal_type_case()) {\n+    case substrait::Expression::Literal::kBoolean:\n+      return Datum(lit.boolean());\n+\n+    case substrait::Expression::Literal::kI8:\n+      return Datum(static_cast<int8_t>(lit.i8()));\n+    case substrait::Expression::Literal::kI16:\n+      return Datum(static_cast<int16_t>(lit.i16()));\n+    case substrait::Expression::Literal::kI32:\n+      return Datum(static_cast<int32_t>(lit.i32()));\n+    case substrait::Expression::Literal::kI64:\n+      return Datum(static_cast<int64_t>(lit.i64()));\n+\n+    case substrait::Expression::Literal::kFp32:\n+      return Datum(lit.fp32());\n+    case substrait::Expression::Literal::kFp64:\n+      return Datum(lit.fp64());\n+\n+    case substrait::Expression::Literal::kString:\n+      return Datum(lit.string());\n+    case substrait::Expression::Literal::kBinary:\n+      return Datum(BinaryScalar(Buffer::FromString(lit.binary())));\n+\n+    case substrait::Expression::Literal::kTimestamp:\n+      return Datum(\n+          TimestampScalar(static_cast<int64_t>(lit.timestamp()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kTimestampTz:\n+      return Datum(TimestampScalar(static_cast<int64_t>(lit.timestamp_tz()),\n+                                   TimeUnit::MICRO, TimestampTzTimezoneString()));\n+\n+    case substrait::Expression::Literal::kDate:\n+      return Datum(Date64Scalar(static_cast<int64_t>(lit.date())));\n+    case substrait::Expression::Literal::kTime:\n+      return Datum(Time64Scalar(static_cast<int64_t>(lit.time()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kIntervalYearToMonth:\n+    case substrait::Expression::Literal::kIntervalDayToSecond: {\n+      Int32Builder builder;\n+      std::shared_ptr<DataType> type;\n+      if (lit.has_interval_year_to_month()) {\n+        RETURN_NOT_OK(builder.Append(lit.interval_year_to_month().years()));\n+        RETURN_NOT_OK(builder.Append(lit.interval_year_to_month().months()));\n+        type = interval_year();\n+      } else {\n+        RETURN_NOT_OK(builder.Append(lit.interval_day_to_second().days()));\n+        RETURN_NOT_OK(builder.Append(lit.interval_day_to_second().seconds()));\n+        type = interval_day();\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto array, builder.Finish());\n+      return Datum(\n+          ExtensionScalar(FixedSizeListScalar(std::move(array)), std::move(type)));\n+    }\n+\n+    case substrait::Expression::Literal::kUuid:\n+      return Datum(ExtensionScalar(FixedSizeBinaryScalarFromBytes(lit.uuid()), uuid()));\n+\n+    case substrait::Expression::Literal::kFixedChar:\n+      return Datum(\n+          ExtensionScalar(FixedSizeBinaryScalarFromBytes(lit.fixed_char()),\n+                          fixed_char(static_cast<int32_t>(lit.fixed_char().size()))));\n+\n+    case substrait::Expression::Literal::kVarChar:\n+      return Datum(\n+          ExtensionScalar(StringScalar(lit.var_char().value()),\n+                          varchar(static_cast<int32_t>(lit.var_char().length()))));\n\nReview comment:\n       Technically `kVarChar` is not part of the Substrait spec.  But maybe that's just a \"not part of it yet\" kind of thing and so forward planning isn't a bad idea.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n+        ARROW_ASSIGN_OR_RAISE(auto compute_if, FromProto(if_.if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto compute_then, FromProto(if_.then(), ext_set));\n+        conditions.emplace_back(std::move(compute_if));\n+        args.emplace_back(std::move(compute_then));\n+        condition_names.emplace_back(\"cond\" + std::to_string(++name_counter));\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto compute_else, FromProto(if_then.else_(), ext_set));\n+      args.emplace_back(std::move(compute_else));\n+      args[0] = compute::call(\"make_struct\", std::move(conditions),\n+                              compute::MakeStructOptions(condition_names));\n+      return compute::call(\"case_when\", std::move(args));\n+    }\n+\n+    case substrait::Expression::kScalarFunction: {\n+      const auto& scalar_fn = expr.scalar_function();\n+\n+      auto id = ext_set.function_ids()[scalar_fn.function_reference()];\n+\n+      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n+      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n+      }\n+\n+      return compute::call(id.name.to_string(), std::move(arguments));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::compute::Expression from \",\n+                                expr.DebugString());\n+}\n+\n+Result<Datum> FromProto(const substrait::Expression::Literal& lit,\n+                        const ExtensionSet& ext_set) {\n+  if (lit.nullable()) {\n+    // FIXME not sure how this field should be interpreted and there's no way to round\n+    // trip it through arrow\n+    return Status::Invalid(\n+        \"Nullable Literals - Literal.nullable must be left at the default\");\n+  }\n+\n+  switch (lit.literal_type_case()) {\n+    case substrait::Expression::Literal::kBoolean:\n+      return Datum(lit.boolean());\n+\n+    case substrait::Expression::Literal::kI8:\n+      return Datum(static_cast<int8_t>(lit.i8()));\n+    case substrait::Expression::Literal::kI16:\n+      return Datum(static_cast<int16_t>(lit.i16()));\n+    case substrait::Expression::Literal::kI32:\n+      return Datum(static_cast<int32_t>(lit.i32()));\n+    case substrait::Expression::Literal::kI64:\n+      return Datum(static_cast<int64_t>(lit.i64()));\n+\n+    case substrait::Expression::Literal::kFp32:\n+      return Datum(lit.fp32());\n+    case substrait::Expression::Literal::kFp64:\n+      return Datum(lit.fp64());\n+\n+    case substrait::Expression::Literal::kString:\n+      return Datum(lit.string());\n+    case substrait::Expression::Literal::kBinary:\n+      return Datum(BinaryScalar(Buffer::FromString(lit.binary())));\n+\n+    case substrait::Expression::Literal::kTimestamp:\n+      return Datum(\n+          TimestampScalar(static_cast<int64_t>(lit.timestamp()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kTimestampTz:\n+      return Datum(TimestampScalar(static_cast<int64_t>(lit.timestamp_tz()),\n+                                   TimeUnit::MICRO, TimestampTzTimezoneString()));\n+\n+    case substrait::Expression::Literal::kDate:\n+      return Datum(Date64Scalar(static_cast<int64_t>(lit.date())));\n+    case substrait::Expression::Literal::kTime:\n+      return Datum(Time64Scalar(static_cast<int64_t>(lit.time()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kIntervalYearToMonth:\n+    case substrait::Expression::Literal::kIntervalDayToSecond: {\n+      Int32Builder builder;\n+      std::shared_ptr<DataType> type;\n+      if (lit.has_interval_year_to_month()) {\n+        RETURN_NOT_OK(builder.Append(lit.interval_year_to_month().years()));\n+        RETURN_NOT_OK(builder.Append(lit.interval_year_to_month().months()));\n+        type = interval_year();\n+      } else {\n+        RETURN_NOT_OK(builder.Append(lit.interval_day_to_second().days()));\n+        RETURN_NOT_OK(builder.Append(lit.interval_day_to_second().seconds()));\n+        type = interval_day();\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto array, builder.Finish());\n+      return Datum(\n+          ExtensionScalar(FixedSizeListScalar(std::move(array)), std::move(type)));\n+    }\n+\n+    case substrait::Expression::Literal::kUuid:\n+      return Datum(ExtensionScalar(FixedSizeBinaryScalarFromBytes(lit.uuid()), uuid()));\n+\n+    case substrait::Expression::Literal::kFixedChar:\n+      return Datum(\n+          ExtensionScalar(FixedSizeBinaryScalarFromBytes(lit.fixed_char()),\n+                          fixed_char(static_cast<int32_t>(lit.fixed_char().size()))));\n+\n+    case substrait::Expression::Literal::kVarChar:\n+      return Datum(\n+          ExtensionScalar(StringScalar(lit.var_char().value()),\n+                          varchar(static_cast<int32_t>(lit.var_char().length()))));\n+\n+    case substrait::Expression::Literal::kFixedBinary:\n+      return Datum(FixedSizeBinaryScalarFromBytes(lit.fixed_binary()));\n+\n+    case substrait::Expression::Literal::kDecimal: {\n+      if (lit.decimal().value().size() != sizeof(Decimal128)) {\n+        return Status::Invalid(\"Decimal literal had \", lit.decimal().value().size(),\n+                               \" bytes (expected \", sizeof(Decimal128), \")\");\n+      }\n+\n+      Decimal128 value;\n+      std::memcpy(value.mutable_native_endian_bytes(), lit.decimal().value().data(),\n+                  sizeof(Decimal128));\n+#if !ARROW_LITTLE_ENDIAN\n+      std::reverse(value.mutable_native_endian_bytes(),\n+                   value.mutable_native_endian_bytes() + sizeof(Decimal128));\n+#endif\n+      auto type = decimal128(lit.decimal().precision(), lit.decimal().scale());\n+      return Datum(Decimal128Scalar(value, std::move(type)));\n+    }\n+\n+    case substrait::Expression::Literal::kStruct: {\n+      const auto& struct_ = lit.struct_();\n+\n+      ScalarVector fields(struct_.fields_size());\n+      std::vector<std::string> field_names(fields.size(), \"\");\n+      for (int i = 0; i < struct_.fields_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(auto field, FromProto(struct_.fields(i), ext_set));\n+        DCHECK(field.is_scalar());\n+        fields[i] = field.scalar();\n+      }\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto scalar, StructScalar::Make(std::move(fields), std::move(field_names)));\n+      return Datum(std::move(scalar));\n+    }\n+\n+    case substrait::Expression::Literal::kList: {\n+      const auto& list = lit.list();\n+      if (list.values_size() == 0) {\n+        return Status::Invalid(\n+            \"substrait::Expression::Literal::List had no values; should have been an \"\n+            \"substrait::Expression::Literal::EmptyList\");\n+      }\n+\n+      std::shared_ptr<DataType> element_type;\n+\n+      ScalarVector values(list.values_size());\n+      for (int i = 0; i < list.values_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(auto value, FromProto(list.values(i), ext_set));\n+        DCHECK(value.is_scalar());\n+        values[i] = value.scalar();\n+        if (element_type) {\n+          if (!value.type()->Equals(*element_type)) {\n+            return Status::Invalid(\n+                list.DebugString(),\n+                \" has a value whose type doesn't match the other list values\");\n+          }\n+        } else {\n+          element_type = value.type();\n+        }\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto builder, MakeBuilder(std::move(element_type)));\n+      RETURN_NOT_OK(builder->AppendScalars(values));\n+      ARROW_ASSIGN_OR_RAISE(auto arr, builder->Finish());\n+      return Datum(ListScalar(std::move(arr)));\n+    }\n+\n+    case substrait::Expression::Literal::kMap: {\n+      const auto& map = lit.map();\n+      if (map.key_values_size() == 0) {\n+        return Status::Invalid(\n+            \"substrait::Expression::Literal::Map had no values; should have been an \"\n+            \"substrait::Expression::Literal::EmptyMap\");\n+      }\n+\n+      std::shared_ptr<DataType> key_type, value_type;\n+      ScalarVector keys(map.key_values_size()), values(map.key_values_size());\n+      for (int i = 0; i < map.key_values_size(); ++i) {\n+        const auto& kv = map.key_values(i);\n+\n+        static const std::array<char const*, 4> kMissing = {\"key and value\", \"value\",\n+                                                            \"key\", nullptr};\n+        if (auto missing = kMissing[kv.has_key() + kv.has_value() * 2]) {\n+          return Status::Invalid(\"While converting to MapScalar encountered missing \",\n+                                 missing, \" in \", map.DebugString());\n+        }\n+        ARROW_ASSIGN_OR_RAISE(auto key, FromProto(kv.key(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto value, FromProto(kv.value(), ext_set));\n+\n+        DCHECK(key.is_scalar());\n+        DCHECK(value.is_scalar());\n+\n+        keys[i] = key.scalar();\n+        values[i] = value.scalar();\n+\n+        if (key_type) {\n+          if (!key.type()->Equals(*key_type)) {\n+            return Status::Invalid(map.DebugString(),\n+                                   \" has a key whose type doesn't match key_type\");\n+          }\n+        } else {\n+          key_type = value.type();\n+        }\n+\n+        if (value_type) {\n+          if (!value.type()->Equals(*value_type)) {\n+            return Status::Invalid(map.DebugString(),\n+                                   \" has a value whose type doesn't match value_type\");\n+          }\n+        } else {\n+          value_type = value.type();\n+        }\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto key_builder, MakeBuilder(key_type));\n+      ARROW_ASSIGN_OR_RAISE(auto value_builder, MakeBuilder(value_type));\n+      RETURN_NOT_OK(key_builder->AppendScalars(keys));\n+      RETURN_NOT_OK(value_builder->AppendScalars(values));\n+      ARROW_ASSIGN_OR_RAISE(auto key_arr, key_builder->Finish());\n+      ARROW_ASSIGN_OR_RAISE(auto value_arr, value_builder->Finish());\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto kv_arr,\n+          StructArray::Make(ArrayVector{std::move(key_arr), std::move(value_arr)},\n+                            std::vector<std::string>{\"key\", \"value\"}));\n+      return Datum(std::make_shared<MapScalar>(std::move(kv_arr)));\n+    }\n+\n+    case substrait::Expression::Literal::kEmptyList: {\n+      ARROW_ASSIGN_OR_RAISE(auto type_nullable,\n+                            FromProto(lit.empty_list().type(), ext_set));\n+      ARROW_ASSIGN_OR_RAISE(auto values, MakeEmptyArray(type_nullable.first));\n+      return ListScalar{std::move(values)};\n+    }\n+\n+    case substrait::Expression::Literal::kEmptyMap: {\n+      ARROW_ASSIGN_OR_RAISE(auto key_type_nullable,\n+                            FromProto(lit.empty_map().key(), ext_set));\n+      ARROW_ASSIGN_OR_RAISE(auto keys,\n+                            MakeEmptyArray(std::move(key_type_nullable.first)));\n+\n+      ARROW_ASSIGN_OR_RAISE(auto value_type_nullable,\n+                            FromProto(lit.empty_map().value(), ext_set));\n+      ARROW_ASSIGN_OR_RAISE(auto values,\n+                            MakeEmptyArray(std::move(value_type_nullable.first)));\n+\n+      auto map_type = std::make_shared<MapType>(keys->type(), values->type());\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto key_values,\n+          StructArray::Make(\n+              {std::move(keys), std::move(values)},\n+              checked_cast<const ListType&>(*map_type).value_type()->fields()));\n+\n+      return MapScalar{std::move(key_values)};\n+    }\n+\n+    case substrait::Expression::Literal::kNull: {\n+      ARROW_ASSIGN_OR_RAISE(auto type_nullable, FromProto(lit.null(), ext_set));\n+      if (!type_nullable.second) {\n+        return Status::Invalid(\"Null literal \", lit.DebugString(),\n+                               \" is of non-nullable type\");\n+      }\n+\n+      return Datum(MakeNullScalar(std::move(type_nullable.first)));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::Datum from \", lit.DebugString());\n\nReview comment:\n       ```suggestion\r\n     return Status::NotImplemented(\"conversion to arrow::Datum from Substrait literal \", lit.DebugString());\r\n   ```\r\n   I don't know if `lit.DebugString()` would obviously be a substrait literal or not (if it is obvious in some way then this change isn't needed).  I'm imagining a user that tries to run some Ibis query and gets this message and submits it to JIRA.\r\n   \r\n   The same logic applies to the other fallback `NotImplemented` cases.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n+        ARROW_ASSIGN_OR_RAISE(auto compute_if, FromProto(if_.if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto compute_then, FromProto(if_.then(), ext_set));\n+        conditions.emplace_back(std::move(compute_if));\n+        args.emplace_back(std::move(compute_then));\n+        condition_names.emplace_back(\"cond\" + std::to_string(++name_counter));\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto compute_else, FromProto(if_then.else_(), ext_set));\n+      args.emplace_back(std::move(compute_else));\n+      args[0] = compute::call(\"make_struct\", std::move(conditions),\n+                              compute::MakeStructOptions(condition_names));\n+      return compute::call(\"case_when\", std::move(args));\n+    }\n+\n+    case substrait::Expression::kScalarFunction: {\n+      const auto& scalar_fn = expr.scalar_function();\n+\n+      auto id = ext_set.function_ids()[scalar_fn.function_reference()];\n+\n+      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n+      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n+      }\n+\n+      return compute::call(id.name.to_string(), std::move(arguments));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::compute::Expression from \",\n+                                expr.DebugString());\n+}\n+\n+Result<Datum> FromProto(const substrait::Expression::Literal& lit,\n+                        const ExtensionSet& ext_set) {\n+  if (lit.nullable()) {\n+    // FIXME not sure how this field should be interpreted and there's no way to round\n+    // trip it through arrow\n+    return Status::Invalid(\n+        \"Nullable Literals - Literal.nullable must be left at the default\");\n+  }\n+\n+  switch (lit.literal_type_case()) {\n+    case substrait::Expression::Literal::kBoolean:\n+      return Datum(lit.boolean());\n+\n+    case substrait::Expression::Literal::kI8:\n+      return Datum(static_cast<int8_t>(lit.i8()));\n+    case substrait::Expression::Literal::kI16:\n+      return Datum(static_cast<int16_t>(lit.i16()));\n+    case substrait::Expression::Literal::kI32:\n+      return Datum(static_cast<int32_t>(lit.i32()));\n+    case substrait::Expression::Literal::kI64:\n+      return Datum(static_cast<int64_t>(lit.i64()));\n+\n+    case substrait::Expression::Literal::kFp32:\n+      return Datum(lit.fp32());\n+    case substrait::Expression::Literal::kFp64:\n+      return Datum(lit.fp64());\n+\n+    case substrait::Expression::Literal::kString:\n+      return Datum(lit.string());\n+    case substrait::Expression::Literal::kBinary:\n+      return Datum(BinaryScalar(Buffer::FromString(lit.binary())));\n+\n+    case substrait::Expression::Literal::kTimestamp:\n+      return Datum(\n+          TimestampScalar(static_cast<int64_t>(lit.timestamp()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kTimestampTz:\n+      return Datum(TimestampScalar(static_cast<int64_t>(lit.timestamp_tz()),\n+                                   TimeUnit::MICRO, TimestampTzTimezoneString()));\n\nReview comment:\n       Nit: `TimestampTzTimezoneString` is a weird name for \"UTC\" but I can kind of see the reasoning.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n+        ARROW_ASSIGN_OR_RAISE(auto compute_if, FromProto(if_.if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto compute_then, FromProto(if_.then(), ext_set));\n+        conditions.emplace_back(std::move(compute_if));\n+        args.emplace_back(std::move(compute_then));\n+        condition_names.emplace_back(\"cond\" + std::to_string(++name_counter));\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto compute_else, FromProto(if_then.else_(), ext_set));\n+      args.emplace_back(std::move(compute_else));\n+      args[0] = compute::call(\"make_struct\", std::move(conditions),\n+                              compute::MakeStructOptions(condition_names));\n+      return compute::call(\"case_when\", std::move(args));\n+    }\n+\n+    case substrait::Expression::kScalarFunction: {\n+      const auto& scalar_fn = expr.scalar_function();\n+\n+      auto id = ext_set.function_ids()[scalar_fn.function_reference()];\n+\n+      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n+      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n+      }\n+\n+      return compute::call(id.name.to_string(), std::move(arguments));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::compute::Expression from \",\n+                                expr.DebugString());\n+}\n+\n+Result<Datum> FromProto(const substrait::Expression::Literal& lit,\n+                        const ExtensionSet& ext_set) {\n+  if (lit.nullable()) {\n+    // FIXME not sure how this field should be interpreted and there's no way to round\n+    // trip it through arrow\n+    return Status::Invalid(\n+        \"Nullable Literals - Literal.nullable must be left at the default\");\n+  }\n+\n+  switch (lit.literal_type_case()) {\n+    case substrait::Expression::Literal::kBoolean:\n+      return Datum(lit.boolean());\n+\n+    case substrait::Expression::Literal::kI8:\n+      return Datum(static_cast<int8_t>(lit.i8()));\n+    case substrait::Expression::Literal::kI16:\n+      return Datum(static_cast<int16_t>(lit.i16()));\n+    case substrait::Expression::Literal::kI32:\n+      return Datum(static_cast<int32_t>(lit.i32()));\n+    case substrait::Expression::Literal::kI64:\n+      return Datum(static_cast<int64_t>(lit.i64()));\n+\n+    case substrait::Expression::Literal::kFp32:\n+      return Datum(lit.fp32());\n+    case substrait::Expression::Literal::kFp64:\n+      return Datum(lit.fp64());\n+\n+    case substrait::Expression::Literal::kString:\n+      return Datum(lit.string());\n+    case substrait::Expression::Literal::kBinary:\n+      return Datum(BinaryScalar(Buffer::FromString(lit.binary())));\n+\n+    case substrait::Expression::Literal::kTimestamp:\n+      return Datum(\n+          TimestampScalar(static_cast<int64_t>(lit.timestamp()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kTimestampTz:\n+      return Datum(TimestampScalar(static_cast<int64_t>(lit.timestamp_tz()),\n+                                   TimeUnit::MICRO, TimestampTzTimezoneString()));\n+\n+    case substrait::Expression::Literal::kDate:\n+      return Datum(Date64Scalar(static_cast<int64_t>(lit.date())));\n+    case substrait::Expression::Literal::kTime:\n+      return Datum(Time64Scalar(static_cast<int64_t>(lit.time()), TimeUnit::MICRO));\n+\n+    case substrait::Expression::Literal::kIntervalYearToMonth:\n+    case substrait::Expression::Literal::kIntervalDayToSecond: {\n+      Int32Builder builder;\n+      std::shared_ptr<DataType> type;\n+      if (lit.has_interval_year_to_month()) {\n+        RETURN_NOT_OK(builder.Append(lit.interval_year_to_month().years()));\n+        RETURN_NOT_OK(builder.Append(lit.interval_year_to_month().months()));\n+        type = interval_year();\n+      } else {\n+        RETURN_NOT_OK(builder.Append(lit.interval_day_to_second().days()));\n+        RETURN_NOT_OK(builder.Append(lit.interval_day_to_second().seconds()));\n+        type = interval_day();\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto array, builder.Finish());\n+      return Datum(\n+          ExtensionScalar(FixedSizeListScalar(std::move(array)), std::move(type)));\n+    }\n+\n+    case substrait::Expression::Literal::kUuid:\n+      return Datum(ExtensionScalar(FixedSizeBinaryScalarFromBytes(lit.uuid()), uuid()));\n+\n+    case substrait::Expression::Literal::kFixedChar:\n+      return Datum(\n+          ExtensionScalar(FixedSizeBinaryScalarFromBytes(lit.fixed_char()),\n+                          fixed_char(static_cast<int32_t>(lit.fixed_char().size()))));\n+\n+    case substrait::Expression::Literal::kVarChar:\n+      return Datum(\n+          ExtensionScalar(StringScalar(lit.var_char().value()),\n+                          varchar(static_cast<int32_t>(lit.var_char().length()))));\n+\n+    case substrait::Expression::Literal::kFixedBinary:\n+      return Datum(FixedSizeBinaryScalarFromBytes(lit.fixed_binary()));\n+\n+    case substrait::Expression::Literal::kDecimal: {\n+      if (lit.decimal().value().size() != sizeof(Decimal128)) {\n+        return Status::Invalid(\"Decimal literal had \", lit.decimal().value().size(),\n+                               \" bytes (expected \", sizeof(Decimal128), \")\");\n+      }\n+\n+      Decimal128 value;\n+      std::memcpy(value.mutable_native_endian_bytes(), lit.decimal().value().data(),\n+                  sizeof(Decimal128));\n+#if !ARROW_LITTLE_ENDIAN\n+      std::reverse(value.mutable_native_endian_bytes(),\n+                   value.mutable_native_endian_bytes() + sizeof(Decimal128));\n+#endif\n+      auto type = decimal128(lit.decimal().precision(), lit.decimal().scale());\n+      return Datum(Decimal128Scalar(value, std::move(type)));\n+    }\n+\n+    case substrait::Expression::Literal::kStruct: {\n+      const auto& struct_ = lit.struct_();\n+\n+      ScalarVector fields(struct_.fields_size());\n+      std::vector<std::string> field_names(fields.size(), \"\");\n+      for (int i = 0; i < struct_.fields_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(auto field, FromProto(struct_.fields(i), ext_set));\n+        DCHECK(field.is_scalar());\n+        fields[i] = field.scalar();\n+      }\n+      ARROW_ASSIGN_OR_RAISE(\n+          auto scalar, StructScalar::Make(std::move(fields), std::move(field_names)));\n+      return Datum(std::move(scalar));\n+    }\n+\n+    case substrait::Expression::Literal::kList: {\n+      const auto& list = lit.list();\n+      if (list.values_size() == 0) {\n+        return Status::Invalid(\n+            \"substrait::Expression::Literal::List had no values; should have been an \"\n+            \"substrait::Expression::Literal::EmptyList\");\n+      }\n+\n+      std::shared_ptr<DataType> element_type;\n+\n+      ScalarVector values(list.values_size());\n+      for (int i = 0; i < list.values_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(auto value, FromProto(list.values(i), ext_set));\n+        DCHECK(value.is_scalar());\n+        values[i] = value.scalar();\n+        if (element_type) {\n+          if (!value.type()->Equals(*element_type)) {\n+            return Status::Invalid(\n+                list.DebugString(),\n+                \" has a value whose type doesn't match the other list values\");\n+          }\n+        } else {\n+          element_type = value.type();\n+        }\n+      }\n+\n+      ARROW_ASSIGN_OR_RAISE(auto builder, MakeBuilder(std::move(element_type)));\n+      RETURN_NOT_OK(builder->AppendScalars(values));\n+      ARROW_ASSIGN_OR_RAISE(auto arr, builder->Finish());\n+      return Datum(ListScalar(std::move(arr)));\n+    }\n+\n+    case substrait::Expression::Literal::kMap: {\n+      const auto& map = lit.map();\n+      if (map.key_values_size() == 0) {\n+        return Status::Invalid(\n+            \"substrait::Expression::Literal::Map had no values; should have been an \"\n+            \"substrait::Expression::Literal::EmptyMap\");\n+      }\n+\n+      std::shared_ptr<DataType> key_type, value_type;\n+      ScalarVector keys(map.key_values_size()), values(map.key_values_size());\n+      for (int i = 0; i < map.key_values_size(); ++i) {\n+        const auto& kv = map.key_values(i);\n+\n+        static const std::array<char const*, 4> kMissing = {\"key and value\", \"value\",\n+                                                            \"key\", nullptr};\n+        if (auto missing = kMissing[kv.has_key() + kv.has_value() * 2]) {\n\nReview comment:\n       This is right on the edge of too clever for your own good :laughing: \n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n\nReview comment:\n       Will the error be clear enough here?  I suppose we can always figure it out but I wonder if it might be clearer to say that \"we have only implemented direct references\" or something to that effect.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/serde.h\n##########\n@@ -0,0 +1,79 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <functional>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/engine/substrait/extension_set.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+using ConsumerFactory = std::function<std::shared_ptr<compute::SinkNodeConsumer>()>;\n+\n+ARROW_ENGINE_EXPORT Result<std::vector<compute::Declaration>> DeserializePlan(\n+    const Buffer&, const ConsumerFactory&, ExtensionSet* ext_set = NULLPTR);\n+\n+ARROW_ENGINE_EXPORT\n+Result<std::shared_ptr<DataType>> DeserializeType(const Buffer&, const ExtensionSet&);\n+\n+ARROW_ENGINE_EXPORT\n+Result<std::shared_ptr<Buffer>> SerializeType(const DataType&, ExtensionSet*);\n+\n+ARROW_ENGINE_EXPORT\n+Result<std::shared_ptr<Schema>> DeserializeSchema(const Buffer&, const ExtensionSet&);\n+\n+ARROW_ENGINE_EXPORT\n+Result<std::shared_ptr<Buffer>> SerializeSchema(const Schema&, ExtensionSet*);\n+\n+ARROW_ENGINE_EXPORT\n+Result<compute::Expression> DeserializeExpression(const Buffer&, const ExtensionSet&);\n+\n+ARROW_ENGINE_EXPORT\n+Result<std::shared_ptr<Buffer>> SerializeExpression(const compute::Expression&,\n+                                                    ExtensionSet*);\n\nReview comment:\n       What's the use case for serializing?  Is that for testing and internal use only?\n\n##########\nFile path: cpp/src/arrow/engine/substrait/serde.h\n##########\n@@ -0,0 +1,79 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <functional>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/engine/substrait/extension_set.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+using ConsumerFactory = std::function<std::shared_ptr<compute::SinkNodeConsumer>()>;\n+\n+ARROW_ENGINE_EXPORT Result<std::vector<compute::Declaration>> DeserializePlan(\n\nReview comment:\n       It doesn't have to be done in this PR but, as this is probably the primary user interface to the consumer, we should document the methods in this file.  Feel free to file a follow-up JIRA.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.cc\n##########\n@@ -0,0 +1,902 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+\n+#include <utility>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/expression_internal.h\"\n+#include \"arrow/engine/substrait/extension_types.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+#include \"arrow/visit_scalar_inline.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace engine {\n+\n+namespace internal {\n+using ::arrow::internal::make_unique;\n+}  // namespace internal\n+\n+namespace {\n+\n+std::shared_ptr<FixedSizeBinaryScalar> FixedSizeBinaryScalarFromBytes(\n+    const std::string& bytes) {\n+  auto buf = Buffer::FromString(bytes);\n+  auto type = fixed_size_binary(static_cast<int>(buf->size()));\n+  return std::make_shared<FixedSizeBinaryScalar>(std::move(buf), std::move(type));\n+}\n+\n+}  // namespace\n+\n+Result<compute::Expression> FromProto(const substrait::Expression& expr,\n+                                      const ExtensionSet& ext_set) {\n+  switch (expr.rex_type_case()) {\n+    case substrait::Expression::kLiteral: {\n+      ARROW_ASSIGN_OR_RAISE(auto datum, FromProto(expr.literal(), ext_set));\n+      return compute::literal(std::move(datum));\n+    }\n+\n+    case substrait::Expression::kSelection: {\n+      if (!expr.selection().has_direct_reference()) break;\n+\n+      util::optional<compute::Expression> out;\n+      if (expr.selection().has_expression()) {\n+        ARROW_ASSIGN_OR_RAISE(out, FromProto(expr.selection().expression(), ext_set));\n+      }\n+\n+      const auto* ref = &expr.selection().direct_reference();\n+      while (ref != nullptr) {\n+        switch (ref->reference_type_case()) {\n+          case substrait::Expression::ReferenceSegment::kStructField: {\n+            auto index = ref->struct_field().field();\n+            if (!out) {\n+              // Root StructField (column selection)\n+              out = compute::field_ref(FieldRef(index));\n+            } else if (auto out_ref = out->field_ref()) {\n+              // Nested StructFields on the root (selection of struct-typed column\n+              // combined with selecting struct fields)\n+              out = compute::field_ref(FieldRef(*out_ref, index));\n+            } else if (out->call() && out->call()->function_name == \"struct_field\") {\n+              // Nested StructFields on top of an arbitrary expression\n+              std::static_pointer_cast<arrow::compute::StructFieldOptions>(\n+                  out->call()->options)\n+                  ->indices.push_back(index);\n+            } else {\n+              // First StructField on top of an arbitrary expression\n+              out = compute::call(\"struct_field\", {std::move(*out)},\n+                                  arrow::compute::StructFieldOptions({index}));\n+            }\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->struct_field().has_child()) {\n+              ref = &ref->struct_field().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          case substrait::Expression::ReferenceSegment::kListElement: {\n+            if (!out) {\n+              // Root ListField (illegal)\n+              return Status::Invalid(\n+                  \"substrait::ListElement cannot take a Relation as an argument\");\n+            }\n+\n+            // ListField on top of an arbitrary expression\n+            out = compute::call(\n+                \"list_element\",\n+                {std::move(*out), compute::literal(ref->list_element().offset())});\n+\n+            // Segment handled, continue with child segment (if any)\n+            if (ref->list_element().has_child()) {\n+              ref = &ref->list_element().child();\n+            } else {\n+              ref = nullptr;\n+            }\n+            break;\n+          }\n+          default:\n+            // Unimplemented construct, break out of loop\n+            out.reset();\n+            ref = nullptr;\n+        }\n+      }\n+      if (out) {\n+        return *std::move(out);\n+      }\n+      break;\n+    }\n+\n+    case substrait::Expression::kIfThen: {\n+      const auto& if_then = expr.if_then();\n+      if (!if_then.has_else_()) break;\n+      if (if_then.ifs_size() == 0) break;\n+\n+      if (if_then.ifs_size() == 1) {\n+        ARROW_ASSIGN_OR_RAISE(auto if_, FromProto(if_then.ifs(0).if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto then, FromProto(if_then.ifs(0).then(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto else_, FromProto(if_then.else_(), ext_set));\n+        return compute::call(\"if_else\",\n+                             {std::move(if_), std::move(then), std::move(else_)});\n+      }\n+\n+      std::vector<compute::Expression> conditions, args;\n+      std::vector<std::string> condition_names;\n+      conditions.reserve(if_then.ifs_size());\n+      condition_names.reserve(if_then.ifs_size());\n+      size_t name_counter = 0;\n+      args.reserve(if_then.ifs_size() + 2);\n+      args.emplace_back();\n+      for (auto if_ : if_then.ifs()) {\n+        ARROW_ASSIGN_OR_RAISE(auto compute_if, FromProto(if_.if_(), ext_set));\n+        ARROW_ASSIGN_OR_RAISE(auto compute_then, FromProto(if_.then(), ext_set));\n+        conditions.emplace_back(std::move(compute_if));\n+        args.emplace_back(std::move(compute_then));\n+        condition_names.emplace_back(\"cond\" + std::to_string(++name_counter));\n+      }\n+      ARROW_ASSIGN_OR_RAISE(auto compute_else, FromProto(if_then.else_(), ext_set));\n+      args.emplace_back(std::move(compute_else));\n+      args[0] = compute::call(\"make_struct\", std::move(conditions),\n+                              compute::MakeStructOptions(condition_names));\n+      return compute::call(\"case_when\", std::move(args));\n+    }\n+\n+    case substrait::Expression::kScalarFunction: {\n+      const auto& scalar_fn = expr.scalar_function();\n+\n+      auto id = ext_set.function_ids()[scalar_fn.function_reference()];\n+\n+      std::vector<compute::Expression> arguments(scalar_fn.args_size());\n+      for (int i = 0; i < scalar_fn.args_size(); ++i) {\n+        ARROW_ASSIGN_OR_RAISE(arguments[i], FromProto(scalar_fn.args(i), ext_set));\n+      }\n+\n+      return compute::call(id.name.to_string(), std::move(arguments));\n+    }\n+\n+    default:\n+      break;\n+  }\n+\n+  return Status::NotImplemented(\"conversion to arrow::compute::Expression from \",\n\nReview comment:\n       There's a number of features in the Substrait proto that we don't support yet (e.g. switch_expression, single_or_list, multi_or_list).  I'm not recommending we handle those as part of this PR (it is plenty big enough) but I wonder how we track what portion of the spec we've implemented so far?\n\n##########\nFile path: cpp/src/arrow/engine/substrait/relation_internal.cc\n##########\n@@ -0,0 +1,186 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/relation_internal.h\"\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/dataset/file_parquet.h\"\n+#include \"arrow/dataset/plan.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/filesystem/localfs.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+template <typename RelMessage>\n+Status CheckRelCommon(const RelMessage& rel) {\n+  if (rel.has_common()) {\n+    if (rel.common().has_emit()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Emit\");\n+    }\n+    if (rel.common().has_hint()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Hint\");\n+    }\n\nReview comment:\n       Seems like we could ignore this.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/expression_internal.h\n##########\n@@ -0,0 +1,49 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <utility>\n+\n+#include \"arrow/compute/type_fwd.h\"\n+#include \"arrow/engine/substrait/extension_set.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/type_fwd.h\"\n+\n+#include \"substrait/expression.pb.h\"  // IWYU pragma: export\n+\n+namespace arrow {\n+namespace engine {\n+\n+ARROW_ENGINE_EXPORT\n+Result<compute::Expression> FromProto(const substrait::Expression&, const ExtensionSet&);\n+\n+ARROW_ENGINE_EXPORT\n+Result<std::unique_ptr<substrait::Expression>> ToProto(const compute::Expression&,\n+                                                       ExtensionSet*);\n+\n+ARROW_ENGINE_EXPORT\n+Result<Datum> FromProto(const substrait::Expression::Literal&, const ExtensionSet&);\n+\n+ARROW_ENGINE_EXPORT\n+Result<std::unique_ptr<substrait::Expression::Literal>> ToProto(const Datum&,\n+                                                                ExtensionSet*);\n\nReview comment:\n       Super minor nit:  I kind of prefer `FromProtoLiteral`, `FromProtoExpression`, `ToProtoLiteral`, and `ToProtoExpression` vs. the overloaded names.  \n\n##########\nFile path: cpp/src/arrow/engine/substrait/relation_internal.cc\n##########\n@@ -0,0 +1,186 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/relation_internal.h\"\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/dataset/file_parquet.h\"\n+#include \"arrow/dataset/plan.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/filesystem/localfs.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+template <typename RelMessage>\n+Status CheckRelCommon(const RelMessage& rel) {\n+  if (rel.has_common()) {\n+    if (rel.common().has_emit()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Emit\");\n+    }\n+    if (rel.common().has_hint()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Hint\");\n+    }\n+    if (rel.common().has_advanced_extension()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::advanced_extension\");\n+    }\n+  }\n+  if (rel.has_advanced_extension()) {\n+    return Status::NotImplemented(\"substrait AdvancedExtensions\");\n+  }\n+  return Status::OK();\n+}\n+\n+Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n+                                       const ExtensionSet& ext_set) {\n+  static bool dataset_init = false;\n+  if (!dataset_init) {\n+    dataset_init = true;\n+    dataset::internal::Initialize();\n+  }\n+\n+  switch (rel.rel_type_case()) {\n+    case substrait::Rel::RelTypeCase::kRead: {\n+      const auto& read = rel.read();\n+      RETURN_NOT_OK(CheckRelCommon(read));\n+\n+      ARROW_ASSIGN_OR_RAISE(auto base_schema, FromProto(read.base_schema(), ext_set));\n+\n+      auto scan_options = std::make_shared<dataset::ScanOptions>();\n+\n+      if (read.has_filter()) {\n+        ARROW_ASSIGN_OR_RAISE(scan_options->filter, FromProto(read.filter(), ext_set));\n+      }\n+\n+      if (read.has_projection()) {\n+        return Status::NotImplemented(\"substrait::ReadRel::projection\");\n+      }\n\nReview comment:\n       Let's add a JIRA for this.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/relation_internal.cc\n##########\n@@ -0,0 +1,186 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/relation_internal.h\"\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/dataset/file_parquet.h\"\n+#include \"arrow/dataset/plan.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/filesystem/localfs.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+template <typename RelMessage>\n+Status CheckRelCommon(const RelMessage& rel) {\n+  if (rel.has_common()) {\n+    if (rel.common().has_emit()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Emit\");\n+    }\n\nReview comment:\n       This is basically a project right?  Let's add a JIRA for this.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/extension_set.cc\n##########\n@@ -0,0 +1,346 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/extension_set.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/util/hash_util.h\"\n+#include \"arrow/util/hashing.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+namespace arrow {\n+namespace engine {\n+namespace {\n+\n+struct TypePtrHashEq {\n+  template <typename Ptr>\n+  size_t operator()(const Ptr& type) const {\n+    return type->Hash();\n+  }\n+\n+  template <typename Ptr>\n+  bool operator()(const Ptr& l, const Ptr& r) const {\n+    return *l == *r;\n+  }\n+};\n+\n+struct IdHashEq {\n+  using Id = ExtensionSet::Id;\n+\n+  size_t operator()(Id id) const {\n+    constexpr ::arrow::internal::StringViewHash hash = {};\n+    auto out = static_cast<size_t>(hash(id.uri));\n+    ::arrow::internal::hash_combine(out, hash(id.name));\n+    return out;\n+  }\n+\n+  bool operator()(Id l, Id r) const { return l.uri == r.uri && l.name == r.name; }\n+};\n+\n+}  // namespace\n+\n+struct ExtensionSet::Impl {\n+  void AddUri(util::string_view uri, ExtensionSet* self) {\n+    if (uris_.find(uri) != uris_.end()) return;\n+\n+    self->uris_.push_back(uri);\n+    uris_.insert(self->uris_.back());  // lookup helper's keys should reference memory\n+                                       // owned by this ExtensionSet\n+  }\n+\n+  Status CheckHasUri(util::string_view uri) {\n+    if (uris_.find(uri) != uris_.end()) return Status::OK();\n+\n+    return Status::Invalid(\n+        \"Uri \", uri,\n+        \" was referenced by an extension but was not declared in the ExtensionSet.\");\n+  }\n+\n+  uint32_t EncodeType(Id id, const std::shared_ptr<DataType>& type, bool is_variation,\n+                      ExtensionSet* self) {\n+    // note: at this point we're guaranteed to have an Id which points to memory owned by\n+    // the set's registry.\n+    AddUri(id.uri, self);\n+    auto it_success = types_.emplace(id, static_cast<uint32_t>(types_.size()));\n+\n+    if (it_success.second) {\n+      DCHECK_EQ(self->type_ids_.size(), self->types_.size());\n+      self->type_ids_.push_back(id);\n+      self->types_.push_back(type);\n+      self->type_is_variation_.push_back(is_variation);\n+    }\n+\n+    return it_success.first->second;\n+  }\n+\n+  uint32_t EncodeFunction(Id id, util::string_view function_name, ExtensionSet* self) {\n+    // note: at this point we're guaranteed to have an Id which points to memory owned by\n+    // the set's registry.\n+    AddUri(id.uri, self);\n+    auto it_success = functions_.emplace(id, static_cast<uint32_t>(functions_.size()));\n+\n+    if (it_success.second) {\n+      DCHECK_EQ(self->function_ids_.size(), self->function_names_.size());\n+      self->function_ids_.push_back(id);\n+      self->function_names_.push_back(function_name);\n+    }\n+\n+    return it_success.first->second;\n+  }\n+\n+  std::unordered_set<util::string_view, ::arrow::internal::StringViewHash> uris_;\n+  std::unordered_map<Id, uint32_t, IdHashEq, IdHashEq> types_, functions_;\n+};\n+\n+ExtensionSet::ExtensionSet(ExtensionIdRegistry* registry)\n+    : registry_(registry), impl_(new Impl(), [](Impl* impl) { delete impl; }) {}\n+\n+Result<ExtensionSet> ExtensionSet::Make(std::vector<util::string_view> uris,\n+                                        std::vector<Id> type_ids,\n+                                        std::vector<bool> type_is_variation,\n+                                        std::vector<Id> function_ids,\n+                                        ExtensionIdRegistry* registry) {\n+  ExtensionSet set;\n+  set.registry_ = registry;\n+\n+  // TODO(bkietz) move this into the registry as registry->OwnUris(&uris) or so\n+  std::unordered_set<util::string_view, ::arrow::internal::StringViewHash>\n+      uris_owned_by_registry;\n+  for (util::string_view uri : registry->Uris()) {\n+    uris_owned_by_registry.insert(uri);\n+  }\n+\n+  for (auto& uri : uris) {\n+    if (uri.empty()) continue;\n+    auto it = uris_owned_by_registry.find(uri);\n+    if (it == uris_owned_by_registry.end()) {\n+      return Status::KeyError(\"Uri '\", uri, \"' not found in registry\");\n+    }\n+    uri = *it;  // Ensure uris point into the registry's memory\n+    set.impl_->AddUri(*it, &set);\n+  }\n+\n+  if (type_ids.size() != type_is_variation.size()) {\n+    return Status::Invalid(\"Received \", type_ids.size(), \" type ids but a \",\n+                           type_is_variation.size(), \"-long is_variation vector\");\n+  }\n+\n+  set.types_.resize(type_ids.size());\n+\n+  for (size_t i = 0; i < type_ids.size(); ++i) {\n+    if (type_ids[i].empty()) continue;\n+    RETURN_NOT_OK(set.impl_->CheckHasUri(type_ids[i].uri));\n+\n+    if (auto rec = registry->GetType(type_ids[i], type_is_variation[i])) {\n+      set.types_[i] = rec->type;\n+      type_ids[i] = rec->id;  // use Id which references memory owned by the registry\n+      continue;\n+    }\n+    return Status::Invalid(\"Type\", (type_is_variation[i] ? \" variation\" : \"\"), \" \",\n+                           type_ids[i].uri, \"#\", type_ids[i].name, \" not found\");\n+  }\n+\n+  set.function_names_.resize(function_ids.size());\n+\n+  for (size_t i = 0; i < function_ids.size(); ++i) {\n+    if (function_ids[i].empty()) continue;\n+    RETURN_NOT_OK(set.impl_->CheckHasUri(function_ids[i].uri));\n+\n+    if (auto rec = registry->GetFunction(function_ids[i])) {\n+      set.function_names_[i] = rec->function_name;\n+      function_ids[i] = rec->id;  // use Id which references memory owned by the registry\n+      continue;\n+    }\n+    return Status::Invalid(\"Function \", function_ids[i].uri, \"#\", type_ids[i].name,\n+                           \" not found\");\n+  }\n+\n+  set.function_ids_ = std::move(function_ids);\n+  set.type_ids_ = std::move(type_ids);\n+  set.type_is_variation_ = std::move(type_is_variation);\n+  set.uris_ = std::move(uris);\n+\n+  return std::move(set);\n+}\n+\n+Result<uint32_t> ExtensionSet::EncodeType(const DataType& type) {\n+  if (auto rec = registry_->GetType(type)) {\n+    return impl_->EncodeType(rec->id, rec->type, rec->is_variation, this);\n+  }\n+  return Status::KeyError(\"type \", type.ToString(), \" not found in the registry\");\n+}\n+\n+Result<uint32_t> ExtensionSet::EncodeFunction(util::string_view function_name) {\n+  if (auto rec = registry_->GetFunction(function_name)) {\n+    return impl_->EncodeFunction(rec->id, rec->function_name, this);\n+  }\n+  return Status::KeyError(\"function \", function_name, \" not found in the registry\");\n+}\n+\n+template <typename KeyToIndex, typename Key>\n+const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n+  auto it = key_to_index.find(key);\n+  if (it == key_to_index.end()) return nullptr;\n+  return &it->second;\n+}\n+\n+ExtensionIdRegistry* default_extension_id_registry() {\n+  static struct Impl : ExtensionIdRegistry {\n+    Impl() {\n+      struct TypeName {\n\nReview comment:\n       Nit: `TypeAlias`?\n\n##########\nFile path: cpp/src/arrow/engine/substrait/relation_internal.cc\n##########\n@@ -0,0 +1,186 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/relation_internal.h\"\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/dataset/file_parquet.h\"\n+#include \"arrow/dataset/plan.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/filesystem/localfs.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+template <typename RelMessage>\n+Status CheckRelCommon(const RelMessage& rel) {\n+  if (rel.has_common()) {\n+    if (rel.common().has_emit()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Emit\");\n+    }\n+    if (rel.common().has_hint()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Hint\");\n+    }\n+    if (rel.common().has_advanced_extension()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::advanced_extension\");\n+    }\n+  }\n+  if (rel.has_advanced_extension()) {\n+    return Status::NotImplemented(\"substrait AdvancedExtensions\");\n+  }\n+  return Status::OK();\n+}\n+\n+Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n+                                       const ExtensionSet& ext_set) {\n+  static bool dataset_init = false;\n+  if (!dataset_init) {\n+    dataset_init = true;\n+    dataset::internal::Initialize();\n+  }\n+\n+  switch (rel.rel_type_case()) {\n+    case substrait::Rel::RelTypeCase::kRead: {\n+      const auto& read = rel.read();\n+      RETURN_NOT_OK(CheckRelCommon(read));\n+\n+      ARROW_ASSIGN_OR_RAISE(auto base_schema, FromProto(read.base_schema(), ext_set));\n+\n+      auto scan_options = std::make_shared<dataset::ScanOptions>();\n+\n+      if (read.has_filter()) {\n+        ARROW_ASSIGN_OR_RAISE(scan_options->filter, FromProto(read.filter(), ext_set));\n+      }\n+\n+      if (read.has_projection()) {\n+        return Status::NotImplemented(\"substrait::ReadRel::projection\");\n+      }\n+\n+      {\n+        // just project all fields\n+        std::vector<compute::Expression> expressions{base_schema->fields().size()};\n+        for (int i = 0; i < base_schema->num_fields(); ++i) {\n+          expressions[i] = compute::field_ref(i);\n+        }\n+        scan_options->projection =\n+            compute::call(\"make_struct\", std::move(expressions),\n+                          compute::MakeStructOptions{base_schema->field_names()});\n\nReview comment:\n       This is harmless but also completely extraneous.  `scan_options->projection` is only accessed when using one of the scanner \"lightweight producer\" functions like \"ToTable\" or \"Head\".  It isn't referenced by the ScanNode at all.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/relation_internal.cc\n##########\n@@ -0,0 +1,186 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/relation_internal.h\"\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/dataset/file_parquet.h\"\n+#include \"arrow/dataset/plan.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/filesystem/localfs.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+template <typename RelMessage>\n+Status CheckRelCommon(const RelMessage& rel) {\n+  if (rel.has_common()) {\n+    if (rel.common().has_emit()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Emit\");\n+    }\n+    if (rel.common().has_hint()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Hint\");\n+    }\n+    if (rel.common().has_advanced_extension()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::advanced_extension\");\n+    }\n+  }\n+  if (rel.has_advanced_extension()) {\n+    return Status::NotImplemented(\"substrait AdvancedExtensions\");\n+  }\n+  return Status::OK();\n+}\n+\n+Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n+                                       const ExtensionSet& ext_set) {\n+  static bool dataset_init = false;\n+  if (!dataset_init) {\n+    dataset_init = true;\n+    dataset::internal::Initialize();\n+  }\n+\n+  switch (rel.rel_type_case()) {\n+    case substrait::Rel::RelTypeCase::kRead: {\n+      const auto& read = rel.read();\n+      RETURN_NOT_OK(CheckRelCommon(read));\n+\n+      ARROW_ASSIGN_OR_RAISE(auto base_schema, FromProto(read.base_schema(), ext_set));\n+\n+      auto scan_options = std::make_shared<dataset::ScanOptions>();\n+\n+      if (read.has_filter()) {\n+        ARROW_ASSIGN_OR_RAISE(scan_options->filter, FromProto(read.filter(), ext_set));\n+      }\n+\n+      if (read.has_projection()) {\n+        return Status::NotImplemented(\"substrait::ReadRel::projection\");\n+      }\n+\n+      {\n+        // just project all fields\n+        std::vector<compute::Expression> expressions{base_schema->fields().size()};\n+        for (int i = 0; i < base_schema->num_fields(); ++i) {\n+          expressions[i] = compute::field_ref(i);\n+        }\n+        scan_options->projection =\n+            compute::call(\"make_struct\", std::move(expressions),\n+                          compute::MakeStructOptions{base_schema->field_names()});\n+      }\n+\n+      if (!read.has_local_files()) {\n+        return Status::NotImplemented(\n+            \"substrait::ReadRel with read_type other than LocalFiles\");\n+      }\n+\n+      if (read.local_files().has_advanced_extension()) {\n+        return Status::NotImplemented(\n+            \"substrait::ReadRel::LocalFiles::advanced_extension\");\n+      }\n+\n+      auto format = std::make_shared<dataset::ParquetFileFormat>();\n+      auto filesystem = std::make_shared<fs::LocalFileSystem>();\n+      std::vector<std::shared_ptr<dataset::FileFragment>> fragments;\n+\n+      for (const auto& item : read.local_files().items()) {\n+        if (!item.has_uri_file()) {\n+          return Status::NotImplemented(\n+              \"substrait::ReadRel::LocalFiles::FileOrFiles with \"\n+              \"path_type other than uri_file\");\n+        }\n\nReview comment:\n       Let's add a JIRA for this.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/relation_internal.cc\n##########\n@@ -0,0 +1,186 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/relation_internal.h\"\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/dataset/file_parquet.h\"\n+#include \"arrow/dataset/plan.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/filesystem/localfs.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+template <typename RelMessage>\n+Status CheckRelCommon(const RelMessage& rel) {\n+  if (rel.has_common()) {\n+    if (rel.common().has_emit()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Emit\");\n+    }\n+    if (rel.common().has_hint()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Hint\");\n+    }\n+    if (rel.common().has_advanced_extension()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::advanced_extension\");\n+    }\n+  }\n+  if (rel.has_advanced_extension()) {\n+    return Status::NotImplemented(\"substrait AdvancedExtensions\");\n+  }\n+  return Status::OK();\n+}\n+\n+Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n+                                       const ExtensionSet& ext_set) {\n+  static bool dataset_init = false;\n+  if (!dataset_init) {\n+    dataset_init = true;\n+    dataset::internal::Initialize();\n+  }\n+\n+  switch (rel.rel_type_case()) {\n+    case substrait::Rel::RelTypeCase::kRead: {\n+      const auto& read = rel.read();\n+      RETURN_NOT_OK(CheckRelCommon(read));\n+\n+      ARROW_ASSIGN_OR_RAISE(auto base_schema, FromProto(read.base_schema(), ext_set));\n+\n+      auto scan_options = std::make_shared<dataset::ScanOptions>();\n+\n+      if (read.has_filter()) {\n+        ARROW_ASSIGN_OR_RAISE(scan_options->filter, FromProto(read.filter(), ext_set));\n+      }\n+\n+      if (read.has_projection()) {\n+        return Status::NotImplemented(\"substrait::ReadRel::projection\");\n+      }\n+\n+      {\n+        // just project all fields\n+        std::vector<compute::Expression> expressions{base_schema->fields().size()};\n+        for (int i = 0; i < base_schema->num_fields(); ++i) {\n+          expressions[i] = compute::field_ref(i);\n+        }\n+        scan_options->projection =\n+            compute::call(\"make_struct\", std::move(expressions),\n+                          compute::MakeStructOptions{base_schema->field_names()});\n+      }\n+\n+      if (!read.has_local_files()) {\n+        return Status::NotImplemented(\n+            \"substrait::ReadRel with read_type other than LocalFiles\");\n+      }\n+\n+      if (read.local_files().has_advanced_extension()) {\n+        return Status::NotImplemented(\n+            \"substrait::ReadRel::LocalFiles::advanced_extension\");\n+      }\n+\n+      auto format = std::make_shared<dataset::ParquetFileFormat>();\n+      auto filesystem = std::make_shared<fs::LocalFileSystem>();\n+      std::vector<std::shared_ptr<dataset::FileFragment>> fragments;\n+\n+      for (const auto& item : read.local_files().items()) {\n+        if (!item.has_uri_file()) {\n+          return Status::NotImplemented(\n+              \"substrait::ReadRel::LocalFiles::FileOrFiles with \"\n+              \"path_type other than uri_file\");\n+        }\n+\n+        if (item.format() !=\n+            substrait::ReadRel::LocalFiles::FileOrFiles::FILE_FORMAT_PARQUET) {\n+          return Status::NotImplemented(\n+              \"substrait::ReadRel::LocalFiles::FileOrFiles::format \"\n+              \"other than FILE_FORMAT_PARQUET\");\n\nReview comment:\n       Let's add a JIRA for this.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/extension_set.h\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <vector>\n+\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// A mapping from arrow types and functions to the (uri, name) which identifies\n+/// the corresponding substrait extension. Substrait types and variations must be\n+/// registered with their corresponding arrow::DataType before they can be used!\n+class ARROW_ENGINE_EXPORT ExtensionIdRegistry {\n\nReview comment:\n       Maybe clarify what \"Substrait types\" means.  The stock set of types builtin to Substrait doesn't have to be registered with the extension id registry.  However, there are a number of Arrow types which aren't covered by Substrait's stock types and these must be registered.  In addition, there are some stock Substrait types  that don't have an Arrow equivalent (e.g. UUID) and so there are Arrow extension types for those but they have nothing to do with the extension ID registry (I don't think?)\n\n##########\nFile path: cpp/src/arrow/engine/simple_extension_type_internal.h\n##########\n@@ -0,0 +1,183 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/extension_type.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+template <const util::string_view& kExtensionName, typename Params,\n+          typename ParamsProperties, const ParamsProperties* kProperties,\n+          std::shared_ptr<DataType> GetStorage(const Params&)>\n+class SimpleExtensionType : public ExtensionType {\n+ public:\n+  using ParamsType = Params;\n\nReview comment:\n       Is this `using` statement needed?\n\n##########\nFile path: cpp/src/arrow/engine/simple_extension_type_internal.h\n##########\n@@ -0,0 +1,183 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <memory>\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/extension_type.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+template <const util::string_view& kExtensionName, typename Params,\n+          typename ParamsProperties, const ParamsProperties* kProperties,\n+          std::shared_ptr<DataType> GetStorage(const Params&)>\n+class SimpleExtensionType : public ExtensionType {\n+ public:\n+  using ParamsType = Params;\n+\n+  explicit SimpleExtensionType(std::shared_ptr<DataType> storage_type, Params params = {})\n+      : ExtensionType(std::move(storage_type)), params_(std::move(params)) {}\n+\n+  static std::shared_ptr<DataType> Make(Params params) {\n+    auto storage_type = GetStorage(params);\n+    return std::make_shared<SimpleExtensionType>(std::move(storage_type),\n+                                                 std::move(params));\n+  }\n+\n+  static const Params* GetIf(const DataType& type) {\n+    if (type.id() != Type::EXTENSION) return nullptr;\n+\n+    const auto& ext_type = ::arrow::internal::checked_cast<const ExtensionType&>(type);\n+    if (ext_type.extension_name() != kExtensionName) return nullptr;\n+\n+    return &::arrow::internal::checked_cast<const SimpleExtensionType&>(type).params_;\n+  }\n+\n+  std::string extension_name() const override { return kExtensionName.to_string(); }\n+\n+  std::string ToString() const override { return \"extension<\" + this->Serialize() + \">\"; }\n+\n+  struct ExtensionEqualsImpl {\n+    ExtensionEqualsImpl(const Params& l, const Params& r) : left_(l), right_(r) {\n+      kProperties->ForEach(*this);\n+    }\n+\n+    template <typename Property>\n+    void operator()(const Property& prop, size_t i) {\n+      equal_ &= prop.get(left_) == prop.get(right_);\n+    }\n+\n+    const Params& left_;\n+    const Params& right_;\n+    bool equal_ = true;\n+  };\n+  bool ExtensionEquals(const ExtensionType& other) const override {\n+    if (kExtensionName != other.extension_name()) return false;\n+    const auto& other_params = static_cast<const SimpleExtensionType&>(other).params_;\n+    return ExtensionEqualsImpl(params_, other_params).equal_;\n+  }\n+\n+  std::shared_ptr<Array> MakeArray(std::shared_ptr<ArrayData> data) const override {\n+    DCHECK_EQ(data->type->id(), Type::EXTENSION);\n+    DCHECK_EQ(static_cast<const ExtensionType&>(*data->type).extension_name(),\n\nReview comment:\n       ```suggestion\r\n       DCHECK_EQ(arrow::internal::checked_pointer_cast<ExtensionType>(data->type)->extension_name(),\r\n   ```\r\n   I'm a little out of my depth here but this `static_cast` seems odd.  It's entirely possible that it's just fine.  I suppose with a checked_pointer_cast you should probably check to make sure it isn't nullptr.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/extension_set.h\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <vector>\n+\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// A mapping from arrow types and functions to the (uri, name) which identifies\n+/// the corresponding substrait extension. Substrait types and variations must be\n+/// registered with their corresponding arrow::DataType before they can be used!\n+class ARROW_ENGINE_EXPORT ExtensionIdRegistry {\n+ public:\n+  /// All uris registered in this ExtensionIdRegistry\n+  virtual std::vector<util::string_view> Uris() const = 0;\n+\n+  struct Id {\n+    util::string_view uri, name;\n+\n+    bool empty() const { return uri.empty() && name.empty(); }\n+  };\n+\n+  struct TypeRecord {\n+    Id id;\n+    const std::shared_ptr<DataType>& type;\n+    bool is_variation;\n+  };\n+  virtual util::optional<TypeRecord> GetType(const DataType&) const = 0;\n+  virtual util::optional<TypeRecord> GetType(Id, bool is_variation) const = 0;\n+  virtual Status RegisterType(Id, std::shared_ptr<DataType>, bool is_variation) = 0;\n+\n+  // FIXME some functions will not be simple enough to convert without access to their\n+  // arguments/options. For example is_in embeds the set in options rather than using an\n+  // argument:\n+  //     is_in(x, SetLookupOptions(set)) <-> (k...Uri, \"is_in\")(x, set)\n+  //\n+  // ... for another example, depending on the value of the first argument to\n+  // substrait::add it either corresponds to arrow::add or arrow::add_checked\n+  struct FunctionRecord {\n+    Id id;\n+    const std::string& function_name;\n+  };\n+  virtual util::optional<FunctionRecord> GetFunction(Id) const = 0;\n+  virtual util::optional<FunctionRecord> GetFunction(\n+      util::string_view arrow_function_name) const = 0;\n+  virtual Status RegisterFunction(Id, std::string arrow_function_name) = 0;\n+};\n+\n+constexpr util::string_view kArrowExtTypesUri =\n+    \"https://github.com/apache/arrow/blob/master/format/substrait/\"\n+    \"extension_types.yaml\";\n+\n+ARROW_ENGINE_EXPORT ExtensionIdRegistry* default_extension_id_registry();\n+\n+/// A subset of an ExtensionIdRegistry with extensions identifiable by an integer.\n+///\n+/// ExtensionSet does not own strings; it only refers to strings in an\n+/// ExtensionIdRegistry.\n+class ARROW_ENGINE_EXPORT ExtensionSet {\n+ public:\n+  using Id = ExtensionIdRegistry::Id;\n+\n+  /// Construct an empty ExtensionSet to be populated during serialization.\n+  explicit ExtensionSet(ExtensionIdRegistry* = default_extension_id_registry());\n+  ARROW_DEFAULT_MOVE_AND_ASSIGN(ExtensionSet);\n+\n+  /// Construct an ExtensionSet with explicit extension ids for efficient referencing\n+  /// during deserialization. Note that input vectors need not be densely packed; an empty\n+  /// (default constructed) Id may be used as a placeholder to indicate an unused\n+  /// _anchor/_reference. This factory will be used to wrap the extensions declared in a\n+  /// substrait::Plan before deserializing the plan's relations.\n+  ///\n+  /// Views will be replaced with equivalent views pointing to memory owned by the\n+  /// registry.\n+  static Result<ExtensionSet> Make(\n+      std::vector<util::string_view> uris, std::vector<Id> type_ids,\n+      std::vector<bool> type_is_variation, std::vector<Id> function_ids,\n+      ExtensionIdRegistry* = default_extension_id_registry());\n+\n+  // index in these vectors == value of _anchor/_reference fields\n+  /// FIXME this assumes that _anchor/_references won't be huge, which is not guaranteed.\n+  /// Could it be?\n+  const std::vector<util::string_view>& uris() const { return uris_; }\n\nReview comment:\n       It certainly could be.  I wouldn't expect a producer to do so but it seems too likely for comfort.  Maybe we can push for Substrait to recommend low-valued anchors?\n\n##########\nFile path: cpp/src/arrow/engine/substrait/extension_set.cc\n##########\n@@ -0,0 +1,346 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/extension_set.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/util/hash_util.h\"\n+#include \"arrow/util/hashing.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+namespace arrow {\n+namespace engine {\n+namespace {\n+\n+struct TypePtrHashEq {\n+  template <typename Ptr>\n+  size_t operator()(const Ptr& type) const {\n+    return type->Hash();\n+  }\n+\n+  template <typename Ptr>\n+  bool operator()(const Ptr& l, const Ptr& r) const {\n+    return *l == *r;\n+  }\n+};\n+\n+struct IdHashEq {\n+  using Id = ExtensionSet::Id;\n+\n+  size_t operator()(Id id) const {\n+    constexpr ::arrow::internal::StringViewHash hash = {};\n+    auto out = static_cast<size_t>(hash(id.uri));\n+    ::arrow::internal::hash_combine(out, hash(id.name));\n+    return out;\n+  }\n+\n+  bool operator()(Id l, Id r) const { return l.uri == r.uri && l.name == r.name; }\n+};\n+\n+}  // namespace\n+\n+struct ExtensionSet::Impl {\n+  void AddUri(util::string_view uri, ExtensionSet* self) {\n+    if (uris_.find(uri) != uris_.end()) return;\n\nReview comment:\n       I find it hard to follow that `ExtensionSet::uris_` is a `std::vector` and `ExtensionSet::Impl::uris_` is a std::unordered_map`.  Can we use different variable names?\n\n##########\nFile path: cpp/src/arrow/engine/substrait/relation_internal.cc\n##########\n@@ -0,0 +1,186 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/relation_internal.h\"\n+\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/dataset/file_parquet.h\"\n+#include \"arrow/dataset/plan.h\"\n+#include \"arrow/dataset/scanner.h\"\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/filesystem/localfs.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+template <typename RelMessage>\n+Status CheckRelCommon(const RelMessage& rel) {\n+  if (rel.has_common()) {\n+    if (rel.common().has_emit()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Emit\");\n+    }\n+    if (rel.common().has_hint()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::Hint\");\n+    }\n+    if (rel.common().has_advanced_extension()) {\n+      return Status::NotImplemented(\"substrait::RelCommon::advanced_extension\");\n+    }\n+  }\n+  if (rel.has_advanced_extension()) {\n+    return Status::NotImplemented(\"substrait AdvancedExtensions\");\n+  }\n+  return Status::OK();\n+}\n+\n+Result<compute::Declaration> FromProto(const substrait::Rel& rel,\n+                                       const ExtensionSet& ext_set) {\n+  static bool dataset_init = false;\n+  if (!dataset_init) {\n+    dataset_init = true;\n+    dataset::internal::Initialize();\n+  }\n+\n+  switch (rel.rel_type_case()) {\n+    case substrait::Rel::RelTypeCase::kRead: {\n+      const auto& read = rel.read();\n+      RETURN_NOT_OK(CheckRelCommon(read));\n+\n+      ARROW_ASSIGN_OR_RAISE(auto base_schema, FromProto(read.base_schema(), ext_set));\n+\n+      auto scan_options = std::make_shared<dataset::ScanOptions>();\n+\n+      if (read.has_filter()) {\n+        ARROW_ASSIGN_OR_RAISE(scan_options->filter, FromProto(read.filter(), ext_set));\n+      }\n+\n+      if (read.has_projection()) {\n+        return Status::NotImplemented(\"substrait::ReadRel::projection\");\n+      }\n+\n+      {\n+        // just project all fields\n+        std::vector<compute::Expression> expressions{base_schema->fields().size()};\n+        for (int i = 0; i < base_schema->num_fields(); ++i) {\n+          expressions[i] = compute::field_ref(i);\n+        }\n+        scan_options->projection =\n+            compute::call(\"make_struct\", std::move(expressions),\n+                          compute::MakeStructOptions{base_schema->field_names()});\n+      }\n+\n+      if (!read.has_local_files()) {\n+        return Status::NotImplemented(\n+            \"substrait::ReadRel with read_type other than LocalFiles\");\n+      }\n+\n+      if (read.local_files().has_advanced_extension()) {\n+        return Status::NotImplemented(\n+            \"substrait::ReadRel::LocalFiles::advanced_extension\");\n+      }\n+\n+      auto format = std::make_shared<dataset::ParquetFileFormat>();\n+      auto filesystem = std::make_shared<fs::LocalFileSystem>();\n+      std::vector<std::shared_ptr<dataset::FileFragment>> fragments;\n+\n+      for (const auto& item : read.local_files().items()) {\n+        if (!item.has_uri_file()) {\n+          return Status::NotImplemented(\n+              \"substrait::ReadRel::LocalFiles::FileOrFiles with \"\n+              \"path_type other than uri_file\");\n+        }\n+\n+        if (item.format() !=\n+            substrait::ReadRel::LocalFiles::FileOrFiles::FILE_FORMAT_PARQUET) {\n+          return Status::NotImplemented(\n+              \"substrait::ReadRel::LocalFiles::FileOrFiles::format \"\n+              \"other than FILE_FORMAT_PARQUET\");\n+        }\n+\n+        if (!util::string_view{item.uri_file()}.starts_with(\"file:///\")) {\n+          return Status::NotImplemented(\n+              \"substrait::ReadRel::LocalFiles::FileOrFiles::uri_file \"\n+              \"with other than local filesystem (file:///)\");\n+        }\n\nReview comment:\n       Let's add a JIRA for this (uri_folder in particular, I have no idea what uri_path is and uri_path_glob seems lower priority)\n\n##########\nFile path: cpp/src/arrow/engine/substrait/extension_types.cc\n##########\n@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/extension_types.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n\nReview comment:\n       ```suggestion\r\n   ```\n\n##########\nFile path: cpp/src/arrow/engine/substrait/extension_types.cc\n##########\n@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/extension_types.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/engine/simple_extension_type_internal.h\"\n+#include \"arrow/util/hash_util.h\"\n\nReview comment:\n       ```suggestion\r\n   ```\n\n##########\nFile path: cpp/src/arrow/engine/substrait/extension_set.h\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <vector>\n+\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// A mapping from arrow types and functions to the (uri, name) which identifies\n+/// the corresponding substrait extension. Substrait types and variations must be\n+/// registered with their corresponding arrow::DataType before they can be used!\n+class ARROW_ENGINE_EXPORT ExtensionIdRegistry {\n+ public:\n+  /// All uris registered in this ExtensionIdRegistry\n+  virtual std::vector<util::string_view> Uris() const = 0;\n+\n+  struct Id {\n+    util::string_view uri, name;\n+\n+    bool empty() const { return uri.empty() && name.empty(); }\n+  };\n+\n+  struct TypeRecord {\n+    Id id;\n+    const std::shared_ptr<DataType>& type;\n+    bool is_variation;\n+  };\n+  virtual util::optional<TypeRecord> GetType(const DataType&) const = 0;\n+  virtual util::optional<TypeRecord> GetType(Id, bool is_variation) const = 0;\n+  virtual Status RegisterType(Id, std::shared_ptr<DataType>, bool is_variation) = 0;\n+\n+  // FIXME some functions will not be simple enough to convert without access to their\n\nReview comment:\n       Let's create a JIRA for this\n\n##########\nFile path: cpp/src/arrow/engine/substrait/extension_set.h\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <vector>\n+\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+/// A mapping from arrow types and functions to the (uri, name) which identifies\n+/// the corresponding substrait extension. Substrait types and variations must be\n+/// registered with their corresponding arrow::DataType before they can be used!\n+class ARROW_ENGINE_EXPORT ExtensionIdRegistry {\n+ public:\n+  /// All uris registered in this ExtensionIdRegistry\n\nReview comment:\n       I might just be slow on the uptake but it took me a few seconds to realize why the `ExtensionIdRegistry` needed to own URIs.  Maybe add something like...\r\n   \r\n   ```\r\n   Note: These URIs are referenced by the views in each Id\r\n   ```\n\n##########\nFile path: cpp/src/arrow/engine/substrait/serde.h\n##########\n@@ -0,0 +1,79 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <functional>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/engine/substrait/extension_set.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+using ConsumerFactory = std::function<std::shared_ptr<compute::SinkNodeConsumer>()>;\n\nReview comment:\n       I mentioned this elsewhere but now I understand it better.  I think we could name this `RelationConsumer` or something like that.  Or add some documentation.  It isn't clear at a first glance that Arrow ExecPlan's \"sink\" maps to a \"relation\".\r\n   \r\n   That being said, I don't know if this feels quite right.  Shouldn't a substrait plan include a \"sink\" relation for handling the data?  For example, the relation could be a \"write\" relation or it could be a \"send out via flight\" relation or it could be a \"send IPC to some named Arrow C bridge\".\r\n   \r\n   However, I suppose those would all be custom relations at the moment (Substrait really hasn't defined that part) so I think what we have here is fine.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/extension_types.h\n##########\n@@ -0,0 +1,82 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <vector>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+namespace arrow {\n+namespace engine {\n+\n+// arrow::ExtensionTypes are provided to wrap uuid, fixed_char, varchar, interval_year,\n+// and interval_day which are first-class types in substrait but do not appear in\n+// the arrow type system.\n+//\n+// Note that these are not automatically registered with arrow::RegisterExtensionType(),\n+// which means among other things that serialization of these types to IPC would fail.\n\nReview comment:\n       Also, pretty much all compute functions are going to fail as well.  We can maybe add a long term JIRA to add more support for these extension types.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/serde.cc\n##########\n@@ -0,0 +1,232 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/serde.h\"\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+#include \"arrow/engine/substrait/plan_internal.h\"\n+#include \"arrow/engine/substrait/relation_internal.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+#include <google/protobuf/descriptor.h>\n+#include <google/protobuf/io/zero_copy_stream_impl_lite.h>\n+#include <google/protobuf/message.h>\n+#include <google/protobuf/util/json_util.h>\n+#include <google/protobuf/util/message_differencer.h>\n+#include <google/protobuf/util/type_resolver_util.h>\n+\n+namespace arrow {\n+namespace engine {\n+\n+Status ParseFromBufferImpl(const Buffer& buf, const std::string& full_name,\n+                           google::protobuf::Message* message) {\n+  google::protobuf::io::ArrayInputStream buf_stream{buf.data(),\n+                                                    static_cast<int>(buf.size())};\n+\n+  if (message->ParseFromZeroCopyStream(&buf_stream)) {\n+    return Status::OK();\n+  }\n+  return Status::IOError(\"ParseFromZeroCopyStream failed for \", full_name);\n+}\n+\n+template <typename Message>\n+Result<Message> ParseFromBuffer(const Buffer& buf) {\n+  Message message;\n+  ARROW_RETURN_NOT_OK(\n+      ParseFromBufferImpl(buf, Message::descriptor()->full_name(), &message));\n+  return message;\n+}\n+\n+Result<compute::Declaration> DeserializeRelation(const Buffer& buf,\n+                                                 const ExtensionSet& ext_set) {\n+  ARROW_ASSIGN_OR_RAISE(auto rel, ParseFromBuffer<substrait::Rel>(buf));\n+  return FromProto(rel, ext_set);\n+}\n+\n+Result<std::vector<compute::Declaration>> DeserializePlan(\n+    const Buffer& buf, const ConsumerFactory& consumer_factory,\n+    ExtensionSet* ext_set_out) {\n+  ARROW_ASSIGN_OR_RAISE(auto plan, ParseFromBuffer<substrait::Plan>(buf));\n+\n+  ARROW_ASSIGN_OR_RAISE(auto ext_set, GetExtensionSetFromPlan(plan));\n+\n+  std::vector<compute::Declaration> sink_decls;\n+  for (const substrait::PlanRel& plan_rel : plan.relations()) {\n+    if (plan_rel.has_root()) {\n+      return Status::NotImplemented(\"substrait::PlanRel with custom output field names\");\n+    }\n+    ARROW_ASSIGN_OR_RAISE(auto decl, FromProto(plan_rel.rel(), ext_set));\n+\n+    // pipe each relation into a consuming_sink node\n+    auto sink_decl = compute::Declaration::Sequence({\n+        std::move(decl),\n+        {\"consuming_sink\", compute::ConsumingSinkNodeOptions{consumer_factory()}},\n+    });\n+    sink_decls.push_back(std::move(sink_decl));\n+  }\n+\n+  if (ext_set_out) {\n+    *ext_set_out = std::move(ext_set);\n+  }\n+  return sink_decls;\n+}\n+\n+Result<std::shared_ptr<Schema>> DeserializeSchema(const Buffer& buf,\n+                                                  const ExtensionSet& ext_set) {\n+  ARROW_ASSIGN_OR_RAISE(auto named_struct, ParseFromBuffer<substrait::NamedStruct>(buf));\n+  return FromProto(named_struct, ext_set);\n+}\n+\n+Result<std::shared_ptr<Buffer>> SerializeSchema(const Schema& schema,\n+                                                ExtensionSet* ext_set) {\n+  ARROW_ASSIGN_OR_RAISE(auto named_struct, ToProto(schema, ext_set));\n+  std::string serialized = named_struct->SerializeAsString();\n+  return Buffer::FromString(std::move(serialized));\n+}\n+\n+Result<std::shared_ptr<DataType>> DeserializeType(const Buffer& buf,\n+                                                  const ExtensionSet& ext_set) {\n+  ARROW_ASSIGN_OR_RAISE(auto type, ParseFromBuffer<substrait::Type>(buf));\n+  ARROW_ASSIGN_OR_RAISE(auto type_nullable, FromProto(type, ext_set));\n+  return std::move(type_nullable.first);\n+}\n+\n+Result<std::shared_ptr<Buffer>> SerializeType(const DataType& type,\n+                                              ExtensionSet* ext_set) {\n+  ARROW_ASSIGN_OR_RAISE(auto st_type, ToProto(type, /*nullable=*/true, ext_set));\n+  std::string serialized = st_type->SerializeAsString();\n+  return Buffer::FromString(std::move(serialized));\n+}\n+\n+Result<compute::Expression> DeserializeExpression(const Buffer& buf,\n+                                                  const ExtensionSet& ext_set) {\n+  ARROW_ASSIGN_OR_RAISE(auto expr, ParseFromBuffer<substrait::Expression>(buf));\n+  return FromProto(expr, ext_set);\n+}\n+\n+Result<std::shared_ptr<Buffer>> SerializeExpression(const compute::Expression& expr,\n+                                                    ExtensionSet* ext_set) {\n+  ARROW_ASSIGN_OR_RAISE(auto st_expr, ToProto(expr, ext_set));\n+  std::string serialized = st_expr->SerializeAsString();\n+  return Buffer::FromString(std::move(serialized));\n+}\n+\n+namespace internal {\n+\n+template <typename Message>\n+static Status CheckMessagesEquivalent(const Buffer& l_buf, const Buffer& r_buf) {\n+  ARROW_ASSIGN_OR_RAISE(auto l, ParseFromBuffer<Message>(l_buf));\n+  ARROW_ASSIGN_OR_RAISE(auto r, ParseFromBuffer<Message>(r_buf));\n+\n+  using google::protobuf::util::MessageDifferencer;\n+\n+  std::string out;\n+  google::protobuf::io::StringOutputStream out_stream{&out};\n+  MessageDifferencer::StreamReporter reporter{&out_stream};\n+\n+  MessageDifferencer differencer;\n+  differencer.set_message_field_comparison(MessageDifferencer::EQUIVALENT);\n+  differencer.ReportDifferencesTo(&reporter);\n+\n+  if (differencer.Compare(l, r)) {\n+    return Status::OK();\n+  }\n+  return Status::Invalid(\"Messages were not equivalent: \", out);\n+}\n+\n+Status CheckMessagesEquivalent(util::string_view message_name, const Buffer& l_buf,\n+                               const Buffer& r_buf) {\n+  if (message_name == \"Type\") {\n+    return CheckMessagesEquivalent<substrait::Type>(l_buf, r_buf);\n+  }\n+\n+  if (message_name == \"NamedStruct\") {\n+    return CheckMessagesEquivalent<substrait::NamedStruct>(l_buf, r_buf);\n+  }\n+\n+  if (message_name == \"Schema\") {\n+    return Status::Invalid(\n+        \"There is no substrait message named Schema. The substrait message type which \"\n+        \"corresponds to Schemas is NamedStruct\");\n+  }\n\nReview comment:\n       Is this a testing thing?  Who exactly are these error messages intended for?\n\n##########\nFile path: cpp/src/arrow/engine/substrait/extension_set.cc\n##########\n@@ -0,0 +1,346 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/extension_set.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/util/hash_util.h\"\n+#include \"arrow/util/hashing.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+namespace arrow {\n+namespace engine {\n+namespace {\n+\n+struct TypePtrHashEq {\n+  template <typename Ptr>\n+  size_t operator()(const Ptr& type) const {\n+    return type->Hash();\n+  }\n+\n+  template <typename Ptr>\n+  bool operator()(const Ptr& l, const Ptr& r) const {\n+    return *l == *r;\n+  }\n+};\n+\n+struct IdHashEq {\n+  using Id = ExtensionSet::Id;\n+\n+  size_t operator()(Id id) const {\n+    constexpr ::arrow::internal::StringViewHash hash = {};\n+    auto out = static_cast<size_t>(hash(id.uri));\n+    ::arrow::internal::hash_combine(out, hash(id.name));\n+    return out;\n+  }\n+\n+  bool operator()(Id l, Id r) const { return l.uri == r.uri && l.name == r.name; }\n+};\n+\n+}  // namespace\n+\n+struct ExtensionSet::Impl {\n+  void AddUri(util::string_view uri, ExtensionSet* self) {\n+    if (uris_.find(uri) != uris_.end()) return;\n+\n+    self->uris_.push_back(uri);\n+    uris_.insert(self->uris_.back());  // lookup helper's keys should reference memory\n+                                       // owned by this ExtensionSet\n\nReview comment:\n       It's not really clear what \"lookup helper\" is\n\n##########\nFile path: cpp/src/arrow/engine/substrait/extension_set.cc\n##########\n@@ -0,0 +1,346 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/extension_set.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/util/hash_util.h\"\n+#include \"arrow/util/hashing.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+namespace arrow {\n+namespace engine {\n+namespace {\n+\n+struct TypePtrHashEq {\n+  template <typename Ptr>\n+  size_t operator()(const Ptr& type) const {\n+    return type->Hash();\n+  }\n+\n+  template <typename Ptr>\n+  bool operator()(const Ptr& l, const Ptr& r) const {\n+    return *l == *r;\n+  }\n+};\n+\n+struct IdHashEq {\n+  using Id = ExtensionSet::Id;\n+\n+  size_t operator()(Id id) const {\n+    constexpr ::arrow::internal::StringViewHash hash = {};\n+    auto out = static_cast<size_t>(hash(id.uri));\n+    ::arrow::internal::hash_combine(out, hash(id.name));\n+    return out;\n+  }\n+\n+  bool operator()(Id l, Id r) const { return l.uri == r.uri && l.name == r.name; }\n+};\n+\n+}  // namespace\n+\n+struct ExtensionSet::Impl {\n+  void AddUri(util::string_view uri, ExtensionSet* self) {\n+    if (uris_.find(uri) != uris_.end()) return;\n+\n+    self->uris_.push_back(uri);\n+    uris_.insert(self->uris_.back());  // lookup helper's keys should reference memory\n+                                       // owned by this ExtensionSet\n+  }\n+\n+  Status CheckHasUri(util::string_view uri) {\n+    if (uris_.find(uri) != uris_.end()) return Status::OK();\n+\n+    return Status::Invalid(\n+        \"Uri \", uri,\n+        \" was referenced by an extension but was not declared in the ExtensionSet.\");\n+  }\n+\n+  uint32_t EncodeType(Id id, const std::shared_ptr<DataType>& type, bool is_variation,\n+                      ExtensionSet* self) {\n+    // note: at this point we're guaranteed to have an Id which points to memory owned by\n+    // the set's registry.\n+    AddUri(id.uri, self);\n+    auto it_success = types_.emplace(id, static_cast<uint32_t>(types_.size()));\n+\n+    if (it_success.second) {\n+      DCHECK_EQ(self->type_ids_.size(), self->types_.size());\n+      self->type_ids_.push_back(id);\n+      self->types_.push_back(type);\n+      self->type_is_variation_.push_back(is_variation);\n+    }\n+\n+    return it_success.first->second;\n+  }\n+\n+  uint32_t EncodeFunction(Id id, util::string_view function_name, ExtensionSet* self) {\n+    // note: at this point we're guaranteed to have an Id which points to memory owned by\n+    // the set's registry.\n+    AddUri(id.uri, self);\n+    auto it_success = functions_.emplace(id, static_cast<uint32_t>(functions_.size()));\n+\n+    if (it_success.second) {\n+      DCHECK_EQ(self->function_ids_.size(), self->function_names_.size());\n+      self->function_ids_.push_back(id);\n+      self->function_names_.push_back(function_name);\n+    }\n+\n+    return it_success.first->second;\n+  }\n+\n+  std::unordered_set<util::string_view, ::arrow::internal::StringViewHash> uris_;\n+  std::unordered_map<Id, uint32_t, IdHashEq, IdHashEq> types_, functions_;\n+};\n+\n+ExtensionSet::ExtensionSet(ExtensionIdRegistry* registry)\n+    : registry_(registry), impl_(new Impl(), [](Impl* impl) { delete impl; }) {}\n+\n+Result<ExtensionSet> ExtensionSet::Make(std::vector<util::string_view> uris,\n+                                        std::vector<Id> type_ids,\n+                                        std::vector<bool> type_is_variation,\n+                                        std::vector<Id> function_ids,\n+                                        ExtensionIdRegistry* registry) {\n+  ExtensionSet set;\n+  set.registry_ = registry;\n+\n+  // TODO(bkietz) move this into the registry as registry->OwnUris(&uris) or so\n+  std::unordered_set<util::string_view, ::arrow::internal::StringViewHash>\n+      uris_owned_by_registry;\n+  for (util::string_view uri : registry->Uris()) {\n+    uris_owned_by_registry.insert(uri);\n+  }\n+\n+  for (auto& uri : uris) {\n+    if (uri.empty()) continue;\n+    auto it = uris_owned_by_registry.find(uri);\n+    if (it == uris_owned_by_registry.end()) {\n+      return Status::KeyError(\"Uri '\", uri, \"' not found in registry\");\n+    }\n+    uri = *it;  // Ensure uris point into the registry's memory\n+    set.impl_->AddUri(*it, &set);\n+  }\n+\n+  if (type_ids.size() != type_is_variation.size()) {\n+    return Status::Invalid(\"Received \", type_ids.size(), \" type ids but a \",\n+                           type_is_variation.size(), \"-long is_variation vector\");\n+  }\n+\n+  set.types_.resize(type_ids.size());\n+\n+  for (size_t i = 0; i < type_ids.size(); ++i) {\n+    if (type_ids[i].empty()) continue;\n+    RETURN_NOT_OK(set.impl_->CheckHasUri(type_ids[i].uri));\n+\n+    if (auto rec = registry->GetType(type_ids[i], type_is_variation[i])) {\n+      set.types_[i] = rec->type;\n+      type_ids[i] = rec->id;  // use Id which references memory owned by the registry\n+      continue;\n+    }\n+    return Status::Invalid(\"Type\", (type_is_variation[i] ? \" variation\" : \"\"), \" \",\n+                           type_ids[i].uri, \"#\", type_ids[i].name, \" not found\");\n+  }\n+\n+  set.function_names_.resize(function_ids.size());\n+\n+  for (size_t i = 0; i < function_ids.size(); ++i) {\n+    if (function_ids[i].empty()) continue;\n+    RETURN_NOT_OK(set.impl_->CheckHasUri(function_ids[i].uri));\n+\n+    if (auto rec = registry->GetFunction(function_ids[i])) {\n+      set.function_names_[i] = rec->function_name;\n+      function_ids[i] = rec->id;  // use Id which references memory owned by the registry\n+      continue;\n+    }\n+    return Status::Invalid(\"Function \", function_ids[i].uri, \"#\", type_ids[i].name,\n+                           \" not found\");\n+  }\n+\n+  set.function_ids_ = std::move(function_ids);\n+  set.type_ids_ = std::move(type_ids);\n+  set.type_is_variation_ = std::move(type_is_variation);\n+  set.uris_ = std::move(uris);\n+\n+  return std::move(set);\n+}\n+\n+Result<uint32_t> ExtensionSet::EncodeType(const DataType& type) {\n+  if (auto rec = registry_->GetType(type)) {\n+    return impl_->EncodeType(rec->id, rec->type, rec->is_variation, this);\n+  }\n+  return Status::KeyError(\"type \", type.ToString(), \" not found in the registry\");\n+}\n+\n+Result<uint32_t> ExtensionSet::EncodeFunction(util::string_view function_name) {\n+  if (auto rec = registry_->GetFunction(function_name)) {\n+    return impl_->EncodeFunction(rec->id, rec->function_name, this);\n+  }\n+  return Status::KeyError(\"function \", function_name, \" not found in the registry\");\n+}\n+\n+template <typename KeyToIndex, typename Key>\n+const int* GetIndex(const KeyToIndex& key_to_index, const Key& key) {\n+  auto it = key_to_index.find(key);\n+  if (it == key_to_index.end()) return nullptr;\n+  return &it->second;\n+}\n+\n+ExtensionIdRegistry* default_extension_id_registry() {\n+  static struct Impl : ExtensionIdRegistry {\n+    Impl() {\n+      struct TypeName {\n+        std::shared_ptr<DataType> type;\n+        util::string_view name;\n+      };\n+\n+      for (TypeName e : {\n+               TypeName{uint8(), \"u8\"},\n+               TypeName{uint16(), \"u16\"},\n+               TypeName{uint32(), \"u32\"},\n+               TypeName{uint64(), \"u64\"},\n+           }) {\n+        DCHECK_OK(RegisterType({kArrowExtTypesUri, e.name}, std::move(e.type),\n+                               /*is_variation=*/true));\n+      }\n+\n+      for (TypeName e : {\n+               TypeName{null(), \"null\"},\n+           }) {\n+        DCHECK_OK(RegisterType({kArrowExtTypesUri, e.name}, std::move(e.type),\n+                               /*is_variation=*/false));\n+      }\n+\n+      for (util::string_view name : {\n+               \"add\",\n+           }) {\n+        DCHECK_OK(RegisterFunction({kArrowExtTypesUri, name}, name.to_string()));\n+      }\n+    }\n+\n+    std::vector<util::string_view> Uris() const override {\n+      return {uris_.begin(), uris_.end()};\n+    }\n+\n+    util::optional<TypeRecord> GetType(const DataType& type) const override {\n+      if (auto index = GetIndex(type_to_index_, &type)) {\n+        return TypeRecord{type_ids_[*index], types_[*index], type_is_variation_[*index]};\n+      }\n+      return {};\n+    }\n+\n+    util::optional<TypeRecord> GetType(Id id, bool is_variation) const override {\n+      if (auto index =\n+              GetIndex(is_variation ? variation_id_to_index_ : id_to_index_, id)) {\n+        return TypeRecord{type_ids_[*index], types_[*index], type_is_variation_[*index]};\n+      }\n+      return {};\n+    }\n+\n+    Status RegisterType(Id id, std::shared_ptr<DataType> type,\n+                        bool is_variation) override {\n+      DCHECK_EQ(type_ids_.size(), types_.size());\n+      DCHECK_EQ(type_ids_.size(), type_is_variation_.size());\n+\n+      Id copied_id{*uris_.emplace(id.uri.to_string()).first,\n+                   *names_.emplace(id.name.to_string()).first};\n+\n+      auto index = static_cast<int>(type_ids_.size());\n+\n+      auto* id_to_index = is_variation ? &variation_id_to_index_ : &id_to_index_;\n+      auto it_success = id_to_index->emplace(copied_id, index);\n+\n+      if (!it_success.second) {\n+        return Status::Invalid(\"Type id was already registered\");\n+      }\n+\n+      if (!type_to_index_.emplace(type.get(), index).second) {\n+        id_to_index->erase(it_success.first);\n+        return Status::Invalid(\"Type was already registered\");\n+      }\n+\n+      type_ids_.push_back(copied_id);\n+      types_.push_back(std::move(type));\n+      type_is_variation_.push_back(is_variation);\n+      return Status::OK();\n+    }\n+\n+    util::optional<FunctionRecord> GetFunction(\n+        util::string_view arrow_function_name) const override {\n+      if (auto index = GetIndex(function_name_to_index_, arrow_function_name)) {\n+        return FunctionRecord{function_ids_[*index], *function_name_ptrs_[*index]};\n+      }\n+      return {};\n+    }\n+\n+    util::optional<FunctionRecord> GetFunction(Id id) const override {\n+      if (auto index = GetIndex(function_id_to_index_, id)) {\n+        return FunctionRecord{function_ids_[*index], *function_name_ptrs_[*index]};\n+      }\n+      return {};\n+    }\n+\n+    Status RegisterFunction(Id id, std::string arrow_function_name) override {\n+      DCHECK_EQ(function_ids_.size(), function_name_ptrs_.size());\n+\n+      Id copied_id{*uris_.emplace(id.uri.to_string()).first,\n+                   *names_.emplace(id.name.to_string()).first};\n+\n+      const std::string& copied_function_name{\n+          *function_names_.emplace(std::move(arrow_function_name)).first};\n+\n+      auto index = static_cast<int>(function_ids_.size());\n+\n+      auto it_success = function_id_to_index_.emplace(copied_id, index);\n+\n+      if (!it_success.second) {\n+        return Status::Invalid(\"Function id was already registered\");\n+      }\n+\n+      if (!function_name_to_index_.emplace(copied_function_name, index).second) {\n+        function_id_to_index_.erase(it_success.first);\n+        return Status::Invalid(\"Function name was already registered\");\n+      }\n+\n+      function_name_ptrs_.push_back(&copied_function_name);\n+      function_ids_.push_back(copied_id);\n+      return Status::OK();\n+    }\n+\n+    // owning storage of uris, names, (arrow::)function_names, types\n+    //    note that storing strings like this is safe since references into an\n+    //    unordered_set are not invalidated on insertion\n+    std::unordered_set<std::string> uris_, names_, function_names_;\n\nReview comment:\n       You're introducing quite a bit of complexity simply to avoid `unordered_map` lookups during plan building.  Off the cuff it feels like a premature optimization but I suppose it can't hurt as long as the anchors are low numbers.\n\n##########\nFile path: cpp/src/arrow/engine/substrait/plan_internal.h\n##########\n@@ -0,0 +1,39 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include \"arrow/engine/substrait/extension_set.h\"\n+#include \"arrow/engine/visibility.h\"\n+#include \"arrow/type_fwd.h\"\n+\n+#include \"substrait/plan.pb.h\"  // IWYU pragma: export\n+\n+namespace arrow {\n+namespace engine {\n+\n+ARROW_ENGINE_EXPORT\n+Status AddExtensionSetToPlan(const ExtensionSet&, substrait::Plan*);\n\nReview comment:\n       At the moment this is completely unused but I can see how it would be useful if we are going to be creating plans.  But I don't really know if we're going to be doing that.  What do you see as the future for this?\r\n   \r\n   Either way some docstrings about what this function does could be useful.  It could be something brief like \"Adds extension definitions to a Substrait plan to be referenced by anchors throughout the rest of the plan\"\n\n##########\nFile path: cpp/src/arrow/engine/substrait/serde.cc\n##########\n@@ -0,0 +1,232 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/engine/substrait/serde.h\"\n+\n+#include \"arrow/engine/substrait/expression_internal.h\"\n+#include \"arrow/engine/substrait/plan_internal.h\"\n+#include \"arrow/engine/substrait/relation_internal.h\"\n+#include \"arrow/engine/substrait/type_internal.h\"\n+#include \"arrow/util/string_view.h\"\n+\n+#include <google/protobuf/descriptor.h>\n+#include <google/protobuf/io/zero_copy_stream_impl_lite.h>\n+#include <google/protobuf/message.h>\n+#include <google/protobuf/util/json_util.h>\n+#include <google/protobuf/util/message_differencer.h>\n+#include <google/protobuf/util/type_resolver_util.h>\n+\n+namespace arrow {\n+namespace engine {\n+\n+Status ParseFromBufferImpl(const Buffer& buf, const std::string& full_name,\n+                           google::protobuf::Message* message) {\n+  google::protobuf::io::ArrayInputStream buf_stream{buf.data(),\n+                                                    static_cast<int>(buf.size())};\n+\n+  if (message->ParseFromZeroCopyStream(&buf_stream)) {\n+    return Status::OK();\n+  }\n+  return Status::IOError(\"ParseFromZeroCopyStream failed for \", full_name);\n+}\n+\n+template <typename Message>\n+Result<Message> ParseFromBuffer(const Buffer& buf) {\n+  Message message;\n+  ARROW_RETURN_NOT_OK(\n+      ParseFromBufferImpl(buf, Message::descriptor()->full_name(), &message));\n+  return message;\n+}\n+\n+Result<compute::Declaration> DeserializeRelation(const Buffer& buf,\n+                                                 const ExtensionSet& ext_set) {\n+  ARROW_ASSIGN_OR_RAISE(auto rel, ParseFromBuffer<substrait::Rel>(buf));\n+  return FromProto(rel, ext_set);\n+}\n+\n+Result<std::vector<compute::Declaration>> DeserializePlan(\n+    const Buffer& buf, const ConsumerFactory& consumer_factory,\n+    ExtensionSet* ext_set_out) {\n+  ARROW_ASSIGN_OR_RAISE(auto plan, ParseFromBuffer<substrait::Plan>(buf));\n+\n+  ARROW_ASSIGN_OR_RAISE(auto ext_set, GetExtensionSetFromPlan(plan));\n+\n+  std::vector<compute::Declaration> sink_decls;\n+  for (const substrait::PlanRel& plan_rel : plan.relations()) {\n+    if (plan_rel.has_root()) {\n+      return Status::NotImplemented(\"substrait::PlanRel with custom output field names\");\n+    }\n\nReview comment:\n       Is this just a TODO or is there some reason we can't handle this with a final `project`?  If it's just a TODO let's add a JIRA.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T05:06:48.177+0000",
                    "updated": "2022-02-01T05:06:48.177+0000",
                    "started": "2022-02-01T05:06:48.177+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718417",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/718531",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#issuecomment-1026670176\n\n\n   @westonpace Thank you for the review (thus far)!\r\n   \r\n   > There is a lot of follow-up work and it would probably be good to start filing JIRAs (ideally grouped under some kind of parent JIRA or label) to tackle this before merging this in. Let me know and I'd be happy to create these.\r\n   \r\n   That would be very helpful; I'm still having a hard time seeing the forest for the trees. Heck, by that analogy, I feel like I'm still staring at the roots of just one of the trees, trying to wrap my head around (the details of) the Substrait specification.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T10:07:22.262+0000",
                    "updated": "2022-02-01T10:07:22.262+0000",
                    "started": "2022-02-01T10:07:22.261+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718531",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/718533",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on a change in pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#discussion_r796440289\n\n\n\n##########\nFile path: cpp/cmake_modules/DefineOptions.cmake\n##########\n@@ -225,7 +225,7 @@ if(\"${CMAKE_SOURCE_DIR}\" STREQUAL \"${CMAKE_CURRENT_SOURCE_DIR}\")\n \n   define_option(ARROW_DATASET \"Build the Arrow Dataset Modules\" OFF)\n \n-  define_option(ARROW_ENGINE \"Build the Arrow Execution Engine\" OFF)\n+  define_option(ARROW_ENGINE \"Build the Arrow Query Engine Module\" OFF)\n\nReview comment:\n       I suppose the idea might have been that once we have Substrait support and there's a SQL parser that can produce Substrait for it, you *will* be able to speak SQL to it. But I don't have a personal opinion on this, nor have I been involved long enough to know the history.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T10:10:08.438+0000",
                    "updated": "2022-02-01T10:10:08.438+0000",
                    "started": "2022-02-01T10:10:08.437+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718533",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/718540",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on a change in pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#discussion_r796453054\n\n\n\n##########\nFile path: cpp/cmake_modules/DefineOptions.cmake\n##########\n@@ -478,6 +478,13 @@ advised that if this is enabled 'install' will fail silently on components;\\\n that have not been built\"\n                 OFF)\n \n+  set(ARROW_SUBSTRAIT_REPO_AND_TAG_DEFAULT\n+      \"https://github.com/substrait-io/substrait e1b4c04a1b518912f4c4065b16a1b2c0ac8e14cf\"\n+  )\n+  define_option_string(ARROW_SUBSTRAIT_REPO_AND_TAG\n+                       \"Custom 'repository_url tag' for generating substrait accessors\"\n+                       \"${ARROW_SUBSTRAIT_REPO_AND_TAG_DEFAULT}\")\n+\n\nReview comment:\n       I agree. aa0e94b\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T10:26:13.933+0000",
                    "updated": "2022-02-01T10:26:13.933+0000",
                    "started": "2022-02-01T10:26:13.932+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718540",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/718544",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on a change in pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#discussion_r796460348\n\n\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n\nReview comment:\n       It looks to me like the macro was just copy-pasted from one of the other examples. Four out of the six other examples in the directory make use of it, one uses your suggestion, and the remaining one does more complicated error handling. So I'll leave it as is based on precedence.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T10:34:43.944+0000",
                    "updated": "2022-02-01T10:34:43.944+0000",
                    "started": "2022-02-01T10:34:43.944+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718544",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/718545",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on a change in pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#discussion_r796462960\n\n\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n\nReview comment:\n       Agreed. 584b49e\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T10:38:06.985+0000",
                    "updated": "2022-02-01T10:38:06.985+0000",
                    "started": "2022-02-01T10:38:06.985+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718545",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/718565",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on a change in pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#discussion_r796490480\n\n\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n+};\n+\n+int main(int argc, char** argv) {\n+  // Plans arrive at the consumer serialized in a substrait-formatted Buffer\n+  auto maybe_serialized_plan = GetSubstraitFromServer().result();\n+  ABORT_ON_FAILURE(maybe_serialized_plan.status());\n+  std::shared_ptr<arrow::Buffer> serialized_plan =\n+      std::move(maybe_serialized_plan).ValueOrDie();\n+\n+  // Print the received plan to stdout as JSON\n+  arrow::Result<std::string> maybe_plan_json =\n+      eng::internal::SubstraitToJSON(\"Plan\", *serialized_plan);\n+  ABORT_ON_FAILURE(maybe_plan_json.status());\n+  std::cout << std::string('#', 50) << \" received substrait::Plan:\" << std::endl;\n+  std::cout << maybe_plan_json.ValueOrDie() << std::endl;\n+\n+  // Deserializing a plan requires a factory for consumers: each time a sink node is\n+  // deserialized, a consumer is constructed into which its batches will be piped.\n+  std::vector<std::shared_ptr<cp::SinkNodeConsumer>> consumers;\n+  std::function<std::shared_ptr<cp::SinkNodeConsumer>()> consumer_factory = [&] {\n+    // All batches produced by the plan will be fed into IgnoringConsumers:\n+    auto tag = consumers.size();\n+    consumers.emplace_back(new IgnoringConsumer{tag});\n+    return consumers.back();\n+  };\n+\n+  // NOTE Although most of the Deserialize functions require a const ExtensionSet& to\n+  // resolve extension references, a Plan is what we use to construct that ExtensionSet.\n+  // (It should be an optional output later.) In particular, it does not need to be kept\n+  // alive nor does the serialized plan- none of the arrow:: objects in the output will\n+  // contain references to memory owned by either.\n+  auto maybe_decls = eng::DeserializePlan(*serialized_plan, consumer_factory);\n+  ABORT_ON_FAILURE(maybe_decls.status());\n+  std::vector<cp::Declaration> decls = std::move(maybe_decls).ValueOrDie();\n+\n+  // It's safe to drop the serialized plan; we don't leave references to its memory\n+  serialized_plan.reset();\n+\n+  // Construct an empty plan (note: configure Function registry and ThreadPool here)\n+  auto maybe_plan = cp::ExecPlan::Make();\n+  ABORT_ON_FAILURE(maybe_plan.status());\n+  std::shared_ptr<cp::ExecPlan> plan = std::move(maybe_plan).ValueOrDie();\n+\n+  for (const cp::Declaration& decl : decls) {\n+    // Add decl to plan (note: configure ExecNode registry here)\n+    ABORT_ON_FAILURE(decl.AddToPlan(plan.get()).status());\n+  }\n+\n+  // Validate the plan and print it to stdout\n+  ABORT_ON_FAILURE(plan->Validate());\n+  std::cout << std::string('#', 50) << \" produced arrow::ExecPlan:\" << std::endl;\n+  std::cout << plan->ToString() << std::endl;\n+\n+  // Start the plan...\n+  std::cout << std::string('#', 50) << \" consuming batches:\" << std::endl;\n+  ABORT_ON_FAILURE(plan->StartProducing());\n+\n+  // ... and wait for it to finish\n+  ABORT_ON_FAILURE(plan->finished().status());\n+  return EXIT_SUCCESS;\n+}\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer() {\n\nReview comment:\n       In Substrait, the sink(s) is/are indeed implicit. But `SinkNodeConsumer` is preexisting Arrow compute terminology, so I can't really change its name. I clarified the comment describing what the factory of consumers is for (f1e6259), but don't know how else to improve the situation.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T11:13:04.286+0000",
                    "updated": "2022-02-01T11:13:04.286+0000",
                    "started": "2022-02-01T11:13:04.285+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718565",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/718573",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on a change in pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#discussion_r796495301\n\n\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n\nReview comment:\n       Yeah, when Substrait talks about consumers they mean something that consumes a plan, whereas Arrow uses the term for something that consumes data. It's painful, but I think that's just going to be the nature of the beast.\r\n   \r\n   Or maybe we should submit an issue to the Oxford English Dictionary to introduce the `::` operator and start namespacing English words, and prefix sections with `using namespace` where applicable? :)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T11:19:38.928+0000",
                    "updated": "2022-02-01T11:19:38.928+0000",
                    "started": "2022-02-01T11:19:38.928+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718573",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/718581",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on a change in pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#discussion_r796501552\n\n\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n\nReview comment:\n       See 283e87b\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T11:27:41.744+0000",
                    "updated": "2022-02-01T11:27:41.744+0000",
                    "started": "2022-02-01T11:27:41.744+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718581",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/718586",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on a change in pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#discussion_r796507162\n\n\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n+};\n+\n+int main(int argc, char** argv) {\n+  // Plans arrive at the consumer serialized in a substrait-formatted Buffer\n\nReview comment:\n       See d64d53b\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T11:35:24.993+0000",
                    "updated": "2022-02-01T11:35:24.993+0000",
                    "started": "2022-02-01T11:35:24.993+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718586",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/718601",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on a change in pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#discussion_r796517780\n\n\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n+};\n+\n+int main(int argc, char** argv) {\n+  // Plans arrive at the consumer serialized in a substrait-formatted Buffer\n+  auto maybe_serialized_plan = GetSubstraitFromServer().result();\n+  ABORT_ON_FAILURE(maybe_serialized_plan.status());\n+  std::shared_ptr<arrow::Buffer> serialized_plan =\n+      std::move(maybe_serialized_plan).ValueOrDie();\n+\n+  // Print the received plan to stdout as JSON\n+  arrow::Result<std::string> maybe_plan_json =\n+      eng::internal::SubstraitToJSON(\"Plan\", *serialized_plan);\n+  ABORT_ON_FAILURE(maybe_plan_json.status());\n+  std::cout << std::string('#', 50) << \" received substrait::Plan:\" << std::endl;\n+  std::cout << maybe_plan_json.ValueOrDie() << std::endl;\n+\n+  // Deserializing a plan requires a factory for consumers: each time a sink node is\n+  // deserialized, a consumer is constructed into which its batches will be piped.\n+  std::vector<std::shared_ptr<cp::SinkNodeConsumer>> consumers;\n+  std::function<std::shared_ptr<cp::SinkNodeConsumer>()> consumer_factory = [&] {\n+    // All batches produced by the plan will be fed into IgnoringConsumers:\n+    auto tag = consumers.size();\n+    consumers.emplace_back(new IgnoringConsumer{tag});\n+    return consumers.back();\n+  };\n+\n+  // NOTE Although most of the Deserialize functions require a const ExtensionSet& to\n+  // resolve extension references, a Plan is what we use to construct that ExtensionSet.\n+  // (It should be an optional output later.) In particular, it does not need to be kept\n+  // alive nor does the serialized plan- none of the arrow:: objects in the output will\n+  // contain references to memory owned by either.\n\nReview comment:\n       I agree; this is an implementation detail that should be hidden from the user if at all possible. See e730309.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T11:49:34.903+0000",
                    "updated": "2022-02-01T11:49:34.903+0000",
                    "started": "2022-02-01T11:49:34.903+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718601",
                    "issueId": "13420453"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/worklog/718604",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jvanstraten commented on a change in pull request #12279:\nURL: https://github.com/apache/arrow/pull/12279#discussion_r796519209\n\n\n\n##########\nFile path: cpp/examples/arrow/engine_substrait_consumption.cc\n##########\n@@ -0,0 +1,187 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements. See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership. The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License. You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied. See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <arrow/api.h>\n+#include <arrow/compute/api.h>\n+#include <arrow/compute/exec/options.h>\n+#include <arrow/engine/substrait/serde.h>\n+\n+#include <cstdlib>\n+#include <iostream>\n+#include <memory>\n+#include <vector>\n+\n+namespace eng = ::arrow::engine;\n+namespace cp = ::arrow::compute;\n+\n+#define ABORT_ON_FAILURE(expr)                     \\\n+  do {                                             \\\n+    arrow::Status status_ = (expr);                \\\n+    if (!status_.ok()) {                           \\\n+      std::cerr << status_.message() << std::endl; \\\n+      abort();                                     \\\n+    }                                              \\\n+  } while (0);\n+\n+arrow::Future<std::shared_ptr<arrow::Buffer>> GetSubstraitFromServer();\n+\n+class IgnoringConsumer : public cp::SinkNodeConsumer {\n+ public:\n+  explicit IgnoringConsumer(size_t tag) : tag_{tag} {}\n+\n+  arrow::Status Consume(cp::ExecBatch batch) override {\n+    // Consume a batch of data\n+    // (just print its row count to stdout)\n+    std::cout << \"-\" << tag_ << \" consumed \" << batch.length << \" rows\" << std::endl;\n+    return arrow::Status::OK();\n+  }\n+\n+  arrow::Future<> Finish() override {\n+    // Signal to the consumer that the last batch has been delivered\n+    // (we don't do any real work in this consumer so mark it finished immediately)\n+    //\n+    // The returned future should only finish when all outstanding tasks have completed\n+    // (after this method is called Consume is guaranteed not to be called again)\n+    std::cout << \"-\" << tag_ << \" finished\" << std::endl;\n+    return arrow::Future<>::MakeFinished();\n+  }\n+\n+ private:\n+  size_t tag_;\n+};\n+\n+int main(int argc, char** argv) {\n+  // Plans arrive at the consumer serialized in a substrait-formatted Buffer\n+  auto maybe_serialized_plan = GetSubstraitFromServer().result();\n+  ABORT_ON_FAILURE(maybe_serialized_plan.status());\n+  std::shared_ptr<arrow::Buffer> serialized_plan =\n+      std::move(maybe_serialized_plan).ValueOrDie();\n+\n+  // Print the received plan to stdout as JSON\n+  arrow::Result<std::string> maybe_plan_json =\n+      eng::internal::SubstraitToJSON(\"Plan\", *serialized_plan);\n+  ABORT_ON_FAILURE(maybe_plan_json.status());\n+  std::cout << std::string('#', 50) << \" received substrait::Plan:\" << std::endl;\n+  std::cout << maybe_plan_json.ValueOrDie() << std::endl;\n+\n+  // Deserializing a plan requires a factory for consumers: each time a sink node is\n+  // deserialized, a consumer is constructed into which its batches will be piped.\n+  std::vector<std::shared_ptr<cp::SinkNodeConsumer>> consumers;\n+  std::function<std::shared_ptr<cp::SinkNodeConsumer>()> consumer_factory = [&] {\n+    // All batches produced by the plan will be fed into IgnoringConsumers:\n+    auto tag = consumers.size();\n+    consumers.emplace_back(new IgnoringConsumer{tag});\n+    return consumers.back();\n+  };\n+\n+  // NOTE Although most of the Deserialize functions require a const ExtensionSet& to\n+  // resolve extension references, a Plan is what we use to construct that ExtensionSet.\n+  // (It should be an optional output later.) In particular, it does not need to be kept\n+  // alive nor does the serialized plan- none of the arrow:: objects in the output will\n+  // contain references to memory owned by either.\n+  auto maybe_decls = eng::DeserializePlan(*serialized_plan, consumer_factory);\n\nReview comment:\n       See e730309, though these `auto`s were visually resolved pretty easily because the type was already explicit after unwrapping the Result.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-01T11:51:32.852+0000",
                    "updated": "2022-02-01T11:51:32.852+0000",
                    "started": "2022-02-01T11:51:32.851+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "718604",
                    "issueId": "13420453"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 81000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3f8b4309[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@53db17f3[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@35965df9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@3e79b037[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@77656d9f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@21ac8b73[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2652632a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@55d987df[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@90c016e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@4cbee42f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@79c095a1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@603e0239[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 81000,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Feb 16 02:22:38 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-02-16T02:22:38.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15238/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2022-01-03T19:47:46.000+0000",
        "updated": "2022-02-17T01:02:14.000+0000",
        "timeoriginalestimate": null,
        "description": "Circular dependencies are popping up in the query engine as the compute module is very low level.  For example, it would be nice if the default registry included the scan node and dataset write node.  We will want to be adding spillover support at some point and that will rely on parquet/dataset operations.\r\n\r\nWe should create a dedicated engine module which includes the query plans, the nodes, etc.  This module would not contain the kernels or other low level compute primitives.  This way we could have something like...\r\n\r\nengine -> datasets (for scanning) -> parquet -> compute (for calculating statistics)\r\n\r\nThe base ExecPlan itself could either go in compute or engine depending on which has the least amount of friction.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "22.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 81000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Create \"engine\" module for the query engine",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/comment/17469488",
                    "id": "17469488",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "One artifact of this is that the arrow::dataset::internal::Intialize function should go away and the adding of scan/write tasks to the exec node registry should happen statically when the default exec node registry is created (this default exec node registry creation will need to happen in the engine module).",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-01-05T19:04:14.224+0000",
                    "updated": "2022-01-05T19:04:14.224+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13420453/comment/17492963",
                    "id": "17492963",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 12279\n[https://github.com/apache/arrow/pull/12279]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-02-16T02:22:38.799+0000",
                    "updated": "2022-02-16T02:22:38.799+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0y7go:",
        "customfield_12314139": null
    }
}