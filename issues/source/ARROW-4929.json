{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13222110",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110",
    "key": "ARROW-4929",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343937",
                "id": "12343937",
                "description": "",
                "name": "0.13.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-04-01"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
            "name": "kou",
            "key": "kou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
            },
            "displayName": "Kouhei Sutou",
            "active": true,
            "timeZone": "Asia/Tokyo"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12332430",
                "id": "12332430",
                "name": "GLib"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
            "name": "kou",
            "key": "kou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
            },
            "displayName": "Kouhei Sutou",
            "active": true,
            "timeZone": "Asia/Tokyo"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
            "name": "kou",
            "key": "kou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
            },
            "displayName": "Kouhei Sutou",
            "active": true,
            "timeZone": "Asia/Tokyo"
        },
        "aggregateprogress": {
            "progress": 8400,
            "total": 8400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 8400,
            "total": 8400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4929/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 14,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214316",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-16T23:01:44.286+0000",
                    "updated": "2019-03-16T23:01:44.286+0000",
                    "started": "2019-03-16T23:01:44.285+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214316",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214354",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on issue #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941#issuecomment-473611112\n \n \n   I've moved all computation codes to `compute.{cpp,h}` from `basic-array.{cpp,h}`.\r\n   It generates large diff. Sorry. Core change is https://github.com/apache/arrow/pull/3941/commits/95c080750332450f5267a007e9a17e10aa01e74b .\r\n   \r\n   Moving to `compute.{cpp,h}` is for better documentation.\r\n   If we implement all computation features in `basic-array.{cpp,h}`, we can't use composite array such as `GArrowDictionaryArray` and `GArrowStructArray` as a return value type.\r\n   If we use composite array in `basic-array.h`, we need to declare composite array type in `basic-array.h`. It generates document that has composite arrays in basic array page. It's weird. So I've moved all computation codes to `compute.{cpp,h}`.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-17T02:53:18.960+0000",
                    "updated": "2019-03-17T02:53:18.960+0000",
                    "started": "2019-03-17T02:53:18.959+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214354",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214523",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "shiro615 commented on pull request #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-17T23:40:10.575+0000",
                    "updated": "2019-03-17T23:40:10.575+0000",
                    "started": "2019-03-17T23:40:10.575+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214523",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214606",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mrkn commented on pull request #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941#discussion_r266316120\n \n \n\n ##########\n File path: c_glib/arrow-glib/compute.cpp\n ##########\n @@ -295,6 +328,581 @@ garrow_count_options_new(void)\n   return GARROW_COUNT_OPTIONS(count_options);\n }\n \n+\n+/**\n+ * garrow_array_cast:\n+ * @array: A #GArrowArray.\n+ * @target_data_type: A #GArrowDataType of cast target data.\n+ * @options: (nullable): A #GArrowCastOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created casted array on success, %NULL on error.\n+ *\n+ * Since: 0.7.0\n+ */\n+GArrowArray *\n+garrow_array_cast(GArrowArray *array,\n+                  GArrowDataType *target_data_type,\n+                  GArrowCastOptions *options,\n+                  GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  auto arrow_target_data_type = garrow_data_type_get_raw(target_data_type);\n+  std::shared_ptr<arrow::Array> arrow_casted_array;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_cast_options_get_raw(options);\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  *arrow_options,\n+                                  &arrow_casted_array);\n+  } else {\n+    arrow::compute::CastOptions arrow_options;\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  arrow_options,\n+                                  &arrow_casted_array);\n+  }\n+\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][cast] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \"> -> <\";\n+    message << arrow_target_data_type->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_casted_array);\n+}\n+\n+/**\n+ * garrow_array_unique:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created unique elements array on success, %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowArray *\n+garrow_array_unique(GArrowArray *array,\n+                    GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  std::shared_ptr<arrow::Array> arrow_unique_array;\n+  auto status = arrow::compute::Unique(&context,\n+                                       arrow::compute::Datum(arrow_array),\n+                                       &arrow_unique_array);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][unique] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_unique_array);\n+}\n+\n+/**\n+ * garrow_array_dictionary_encode:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created #GArrowDictionaryArray for the @array on success,\n+ *   %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowDictionaryArray *\n+garrow_array_dictionary_encode(GArrowArray *array,\n+                               GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum dictionary_encoded_datum;\n+  auto status =\n+    arrow::compute::DictionaryEncode(&context,\n+                                     arrow::compute::Datum(arrow_array),\n+                                     &dictionary_encoded_datum);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][dictionary-encode] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  auto arrow_dictionary_encoded_array =\n+    arrow::MakeArray(dictionary_encoded_datum.array());\n+  auto dictionary_encoded_array =\n+    garrow_array_new_raw(&arrow_dictionary_encoded_array);\n+  return GARROW_DICTIONARY_ARRAY(dictionary_encoded_array);\n+}\n+\n+/**\n+ * garrow_array_count:\n+ * @array: A #GArrowArray.\n+ * @options: (nullable): A #GArrowCountOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: The number of target values on success. If an error is occurred,\n+ *   the returned value is untrustful value.\n+ *\n+ * Since: 0.13.0\n+ */\n+gint64\n+garrow_array_count(GArrowArray *array,\n+                   GArrowCountOptions *options,\n+                   GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum counted_datum;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_count_options_get_raw(options);\n+    status = arrow::compute::Count(&context,\n+                                   *arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  } else {\n+    arrow::compute::CountOptions arrow_options(arrow::compute::CountOptions::COUNT_ALL);\n+    status = arrow::compute::Count(&context,\n+                                   arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  }\n+\n+  if (garrow_error_check(error, status, \"[array][count]\")) {\n+    using ScalarType = typename arrow::TypeTraits<arrow::Int64Type>::ScalarType;\n+    auto counted_scalar = std::dynamic_pointer_cast<ScalarType>(counted_datum.scalar());\n+    return counted_scalar->value;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+/**\n+ * garrow_array_count_values:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A #GArrowStructArray of `{input type \"values\", int64_t \"counts\"}`\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.13.0\n+ */\n+GArrowStructArray *\n+garrow_array_count_values(GArrowArray *array,\n \n Review comment:\n   @kou Why this function name is not `*_value_counts`?\r\n   \r\n   I think `*_value_counts` is better than `*_count_values` because it can be derived trivially from the wrapped C++ function name `ValueCounts`.\r\n   \r\n   Moreover, in Ruby side, `value_counts` is better for me because enumerable-statistics.gem I maintained provides `value_counts` method for Array and Enumerable.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-18T07:18:58.093+0000",
                    "updated": "2019-03-18T07:18:58.093+0000",
                    "started": "2019-03-18T07:18:58.092+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214606",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214613",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941#discussion_r266317610\n \n \n\n ##########\n File path: c_glib/arrow-glib/compute.cpp\n ##########\n @@ -295,6 +328,581 @@ garrow_count_options_new(void)\n   return GARROW_COUNT_OPTIONS(count_options);\n }\n \n+\n+/**\n+ * garrow_array_cast:\n+ * @array: A #GArrowArray.\n+ * @target_data_type: A #GArrowDataType of cast target data.\n+ * @options: (nullable): A #GArrowCastOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created casted array on success, %NULL on error.\n+ *\n+ * Since: 0.7.0\n+ */\n+GArrowArray *\n+garrow_array_cast(GArrowArray *array,\n+                  GArrowDataType *target_data_type,\n+                  GArrowCastOptions *options,\n+                  GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  auto arrow_target_data_type = garrow_data_type_get_raw(target_data_type);\n+  std::shared_ptr<arrow::Array> arrow_casted_array;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_cast_options_get_raw(options);\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  *arrow_options,\n+                                  &arrow_casted_array);\n+  } else {\n+    arrow::compute::CastOptions arrow_options;\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  arrow_options,\n+                                  &arrow_casted_array);\n+  }\n+\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][cast] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \"> -> <\";\n+    message << arrow_target_data_type->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_casted_array);\n+}\n+\n+/**\n+ * garrow_array_unique:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created unique elements array on success, %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowArray *\n+garrow_array_unique(GArrowArray *array,\n+                    GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  std::shared_ptr<arrow::Array> arrow_unique_array;\n+  auto status = arrow::compute::Unique(&context,\n+                                       arrow::compute::Datum(arrow_array),\n+                                       &arrow_unique_array);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][unique] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_unique_array);\n+}\n+\n+/**\n+ * garrow_array_dictionary_encode:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created #GArrowDictionaryArray for the @array on success,\n+ *   %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowDictionaryArray *\n+garrow_array_dictionary_encode(GArrowArray *array,\n+                               GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum dictionary_encoded_datum;\n+  auto status =\n+    arrow::compute::DictionaryEncode(&context,\n+                                     arrow::compute::Datum(arrow_array),\n+                                     &dictionary_encoded_datum);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][dictionary-encode] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  auto arrow_dictionary_encoded_array =\n+    arrow::MakeArray(dictionary_encoded_datum.array());\n+  auto dictionary_encoded_array =\n+    garrow_array_new_raw(&arrow_dictionary_encoded_array);\n+  return GARROW_DICTIONARY_ARRAY(dictionary_encoded_array);\n+}\n+\n+/**\n+ * garrow_array_count:\n+ * @array: A #GArrowArray.\n+ * @options: (nullable): A #GArrowCountOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: The number of target values on success. If an error is occurred,\n+ *   the returned value is untrustful value.\n+ *\n+ * Since: 0.13.0\n+ */\n+gint64\n+garrow_array_count(GArrowArray *array,\n+                   GArrowCountOptions *options,\n+                   GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum counted_datum;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_count_options_get_raw(options);\n+    status = arrow::compute::Count(&context,\n+                                   *arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  } else {\n+    arrow::compute::CountOptions arrow_options(arrow::compute::CountOptions::COUNT_ALL);\n+    status = arrow::compute::Count(&context,\n+                                   arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  }\n+\n+  if (garrow_error_check(error, status, \"[array][count]\")) {\n+    using ScalarType = typename arrow::TypeTraits<arrow::Int64Type>::ScalarType;\n+    auto counted_scalar = std::dynamic_pointer_cast<ScalarType>(counted_datum.scalar());\n+    return counted_scalar->value;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+/**\n+ * garrow_array_count_values:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A #GArrowStructArray of `{input type \"values\", int64_t \"counts\"}`\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.13.0\n+ */\n+GArrowStructArray *\n+garrow_array_count_values(GArrowArray *array,\n \n Review comment:\n   Because `value_counts` isn't a verb.\r\n   `compute_value_counts()` will be an alternative but it's a bit long.\r\n   PHP has `array_count_values`: http://php.net/manual/en/function.array-count-values.php\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-18T07:26:42.042+0000",
                    "updated": "2019-03-18T07:26:42.042+0000",
                    "started": "2019-03-18T07:26:42.041+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214613",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214614",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mrkn commented on pull request #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941#discussion_r266318871\n \n \n\n ##########\n File path: c_glib/arrow-glib/compute.cpp\n ##########\n @@ -295,6 +328,581 @@ garrow_count_options_new(void)\n   return GARROW_COUNT_OPTIONS(count_options);\n }\n \n+\n+/**\n+ * garrow_array_cast:\n+ * @array: A #GArrowArray.\n+ * @target_data_type: A #GArrowDataType of cast target data.\n+ * @options: (nullable): A #GArrowCastOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created casted array on success, %NULL on error.\n+ *\n+ * Since: 0.7.0\n+ */\n+GArrowArray *\n+garrow_array_cast(GArrowArray *array,\n+                  GArrowDataType *target_data_type,\n+                  GArrowCastOptions *options,\n+                  GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  auto arrow_target_data_type = garrow_data_type_get_raw(target_data_type);\n+  std::shared_ptr<arrow::Array> arrow_casted_array;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_cast_options_get_raw(options);\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  *arrow_options,\n+                                  &arrow_casted_array);\n+  } else {\n+    arrow::compute::CastOptions arrow_options;\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  arrow_options,\n+                                  &arrow_casted_array);\n+  }\n+\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][cast] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \"> -> <\";\n+    message << arrow_target_data_type->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_casted_array);\n+}\n+\n+/**\n+ * garrow_array_unique:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created unique elements array on success, %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowArray *\n+garrow_array_unique(GArrowArray *array,\n+                    GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  std::shared_ptr<arrow::Array> arrow_unique_array;\n+  auto status = arrow::compute::Unique(&context,\n+                                       arrow::compute::Datum(arrow_array),\n+                                       &arrow_unique_array);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][unique] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_unique_array);\n+}\n+\n+/**\n+ * garrow_array_dictionary_encode:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created #GArrowDictionaryArray for the @array on success,\n+ *   %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowDictionaryArray *\n+garrow_array_dictionary_encode(GArrowArray *array,\n+                               GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum dictionary_encoded_datum;\n+  auto status =\n+    arrow::compute::DictionaryEncode(&context,\n+                                     arrow::compute::Datum(arrow_array),\n+                                     &dictionary_encoded_datum);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][dictionary-encode] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  auto arrow_dictionary_encoded_array =\n+    arrow::MakeArray(dictionary_encoded_datum.array());\n+  auto dictionary_encoded_array =\n+    garrow_array_new_raw(&arrow_dictionary_encoded_array);\n+  return GARROW_DICTIONARY_ARRAY(dictionary_encoded_array);\n+}\n+\n+/**\n+ * garrow_array_count:\n+ * @array: A #GArrowArray.\n+ * @options: (nullable): A #GArrowCountOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: The number of target values on success. If an error is occurred,\n+ *   the returned value is untrustful value.\n+ *\n+ * Since: 0.13.0\n+ */\n+gint64\n+garrow_array_count(GArrowArray *array,\n+                   GArrowCountOptions *options,\n+                   GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum counted_datum;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_count_options_get_raw(options);\n+    status = arrow::compute::Count(&context,\n+                                   *arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  } else {\n+    arrow::compute::CountOptions arrow_options(arrow::compute::CountOptions::COUNT_ALL);\n+    status = arrow::compute::Count(&context,\n+                                   arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  }\n+\n+  if (garrow_error_check(error, status, \"[array][count]\")) {\n+    using ScalarType = typename arrow::TypeTraits<arrow::Int64Type>::ScalarType;\n+    auto counted_scalar = std::dynamic_pointer_cast<ScalarType>(counted_datum.scalar());\n+    return counted_scalar->value;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+/**\n+ * garrow_array_count_values:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A #GArrowStructArray of `{input type \"values\", int64_t \"counts\"}`\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.13.0\n+ */\n+GArrowStructArray *\n+garrow_array_count_values(GArrowArray *array,\n \n Review comment:\n   PHP is not standard in data science field, so it cannot be a reference.\r\n   In the context of Apache Arrow, we should refer pandas.\r\n   Pandas's `value_counts` is defacto standard name in such the feature as my knowledge.\r\n   `count_values` will make programmers confusing.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-18T07:31:58.255+0000",
                    "updated": "2019-03-18T07:31:58.255+0000",
                    "started": "2019-03-18T07:31:58.255+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214614",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214615",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mrkn commented on pull request #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941#discussion_r266319718\n \n \n\n ##########\n File path: c_glib/arrow-glib/compute.cpp\n ##########\n @@ -295,6 +328,581 @@ garrow_count_options_new(void)\n   return GARROW_COUNT_OPTIONS(count_options);\n }\n \n+\n+/**\n+ * garrow_array_cast:\n+ * @array: A #GArrowArray.\n+ * @target_data_type: A #GArrowDataType of cast target data.\n+ * @options: (nullable): A #GArrowCastOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created casted array on success, %NULL on error.\n+ *\n+ * Since: 0.7.0\n+ */\n+GArrowArray *\n+garrow_array_cast(GArrowArray *array,\n+                  GArrowDataType *target_data_type,\n+                  GArrowCastOptions *options,\n+                  GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  auto arrow_target_data_type = garrow_data_type_get_raw(target_data_type);\n+  std::shared_ptr<arrow::Array> arrow_casted_array;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_cast_options_get_raw(options);\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  *arrow_options,\n+                                  &arrow_casted_array);\n+  } else {\n+    arrow::compute::CastOptions arrow_options;\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  arrow_options,\n+                                  &arrow_casted_array);\n+  }\n+\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][cast] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \"> -> <\";\n+    message << arrow_target_data_type->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_casted_array);\n+}\n+\n+/**\n+ * garrow_array_unique:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created unique elements array on success, %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowArray *\n+garrow_array_unique(GArrowArray *array,\n+                    GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  std::shared_ptr<arrow::Array> arrow_unique_array;\n+  auto status = arrow::compute::Unique(&context,\n+                                       arrow::compute::Datum(arrow_array),\n+                                       &arrow_unique_array);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][unique] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_unique_array);\n+}\n+\n+/**\n+ * garrow_array_dictionary_encode:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created #GArrowDictionaryArray for the @array on success,\n+ *   %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowDictionaryArray *\n+garrow_array_dictionary_encode(GArrowArray *array,\n+                               GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum dictionary_encoded_datum;\n+  auto status =\n+    arrow::compute::DictionaryEncode(&context,\n+                                     arrow::compute::Datum(arrow_array),\n+                                     &dictionary_encoded_datum);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][dictionary-encode] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  auto arrow_dictionary_encoded_array =\n+    arrow::MakeArray(dictionary_encoded_datum.array());\n+  auto dictionary_encoded_array =\n+    garrow_array_new_raw(&arrow_dictionary_encoded_array);\n+  return GARROW_DICTIONARY_ARRAY(dictionary_encoded_array);\n+}\n+\n+/**\n+ * garrow_array_count:\n+ * @array: A #GArrowArray.\n+ * @options: (nullable): A #GArrowCountOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: The number of target values on success. If an error is occurred,\n+ *   the returned value is untrustful value.\n+ *\n+ * Since: 0.13.0\n+ */\n+gint64\n+garrow_array_count(GArrowArray *array,\n+                   GArrowCountOptions *options,\n+                   GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum counted_datum;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_count_options_get_raw(options);\n+    status = arrow::compute::Count(&context,\n+                                   *arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  } else {\n+    arrow::compute::CountOptions arrow_options(arrow::compute::CountOptions::COUNT_ALL);\n+    status = arrow::compute::Count(&context,\n+                                   arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  }\n+\n+  if (garrow_error_check(error, status, \"[array][count]\")) {\n+    using ScalarType = typename arrow::TypeTraits<arrow::Int64Type>::ScalarType;\n+    auto counted_scalar = std::dynamic_pointer_cast<ScalarType>(counted_datum.scalar());\n+    return counted_scalar->value;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+/**\n+ * garrow_array_count_values:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A #GArrowStructArray of `{input type \"values\", int64_t \"counts\"}`\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.13.0\n+ */\n+GArrowStructArray *\n+garrow_array_count_values(GArrowArray *array,\n \n Review comment:\n   If renaming this function isn't acceptable, I'd like to propose adding `garrow_array_value_counts` as an alias.\r\n   How do you think about this?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-18T07:35:58.362+0000",
                    "updated": "2019-03-18T07:35:58.362+0000",
                    "started": "2019-03-18T07:35:58.362+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214615",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214616",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941#discussion_r266319808\n \n \n\n ##########\n File path: c_glib/arrow-glib/compute.cpp\n ##########\n @@ -295,6 +328,581 @@ garrow_count_options_new(void)\n   return GARROW_COUNT_OPTIONS(count_options);\n }\n \n+\n+/**\n+ * garrow_array_cast:\n+ * @array: A #GArrowArray.\n+ * @target_data_type: A #GArrowDataType of cast target data.\n+ * @options: (nullable): A #GArrowCastOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created casted array on success, %NULL on error.\n+ *\n+ * Since: 0.7.0\n+ */\n+GArrowArray *\n+garrow_array_cast(GArrowArray *array,\n+                  GArrowDataType *target_data_type,\n+                  GArrowCastOptions *options,\n+                  GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  auto arrow_target_data_type = garrow_data_type_get_raw(target_data_type);\n+  std::shared_ptr<arrow::Array> arrow_casted_array;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_cast_options_get_raw(options);\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  *arrow_options,\n+                                  &arrow_casted_array);\n+  } else {\n+    arrow::compute::CastOptions arrow_options;\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  arrow_options,\n+                                  &arrow_casted_array);\n+  }\n+\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][cast] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \"> -> <\";\n+    message << arrow_target_data_type->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_casted_array);\n+}\n+\n+/**\n+ * garrow_array_unique:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created unique elements array on success, %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowArray *\n+garrow_array_unique(GArrowArray *array,\n+                    GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  std::shared_ptr<arrow::Array> arrow_unique_array;\n+  auto status = arrow::compute::Unique(&context,\n+                                       arrow::compute::Datum(arrow_array),\n+                                       &arrow_unique_array);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][unique] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_unique_array);\n+}\n+\n+/**\n+ * garrow_array_dictionary_encode:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created #GArrowDictionaryArray for the @array on success,\n+ *   %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowDictionaryArray *\n+garrow_array_dictionary_encode(GArrowArray *array,\n+                               GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum dictionary_encoded_datum;\n+  auto status =\n+    arrow::compute::DictionaryEncode(&context,\n+                                     arrow::compute::Datum(arrow_array),\n+                                     &dictionary_encoded_datum);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][dictionary-encode] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  auto arrow_dictionary_encoded_array =\n+    arrow::MakeArray(dictionary_encoded_datum.array());\n+  auto dictionary_encoded_array =\n+    garrow_array_new_raw(&arrow_dictionary_encoded_array);\n+  return GARROW_DICTIONARY_ARRAY(dictionary_encoded_array);\n+}\n+\n+/**\n+ * garrow_array_count:\n+ * @array: A #GArrowArray.\n+ * @options: (nullable): A #GArrowCountOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: The number of target values on success. If an error is occurred,\n+ *   the returned value is untrustful value.\n+ *\n+ * Since: 0.13.0\n+ */\n+gint64\n+garrow_array_count(GArrowArray *array,\n+                   GArrowCountOptions *options,\n+                   GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum counted_datum;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_count_options_get_raw(options);\n+    status = arrow::compute::Count(&context,\n+                                   *arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  } else {\n+    arrow::compute::CountOptions arrow_options(arrow::compute::CountOptions::COUNT_ALL);\n+    status = arrow::compute::Count(&context,\n+                                   arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  }\n+\n+  if (garrow_error_check(error, status, \"[array][count]\")) {\n+    using ScalarType = typename arrow::TypeTraits<arrow::Int64Type>::ScalarType;\n+    auto counted_scalar = std::dynamic_pointer_cast<ScalarType>(counted_datum.scalar());\n+    return counted_scalar->value;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+/**\n+ * garrow_array_count_values:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A #GArrowStructArray of `{input type \"values\", int64_t \"counts\"}`\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.13.0\n+ */\n+GArrowStructArray *\n+garrow_array_count_values(GArrowArray *array,\n \n Review comment:\n   If someone wants pandas compatible API.\r\n   We can just provide alias as pandas compatible layer.\r\n   I think that we provide consistent API than pandas compatible API.\r\n   R uses `table` for the feature. It's different with pandas.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-18T07:36:24.965+0000",
                    "updated": "2019-03-18T07:36:24.965+0000",
                    "started": "2019-03-18T07:36:24.965+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214616",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214619",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mrkn commented on pull request #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941#discussion_r266320538\n \n \n\n ##########\n File path: c_glib/arrow-glib/compute.cpp\n ##########\n @@ -295,6 +328,581 @@ garrow_count_options_new(void)\n   return GARROW_COUNT_OPTIONS(count_options);\n }\n \n+\n+/**\n+ * garrow_array_cast:\n+ * @array: A #GArrowArray.\n+ * @target_data_type: A #GArrowDataType of cast target data.\n+ * @options: (nullable): A #GArrowCastOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created casted array on success, %NULL on error.\n+ *\n+ * Since: 0.7.0\n+ */\n+GArrowArray *\n+garrow_array_cast(GArrowArray *array,\n+                  GArrowDataType *target_data_type,\n+                  GArrowCastOptions *options,\n+                  GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  auto arrow_target_data_type = garrow_data_type_get_raw(target_data_type);\n+  std::shared_ptr<arrow::Array> arrow_casted_array;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_cast_options_get_raw(options);\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  *arrow_options,\n+                                  &arrow_casted_array);\n+  } else {\n+    arrow::compute::CastOptions arrow_options;\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  arrow_options,\n+                                  &arrow_casted_array);\n+  }\n+\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][cast] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \"> -> <\";\n+    message << arrow_target_data_type->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_casted_array);\n+}\n+\n+/**\n+ * garrow_array_unique:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created unique elements array on success, %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowArray *\n+garrow_array_unique(GArrowArray *array,\n+                    GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  std::shared_ptr<arrow::Array> arrow_unique_array;\n+  auto status = arrow::compute::Unique(&context,\n+                                       arrow::compute::Datum(arrow_array),\n+                                       &arrow_unique_array);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][unique] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_unique_array);\n+}\n+\n+/**\n+ * garrow_array_dictionary_encode:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created #GArrowDictionaryArray for the @array on success,\n+ *   %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowDictionaryArray *\n+garrow_array_dictionary_encode(GArrowArray *array,\n+                               GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum dictionary_encoded_datum;\n+  auto status =\n+    arrow::compute::DictionaryEncode(&context,\n+                                     arrow::compute::Datum(arrow_array),\n+                                     &dictionary_encoded_datum);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][dictionary-encode] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  auto arrow_dictionary_encoded_array =\n+    arrow::MakeArray(dictionary_encoded_datum.array());\n+  auto dictionary_encoded_array =\n+    garrow_array_new_raw(&arrow_dictionary_encoded_array);\n+  return GARROW_DICTIONARY_ARRAY(dictionary_encoded_array);\n+}\n+\n+/**\n+ * garrow_array_count:\n+ * @array: A #GArrowArray.\n+ * @options: (nullable): A #GArrowCountOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: The number of target values on success. If an error is occurred,\n+ *   the returned value is untrustful value.\n+ *\n+ * Since: 0.13.0\n+ */\n+gint64\n+garrow_array_count(GArrowArray *array,\n+                   GArrowCountOptions *options,\n+                   GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum counted_datum;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_count_options_get_raw(options);\n+    status = arrow::compute::Count(&context,\n+                                   *arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  } else {\n+    arrow::compute::CountOptions arrow_options(arrow::compute::CountOptions::COUNT_ALL);\n+    status = arrow::compute::Count(&context,\n+                                   arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  }\n+\n+  if (garrow_error_check(error, status, \"[array][count]\")) {\n+    using ScalarType = typename arrow::TypeTraits<arrow::Int64Type>::ScalarType;\n+    auto counted_scalar = std::dynamic_pointer_cast<ScalarType>(counted_datum.scalar());\n+    return counted_scalar->value;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+/**\n+ * garrow_array_count_values:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A #GArrowStructArray of `{input type \"values\", int64_t \"counts\"}`\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.13.0\n+ */\n+GArrowStructArray *\n+garrow_array_count_values(GArrowArray *array,\n \n Review comment:\n   I understand.\r\n   \r\n   Then I have another question.  Red arrow can have pandas compatible API?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-18T07:39:21.350+0000",
                    "updated": "2019-03-18T07:39:21.350+0000",
                    "started": "2019-03-18T07:39:21.350+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214619",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214620",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941#discussion_r266319808\n \n \n\n ##########\n File path: c_glib/arrow-glib/compute.cpp\n ##########\n @@ -295,6 +328,581 @@ garrow_count_options_new(void)\n   return GARROW_COUNT_OPTIONS(count_options);\n }\n \n+\n+/**\n+ * garrow_array_cast:\n+ * @array: A #GArrowArray.\n+ * @target_data_type: A #GArrowDataType of cast target data.\n+ * @options: (nullable): A #GArrowCastOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created casted array on success, %NULL on error.\n+ *\n+ * Since: 0.7.0\n+ */\n+GArrowArray *\n+garrow_array_cast(GArrowArray *array,\n+                  GArrowDataType *target_data_type,\n+                  GArrowCastOptions *options,\n+                  GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  auto arrow_target_data_type = garrow_data_type_get_raw(target_data_type);\n+  std::shared_ptr<arrow::Array> arrow_casted_array;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_cast_options_get_raw(options);\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  *arrow_options,\n+                                  &arrow_casted_array);\n+  } else {\n+    arrow::compute::CastOptions arrow_options;\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  arrow_options,\n+                                  &arrow_casted_array);\n+  }\n+\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][cast] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \"> -> <\";\n+    message << arrow_target_data_type->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_casted_array);\n+}\n+\n+/**\n+ * garrow_array_unique:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created unique elements array on success, %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowArray *\n+garrow_array_unique(GArrowArray *array,\n+                    GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  std::shared_ptr<arrow::Array> arrow_unique_array;\n+  auto status = arrow::compute::Unique(&context,\n+                                       arrow::compute::Datum(arrow_array),\n+                                       &arrow_unique_array);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][unique] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_unique_array);\n+}\n+\n+/**\n+ * garrow_array_dictionary_encode:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created #GArrowDictionaryArray for the @array on success,\n+ *   %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowDictionaryArray *\n+garrow_array_dictionary_encode(GArrowArray *array,\n+                               GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum dictionary_encoded_datum;\n+  auto status =\n+    arrow::compute::DictionaryEncode(&context,\n+                                     arrow::compute::Datum(arrow_array),\n+                                     &dictionary_encoded_datum);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][dictionary-encode] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  auto arrow_dictionary_encoded_array =\n+    arrow::MakeArray(dictionary_encoded_datum.array());\n+  auto dictionary_encoded_array =\n+    garrow_array_new_raw(&arrow_dictionary_encoded_array);\n+  return GARROW_DICTIONARY_ARRAY(dictionary_encoded_array);\n+}\n+\n+/**\n+ * garrow_array_count:\n+ * @array: A #GArrowArray.\n+ * @options: (nullable): A #GArrowCountOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: The number of target values on success. If an error is occurred,\n+ *   the returned value is untrustful value.\n+ *\n+ * Since: 0.13.0\n+ */\n+gint64\n+garrow_array_count(GArrowArray *array,\n+                   GArrowCountOptions *options,\n+                   GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum counted_datum;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_count_options_get_raw(options);\n+    status = arrow::compute::Count(&context,\n+                                   *arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  } else {\n+    arrow::compute::CountOptions arrow_options(arrow::compute::CountOptions::COUNT_ALL);\n+    status = arrow::compute::Count(&context,\n+                                   arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  }\n+\n+  if (garrow_error_check(error, status, \"[array][count]\")) {\n+    using ScalarType = typename arrow::TypeTraits<arrow::Int64Type>::ScalarType;\n+    auto counted_scalar = std::dynamic_pointer_cast<ScalarType>(counted_datum.scalar());\n+    return counted_scalar->value;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+/**\n+ * garrow_array_count_values:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A #GArrowStructArray of `{input type \"values\", int64_t \"counts\"}`\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.13.0\n+ */\n+GArrowStructArray *\n+garrow_array_count_values(GArrowArray *array,\n \n Review comment:\n   If someone wants pandas compatible API, we can just provide an alias as pandas compatible layer.\r\n   I think that we provide consistent API than pandas compatible API.\r\n   R uses `table` for the feature. It's different with pandas.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-18T07:39:58.229+0000",
                    "updated": "2019-03-18T07:39:58.229+0000",
                    "started": "2019-03-18T07:39:58.229+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214620",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214621",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941#discussion_r266320893\n \n \n\n ##########\n File path: c_glib/arrow-glib/compute.cpp\n ##########\n @@ -295,6 +328,581 @@ garrow_count_options_new(void)\n   return GARROW_COUNT_OPTIONS(count_options);\n }\n \n+\n+/**\n+ * garrow_array_cast:\n+ * @array: A #GArrowArray.\n+ * @target_data_type: A #GArrowDataType of cast target data.\n+ * @options: (nullable): A #GArrowCastOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created casted array on success, %NULL on error.\n+ *\n+ * Since: 0.7.0\n+ */\n+GArrowArray *\n+garrow_array_cast(GArrowArray *array,\n+                  GArrowDataType *target_data_type,\n+                  GArrowCastOptions *options,\n+                  GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  auto arrow_target_data_type = garrow_data_type_get_raw(target_data_type);\n+  std::shared_ptr<arrow::Array> arrow_casted_array;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_cast_options_get_raw(options);\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  *arrow_options,\n+                                  &arrow_casted_array);\n+  } else {\n+    arrow::compute::CastOptions arrow_options;\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  arrow_options,\n+                                  &arrow_casted_array);\n+  }\n+\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][cast] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \"> -> <\";\n+    message << arrow_target_data_type->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_casted_array);\n+}\n+\n+/**\n+ * garrow_array_unique:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created unique elements array on success, %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowArray *\n+garrow_array_unique(GArrowArray *array,\n+                    GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  std::shared_ptr<arrow::Array> arrow_unique_array;\n+  auto status = arrow::compute::Unique(&context,\n+                                       arrow::compute::Datum(arrow_array),\n+                                       &arrow_unique_array);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][unique] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_unique_array);\n+}\n+\n+/**\n+ * garrow_array_dictionary_encode:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created #GArrowDictionaryArray for the @array on success,\n+ *   %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowDictionaryArray *\n+garrow_array_dictionary_encode(GArrowArray *array,\n+                               GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum dictionary_encoded_datum;\n+  auto status =\n+    arrow::compute::DictionaryEncode(&context,\n+                                     arrow::compute::Datum(arrow_array),\n+                                     &dictionary_encoded_datum);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][dictionary-encode] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  auto arrow_dictionary_encoded_array =\n+    arrow::MakeArray(dictionary_encoded_datum.array());\n+  auto dictionary_encoded_array =\n+    garrow_array_new_raw(&arrow_dictionary_encoded_array);\n+  return GARROW_DICTIONARY_ARRAY(dictionary_encoded_array);\n+}\n+\n+/**\n+ * garrow_array_count:\n+ * @array: A #GArrowArray.\n+ * @options: (nullable): A #GArrowCountOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: The number of target values on success. If an error is occurred,\n+ *   the returned value is untrustful value.\n+ *\n+ * Since: 0.13.0\n+ */\n+gint64\n+garrow_array_count(GArrowArray *array,\n+                   GArrowCountOptions *options,\n+                   GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum counted_datum;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_count_options_get_raw(options);\n+    status = arrow::compute::Count(&context,\n+                                   *arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  } else {\n+    arrow::compute::CountOptions arrow_options(arrow::compute::CountOptions::COUNT_ALL);\n+    status = arrow::compute::Count(&context,\n+                                   arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  }\n+\n+  if (garrow_error_check(error, status, \"[array][count]\")) {\n+    using ScalarType = typename arrow::TypeTraits<arrow::Int64Type>::ScalarType;\n+    auto counted_scalar = std::dynamic_pointer_cast<ScalarType>(counted_datum.scalar());\n+    return counted_scalar->value;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+/**\n+ * garrow_array_count_values:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A #GArrowStructArray of `{input type \"values\", int64_t \"counts\"}`\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.13.0\n+ */\n+GArrowStructArray *\n+garrow_array_count_values(GArrowArray *array,\n \n Review comment:\n   Yes.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-18T07:40:56.882+0000",
                    "updated": "2019-03-18T07:40:56.882+0000",
                    "started": "2019-03-18T07:40:56.881+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214621",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214622",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mrkn commented on pull request #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941#discussion_r266321017\n \n \n\n ##########\n File path: c_glib/arrow-glib/compute.cpp\n ##########\n @@ -295,6 +328,581 @@ garrow_count_options_new(void)\n   return GARROW_COUNT_OPTIONS(count_options);\n }\n \n+\n+/**\n+ * garrow_array_cast:\n+ * @array: A #GArrowArray.\n+ * @target_data_type: A #GArrowDataType of cast target data.\n+ * @options: (nullable): A #GArrowCastOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created casted array on success, %NULL on error.\n+ *\n+ * Since: 0.7.0\n+ */\n+GArrowArray *\n+garrow_array_cast(GArrowArray *array,\n+                  GArrowDataType *target_data_type,\n+                  GArrowCastOptions *options,\n+                  GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  auto arrow_target_data_type = garrow_data_type_get_raw(target_data_type);\n+  std::shared_ptr<arrow::Array> arrow_casted_array;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_cast_options_get_raw(options);\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  *arrow_options,\n+                                  &arrow_casted_array);\n+  } else {\n+    arrow::compute::CastOptions arrow_options;\n+    status = arrow::compute::Cast(&context,\n+                                  *arrow_array_raw,\n+                                  arrow_target_data_type,\n+                                  arrow_options,\n+                                  &arrow_casted_array);\n+  }\n+\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][cast] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \"> -> <\";\n+    message << arrow_target_data_type->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_casted_array);\n+}\n+\n+/**\n+ * garrow_array_unique:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created unique elements array on success, %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowArray *\n+garrow_array_unique(GArrowArray *array,\n+                    GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  std::shared_ptr<arrow::Array> arrow_unique_array;\n+  auto status = arrow::compute::Unique(&context,\n+                                       arrow::compute::Datum(arrow_array),\n+                                       &arrow_unique_array);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][unique] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  return garrow_array_new_raw(&arrow_unique_array);\n+}\n+\n+/**\n+ * garrow_array_dictionary_encode:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A newly created #GArrowDictionaryArray for the @array on success,\n+ *   %NULL on error.\n+ *\n+ * Since: 0.8.0\n+ */\n+GArrowDictionaryArray *\n+garrow_array_dictionary_encode(GArrowArray *array,\n+                               GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum dictionary_encoded_datum;\n+  auto status =\n+    arrow::compute::DictionaryEncode(&context,\n+                                     arrow::compute::Datum(arrow_array),\n+                                     &dictionary_encoded_datum);\n+  if (!status.ok()) {\n+    std::stringstream message;\n+    message << \"[array][dictionary-encode] <\";\n+    message << arrow_array->type()->ToString();\n+    message << \">\";\n+    garrow_error_check(error, status, message.str().c_str());\n+    return NULL;\n+  }\n+\n+  auto arrow_dictionary_encoded_array =\n+    arrow::MakeArray(dictionary_encoded_datum.array());\n+  auto dictionary_encoded_array =\n+    garrow_array_new_raw(&arrow_dictionary_encoded_array);\n+  return GARROW_DICTIONARY_ARRAY(dictionary_encoded_array);\n+}\n+\n+/**\n+ * garrow_array_count:\n+ * @array: A #GArrowArray.\n+ * @options: (nullable): A #GArrowCountOptions.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: The number of target values on success. If an error is occurred,\n+ *   the returned value is untrustful value.\n+ *\n+ * Since: 0.13.0\n+ */\n+gint64\n+garrow_array_count(GArrowArray *array,\n+                   GArrowCountOptions *options,\n+                   GError **error)\n+{\n+  auto arrow_array = garrow_array_get_raw(array);\n+  auto arrow_array_raw = arrow_array.get();\n+  auto memory_pool = arrow::default_memory_pool();\n+  arrow::compute::FunctionContext context(memory_pool);\n+  arrow::compute::Datum counted_datum;\n+  arrow::Status status;\n+  if (options) {\n+    auto arrow_options = garrow_count_options_get_raw(options);\n+    status = arrow::compute::Count(&context,\n+                                   *arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  } else {\n+    arrow::compute::CountOptions arrow_options(arrow::compute::CountOptions::COUNT_ALL);\n+    status = arrow::compute::Count(&context,\n+                                   arrow_options,\n+                                   *arrow_array_raw,\n+                                   &counted_datum);\n+  }\n+\n+  if (garrow_error_check(error, status, \"[array][count]\")) {\n+    using ScalarType = typename arrow::TypeTraits<arrow::Int64Type>::ScalarType;\n+    auto counted_scalar = std::dynamic_pointer_cast<ScalarType>(counted_datum.scalar());\n+    return counted_scalar->value;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+/**\n+ * garrow_array_count_values:\n+ * @array: A #GArrowArray.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full):\n+ *   A #GArrowStructArray of `{input type \"values\", int64_t \"counts\"}`\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.13.0\n+ */\n+GArrowStructArray *\n+garrow_array_count_values(GArrowArray *array,\n \n Review comment:\n   OK. I'll make a pull-request.\r\n   Thank you very much!\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-18T07:41:26.929+0000",
                    "updated": "2019-03-18T07:41:26.929+0000",
                    "started": "2019-03-18T07:41:26.929+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214622",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214730",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941#issuecomment-473887548\n \n \n   I don't think it's important to follow pandas's names for things. We might rename the C++ API \"GetValueCounts\" or \"CountValues\"\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-18T12:21:21.155+0000",
                    "updated": "2019-03-18T12:21:21.155+0000",
                    "started": "2019-03-18T12:21:21.155+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214730",
                    "issueId": "13222110"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/worklog/214766",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mrkn commented on issue #3941: ARROW-4929: [GLib] Add garrow_array_count_values()\nURL: https://github.com/apache/arrow/pull/3941#issuecomment-473912778\n \n \n   @wesm This is good news for me.  I think it is much better if API names are consistent among each language.  If it is better to make method and function names verbs, would you please consider renaming C++ API to `CountValues` and letting other languages follow this change.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-03-18T13:37:16.941+0000",
                    "updated": "2019-03-18T13:37:16.941+0000",
                    "started": "2019-03-18T13:37:16.940+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "214766",
                    "issueId": "13222110"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 8400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@73a4bebc[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@654efec[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@301ecfa2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@11147dc2[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@fe7e8e8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@27b250d3[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6197e858[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@535f73c5[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@634f71ee[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@56ce919c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@8c56635[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@20acedb3[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 8400,
        "customfield_12312520": null,
        "customfield_12312521": "Sun Mar 17 23:40:04 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-03-17T23:40:04.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4929/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2019-03-16T23:01:12.000+0000",
        "updated": "2019-03-18T13:37:16.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 8400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[GLib] Add garrow_array_count_values()",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13222110/comment/16794615",
                    "id": "16794615",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=shiro615",
                        "name": "shiro615",
                        "key": "shiro615",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34043",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34043",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34043",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34043"
                        },
                        "displayName": "Yosuke Shiro",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 3941\n[https://github.com/apache/arrow/pull/3941]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=shiro615",
                        "name": "shiro615",
                        "key": "shiro615",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34043",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34043",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34043",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34043"
                        },
                        "displayName": "Yosuke Shiro",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2019-03-17T23:40:04.799+0000",
                    "updated": "2019-03-17T23:40:04.799+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z00s60:",
        "customfield_12314139": null
    }
}