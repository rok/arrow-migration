{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13337037",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037",
    "key": "ARROW-10381",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 6600,
            "total": 6600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 6600,
            "total": 6600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10381/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 11,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037/worklog/504472",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao opened a new pull request #8517:\nURL: https://github.com/apache/arrow/pull/8517\n\n\n   Currently, the code on `array/ord.rs` is centered around intra-array comparison. However, this does not allow to compare values from two different arrays, which is required on e.g. merge-sort operations.\r\n   \r\n   This PR:\r\n   * simplifies the code around `sort` by splitting it in smaller functions for ease of understanding (first 2 commits)\r\n   * adds a benchmark to the `sort` kernel which I used to verify that there was no performance regression  (3rd commit)\r\n   * simplifies and generalizes the code around `ord` to support comparisons between two arrays (that may be the same), 4th commit\r\n   * adds some more tests to edge cases around float comparison (nan and zeros)\r\n   \r\n   There was no performance change on my computer.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-24T16:41:49.813+0000",
                    "updated": "2020-10-24T16:41:49.813+0000",
                    "started": "2020-10-24T16:41:49.813+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "504472",
                    "issueId": "13337037"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037/worklog/504473",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on pull request #8517:\nURL: https://github.com/apache/arrow/pull/8517#issuecomment-715986049\n\n\n   FYI @andygrove @alamb : I planning to approach the MergeSort in DataFusion: my current idea is to merge-sort record-batches within a part and then merge-sort then again across partitions. This is preparatory work for that, as we can't merge sort two arrays together before this PR.\r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-24T16:46:24.168+0000",
                    "updated": "2020-10-24T16:46:24.168+0000",
                    "started": "2020-10-24T16:46:24.168+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "504473",
                    "issueId": "13337037"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037/worklog/504474",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8517:\nURL: https://github.com/apache/arrow/pull/8517#issuecomment-715988969\n\n\n   https://issues.apache.org/jira/browse/ARROW-10381\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-24T16:50:20.135+0000",
                    "updated": "2020-10-24T16:50:20.135+0000",
                    "started": "2020-10-24T16:50:20.135+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "504474",
                    "issueId": "13337037"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037/worklog/504476",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8517:\nURL: https://github.com/apache/arrow/pull/8517#discussion_r511491453\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/sort.rs\n##########\n@@ -453,49 +466,46 @@ pub fn lexsort(columns: &[SortColumn]) -> Result<Vec<ArrayRef>> {\n /// Sort elements lexicographically from a list of `ArrayRef` into an unsigned integer\n /// (`UInt32Array`) of indices.\n pub fn lexsort_to_indices(columns: &[SortColumn]) -> Result<UInt32Array> {\n+    if columns.len() == 0 {\n+        return Err(ArrowError::InvalidArgumentError(\n+            \"Sort requires at least one column\".to_string(),\n+        ));\n+    }\n     if columns.len() == 1 {\n         // fallback to non-lexical sort\n         let column = &columns[0];\n         return sort_to_indices(&column.values, column.options);\n     }\n \n-    let mut row_count = None;\n+    let row_count = columns[0].values.len();\n+    if columns.iter().any(|item| item.values.len() != row_count) {\n+        return Err(ArrowError::ComputeError(\n+            \"lexical sort columns have different row counts\".to_string(),\n+        ));\n+    };\n+\n     // convert ArrayRefs to OrdArray trait objects and perform row count check\n     let flat_columns = columns\n         .iter()\n-        .map(|column| -> Result<(&Array, Box<OrdArray>, SortOptions)> {\n-            // row count check\n-            let curr_row_count = column.values.len() - column.values.offset();\n-            match row_count {\n-                None => {\n-                    row_count = Some(curr_row_count);\n-                }\n-                Some(cnt) => {\n-                    if curr_row_count != cnt {\n-                        return Err(ArrowError::ComputeError(\n-                            \"lexical sort columns have different row counts\".to_string(),\n-                        ));\n-                    }\n-                }\n-            }\n-            // flatten and convert to OrdArray\n+        .map(|column| -> Result<(&Array, DynComparator, SortOptions)> {\n+            // flatten and convert build comparators\n             Ok((\n                 column.values.as_ref(),\n-                as_ordarray(&column.values)?,\n+                build_compare(column.values.as_ref(), column.values.as_ref())?,\n\nReview comment:\n       This is the main change: we no longer create an `OrdArray`. Instead, return a heap-allocated function (`DynComparator`) that can compare stuff.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-24T16:50:46.534+0000",
                    "updated": "2020-10-24T16:50:46.534+0000",
                    "started": "2020-10-24T16:50:46.534+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "504476",
                    "issueId": "13337037"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037/worklog/504478",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8517:\nURL: https://github.com/apache/arrow/pull/8517#discussion_r511491453\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/sort.rs\n##########\n@@ -453,49 +466,46 @@ pub fn lexsort(columns: &[SortColumn]) -> Result<Vec<ArrayRef>> {\n /// Sort elements lexicographically from a list of `ArrayRef` into an unsigned integer\n /// (`UInt32Array`) of indices.\n pub fn lexsort_to_indices(columns: &[SortColumn]) -> Result<UInt32Array> {\n+    if columns.len() == 0 {\n+        return Err(ArrowError::InvalidArgumentError(\n+            \"Sort requires at least one column\".to_string(),\n+        ));\n+    }\n     if columns.len() == 1 {\n         // fallback to non-lexical sort\n         let column = &columns[0];\n         return sort_to_indices(&column.values, column.options);\n     }\n \n-    let mut row_count = None;\n+    let row_count = columns[0].values.len();\n+    if columns.iter().any(|item| item.values.len() != row_count) {\n+        return Err(ArrowError::ComputeError(\n+            \"lexical sort columns have different row counts\".to_string(),\n+        ));\n+    };\n+\n     // convert ArrayRefs to OrdArray trait objects and perform row count check\n     let flat_columns = columns\n         .iter()\n-        .map(|column| -> Result<(&Array, Box<OrdArray>, SortOptions)> {\n-            // row count check\n-            let curr_row_count = column.values.len() - column.values.offset();\n-            match row_count {\n-                None => {\n-                    row_count = Some(curr_row_count);\n-                }\n-                Some(cnt) => {\n-                    if curr_row_count != cnt {\n-                        return Err(ArrowError::ComputeError(\n-                            \"lexical sort columns have different row counts\".to_string(),\n-                        ));\n-                    }\n-                }\n-            }\n-            // flatten and convert to OrdArray\n+        .map(|column| -> Result<(&Array, DynComparator, SortOptions)> {\n+            // flatten and convert build comparators\n             Ok((\n                 column.values.as_ref(),\n-                as_ordarray(&column.values)?,\n+                build_compare(column.values.as_ref(), column.values.as_ref())?,\n\nReview comment:\n       This is the main change: we no longer create an `OrdArray`. Instead, return a heap-allocated function (`DynComparator`) that can compare values.\r\n   \r\n   In this case we pass the same array on the left and right side, but it works more generally (with different arrays), which is the necessary interface we need to merge-sort arrays.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-24T16:51:53.117+0000",
                    "updated": "2020-10-24T16:51:53.117+0000",
                    "started": "2020-10-24T16:51:53.117+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "504478",
                    "issueId": "13337037"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037/worklog/504484",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #8517:\nURL: https://github.com/apache/arrow/pull/8517#issuecomment-716031171\n\n\n   @jorgecarleitao this sounds good. I am going to make time tomorrow to catch up on the current PRs.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-24T17:54:39.320+0000",
                    "updated": "2020-10-24T17:54:39.320+0000",
                    "started": "2020-10-24T17:54:39.319+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "504484",
                    "issueId": "13337037"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037/worklog/504595",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8517:\nURL: https://github.com/apache/arrow/pull/8517#discussion_r511642958\n\n\n\n##########\nFile path: rust/arrow/src/array/ord.rs\n##########\n@@ -15,297 +15,280 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-//! Defines trait for array element comparison\n+//! Contains functions and function factories to compare arrays.\n \n use std::cmp::Ordering;\n \n use crate::array::*;\n+use crate::datatypes::TimeUnit;\n use crate::datatypes::*;\n use crate::error::{ArrowError, Result};\n \n-use TimeUnit::*;\n+use num::Float;\n \n-/// Trait for Arrays that can be sorted\n-///\n-/// Example:\n-/// ```\n-/// use std::cmp::Ordering;\n-/// use arrow::array::*;\n-/// use arrow::datatypes::*;\n-///\n-/// let arr: Box<dyn OrdArray> = Box::new(PrimitiveArray::<Int64Type>::from(vec![\n-///     Some(-2),\n-///     Some(89),\n-///     Some(-64),\n-///     Some(101),\n-/// ]));\n-///\n-/// assert_eq!(arr.cmp_value(1, 2), Ordering::Greater);\n-/// ```\n-pub trait OrdArray {\n-    /// Return ordering between array element at index i and j\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering;\n-}\n+/// The public interface to compare values from arrays in a dynamically-typed fashion.\n+pub type DynComparator<'a> = Box<dyn Fn(usize, usize) -> Ordering + 'a>;\n \n-impl<T: OrdArray> OrdArray for Box<T> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n+/// compares two floats, placing NaNs at last\n+fn cmp_nans_last<T: Float>(a: &T, b: &T) -> Ordering {\n+    match (a, b) {\n+        (x, y) if x.is_nan() && y.is_nan() => Ordering::Equal,\n+        (x, _) if x.is_nan() => Ordering::Greater,\n+        (_, y) if y.is_nan() => Ordering::Less,\n+        (_, _) => a.partial_cmp(b).unwrap(),\n     }\n }\n \n-impl<T: OrdArray> OrdArray for &T {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n-    }\n+fn compare_primitives<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n+where\n+    T::Native: Ord,\n+{\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl<T: ArrowPrimitiveType> OrdArray for PrimitiveArray<T>\n+fn compare_float<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n where\n-    T::Native: std::cmp::Ord,\n+    T::Native: Float,\n {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(&self.value(j))\n-    }\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| cmp_nans_last(&left.value(i), &right.value(j)))\n }\n \n-impl OrdArray for StringArray {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(self.value(j))\n-    }\n+fn compare_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: StringOffsetSizeTrait,\n+{\n+    let left = left\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    let right = right\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl OrdArray for NullArray {\n-    fn cmp_value(&self, _i: usize, _j: usize) -> Ordering {\n-        Ordering::Equal\n-    }\n+fn compare_dict_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: ArrowDictionaryKeyType,\n+{\n+    let left = left.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let left_keys = left.keys_array();\n+    let right_keys = right.keys_array();\n+\n+    let left_values = StringArray::from(left.values().data());\n+    let right_values = StringArray::from(left.values().data());\n+\n+    Box::new(move |i: usize, j: usize| {\n+        let key_left = left_keys.value(i).to_usize().unwrap();\n+        let key_right = right_keys.value(j).to_usize().unwrap();\n+        let left = left_values.value(key_left);\n+        let right = right_values.value(key_right);\n+        left.cmp(&right)\n+    })\n }\n \n-macro_rules! float_ord_cmp {\n-    ($NAME: ident, $T: ty) => {\n-        #[inline]\n-        fn $NAME(a: $T, b: $T) -> Ordering {\n-            if a < b {\n-                return Ordering::Less;\n-            }\n-            if a > b {\n-                return Ordering::Greater;\n+/// returns a comparison function that compares two values at two different positions\n+/// between the two arrays.\n+/// The arrays' types must be equal.\n+/// # Example\n+/// ```\n+/// use arrow::array::{build_compare, Int32Array};\n+///\n+/// # fn main() -> arrow::error::Result<()> {\n+/// let array1 = Int32Array::from(vec![1, 2]);\n+/// let array2 = Int32Array::from(vec![3, 4]);\n+///\n+/// let cmp = build_compare(&array1, &array2)?;\n+///\n+/// // 1 (index 0 of array1) is smaller than 4 (index 1 of array2)\n+/// assert_eq!(std::cmp::Ordering::Less, (cmp)(0, 1));\n+/// # Ok(())\n+/// # }\n+/// ```\n+// This is a factory of comparisons.\n+// The lifetime 'a enforces that we cannot use the closure beyond any of the array's lifetime.\n+pub fn build_compare<'a>(left: &'a Array, right: &'a Array) -> Result<DynComparator<'a>> {\n+    use DataType::*;\n+    use IntervalUnit::*;\n+    use TimeUnit::*;\n+    Ok(match (left.data_type(), right.data_type()) {\n+        (a, b) if a != b => {\n+            return Err(ArrowError::InvalidArgumentError(\n+                \"Can't compare arrays of different types\".to_string(),\n+            ));\n+        }\n+        (Boolean, Boolean) => compare_primitives::<BooleanType>(left, right),\n+        (UInt8, UInt8) => compare_primitives::<UInt8Type>(left, right),\n+        (UInt16, UInt16) => compare_primitives::<UInt16Type>(left, right),\n+        (UInt32, UInt32) => compare_primitives::<UInt32Type>(left, right),\n+        (UInt64, UInt64) => compare_primitives::<UInt64Type>(left, right),\n+        (Int8, Int8) => compare_primitives::<Int8Type>(left, right),\n+        (Int16, Int16) => compare_primitives::<Int16Type>(left, right),\n+        (Int32, Int32) => compare_primitives::<Int32Type>(left, right),\n+        (Int64, Int64) => compare_primitives::<Int64Type>(left, right),\n+        (Float32, Float32) => compare_float::<Float32Type>(left, right),\n+        (Float64, Float64) => compare_float::<Float64Type>(left, right),\n+        (Date32(_), Date32(_)) => compare_primitives::<Date32Type>(left, right),\n+        (Date64(_), Date64(_)) => compare_primitives::<Date64Type>(left, right),\n+        (Time32(Second), Time32(Second)) => {\n+            compare_primitives::<Time32SecondType>(left, right)\n+        }\n+        (Time32(Millisecond), Time32(Millisecond)) => {\n+            compare_primitives::<Time32MillisecondType>(left, right)\n+        }\n+        (Time64(Microsecond), Time64(Microsecond)) => {\n+            compare_primitives::<Time64MicrosecondType>(left, right)\n+        }\n+        (Time64(Nanosecond), Time64(Nanosecond)) => {\n+            compare_primitives::<Time64NanosecondType>(left, right)\n+        }\n+        (Timestamp(Second, _), Timestamp(Second, _)) => {\n+            compare_primitives::<TimestampSecondType>(left, right)\n+        }\n+        (Timestamp(Millisecond, _), Timestamp(Millisecond, _)) => {\n+            compare_primitives::<TimestampMillisecondType>(left, right)\n+        }\n+        (Timestamp(Microsecond, _), Timestamp(Microsecond, _)) => {\n+            compare_primitives::<TimestampMicrosecondType>(left, right)\n+        }\n+        (Timestamp(Nanosecond, _), Timestamp(Nanosecond, _)) => {\n+            compare_primitives::<TimestampNanosecondType>(left, right)\n+        }\n+        (Interval(YearMonth), Interval(YearMonth)) => {\n+            compare_primitives::<IntervalYearMonthType>(left, right)\n+        }\n+        (Interval(DayTime), Interval(DayTime)) => {\n+            compare_primitives::<IntervalDayTimeType>(left, right)\n+        }\n+        (Duration(Second), Duration(Second)) => {\n+            compare_primitives::<DurationSecondType>(left, right)\n+        }\n+        (Duration(Millisecond), Duration(Millisecond)) => {\n+            compare_primitives::<DurationMillisecondType>(left, right)\n+        }\n+        (Duration(Microsecond), Duration(Microsecond)) => {\n+            compare_primitives::<DurationMicrosecondType>(left, right)\n+        }\n+        (Duration(Nanosecond), Duration(Nanosecond)) => {\n+            compare_primitives::<DurationNanosecondType>(left, right)\n+        }\n+        (Utf8, Utf8) => compare_string::<i32>(left, right),\n+        (LargeUtf8, LargeUtf8) => compare_string::<i64>(left, right),\n+        (\n+            Dictionary(key_type_lhs, value_type_lhs),\n+            Dictionary(key_type_rhs, value_type_rhs),\n+        ) => {\n+            if value_type_lhs.as_ref() != &DataType::Utf8\n+                || value_type_rhs.as_ref() != &DataType::Utf8\n+            {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Arrow still does not support comparisons of non-string dictionary arrays\"\n\nReview comment:\n       Would we incur a high cost if we cast dictionaries to primitives, then compared the primitives?\n\n##########\nFile path: rust/arrow/src/array/ord.rs\n##########\n@@ -15,297 +15,280 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-//! Defines trait for array element comparison\n+//! Contains functions and function factories to compare arrays.\n \n use std::cmp::Ordering;\n \n use crate::array::*;\n+use crate::datatypes::TimeUnit;\n use crate::datatypes::*;\n use crate::error::{ArrowError, Result};\n \n-use TimeUnit::*;\n+use num::Float;\n \n-/// Trait for Arrays that can be sorted\n-///\n-/// Example:\n-/// ```\n-/// use std::cmp::Ordering;\n-/// use arrow::array::*;\n-/// use arrow::datatypes::*;\n-///\n-/// let arr: Box<dyn OrdArray> = Box::new(PrimitiveArray::<Int64Type>::from(vec![\n-///     Some(-2),\n-///     Some(89),\n-///     Some(-64),\n-///     Some(101),\n-/// ]));\n-///\n-/// assert_eq!(arr.cmp_value(1, 2), Ordering::Greater);\n-/// ```\n-pub trait OrdArray {\n-    /// Return ordering between array element at index i and j\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering;\n-}\n+/// The public interface to compare values from arrays in a dynamically-typed fashion.\n+pub type DynComparator<'a> = Box<dyn Fn(usize, usize) -> Ordering + 'a>;\n \n-impl<T: OrdArray> OrdArray for Box<T> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n+/// compares two floats, placing NaNs at last\n+fn cmp_nans_last<T: Float>(a: &T, b: &T) -> Ordering {\n+    match (a, b) {\n+        (x, y) if x.is_nan() && y.is_nan() => Ordering::Equal,\n+        (x, _) if x.is_nan() => Ordering::Greater,\n+        (_, y) if y.is_nan() => Ordering::Less,\n+        (_, _) => a.partial_cmp(b).unwrap(),\n     }\n }\n \n-impl<T: OrdArray> OrdArray for &T {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n-    }\n+fn compare_primitives<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n+where\n+    T::Native: Ord,\n+{\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl<T: ArrowPrimitiveType> OrdArray for PrimitiveArray<T>\n+fn compare_float<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n where\n-    T::Native: std::cmp::Ord,\n+    T::Native: Float,\n {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(&self.value(j))\n-    }\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| cmp_nans_last(&left.value(i), &right.value(j)))\n }\n \n-impl OrdArray for StringArray {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(self.value(j))\n-    }\n+fn compare_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: StringOffsetSizeTrait,\n+{\n+    let left = left\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    let right = right\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl OrdArray for NullArray {\n-    fn cmp_value(&self, _i: usize, _j: usize) -> Ordering {\n-        Ordering::Equal\n-    }\n+fn compare_dict_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: ArrowDictionaryKeyType,\n+{\n+    let left = left.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let left_keys = left.keys_array();\n+    let right_keys = right.keys_array();\n+\n+    let left_values = StringArray::from(left.values().data());\n+    let right_values = StringArray::from(left.values().data());\n+\n+    Box::new(move |i: usize, j: usize| {\n+        let key_left = left_keys.value(i).to_usize().unwrap();\n+        let key_right = right_keys.value(j).to_usize().unwrap();\n+        let left = left_values.value(key_left);\n+        let right = right_values.value(key_right);\n+        left.cmp(&right)\n+    })\n }\n \n-macro_rules! float_ord_cmp {\n-    ($NAME: ident, $T: ty) => {\n-        #[inline]\n-        fn $NAME(a: $T, b: $T) -> Ordering {\n-            if a < b {\n-                return Ordering::Less;\n-            }\n-            if a > b {\n-                return Ordering::Greater;\n+/// returns a comparison function that compares two values at two different positions\n+/// between the two arrays.\n+/// The arrays' types must be equal.\n+/// # Example\n+/// ```\n+/// use arrow::array::{build_compare, Int32Array};\n+///\n+/// # fn main() -> arrow::error::Result<()> {\n+/// let array1 = Int32Array::from(vec![1, 2]);\n+/// let array2 = Int32Array::from(vec![3, 4]);\n+///\n+/// let cmp = build_compare(&array1, &array2)?;\n+///\n+/// // 1 (index 0 of array1) is smaller than 4 (index 1 of array2)\n+/// assert_eq!(std::cmp::Ordering::Less, (cmp)(0, 1));\n+/// # Ok(())\n+/// # }\n+/// ```\n+// This is a factory of comparisons.\n+// The lifetime 'a enforces that we cannot use the closure beyond any of the array's lifetime.\n+pub fn build_compare<'a>(left: &'a Array, right: &'a Array) -> Result<DynComparator<'a>> {\n+    use DataType::*;\n+    use IntervalUnit::*;\n+    use TimeUnit::*;\n+    Ok(match (left.data_type(), right.data_type()) {\n+        (a, b) if a != b => {\n+            return Err(ArrowError::InvalidArgumentError(\n+                \"Can't compare arrays of different types\".to_string(),\n+            ));\n+        }\n+        (Boolean, Boolean) => compare_primitives::<BooleanType>(left, right),\n+        (UInt8, UInt8) => compare_primitives::<UInt8Type>(left, right),\n+        (UInt16, UInt16) => compare_primitives::<UInt16Type>(left, right),\n+        (UInt32, UInt32) => compare_primitives::<UInt32Type>(left, right),\n+        (UInt64, UInt64) => compare_primitives::<UInt64Type>(left, right),\n+        (Int8, Int8) => compare_primitives::<Int8Type>(left, right),\n+        (Int16, Int16) => compare_primitives::<Int16Type>(left, right),\n+        (Int32, Int32) => compare_primitives::<Int32Type>(left, right),\n+        (Int64, Int64) => compare_primitives::<Int64Type>(left, right),\n+        (Float32, Float32) => compare_float::<Float32Type>(left, right),\n+        (Float64, Float64) => compare_float::<Float64Type>(left, right),\n+        (Date32(_), Date32(_)) => compare_primitives::<Date32Type>(left, right),\n+        (Date64(_), Date64(_)) => compare_primitives::<Date64Type>(left, right),\n+        (Time32(Second), Time32(Second)) => {\n+            compare_primitives::<Time32SecondType>(left, right)\n+        }\n+        (Time32(Millisecond), Time32(Millisecond)) => {\n+            compare_primitives::<Time32MillisecondType>(left, right)\n+        }\n+        (Time64(Microsecond), Time64(Microsecond)) => {\n+            compare_primitives::<Time64MicrosecondType>(left, right)\n+        }\n+        (Time64(Nanosecond), Time64(Nanosecond)) => {\n+            compare_primitives::<Time64NanosecondType>(left, right)\n+        }\n+        (Timestamp(Second, _), Timestamp(Second, _)) => {\n+            compare_primitives::<TimestampSecondType>(left, right)\n+        }\n+        (Timestamp(Millisecond, _), Timestamp(Millisecond, _)) => {\n+            compare_primitives::<TimestampMillisecondType>(left, right)\n+        }\n+        (Timestamp(Microsecond, _), Timestamp(Microsecond, _)) => {\n+            compare_primitives::<TimestampMicrosecondType>(left, right)\n+        }\n+        (Timestamp(Nanosecond, _), Timestamp(Nanosecond, _)) => {\n+            compare_primitives::<TimestampNanosecondType>(left, right)\n+        }\n+        (Interval(YearMonth), Interval(YearMonth)) => {\n+            compare_primitives::<IntervalYearMonthType>(left, right)\n+        }\n+        (Interval(DayTime), Interval(DayTime)) => {\n+            compare_primitives::<IntervalDayTimeType>(left, right)\n+        }\n+        (Duration(Second), Duration(Second)) => {\n+            compare_primitives::<DurationSecondType>(left, right)\n+        }\n+        (Duration(Millisecond), Duration(Millisecond)) => {\n+            compare_primitives::<DurationMillisecondType>(left, right)\n+        }\n+        (Duration(Microsecond), Duration(Microsecond)) => {\n+            compare_primitives::<DurationMicrosecondType>(left, right)\n+        }\n+        (Duration(Nanosecond), Duration(Nanosecond)) => {\n+            compare_primitives::<DurationNanosecondType>(left, right)\n+        }\n+        (Utf8, Utf8) => compare_string::<i32>(left, right),\n+        (LargeUtf8, LargeUtf8) => compare_string::<i64>(left, right),\n+        (\n+            Dictionary(key_type_lhs, value_type_lhs),\n+            Dictionary(key_type_rhs, value_type_rhs),\n+        ) => {\n+            if value_type_lhs.as_ref() != &DataType::Utf8\n+                || value_type_rhs.as_ref() != &DataType::Utf8\n+            {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Arrow still does not support comparisons of non-string dictionary arrays\"\n+                        .to_string(),\n+                ));\n             }\n-\n-            // convert to bits with canonical pattern for NaN\n-            let a = if a.is_nan() {\n-                <$T>::NAN.to_bits()\n-            } else {\n-                a.to_bits()\n-            };\n-            let b = if b.is_nan() {\n-                <$T>::NAN.to_bits()\n-            } else {\n-                b.to_bits()\n-            };\n-\n-            if a == b {\n-                // Equal or both NaN\n-                Ordering::Equal\n-            } else if a < b {\n-                // (-0.0, 0.0) or (!NaN, NaN)\n-                Ordering::Less\n-            } else {\n-                // (0.0, -0.0) or (NaN, !NaN)\n-                Ordering::Greater\n+            match (key_type_lhs.as_ref(), key_type_rhs.as_ref()) {\n+                (a, b) if a != b => {\n+                    return Err(ArrowError::InvalidArgumentError(\n+                        \"Can't compare arrays of different types\".to_string(),\n+                    ));\n+                }\n+                (UInt8, UInt8) => compare_dict_string::<UInt8Type>(left, right),\n+                (UInt16, UInt16) => compare_dict_string::<UInt16Type>(left, right),\n+                (UInt32, UInt32) => compare_dict_string::<UInt32Type>(left, right),\n+                (UInt64, UInt64) => compare_dict_string::<UInt64Type>(left, right),\n+                (Int8, Int8) => compare_dict_string::<Int8Type>(left, right),\n+                (Int16, Int16) => compare_dict_string::<Int16Type>(left, right),\n+                (Int32, Int32) => compare_dict_string::<Int32Type>(left, right),\n+                (Int64, Int64) => compare_dict_string::<Int64Type>(left, right),\n+                _ => todo!(),\n             }\n         }\n-    };\n+        _ => todo!(),\n\nReview comment:\n       We can add a helpful err instead of panicking\n\n##########\nFile path: rust/arrow/src/compute/kernels/sort.rs\n##########\n@@ -453,49 +466,46 @@ pub fn lexsort(columns: &[SortColumn]) -> Result<Vec<ArrayRef>> {\n /// Sort elements lexicographically from a list of `ArrayRef` into an unsigned integer\n /// (`UInt32Array`) of indices.\n pub fn lexsort_to_indices(columns: &[SortColumn]) -> Result<UInt32Array> {\n+    if columns.len() == 0 {\n+        return Err(ArrowError::InvalidArgumentError(\n+            \"Sort requires at least one column\".to_string(),\n+        ));\n+    }\n     if columns.len() == 1 {\n         // fallback to non-lexical sort\n         let column = &columns[0];\n         return sort_to_indices(&column.values, column.options);\n     }\n \n-    let mut row_count = None;\n+    let row_count = columns[0].values.len();\n+    if columns.iter().any(|item| item.values.len() != row_count) {\n+        return Err(ArrowError::ComputeError(\n+            \"lexical sort columns have different row counts\".to_string(),\n+        ));\n+    };\n+\n     // convert ArrayRefs to OrdArray trait objects and perform row count check\n     let flat_columns = columns\n         .iter()\n-        .map(|column| -> Result<(&Array, Box<OrdArray>, SortOptions)> {\n-            // row count check\n-            let curr_row_count = column.values.len() - column.values.offset();\n-            match row_count {\n-                None => {\n-                    row_count = Some(curr_row_count);\n-                }\n-                Some(cnt) => {\n-                    if curr_row_count != cnt {\n-                        return Err(ArrowError::ComputeError(\n-                            \"lexical sort columns have different row counts\".to_string(),\n-                        ));\n-                    }\n-                }\n-            }\n-            // flatten and convert to OrdArray\n+        .map(|column| -> Result<(&Array, DynComparator, SortOptions)> {\n+            // flatten and convert build comparators\n             Ok((\n                 column.values.as_ref(),\n-                as_ordarray(&column.values)?,\n+                build_compare(column.values.as_ref(), column.values.as_ref())?,\n\nReview comment:\n       I'm happy with this approach, very creative\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-25T20:22:01.529+0000",
                    "updated": "2020-10-25T20:22:01.529+0000",
                    "started": "2020-10-25T20:22:01.529+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "504595",
                    "issueId": "13337037"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037/worklog/504688",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8517:\nURL: https://github.com/apache/arrow/pull/8517#discussion_r511896397\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/sort.rs\n##########\n@@ -41,110 +41,123 @@ pub fn sort(values: &ArrayRef, options: Option<SortOptions>) -> Result<ArrayRef>\n     take(values, &indices, None)\n }\n \n+fn partition_nan<T: ArrowPrimitiveType>(\n+    array: &ArrayRef,\n+    v: Vec<u32>,\n+) -> (Vec<u32>, Vec<u32>) {\n+    // partition by nan for float types\n+    if T::DATA_TYPE == DataType::Float32 {\n+        // T::Native has no `is_nan` and thus we need to downcast\n+        let array = array\n+            .as_any()\n+            .downcast_ref::<Float32Array>()\n+            .expect(\"Unable to downcast array\");\n+        let has_nan = v.iter().any(|index| array.value(*index as usize).is_nan());\n\nReview comment:\n       A minor comment is that you might be able  to make the code smaller (avoid scanning the array twice) if we don't bother to check for `has_nan`-- and just always do `v.into_iter().partition(....)`.  The rationale is if `has_nan` is false, you had to scan the entire array anyways.\r\n   \r\n   I have not tested my statement, and it is based on assumptions of the compiler being clever about optimizing `into_iter()` \r\n   \n\n##########\nFile path: rust/arrow/src/compute/kernels/sort.rs\n##########\n@@ -41,110 +41,123 @@ pub fn sort(values: &ArrayRef, options: Option<SortOptions>) -> Result<ArrayRef>\n     take(values, &indices, None)\n }\n \n+fn partition_nan<T: ArrowPrimitiveType>(\n\nReview comment:\n       Suggest add comments:\r\n   \r\n   ```\r\n       // partition indices into non-NaN and NaN\r\n   ```\n\n##########\nFile path: rust/arrow/src/compute/kernels/sort.rs\n##########\n@@ -41,110 +41,123 @@ pub fn sort(values: &ArrayRef, options: Option<SortOptions>) -> Result<ArrayRef>\n     take(values, &indices, None)\n }\n \n+fn partition_nan<T: ArrowPrimitiveType>(\n+    array: &ArrayRef,\n+    v: Vec<u32>,\n+) -> (Vec<u32>, Vec<u32>) {\n+    // partition by nan for float types\n+    if T::DATA_TYPE == DataType::Float32 {\n+        // T::Native has no `is_nan` and thus we need to downcast\n+        let array = array\n+            .as_any()\n+            .downcast_ref::<Float32Array>()\n+            .expect(\"Unable to downcast array\");\n+        let has_nan = v.iter().any(|index| array.value(*index as usize).is_nan());\n+        if has_nan {\n+            v.into_iter()\n+                .partition(|index| !array.value(*index as usize).is_nan())\n+        } else {\n+            (v, vec![])\n+        }\n+    } else if T::DATA_TYPE == DataType::Float64 {\n+        let array = array\n+            .as_any()\n+            .downcast_ref::<Float64Array>()\n+            .expect(\"Unable to downcast array\");\n+        let has_nan = v.iter().any(|index| array.value(*index as usize).is_nan());\n+        if has_nan {\n+            v.into_iter()\n+                .partition(|index| !array.value(*index as usize).is_nan())\n+        } else {\n+            (v, vec![])\n+        }\n+    } else {\n+        unreachable!(\"Partition by nan is only applicable to float types\")\n+    }\n+}\n+\n+fn partition_validity(array: &ArrayRef) -> (Vec<u32>, Vec<u32>) {\n\nReview comment:\n       ```\r\n       // partition indices into valid and null indices\r\n   ```\n\n##########\nFile path: rust/arrow/src/array/ord.rs\n##########\n@@ -15,297 +15,259 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-//! Defines trait for array element comparison\n+//! Contains functions and function factories to compare arrays.\n \n use std::cmp::Ordering;\n \n use crate::array::*;\n+use crate::datatypes::TimeUnit;\n use crate::datatypes::*;\n use crate::error::{ArrowError, Result};\n \n-use TimeUnit::*;\n+use num::Float;\n \n-/// Trait for Arrays that can be sorted\n-///\n-/// Example:\n-/// ```\n-/// use std::cmp::Ordering;\n-/// use arrow::array::*;\n-/// use arrow::datatypes::*;\n-///\n-/// let arr: Box<dyn OrdArray> = Box::new(PrimitiveArray::<Int64Type>::from(vec![\n-///     Some(-2),\n-///     Some(89),\n-///     Some(-64),\n-///     Some(101),\n-/// ]));\n-///\n-/// assert_eq!(arr.cmp_value(1, 2), Ordering::Greater);\n-/// ```\n-pub trait OrdArray {\n-    /// Return ordering between array element at index i and j\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering;\n-}\n+/// The public interface to compare values from arrays in a dynamically-typed fashion.\n+pub type DynComparator<'a> = Box<dyn Fn(usize, usize) -> Ordering + 'a>;\n\nReview comment:\n       ```\r\n   /// Compare the values at two arbitrary indices in two arrays.\r\n   ```\n\n##########\nFile path: rust/arrow/src/array/ord.rs\n##########\n@@ -15,297 +15,280 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-//! Defines trait for array element comparison\n+//! Contains functions and function factories to compare arrays.\n \n use std::cmp::Ordering;\n \n use crate::array::*;\n+use crate::datatypes::TimeUnit;\n use crate::datatypes::*;\n use crate::error::{ArrowError, Result};\n \n-use TimeUnit::*;\n+use num::Float;\n \n-/// Trait for Arrays that can be sorted\n-///\n-/// Example:\n-/// ```\n-/// use std::cmp::Ordering;\n-/// use arrow::array::*;\n-/// use arrow::datatypes::*;\n-///\n-/// let arr: Box<dyn OrdArray> = Box::new(PrimitiveArray::<Int64Type>::from(vec![\n-///     Some(-2),\n-///     Some(89),\n-///     Some(-64),\n-///     Some(101),\n-/// ]));\n-///\n-/// assert_eq!(arr.cmp_value(1, 2), Ordering::Greater);\n-/// ```\n-pub trait OrdArray {\n-    /// Return ordering between array element at index i and j\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering;\n-}\n+/// The public interface to compare values from arrays in a dynamically-typed fashion.\n+pub type DynComparator<'a> = Box<dyn Fn(usize, usize) -> Ordering + 'a>;\n \n-impl<T: OrdArray> OrdArray for Box<T> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n+/// compares two floats, placing NaNs at last\n+fn cmp_nans_last<T: Float>(a: &T, b: &T) -> Ordering {\n+    match (a, b) {\n+        (x, y) if x.is_nan() && y.is_nan() => Ordering::Equal,\n+        (x, _) if x.is_nan() => Ordering::Greater,\n+        (_, y) if y.is_nan() => Ordering::Less,\n+        (_, _) => a.partial_cmp(b).unwrap(),\n     }\n }\n \n-impl<T: OrdArray> OrdArray for &T {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n-    }\n+fn compare_primitives<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n+where\n+    T::Native: Ord,\n+{\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl<T: ArrowPrimitiveType> OrdArray for PrimitiveArray<T>\n+fn compare_float<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n where\n-    T::Native: std::cmp::Ord,\n+    T::Native: Float,\n {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(&self.value(j))\n-    }\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| cmp_nans_last(&left.value(i), &right.value(j)))\n }\n \n-impl OrdArray for StringArray {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(self.value(j))\n-    }\n+fn compare_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: StringOffsetSizeTrait,\n+{\n+    let left = left\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    let right = right\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl OrdArray for NullArray {\n-    fn cmp_value(&self, _i: usize, _j: usize) -> Ordering {\n-        Ordering::Equal\n-    }\n+fn compare_dict_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: ArrowDictionaryKeyType,\n+{\n+    let left = left.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let left_keys = left.keys_array();\n+    let right_keys = right.keys_array();\n+\n+    let left_values = StringArray::from(left.values().data());\n+    let right_values = StringArray::from(left.values().data());\n+\n+    Box::new(move |i: usize, j: usize| {\n+        let key_left = left_keys.value(i).to_usize().unwrap();\n+        let key_right = right_keys.value(j).to_usize().unwrap();\n+        let left = left_values.value(key_left);\n+        let right = right_values.value(key_right);\n+        left.cmp(&right)\n+    })\n }\n \n-macro_rules! float_ord_cmp {\n-    ($NAME: ident, $T: ty) => {\n-        #[inline]\n-        fn $NAME(a: $T, b: $T) -> Ordering {\n-            if a < b {\n-                return Ordering::Less;\n-            }\n-            if a > b {\n-                return Ordering::Greater;\n+/// returns a comparison function that compares two values at two different positions\n+/// between the two arrays.\n+/// The arrays' types must be equal.\n+/// # Example\n+/// ```\n+/// use arrow::array::{build_compare, Int32Array};\n+///\n+/// # fn main() -> arrow::error::Result<()> {\n+/// let array1 = Int32Array::from(vec![1, 2]);\n+/// let array2 = Int32Array::from(vec![3, 4]);\n+///\n+/// let cmp = build_compare(&array1, &array2)?;\n+///\n+/// // 1 (index 0 of array1) is smaller than 4 (index 1 of array2)\n+/// assert_eq!(std::cmp::Ordering::Less, (cmp)(0, 1));\n+/// # Ok(())\n+/// # }\n+/// ```\n+// This is a factory of comparisons.\n+// The lifetime 'a enforces that we cannot use the closure beyond any of the array's lifetime.\n+pub fn build_compare<'a>(left: &'a Array, right: &'a Array) -> Result<DynComparator<'a>> {\n+    use DataType::*;\n+    use IntervalUnit::*;\n+    use TimeUnit::*;\n+    Ok(match (left.data_type(), right.data_type()) {\n+        (a, b) if a != b => {\n+            return Err(ArrowError::InvalidArgumentError(\n+                \"Can't compare arrays of different types\".to_string(),\n+            ));\n+        }\n+        (Boolean, Boolean) => compare_primitives::<BooleanType>(left, right),\n+        (UInt8, UInt8) => compare_primitives::<UInt8Type>(left, right),\n+        (UInt16, UInt16) => compare_primitives::<UInt16Type>(left, right),\n+        (UInt32, UInt32) => compare_primitives::<UInt32Type>(left, right),\n+        (UInt64, UInt64) => compare_primitives::<UInt64Type>(left, right),\n+        (Int8, Int8) => compare_primitives::<Int8Type>(left, right),\n+        (Int16, Int16) => compare_primitives::<Int16Type>(left, right),\n+        (Int32, Int32) => compare_primitives::<Int32Type>(left, right),\n+        (Int64, Int64) => compare_primitives::<Int64Type>(left, right),\n+        (Float32, Float32) => compare_float::<Float32Type>(left, right),\n+        (Float64, Float64) => compare_float::<Float64Type>(left, right),\n+        (Date32(_), Date32(_)) => compare_primitives::<Date32Type>(left, right),\n+        (Date64(_), Date64(_)) => compare_primitives::<Date64Type>(left, right),\n+        (Time32(Second), Time32(Second)) => {\n+            compare_primitives::<Time32SecondType>(left, right)\n+        }\n+        (Time32(Millisecond), Time32(Millisecond)) => {\n+            compare_primitives::<Time32MillisecondType>(left, right)\n+        }\n+        (Time64(Microsecond), Time64(Microsecond)) => {\n+            compare_primitives::<Time64MicrosecondType>(left, right)\n+        }\n+        (Time64(Nanosecond), Time64(Nanosecond)) => {\n+            compare_primitives::<Time64NanosecondType>(left, right)\n+        }\n+        (Timestamp(Second, _), Timestamp(Second, _)) => {\n+            compare_primitives::<TimestampSecondType>(left, right)\n+        }\n+        (Timestamp(Millisecond, _), Timestamp(Millisecond, _)) => {\n+            compare_primitives::<TimestampMillisecondType>(left, right)\n+        }\n+        (Timestamp(Microsecond, _), Timestamp(Microsecond, _)) => {\n+            compare_primitives::<TimestampMicrosecondType>(left, right)\n+        }\n+        (Timestamp(Nanosecond, _), Timestamp(Nanosecond, _)) => {\n+            compare_primitives::<TimestampNanosecondType>(left, right)\n+        }\n+        (Interval(YearMonth), Interval(YearMonth)) => {\n+            compare_primitives::<IntervalYearMonthType>(left, right)\n+        }\n+        (Interval(DayTime), Interval(DayTime)) => {\n+            compare_primitives::<IntervalDayTimeType>(left, right)\n+        }\n+        (Duration(Second), Duration(Second)) => {\n+            compare_primitives::<DurationSecondType>(left, right)\n+        }\n+        (Duration(Millisecond), Duration(Millisecond)) => {\n+            compare_primitives::<DurationMillisecondType>(left, right)\n+        }\n+        (Duration(Microsecond), Duration(Microsecond)) => {\n+            compare_primitives::<DurationMicrosecondType>(left, right)\n+        }\n+        (Duration(Nanosecond), Duration(Nanosecond)) => {\n+            compare_primitives::<DurationNanosecondType>(left, right)\n+        }\n+        (Utf8, Utf8) => compare_string::<i32>(left, right),\n+        (LargeUtf8, LargeUtf8) => compare_string::<i64>(left, right),\n+        (\n+            Dictionary(key_type_lhs, value_type_lhs),\n+            Dictionary(key_type_rhs, value_type_rhs),\n+        ) => {\n+            if value_type_lhs.as_ref() != &DataType::Utf8\n+                || value_type_rhs.as_ref() != &DataType::Utf8\n+            {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Arrow still does not support comparisons of non-string dictionary arrays\"\n\nReview comment:\n       Or maybe we can leverage the comparison kernel somehow\n\n##########\nFile path: rust/arrow/src/compute/kernels/sort.rs\n##########\n@@ -41,110 +41,123 @@ pub fn sort(values: &ArrayRef, options: Option<SortOptions>) -> Result<ArrayRef>\n     take(values, &indices, None)\n }\n \n+fn partition_nan<T: ArrowPrimitiveType>(\n+    array: &ArrayRef,\n+    v: Vec<u32>,\n+) -> (Vec<u32>, Vec<u32>) {\n+    // partition by nan for float types\n+    if T::DATA_TYPE == DataType::Float32 {\n+        // T::Native has no `is_nan` and thus we need to downcast\n+        let array = array\n+            .as_any()\n+            .downcast_ref::<Float32Array>()\n+            .expect(\"Unable to downcast array\");\n+        let has_nan = v.iter().any(|index| array.value(*index as usize).is_nan());\n\nReview comment:\n       But I see this is just refactored from below, so no need to change\n\n##########\nFile path: rust/arrow/src/array/ord.rs\n##########\n@@ -15,297 +15,280 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-//! Defines trait for array element comparison\n+//! Contains functions and function factories to compare arrays.\n \n use std::cmp::Ordering;\n \n use crate::array::*;\n+use crate::datatypes::TimeUnit;\n use crate::datatypes::*;\n use crate::error::{ArrowError, Result};\n \n-use TimeUnit::*;\n+use num::Float;\n \n-/// Trait for Arrays that can be sorted\n-///\n-/// Example:\n-/// ```\n-/// use std::cmp::Ordering;\n-/// use arrow::array::*;\n-/// use arrow::datatypes::*;\n-///\n-/// let arr: Box<dyn OrdArray> = Box::new(PrimitiveArray::<Int64Type>::from(vec![\n-///     Some(-2),\n-///     Some(89),\n-///     Some(-64),\n-///     Some(101),\n-/// ]));\n-///\n-/// assert_eq!(arr.cmp_value(1, 2), Ordering::Greater);\n-/// ```\n-pub trait OrdArray {\n-    /// Return ordering between array element at index i and j\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering;\n-}\n+/// The public interface to compare values from arrays in a dynamically-typed fashion.\n+pub type DynComparator<'a> = Box<dyn Fn(usize, usize) -> Ordering + 'a>;\n \n-impl<T: OrdArray> OrdArray for Box<T> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n+/// compares two floats, placing NaNs at last\n+fn cmp_nans_last<T: Float>(a: &T, b: &T) -> Ordering {\n+    match (a, b) {\n+        (x, y) if x.is_nan() && y.is_nan() => Ordering::Equal,\n+        (x, _) if x.is_nan() => Ordering::Greater,\n+        (_, y) if y.is_nan() => Ordering::Less,\n+        (_, _) => a.partial_cmp(b).unwrap(),\n     }\n }\n \n-impl<T: OrdArray> OrdArray for &T {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n-    }\n+fn compare_primitives<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n+where\n+    T::Native: Ord,\n+{\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl<T: ArrowPrimitiveType> OrdArray for PrimitiveArray<T>\n+fn compare_float<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n where\n-    T::Native: std::cmp::Ord,\n+    T::Native: Float,\n {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(&self.value(j))\n-    }\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| cmp_nans_last(&left.value(i), &right.value(j)))\n }\n \n-impl OrdArray for StringArray {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(self.value(j))\n-    }\n+fn compare_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: StringOffsetSizeTrait,\n+{\n+    let left = left\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    let right = right\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl OrdArray for NullArray {\n-    fn cmp_value(&self, _i: usize, _j: usize) -> Ordering {\n-        Ordering::Equal\n-    }\n+fn compare_dict_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: ArrowDictionaryKeyType,\n+{\n+    let left = left.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let left_keys = left.keys_array();\n+    let right_keys = right.keys_array();\n+\n+    let left_values = StringArray::from(left.values().data());\n+    let right_values = StringArray::from(left.values().data());\n+\n+    Box::new(move |i: usize, j: usize| {\n+        let key_left = left_keys.value(i).to_usize().unwrap();\n+        let key_right = right_keys.value(j).to_usize().unwrap();\n+        let left = left_values.value(key_left);\n+        let right = right_values.value(key_right);\n+        left.cmp(&right)\n+    })\n }\n \n-macro_rules! float_ord_cmp {\n-    ($NAME: ident, $T: ty) => {\n-        #[inline]\n-        fn $NAME(a: $T, b: $T) -> Ordering {\n-            if a < b {\n-                return Ordering::Less;\n-            }\n-            if a > b {\n-                return Ordering::Greater;\n+/// returns a comparison function that compares two values at two different positions\n+/// between the two arrays.\n+/// The arrays' types must be equal.\n+/// # Example\n+/// ```\n+/// use arrow::array::{build_compare, Int32Array};\n+///\n+/// # fn main() -> arrow::error::Result<()> {\n+/// let array1 = Int32Array::from(vec![1, 2]);\n+/// let array2 = Int32Array::from(vec![3, 4]);\n+///\n+/// let cmp = build_compare(&array1, &array2)?;\n+///\n+/// // 1 (index 0 of array1) is smaller than 4 (index 1 of array2)\n+/// assert_eq!(std::cmp::Ordering::Less, (cmp)(0, 1));\n+/// # Ok(())\n+/// # }\n+/// ```\n+// This is a factory of comparisons.\n+// The lifetime 'a enforces that we cannot use the closure beyond any of the array's lifetime.\n+pub fn build_compare<'a>(left: &'a Array, right: &'a Array) -> Result<DynComparator<'a>> {\n+    use DataType::*;\n+    use IntervalUnit::*;\n+    use TimeUnit::*;\n+    Ok(match (left.data_type(), right.data_type()) {\n+        (a, b) if a != b => {\n+            return Err(ArrowError::InvalidArgumentError(\n+                \"Can't compare arrays of different types\".to_string(),\n+            ));\n+        }\n+        (Boolean, Boolean) => compare_primitives::<BooleanType>(left, right),\n+        (UInt8, UInt8) => compare_primitives::<UInt8Type>(left, right),\n+        (UInt16, UInt16) => compare_primitives::<UInt16Type>(left, right),\n+        (UInt32, UInt32) => compare_primitives::<UInt32Type>(left, right),\n+        (UInt64, UInt64) => compare_primitives::<UInt64Type>(left, right),\n+        (Int8, Int8) => compare_primitives::<Int8Type>(left, right),\n+        (Int16, Int16) => compare_primitives::<Int16Type>(left, right),\n+        (Int32, Int32) => compare_primitives::<Int32Type>(left, right),\n+        (Int64, Int64) => compare_primitives::<Int64Type>(left, right),\n+        (Float32, Float32) => compare_float::<Float32Type>(left, right),\n+        (Float64, Float64) => compare_float::<Float64Type>(left, right),\n+        (Date32(_), Date32(_)) => compare_primitives::<Date32Type>(left, right),\n+        (Date64(_), Date64(_)) => compare_primitives::<Date64Type>(left, right),\n+        (Time32(Second), Time32(Second)) => {\n+            compare_primitives::<Time32SecondType>(left, right)\n+        }\n+        (Time32(Millisecond), Time32(Millisecond)) => {\n+            compare_primitives::<Time32MillisecondType>(left, right)\n+        }\n+        (Time64(Microsecond), Time64(Microsecond)) => {\n+            compare_primitives::<Time64MicrosecondType>(left, right)\n+        }\n+        (Time64(Nanosecond), Time64(Nanosecond)) => {\n+            compare_primitives::<Time64NanosecondType>(left, right)\n+        }\n+        (Timestamp(Second, _), Timestamp(Second, _)) => {\n+            compare_primitives::<TimestampSecondType>(left, right)\n+        }\n+        (Timestamp(Millisecond, _), Timestamp(Millisecond, _)) => {\n+            compare_primitives::<TimestampMillisecondType>(left, right)\n+        }\n+        (Timestamp(Microsecond, _), Timestamp(Microsecond, _)) => {\n+            compare_primitives::<TimestampMicrosecondType>(left, right)\n+        }\n+        (Timestamp(Nanosecond, _), Timestamp(Nanosecond, _)) => {\n+            compare_primitives::<TimestampNanosecondType>(left, right)\n+        }\n+        (Interval(YearMonth), Interval(YearMonth)) => {\n+            compare_primitives::<IntervalYearMonthType>(left, right)\n+        }\n+        (Interval(DayTime), Interval(DayTime)) => {\n+            compare_primitives::<IntervalDayTimeType>(left, right)\n+        }\n+        (Duration(Second), Duration(Second)) => {\n+            compare_primitives::<DurationSecondType>(left, right)\n+        }\n+        (Duration(Millisecond), Duration(Millisecond)) => {\n+            compare_primitives::<DurationMillisecondType>(left, right)\n+        }\n+        (Duration(Microsecond), Duration(Microsecond)) => {\n+            compare_primitives::<DurationMicrosecondType>(left, right)\n+        }\n+        (Duration(Nanosecond), Duration(Nanosecond)) => {\n+            compare_primitives::<DurationNanosecondType>(left, right)\n+        }\n+        (Utf8, Utf8) => compare_string::<i32>(left, right),\n+        (LargeUtf8, LargeUtf8) => compare_string::<i64>(left, right),\n+        (\n+            Dictionary(key_type_lhs, value_type_lhs),\n+            Dictionary(key_type_rhs, value_type_rhs),\n+        ) => {\n+            if value_type_lhs.as_ref() != &DataType::Utf8\n+                || value_type_rhs.as_ref() != &DataType::Utf8\n+            {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Arrow still does not support comparisons of non-string dictionary arrays\"\n+                        .to_string(),\n+                ));\n             }\n-\n-            // convert to bits with canonical pattern for NaN\n-            let a = if a.is_nan() {\n-                <$T>::NAN.to_bits()\n-            } else {\n-                a.to_bits()\n-            };\n-            let b = if b.is_nan() {\n-                <$T>::NAN.to_bits()\n-            } else {\n-                b.to_bits()\n-            };\n-\n-            if a == b {\n-                // Equal or both NaN\n-                Ordering::Equal\n-            } else if a < b {\n-                // (-0.0, 0.0) or (!NaN, NaN)\n-                Ordering::Less\n-            } else {\n-                // (0.0, -0.0) or (NaN, !NaN)\n-                Ordering::Greater\n+            match (key_type_lhs.as_ref(), key_type_rhs.as_ref()) {\n+                (a, b) if a != b => {\n+                    return Err(ArrowError::InvalidArgumentError(\n+                        \"Can't compare arrays of different types\".to_string(),\n+                    ));\n+                }\n+                (UInt8, UInt8) => compare_dict_string::<UInt8Type>(left, right),\n+                (UInt16, UInt16) => compare_dict_string::<UInt16Type>(left, right),\n+                (UInt32, UInt32) => compare_dict_string::<UInt32Type>(left, right),\n+                (UInt64, UInt64) => compare_dict_string::<UInt64Type>(left, right),\n+                (Int8, Int8) => compare_dict_string::<Int8Type>(left, right),\n+                (Int16, Int16) => compare_dict_string::<Int16Type>(left, right),\n+                (Int32, Int32) => compare_dict_string::<Int32Type>(left, right),\n+                (Int64, Int64) => compare_dict_string::<Int64Type>(left, right),\n+                _ => todo!(),\n             }\n         }\n-    };\n+        _ => todo!(),\n\nReview comment:\n       \u2795 \n\n##########\nFile path: rust/arrow/benches/sort_kernel.rs\n##########\n@@ -0,0 +1,83 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#[macro_use]\n+extern crate criterion;\n+use criterion::Criterion;\n+\n+use rand::Rng;\n+use std::sync::Arc;\n+\n+extern crate arrow;\n+\n+use arrow::array::*;\n+use arrow::compute::kernels::sort::{lexsort, SortColumn};\n+\n+fn create_array(size: usize, with_nulls: bool) -> ArrayRef {\n+    // use random numbers to avoid spurious compiler optimizations wrt to branching\n+    let mut rng = rand::thread_rng();\n+    let mut builder = Float32Builder::new(size);\n+\n+    for _ in 0..size {\n+        if with_nulls && rng.gen::<f32>() > 0.5 {\n+            builder.append_null().unwrap();\n+        } else {\n+            builder.append_value(rng.gen()).unwrap();\n+        }\n+    }\n+    Arc::new(builder.finish())\n+}\n+\n+fn bench_sort(arr_a: &ArrayRef, array_b: &ArrayRef) {\n+    let columns = vec![\n+        SortColumn {\n+            values: arr_a.clone(),\n+            options: None,\n+        },\n+        SortColumn {\n+            values: array_b.clone(),\n+            options: None,\n+        },\n+    ];\n+\n+    criterion::black_box(lexsort(&columns).unwrap());\n+}\n+\n+fn add_benchmark(c: &mut Criterion) {\n\nReview comment:\n       What would you think about adding a sort kernel for `u64` data as well?\n\n##########\nFile path: rust/arrow/src/array/ord.rs\n##########\n@@ -15,297 +15,259 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-//! Defines trait for array element comparison\n+//! Contains functions and function factories to compare arrays.\n \n use std::cmp::Ordering;\n \n use crate::array::*;\n+use crate::datatypes::TimeUnit;\n use crate::datatypes::*;\n use crate::error::{ArrowError, Result};\n \n-use TimeUnit::*;\n+use num::Float;\n \n-/// Trait for Arrays that can be sorted\n-///\n-/// Example:\n-/// ```\n-/// use std::cmp::Ordering;\n-/// use arrow::array::*;\n-/// use arrow::datatypes::*;\n-///\n-/// let arr: Box<dyn OrdArray> = Box::new(PrimitiveArray::<Int64Type>::from(vec![\n-///     Some(-2),\n-///     Some(89),\n-///     Some(-64),\n-///     Some(101),\n-/// ]));\n-///\n-/// assert_eq!(arr.cmp_value(1, 2), Ordering::Greater);\n-/// ```\n-pub trait OrdArray {\n-    /// Return ordering between array element at index i and j\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering;\n-}\n+/// The public interface to compare values from arrays in a dynamically-typed fashion.\n+pub type DynComparator<'a> = Box<dyn Fn(usize, usize) -> Ordering + 'a>;\n \n-impl<T: OrdArray> OrdArray for Box<T> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n+/// compares two floats, placing NaNs at last\n+fn cmp_nans_last<T: Float>(a: &T, b: &T) -> Ordering {\n+    match (a, b) {\n+        (x, y) if x.is_nan() && y.is_nan() => Ordering::Equal,\n+        (x, _) if x.is_nan() => Ordering::Greater,\n+        (_, y) if y.is_nan() => Ordering::Less,\n+        (_, _) => a.partial_cmp(b).unwrap(),\n     }\n }\n \n-impl<T: OrdArray> OrdArray for &T {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n-    }\n-}\n-\n-impl<T: ArrowPrimitiveType> OrdArray for PrimitiveArray<T>\n+fn compare_primitives<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n where\n-    T::Native: std::cmp::Ord,\n+    T::Native: Ord,\n {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(&self.value(j))\n-    }\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl OrdArray for StringArray {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(self.value(j))\n-    }\n-}\n-\n-impl OrdArray for NullArray {\n-    fn cmp_value(&self, _i: usize, _j: usize) -> Ordering {\n-        Ordering::Equal\n-    }\n-}\n-\n-macro_rules! float_ord_cmp {\n-    ($NAME: ident, $T: ty) => {\n-        #[inline]\n-        fn $NAME(a: $T, b: $T) -> Ordering {\n-            if a < b {\n-                return Ordering::Less;\n-            }\n-            if a > b {\n-                return Ordering::Greater;\n-            }\n-\n-            // convert to bits with canonical pattern for NaN\n-            let a = if a.is_nan() {\n-                <$T>::NAN.to_bits()\n-            } else {\n-                a.to_bits()\n-            };\n-            let b = if b.is_nan() {\n-                <$T>::NAN.to_bits()\n-            } else {\n-                b.to_bits()\n-            };\n-\n-            if a == b {\n-                // Equal or both NaN\n-                Ordering::Equal\n-            } else if a < b {\n-                // (-0.0, 0.0) or (!NaN, NaN)\n-                Ordering::Less\n-            } else {\n-                // (0.0, -0.0) or (NaN, !NaN)\n-                Ordering::Greater\n-            }\n-        }\n-    };\n-}\n-\n-float_ord_cmp!(cmp_f64, f64);\n-float_ord_cmp!(cmp_f32, f32);\n-\n-#[repr(transparent)]\n-struct Float64ArrayAsOrdArray<'a>(&'a Float64Array);\n-#[repr(transparent)]\n-struct Float32ArrayAsOrdArray<'a>(&'a Float32Array);\n-\n-impl OrdArray for Float64ArrayAsOrdArray<'_> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        let a: f64 = self.0.value(i);\n-        let b: f64 = self.0.value(j);\n-\n-        cmp_f64(a, b)\n-    }\n-}\n-\n-impl OrdArray for Float32ArrayAsOrdArray<'_> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        let a: f32 = self.0.value(i);\n-        let b: f32 = self.0.value(j);\n-\n-        cmp_f32(a, b)\n-    }\n-}\n-\n-fn float32_as_ord_array<'a>(array: &'a ArrayRef) -> Box<dyn OrdArray + 'a> {\n-    let float_array: &Float32Array = as_primitive_array::<Float32Type>(array);\n-    Box::new(Float32ArrayAsOrdArray(float_array))\n-}\n-\n-fn float64_as_ord_array<'a>(array: &'a ArrayRef) -> Box<dyn OrdArray + 'a> {\n-    let float_array: &Float64Array = as_primitive_array::<Float64Type>(array);\n-    Box::new(Float64ArrayAsOrdArray(float_array))\n-}\n-\n-struct StringDictionaryArrayAsOrdArray<'a, T: ArrowDictionaryKeyType> {\n-    dict_array: &'a DictionaryArray<T>,\n-    values: StringArray,\n-    keys: PrimitiveArray<T>,\n+fn compare_float<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n+where\n+    T::Native: Float,\n+{\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| cmp_nans_last(&left.value(i), &right.value(j)))\n }\n \n-impl<T: ArrowDictionaryKeyType> OrdArray for StringDictionaryArrayAsOrdArray<'_, T> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        let keys = &self.keys;\n-        let dict = &self.values;\n-\n-        let key_a: T::Native = keys.value(i);\n-        let key_b: T::Native = keys.value(j);\n-\n-        let str_a = dict.value(key_a.to_usize().unwrap());\n-        let str_b = dict.value(key_b.to_usize().unwrap());\n-\n-        str_a.cmp(str_b)\n-    }\n+fn compare_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: StringOffsetSizeTrait,\n+{\n+    let left = left\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    let right = right\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-fn string_dict_as_ord_array<'a, T: ArrowDictionaryKeyType>(\n-    array: &'a ArrayRef,\n-) -> Box<dyn OrdArray + 'a>\n+fn compare_dict_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n where\n-    T::Native: std::cmp::Ord,\n+    T: ArrowDictionaryKeyType,\n {\n-    let dict_array = as_dictionary_array::<T>(array);\n-    let keys = dict_array.keys_array();\n-\n-    let values = &dict_array.values();\n-    let values = StringArray::from(values.data());\n-\n-    Box::new(StringDictionaryArrayAsOrdArray {\n-        dict_array,\n-        values,\n-        keys,\n+    let left = left.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let left_keys = left.keys_array();\n+    let right_keys = right.keys_array();\n+\n+    let left_values = StringArray::from(left.values().data());\n+    let right_values = StringArray::from(left.values().data());\n+\n+    Box::new(move |i: usize, j: usize| {\n+        let key_left = left_keys.value(i).to_usize().unwrap();\n+        let key_right = right_keys.value(j).to_usize().unwrap();\n+        let left = left_values.value(key_left);\n+        let right = right_values.value(key_right);\n+        left.cmp(&right)\n     })\n }\n \n-/// Convert ArrayRef to OrdArray trait object\n-pub fn as_ordarray<'a>(values: &'a ArrayRef) -> Result<Box<OrdArray + 'a>> {\n-    match values.data_type() {\n-        DataType::Boolean => Ok(Box::new(as_boolean_array(&values))),\n-        DataType::Utf8 => Ok(Box::new(as_string_array(&values))),\n-        DataType::Null => Ok(Box::new(as_null_array(&values))),\n-        DataType::Int8 => Ok(Box::new(as_primitive_array::<Int8Type>(&values))),\n-        DataType::Int16 => Ok(Box::new(as_primitive_array::<Int16Type>(&values))),\n-        DataType::Int32 => Ok(Box::new(as_primitive_array::<Int32Type>(&values))),\n-        DataType::Int64 => Ok(Box::new(as_primitive_array::<Int64Type>(&values))),\n-        DataType::UInt8 => Ok(Box::new(as_primitive_array::<UInt8Type>(&values))),\n-        DataType::UInt16 => Ok(Box::new(as_primitive_array::<UInt16Type>(&values))),\n-        DataType::UInt32 => Ok(Box::new(as_primitive_array::<UInt32Type>(&values))),\n-        DataType::UInt64 => Ok(Box::new(as_primitive_array::<UInt64Type>(&values))),\n-        DataType::Date32(_) => Ok(Box::new(as_primitive_array::<Date32Type>(&values))),\n-        DataType::Date64(_) => Ok(Box::new(as_primitive_array::<Date64Type>(&values))),\n-        DataType::Time32(Second) => {\n-            Ok(Box::new(as_primitive_array::<Time32SecondType>(&values)))\n+/// returns a comparison function that compares two values at two different positions\n+/// between the two arrays.\n+/// The arrays' types must be equal.\n+/// # Example\n+/// ```\n+/// use arrow::array::{build_compare, Int32Array};\n+///\n+/// # fn main() -> arrow::error::Result<()> {\n+/// let array1 = Int32Array::from(vec![1, 2]);\n+/// let array2 = Int32Array::from(vec![3, 4]);\n+///\n+/// let cmp = build_compare(&array1, &array2)?;\n+///\n+/// // 1 (index 0 of array1) is smaller than 4 (index 1 of array2)\n+/// assert_eq!(std::cmp::Ordering::Less, (cmp)(0, 1));\n+/// # Ok(())\n+/// # }\n+/// ```\n+// This is a factory of comparisons.\n+// The lifetime 'a enforces that we cannot use the closure beyond any of the array's lifetime.\n+pub fn build_compare<'a>(left: &'a Array, right: &'a Array) -> Result<DynComparator<'a>> {\n\nReview comment:\n       This all looks cool -- though I do wonder at the runtime overhead of doing dynamic dispatch for each comparison. However, if you have measured no performance regression, this code seems like an improvement to what is on master.\r\n   \r\n   I do wonder if there is some way to reuse the work in the comparison kernel:\r\n   https://github.com/apache/arrow/blob/master/rust/arrow/src/compute/kernels/comparison.rs to try and improve performance over row by row comparison + a dynamic dispatch.\r\n   \r\n   Perhaps that is a good optimization for some future PR\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-26T11:53:50.811+0000",
                    "updated": "2020-10-26T11:53:50.811+0000",
                    "started": "2020-10-26T11:53:50.811+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "504688",
                    "issueId": "13337037"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037/worklog/505513",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8517:\nURL: https://github.com/apache/arrow/pull/8517#discussion_r513161172\n\n\n\n##########\nFile path: rust/arrow/src/array/ord.rs\n##########\n@@ -15,297 +15,259 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-//! Defines trait for array element comparison\n+//! Contains functions and function factories to compare arrays.\n \n use std::cmp::Ordering;\n \n use crate::array::*;\n+use crate::datatypes::TimeUnit;\n use crate::datatypes::*;\n use crate::error::{ArrowError, Result};\n \n-use TimeUnit::*;\n+use num::Float;\n \n-/// Trait for Arrays that can be sorted\n-///\n-/// Example:\n-/// ```\n-/// use std::cmp::Ordering;\n-/// use arrow::array::*;\n-/// use arrow::datatypes::*;\n-///\n-/// let arr: Box<dyn OrdArray> = Box::new(PrimitiveArray::<Int64Type>::from(vec![\n-///     Some(-2),\n-///     Some(89),\n-///     Some(-64),\n-///     Some(101),\n-/// ]));\n-///\n-/// assert_eq!(arr.cmp_value(1, 2), Ordering::Greater);\n-/// ```\n-pub trait OrdArray {\n-    /// Return ordering between array element at index i and j\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering;\n-}\n+/// The public interface to compare values from arrays in a dynamically-typed fashion.\n+pub type DynComparator<'a> = Box<dyn Fn(usize, usize) -> Ordering + 'a>;\n \n-impl<T: OrdArray> OrdArray for Box<T> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n+/// compares two floats, placing NaNs at last\n+fn cmp_nans_last<T: Float>(a: &T, b: &T) -> Ordering {\n+    match (a, b) {\n+        (x, y) if x.is_nan() && y.is_nan() => Ordering::Equal,\n+        (x, _) if x.is_nan() => Ordering::Greater,\n+        (_, y) if y.is_nan() => Ordering::Less,\n+        (_, _) => a.partial_cmp(b).unwrap(),\n     }\n }\n \n-impl<T: OrdArray> OrdArray for &T {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n-    }\n-}\n-\n-impl<T: ArrowPrimitiveType> OrdArray for PrimitiveArray<T>\n+fn compare_primitives<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n where\n-    T::Native: std::cmp::Ord,\n+    T::Native: Ord,\n {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(&self.value(j))\n-    }\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl OrdArray for StringArray {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(self.value(j))\n-    }\n-}\n-\n-impl OrdArray for NullArray {\n-    fn cmp_value(&self, _i: usize, _j: usize) -> Ordering {\n-        Ordering::Equal\n-    }\n-}\n-\n-macro_rules! float_ord_cmp {\n-    ($NAME: ident, $T: ty) => {\n-        #[inline]\n-        fn $NAME(a: $T, b: $T) -> Ordering {\n-            if a < b {\n-                return Ordering::Less;\n-            }\n-            if a > b {\n-                return Ordering::Greater;\n-            }\n-\n-            // convert to bits with canonical pattern for NaN\n-            let a = if a.is_nan() {\n-                <$T>::NAN.to_bits()\n-            } else {\n-                a.to_bits()\n-            };\n-            let b = if b.is_nan() {\n-                <$T>::NAN.to_bits()\n-            } else {\n-                b.to_bits()\n-            };\n-\n-            if a == b {\n-                // Equal or both NaN\n-                Ordering::Equal\n-            } else if a < b {\n-                // (-0.0, 0.0) or (!NaN, NaN)\n-                Ordering::Less\n-            } else {\n-                // (0.0, -0.0) or (NaN, !NaN)\n-                Ordering::Greater\n-            }\n-        }\n-    };\n-}\n-\n-float_ord_cmp!(cmp_f64, f64);\n-float_ord_cmp!(cmp_f32, f32);\n-\n-#[repr(transparent)]\n-struct Float64ArrayAsOrdArray<'a>(&'a Float64Array);\n-#[repr(transparent)]\n-struct Float32ArrayAsOrdArray<'a>(&'a Float32Array);\n-\n-impl OrdArray for Float64ArrayAsOrdArray<'_> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        let a: f64 = self.0.value(i);\n-        let b: f64 = self.0.value(j);\n-\n-        cmp_f64(a, b)\n-    }\n-}\n-\n-impl OrdArray for Float32ArrayAsOrdArray<'_> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        let a: f32 = self.0.value(i);\n-        let b: f32 = self.0.value(j);\n-\n-        cmp_f32(a, b)\n-    }\n-}\n-\n-fn float32_as_ord_array<'a>(array: &'a ArrayRef) -> Box<dyn OrdArray + 'a> {\n-    let float_array: &Float32Array = as_primitive_array::<Float32Type>(array);\n-    Box::new(Float32ArrayAsOrdArray(float_array))\n-}\n-\n-fn float64_as_ord_array<'a>(array: &'a ArrayRef) -> Box<dyn OrdArray + 'a> {\n-    let float_array: &Float64Array = as_primitive_array::<Float64Type>(array);\n-    Box::new(Float64ArrayAsOrdArray(float_array))\n-}\n-\n-struct StringDictionaryArrayAsOrdArray<'a, T: ArrowDictionaryKeyType> {\n-    dict_array: &'a DictionaryArray<T>,\n-    values: StringArray,\n-    keys: PrimitiveArray<T>,\n+fn compare_float<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n+where\n+    T::Native: Float,\n+{\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| cmp_nans_last(&left.value(i), &right.value(j)))\n }\n \n-impl<T: ArrowDictionaryKeyType> OrdArray for StringDictionaryArrayAsOrdArray<'_, T> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        let keys = &self.keys;\n-        let dict = &self.values;\n-\n-        let key_a: T::Native = keys.value(i);\n-        let key_b: T::Native = keys.value(j);\n-\n-        let str_a = dict.value(key_a.to_usize().unwrap());\n-        let str_b = dict.value(key_b.to_usize().unwrap());\n-\n-        str_a.cmp(str_b)\n-    }\n+fn compare_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: StringOffsetSizeTrait,\n+{\n+    let left = left\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    let right = right\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-fn string_dict_as_ord_array<'a, T: ArrowDictionaryKeyType>(\n-    array: &'a ArrayRef,\n-) -> Box<dyn OrdArray + 'a>\n+fn compare_dict_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n where\n-    T::Native: std::cmp::Ord,\n+    T: ArrowDictionaryKeyType,\n {\n-    let dict_array = as_dictionary_array::<T>(array);\n-    let keys = dict_array.keys_array();\n-\n-    let values = &dict_array.values();\n-    let values = StringArray::from(values.data());\n-\n-    Box::new(StringDictionaryArrayAsOrdArray {\n-        dict_array,\n-        values,\n-        keys,\n+    let left = left.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let left_keys = left.keys_array();\n+    let right_keys = right.keys_array();\n+\n+    let left_values = StringArray::from(left.values().data());\n+    let right_values = StringArray::from(left.values().data());\n+\n+    Box::new(move |i: usize, j: usize| {\n+        let key_left = left_keys.value(i).to_usize().unwrap();\n+        let key_right = right_keys.value(j).to_usize().unwrap();\n+        let left = left_values.value(key_left);\n+        let right = right_values.value(key_right);\n+        left.cmp(&right)\n     })\n }\n \n-/// Convert ArrayRef to OrdArray trait object\n-pub fn as_ordarray<'a>(values: &'a ArrayRef) -> Result<Box<OrdArray + 'a>> {\n-    match values.data_type() {\n-        DataType::Boolean => Ok(Box::new(as_boolean_array(&values))),\n-        DataType::Utf8 => Ok(Box::new(as_string_array(&values))),\n-        DataType::Null => Ok(Box::new(as_null_array(&values))),\n-        DataType::Int8 => Ok(Box::new(as_primitive_array::<Int8Type>(&values))),\n-        DataType::Int16 => Ok(Box::new(as_primitive_array::<Int16Type>(&values))),\n-        DataType::Int32 => Ok(Box::new(as_primitive_array::<Int32Type>(&values))),\n-        DataType::Int64 => Ok(Box::new(as_primitive_array::<Int64Type>(&values))),\n-        DataType::UInt8 => Ok(Box::new(as_primitive_array::<UInt8Type>(&values))),\n-        DataType::UInt16 => Ok(Box::new(as_primitive_array::<UInt16Type>(&values))),\n-        DataType::UInt32 => Ok(Box::new(as_primitive_array::<UInt32Type>(&values))),\n-        DataType::UInt64 => Ok(Box::new(as_primitive_array::<UInt64Type>(&values))),\n-        DataType::Date32(_) => Ok(Box::new(as_primitive_array::<Date32Type>(&values))),\n-        DataType::Date64(_) => Ok(Box::new(as_primitive_array::<Date64Type>(&values))),\n-        DataType::Time32(Second) => {\n-            Ok(Box::new(as_primitive_array::<Time32SecondType>(&values)))\n+/// returns a comparison function that compares two values at two different positions\n+/// between the two arrays.\n+/// The arrays' types must be equal.\n+/// # Example\n+/// ```\n+/// use arrow::array::{build_compare, Int32Array};\n+///\n+/// # fn main() -> arrow::error::Result<()> {\n+/// let array1 = Int32Array::from(vec![1, 2]);\n+/// let array2 = Int32Array::from(vec![3, 4]);\n+///\n+/// let cmp = build_compare(&array1, &array2)?;\n+///\n+/// // 1 (index 0 of array1) is smaller than 4 (index 1 of array2)\n+/// assert_eq!(std::cmp::Ordering::Less, (cmp)(0, 1));\n+/// # Ok(())\n+/// # }\n+/// ```\n+// This is a factory of comparisons.\n+// The lifetime 'a enforces that we cannot use the closure beyond any of the array's lifetime.\n+pub fn build_compare<'a>(left: &'a Array, right: &'a Array) -> Result<DynComparator<'a>> {\n\nReview comment:\n       Note that we were already using dynamic dispatch with the `OrdArray`: in the lexical sort, we built a vector of arrays of unknown types, and then call their `cmp_values`. Because the vector contains heterogeneous array types, the calls are dynamically dispatched.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-28T03:39:40.198+0000",
                    "updated": "2020-10-28T03:39:40.198+0000",
                    "started": "2020-10-28T03:39:40.198+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "505513",
                    "issueId": "13337037"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037/worklog/505525",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8517:\nURL: https://github.com/apache/arrow/pull/8517#discussion_r513164636\n\n\n\n##########\nFile path: rust/arrow/src/array/ord.rs\n##########\n@@ -15,297 +15,280 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-//! Defines trait for array element comparison\n+//! Contains functions and function factories to compare arrays.\n \n use std::cmp::Ordering;\n \n use crate::array::*;\n+use crate::datatypes::TimeUnit;\n use crate::datatypes::*;\n use crate::error::{ArrowError, Result};\n \n-use TimeUnit::*;\n+use num::Float;\n \n-/// Trait for Arrays that can be sorted\n-///\n-/// Example:\n-/// ```\n-/// use std::cmp::Ordering;\n-/// use arrow::array::*;\n-/// use arrow::datatypes::*;\n-///\n-/// let arr: Box<dyn OrdArray> = Box::new(PrimitiveArray::<Int64Type>::from(vec![\n-///     Some(-2),\n-///     Some(89),\n-///     Some(-64),\n-///     Some(101),\n-/// ]));\n-///\n-/// assert_eq!(arr.cmp_value(1, 2), Ordering::Greater);\n-/// ```\n-pub trait OrdArray {\n-    /// Return ordering between array element at index i and j\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering;\n-}\n+/// The public interface to compare values from arrays in a dynamically-typed fashion.\n+pub type DynComparator<'a> = Box<dyn Fn(usize, usize) -> Ordering + 'a>;\n \n-impl<T: OrdArray> OrdArray for Box<T> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n+/// compares two floats, placing NaNs at last\n+fn cmp_nans_last<T: Float>(a: &T, b: &T) -> Ordering {\n+    match (a, b) {\n+        (x, y) if x.is_nan() && y.is_nan() => Ordering::Equal,\n+        (x, _) if x.is_nan() => Ordering::Greater,\n+        (_, y) if y.is_nan() => Ordering::Less,\n+        (_, _) => a.partial_cmp(b).unwrap(),\n     }\n }\n \n-impl<T: OrdArray> OrdArray for &T {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n-    }\n+fn compare_primitives<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n+where\n+    T::Native: Ord,\n+{\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl<T: ArrowPrimitiveType> OrdArray for PrimitiveArray<T>\n+fn compare_float<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n where\n-    T::Native: std::cmp::Ord,\n+    T::Native: Float,\n {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(&self.value(j))\n-    }\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| cmp_nans_last(&left.value(i), &right.value(j)))\n }\n \n-impl OrdArray for StringArray {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(self.value(j))\n-    }\n+fn compare_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: StringOffsetSizeTrait,\n+{\n+    let left = left\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    let right = right\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl OrdArray for NullArray {\n-    fn cmp_value(&self, _i: usize, _j: usize) -> Ordering {\n-        Ordering::Equal\n-    }\n+fn compare_dict_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: ArrowDictionaryKeyType,\n+{\n+    let left = left.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let left_keys = left.keys_array();\n+    let right_keys = right.keys_array();\n+\n+    let left_values = StringArray::from(left.values().data());\n+    let right_values = StringArray::from(left.values().data());\n+\n+    Box::new(move |i: usize, j: usize| {\n+        let key_left = left_keys.value(i).to_usize().unwrap();\n+        let key_right = right_keys.value(j).to_usize().unwrap();\n+        let left = left_values.value(key_left);\n+        let right = right_values.value(key_right);\n+        left.cmp(&right)\n+    })\n }\n \n-macro_rules! float_ord_cmp {\n-    ($NAME: ident, $T: ty) => {\n-        #[inline]\n-        fn $NAME(a: $T, b: $T) -> Ordering {\n-            if a < b {\n-                return Ordering::Less;\n-            }\n-            if a > b {\n-                return Ordering::Greater;\n+/// returns a comparison function that compares two values at two different positions\n+/// between the two arrays.\n+/// The arrays' types must be equal.\n+/// # Example\n+/// ```\n+/// use arrow::array::{build_compare, Int32Array};\n+///\n+/// # fn main() -> arrow::error::Result<()> {\n+/// let array1 = Int32Array::from(vec![1, 2]);\n+/// let array2 = Int32Array::from(vec![3, 4]);\n+///\n+/// let cmp = build_compare(&array1, &array2)?;\n+///\n+/// // 1 (index 0 of array1) is smaller than 4 (index 1 of array2)\n+/// assert_eq!(std::cmp::Ordering::Less, (cmp)(0, 1));\n+/// # Ok(())\n+/// # }\n+/// ```\n+// This is a factory of comparisons.\n+// The lifetime 'a enforces that we cannot use the closure beyond any of the array's lifetime.\n+pub fn build_compare<'a>(left: &'a Array, right: &'a Array) -> Result<DynComparator<'a>> {\n+    use DataType::*;\n+    use IntervalUnit::*;\n+    use TimeUnit::*;\n+    Ok(match (left.data_type(), right.data_type()) {\n+        (a, b) if a != b => {\n+            return Err(ArrowError::InvalidArgumentError(\n+                \"Can't compare arrays of different types\".to_string(),\n+            ));\n+        }\n+        (Boolean, Boolean) => compare_primitives::<BooleanType>(left, right),\n+        (UInt8, UInt8) => compare_primitives::<UInt8Type>(left, right),\n+        (UInt16, UInt16) => compare_primitives::<UInt16Type>(left, right),\n+        (UInt32, UInt32) => compare_primitives::<UInt32Type>(left, right),\n+        (UInt64, UInt64) => compare_primitives::<UInt64Type>(left, right),\n+        (Int8, Int8) => compare_primitives::<Int8Type>(left, right),\n+        (Int16, Int16) => compare_primitives::<Int16Type>(left, right),\n+        (Int32, Int32) => compare_primitives::<Int32Type>(left, right),\n+        (Int64, Int64) => compare_primitives::<Int64Type>(left, right),\n+        (Float32, Float32) => compare_float::<Float32Type>(left, right),\n+        (Float64, Float64) => compare_float::<Float64Type>(left, right),\n+        (Date32(_), Date32(_)) => compare_primitives::<Date32Type>(left, right),\n+        (Date64(_), Date64(_)) => compare_primitives::<Date64Type>(left, right),\n+        (Time32(Second), Time32(Second)) => {\n+            compare_primitives::<Time32SecondType>(left, right)\n+        }\n+        (Time32(Millisecond), Time32(Millisecond)) => {\n+            compare_primitives::<Time32MillisecondType>(left, right)\n+        }\n+        (Time64(Microsecond), Time64(Microsecond)) => {\n+            compare_primitives::<Time64MicrosecondType>(left, right)\n+        }\n+        (Time64(Nanosecond), Time64(Nanosecond)) => {\n+            compare_primitives::<Time64NanosecondType>(left, right)\n+        }\n+        (Timestamp(Second, _), Timestamp(Second, _)) => {\n+            compare_primitives::<TimestampSecondType>(left, right)\n+        }\n+        (Timestamp(Millisecond, _), Timestamp(Millisecond, _)) => {\n+            compare_primitives::<TimestampMillisecondType>(left, right)\n+        }\n+        (Timestamp(Microsecond, _), Timestamp(Microsecond, _)) => {\n+            compare_primitives::<TimestampMicrosecondType>(left, right)\n+        }\n+        (Timestamp(Nanosecond, _), Timestamp(Nanosecond, _)) => {\n+            compare_primitives::<TimestampNanosecondType>(left, right)\n+        }\n+        (Interval(YearMonth), Interval(YearMonth)) => {\n+            compare_primitives::<IntervalYearMonthType>(left, right)\n+        }\n+        (Interval(DayTime), Interval(DayTime)) => {\n+            compare_primitives::<IntervalDayTimeType>(left, right)\n+        }\n+        (Duration(Second), Duration(Second)) => {\n+            compare_primitives::<DurationSecondType>(left, right)\n+        }\n+        (Duration(Millisecond), Duration(Millisecond)) => {\n+            compare_primitives::<DurationMillisecondType>(left, right)\n+        }\n+        (Duration(Microsecond), Duration(Microsecond)) => {\n+            compare_primitives::<DurationMicrosecondType>(left, right)\n+        }\n+        (Duration(Nanosecond), Duration(Nanosecond)) => {\n+            compare_primitives::<DurationNanosecondType>(left, right)\n+        }\n+        (Utf8, Utf8) => compare_string::<i32>(left, right),\n+        (LargeUtf8, LargeUtf8) => compare_string::<i64>(left, right),\n+        (\n+            Dictionary(key_type_lhs, value_type_lhs),\n+            Dictionary(key_type_rhs, value_type_rhs),\n+        ) => {\n+            if value_type_lhs.as_ref() != &DataType::Utf8\n+                || value_type_rhs.as_ref() != &DataType::Utf8\n+            {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Arrow still does not support comparisons of non-string dictionary arrays\"\n\nReview comment:\n       This code is as it was here.\r\n   \r\n   FYI I did tried to make this for arbitrary types, and I was very (very) close from having it one done, but it requires some unsafe usage, and so I left it for a separate PR. The relevant thread is here: https://users.rust-lang.org/t/how-to-move-values-to-closure-that-indirectly-depends-on-them/50586\n\n##########\nFile path: rust/arrow/src/array/ord.rs\n##########\n@@ -15,297 +15,280 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-//! Defines trait for array element comparison\n+//! Contains functions and function factories to compare arrays.\n \n use std::cmp::Ordering;\n \n use crate::array::*;\n+use crate::datatypes::TimeUnit;\n use crate::datatypes::*;\n use crate::error::{ArrowError, Result};\n \n-use TimeUnit::*;\n+use num::Float;\n \n-/// Trait for Arrays that can be sorted\n-///\n-/// Example:\n-/// ```\n-/// use std::cmp::Ordering;\n-/// use arrow::array::*;\n-/// use arrow::datatypes::*;\n-///\n-/// let arr: Box<dyn OrdArray> = Box::new(PrimitiveArray::<Int64Type>::from(vec![\n-///     Some(-2),\n-///     Some(89),\n-///     Some(-64),\n-///     Some(101),\n-/// ]));\n-///\n-/// assert_eq!(arr.cmp_value(1, 2), Ordering::Greater);\n-/// ```\n-pub trait OrdArray {\n-    /// Return ordering between array element at index i and j\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering;\n-}\n+/// The public interface to compare values from arrays in a dynamically-typed fashion.\n+pub type DynComparator<'a> = Box<dyn Fn(usize, usize) -> Ordering + 'a>;\n \n-impl<T: OrdArray> OrdArray for Box<T> {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n+/// compares two floats, placing NaNs at last\n+fn cmp_nans_last<T: Float>(a: &T, b: &T) -> Ordering {\n+    match (a, b) {\n+        (x, y) if x.is_nan() && y.is_nan() => Ordering::Equal,\n+        (x, _) if x.is_nan() => Ordering::Greater,\n+        (_, y) if y.is_nan() => Ordering::Less,\n+        (_, _) => a.partial_cmp(b).unwrap(),\n     }\n }\n \n-impl<T: OrdArray> OrdArray for &T {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        T::cmp_value(self, i, j)\n-    }\n+fn compare_primitives<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n+where\n+    T::Native: Ord,\n+{\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl<T: ArrowPrimitiveType> OrdArray for PrimitiveArray<T>\n+fn compare_float<'a, T: ArrowPrimitiveType>(\n+    left: &'a Array,\n+    right: &'a Array,\n+) -> DynComparator<'a>\n where\n-    T::Native: std::cmp::Ord,\n+    T::Native: Float,\n {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(&self.value(j))\n-    }\n+    let left = left.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<PrimitiveArray<T>>().unwrap();\n+    Box::new(move |i, j| cmp_nans_last(&left.value(i), &right.value(j)))\n }\n \n-impl OrdArray for StringArray {\n-    fn cmp_value(&self, i: usize, j: usize) -> Ordering {\n-        self.value(i).cmp(self.value(j))\n-    }\n+fn compare_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: StringOffsetSizeTrait,\n+{\n+    let left = left\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    let right = right\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T>>()\n+        .unwrap();\n+    Box::new(move |i, j| left.value(i).cmp(&right.value(j)))\n }\n \n-impl OrdArray for NullArray {\n-    fn cmp_value(&self, _i: usize, _j: usize) -> Ordering {\n-        Ordering::Equal\n-    }\n+fn compare_dict_string<'a, T>(left: &'a Array, right: &'a Array) -> DynComparator<'a>\n+where\n+    T: ArrowDictionaryKeyType,\n+{\n+    let left = left.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let right = right.as_any().downcast_ref::<DictionaryArray<T>>().unwrap();\n+    let left_keys = left.keys_array();\n+    let right_keys = right.keys_array();\n+\n+    let left_values = StringArray::from(left.values().data());\n+    let right_values = StringArray::from(left.values().data());\n+\n+    Box::new(move |i: usize, j: usize| {\n+        let key_left = left_keys.value(i).to_usize().unwrap();\n+        let key_right = right_keys.value(j).to_usize().unwrap();\n+        let left = left_values.value(key_left);\n+        let right = right_values.value(key_right);\n+        left.cmp(&right)\n+    })\n }\n \n-macro_rules! float_ord_cmp {\n-    ($NAME: ident, $T: ty) => {\n-        #[inline]\n-        fn $NAME(a: $T, b: $T) -> Ordering {\n-            if a < b {\n-                return Ordering::Less;\n-            }\n-            if a > b {\n-                return Ordering::Greater;\n+/// returns a comparison function that compares two values at two different positions\n+/// between the two arrays.\n+/// The arrays' types must be equal.\n+/// # Example\n+/// ```\n+/// use arrow::array::{build_compare, Int32Array};\n+///\n+/// # fn main() -> arrow::error::Result<()> {\n+/// let array1 = Int32Array::from(vec![1, 2]);\n+/// let array2 = Int32Array::from(vec![3, 4]);\n+///\n+/// let cmp = build_compare(&array1, &array2)?;\n+///\n+/// // 1 (index 0 of array1) is smaller than 4 (index 1 of array2)\n+/// assert_eq!(std::cmp::Ordering::Less, (cmp)(0, 1));\n+/// # Ok(())\n+/// # }\n+/// ```\n+// This is a factory of comparisons.\n+// The lifetime 'a enforces that we cannot use the closure beyond any of the array's lifetime.\n+pub fn build_compare<'a>(left: &'a Array, right: &'a Array) -> Result<DynComparator<'a>> {\n+    use DataType::*;\n+    use IntervalUnit::*;\n+    use TimeUnit::*;\n+    Ok(match (left.data_type(), right.data_type()) {\n+        (a, b) if a != b => {\n+            return Err(ArrowError::InvalidArgumentError(\n+                \"Can't compare arrays of different types\".to_string(),\n+            ));\n+        }\n+        (Boolean, Boolean) => compare_primitives::<BooleanType>(left, right),\n+        (UInt8, UInt8) => compare_primitives::<UInt8Type>(left, right),\n+        (UInt16, UInt16) => compare_primitives::<UInt16Type>(left, right),\n+        (UInt32, UInt32) => compare_primitives::<UInt32Type>(left, right),\n+        (UInt64, UInt64) => compare_primitives::<UInt64Type>(left, right),\n+        (Int8, Int8) => compare_primitives::<Int8Type>(left, right),\n+        (Int16, Int16) => compare_primitives::<Int16Type>(left, right),\n+        (Int32, Int32) => compare_primitives::<Int32Type>(left, right),\n+        (Int64, Int64) => compare_primitives::<Int64Type>(left, right),\n+        (Float32, Float32) => compare_float::<Float32Type>(left, right),\n+        (Float64, Float64) => compare_float::<Float64Type>(left, right),\n+        (Date32(_), Date32(_)) => compare_primitives::<Date32Type>(left, right),\n+        (Date64(_), Date64(_)) => compare_primitives::<Date64Type>(left, right),\n+        (Time32(Second), Time32(Second)) => {\n+            compare_primitives::<Time32SecondType>(left, right)\n+        }\n+        (Time32(Millisecond), Time32(Millisecond)) => {\n+            compare_primitives::<Time32MillisecondType>(left, right)\n+        }\n+        (Time64(Microsecond), Time64(Microsecond)) => {\n+            compare_primitives::<Time64MicrosecondType>(left, right)\n+        }\n+        (Time64(Nanosecond), Time64(Nanosecond)) => {\n+            compare_primitives::<Time64NanosecondType>(left, right)\n+        }\n+        (Timestamp(Second, _), Timestamp(Second, _)) => {\n+            compare_primitives::<TimestampSecondType>(left, right)\n+        }\n+        (Timestamp(Millisecond, _), Timestamp(Millisecond, _)) => {\n+            compare_primitives::<TimestampMillisecondType>(left, right)\n+        }\n+        (Timestamp(Microsecond, _), Timestamp(Microsecond, _)) => {\n+            compare_primitives::<TimestampMicrosecondType>(left, right)\n+        }\n+        (Timestamp(Nanosecond, _), Timestamp(Nanosecond, _)) => {\n+            compare_primitives::<TimestampNanosecondType>(left, right)\n+        }\n+        (Interval(YearMonth), Interval(YearMonth)) => {\n+            compare_primitives::<IntervalYearMonthType>(left, right)\n+        }\n+        (Interval(DayTime), Interval(DayTime)) => {\n+            compare_primitives::<IntervalDayTimeType>(left, right)\n+        }\n+        (Duration(Second), Duration(Second)) => {\n+            compare_primitives::<DurationSecondType>(left, right)\n+        }\n+        (Duration(Millisecond), Duration(Millisecond)) => {\n+            compare_primitives::<DurationMillisecondType>(left, right)\n+        }\n+        (Duration(Microsecond), Duration(Microsecond)) => {\n+            compare_primitives::<DurationMicrosecondType>(left, right)\n+        }\n+        (Duration(Nanosecond), Duration(Nanosecond)) => {\n+            compare_primitives::<DurationNanosecondType>(left, right)\n+        }\n+        (Utf8, Utf8) => compare_string::<i32>(left, right),\n+        (LargeUtf8, LargeUtf8) => compare_string::<i64>(left, right),\n+        (\n+            Dictionary(key_type_lhs, value_type_lhs),\n+            Dictionary(key_type_rhs, value_type_rhs),\n+        ) => {\n+            if value_type_lhs.as_ref() != &DataType::Utf8\n+                || value_type_rhs.as_ref() != &DataType::Utf8\n+            {\n+                return Err(ArrowError::InvalidArgumentError(\n+                    \"Arrow still does not support comparisons of non-string dictionary arrays\"\n\nReview comment:\n       This code is as it was here.\r\n   \r\n   FYI I did try to make this for arbitrary types, and I was very (very) close from having it one done, but it requires some unsafe usage, and so I left it for a separate PR. The relevant thread is here: https://users.rust-lang.org/t/how-to-move-values-to-closure-that-indirectly-depends-on-them/50586\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-28T03:52:17.637+0000",
                    "updated": "2020-10-28T03:52:17.637+0000",
                    "started": "2020-10-28T03:52:17.636+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "505525",
                    "issueId": "13337037"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037/worklog/506059",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao closed pull request #8517:\nURL: https://github.com/apache/arrow/pull/8517\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-29T04:49:49.746+0000",
                    "updated": "2020-10-29T04:49:49.746+0000",
                    "started": "2020-10-29T04:49:49.746+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "506059",
                    "issueId": "13337037"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 6600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1d9a2388[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5665b467[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@eb5e014[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7508bb29[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2d393998[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@1711b392[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@36854424[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@6e4602e[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@62757c93[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@7862ce6c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@64da0120[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@419af885[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 6600,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Oct 29 04:49:38 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-10-29T04:49:38.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10381/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2020-10-24T16:19:17.000+0000",
        "updated": "2020-10-29T04:49:50.000+0000",
        "timeoriginalestimate": null,
        "description": "Currently, the code to sort is centered around creating an array that can be sorted. This is useful for intra-array comparison, but does not allow things like `merge-sort`, where a comparison between two arrays (of the same data type) is needed.\r\n\r\nThe goal of this issue is to generalize the current code to support both.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 6600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Generalize Arrow to support MergeSort",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13337037/comment/17222705",
                    "id": "17222705",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
                        "name": "jorgecarleitao",
                        "key": "jorgecarleitao",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
                        },
                        "displayName": "Jorge Leit\u00e3o",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 8517\n[https://github.com/apache/arrow/pull/8517]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
                        "name": "jorgecarleitao",
                        "key": "jorgecarleitao",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
                        },
                        "displayName": "Jorge Leit\u00e3o",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2020-10-29T04:49:38.927+0000",
                    "updated": "2020-10-29T04:49:38.927+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0jz54:",
        "customfield_12314139": null
    }
}