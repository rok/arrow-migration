{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13442195",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195",
    "key": "ARROW-16389",
    "fields": {
        "fixVersions": [],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12640556",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12640556",
                "type": {
                    "id": "12310051",
                    "name": "Supercedes",
                    "inward": "is superceded by",
                    "outward": "supercedes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"
                },
                "outwardIssue": {
                    "id": "13403991",
                    "key": "ARROW-14163",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13403991",
                    "fields": {
                        "summary": "[C++] Naive spillover implementation for join",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sakras",
            "name": "sakras",
            "key": "sakras",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sasha Krassovsky",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/3",
            "description": "This issue is being actively worked on at the moment by the assignee.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
            "name": "In Progress",
            "id": "3",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                "id": 4,
                "key": "indeterminate",
                "colorName": "yellow",
                "name": "In Progress"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 37800,
            "total": 37800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 37800,
            "total": 37800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16389/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 63,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/793534",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer opened a new pull request, #13669:\nURL: https://github.com/apache/arrow/pull/13669\n\n   Adds support for spilling data to disk during hash join. \n\n\n",
                    "created": "2022-07-21T05:03:35.035+0000",
                    "updated": "2022-07-21T05:03:35.035+0000",
                    "started": "2022-07-21T05:03:35.034+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "793534",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/793536",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#issuecomment-1191042363\n\n   https://issues.apache.org/jira/browse/ARROW-16389\n\n\n",
                    "created": "2022-07-21T05:04:33.758+0000",
                    "updated": "2022-07-21T05:04:33.758+0000",
                    "started": "2022-07-21T05:04:33.757+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "793536",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/793730",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r926657650\n\n\n##########\ncpp/src/arrow/memory_pool_internal.h:\n##########\n@@ -26,7 +26,7 @@ namespace memory_pool {\n \n namespace internal {\n \n-static constexpr size_t kAlignment = 64;\n+static constexpr size_t kAlignment = 512;\n\nReview Comment:\n   This is not going to work.  The impact would be too large.  Is this because you are using direct I/O below?  If so,we could potentially make the alignment configurable and create a custom memory pool and require users that want direct I/O to use the custom memory pool.\n\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.cc:\n##########\n@@ -0,0 +1,253 @@\n+#include \"spilling_util.h\"\n+\n+namespace arrow\n+{\n+namespace compute\n+{\n+\n+    struct ArrayInfo\n+    {\n+        int64_t num_children;\n+        std::array<std::shared_ptr<Buffer>, 3> bufs;\n+        std::array<size_t, 3> sizes;\n+        bool has_dict;\n+    };\n+\n+    struct SpillFile::BatchInfo\n+    {\n+        int64_t start;\n+        std::vector<ArrayInfo> arrays;\n+    };\n+\n+#ifdef _WIN32\n+#include \"windows_compatibility.h\"\n+\n+const FileHandle kInvalidHandle = INVALID_HANDLE_VALUE;\n+\n+static Result<FileHandle> OpenTemporaryFile()\n\nReview Comment:\n   We already have some temporary file handling utilities in util/io_util.cc.  Is there a reason you couldn't reuse those?  Also, should this be a temporary directory anyway?  It seems like forcing users to configure and specify a spilling directory might help them to be more aware of what is going on.\n\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.cc:\n##########\n@@ -0,0 +1,253 @@\n+#include \"spilling_util.h\"\n+\n+namespace arrow\n+{\n+namespace compute\n+{\n+\n+    struct ArrayInfo\n+    {\n+        int64_t num_children;\n+        std::array<std::shared_ptr<Buffer>, 3> bufs;\n+        std::array<size_t, 3> sizes;\n+        bool has_dict;\n+    };\n+\n+    struct SpillFile::BatchInfo\n+    {\n+        int64_t start;\n+        std::vector<ArrayInfo> arrays;\n+    };\n+\n+#ifdef _WIN32\n+#include \"windows_compatibility.h\"\n+\n+const FileHandle kInvalidHandle = INVALID_HANDLE_VALUE;\n+\n+static Result<FileHandle> OpenTemporaryFile()\n+{\n+    constexpr DWORD kTempFileNameSize = MAX_PATH + 1;\n+    wchar_t tmp_name_buf[kTempFileNameSize];\n+    wchar_t tmp_path_buf[kTempFileNameSize];\n+\n+    DWORD ret;\n+    ret = GetTempPath2W(kTempFileNameSize, tmp_path_buf);\n+    if(ret > kTempFileNameSize || ret == 0)\n+        return Status::IOError();\n+    if(GetTempFileNameW(tmp_path_buf, L\"ARROW_TMP\", 0, tmp_name_buf) == 0)\n+        return Status::IOError();\n+\n+    HANDLE file_handle = CreateFileA(\n+        tmp_name_buf,\n+        GENERIC_READ | GENERIC_WRITE | FILE_APPEND_DATA,\n+        0,\n+        NULL,\n+        CREATE_ALWAYS,\n+        FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,\n+        NULL);\n+    if(file_handle == INVALID_HANDLE_VALUE)\n+        return Status::IOError(\"Failed to create temp file\");\n+    return file_handle;\n+}\n+\n+static Status CloseTemporaryFile(FileHandle handle)\n+{\n+    if(!CloseHandle(handle))\n+        return Status::IOError(\"Failed to close temp file\");\n+    return Status::OK();\n+}\n+\n+static Status WriteBatch_PlatformSpecific(FileHandle handle, const SpillFile::BatchInfo &info)\n+{\n+    OVERLAPPED overlapped;\n+    int64_t offset = info.start;\n+    for(const ArrayInfo &arr : info.arrays)\n+    {\n+        for(int i = 0; i < 3; i++)\n+        {\n+            if(info.bufs[i] != 0)\n+            {\n+                overlapped.Offset = static_cast<DWORD>(offset);\n+                overlapped.OffsetHigh = static_cast<DWORD>(offset >> 32);\n+                if(!WriteFile(\n+                       handle,\n+                       info.bufs[i]->data(),\n+                       info.bufs[i]->size(),\n+                       NULL,\n+                       &overlapped))\n+                    return Status::IOError(\"Failed to spill!\");\n+                offset += info.sizes[i];\n+            }\n+        }\n+    }\n+    return Status::OK();\n+}\n+#else\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <sys/uio.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+\n+Result<FileHandle> OpenTemporaryFile()\n+{\n+    const char *selectors[] = { \"TMPDIR\", \"TMP\", \"TEMP\", \"TEMPDIR\" };\n+    constexpr size_t kNumSelectors = sizeof(selectors) / sizeof(selectors[0]);\n+#ifdef __ANDROID__\n+    const char *backup = \"/data/local/tmp/\";\n+#else\n+    const char *backup = \"/tmp/\";\n+#endif\n+    const char *tmp_dir = backup;\n+    for(size_t i = 0; i < kNumSelectors; i++)\n+    {\n+        const char *env = getenv(selectors[i]);\n+        if(env)\n+        {\n+            tmp_dir = env;\n+            break;\n+        }\n+    }\n+    size_t tmp_dir_length = std::strlen(tmp_dir);\n+\n+    const char *tmp_name_template = \"/ARROW_TMP_XXXXXX\";\n+    size_t tmp_name_length = std::strlen(tmp_name_template);\n+\n+    constexpr int kFileNameSize = 1024;\n+\n+    if((tmp_dir_length + tmp_name_length) >= kFileNameSize)\n+    {\n+        tmp_dir = backup;\n+        tmp_dir_length = std::strlen(backup);\n+    }\n+\n+    char name[kFileNameSize + 1] = {};\n+    std::strncpy(name, tmp_dir, kFileNameSize);\n+    std::strncpy(name + tmp_dir_length, tmp_name_template, kFileNameSize - tmp_dir_length);\n+\n+#ifdef __APPLE__\n+    int fd = mkstemp(name);\n+    if(fd == kInvalidHandle)\n+        return Status::IOError(strerror(errno));\n+    if(fcntl(fd, F_NOCACHE, 1) == -1)\n+        return Status::IOError(strerror(errno));\n+#else    \n+    int fd = mkostemp(name, O_DIRECT);\n\nReview Comment:\n   There was some discussion of direct I/O in #13640.  I think there are concerns and it should at least be opt-in until we have a better picture of real world performance.  Especially considering the alignment requirements.\n\n\n\n",
                    "created": "2022-07-21T13:19:11.006+0000",
                    "updated": "2022-07-21T13:19:11.006+0000",
                    "started": "2022-07-21T13:19:11.006+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "793730",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/793891",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r926999451\n\n\n##########\ncpp/src/arrow/memory_pool_internal.h:\n##########\n@@ -26,7 +26,7 @@ namespace memory_pool {\n \n namespace internal {\n \n-static constexpr size_t kAlignment = 64;\n+static constexpr size_t kAlignment = 512;\n\nReview Comment:\n   Yeah I was going to add the option later (I wanted to change it to this for now just so I could test other stuff). \n\n\n\n",
                    "created": "2022-07-21T18:42:38.690+0000",
                    "updated": "2022-07-21T18:42:38.690+0000",
                    "started": "2022-07-21T18:42:38.690+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "793891",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/793899",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r927014378\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.cc:\n##########\n@@ -0,0 +1,253 @@\n+#include \"spilling_util.h\"\n+\n+namespace arrow\n+{\n+namespace compute\n+{\n+\n+    struct ArrayInfo\n+    {\n+        int64_t num_children;\n+        std::array<std::shared_ptr<Buffer>, 3> bufs;\n+        std::array<size_t, 3> sizes;\n+        bool has_dict;\n+    };\n+\n+    struct SpillFile::BatchInfo\n+    {\n+        int64_t start;\n+        std::vector<ArrayInfo> arrays;\n+    };\n+\n+#ifdef _WIN32\n+#include \"windows_compatibility.h\"\n+\n+const FileHandle kInvalidHandle = INVALID_HANDLE_VALUE;\n+\n+static Result<FileHandle> OpenTemporaryFile()\n+{\n+    constexpr DWORD kTempFileNameSize = MAX_PATH + 1;\n+    wchar_t tmp_name_buf[kTempFileNameSize];\n+    wchar_t tmp_path_buf[kTempFileNameSize];\n+\n+    DWORD ret;\n+    ret = GetTempPath2W(kTempFileNameSize, tmp_path_buf);\n+    if(ret > kTempFileNameSize || ret == 0)\n+        return Status::IOError();\n+    if(GetTempFileNameW(tmp_path_buf, L\"ARROW_TMP\", 0, tmp_name_buf) == 0)\n+        return Status::IOError();\n+\n+    HANDLE file_handle = CreateFileA(\n+        tmp_name_buf,\n+        GENERIC_READ | GENERIC_WRITE | FILE_APPEND_DATA,\n+        0,\n+        NULL,\n+        CREATE_ALWAYS,\n+        FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,\n+        NULL);\n+    if(file_handle == INVALID_HANDLE_VALUE)\n+        return Status::IOError(\"Failed to create temp file\");\n+    return file_handle;\n+}\n+\n+static Status CloseTemporaryFile(FileHandle handle)\n+{\n+    if(!CloseHandle(handle))\n+        return Status::IOError(\"Failed to close temp file\");\n+    return Status::OK();\n+}\n+\n+static Status WriteBatch_PlatformSpecific(FileHandle handle, const SpillFile::BatchInfo &info)\n+{\n+    OVERLAPPED overlapped;\n+    int64_t offset = info.start;\n+    for(const ArrayInfo &arr : info.arrays)\n+    {\n+        for(int i = 0; i < 3; i++)\n+        {\n+            if(info.bufs[i] != 0)\n+            {\n+                overlapped.Offset = static_cast<DWORD>(offset);\n+                overlapped.OffsetHigh = static_cast<DWORD>(offset >> 32);\n+                if(!WriteFile(\n+                       handle,\n+                       info.bufs[i]->data(),\n+                       info.bufs[i]->size(),\n+                       NULL,\n+                       &overlapped))\n+                    return Status::IOError(\"Failed to spill!\");\n+                offset += info.sizes[i];\n+            }\n+        }\n+    }\n+    return Status::OK();\n+}\n+#else\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <sys/uio.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+\n+Result<FileHandle> OpenTemporaryFile()\n+{\n+    const char *selectors[] = { \"TMPDIR\", \"TMP\", \"TEMP\", \"TEMPDIR\" };\n+    constexpr size_t kNumSelectors = sizeof(selectors) / sizeof(selectors[0]);\n+#ifdef __ANDROID__\n+    const char *backup = \"/data/local/tmp/\";\n+#else\n+    const char *backup = \"/tmp/\";\n+#endif\n+    const char *tmp_dir = backup;\n+    for(size_t i = 0; i < kNumSelectors; i++)\n+    {\n+        const char *env = getenv(selectors[i]);\n+        if(env)\n+        {\n+            tmp_dir = env;\n+            break;\n+        }\n+    }\n+    size_t tmp_dir_length = std::strlen(tmp_dir);\n+\n+    const char *tmp_name_template = \"/ARROW_TMP_XXXXXX\";\n+    size_t tmp_name_length = std::strlen(tmp_name_template);\n+\n+    constexpr int kFileNameSize = 1024;\n+\n+    if((tmp_dir_length + tmp_name_length) >= kFileNameSize)\n+    {\n+        tmp_dir = backup;\n+        tmp_dir_length = std::strlen(backup);\n+    }\n+\n+    char name[kFileNameSize + 1] = {};\n+    std::strncpy(name, tmp_dir, kFileNameSize);\n+    std::strncpy(name + tmp_dir_length, tmp_name_template, kFileNameSize - tmp_dir_length);\n+\n+#ifdef __APPLE__\n+    int fd = mkstemp(name);\n+    if(fd == kInvalidHandle)\n+        return Status::IOError(strerror(errno));\n+    if(fcntl(fd, F_NOCACHE, 1) == -1)\n+        return Status::IOError(strerror(errno));\n+#else    \n+    int fd = mkostemp(name, O_DIRECT);\n\nReview Comment:\n   Alignment requirements are not an issue since we're partitioning everything anyway. We will just make the partitioned batches aligned. \r\n   \r\n   I didn't understand that discussion, the point of spilling is to get the stuff out of memory as soon as possible and avoid memcpy-ing it around into staging buffers. \n\n\n\n",
                    "created": "2022-07-21T19:02:10.066+0000",
                    "updated": "2022-07-21T19:02:10.066+0000",
                    "started": "2022-07-21T19:02:10.066+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "793899",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/793902",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r927015664\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.cc:\n##########\n@@ -0,0 +1,253 @@\n+#include \"spilling_util.h\"\n+\n+namespace arrow\n+{\n+namespace compute\n+{\n+\n+    struct ArrayInfo\n+    {\n+        int64_t num_children;\n+        std::array<std::shared_ptr<Buffer>, 3> bufs;\n+        std::array<size_t, 3> sizes;\n+        bool has_dict;\n+    };\n+\n+    struct SpillFile::BatchInfo\n+    {\n+        int64_t start;\n+        std::vector<ArrayInfo> arrays;\n+    };\n+\n+#ifdef _WIN32\n+#include \"windows_compatibility.h\"\n+\n+const FileHandle kInvalidHandle = INVALID_HANDLE_VALUE;\n+\n+static Result<FileHandle> OpenTemporaryFile()\n\nReview Comment:\n   The only thing in `io_util` that I saw was creating a temporary directory, nothing to do with making temp files. \n\n\n\n",
                    "created": "2022-07-21T19:03:55.189+0000",
                    "updated": "2022-07-21T19:03:55.189+0000",
                    "started": "2022-07-21T19:03:55.188+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "793902",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/793907",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r927017388\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.cc:\n##########\n@@ -0,0 +1,253 @@\n+#include \"spilling_util.h\"\n+\n+namespace arrow\n+{\n+namespace compute\n+{\n+\n+    struct ArrayInfo\n+    {\n+        int64_t num_children;\n+        std::array<std::shared_ptr<Buffer>, 3> bufs;\n+        std::array<size_t, 3> sizes;\n+        bool has_dict;\n+    };\n+\n+    struct SpillFile::BatchInfo\n+    {\n+        int64_t start;\n+        std::vector<ArrayInfo> arrays;\n+    };\n+\n+#ifdef _WIN32\n+#include \"windows_compatibility.h\"\n+\n+const FileHandle kInvalidHandle = INVALID_HANDLE_VALUE;\n+\n+static Result<FileHandle> OpenTemporaryFile()\n\nReview Comment:\n   Regarding forcing them to make a spilling directory, ideally I'd like spilling to be completely transparent to them. If they do care, they can always set the environment variable. \n\n\n\n",
                    "created": "2022-07-21T19:06:15.384+0000",
                    "updated": "2022-07-21T19:06:15.384+0000",
                    "started": "2022-07-21T19:06:15.384+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "793907",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/800135",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r943998671\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.cc:\n##########\n@@ -0,0 +1,253 @@\n+#include \"spilling_util.h\"\n+\n+namespace arrow\n+{\n+namespace compute\n+{\n+\n+    struct ArrayInfo\n+    {\n+        int64_t num_children;\n+        std::array<std::shared_ptr<Buffer>, 3> bufs;\n+        std::array<size_t, 3> sizes;\n+        bool has_dict;\n+    };\n+\n+    struct SpillFile::BatchInfo\n+    {\n+        int64_t start;\n+        std::vector<ArrayInfo> arrays;\n+    };\n+\n+#ifdef _WIN32\n+#include \"windows_compatibility.h\"\n+\n+const FileHandle kInvalidHandle = INVALID_HANDLE_VALUE;\n+\n+static Result<FileHandle> OpenTemporaryFile()\n+{\n+    constexpr DWORD kTempFileNameSize = MAX_PATH + 1;\n+    wchar_t tmp_name_buf[kTempFileNameSize];\n+    wchar_t tmp_path_buf[kTempFileNameSize];\n+\n+    DWORD ret;\n+    ret = GetTempPath2W(kTempFileNameSize, tmp_path_buf);\n+    if(ret > kTempFileNameSize || ret == 0)\n+        return Status::IOError();\n+    if(GetTempFileNameW(tmp_path_buf, L\"ARROW_TMP\", 0, tmp_name_buf) == 0)\n+        return Status::IOError();\n+\n+    HANDLE file_handle = CreateFileA(\n+        tmp_name_buf,\n+        GENERIC_READ | GENERIC_WRITE | FILE_APPEND_DATA,\n+        0,\n+        NULL,\n+        CREATE_ALWAYS,\n+        FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,\n+        NULL);\n+    if(file_handle == INVALID_HANDLE_VALUE)\n+        return Status::IOError(\"Failed to create temp file\");\n+    return file_handle;\n+}\n+\n+static Status CloseTemporaryFile(FileHandle handle)\n+{\n+    if(!CloseHandle(handle))\n+        return Status::IOError(\"Failed to close temp file\");\n+    return Status::OK();\n+}\n+\n+static Status WriteBatch_PlatformSpecific(FileHandle handle, const SpillFile::BatchInfo &info)\n+{\n+    OVERLAPPED overlapped;\n+    int64_t offset = info.start;\n+    for(const ArrayInfo &arr : info.arrays)\n+    {\n+        for(int i = 0; i < 3; i++)\n+        {\n+            if(info.bufs[i] != 0)\n+            {\n+                overlapped.Offset = static_cast<DWORD>(offset);\n+                overlapped.OffsetHigh = static_cast<DWORD>(offset >> 32);\n+                if(!WriteFile(\n+                       handle,\n+                       info.bufs[i]->data(),\n+                       info.bufs[i]->size(),\n+                       NULL,\n+                       &overlapped))\n+                    return Status::IOError(\"Failed to spill!\");\n+                offset += info.sizes[i];\n+            }\n+        }\n+    }\n+    return Status::OK();\n+}\n+#else\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <sys/uio.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+\n+Result<FileHandle> OpenTemporaryFile()\n+{\n+    const char *selectors[] = { \"TMPDIR\", \"TMP\", \"TEMP\", \"TEMPDIR\" };\n+    constexpr size_t kNumSelectors = sizeof(selectors) / sizeof(selectors[0]);\n+#ifdef __ANDROID__\n+    const char *backup = \"/data/local/tmp/\";\n+#else\n+    const char *backup = \"/tmp/\";\n+#endif\n+    const char *tmp_dir = backup;\n+    for(size_t i = 0; i < kNumSelectors; i++)\n+    {\n+        const char *env = getenv(selectors[i]);\n+        if(env)\n+        {\n+            tmp_dir = env;\n+            break;\n+        }\n+    }\n+    size_t tmp_dir_length = std::strlen(tmp_dir);\n+\n+    const char *tmp_name_template = \"/ARROW_TMP_XXXXXX\";\n+    size_t tmp_name_length = std::strlen(tmp_name_template);\n+\n+    constexpr int kFileNameSize = 1024;\n+\n+    if((tmp_dir_length + tmp_name_length) >= kFileNameSize)\n+    {\n+        tmp_dir = backup;\n+        tmp_dir_length = std::strlen(backup);\n+    }\n+\n+    char name[kFileNameSize + 1] = {};\n+    std::strncpy(name, tmp_dir, kFileNameSize);\n+    std::strncpy(name + tmp_dir_length, tmp_name_template, kFileNameSize - tmp_dir_length);\n+\n+#ifdef __APPLE__\n+    int fd = mkstemp(name);\n+    if(fd == kInvalidHandle)\n+        return Status::IOError(strerror(errno));\n+    if(fcntl(fd, F_NOCACHE, 1) == -1)\n+        return Status::IOError(strerror(errno));\n+#else    \n+    int fd = mkostemp(name, O_DIRECT);\n\nReview Comment:\n   > the point of spilling is to get the stuff out of memory as soon as possible and avoid memcpy-ing it around into staging buffers.\r\n   \r\n   This is good point.\r\n   \r\n   > Alignment requirements are not an issue since we're partitioning everything anyway. We will just make the partitioned batches aligned.\r\n   \r\n   Sounds good.\n\n\n\n",
                    "created": "2022-08-11T22:52:15.280+0000",
                    "updated": "2022-08-11T22:52:15.280+0000",
                    "started": "2022-08-11T22:52:15.280+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800135",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/800136",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r943999661\n\n\n##########\ncpp/src/arrow/compute/light_array.h:\n##########\n@@ -348,11 +349,13 @@ class ARROW_EXPORT ExecBatchBuilder {\n   ExecBatch Flush();\n \n   int num_rows() const { return values_.empty() ? 0 : values_[0].num_rows(); }\n+  bool is_full() const { return num_rows() == num_rows_max(); }\n \n   static int num_rows_max() { return 1 << kLogNumRows; }\n \n  private:\n   static constexpr int kLogNumRows = 15;\n+  static constexpr int64_t kAlignment = 512;\n\nReview Comment:\n   I'm not quite sure I understand when this is used vs `alignment_`.  Also, can you add a comment or clarify in some way how this is different than `MemoryPool::kDefaultAlignment` and what the purpose is for the constant?\n\n\n\n##########\ncpp/src/arrow/memory_pool.h:\n##########\n@@ -71,21 +73,25 @@ class ARROW_EXPORT MemoryPool {\n   /// Allocate a new memory region of at least size bytes.\n   ///\n   /// The allocated region shall be 64-byte aligned.\n-  virtual Status Allocate(int64_t size, uint8_t** out) = 0;\n+  Status Allocate(int64_t size, uint8_t** out) { return Allocate(size, kDefaultAlignment, out); }\n\nReview Comment:\n   I may be reading this wrong but it looks like you added alignment support for jemalloc but not any of the other allocators.  Is that correct?  Is this a todo or am I missing something?\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,173 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+\n+#pragma once\n+\n+namespace arrow\n+{\n+    namespace internal\n+    {\n+        class CpuInfo;\n+    }\n+\n+    using io::IOContext;\n+    namespace compute\n+    {\n+        struct ARROW_EXPORT QueryOptions\n+        {\n+            QueryOptions();\n+            // 0 means unlimited\n+            size_t max_memory_bytes;\n+\n+            /// \\brief Should the plan use a legacy batching strategy\n+            ///\n+            /// This is currently in place only to support the Scanner::ToTable\n+            /// method.  This method relies on batch indices from the scanner\n+            /// remaining consistent.  This is impractical in the ExecPlan which\n+            /// might slice batches as needed (e.g. for a join)\n+            ///\n+            /// However, it still works for simple plans and this is the only way\n+            /// we have at the moment for maintaining implicit order.\n+            bool use_legacy_batching;\n+        };\n+\n+        class ARROW_EXPORT QueryContext\n+        {\n+        public:\n+        QueryContext(\n+            QueryOptions opts = {},\n+            ExecContext exec_context = *default_exec_context());\n+\n+            Status Init(size_t max_num_threads);\n+\n+            const ::arrow::internal::CpuInfo *cpu_info() const;\n+            const QueryOptions &options() const { return options_; }\n+            MemoryPool *memory_pool() const { return exec_context_.memory_pool(); }\n+            ::arrow::internal::Executor *executor() const { return exec_context_.executor(); }\n+            ExecContext *exec_context() { return &exec_context_; }\n+            IOContext *io_context() { return &io_context_; }\n+            TaskScheduler *scheduler() { return task_scheduler_.get(); }\n+            util::AsyncTaskGroup *task_group() { return &task_group_; }\n+\n+            size_t GetThreadIndex();\n+            size_t max_concurrency() const;\n+            Result<util::TempVectorStack *> GetTempStack(size_t thread_index);\n+\n+            /// \\brief Start an external task\n+            ///\n+            /// This should be avoided if possible.  It is kept in for now for legacy\n+            /// purposes.  This should be called before the external task is started.  If\n+            /// a valid future is returned then it should be marked complete when the\n+            /// external task has finished.\n+            ///\n+            /// \\return an invalid future if the plan has already ended, otherwise this\n+            ///         returns a future that must be completed when the external task\n+            ///         finishes.\n+            Result<Future<>> BeginExternalTask();\n+\n+            /// \\brief Add a single function as a task to the query's task group\n+            ///        on the compute threadpool.\n+            ///\n+            /// \\param fn The task to run. Takes no arguments and returns a Status.\n+            Status ScheduleTask(std::function<Status()> fn);\n+            /// \\brief Add a single function as a task to the query's task group\n+            ///        on the compute threadpool.\n+            ///\n+            /// \\param fn The task to run. Takes the thread index and returns a Status.\n+            Status ScheduleTask(std::function<Status(size_t)> fn);\n+            /// \\brief Add a single function as a task to the query's task group on\n+            ///        the IO thread pool\n+            ///\n+            /// \\param fn The task to run. Returns a status.\n+            Status ScheduleIOTask(std::function<Status()> fn);\n+\n+            // Register/Start TaskGroup is a way of performing a \"Parallel For\" pattern:\n+            // - The task function takes the thread index and the index of the task\n+            // - The on_finished function takes the thread index\n+            // Returns an integer ID that will be used to reference the task group in\n+            // StartTaskGroup. At runtime, call StartTaskGroup with the ID and the number of times\n+            // you'd like the task to be executed. The need to register a task group before use will\n+            // be removed after we rewrite the scheduler.\n+            /// \\brief Register a \"parallel for\" task group with the scheduler\n+            ///\n+            /// \\param task The function implementing the task. Takes the thread_index and\n+            ///             the task index.\n+            /// \\param on_finished The function that gets run once all tasks have been completed.\n+            /// Takes the thread_index.\n+            ///\n+            /// Must be called inside of ExecNode::Init.\n+            int RegisterTaskGroup(std::function<Status(size_t, int64_t)> task,\n+                                  std::function<Status(size_t)> on_finished);\n+\n+            /// \\brief Start the task group with the specified ID. This can only\n+            ///        be called once per task_group_id.\n+            ///\n+            /// \\param task_group_id The ID  of the task group to run\n+            /// \\param num_tasks The number of times to run the task\n+            Status StartTaskGroup(int task_group_id, int64_t num_tasks);\n+\n+            struct TempFileIOMark\n+            {\n+                QueryContext *ctx_;\n+                size_t bytes_;\n+                \n+                TempFileIOMark(QueryContext *ctx, size_t bytes)\n+                    :\n+                    ctx_(ctx),\n+                    bytes_(bytes)\n+                {\n+                    ctx_->in_flight_bytes_to_disk_ += bytes_;\n+                }\n+\n+                ~TempFileIOMark()\n+                {\n+                    ctx_->in_flight_bytes_to_disk_ -= bytes_;\n+                }\n+            };\n+\n+            TempFileIOMark ReportTempFileIO(size_t bytes)\n+            {\n+                return { this, bytes };\n+            }\n+\n+        private:\n+            QueryOptions options_;\n+            // To be replaced with Acero-specific context once scheduler is done and\n+            // we don't need ExecContext for kernels\n\nReview Comment:\n   We can mostly keep todos like this in JIRAs I think unless trying to explain away something weird or unusual (which this is not).  Although I am probably the worst offender for rambling comments.\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,173 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+\n+#pragma once\n+\n+namespace arrow\n+{\n+    namespace internal\n+    {\n+        class CpuInfo;\n+    }\n+\n+    using io::IOContext;\n+    namespace compute\n+    {\n+        struct ARROW_EXPORT QueryOptions\n+        {\n+            QueryOptions();\n+            // 0 means unlimited\n+            size_t max_memory_bytes;\n+\n+            /// \\brief Should the plan use a legacy batching strategy\n+            ///\n+            /// This is currently in place only to support the Scanner::ToTable\n+            /// method.  This method relies on batch indices from the scanner\n+            /// remaining consistent.  This is impractical in the ExecPlan which\n+            /// might slice batches as needed (e.g. for a join)\n+            ///\n+            /// However, it still works for simple plans and this is the only way\n+            /// we have at the moment for maintaining implicit order.\n+            bool use_legacy_batching;\n+        };\n+\n+        class ARROW_EXPORT QueryContext\n+        {\n+        public:\n+        QueryContext(\n+            QueryOptions opts = {},\n+            ExecContext exec_context = *default_exec_context());\n+\n+            Status Init(size_t max_num_threads);\n+\n+            const ::arrow::internal::CpuInfo *cpu_info() const;\n+            const QueryOptions &options() const { return options_; }\n+            MemoryPool *memory_pool() const { return exec_context_.memory_pool(); }\n+            ::arrow::internal::Executor *executor() const { return exec_context_.executor(); }\n+            ExecContext *exec_context() { return &exec_context_; }\n+            IOContext *io_context() { return &io_context_; }\n\nReview Comment:\n   At first this surprised me since `io_context` is really only needed by the scan & write nodes but then I remembered we were doing spilling :).  So this is the `io_context` used to spill to disk then?\n\n\n\n##########\ncpp/src/arrow/compute/light_array.h:\n##########\n@@ -348,11 +349,13 @@ class ARROW_EXPORT ExecBatchBuilder {\n   ExecBatch Flush();\n \n   int num_rows() const { return values_.empty() ? 0 : values_[0].num_rows(); }\n+  bool is_full() const { return num_rows() == num_rows_max(); }\n \n   static int num_rows_max() { return 1 << kLogNumRows; }\n \n  private:\n   static constexpr int kLogNumRows = 15;\n+  static constexpr int64_t kAlignment = 512;\n\nReview Comment:\n   How confident are we that `512` will work for all disks?  What will happen if it doesn't?\n\n\n\n##########\ncpp/src/arrow/compute/exec/accumulation_queue.h:\n##########\n@@ -42,9 +45,11 @@ class AccumulationQueue {\n \n   void Concatenate(AccumulationQueue&& that);\n   void InsertBatch(ExecBatch batch);\n+  void InsertAt(ExecBatch batch, size_t idx);\n   int64_t row_count() { return row_count_; }\n   size_t batch_count() { return batches_.size(); }\n   bool empty() const { return batches_.empty(); }\n+  void Resize(size_t size) { batches_.resize(size); }\n\nReview Comment:\n   What are the semantics / expectations here?  Is this more like `std::vector::reserve` or `std::vector::resize`?  Would be good to add a comment pointing out that default-constructed (empty? invalid?) batches will fill the newly added space.  Is the newly added space usable?\n\n\n\n##########\ncpp/src/arrow/compute/exec/accumulation_queue.cc:\n##########\n@@ -15,13 +15,15 @@\n // specific language governing permissions and limitations\n // under the License.\n \n+#include \"arrow/util/atomic_util.h\"\n\nReview Comment:\n   Where is this file?  I can't seem to find it.\n\n\n\n##########\ncpp/src/arrow/util/io_util.h:\n##########\n@@ -410,5 +410,11 @@ uint64_t GetThreadId();\n ARROW_EXPORT\n int64_t GetCurrentRSS();\n \n+/// \\brief Get the total memory available to the system in bytes\n+///\n+/// This function supports Windows, Linux, and Mac and will return 0 otherwise\n+ARROW_EXPORT\n+int64_t GetTotalMemoryBytes();\n\nReview Comment:\n   Can we get a quick unit test on this?  Just something to make sure we get a value > 0 is probably sufficient.  That way we can know quickly if we add some CI environment where this isn't supported.\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,173 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+\n+#pragma once\n+\n+namespace arrow\n+{\n+    namespace internal\n+    {\n+        class CpuInfo;\n+    }\n+\n+    using io::IOContext;\n+    namespace compute\n+    {\n+        struct ARROW_EXPORT QueryOptions\n+        {\n+            QueryOptions();\n+            // 0 means unlimited\n+            size_t max_memory_bytes;\n+\n+            /// \\brief Should the plan use a legacy batching strategy\n+            ///\n+            /// This is currently in place only to support the Scanner::ToTable\n+            /// method.  This method relies on batch indices from the scanner\n+            /// remaining consistent.  This is impractical in the ExecPlan which\n+            /// might slice batches as needed (e.g. for a join)\n+            ///\n+            /// However, it still works for simple plans and this is the only way\n+            /// we have at the moment for maintaining implicit order.\n+            bool use_legacy_batching;\n+        };\n+\n+        class ARROW_EXPORT QueryContext\n+        {\n+        public:\n+        QueryContext(\n+            QueryOptions opts = {},\n+            ExecContext exec_context = *default_exec_context());\n+\n+            Status Init(size_t max_num_threads);\n+\n+            const ::arrow::internal::CpuInfo *cpu_info() const;\n+            const QueryOptions &options() const { return options_; }\n+            MemoryPool *memory_pool() const { return exec_context_.memory_pool(); }\n+            ::arrow::internal::Executor *executor() const { return exec_context_.executor(); }\n+            ExecContext *exec_context() { return &exec_context_; }\n+            IOContext *io_context() { return &io_context_; }\n+            TaskScheduler *scheduler() { return task_scheduler_.get(); }\n+            util::AsyncTaskGroup *task_group() { return &task_group_; }\n+\n+            size_t GetThreadIndex();\n\nReview Comment:\n   This would not have been my first guess where to find this method.  However, I think the reasoning is that we need the executor to get this info?  Or is this just because we are still using the old `ThreadIndexer` approach?  Ideally I guess I would like to someday see this as a base method in `ExecNode`?  Does that make sense?\n\n\n\n##########\ncpp/src/arrow/compute/exec/query_context.h:\n##########\n@@ -0,0 +1,173 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+\n+#pragma once\n+\n+namespace arrow\n+{\n+    namespace internal\n+    {\n+        class CpuInfo;\n+    }\n+\n+    using io::IOContext;\n+    namespace compute\n+    {\n+        struct ARROW_EXPORT QueryOptions\n+        {\n+            QueryOptions();\n+            // 0 means unlimited\n+            size_t max_memory_bytes;\n+\n+            /// \\brief Should the plan use a legacy batching strategy\n+            ///\n+            /// This is currently in place only to support the Scanner::ToTable\n+            /// method.  This method relies on batch indices from the scanner\n+            /// remaining consistent.  This is impractical in the ExecPlan which\n+            /// might slice batches as needed (e.g. for a join)\n+            ///\n+            /// However, it still works for simple plans and this is the only way\n+            /// we have at the moment for maintaining implicit order.\n+            bool use_legacy_batching;\n+        };\n+\n+        class ARROW_EXPORT QueryContext\n+        {\n+        public:\n+        QueryContext(\n+            QueryOptions opts = {},\n+            ExecContext exec_context = *default_exec_context());\n+\n+            Status Init(size_t max_num_threads);\n+\n+            const ::arrow::internal::CpuInfo *cpu_info() const;\n+            const QueryOptions &options() const { return options_; }\n+            MemoryPool *memory_pool() const { return exec_context_.memory_pool(); }\n+            ::arrow::internal::Executor *executor() const { return exec_context_.executor(); }\n+            ExecContext *exec_context() { return &exec_context_; }\n+            IOContext *io_context() { return &io_context_; }\n+            TaskScheduler *scheduler() { return task_scheduler_.get(); }\n+            util::AsyncTaskGroup *task_group() { return &task_group_; }\n+\n+            size_t GetThreadIndex();\n+            size_t max_concurrency() const;\n+            Result<util::TempVectorStack *> GetTempStack(size_t thread_index);\n+\n+            /// \\brief Start an external task\n+            ///\n+            /// This should be avoided if possible.  It is kept in for now for legacy\n+            /// purposes.  This should be called before the external task is started.  If\n+            /// a valid future is returned then it should be marked complete when the\n+            /// external task has finished.\n+            ///\n+            /// \\return an invalid future if the plan has already ended, otherwise this\n+            ///         returns a future that must be completed when the external task\n+            ///         finishes.\n+            Result<Future<>> BeginExternalTask();\n+\n+            /// \\brief Add a single function as a task to the query's task group\n+            ///        on the compute threadpool.\n+            ///\n+            /// \\param fn The task to run. Takes no arguments and returns a Status.\n+            Status ScheduleTask(std::function<Status()> fn);\n+            /// \\brief Add a single function as a task to the query's task group\n+            ///        on the compute threadpool.\n+            ///\n+            /// \\param fn The task to run. Takes the thread index and returns a Status.\n+            Status ScheduleTask(std::function<Status(size_t)> fn);\n+            /// \\brief Add a single function as a task to the query's task group on\n+            ///        the IO thread pool\n+            ///\n+            /// \\param fn The task to run. Returns a status.\n+            Status ScheduleIOTask(std::function<Status()> fn);\n+\n+            // Register/Start TaskGroup is a way of performing a \"Parallel For\" pattern:\n+            // - The task function takes the thread index and the index of the task\n+            // - The on_finished function takes the thread index\n+            // Returns an integer ID that will be used to reference the task group in\n+            // StartTaskGroup. At runtime, call StartTaskGroup with the ID and the number of times\n+            // you'd like the task to be executed. The need to register a task group before use will\n+            // be removed after we rewrite the scheduler.\n+            /// \\brief Register a \"parallel for\" task group with the scheduler\n+            ///\n+            /// \\param task The function implementing the task. Takes the thread_index and\n+            ///             the task index.\n+            /// \\param on_finished The function that gets run once all tasks have been completed.\n+            /// Takes the thread_index.\n+            ///\n+            /// Must be called inside of ExecNode::Init.\n+            int RegisterTaskGroup(std::function<Status(size_t, int64_t)> task,\n+                                  std::function<Status(size_t)> on_finished);\n+\n+            /// \\brief Start the task group with the specified ID. This can only\n+            ///        be called once per task_group_id.\n+            ///\n+            /// \\param task_group_id The ID  of the task group to run\n+            /// \\param num_tasks The number of times to run the task\n+            Status StartTaskGroup(int task_group_id, int64_t num_tasks);\n+\n+            struct TempFileIOMark\n+            {\n+                QueryContext *ctx_;\n+                size_t bytes_;\n+                \n+                TempFileIOMark(QueryContext *ctx, size_t bytes)\n+                    :\n+                    ctx_(ctx),\n+                    bytes_(bytes)\n+                {\n+                    ctx_->in_flight_bytes_to_disk_ += bytes_;\n+                }\n+\n+                ~TempFileIOMark()\n+                {\n+                    ctx_->in_flight_bytes_to_disk_ -= bytes_;\n+                }\n+            };\n+\n+            TempFileIOMark ReportTempFileIO(size_t bytes)\n+            {\n+                return { this, bytes };\n+            }\n\nReview Comment:\n   This could use some comments / explanation.\n\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.h:\n##########\n@@ -0,0 +1,66 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"arrow/compute/exec/exec_plan.h\"\n+\n+namespace arrow\n+{\n+    namespace compute\n+    {\n+#ifdef _WIN32\n+        using FileHandle = void *;\n+        extern const FileHandle kInvalidHandle;\n+#else\n+        using FileHandle = int;\n+        constexpr FileHandle kInvalidHandle = -1;\n+#endif\n+\n+        class SpillFile\n+        {\n+        public:\n+\n+            // To spill a batch the following must be true:\n+            // - Row offset for each column must be 0.\n+            // - Column buffers must be aligned to 512 bits\n+            // - No column can be a scalar\n+            // These assumptions aren't as inconvenient as it seems because\n+            // typically batches will be partitioned before being spilled,\n+            // meaning the batches will come from ExecBatchBuilder, which\n+            // ensures these assumptions hold. \n+            Status SpillBatch(QueryContext *ctx, ExecBatch batch);\n+            Status ReadBackBatches(\n+                QueryContext *ctx,\n+                std::function<Status(size_t, ExecBatch)> fn,\n+                std::function<Status(size_t)> on_finished);\n+            Status Cleanup();\n\nReview Comment:\n   When would I call `Cleanup` and why?\n\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_join.h:\n##########\n@@ -0,0 +1,100 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <bitset>\n+\n+#include \"arrow/compute/exec/query_context.h\"\n+#include \"arrow/compute/exec/hash_join.h\"\n+#include \"arrow/compute/exec/accumulation_queue.h\"\n+\n+namespace arrow\n+{\n+    namespace compute\n+    {\n+        class SpillingHashJoin\n+        {\n+        public:\n+            using OutputBatchCallback = std::function<void(int64_t, ExecBatch)>;\n+            using BuildFinishedCallback = std::function<Status(size_t)>;\n+            using FinishedCallback = std::function<void(int64_t)>;\n+            using RegisterTaskGroupCallback = std::function<int(\n+                std::function<Status(size_t, int64_t)>, std::function<Status(size_t)>)>;\n+            using StartTaskGroupCallback = std::function<Status(int, int64_t)>;\n+            using PauseProbeSideCallback = std::function<void(int)>;\n+            using ResumeProbeSideCallback = std::function<void(int)>;\n+            using AbortContinuationImpl = std::function<void()>;\n+\n+            struct CallbackRecord\n+            {\n+                OutputBatchCallback output_batch_callback;\n+                BuildFinishedCallback build_finished_callback;\n+                FinishedCallback finished_callback;\n+                RegisterTaskGroupCallback register_task_group_;\n+                StartTaskGroupCallback start_task_group_callback;\n+                PauseProbeSideCallback pause_probe_side_callback;\n+                AbortContinuationImpl abort_callback;\n+            };\n\nReview Comment:\n   Can we just use a pure virtual class at this point?\r\n   \r\n   ```\r\n   class HashJoinExternals {\r\n     virtual void OutputBatch(int64_t, ExecBatch) = 0;\r\n     // ...\r\n   };\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/accumulation_queue.h:\n##########\n@@ -42,9 +45,11 @@ class AccumulationQueue {\n \n   void Concatenate(AccumulationQueue&& that);\n   void InsertBatch(ExecBatch batch);\n+  void InsertAt(ExecBatch batch, size_t idx);\n\nReview Comment:\n   If I understand this method correctly it replaces the batch at index `idx`.  That was a little surprising since I think of `AccumulationQueue` as a vector and `std::vector` has an `insert` method that pushes elements to the right.  Can you change this to a name like `Replace` or `Set`?  Or at least add a brief doc comment.\n\n\n\n##########\ncpp/src/arrow/util/atomic_util.h:\n##########\n@@ -0,0 +1,157 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <atomic>\n+#include <type_traits>\n+\n+namespace arrow\n+{\n+    namespace util\n+    {\n+#if defined(__clang) || defined(__GNUC__)\n+        template <typename T>\n+        inline T AtomicLoad(T *addr, std::memory_order order = std::memory_order_seq_cst) noexcept\n+        {\n+            T ret;\n+            __atomic_load(addr, &ret, order);\n+            return ret;\n+        }\n+\n+        template <typename T>\n+        inline void AtomicStore(T *addr, T &val, std::memory_order order = std::memory_order_seq_cst) noexcept\n+        {\n+            __atomic_store(addr, val, order);\n+        }\n+\n+        template <typename T>\n+        inline T AtomicFetchAdd(T *addr, T &val, std::memory_order order = std::memory_order_seq_cst) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchAdd can only be used on integral types\");\n+            return __atomic_fetch_add(addr, val, order);\n+        }\n+\n+        template <typename T>\n+        inline T AtomicFetchSub(T *addr, T &val, std::memory_order order = std::memory_order_seq_cst) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchSub can only be used on integral types\");\n+            return __atomic_fetch_sub(addr, val, order);\n+        }\n+\n+#elif defined(_MSC_VER)\n+        #include <intrin.h>\n+        template <typename T>\n+        inline T AtomicLoad(T *addr, std::memory_order /*order*/) noexcept\n+        {\n+            T val = *addr;\n+            _ReadWriteBarrier();\n+            return val;\n+        }\n+\n+        template <typename T>\n+        inline void AtomicStore(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            _ReadWriteBarrier();\n+            *addr = val;\n+        }\n+\n+        template <typename T, typename std::enable_if<sizeof(T) == 1>::type>\n+        inline T AtomicFetchAdd(T *addr, T &val, std::memory_order /*order*/) noexcepet\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchAdd can only be used on integral types\");\n+            return _InterlockedExchangeAdd8(addr, val);\n+        }\n+\n+        template <typename T, typename std::enable_if<sizeof(T) == 2>::type>\n+        inline T AtomicFetchAdd(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchAdd can only be used on integral types\");\n+            return _InterlockedExchangeAdd16(addr, val);\n+        }\n+\n+        template <typename T, typename std::enable_if<sizeof(T) == 4>::type>\n+        inline T AtomicFetchAdd(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchAdd can only be used on integral types\");\n+            return _InterlockedExchangeAdd(addr, val);\n+        }\n+\n+#if _WIN64\n+        template <typename T, typename std::enable_if<sizeof(T) == 8>::type>\n+        inline T AtomicFetchAdd(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchAdd can only be used on integral types\");\n+            return _InterlockedExchangeAdd64(addr, val);\n+        }\n+#else\n+        template <typename T, typename std::enable_if<sizeof(T) == 8>::type>\n+        inline T AtomicFetchAdd(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchAdd can only be used on integral types\");\n+            _ReadWriteBarrier();\n+            T expected = *addr;\n+            for(;;)\n+            {\n+                T new_val = expected + val;\n+                T prev = _InterlockedCompareExchange64(addr, new_val, expected);\n+                if(prev == expected)\n+                    return prev;\n+                expected = prev;\n+            }\n+        }\n+#endif\n+\n+        template <typename T, typename std::enable_if<sizeof(T) == 1>::type>\n+        inline T AtomicFetchSub(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchSub can only be used on integral types\");\n+            return _InterlockedExchangeAdd8(addr, -val);\n+        }\n+\n+        template <typename T, typename std::enable_if<sizeof(T) == 2>::type>\n+        inline T AtomicFetchSub(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchSub can only be used on integral types\");\n+            return _InterlockedExchangeAdd16(addr, -val);\n+        }\n+\n+        template <typename T, typename std::enable_if<sizeof(T) == 4>::type>\n+        inline T AtomicFetchSub(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchSub can only be used on integral types\");\n+            return _InterlockedExchangeAdd(addr, -val);\n+        }\n+\n+#if _WIN64\n+        template <typename T, typename std::enable_if<sizeof(T) == 8>::type>\n+        inline T AtomicFetchSub(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchSub can only be used on integral types\");\n+            return _InterlockedExchangeAdd64(addr, -val);\n+        }\n+#else\n+        template <typename T, typename std::enable_if<sizeof(T) == 8>::type>\n+        inline T AtomicFetchSub(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchSub can only be used on integral types\");\n+            return AtomicFetchAdd(addr, -val, std::memory_order_seq_cst);\n+        }        \n+#endif\n+#endif\n\nReview Comment:\n   Why do you need these instead of `std::atomic`?\n\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.h:\n##########\n@@ -0,0 +1,66 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"arrow/compute/exec/exec_plan.h\"\n+\n+namespace arrow\n+{\n+    namespace compute\n+    {\n+#ifdef _WIN32\n+        using FileHandle = void *;\n+        extern const FileHandle kInvalidHandle;\n+#else\n+        using FileHandle = int;\n+        constexpr FileHandle kInvalidHandle = -1;\n+#endif\n+\n+        class SpillFile\n+        {\n+        public:\n+\n+            // To spill a batch the following must be true:\n+            // - Row offset for each column must be 0.\n+            // - Column buffers must be aligned to 512 bits\n+            // - No column can be a scalar\n+            // These assumptions aren't as inconvenient as it seems because\n+            // typically batches will be partitioned before being spilled,\n+            // meaning the batches will come from ExecBatchBuilder, which\n+            // ensures these assumptions hold. \n+            Status SpillBatch(QueryContext *ctx, ExecBatch batch);\n+            Status ReadBackBatches(\n+                QueryContext *ctx,\n+                std::function<Status(size_t, ExecBatch)> fn,\n+                std::function<Status(size_t)> on_finished);\n\nReview Comment:\n   Can you add a comment explaining this method (or really the whole class)?  Does `fn` get called multiple times?  Is there a batch size of some kind?\n\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.h:\n##########\n@@ -0,0 +1,66 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"arrow/compute/exec/exec_plan.h\"\n\nReview Comment:\n   Can we follow `IWYU` here and include `vector`, `atomic`, `functional`, `memory`, and `query_context.h`\n\n\n\n",
                    "created": "2022-08-11T23:33:20.474+0000",
                    "updated": "2022-08-11T23:33:20.474+0000",
                    "started": "2022-08-11T23:33:20.473+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800136",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/800139",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#issuecomment-1212601691\n\n   @marsupialtail do you mind taking a look at spilling_file (and other parts of the PR if interested).  Curious to get your feedback since you experimented with direct I/O as well.\n\n\n",
                    "created": "2022-08-11T23:57:09.373+0000",
                    "updated": "2022-08-11T23:57:09.373+0000",
                    "started": "2022-08-11T23:57:09.372+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800139",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/800355",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "marsupialtail commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r944139454\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.cc:\n##########\n@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"spilling_util.h\"\n+#include <mutex>\n+\n+namespace arrow\n+{\n+namespace compute\n+{\n+    struct ArrayInfo\n+    {\n+        int64_t num_children;\n+        std::array<std::shared_ptr<Buffer>, 3> bufs;\n+        std::array<size_t, 3> sizes;\n+        std::shared_ptr<ArrayData> dictionary;\n+    };\n+\n+    struct SpillFile::BatchInfo\n+    {\n+        int64_t start;\n+        std::vector<ArrayInfo> arrays;\n+    };\n+\n+#ifdef _WIN32\n+#include \"windows_compatibility.h\"\n+\n+const FileHandle kInvalidHandle = INVALID_HANDLE_VALUE;\n+\n+static Result<FileHandle> OpenTemporaryFile()\n+{\n+    constexpr DWORD kTempFileNameSize = MAX_PATH + 1;\n+    wchar_t tmp_name_buf[kTempFileNameSize];\n+    wchar_t tmp_path_buf[kTempFileNameSize];\n+\n+    DWORD ret;\n+    ret = GetTempPath2W(kTempFileNameSize, tmp_path_buf);\n+    if(ret > kTempFileNameSize || ret == 0)\n+        return Status::IOError();\n+    if(GetTempFileNameW(tmp_path_buf, L\"ARROW_TMP\", 0, tmp_name_buf) == 0)\n+        return Status::IOError();\n+\n+    HANDLE file_handle = CreateFileA(\n+        tmp_name_buf,\n+        GENERIC_READ | GENERIC_WRITE | FILE_APPEND_DATA,\n+        0,\n+        NULL,\n+        CREATE_ALWAYS,\n+        FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,\n+        NULL);\n+    if(file_handle == INVALID_HANDLE_VALUE)\n+        return Status::IOError(\"Failed to create temp file\");\n+    return file_handle;\n+}\n+\n+static Status CloseTemporaryFile(FileHandle handle)\n+{\n+    if(!CloseHandle(handle))\n+        return Status::IOError(\"Failed to close temp file\");\n+    return Status::OK();\n+}\n+\n+static Status WriteBatch_PlatformSpecific(FileHandle handle, const SpillFile::BatchInfo &info)\n+{\n+    OVERLAPPED overlapped;\n+    int64_t offset = info.start;\n+    for(const ArrayInfo &arr : info.arrays)\n+    {\n+        for(size_t i = 0; i < arr.bufs.size(); i++)\n+        {\n+            if(info.bufs[i] != 0)\n+            {\n+                overlapped.Offset = static_cast<DWORD>(offset);\n+                overlapped.OffsetHigh = static_cast<DWORD>(offset >> 32);\n+                if(!WriteFile(\n+                       handle,\n+                       info.bufs[i]->data(),\n+                       info.bufs[i]->size(),\n+                       NULL,\n+                       &overlapped))\n+                    return Status::IOError(\"Failed to spill!\");\n+                offset += info.sizes[i];\n+                info.bufs[i].reset();\n+            }\n+        }\n+    }\n+    return Status::OK();\n+}\n+#else\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <sys/uio.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+\n+Result<FileHandle> OpenTemporaryFile()\n+{\n+    static std::once_flag generate_tmp_file_name_flag;\n+\n+    constexpr int kFileNameSize = 1024;\n+    static char name[kFileNameSize];\n+\n+    char *name_ptr = name;\n+    std::call_once(generate_tmp_file_name_flag, [name_ptr]() noexcept\n+    {\n+        const char *selectors[] = { \"TMPDIR\", \"TMP\", \"TEMP\", \"TEMPDIR\" };\n+        constexpr size_t kNumSelectors = sizeof(selectors) / sizeof(selectors[0]);\n+#ifdef __ANDROID__\n+        const char *backup = \"/data/local/tmp/\";\n+#else\n+        const char *backup = \"/tmp/\";\n\nReview Comment:\n   What if I want to spill to an attached NVME SSD that is mounted on its own directory?\n\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.cc:\n##########\n@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"spilling_util.h\"\n+#include <mutex>\n+\n+namespace arrow\n+{\n+namespace compute\n+{\n+    struct ArrayInfo\n+    {\n+        int64_t num_children;\n+        std::array<std::shared_ptr<Buffer>, 3> bufs;\n+        std::array<size_t, 3> sizes;\n+        std::shared_ptr<ArrayData> dictionary;\n+    };\n+\n+    struct SpillFile::BatchInfo\n+    {\n+        int64_t start;\n+        std::vector<ArrayInfo> arrays;\n+    };\n+\n+#ifdef _WIN32\n+#include \"windows_compatibility.h\"\n+\n+const FileHandle kInvalidHandle = INVALID_HANDLE_VALUE;\n+\n+static Result<FileHandle> OpenTemporaryFile()\n+{\n+    constexpr DWORD kTempFileNameSize = MAX_PATH + 1;\n+    wchar_t tmp_name_buf[kTempFileNameSize];\n+    wchar_t tmp_path_buf[kTempFileNameSize];\n+\n+    DWORD ret;\n+    ret = GetTempPath2W(kTempFileNameSize, tmp_path_buf);\n+    if(ret > kTempFileNameSize || ret == 0)\n+        return Status::IOError();\n+    if(GetTempFileNameW(tmp_path_buf, L\"ARROW_TMP\", 0, tmp_name_buf) == 0)\n+        return Status::IOError();\n+\n+    HANDLE file_handle = CreateFileA(\n+        tmp_name_buf,\n+        GENERIC_READ | GENERIC_WRITE | FILE_APPEND_DATA,\n+        0,\n+        NULL,\n+        CREATE_ALWAYS,\n+        FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,\n+        NULL);\n+    if(file_handle == INVALID_HANDLE_VALUE)\n+        return Status::IOError(\"Failed to create temp file\");\n+    return file_handle;\n+}\n+\n+static Status CloseTemporaryFile(FileHandle handle)\n+{\n+    if(!CloseHandle(handle))\n+        return Status::IOError(\"Failed to close temp file\");\n+    return Status::OK();\n+}\n+\n+static Status WriteBatch_PlatformSpecific(FileHandle handle, const SpillFile::BatchInfo &info)\n+{\n+    OVERLAPPED overlapped;\n+    int64_t offset = info.start;\n+    for(const ArrayInfo &arr : info.arrays)\n+    {\n+        for(size_t i = 0; i < arr.bufs.size(); i++)\n+        {\n+            if(info.bufs[i] != 0)\n+            {\n+                overlapped.Offset = static_cast<DWORD>(offset);\n+                overlapped.OffsetHigh = static_cast<DWORD>(offset >> 32);\n+                if(!WriteFile(\n+                       handle,\n+                       info.bufs[i]->data(),\n+                       info.bufs[i]->size(),\n+                       NULL,\n+                       &overlapped))\n+                    return Status::IOError(\"Failed to spill!\");\n+                offset += info.sizes[i];\n+                info.bufs[i].reset();\n+            }\n+        }\n+    }\n+    return Status::OK();\n+}\n+#else\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <sys/uio.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+\n+Result<FileHandle> OpenTemporaryFile()\n+{\n+    static std::once_flag generate_tmp_file_name_flag;\n+\n+    constexpr int kFileNameSize = 1024;\n+    static char name[kFileNameSize];\n+\n+    char *name_ptr = name;\n+    std::call_once(generate_tmp_file_name_flag, [name_ptr]() noexcept\n+    {\n+        const char *selectors[] = { \"TMPDIR\", \"TMP\", \"TEMP\", \"TEMPDIR\" };\n+        constexpr size_t kNumSelectors = sizeof(selectors) / sizeof(selectors[0]);\n+#ifdef __ANDROID__\n+        const char *backup = \"/data/local/tmp/\";\n+#else\n+        const char *backup = \"/tmp/\";\n+#endif\n+        const char *tmp_dir = backup;\n+        for(size_t i = 0; i < kNumSelectors; i++)\n+        {\n+            const char *env = getenv(selectors[i]);\n+            if(env)\n+            {\n+                tmp_dir = env;\n+                break;\n+            }\n+        }\n+        size_t tmp_dir_length = std::strlen(tmp_dir);\n+\n+        const char *tmp_name_template = \"/ARROW_TMP_XXXXXX\";\n+        size_t tmp_name_length = std::strlen(tmp_name_template);\n+\n+        if((tmp_dir_length + tmp_name_length) >= kFileNameSize)\n+        {\n+            tmp_dir = backup;\n+            tmp_dir_length = std::strlen(backup);\n+        }\n+\n+        std::strncpy(name_ptr, tmp_dir, kFileNameSize);\n+        std::strncpy(name_ptr + tmp_dir_length, tmp_name_template, kFileNameSize - tmp_dir_length);\n+    });\n+\n+#ifdef __APPLE__\n+    int fd = mkstemp(name);\n+    if(fd == kInvalidHandle)\n+        return Status::IOError(strerror(errno));\n+    if(fcntl(fd, F_NOCACHE, 1) == -1)\n+        return Status::IOError(strerror(errno));\n+#else    \n+    int fd = mkostemp(name, O_DIRECT);\n+    if(fd == kInvalidHandle)\n+        return Status::IOError(strerror(errno));\n+#endif\n+\n+    if(unlink(name) != 0)\n+        return Status::IOError(strerror(errno));\n+    return fd;\n+}\n+\n+static Status CloseTemporaryFile(FileHandle handle)\n+{\n+    if(close(handle) == -1)\n+        return Status::IOError(strerror(errno));\n+    return Status::OK();\n+}\n+\n+static Status WriteBatch_PlatformSpecific(FileHandle handle, SpillFile::BatchInfo &info)\n+{\n+    std::vector<struct iovec> ios;\n+    for(const ArrayInfo &arr : info.arrays)\n+    {\n+        for(int i = 0; i < 3; i++)\n+        {\n+            if(arr.bufs[i])\n+            {\n+                struct iovec io;\n+                io.iov_base = static_cast<void *>(arr.bufs[i]->mutable_data());\n+                io.iov_len = static_cast<size_t>(arr.bufs[i]->size());\n+                ios.push_back(io);\n+            }\n+        }\n+    }\n+\n+    if(pwritev(handle, ios.data(), static_cast<int>(ios.size()), info.start) == -1)\n+        return Status::IOError(\"Failed to spill!\");\n\nReview Comment:\n   I seem to recall a discussion here where we talked about the performance of using pwritev versus things like IO uring where you were able to saturate NVME SSD bandwidth. Were you able to saturate SSD with pwritev? I understand that when you are spilling many batches there might be many pwritevs happening at the same time. Still I am curious how the perf compares to IO uring ",
                    "created": "2022-08-12T17:24:55.221+0000",
                    "updated": "2022-08-12T17:24:55.221+0000",
                    "started": "2022-08-12T17:24:55.221+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800355",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/800356",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "marsupialtail commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r944139454\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.cc:\n##########\n@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"spilling_util.h\"\n+#include <mutex>\n+\n+namespace arrow\n+{\n+namespace compute\n+{\n+    struct ArrayInfo\n+    {\n+        int64_t num_children;\n+        std::array<std::shared_ptr<Buffer>, 3> bufs;\n+        std::array<size_t, 3> sizes;\n+        std::shared_ptr<ArrayData> dictionary;\n+    };\n+\n+    struct SpillFile::BatchInfo\n+    {\n+        int64_t start;\n+        std::vector<ArrayInfo> arrays;\n+    };\n+\n+#ifdef _WIN32\n+#include \"windows_compatibility.h\"\n+\n+const FileHandle kInvalidHandle = INVALID_HANDLE_VALUE;\n+\n+static Result<FileHandle> OpenTemporaryFile()\n+{\n+    constexpr DWORD kTempFileNameSize = MAX_PATH + 1;\n+    wchar_t tmp_name_buf[kTempFileNameSize];\n+    wchar_t tmp_path_buf[kTempFileNameSize];\n+\n+    DWORD ret;\n+    ret = GetTempPath2W(kTempFileNameSize, tmp_path_buf);\n+    if(ret > kTempFileNameSize || ret == 0)\n+        return Status::IOError();\n+    if(GetTempFileNameW(tmp_path_buf, L\"ARROW_TMP\", 0, tmp_name_buf) == 0)\n+        return Status::IOError();\n+\n+    HANDLE file_handle = CreateFileA(\n+        tmp_name_buf,\n+        GENERIC_READ | GENERIC_WRITE | FILE_APPEND_DATA,\n+        0,\n+        NULL,\n+        CREATE_ALWAYS,\n+        FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,\n+        NULL);\n+    if(file_handle == INVALID_HANDLE_VALUE)\n+        return Status::IOError(\"Failed to create temp file\");\n+    return file_handle;\n+}\n+\n+static Status CloseTemporaryFile(FileHandle handle)\n+{\n+    if(!CloseHandle(handle))\n+        return Status::IOError(\"Failed to close temp file\");\n+    return Status::OK();\n+}\n+\n+static Status WriteBatch_PlatformSpecific(FileHandle handle, const SpillFile::BatchInfo &info)\n+{\n+    OVERLAPPED overlapped;\n+    int64_t offset = info.start;\n+    for(const ArrayInfo &arr : info.arrays)\n+    {\n+        for(size_t i = 0; i < arr.bufs.size(); i++)\n+        {\n+            if(info.bufs[i] != 0)\n+            {\n+                overlapped.Offset = static_cast<DWORD>(offset);\n+                overlapped.OffsetHigh = static_cast<DWORD>(offset >> 32);\n+                if(!WriteFile(\n+                       handle,\n+                       info.bufs[i]->data(),\n+                       info.bufs[i]->size(),\n+                       NULL,\n+                       &overlapped))\n+                    return Status::IOError(\"Failed to spill!\");\n+                offset += info.sizes[i];\n+                info.bufs[i].reset();\n+            }\n+        }\n+    }\n+    return Status::OK();\n+}\n+#else\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <sys/uio.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+\n+Result<FileHandle> OpenTemporaryFile()\n+{\n+    static std::once_flag generate_tmp_file_name_flag;\n+\n+    constexpr int kFileNameSize = 1024;\n+    static char name[kFileNameSize];\n+\n+    char *name_ptr = name;\n+    std::call_once(generate_tmp_file_name_flag, [name_ptr]() noexcept\n+    {\n+        const char *selectors[] = { \"TMPDIR\", \"TMP\", \"TEMP\", \"TEMPDIR\" };\n+        constexpr size_t kNumSelectors = sizeof(selectors) / sizeof(selectors[0]);\n+#ifdef __ANDROID__\n+        const char *backup = \"/data/local/tmp/\";\n+#else\n+        const char *backup = \"/tmp/\";\n\nReview Comment:\n   What if I want to spill to an attached NVME SSD that is mounted on its own directory? E.g. on AWS instances with NVME SSD you usually mount it to a directory called /data or something\n\n\n\n",
                    "created": "2022-08-12T17:25:35.458+0000",
                    "updated": "2022-08-12T17:25:35.458+0000",
                    "started": "2022-08-12T17:25:35.457+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "800356",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/804059",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r956365103\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.cc:\n##########\n@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"spilling_util.h\"\n+#include <mutex>\n+\n+namespace arrow\n+{\n+namespace compute\n+{\n+    struct ArrayInfo\n+    {\n+        int64_t num_children;\n+        std::array<std::shared_ptr<Buffer>, 3> bufs;\n+        std::array<size_t, 3> sizes;\n+        std::shared_ptr<ArrayData> dictionary;\n+    };\n+\n+    struct SpillFile::BatchInfo\n+    {\n+        int64_t start;\n+        std::vector<ArrayInfo> arrays;\n+    };\n+\n+#ifdef _WIN32\n+#include \"windows_compatibility.h\"\n+\n+const FileHandle kInvalidHandle = INVALID_HANDLE_VALUE;\n+\n+static Result<FileHandle> OpenTemporaryFile()\n+{\n+    constexpr DWORD kTempFileNameSize = MAX_PATH + 1;\n+    wchar_t tmp_name_buf[kTempFileNameSize];\n+    wchar_t tmp_path_buf[kTempFileNameSize];\n+\n+    DWORD ret;\n+    ret = GetTempPath2W(kTempFileNameSize, tmp_path_buf);\n+    if(ret > kTempFileNameSize || ret == 0)\n+        return Status::IOError();\n+    if(GetTempFileNameW(tmp_path_buf, L\"ARROW_TMP\", 0, tmp_name_buf) == 0)\n+        return Status::IOError();\n+\n+    HANDLE file_handle = CreateFileA(\n+        tmp_name_buf,\n+        GENERIC_READ | GENERIC_WRITE | FILE_APPEND_DATA,\n+        0,\n+        NULL,\n+        CREATE_ALWAYS,\n+        FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,\n+        NULL);\n+    if(file_handle == INVALID_HANDLE_VALUE)\n+        return Status::IOError(\"Failed to create temp file\");\n+    return file_handle;\n+}\n+\n+static Status CloseTemporaryFile(FileHandle handle)\n+{\n+    if(!CloseHandle(handle))\n+        return Status::IOError(\"Failed to close temp file\");\n+    return Status::OK();\n+}\n+\n+static Status WriteBatch_PlatformSpecific(FileHandle handle, const SpillFile::BatchInfo &info)\n+{\n+    OVERLAPPED overlapped;\n+    int64_t offset = info.start;\n+    for(const ArrayInfo &arr : info.arrays)\n+    {\n+        for(size_t i = 0; i < arr.bufs.size(); i++)\n+        {\n+            if(info.bufs[i] != 0)\n+            {\n+                overlapped.Offset = static_cast<DWORD>(offset);\n+                overlapped.OffsetHigh = static_cast<DWORD>(offset >> 32);\n+                if(!WriteFile(\n+                       handle,\n+                       info.bufs[i]->data(),\n+                       info.bufs[i]->size(),\n+                       NULL,\n+                       &overlapped))\n+                    return Status::IOError(\"Failed to spill!\");\n+                offset += info.sizes[i];\n+                info.bufs[i].reset();\n+            }\n+        }\n+    }\n+    return Status::OK();\n+}\n+#else\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <sys/uio.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+\n+Result<FileHandle> OpenTemporaryFile()\n+{\n+    static std::once_flag generate_tmp_file_name_flag;\n+\n+    constexpr int kFileNameSize = 1024;\n+    static char name[kFileNameSize];\n+\n+    char *name_ptr = name;\n+    std::call_once(generate_tmp_file_name_flag, [name_ptr]() noexcept\n+    {\n+        const char *selectors[] = { \"TMPDIR\", \"TMP\", \"TEMP\", \"TEMPDIR\" };\n+        constexpr size_t kNumSelectors = sizeof(selectors) / sizeof(selectors[0]);\n+#ifdef __ANDROID__\n+        const char *backup = \"/data/local/tmp/\";\n+#else\n+        const char *backup = \"/tmp/\";\n+#endif\n+        const char *tmp_dir = backup;\n+        for(size_t i = 0; i < kNumSelectors; i++)\n+        {\n+            const char *env = getenv(selectors[i]);\n+            if(env)\n+            {\n+                tmp_dir = env;\n+                break;\n+            }\n+        }\n+        size_t tmp_dir_length = std::strlen(tmp_dir);\n+\n+        const char *tmp_name_template = \"/ARROW_TMP_XXXXXX\";\n+        size_t tmp_name_length = std::strlen(tmp_name_template);\n+\n+        if((tmp_dir_length + tmp_name_length) >= kFileNameSize)\n+        {\n+            tmp_dir = backup;\n+            tmp_dir_length = std::strlen(backup);\n+        }\n+\n+        std::strncpy(name_ptr, tmp_dir, kFileNameSize);\n+        std::strncpy(name_ptr + tmp_dir_length, tmp_name_template, kFileNameSize - tmp_dir_length);\n+    });\n+\n+#ifdef __APPLE__\n+    int fd = mkstemp(name);\n+    if(fd == kInvalidHandle)\n+        return Status::IOError(strerror(errno));\n+    if(fcntl(fd, F_NOCACHE, 1) == -1)\n+        return Status::IOError(strerror(errno));\n+#else    \n+    int fd = mkostemp(name, O_DIRECT);\n+    if(fd == kInvalidHandle)\n+        return Status::IOError(strerror(errno));\n+#endif\n+\n+    if(unlink(name) != 0)\n+        return Status::IOError(strerror(errno));\n+    return fd;\n+}\n+\n+static Status CloseTemporaryFile(FileHandle handle)\n+{\n+    if(close(handle) == -1)\n+        return Status::IOError(strerror(errno));\n+    return Status::OK();\n+}\n+\n+static Status WriteBatch_PlatformSpecific(FileHandle handle, SpillFile::BatchInfo &info)\n+{\n+    std::vector<struct iovec> ios;\n+    for(const ArrayInfo &arr : info.arrays)\n+    {\n+        for(int i = 0; i < 3; i++)\n+        {\n+            if(arr.bufs[i])\n+            {\n+                struct iovec io;\n+                io.iov_base = static_cast<void *>(arr.bufs[i]->mutable_data());\n+                io.iov_len = static_cast<size_t>(arr.bufs[i]->size());\n+                ios.push_back(io);\n+            }\n+        }\n+    }\n+\n+    if(pwritev(handle, ios.data(), static_cast<int>(ios.size()), info.start) == -1)\n+        return Status::IOError(\"Failed to spill!\");\n\nReview Comment:\n   I think you are conflating two things: The IO command (pwritev) and the interface used to invoke it (syscall vs `io_uring`). `io_uring` lets you kick off a `pwritev` by writing into a ring buffer and invoking a memory barrier and allowing it to be executed on a kernel-mode thread. `pwritev` is a normal syscall that is synchronous, but I'm invoking it on a different user space thread in order to emulate asynchrony, so the net effect should be the same (but more cumbersome to write the code). I am using `pwritev` in both scenarios, just invoking it in two different ways. \r\n   \r\n   That said, I will add a benchmark.\n\n\n\n",
                    "created": "2022-08-26T19:12:37.536+0000",
                    "updated": "2022-08-26T19:12:37.536+0000",
                    "started": "2022-08-26T19:12:37.536+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "804059",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/804060",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r956366401\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.cc:\n##########\n@@ -0,0 +1,305 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"spilling_util.h\"\n+#include <mutex>\n+\n+namespace arrow\n+{\n+namespace compute\n+{\n+    struct ArrayInfo\n+    {\n+        int64_t num_children;\n+        std::array<std::shared_ptr<Buffer>, 3> bufs;\n+        std::array<size_t, 3> sizes;\n+        std::shared_ptr<ArrayData> dictionary;\n+    };\n+\n+    struct SpillFile::BatchInfo\n+    {\n+        int64_t start;\n+        std::vector<ArrayInfo> arrays;\n+    };\n+\n+#ifdef _WIN32\n+#include \"windows_compatibility.h\"\n+\n+const FileHandle kInvalidHandle = INVALID_HANDLE_VALUE;\n+\n+static Result<FileHandle> OpenTemporaryFile()\n+{\n+    constexpr DWORD kTempFileNameSize = MAX_PATH + 1;\n+    wchar_t tmp_name_buf[kTempFileNameSize];\n+    wchar_t tmp_path_buf[kTempFileNameSize];\n+\n+    DWORD ret;\n+    ret = GetTempPath2W(kTempFileNameSize, tmp_path_buf);\n+    if(ret > kTempFileNameSize || ret == 0)\n+        return Status::IOError();\n+    if(GetTempFileNameW(tmp_path_buf, L\"ARROW_TMP\", 0, tmp_name_buf) == 0)\n+        return Status::IOError();\n+\n+    HANDLE file_handle = CreateFileA(\n+        tmp_name_buf,\n+        GENERIC_READ | GENERIC_WRITE | FILE_APPEND_DATA,\n+        0,\n+        NULL,\n+        CREATE_ALWAYS,\n+        FILE_FLAG_NO_BUFFERING | FILE_FLAG_OVERLAPPED | FILE_FLAG_DELETE_ON_CLOSE,\n+        NULL);\n+    if(file_handle == INVALID_HANDLE_VALUE)\n+        return Status::IOError(\"Failed to create temp file\");\n+    return file_handle;\n+}\n+\n+static Status CloseTemporaryFile(FileHandle handle)\n+{\n+    if(!CloseHandle(handle))\n+        return Status::IOError(\"Failed to close temp file\");\n+    return Status::OK();\n+}\n+\n+static Status WriteBatch_PlatformSpecific(FileHandle handle, const SpillFile::BatchInfo &info)\n+{\n+    OVERLAPPED overlapped;\n+    int64_t offset = info.start;\n+    for(const ArrayInfo &arr : info.arrays)\n+    {\n+        for(size_t i = 0; i < arr.bufs.size(); i++)\n+        {\n+            if(info.bufs[i] != 0)\n+            {\n+                overlapped.Offset = static_cast<DWORD>(offset);\n+                overlapped.OffsetHigh = static_cast<DWORD>(offset >> 32);\n+                if(!WriteFile(\n+                       handle,\n+                       info.bufs[i]->data(),\n+                       info.bufs[i]->size(),\n+                       NULL,\n+                       &overlapped))\n+                    return Status::IOError(\"Failed to spill!\");\n+                offset += info.sizes[i];\n+                info.bufs[i].reset();\n+            }\n+        }\n+    }\n+    return Status::OK();\n+}\n+#else\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#include <sys/uio.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+\n+Result<FileHandle> OpenTemporaryFile()\n+{\n+    static std::once_flag generate_tmp_file_name_flag;\n+\n+    constexpr int kFileNameSize = 1024;\n+    static char name[kFileNameSize];\n+\n+    char *name_ptr = name;\n+    std::call_once(generate_tmp_file_name_flag, [name_ptr]() noexcept\n+    {\n+        const char *selectors[] = { \"TMPDIR\", \"TMP\", \"TEMP\", \"TEMPDIR\" };\n+        constexpr size_t kNumSelectors = sizeof(selectors) / sizeof(selectors[0]);\n+#ifdef __ANDROID__\n+        const char *backup = \"/data/local/tmp/\";\n+#else\n+        const char *backup = \"/tmp/\";\n\nReview Comment:\n   For now you can set one of the below environment variables, but eventually we'll flesh out `QueryOptions` to allow you to specify more options such as the temp directory. \r\n   ```\r\n   const char *selectors[] = { \"TMPDIR\", \"TMP\", \"TEMP\", \"TEMPDIR\" };\r\n   ```\n\n\n\n",
                    "created": "2022-08-26T19:14:07.720+0000",
                    "updated": "2022-08-26T19:14:07.720+0000",
                    "started": "2022-08-26T19:14:07.720+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "804060",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/804062",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r956368290\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_join.h:\n##########\n@@ -0,0 +1,100 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <bitset>\n+\n+#include \"arrow/compute/exec/query_context.h\"\n+#include \"arrow/compute/exec/hash_join.h\"\n+#include \"arrow/compute/exec/accumulation_queue.h\"\n+\n+namespace arrow\n+{\n+    namespace compute\n+    {\n+        class SpillingHashJoin\n+        {\n+        public:\n+            using OutputBatchCallback = std::function<void(int64_t, ExecBatch)>;\n+            using BuildFinishedCallback = std::function<Status(size_t)>;\n+            using FinishedCallback = std::function<void(int64_t)>;\n+            using RegisterTaskGroupCallback = std::function<int(\n+                std::function<Status(size_t, int64_t)>, std::function<Status(size_t)>)>;\n+            using StartTaskGroupCallback = std::function<Status(int, int64_t)>;\n+            using PauseProbeSideCallback = std::function<void(int)>;\n+            using ResumeProbeSideCallback = std::function<void(int)>;\n+            using AbortContinuationImpl = std::function<void()>;\n+\n+            struct CallbackRecord\n+            {\n+                OutputBatchCallback output_batch_callback;\n+                BuildFinishedCallback build_finished_callback;\n+                FinishedCallback finished_callback;\n+                RegisterTaskGroupCallback register_task_group_;\n+                StartTaskGroupCallback start_task_group_callback;\n+                PauseProbeSideCallback pause_probe_side_callback;\n+                AbortContinuationImpl abort_callback;\n+            };\n\nReview Comment:\n   I personally find these pure-virtual classes cumbersome to deal with as they remove the callback record from being near the site where I invoke `Init`. They're also less flexible and don't let me reuse functions (like HashJoinImpl and SpillingHashJoin reuse a lot of the same callbacks, I can just assign the same stuff between the two callback records).  \n\n\n\n##########\ncpp/src/arrow/util/atomic_util.h:\n##########\n@@ -0,0 +1,157 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <atomic>\n+#include <type_traits>\n+\n+namespace arrow\n+{\n+    namespace util\n+    {\n+#if defined(__clang) || defined(__GNUC__)\n+        template <typename T>\n+        inline T AtomicLoad(T *addr, std::memory_order order = std::memory_order_seq_cst) noexcept\n+        {\n+            T ret;\n+            __atomic_load(addr, &ret, order);\n+            return ret;\n+        }\n+\n+        template <typename T>\n+        inline void AtomicStore(T *addr, T &val, std::memory_order order = std::memory_order_seq_cst) noexcept\n+        {\n+            __atomic_store(addr, val, order);\n+        }\n+\n+        template <typename T>\n+        inline T AtomicFetchAdd(T *addr, T &val, std::memory_order order = std::memory_order_seq_cst) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchAdd can only be used on integral types\");\n+            return __atomic_fetch_add(addr, val, order);\n+        }\n+\n+        template <typename T>\n+        inline T AtomicFetchSub(T *addr, T &val, std::memory_order order = std::memory_order_seq_cst) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchSub can only be used on integral types\");\n+            return __atomic_fetch_sub(addr, val, order);\n+        }\n+\n+#elif defined(_MSC_VER)\n+        #include <intrin.h>\n+        template <typename T>\n+        inline T AtomicLoad(T *addr, std::memory_order /*order*/) noexcept\n+        {\n+            T val = *addr;\n+            _ReadWriteBarrier();\n+            return val;\n+        }\n+\n+        template <typename T>\n+        inline void AtomicStore(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            _ReadWriteBarrier();\n+            *addr = val;\n+        }\n+\n+        template <typename T, typename std::enable_if<sizeof(T) == 1>::type>\n+        inline T AtomicFetchAdd(T *addr, T &val, std::memory_order /*order*/) noexcepet\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchAdd can only be used on integral types\");\n+            return _InterlockedExchangeAdd8(addr, val);\n+        }\n+\n+        template <typename T, typename std::enable_if<sizeof(T) == 2>::type>\n+        inline T AtomicFetchAdd(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchAdd can only be used on integral types\");\n+            return _InterlockedExchangeAdd16(addr, val);\n+        }\n+\n+        template <typename T, typename std::enable_if<sizeof(T) == 4>::type>\n+        inline T AtomicFetchAdd(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchAdd can only be used on integral types\");\n+            return _InterlockedExchangeAdd(addr, val);\n+        }\n+\n+#if _WIN64\n+        template <typename T, typename std::enable_if<sizeof(T) == 8>::type>\n+        inline T AtomicFetchAdd(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchAdd can only be used on integral types\");\n+            return _InterlockedExchangeAdd64(addr, val);\n+        }\n+#else\n+        template <typename T, typename std::enable_if<sizeof(T) == 8>::type>\n+        inline T AtomicFetchAdd(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchAdd can only be used on integral types\");\n+            _ReadWriteBarrier();\n+            T expected = *addr;\n+            for(;;)\n+            {\n+                T new_val = expected + val;\n+                T prev = _InterlockedCompareExchange64(addr, new_val, expected);\n+                if(prev == expected)\n+                    return prev;\n+                expected = prev;\n+            }\n+        }\n+#endif\n+\n+        template <typename T, typename std::enable_if<sizeof(T) == 1>::type>\n+        inline T AtomicFetchSub(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchSub can only be used on integral types\");\n+            return _InterlockedExchangeAdd8(addr, -val);\n+        }\n+\n+        template <typename T, typename std::enable_if<sizeof(T) == 2>::type>\n+        inline T AtomicFetchSub(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchSub can only be used on integral types\");\n+            return _InterlockedExchangeAdd16(addr, -val);\n+        }\n+\n+        template <typename T, typename std::enable_if<sizeof(T) == 4>::type>\n+        inline T AtomicFetchSub(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchSub can only be used on integral types\");\n+            return _InterlockedExchangeAdd(addr, -val);\n+        }\n+\n+#if _WIN64\n+        template <typename T, typename std::enable_if<sizeof(T) == 8>::type>\n+        inline T AtomicFetchSub(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchSub can only be used on integral types\");\n+            return _InterlockedExchangeAdd64(addr, -val);\n+        }\n+#else\n+        template <typename T, typename std::enable_if<sizeof(T) == 8>::type>\n+        inline T AtomicFetchSub(T *addr, T &val, std::memory_order /*order*/) noexcept\n+        {\n+            static_assert(std::is_integral<T>::value, \"AtomicFetchSub can only be used on integral types\");\n+            return AtomicFetchAdd(addr, -val, std::memory_order_seq_cst);\n+        }        \n+#endif\n+#endif\n\nReview Comment:\n   Sometimes you don't want to always have an atomic, and only do an atomic operation in a specific situation. In other words, using these you can upgrade a non-atomic to an atomic temporarily, but you can't downgrade an atomic to a non-atomic. C++20 has `std::atomic_ref` to solve this, but we're still on 11. \n\n\n\n",
                    "created": "2022-08-26T19:16:17.984+0000",
                    "updated": "2022-08-26T19:16:17.984+0000",
                    "started": "2022-08-26T19:16:17.984+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "804062",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/804064",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r956375947\n\n\n##########\ncpp/src/arrow/compute/exec/spilling_util.h:\n##########\n@@ -0,0 +1,66 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include \"arrow/compute/exec/exec_plan.h\"\n+\n+namespace arrow\n+{\n+    namespace compute\n+    {\n+#ifdef _WIN32\n+        using FileHandle = void *;\n+        extern const FileHandle kInvalidHandle;\n+#else\n+        using FileHandle = int;\n+        constexpr FileHandle kInvalidHandle = -1;\n+#endif\n+\n+        class SpillFile\n+        {\n+        public:\n+\n+            // To spill a batch the following must be true:\n+            // - Row offset for each column must be 0.\n+            // - Column buffers must be aligned to 512 bits\n+            // - No column can be a scalar\n+            // These assumptions aren't as inconvenient as it seems because\n+            // typically batches will be partitioned before being spilled,\n+            // meaning the batches will come from ExecBatchBuilder, which\n+            // ensures these assumptions hold. \n+            Status SpillBatch(QueryContext *ctx, ExecBatch batch);\n+            Status ReadBackBatches(\n+                QueryContext *ctx,\n+                std::function<Status(size_t, ExecBatch)> fn,\n+                std::function<Status(size_t)> on_finished);\n+            Status Cleanup();\n\nReview Comment:\n   Used for closing the file after the partition has been read back. \n\n\n\n",
                    "created": "2022-08-26T19:25:38.840+0000",
                    "updated": "2022-08-26T19:25:38.840+0000",
                    "started": "2022-08-26T19:25:38.839+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "804064",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/804065",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r956376738\n\n\n##########\ncpp/src/arrow/util/io_util.h:\n##########\n@@ -410,5 +410,11 @@ uint64_t GetThreadId();\n ARROW_EXPORT\n int64_t GetCurrentRSS();\n \n+/// \\brief Get the total memory available to the system in bytes\n+///\n+/// This function supports Windows, Linux, and Mac and will return 0 otherwise\n+ARROW_EXPORT\n+int64_t GetTotalMemoryBytes();\n\nReview Comment:\n   Done\n\n\n\n",
                    "created": "2022-08-26T19:26:34.231+0000",
                    "updated": "2022-08-26T19:26:34.231+0000",
                    "started": "2022-08-26T19:26:34.230+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "804065",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/804066",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r956382906\n\n\n##########\ncpp/src/arrow/compute/light_array.h:\n##########\n@@ -348,11 +349,13 @@ class ARROW_EXPORT ExecBatchBuilder {\n   ExecBatch Flush();\n \n   int num_rows() const { return values_.empty() ? 0 : values_[0].num_rows(); }\n+  bool is_full() const { return num_rows() == num_rows_max(); }\n \n   static int num_rows_max() { return 1 << kLogNumRows; }\n \n  private:\n   static constexpr int kLogNumRows = 15;\n+  static constexpr int64_t kAlignment = 512;\n\nReview Comment:\n   `kAlignment` is inside of `ExecBatchBuilder`, it will always align its buffers to `512` bytes. `alignment_` is a member of ResizableArrayData so that you can specify different alignments for `ResizableArrayData`. \n\n\n\n",
                    "created": "2022-08-26T19:29:34.574+0000",
                    "updated": "2022-08-26T19:29:34.574+0000",
                    "started": "2022-08-26T19:29:34.574+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "804066",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/804067",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r956385050\n\n\n##########\ncpp/src/arrow/memory_pool.h:\n##########\n@@ -71,21 +73,25 @@ class ARROW_EXPORT MemoryPool {\n   /// Allocate a new memory region of at least size bytes.\n   ///\n   /// The allocated region shall be 64-byte aligned.\n-  virtual Status Allocate(int64_t size, uint8_t** out) = 0;\n+  Status Allocate(int64_t size, uint8_t** out) { return Allocate(size, kDefaultAlignment, out); }\n\nReview Comment:\n   No I'm pretty sure I added it to the other allocators. There are four that I could find: Jemalloc, system allocator, mimalloc allocator, and stl_allocator.\n\n\n\n",
                    "created": "2022-08-26T19:32:19.413+0000",
                    "updated": "2022-08-26T19:32:19.413+0000",
                    "started": "2022-08-26T19:32:19.413+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "804067",
                    "issueId": "13442195"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/worklog/804072",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13669:\nURL: https://github.com/apache/arrow/pull/13669#discussion_r956421194\n\n\n##########\ncpp/src/arrow/compute/light_array.h:\n##########\n@@ -348,11 +349,13 @@ class ARROW_EXPORT ExecBatchBuilder {\n   ExecBatch Flush();\n \n   int num_rows() const { return values_.empty() ? 0 : values_[0].num_rows(); }\n+  bool is_full() const { return num_rows() == num_rows_max(); }\n \n   static int num_rows_max() { return 1 << kLogNumRows; }\n \n  private:\n   static constexpr int kLogNumRows = 15;\n+  static constexpr int64_t kAlignment = 512;\n\nReview Comment:\n   512 is the number I see posted most often on the internet, but supposedly the requirements can vary by file system or something. Anyway, I think in the worst case `O_DIRECT` will be a no-op.\n\n\n\n##########\ncpp/src/arrow/compute/light_array.h:\n##########\n@@ -348,11 +349,13 @@ class ARROW_EXPORT ExecBatchBuilder {\n   ExecBatch Flush();\n \n   int num_rows() const { return values_.empty() ? 0 : values_[0].num_rows(); }\n+  bool is_full() const { return num_rows() == num_rows_max(); }\n \n   static int num_rows_max() { return 1 << kLogNumRows; }\n \n  private:\n   static constexpr int kLogNumRows = 15;\n+  static constexpr int64_t kAlignment = 512;\n\nReview Comment:\n   512 is the number I see posted most often on the internet, but supposedly the requirements can vary by file system or something. Anyway, I think in the worst case `O_DIRECT` will have no effect.\n\n\n\n",
                    "created": "2022-08-26T20:19:19.932+0000",
                    "updated": "2022-08-26T20:19:19.932+0000",
                    "started": "2022-08-26T20:19:19.932+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "804072",
                    "issueId": "13442195"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 37800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@2ae0e540[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7ae95bbe[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@f6d5ba7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@3fe9d55f[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5127ab85[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@205ed10a[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@450b16c5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@34397016[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@582e8e97[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@eaed219[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@130e5037[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6c482b80[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 37800,
        "customfield_12312520": null,
        "customfield_12312521": "Thu May 12 01:39:04 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16389/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2022-04-28T01:57:56.000+0000",
        "updated": "2022-09-15T21:00:26.000+0000",
        "timeoriginalestimate": null,
        "description": "The current implementation of the hash-join node current queues in memory the hashtable, the entire build side input, and the entire probe side input (e.g. the entire dataset).  This means the current implementation will run out of memory and crash if the input dataset is larger than the memory on the system.\r\n\r\nBy spilling to disk when memory starts to fill up we can allow the hash-join node to process datasets larger than the available memory on the machine.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "10.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 37800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Support hash-join on larger than memory datasets",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13442195/comment/17535807",
                    "id": "17535807",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Attaching a design for this created by [~michalno]: https://docs.google.com/document/d/1hPxmfJYmWne_OyX3-CqXXyvDBoimi00M0WbS6bXcGYw/edit?usp=sharing",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-05-12T01:39:04.985+0000",
                    "updated": "2022-05-12T01:39:04.985+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z11w5k:",
        "customfield_12314139": null
    }
}