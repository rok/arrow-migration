{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13145551",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13145551",
    "key": "ARROW-2319",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12342562",
                "id": "12342562",
                "description": "",
                "name": "0.10.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-08-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2319/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@4a629ccb[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@404a15a4[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2d59028e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@3daec5b4[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@44bab2fe[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2d370a4c[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@481f2016[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@357dfc4[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@12ebb012[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@79bad69[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@36b5321c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@ba172f1[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Apr 18 11:00:01 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-04-18T11:00:01.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2319/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2018-03-16T00:41:05.000+0000",
        "updated": "2018-04-18T11:00:01.000+0000",
        "timeoriginalestimate": null,
        "description": "This purpose of this is to throttle smaller writes to the actual underlying {{OutputStream}} interface, which might be a file or network protocol. ",
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add buffered output class implementing OutputStream interface",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13145551/comment/16440920",
                    "id": "16440920",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou opened a new pull request #1903: ARROW-2319: [C++] Add BufferedOutputStream class\nURL: https://github.com/apache/arrow/pull/1903\n \n \n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-17T14:28:45.471+0000",
                    "updated": "2018-04-17T14:28:45.471+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13145551/comment/16442282",
                    "id": "16442282",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "xhochy closed pull request #1903: ARROW-2319: [C++] Add BufferedOutputStream class\nURL: https://github.com/apache/arrow/pull/1903\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/CMakeLists.txt b/cpp/src/arrow/CMakeLists.txt\nindex 5fd9256702..da7e24d2d3 100644\n--- a/cpp/src/arrow/CMakeLists.txt\n+++ b/cpp/src/arrow/CMakeLists.txt\n@@ -30,6 +30,7 @@ set(ARROW_SRCS\n   type.cc\n   visitor.cc\n \n+  io/buffered.cc\n   io/file.cc\n   io/interfaces.cc\n   io/memory.cc\ndiff --git a/cpp/src/arrow/io/CMakeLists.txt b/cpp/src/arrow/io/CMakeLists.txt\nindex a7e569870b..65221d097f 100644\n--- a/cpp/src/arrow/io/CMakeLists.txt\n+++ b/cpp/src/arrow/io/CMakeLists.txt\n@@ -18,6 +18,7 @@\n # ----------------------------------------------------------------------\n # arrow_io : Arrow IO interfaces\n \n+ADD_ARROW_TEST(io-buffered-test)\n ADD_ARROW_TEST(io-file-test)\n \n if (ARROW_HDFS AND NOT ARROW_BOOST_HEADER_ONLY)\n@@ -26,11 +27,13 @@ endif()\n \n ADD_ARROW_TEST(io-memory-test)\n \n+ADD_ARROW_BENCHMARK(io-file-benchmark)\n ADD_ARROW_BENCHMARK(io-memory-benchmark)\n \n # Headers: top level\n install(FILES\n   api.h\n+  buffered.h\n   file.h\n   hdfs.h\n   interfaces.h\ndiff --git a/cpp/src/arrow/io/buffered.cc b/cpp/src/arrow/io/buffered.cc\nnew file mode 100644\nindex 0000000000..7ff8ad6804\n--- /dev/null\n+++ b/cpp/src/arrow/io/buffered.cc\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/io/buffered.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/logging.h\"\n+\n+#include <cstring>\n+#include <memory>\n+#include <mutex>\n+#include <string>\n+#include <utility>\n+\n+namespace arrow {\n+namespace io {\n+\n+// ----------------------------------------------------------------------\n+// BufferedOutputStream implementation\n+\n+class BufferedOutputStream::Impl {\n+ public:\n+  explicit Impl(std::shared_ptr<OutputStream> raw)\n+      : raw_(raw),\n+        is_open_(true),\n+        buffer_(std::string(BUFFER_SIZE, '\\0')),\n+        buffer_data_(const_cast<char*>(buffer_.data())),\n+        buffer_pos_(0),\n+        raw_pos_(-1) {}\n+\n+  ~Impl() { DCHECK(Close().ok()); }\n+\n+  Status Close() {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (is_open_) {\n+      Status st = FlushUnlocked();\n+      is_open_ = false;\n+      RETURN_NOT_OK(raw_->Close());\n+      return st;\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Tell(int64_t* position) const {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (raw_pos_ == -1) {\n+      RETURN_NOT_OK(raw_->Tell(&raw_pos_));\n+      DCHECK_GE(raw_pos_, 0);\n+    }\n+    *position = raw_pos_ + buffer_pos_;\n+    return Status::OK();\n+  }\n+\n+  Status Write(const void* data, int64_t nbytes) {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    if (nbytes < 0) {\n+      return Status::Invalid(\"write count should be >= 0\");\n+    }\n+    if (nbytes == 0) {\n+      return Status::OK();\n+    }\n+    if (nbytes + buffer_pos_ >= BUFFER_SIZE) {\n+      RETURN_NOT_OK(FlushUnlocked());\n+      DCHECK_EQ(buffer_pos_, 0);\n+      if (nbytes >= BUFFER_SIZE) {\n+        // Direct write\n+        return raw_->Write(data, nbytes);\n+      }\n+    }\n+    DCHECK_LE(buffer_pos_ + nbytes, BUFFER_SIZE);\n+    std::memcpy(buffer_data_ + buffer_pos_, data, nbytes);\n+    buffer_pos_ += nbytes;\n+    return Status::OK();\n+  }\n+\n+  Status FlushUnlocked() {\n+    if (buffer_pos_ > 0) {\n+      // Invalidate cached raw pos\n+      raw_pos_ = -1;\n+      RETURN_NOT_OK(raw_->Write(buffer_data_, buffer_pos_));\n+      buffer_pos_ = 0;\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Flush() {\n+    std::lock_guard<std::mutex> guard(lock_);\n+    return FlushUnlocked();\n+  }\n+\n+  std::shared_ptr<OutputStream> raw() const { return raw_; }\n+\n+ private:\n+  // This size chosen so that memcpy() remains cheap\n+  static const int64_t BUFFER_SIZE = 4096;\n+\n+  std::shared_ptr<OutputStream> raw_;\n+  bool is_open_;\n+  std::string buffer_;\n+  char* buffer_data_;\n+  int64_t buffer_pos_;\n+  mutable int64_t raw_pos_;\n+  mutable std::mutex lock_;\n+};\n+\n+BufferedOutputStream::BufferedOutputStream(std::shared_ptr<OutputStream> raw)\n+    : impl_(new BufferedOutputStream::Impl(std::move(raw))) {}\n+\n+BufferedOutputStream::~BufferedOutputStream() {}\n+\n+Status BufferedOutputStream::Close() { return impl_->Close(); }\n+\n+Status BufferedOutputStream::Tell(int64_t* position) const {\n+  return impl_->Tell(position);\n+}\n+\n+Status BufferedOutputStream::Write(const void* data, int64_t nbytes) {\n+  return impl_->Write(data, nbytes);\n+}\n+\n+std::shared_ptr<OutputStream> BufferedOutputStream::raw() const { return impl_->raw(); }\n+\n+}  // namespace io\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/io/buffered.h b/cpp/src/arrow/io/buffered.h\nnew file mode 100644\nindex 0000000000..deb344cb7c\n--- /dev/null\n+++ b/cpp/src/arrow/io/buffered.h\n@@ -0,0 +1,63 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Buffered stream implementations\n+\n+#ifndef ARROW_IO_BUFFERED_H\n+#define ARROW_IO_BUFFERED_H\n+\n+#include <memory>\n+#include <string>\n+\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+\n+class Status;\n+\n+namespace io {\n+\n+class ARROW_EXPORT BufferedOutputStream : public OutputStream {\n+ public:\n+  ~BufferedOutputStream() override;\n+\n+  /// \\brief Create a buffered output stream wrapping the given output stream.\n+  explicit BufferedOutputStream(std::shared_ptr<OutputStream> raw);\n+\n+  // OutputStream interface\n+\n+  /// \\brief Close the buffered output stream.  This implicitly closes the\n+  /// underlying raw output stream.\n+  Status Close() override;\n+\n+  Status Tell(int64_t* position) const override;\n+  // Write bytes to the stream. Thread-safe\n+  Status Write(const void* data, int64_t nbytes) override;\n+\n+  /// \\brief Return the underlying raw output stream.\n+  std::shared_ptr<OutputStream> raw() const;\n+\n+ private:\n+  class ARROW_NO_EXPORT Impl;\n+  std::unique_ptr<Impl> impl_;\n+};\n+\n+}  // namespace io\n+}  // namespace arrow\n+\n+#endif  // ARROW_IO_BUFFERED_H\ndiff --git a/cpp/src/arrow/io/file.cc b/cpp/src/arrow/io/file.cc\nindex 02cc4dbbd6..008f2b2e22 100644\n--- a/cpp/src/arrow/io/file.cc\n+++ b/cpp/src/arrow/io/file.cc\n@@ -388,8 +388,10 @@ class OSFile {\n \n   Status Close() {\n     if (is_open_) {\n-      RETURN_NOT_OK(FileClose(fd_));\n+      // Even if closing fails, the fd will likely be closed (perhaps it's\n+      // already closed).\n       is_open_ = false;\n+      RETURN_NOT_OK(FileClose(fd_));\n     }\n     return Status::OK();\n   }\ndiff --git a/cpp/src/arrow/io/io-buffered-test.cc b/cpp/src/arrow/io/io-buffered-test.cc\nnew file mode 100644\nindex 0000000000..829a2d52fc\n--- /dev/null\n+++ b/cpp/src/arrow/io/io-buffered-test.cc\n@@ -0,0 +1,228 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <memory>\n+#include <random>\n+#include <string>\n+#include <valarray>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/io/buffered.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/io/test-common.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/test-util.h\"\n+\n+namespace arrow {\n+namespace io {\n+\n+static std::string GenerateRandomData(size_t nbytes) {\n+  // MSVC doesn't accept uint8_t for std::independent_bits_engine<>\n+  typedef unsigned long UInt;  // NOLINT\n+  std::independent_bits_engine<std::default_random_engine, 8 * sizeof(UInt), UInt> engine;\n+\n+  std::vector<UInt> data(nbytes / sizeof(UInt) + 1);\n+  std::generate(begin(data), end(data), std::ref(engine));\n+  return std::string(reinterpret_cast<char*>(data.data()), nbytes);\n+}\n+\n+class FileTestFixture : public ::testing::Test {\n+ public:\n+  void SetUp() {\n+    path_ = \"arrow-test-io-buffered-output-stream.txt\";\n+    EnsureFileDeleted();\n+  }\n+\n+  void TearDown() { EnsureFileDeleted(); }\n+\n+  void EnsureFileDeleted() {\n+    if (FileExists(path_)) {\n+      std::remove(path_.c_str());\n+    }\n+  }\n+\n+ protected:\n+  std::string path_;\n+};\n+\n+// ----------------------------------------------------------------------\n+// File output tests\n+\n+class TestBufferedOutputStream : public FileTestFixture {\n+ public:\n+  void OpenBuffered(bool append = false) {\n+    stream_.reset();\n+    std::shared_ptr<FileOutputStream> file;\n+    ASSERT_OK(FileOutputStream::Open(path_, append, &file));\n+    fd_ = file->file_descriptor();\n+    if (append) {\n+    // Workaround for ARROW-2466 (\"append\" flag doesn't set file pos)\n+#if defined(_MSC_VER)\n+      _lseeki64(fd_, 0, SEEK_END);\n+#else\n+      lseek(fd_, 0, SEEK_END);\n+#endif\n+    }\n+    stream_ = std::make_shared<BufferedOutputStream>(std::move(file));\n+  }\n+\n+  void WriteChunkwise(const std::string& datastr, const std::valarray<int64_t>& sizes) {\n+    const char* data = datastr.data();\n+    const int64_t data_size = static_cast<int64_t>(datastr.size());\n+    int64_t data_pos = 0;\n+    auto size_it = std::begin(sizes);\n+\n+    // Write datastr, chunk by chunk, until exhausted\n+    while (true) {\n+      int64_t size = *size_it++;\n+      if (size_it == std::end(sizes)) {\n+        size_it = std::begin(sizes);\n+      }\n+      if (data_pos + size > data_size) {\n+        break;\n+      }\n+      ASSERT_OK(stream_->Write(data + data_pos, size));\n+      data_pos += size;\n+    }\n+    ASSERT_OK(stream_->Write(data + data_pos, data_size - data_pos));\n+  }\n+\n+  void AssertTell(int64_t expected) {\n+    int64_t actual;\n+    ASSERT_OK(stream_->Tell(&actual));\n+    ASSERT_EQ(expected, actual);\n+  }\n+\n+ protected:\n+  int fd_;\n+  std::shared_ptr<OutputStream> stream_;\n+};\n+\n+TEST_F(TestBufferedOutputStream, DestructorClosesFile) {\n+  OpenBuffered();\n+  ASSERT_FALSE(FileIsClosed(fd_));\n+  stream_.reset();\n+  ASSERT_TRUE(FileIsClosed(fd_));\n+}\n+\n+TEST_F(TestBufferedOutputStream, ExplicitCloseClosesFile) {\n+  OpenBuffered();\n+  ASSERT_FALSE(FileIsClosed(fd_));\n+  ASSERT_OK(stream_->Close());\n+  ASSERT_TRUE(FileIsClosed(fd_));\n+  // Idempotency\n+  ASSERT_OK(stream_->Close());\n+  ASSERT_TRUE(FileIsClosed(fd_));\n+}\n+\n+TEST_F(TestBufferedOutputStream, InvalidWrites) {\n+  OpenBuffered();\n+\n+  const char* data = \"\";\n+  ASSERT_RAISES(Invalid, stream_->Write(data, -1));\n+}\n+\n+TEST_F(TestBufferedOutputStream, TinyWrites) {\n+  OpenBuffered();\n+\n+  const std::string datastr = \"1234568790\";\n+  const char* data = datastr.data();\n+\n+  ASSERT_OK(stream_->Write(data, 2));\n+  ASSERT_OK(stream_->Write(data + 2, 6));\n+  ASSERT_OK(stream_->Close());\n+\n+  AssertFileContents(path_, datastr.substr(0, 8));\n+}\n+\n+TEST_F(TestBufferedOutputStream, SmallWrites) {\n+  OpenBuffered();\n+\n+  // Data here should be larger than BufferedOutputStream's buffer size\n+  const std::string data = GenerateRandomData(200000);\n+  const std::valarray<int64_t> sizes = {1, 1, 2, 3, 5, 8, 13};\n+\n+  WriteChunkwise(data, sizes);\n+  ASSERT_OK(stream_->Close());\n+\n+  AssertFileContents(path_, data);\n+}\n+\n+TEST_F(TestBufferedOutputStream, MixedWrites) {\n+  OpenBuffered();\n+\n+  const std::string data = GenerateRandomData(300000);\n+  const std::valarray<int64_t> sizes = {1, 1, 2, 3, 70000};\n+\n+  WriteChunkwise(data, sizes);\n+  ASSERT_OK(stream_->Close());\n+\n+  AssertFileContents(path_, data);\n+}\n+\n+TEST_F(TestBufferedOutputStream, LargeWrites) {\n+  OpenBuffered();\n+\n+  const std::string data = GenerateRandomData(800000);\n+  const std::valarray<int64_t> sizes = {10000, 60000, 70000};\n+\n+  WriteChunkwise(data, sizes);\n+  ASSERT_OK(stream_->Close());\n+\n+  AssertFileContents(path_, data);\n+}\n+\n+TEST_F(TestBufferedOutputStream, Tell) {\n+  OpenBuffered();\n+\n+  AssertTell(0);\n+  AssertTell(0);\n+  WriteChunkwise(std::string(100, 'x'), {1, 1, 2, 3, 5, 8});\n+  AssertTell(100);\n+  WriteChunkwise(std::string(100000, 'x'), {60000});\n+  AssertTell(100100);\n+\n+  ASSERT_OK(stream_->Close());\n+\n+  OpenBuffered(true /* append */);\n+  AssertTell(100100);\n+  WriteChunkwise(std::string(90, 'x'), {1, 1, 2, 3, 5, 8});\n+  AssertTell(100190);\n+\n+  ASSERT_OK(stream_->Close());\n+\n+  OpenBuffered();\n+  AssertTell(0);\n+}\n+\n+TEST_F(TestBufferedOutputStream, TruncatesFile) {\n+  OpenBuffered();\n+\n+  const std::string datastr = \"1234568790\";\n+  ASSERT_OK(stream_->Write(datastr.data(), datastr.size()));\n+  ASSERT_OK(stream_->Close());\n+\n+  AssertFileContents(path_, datastr);\n+\n+  OpenBuffered();\n+  AssertFileContents(path_, \"\");\n+}\n+\n+}  // namespace io\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/io/io-file-benchmark.cc b/cpp/src/arrow/io/io-file-benchmark.cc\nnew file mode 100644\nindex 0000000000..bb35b080d1\n--- /dev/null\n+++ b/cpp/src/arrow/io/io-file-benchmark.cc\n@@ -0,0 +1,95 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/io/buffered.h\"\n+#include \"arrow/io/file.h\"\n+#include \"arrow/test-util.h\"\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include <algorithm>\n+#include <iostream>\n+#include <valarray>\n+\n+namespace arrow {\n+\n+// XXX Writing to /dev/null is irrealistic as the kernel likely doesn't\n+// copy the data at all.  Use a socketpair instead?\n+std::string GetNullFile() { return \"/dev/null\"; }\n+\n+const std::valarray<int64_t> small_sizes = {8, 24, 33, 1, 32, 192, 16, 40};\n+const std::valarray<int64_t> large_sizes = {8192, 100000};\n+\n+static void BenchmarkStreamingWrites(benchmark::State& state,\n+                                     std::valarray<int64_t> sizes,\n+                                     io::OutputStream* stream) {\n+  const std::string datastr(*std::max_element(std::begin(sizes), std::end(sizes)), 'x');\n+  const void* data = datastr.data();\n+  const int64_t sum_sizes = sizes.sum();\n+\n+  while (state.KeepRunning()) {\n+    for (const int64_t size : sizes) {\n+      ABORT_NOT_OK(stream->Write(data, size));\n+    }\n+  }\n+  state.SetBytesProcessed(int64_t(state.iterations()) * sum_sizes);\n+}\n+\n+static void BM_FileOutputStreamSmallWrites(\n+    benchmark::State& state) {  // NOLINT non-const reference\n+  std::shared_ptr<io::OutputStream> stream;\n+  ABORT_NOT_OK(io::FileOutputStream::Open(GetNullFile(), &stream));\n+\n+  BenchmarkStreamingWrites(state, small_sizes, stream.get());\n+}\n+\n+static void BM_FileOutputStreamLargeWrites(\n+    benchmark::State& state) {  // NOLINT non-const reference\n+  std::shared_ptr<io::OutputStream> stream;\n+  ABORT_NOT_OK(io::FileOutputStream::Open(GetNullFile(), &stream));\n+\n+  BenchmarkStreamingWrites(state, large_sizes, stream.get());\n+}\n+\n+static void BM_BufferedOutputStreamSmallWrites(\n+    benchmark::State& state) {  // NOLINT non-const reference\n+  std::shared_ptr<io::OutputStream> stream;\n+  ABORT_NOT_OK(io::FileOutputStream::Open(GetNullFile(), &stream));\n+  stream = std::make_shared<io::BufferedOutputStream>(std::move(stream));\n+\n+  BenchmarkStreamingWrites(state, small_sizes, stream.get());\n+}\n+\n+static void BM_BufferedOutputStreamLargeWrites(\n+    benchmark::State& state) {  // NOLINT non-const reference\n+  std::shared_ptr<io::OutputStream> stream;\n+  ABORT_NOT_OK(io::FileOutputStream::Open(GetNullFile(), &stream));\n+  stream = std::make_shared<io::BufferedOutputStream>(std::move(stream));\n+\n+  BenchmarkStreamingWrites(state, large_sizes, stream.get());\n+}\n+\n+BENCHMARK(BM_FileOutputStreamSmallWrites)->Repetitions(2)->MinTime(1.0);\n+\n+BENCHMARK(BM_FileOutputStreamLargeWrites)->Repetitions(2)->MinTime(1.0);\n+\n+BENCHMARK(BM_BufferedOutputStreamSmallWrites)->Repetitions(2)->MinTime(1.0);\n+\n+BENCHMARK(BM_BufferedOutputStreamLargeWrites)->Repetitions(2)->MinTime(1.0);\n+\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/io/io-file-test.cc b/cpp/src/arrow/io/io-file-test.cc\nindex 53218ca857..098e82f437 100644\n--- a/cpp/src/arrow/io/io-file-test.cc\n+++ b/cpp/src/arrow/io/io-file-test.cc\n@@ -21,17 +21,12 @@\n #include <cstdio>\n #include <cstdlib>\n #include <cstring>\n-#include <fstream>  // IWYU pragma: keep\n #include <memory>\n #include <sstream>  // IWYU pragma: keep\n #include <string>\n #include <thread>\n #include <vector>\n \n-#ifndef _MSC_VER\n-#include <fcntl.h>\n-#endif\n-\n #include <gtest/gtest.h>\n \n #include \"arrow/buffer.h\"\n@@ -45,38 +40,6 @@\n namespace arrow {\n namespace io {\n \n-static bool FileExists(const std::string& path) {\n-  return std::ifstream(path.c_str()).good();\n-}\n-\n-#if defined(_MSC_VER)\n-void InvalidParamHandler(const wchar_t* expr, const wchar_t* func,\n-                         const wchar_t* source_file, unsigned int source_line,\n-                         uintptr_t reserved) {\n-  wprintf(L\"Invalid parameter in function %s. Source: %s line %d expression %s\", func,\n-          source_file, source_line, expr);\n-}\n-#endif\n-\n-static bool FileIsClosed(int fd) {\n-#if defined(_MSC_VER)\n-  // Disables default behavior on wrong params which causes the application to crash\n-  // https://msdn.microsoft.com/en-us/library/ksazx244.aspx\n-  _set_invalid_parameter_handler(InvalidParamHandler);\n-\n-  // Disables possible assertion alert box on invalid input arguments\n-  _CrtSetReportMode(_CRT_ASSERT, 0);\n-\n-  int ret = static_cast<int>(_close(fd));\n-  return (ret == -1);\n-#else\n-  if (-1 != fcntl(fd, F_GETFD)) {\n-    return false;\n-  }\n-  return errno == EBADF;\n-#endif\n-}\n-\n class FileTestFixture : public ::testing::Test {\n  public:\n   void SetUp() {\n@@ -155,12 +118,7 @@ TEST_F(TestFileOutputStream, Close) {\n   // Idempotent\n   ASSERT_OK(file_->Close());\n \n-  std::shared_ptr<ReadableFile> rd_file;\n-  ASSERT_OK(ReadableFile::Open(path_, &rd_file));\n-\n-  int64_t size = 0;\n-  ASSERT_OK(rd_file->GetSize(&size));\n-  ASSERT_EQ(strlen(data), size);\n+  AssertFileContents(path_, data);\n \n   ASSERT_OK(stream_->Write(data, strlen(data)));\n \n@@ -171,9 +129,7 @@ TEST_F(TestFileOutputStream, Close) {\n   // Idempotent\n   ASSERT_OK(stream_->Close());\n \n-  ASSERT_OK(ReadableFile::Open(path_, &rd_file));\n-  ASSERT_OK(rd_file->GetSize(&size));\n-  ASSERT_EQ(strlen(data), size);\n+  AssertFileContents(path_, data);\n }\n \n TEST_F(TestFileOutputStream, InvalidWrites) {\n@@ -215,12 +171,7 @@ TEST_F(TestFileOutputStream, TruncatesNewFile) {\n   ASSERT_OK(FileOutputStream::Open(path_, &file_));\n   ASSERT_OK(file_->Close());\n \n-  std::shared_ptr<ReadableFile> rd_file;\n-  ASSERT_OK(ReadableFile::Open(path_, &rd_file));\n-\n-  int64_t size;\n-  ASSERT_OK(rd_file->GetSize(&size));\n-  ASSERT_EQ(0, size);\n+  AssertFileContents(path_, \"\");\n \n   ASSERT_OK(FileOutputStream::Open(path_, &stream_));\n \n@@ -230,9 +181,7 @@ TEST_F(TestFileOutputStream, TruncatesNewFile) {\n   ASSERT_OK(FileOutputStream::Open(path_, &stream_));\n   ASSERT_OK(stream_->Close());\n \n-  ASSERT_OK(ReadableFile::Open(path_, &rd_file));\n-  ASSERT_OK(rd_file->GetSize(&size));\n-  ASSERT_EQ(0, size);\n+  AssertFileContents(path_, \"\");\n }\n \n // ----------------------------------------------------------------------\ndiff --git a/cpp/src/arrow/io/test-common.h b/cpp/src/arrow/io/test-common.h\nindex a4974b7752..fa9145259b 100644\n--- a/cpp/src/arrow/io/test-common.h\n+++ b/cpp/src/arrow/io/test-common.h\n@@ -20,10 +20,15 @@\n \n #include <algorithm>\n #include <cstdint>\n+#include <fstream>  // IWYU pragma: keep\n #include <memory>\n #include <string>\n #include <vector>\n \n+#ifndef _MSC_VER\n+#include <fcntl.h>\n+#endif\n+\n #if defined(__MINGW32__)  // MinGW\n // nothing\n #elif defined(_MSC_VER)  // Visual Studio\n@@ -41,6 +46,56 @@\n namespace arrow {\n namespace io {\n \n+static inline void AssertFileContents(const std::string& path,\n+                                      const std::string& contents) {\n+  std::shared_ptr<ReadableFile> rf;\n+  int64_t size;\n+\n+  ASSERT_OK(ReadableFile::Open(path, &rf));\n+  ASSERT_OK(rf->GetSize(&size));\n+  ASSERT_EQ(size, contents.size());\n+\n+  std::shared_ptr<Buffer> actual_data;\n+  ASSERT_OK(rf->Read(size, &actual_data));\n+  ASSERT_TRUE(actual_data->Equals(Buffer(contents)));\n+}\n+\n+static inline bool FileExists(const std::string& path) {\n+  return std::ifstream(path.c_str()).good();\n+}\n+\n+#if defined(_MSC_VER)\n+static inline void InvalidParamHandler(const wchar_t* expr, const wchar_t* func,\n+                                       const wchar_t* source_file,\n+                                       unsigned int source_line, uintptr_t reserved) {\n+  wprintf(L\"Invalid parameter in function '%s'. Source: '%s' line %d expression '%s'\\n\",\n+          func, source_file, source_line, expr);\n+}\n+#endif\n+\n+static inline bool FileIsClosed(int fd) {\n+#if defined(_MSC_VER)\n+  // Disables default behavior on wrong params which causes the application to crash\n+  // https://msdn.microsoft.com/en-us/library/ksazx244.aspx\n+  _set_invalid_parameter_handler(InvalidParamHandler);\n+\n+  // Disables possible assertion alert box on invalid input arguments\n+  _CrtSetReportMode(_CRT_ASSERT, 0);\n+\n+  int new_fd = _dup(fd);\n+  if (new_fd == -1) {\n+    return errno == EBADF;\n+  }\n+  _close(new_fd);\n+  return false;\n+#else\n+  if (-1 != fcntl(fd, F_GETFD)) {\n+    return false;\n+  }\n+  return errno == EBADF;\n+#endif\n+}\n+\n static inline Status ZeroMemoryMap(MemoryMappedFile* file) {\n   constexpr int64_t kBufferSize = 512;\n   static constexpr uint8_t kZeroBytes[kBufferSize] = {0};\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-18T10:58:55.614+0000",
                    "updated": "2018-04-18T10:58:55.614+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13145551/comment/16442283",
                    "id": "16442283",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "Issue resolved by pull request 1903\n[https://github.com/apache/arrow/pull/1903]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2018-04-18T11:00:01.701+0000",
                    "updated": "2018-04-18T11:00:01.701+0000"
                }
            ],
            "maxResults": 3,
            "total": 3,
            "startAt": 0
        },
        "customfield_12311820": "0|i3rdin:",
        "customfield_12314139": null
    }
}