{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13449553",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553",
    "key": "ARROW-16809",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351550",
                "id": "12351550",
                "name": "9.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-08-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=ichauster",
            "name": "ichauster",
            "key": "JIRAUSER290345",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34055",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34055",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34055",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34055"
            },
            "displayName": "Ivan Chau",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334978",
                "id": "12334978",
                "name": "Benchmarking"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=ichauster",
            "name": "ichauster",
            "key": "JIRAUSER290345",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34055",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34055",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34055",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34055"
            },
            "displayName": "Ivan Chau",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=ichauster",
            "name": "ichauster",
            "key": "JIRAUSER290345",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34055",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34055",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34055",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34055"
            },
            "displayName": "Ivan Chau",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 19200,
            "total": 19200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 19200,
            "total": 19200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16809/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 32,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/780387",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster opened a new pull request, #13366:\nURL: https://github.com/apache/arrow/pull/13366\n\n   Add `filter_benchmark.cc` and add to `arrow/compute/exec/CMakeLists`\n\n\n",
                    "created": "2022-06-10T17:48:32.920+0000",
                    "updated": "2022-06-10T17:48:32.920+0000",
                    "started": "2022-06-10T17:48:32.920+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780387",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/780388",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#issuecomment-1152598209\n\n   https://issues.apache.org/jira/browse/ARROW-16809\n\n\n",
                    "created": "2022-06-10T17:48:52.704+0000",
                    "updated": "2022-06-10T17:48:52.704+0000",
                    "started": "2022-06-10T17:48:52.704+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780388",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/780389",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#issuecomment-1152598215\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-06-10T17:48:54.594+0000",
                    "updated": "2022-06-10T17:48:54.594+0000",
                    "started": "2022-06-10T17:48:54.594+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780389",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/780390",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster commented on code in PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#discussion_r894772961\n\n\n##########\ncpp/src/arrow/compute/exec/filter_benchmark.cc:\n##########\n@@ -0,0 +1,176 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include <condition_variable>\n+#include <mutex>\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/dataset/partition.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/generator.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+static constexpr int64_t kTotalBatchSize = 1000000;\n+\n+static void FilterOverhead(benchmark::State& state, Expression expr) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         ExecPlan::Make(&ctx));\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+    ASSERT_OK(Declaration::Sequence(\n+                  {\n+                      {\"source\",\n+                       SourceNodeOptions{data.schema,\n+                                         data.gen(/*parallel=*/true, /*slow=*/false)},\n+                       \"custom_source_label\"},\n+                      {\"filter\",\n+                       FilterNodeOptions{\n+                           expr,\n+                       }},\n+                      {\"sink\", SinkNodeOptions{&sink_gen}, \"custom_sink_label\"},\n+                  })\n+                  .AddToPlan(plan.get()));\n+    state.ResumeTiming();\n+    ASSERT_FINISHES_OK(StartAndCollect(plan.get(), sink_gen));\n+  }\n+  state.counters[\"rows_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches * batch_size),\n+      benchmark::Counter::kIsRate);\n+\n+  state.counters[\"batches_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches), benchmark::Counter::kIsRate);\n+}\n+\n+static void FilterOverheadIsolated(benchmark::State& state, Expression expr) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         ExecPlan::Make(&ctx));\n+    // Source and sink nodes have no effect on the benchmark.\n+    // Used for dummy purposes as they are referenced in InputReceived and InputFinished.\n+    ASSERT_OK_AND_ASSIGN(\n+        arrow::compute::ExecNode * source_node,\n+        MakeExecNode(\"source\", plan.get(), {},\n+                     SourceNodeOptions{data.schema, data.gen(/*parallel=*/true,\n+                                                             /*slow=*/false)}));\n+    ASSERT_OK_AND_ASSIGN(arrow::compute::ExecNode * project_node,\n+                         MakeExecNode(\"filter\", plan.get(), {source_node},\n+                                      FilterNodeOptions{\n+                                          expr,\n+                                      }));\n+    MakeExecNode(\"sink\", plan.get(), {project_node}, SinkNodeOptions{&sink_gen});\n+\n+    std::unique_ptr<arrow::compute::TaskScheduler> scheduler = TaskScheduler::Make();\n+    std::condition_variable all_tasks_finished_cv;\n+    std::mutex mutex;\n+    int task_group_id = scheduler->RegisterTaskGroup(\n+        [&](size_t thread_id, int64_t task_id) {\n+          project_node->InputReceived(source_node, data.batches[task_id]);\n+          return Status::OK();\n+        },\n+        [&](size_t thread_id) {\n+          project_node->InputFinished(source_node, static_cast<int>(data.batches.size()));\n+          std::unique_lock<std::mutex> lk(mutex);\n+          all_tasks_finished_cv.notify_one();\n+          return Status::OK();\n+        });\n+    scheduler->RegisterEnd();\n+    ThreadIndexer thread_indexer;\n+\n+    state.ResumeTiming();\n+    arrow::internal::ThreadPool* thread_pool = arrow::internal::GetCpuThreadPool();\n+    ASSERT_OK(scheduler->StartScheduling(\n+        thread_indexer(),\n+        [&](std::function<Status(size_t)> task) -> Status {\n+          return thread_pool->Spawn([&, task]() {\n+            size_t tid = thread_indexer();\n+            ARROW_DCHECK_OK(task(tid));\n+          });\n+        },\n+        thread_pool->GetCapacity(),\n+        /*use_sync_execution=*/false));\n+    std::unique_lock<std::mutex> lk(mutex);\n+    ASSERT_OK(scheduler->StartTaskGroup(thread_indexer(), task_group_id, num_batches));\n+    all_tasks_finished_cv.wait(lk);\n+    ASSERT_TRUE(project_node->finished().is_finished());\n+  }\n+  state.counters[\"rows_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches * batch_size),\n+      benchmark::Counter::kIsRate);\n+\n+  state.counters[\"batches_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches), benchmark::Counter::kIsRate);\n+}\n+\n+arrow::compute::Expression complex_expression =\n+    less(less(field_ref(\"i64\"), literal(20)), greater(field_ref(\"i64\"), literal(0)));\n+arrow::compute::Expression simple_expression =\n+    less(call(\"negate\", {field_ref(\"i64\")}), literal(0));\n+arrow::compute::Expression zero_copy_expression = is_valid((call(\n+    \"cast\", {field_ref(\"i64\")}, compute::CastOptions::Safe(timestamp(TimeUnit::NANO)))));\n+arrow::compute::Expression ref_only_expression = less(field_ref(\"i64\"), literal(0));\n\nReview Comment:\n   I'm not sure how we want to express the complexity of filter expressions, so I used a similar approach to `ExpressionOverhead` / `ProjectBenchmarks`. `zero_copy` seems to perform a bit better than the others because it uses `is_valid` (I cannot do the less operation on timestamps). \r\n   \r\n   Is there something I can change to make these more consistent?\n\n\n\n",
                    "created": "2022-06-10T17:52:19.441+0000",
                    "updated": "2022-06-10T17:52:19.441+0000",
                    "started": "2022-06-10T17:52:19.441+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780390",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/780391",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster commented on PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#issuecomment-1152601282\n\n   Hi @westonpace, this is a similar PR to #13314, just switched out the `ProjectNode` for a `FilterNode`. \r\n   \r\n   I had some questions about the expression complexity and if we would want to adjust that for these benchmarks!\n\n\n",
                    "created": "2022-06-10T17:53:27.966+0000",
                    "updated": "2022-06-10T17:53:27.966+0000",
                    "started": "2022-06-10T17:53:27.966+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780391",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/780399",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster commented on code in PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#discussion_r894772961\n\n\n##########\ncpp/src/arrow/compute/exec/filter_benchmark.cc:\n##########\n@@ -0,0 +1,176 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include <condition_variable>\n+#include <mutex>\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/dataset/partition.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/generator.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+static constexpr int64_t kTotalBatchSize = 1000000;\n+\n+static void FilterOverhead(benchmark::State& state, Expression expr) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         ExecPlan::Make(&ctx));\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+    ASSERT_OK(Declaration::Sequence(\n+                  {\n+                      {\"source\",\n+                       SourceNodeOptions{data.schema,\n+                                         data.gen(/*parallel=*/true, /*slow=*/false)},\n+                       \"custom_source_label\"},\n+                      {\"filter\",\n+                       FilterNodeOptions{\n+                           expr,\n+                       }},\n+                      {\"sink\", SinkNodeOptions{&sink_gen}, \"custom_sink_label\"},\n+                  })\n+                  .AddToPlan(plan.get()));\n+    state.ResumeTiming();\n+    ASSERT_FINISHES_OK(StartAndCollect(plan.get(), sink_gen));\n+  }\n+  state.counters[\"rows_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches * batch_size),\n+      benchmark::Counter::kIsRate);\n+\n+  state.counters[\"batches_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches), benchmark::Counter::kIsRate);\n+}\n+\n+static void FilterOverheadIsolated(benchmark::State& state, Expression expr) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         ExecPlan::Make(&ctx));\n+    // Source and sink nodes have no effect on the benchmark.\n+    // Used for dummy purposes as they are referenced in InputReceived and InputFinished.\n+    ASSERT_OK_AND_ASSIGN(\n+        arrow::compute::ExecNode * source_node,\n+        MakeExecNode(\"source\", plan.get(), {},\n+                     SourceNodeOptions{data.schema, data.gen(/*parallel=*/true,\n+                                                             /*slow=*/false)}));\n+    ASSERT_OK_AND_ASSIGN(arrow::compute::ExecNode * project_node,\n+                         MakeExecNode(\"filter\", plan.get(), {source_node},\n+                                      FilterNodeOptions{\n+                                          expr,\n+                                      }));\n+    MakeExecNode(\"sink\", plan.get(), {project_node}, SinkNodeOptions{&sink_gen});\n+\n+    std::unique_ptr<arrow::compute::TaskScheduler> scheduler = TaskScheduler::Make();\n+    std::condition_variable all_tasks_finished_cv;\n+    std::mutex mutex;\n+    int task_group_id = scheduler->RegisterTaskGroup(\n+        [&](size_t thread_id, int64_t task_id) {\n+          project_node->InputReceived(source_node, data.batches[task_id]);\n+          return Status::OK();\n+        },\n+        [&](size_t thread_id) {\n+          project_node->InputFinished(source_node, static_cast<int>(data.batches.size()));\n+          std::unique_lock<std::mutex> lk(mutex);\n+          all_tasks_finished_cv.notify_one();\n+          return Status::OK();\n+        });\n+    scheduler->RegisterEnd();\n+    ThreadIndexer thread_indexer;\n+\n+    state.ResumeTiming();\n+    arrow::internal::ThreadPool* thread_pool = arrow::internal::GetCpuThreadPool();\n+    ASSERT_OK(scheduler->StartScheduling(\n+        thread_indexer(),\n+        [&](std::function<Status(size_t)> task) -> Status {\n+          return thread_pool->Spawn([&, task]() {\n+            size_t tid = thread_indexer();\n+            ARROW_DCHECK_OK(task(tid));\n+          });\n+        },\n+        thread_pool->GetCapacity(),\n+        /*use_sync_execution=*/false));\n+    std::unique_lock<std::mutex> lk(mutex);\n+    ASSERT_OK(scheduler->StartTaskGroup(thread_indexer(), task_group_id, num_batches));\n+    all_tasks_finished_cv.wait(lk);\n+    ASSERT_TRUE(project_node->finished().is_finished());\n+  }\n+  state.counters[\"rows_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches * batch_size),\n+      benchmark::Counter::kIsRate);\n+\n+  state.counters[\"batches_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches), benchmark::Counter::kIsRate);\n+}\n+\n+arrow::compute::Expression complex_expression =\n+    less(less(field_ref(\"i64\"), literal(20)), greater(field_ref(\"i64\"), literal(0)));\n+arrow::compute::Expression simple_expression =\n+    less(call(\"negate\", {field_ref(\"i64\")}), literal(0));\n+arrow::compute::Expression zero_copy_expression = is_valid((call(\n+    \"cast\", {field_ref(\"i64\")}, compute::CastOptions::Safe(timestamp(TimeUnit::NANO)))));\n+arrow::compute::Expression ref_only_expression = less(field_ref(\"i64\"), literal(0));\n\nReview Comment:\n   I'm not sure how we want to express the complexity of filter expressions, so I used a similar approach to `ExpressionOverhead` / `ProjectBenchmarks`. `zero_copy` seems to perform a bit better than the others because it uses `is_valid` (Not sure why the less operation isn't working on timestamps). \r\n   \r\n   Is there something I can change to make these more consistent?\n\n\n\n",
                    "created": "2022-06-10T18:07:15.936+0000",
                    "updated": "2022-06-10T18:07:15.936+0000",
                    "started": "2022-06-10T18:07:15.935+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "780399",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/781646",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster commented on PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#issuecomment-1156462898\n\n   Hi @westonpace, let me know if you've gotten a chance to take a look at this!\n\n\n",
                    "created": "2022-06-15T13:18:52.742+0000",
                    "updated": "2022-06-15T13:18:52.742+0000",
                    "started": "2022-06-15T13:18:52.741+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "781646",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/782222",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#discussion_r899691871\n\n\n##########\ncpp/src/arrow/compute/exec/filter_benchmark.cc:\n##########\n@@ -0,0 +1,176 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include <condition_variable>\n+#include <mutex>\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/dataset/partition.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/generator.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+static constexpr int64_t kTotalBatchSize = 1000000;\n+\n+static void FilterOverhead(benchmark::State& state, Expression expr) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         ExecPlan::Make(&ctx));\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+    ASSERT_OK(Declaration::Sequence(\n+                  {\n+                      {\"source\",\n+                       SourceNodeOptions{data.schema,\n+                                         data.gen(/*parallel=*/true, /*slow=*/false)},\n+                       \"custom_source_label\"},\n+                      {\"filter\",\n+                       FilterNodeOptions{\n+                           expr,\n+                       }},\n+                      {\"sink\", SinkNodeOptions{&sink_gen}, \"custom_sink_label\"},\n+                  })\n+                  .AddToPlan(plan.get()));\n+    state.ResumeTiming();\n+    ASSERT_FINISHES_OK(StartAndCollect(plan.get(), sink_gen));\n+  }\n+  state.counters[\"rows_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches * batch_size),\n+      benchmark::Counter::kIsRate);\n+\n+  state.counters[\"batches_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches), benchmark::Counter::kIsRate);\n+}\n+\n+static void FilterOverheadIsolated(benchmark::State& state, Expression expr) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         ExecPlan::Make(&ctx));\n+    // Source and sink nodes have no effect on the benchmark.\n+    // Used for dummy purposes as they are referenced in InputReceived and InputFinished.\n+    ASSERT_OK_AND_ASSIGN(\n+        arrow::compute::ExecNode * source_node,\n+        MakeExecNode(\"source\", plan.get(), {},\n+                     SourceNodeOptions{data.schema, data.gen(/*parallel=*/true,\n+                                                             /*slow=*/false)}));\n+    ASSERT_OK_AND_ASSIGN(arrow::compute::ExecNode * project_node,\n+                         MakeExecNode(\"filter\", plan.get(), {source_node},\n+                                      FilterNodeOptions{\n+                                          expr,\n+                                      }));\n+    MakeExecNode(\"sink\", plan.get(), {project_node}, SinkNodeOptions{&sink_gen});\n+\n+    std::unique_ptr<arrow::compute::TaskScheduler> scheduler = TaskScheduler::Make();\n+    std::condition_variable all_tasks_finished_cv;\n+    std::mutex mutex;\n+    int task_group_id = scheduler->RegisterTaskGroup(\n+        [&](size_t thread_id, int64_t task_id) {\n+          project_node->InputReceived(source_node, data.batches[task_id]);\n+          return Status::OK();\n+        },\n+        [&](size_t thread_id) {\n+          project_node->InputFinished(source_node, static_cast<int>(data.batches.size()));\n+          std::unique_lock<std::mutex> lk(mutex);\n+          all_tasks_finished_cv.notify_one();\n+          return Status::OK();\n+        });\n+    scheduler->RegisterEnd();\n+    ThreadIndexer thread_indexer;\n+\n+    state.ResumeTiming();\n+    arrow::internal::ThreadPool* thread_pool = arrow::internal::GetCpuThreadPool();\n+    ASSERT_OK(scheduler->StartScheduling(\n+        thread_indexer(),\n+        [&](std::function<Status(size_t)> task) -> Status {\n+          return thread_pool->Spawn([&, task]() {\n+            size_t tid = thread_indexer();\n+            ARROW_DCHECK_OK(task(tid));\n+          });\n+        },\n+        thread_pool->GetCapacity(),\n+        /*use_sync_execution=*/false));\n+    std::unique_lock<std::mutex> lk(mutex);\n+    ASSERT_OK(scheduler->StartTaskGroup(thread_indexer(), task_group_id, num_batches));\n+    all_tasks_finished_cv.wait(lk);\n+    ASSERT_TRUE(project_node->finished().is_finished());\n+  }\n+  state.counters[\"rows_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches * batch_size),\n+      benchmark::Counter::kIsRate);\n+\n+  state.counters[\"batches_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches), benchmark::Counter::kIsRate);\n+}\n+\n+arrow::compute::Expression complex_expression =\n+    less(less(field_ref(\"i64\"), literal(20)), greater(field_ref(\"i64\"), literal(0)));\n+arrow::compute::Expression simple_expression =\n+    less(call(\"negate\", {field_ref(\"i64\")}), literal(0));\n+arrow::compute::Expression zero_copy_expression = is_valid((call(\n+    \"cast\", {field_ref(\"i64\")}, compute::CastOptions::Safe(timestamp(TimeUnit::NANO)))));\n+arrow::compute::Expression ref_only_expression = less(field_ref(\"i64\"), literal(0));\n\nReview Comment:\n   I think that's fine.  I'm not sure `ref_only_expression` is the same thing though?  Perhaps `ref_only_expressions` could be something like `field_ref(\"bool\")` where `bool` is a randomly generated boolean array?\n\n\n\n##########\ncpp/src/arrow/compute/exec/filter_benchmark.cc:\n##########\n@@ -0,0 +1,176 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include <condition_variable>\n+#include <mutex>\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/dataset/partition.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/generator.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+static constexpr int64_t kTotalBatchSize = 1000000;\n+\n+static void FilterOverhead(benchmark::State& state, Expression expr) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         ExecPlan::Make(&ctx));\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+    ASSERT_OK(Declaration::Sequence(\n+                  {\n+                      {\"source\",\n+                       SourceNodeOptions{data.schema,\n+                                         data.gen(/*parallel=*/true, /*slow=*/false)},\n+                       \"custom_source_label\"},\n+                      {\"filter\",\n+                       FilterNodeOptions{\n+                           expr,\n+                       }},\n+                      {\"sink\", SinkNodeOptions{&sink_gen}, \"custom_sink_label\"},\n+                  })\n+                  .AddToPlan(plan.get()));\n+    state.ResumeTiming();\n+    ASSERT_FINISHES_OK(StartAndCollect(plan.get(), sink_gen));\n+  }\n+  state.counters[\"rows_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches * batch_size),\n+      benchmark::Counter::kIsRate);\n+\n+  state.counters[\"batches_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches), benchmark::Counter::kIsRate);\n+}\n+\n+static void FilterOverheadIsolated(benchmark::State& state, Expression expr) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         ExecPlan::Make(&ctx));\n+    // Source and sink nodes have no effect on the benchmark.\n+    // Used for dummy purposes as they are referenced in InputReceived and InputFinished.\n+    ASSERT_OK_AND_ASSIGN(\n+        arrow::compute::ExecNode * source_node,\n+        MakeExecNode(\"source\", plan.get(), {},\n+                     SourceNodeOptions{data.schema, data.gen(/*parallel=*/true,\n+                                                             /*slow=*/false)}));\n+    ASSERT_OK_AND_ASSIGN(arrow::compute::ExecNode * project_node,\n+                         MakeExecNode(\"filter\", plan.get(), {source_node},\n+                                      FilterNodeOptions{\n+                                          expr,\n+                                      }));\n+    MakeExecNode(\"sink\", plan.get(), {project_node}, SinkNodeOptions{&sink_gen});\n+\n+    std::unique_ptr<arrow::compute::TaskScheduler> scheduler = TaskScheduler::Make();\n+    std::condition_variable all_tasks_finished_cv;\n+    std::mutex mutex;\n+    int task_group_id = scheduler->RegisterTaskGroup(\n+        [&](size_t thread_id, int64_t task_id) {\n+          project_node->InputReceived(source_node, data.batches[task_id]);\n+          return Status::OK();\n+        },\n+        [&](size_t thread_id) {\n+          project_node->InputFinished(source_node, static_cast<int>(data.batches.size()));\n+          std::unique_lock<std::mutex> lk(mutex);\n+          all_tasks_finished_cv.notify_one();\n+          return Status::OK();\n+        });\n+    scheduler->RegisterEnd();\n+    ThreadIndexer thread_indexer;\n+\n+    state.ResumeTiming();\n+    arrow::internal::ThreadPool* thread_pool = arrow::internal::GetCpuThreadPool();\n+    ASSERT_OK(scheduler->StartScheduling(\n+        thread_indexer(),\n+        [&](std::function<Status(size_t)> task) -> Status {\n+          return thread_pool->Spawn([&, task]() {\n+            size_t tid = thread_indexer();\n+            ARROW_DCHECK_OK(task(tid));\n+          });\n+        },\n+        thread_pool->GetCapacity(),\n+        /*use_sync_execution=*/false));\n+    std::unique_lock<std::mutex> lk(mutex);\n+    ASSERT_OK(scheduler->StartTaskGroup(thread_indexer(), task_group_id, num_batches));\n+    all_tasks_finished_cv.wait(lk);\n+    ASSERT_TRUE(project_node->finished().is_finished());\n+  }\n+  state.counters[\"rows_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches * batch_size),\n+      benchmark::Counter::kIsRate);\n+\n+  state.counters[\"batches_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches), benchmark::Counter::kIsRate);\n+}\n+\n+arrow::compute::Expression complex_expression =\n+    less(less(field_ref(\"i64\"), literal(20)), greater(field_ref(\"i64\"), literal(0)));\n+arrow::compute::Expression simple_expression =\n+    less(call(\"negate\", {field_ref(\"i64\")}), literal(0));\n+arrow::compute::Expression zero_copy_expression = is_valid((call(\n+    \"cast\", {field_ref(\"i64\")}, compute::CastOptions::Safe(timestamp(TimeUnit::NANO)))));\n\nReview Comment:\n   I don't think we need zero copy for the filter benchmark.  We can probably just get rid of this one.\n\n\n\n##########\ncpp/src/arrow/compute/exec/filter_benchmark.cc:\n##########\n@@ -0,0 +1,176 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include <condition_variable>\n+#include <mutex>\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/dataset/partition.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/generator.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+static constexpr int64_t kTotalBatchSize = 1000000;\n+\n+static void FilterOverhead(benchmark::State& state, Expression expr) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         ExecPlan::Make(&ctx));\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+    ASSERT_OK(Declaration::Sequence(\n+                  {\n+                      {\"source\",\n+                       SourceNodeOptions{data.schema,\n+                                         data.gen(/*parallel=*/true, /*slow=*/false)},\n+                       \"custom_source_label\"},\n+                      {\"filter\",\n+                       FilterNodeOptions{\n+                           expr,\n+                       }},\n+                      {\"sink\", SinkNodeOptions{&sink_gen}, \"custom_sink_label\"},\n+                  })\n+                  .AddToPlan(plan.get()));\n+    state.ResumeTiming();\n+    ASSERT_FINISHES_OK(StartAndCollect(plan.get(), sink_gen));\n+  }\n+  state.counters[\"rows_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches * batch_size),\n+      benchmark::Counter::kIsRate);\n+\n+  state.counters[\"batches_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches), benchmark::Counter::kIsRate);\n+}\n+\n+static void FilterOverheadIsolated(benchmark::State& state, Expression expr) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         ExecPlan::Make(&ctx));\n+    // Source and sink nodes have no effect on the benchmark.\n+    // Used for dummy purposes as they are referenced in InputReceived and InputFinished.\n+    ASSERT_OK_AND_ASSIGN(\n+        arrow::compute::ExecNode * source_node,\n+        MakeExecNode(\"source\", plan.get(), {},\n+                     SourceNodeOptions{data.schema, data.gen(/*parallel=*/true,\n+                                                             /*slow=*/false)}));\n+    ASSERT_OK_AND_ASSIGN(arrow::compute::ExecNode * project_node,\n\nReview Comment:\n   ```suggestion\r\n       ASSERT_OK_AND_ASSIGN(arrow::compute::ExecNode * filter_node,\r\n   ```\r\n   \r\n   Alternatively, we might want to see if we can create a benchmark_util.cc/h that we can use to share some of this logic that will be identical between different benchmarks.  Though maybe filter & project are the only ones simple enough to share the same basic structure.\r\n   \r\n   Also, long term, I think the `XyzIsolated` benchmarks will be less useful, as we address the scheduling issues, so maybe we don't need to spend too much time optimizing the case.  Still, it would be kind of nice to have less code that feels copy/pasted between the benchmarks.\n\n\n\n",
                    "created": "2022-06-17T02:03:41.328+0000",
                    "updated": "2022-06-17T02:03:41.328+0000",
                    "started": "2022-06-17T02:03:41.328+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "782222",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/783546",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster commented on PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#issuecomment-1162283321\n\n   > For a filtering operation I think there is an extra parameter which is the selectivity (what percentage of rows are kept). I think it would be valuable to add that as a parameter but it would make test data generation more complicated.\r\n   \r\n   @westonpace one idea I had to benchmark selectivity is perhaps using the existing 'null_percent/proportion' generators we already have, and then using `is_null` as the filter. Let me know if you think that would be the right approach. \r\n   \n\n\n",
                    "created": "2022-06-21T20:08:04.027+0000",
                    "updated": "2022-06-21T20:08:04.027+0000",
                    "started": "2022-06-21T20:08:04.027+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "783546",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/783909",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster commented on PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#issuecomment-1163390116\n\n   > > For a filtering operation I think there is an extra parameter which is the selectivity (what percentage of rows are kept). I think it would be valuable to add that as a parameter but it would make test data generation more complicated.\r\n   > \r\n   > @westonpace one idea I had to benchmark selectivity is perhaps using the existing 'null_percent/proportion' generators we already have, and then using `is_null` as the filter. Let me know if you think that would be the right approach.\r\n   \r\n   After thinking some more about it, maybe we should use some numerical array with uniform distribution, which will allow us to test multiple filter passes. I think with the other approach, we only can get two (filter out nulls, then filter out by true / false).\n\n\n",
                    "created": "2022-06-22T17:04:45.074+0000",
                    "updated": "2022-06-22T17:04:45.074+0000",
                    "started": "2022-06-22T17:04:45.073+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "783909",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/783945",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster commented on code in PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#discussion_r904131551\n\n\n##########\ncpp/src/arrow/compute/exec/filter_benchmark.cc:\n##########\n@@ -0,0 +1,176 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include <condition_variable>\n+#include <mutex>\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/dataset/partition.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/generator.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+static constexpr int64_t kTotalBatchSize = 1000000;\n+\n+static void FilterOverhead(benchmark::State& state, Expression expr) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         ExecPlan::Make(&ctx));\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+    ASSERT_OK(Declaration::Sequence(\n+                  {\n+                      {\"source\",\n+                       SourceNodeOptions{data.schema,\n+                                         data.gen(/*parallel=*/true, /*slow=*/false)},\n+                       \"custom_source_label\"},\n+                      {\"filter\",\n+                       FilterNodeOptions{\n+                           expr,\n+                       }},\n+                      {\"sink\", SinkNodeOptions{&sink_gen}, \"custom_sink_label\"},\n+                  })\n+                  .AddToPlan(plan.get()));\n+    state.ResumeTiming();\n+    ASSERT_FINISHES_OK(StartAndCollect(plan.get(), sink_gen));\n+  }\n+  state.counters[\"rows_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches * batch_size),\n+      benchmark::Counter::kIsRate);\n+\n+  state.counters[\"batches_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches), benchmark::Counter::kIsRate);\n+}\n+\n+static void FilterOverheadIsolated(benchmark::State& state, Expression expr) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         ExecPlan::Make(&ctx));\n+    // Source and sink nodes have no effect on the benchmark.\n+    // Used for dummy purposes as they are referenced in InputReceived and InputFinished.\n+    ASSERT_OK_AND_ASSIGN(\n+        arrow::compute::ExecNode * source_node,\n+        MakeExecNode(\"source\", plan.get(), {},\n+                     SourceNodeOptions{data.schema, data.gen(/*parallel=*/true,\n+                                                             /*slow=*/false)}));\n+    ASSERT_OK_AND_ASSIGN(arrow::compute::ExecNode * project_node,\n\nReview Comment:\n   Moved most of the logic into `benchmark_util.h`, reflected in `project_benchmark.cc` as well.\n\n\n\n",
                    "created": "2022-06-22T19:01:10.159+0000",
                    "updated": "2022-06-22T19:01:10.159+0000",
                    "started": "2022-06-22T19:01:10.159+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "783945",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/783959",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster commented on code in PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#discussion_r904166211\n\n\n##########\ncpp/src/arrow/compute/exec/filter_benchmark.cc:\n##########\n@@ -0,0 +1,168 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include <condition_variable>\n+#include <mutex>\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/dataset/partition.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/generator.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/benchmark_util.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+static constexpr int64_t kTotalBatchSize = 1000000;\n+constexpr auto kSeed = 0x94378165;\n+\n+static std::shared_ptr<arrow::RecordBatch> GetBatchesWithNullProbability(\n+    const FieldVector& fields, int64_t length, double null_probability,\n+    double bool_true_probability = 0.5) {\n+  std::vector<std::shared_ptr<Array>> arrays(fields.size());\n+  auto rand = random::RandomArrayGenerator(kSeed);\n+  for (size_t i = 0; i < fields.size(); i++) {\n+    const auto& field = fields[i];\n+    if (field.get()->name() == \"bool\") {\n+      arrays[i] = rand.Boolean(length, bool_true_probability, null_probability);\n+    } else {\n\nReview Comment:\n   Because `ArrayOf` doesn't given us too much control over the array of the datatype, we need to add this here... This makes it a bit more difficult to generalize as a utility function that can be used elsewhere ",
                    "created": "2022-06-22T19:47:03.559+0000",
                    "updated": "2022-06-22T19:47:03.559+0000",
                    "started": "2022-06-22T19:47:03.559+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "783959",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/783961",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster commented on PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#issuecomment-1163546329\n\n   @westonpace , I think this is ready for another round of review. I've packaged some of the helpful benchmarking code into `benchmark_util.h`, and have expanded our filter benchmarks. Given some of your notes, most of these have been on the `FilterOverhead` version, which uses the source, node, and sink.\r\n   \r\n   Regarding the multi-pass, there are two parameters: `null probability` (the probability that some element in the batch is null), and `bool_true_probability` (the probability that the boolean in the array is true). \r\n   \r\n   Here are some of my notes:\r\n   - The expressions we are using seem to have far less impact on throughput as compared to projections. All results are around the same magnitude, ~100M rows/s.\r\n   - Interestingly, selectivity can cause some big performance differences, possibly up to 50x speedup, reaching 2G rows/s.\r\n   - Because of this, it may actually be advantageous in some cases for multi-pass filter operations. \r\n   > FilterOverhead/not_null_to_is_true_multipass_benchmark/batch_size:100000/null_prob:100/bool_true_prob:25/real_time        400338 ns        56020 ns         1819 batches_per_second=24.9789k/s rows_per_second=2.49789G/s\r\n   > FilterOverhead/not_null_and_is_true_singlepass_benchmark/batch_size:100000/null_prob:100/bool_true_prob:25/real_time     1226684 ns        78326 ns          581 batches_per_second=8.15206k/s rows_per_second=815.206M/s\r\n   This is probably because the first pass (checking for not null) really shrinks the table, making the second pass (checking for truth) fairly quicker. One caveat is that the passes have to be in the correct order. For example, if we instead check for truth first, and then not null, we do not observe the speedup; but our performance roughly matches single pass.\n\n\n",
                    "created": "2022-06-22T20:01:19.004+0000",
                    "updated": "2022-06-22T20:01:19.004+0000",
                    "started": "2022-06-22T20:01:19.004+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "783961",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/785188",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster commented on PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#issuecomment-1167652804\n\n   Hi @westonpace, let me know if you've gotten a chance to look at this!\r\n   \r\n   Thanks!\n\n\n",
                    "created": "2022-06-27T17:31:05.515+0000",
                    "updated": "2022-06-27T17:31:05.515+0000",
                    "started": "2022-06-27T17:31:05.515+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "785188",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/785762",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#issuecomment-1169377521\n\n   Just a few minor nits.  This looks pretty good.\n\n\n",
                    "created": "2022-06-28T23:15:19.838+0000",
                    "updated": "2022-06-28T23:15:19.838+0000",
                    "started": "2022-06-28T23:15:19.837+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "785762",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/785945",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster commented on PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#issuecomment-1169981636\n\n   Hi @westonpace, was wondering if you could publish the changes you requested ",
                    "created": "2022-06-29T13:28:36.096+0000",
                    "updated": "2022-06-29T13:28:36.096+0000",
                    "started": "2022-06-29T13:28:36.096+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "785945",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/786035",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#discussion_r909068110\n\n\n##########\ncpp/src/arrow/compute/exec/filter_benchmark.cc:\n##########\n@@ -0,0 +1,175 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include <condition_variable>\n+#include <mutex>\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/dataset/partition.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/generator.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/benchmark_util.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+static constexpr int64_t kTotalBatchSize = 1000000;\n+constexpr auto kSeed = 0x94378165;\n+\n+/*\n+    Will return batches of size length, with fields as specified.\n+    null_probability controls the likelihood that an element within the batch is null,\n+   across all fields. bool_true_probability controls the likelihood that an element\n+   belonging to a boolean field is true.\n+*/\n+static std::shared_ptr<arrow::RecordBatch> GetBatchesWithNullProbability(\n+    const FieldVector& fields, int64_t length, double null_probability,\n+    double bool_true_probability = 0.5) {\n+  std::vector<std::shared_ptr<Array>> arrays(fields.size());\n+  auto rand = random::RandomArrayGenerator(kSeed);\n+  for (size_t i = 0; i < fields.size(); i++) {\n+    const auto& field = fields[i];\n+    if (field.get()->name() == \"bool\") {\n+      arrays[i] = rand.Boolean(length, bool_true_probability, null_probability);\n+    } else {\n+      arrays[i] = rand.ArrayOf(field.get()->type(), length, null_probability);\n+    }\n+  }\n+  return RecordBatch::Make(schema(fields), length, std::move(arrays));\n+}\n+\n+BatchesWithSchema MakeRandomBatchesWithNullProbability(\n+    std::shared_ptr<Schema> schema, int num_batches, int batch_size,\n+    double null_probability = 0.5, double bool_true_probability = 0.5) {\n+  BatchesWithSchema out;\n+  out.batches.resize(num_batches);\n+\n+  for (int i = 0; i < num_batches; ++i) {\n+    out.batches[i] = ExecBatch(*GetBatchesWithNullProbability(\n+        schema->fields(), batch_size, null_probability, bool_true_probability));\n+    out.batches[i].values.emplace_back(i);\n+  }\n+  out.schema = schema;\n+  return out;\n+}\n+\n+static void FilterOverhead(benchmark::State& state, std::vector<Expression> expr_vector) {\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const double null_prob = state.range(1) / 100.0;\n+  const double bool_true_probability = state.range(2) / 100.0;\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatchesWithNullProbability(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size,\n+      null_prob, bool_true_probability);\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  std::vector<arrow::compute::Declaration> filter_node_dec;\n+  for (Expression expr : expr_vector) {\n+    filter_node_dec.push_back({\"filter\", FilterNodeOptions(expr)});\n+  }\n+  BenchmarkNodeOverhead(state, ctx, num_batches, batch_size, data, filter_node_dec);\n+}\n+\n+static void FilterOverheadIsolated(benchmark::State& state, Expression expr) {\n+  ExecContext ctx(default_memory_pool(), arrow::internal::GetCpuThreadPool());\n+  const int32_t batch_size = static_cast<int32_t>(state.range(0));\n+  const int32_t num_batches = kTotalBatchSize / batch_size;\n+  arrow::compute::BatchesWithSchema data = MakeRandomBatches(\n+      schema({field(\"i64\", int64()), field(\"bool\", boolean())}), num_batches, batch_size);\n+  FilterNodeOptions options = FilterNodeOptions{expr};\n+  BenchmarkIsolatedNodeOverhead(state, ctx, expr, num_batches, batch_size, data, \"filter\",\n+                                options);\n+}\n+\n+arrow::compute::Expression complex_expression =\n+    less(less(field_ref(\"i64\"), literal(20)), greater(field_ref(\"i64\"), literal(0)));\n+arrow::compute::Expression simple_expression =\n+    less(call(\"negate\", {field_ref(\"i64\")}), literal(0));\n+arrow::compute::Expression ref_only_expression = field_ref(\"bool\");\n+\n+arrow::compute::Expression is_not_null_expression =\n+    not_(is_null(field_ref(\"bool\"), false));\n+arrow::compute::Expression is_true_expression = equal(field_ref(\"bool\"), literal(true));\n+arrow::compute::Expression is_not_null_and_true_expression =\n+    and_(is_not_null_expression, is_true_expression);\n+\n+void SetArgs(benchmark::internal::Benchmark* bench) {\n+  for (int batch_size = 1000; batch_size <= kTotalBatchSize; batch_size *= 10) {\n+    bench->ArgNames({\"batch_size\", \"null_prob\", \"bool_true_prob\"})\n+        ->Args({batch_size, 0, 50})\n+        ->UseRealTime();\n+  }\n+}\n+\n+void SelectivityArgs(benchmark::internal::Benchmark* bench) {\n\nReview Comment:\n   Nit: `SetSelectivityArgs`\n\n\n\n##########\ncpp/src/arrow/compute/exec/filter_benchmark.cc:\n##########\n@@ -0,0 +1,175 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include <condition_variable>\n+#include <mutex>\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/dataset/partition.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/generator.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/benchmark_util.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+static constexpr int64_t kTotalBatchSize = 1000000;\n+constexpr auto kSeed = 0x94378165;\n\nReview Comment:\n   These should probably both be static or neither be static.  For a benchmark file I don't think it really matters (so I'd probably just drop the `static`).\n\n\n\n##########\ncpp/src/arrow/compute/exec/filter_benchmark.cc:\n##########\n@@ -0,0 +1,175 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include <condition_variable>\n+#include <mutex>\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/dataset/partition.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/generator.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/benchmark_util.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+static constexpr int64_t kTotalBatchSize = 1000000;\n+constexpr auto kSeed = 0x94378165;\n+\n+/*\n+    Will return batches of size length, with fields as specified.\n+    null_probability controls the likelihood that an element within the batch is null,\n+   across all fields. bool_true_probability controls the likelihood that an element\n+   belonging to a boolean field is true.\n+*/\n+static std::shared_ptr<arrow::RecordBatch> GetBatchesWithNullProbability(\n+    const FieldVector& fields, int64_t length, double null_probability,\n+    double bool_true_probability = 0.5) {\n+  std::vector<std::shared_ptr<Array>> arrays(fields.size());\n+  auto rand = random::RandomArrayGenerator(kSeed);\n+  for (size_t i = 0; i < fields.size(); i++) {\n+    const auto& field = fields[i];\n+    if (field.get()->name() == \"bool\") {\n+      arrays[i] = rand.Boolean(length, bool_true_probability, null_probability);\n+    } else {\n+      arrays[i] = rand.ArrayOf(field.get()->type(), length, null_probability);\n+    }\n+  }\n+  return RecordBatch::Make(schema(fields), length, std::move(arrays));\n+}\n+\n+BatchesWithSchema MakeRandomBatchesWithNullProbability(\n+    std::shared_ptr<Schema> schema, int num_batches, int batch_size,\n+    double null_probability = 0.5, double bool_true_probability = 0.5) {\n+  BatchesWithSchema out;\n+  out.batches.resize(num_batches);\n+\n+  for (int i = 0; i < num_batches; ++i) {\n+    out.batches[i] = ExecBatch(*GetBatchesWithNullProbability(\n+        schema->fields(), batch_size, null_probability, bool_true_probability));\n+    out.batches[i].values.emplace_back(i);\n+  }\n+  out.schema = schema;\n\nReview Comment:\n   ```suggestion\r\n     out.schema = std::move(schema);\r\n   ```\n\n\n\n##########\ncpp/src/arrow/util/benchmark_util.h:\n##########\n@@ -135,4 +149,114 @@ struct RegressionArgs {\n   bool size_is_bytes_;\n };\n \n-}  // namespace arrow\n+/*\n+  Generates batches from data, then benchmark rows_per_second and batches_per_second for\n+  an isolated node. We do this by passing in batches through a task scheduler, and calling\n+  InputFinished and InputReceived.\n+*/\n\nReview Comment:\n   Prefer `//` over `/*`\n\n\n\n##########\ncpp/src/arrow/compute/exec/filter_benchmark.cc:\n##########\n@@ -0,0 +1,175 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+#include <condition_variable>\n+#include <mutex>\n+\n+#include \"benchmark/benchmark.h\"\n+\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/compute/exec.h\"\n+#include \"arrow/compute/exec/expression.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/task_util.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/dataset/partition.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/testing/future_util.h\"\n+#include \"arrow/testing/generator.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/random.h\"\n+#include \"arrow/type.h\"\n+#include \"arrow/util/benchmark_util.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+static constexpr int64_t kTotalBatchSize = 1000000;\n+constexpr auto kSeed = 0x94378165;\n+\n+/*\n+    Will return batches of size length, with fields as specified.\n+    null_probability controls the likelihood that an element within the batch is null,\n+   across all fields. bool_true_probability controls the likelihood that an element\n+   belonging to a boolean field is true.\n+*/\n\nReview Comment:\n   Can you use `//` for internal comments\n\n\n\n##########\ncpp/src/arrow/util/benchmark_util.h:\n##########\n@@ -135,4 +149,114 @@ struct RegressionArgs {\n   bool size_is_bytes_;\n };\n \n-}  // namespace arrow\n+/*\n+  Generates batches from data, then benchmark rows_per_second and batches_per_second for\n+  an isolated node. We do this by passing in batches through a task scheduler, and calling\n+  InputFinished and InputReceived.\n+*/\n+void BenchmarkIsolatedNodeOverhead(benchmark::State& state,\n+                                   arrow::compute::ExecContext ctx,\n+                                   arrow::compute::Expression expr, int32_t num_batches,\n+                                   int32_t batch_size,\n+                                   arrow::compute::BatchesWithSchema data,\n+                                   std::string factory_name,\n+                                   arrow::compute::ExecNodeOptions& options) {\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    AsyncGenerator<util::optional<arrow::compute::ExecBatch>> sink_gen;\n+\n+    ASSERT_OK_AND_ASSIGN(std::shared_ptr<arrow::compute::ExecPlan> plan,\n+                         arrow::compute::ExecPlan::Make(&ctx));\n+    // Source and sink nodes have no effect on the benchmark.\n+    // Used for dummy purposes as they are referenced in InputReceived and InputFinished.\n+    ASSERT_OK_AND_ASSIGN(arrow::compute::ExecNode * source_node,\n+                         MakeExecNode(\"source\", plan.get(), {},\n+                                      arrow::compute::SourceNodeOptions{\n+                                          data.schema, data.gen(/*parallel=*/true,\n+                                                                /*slow=*/false)}));\n+\n+    ASSERT_OK_AND_ASSIGN(arrow::compute::ExecNode * node,\n+                         MakeExecNode(factory_name, plan.get(), {source_node}, options));\n+    MakeExecNode(\"sink\", plan.get(), {node}, arrow::compute::SinkNodeOptions{&sink_gen});\n+\n+    std::unique_ptr<arrow::compute::TaskScheduler> scheduler =\n+        arrow::compute::TaskScheduler::Make();\n+    std::condition_variable all_tasks_finished_cv;\n+    std::mutex mutex;\n+\n+    int task_group_id = scheduler->RegisterTaskGroup(\n+        [&](size_t thread_id, int64_t task_id) {\n+          node->InputReceived(source_node, data.batches[task_id]);\n+          return Status::OK();\n+        },\n+        [&](size_t thread_id) {\n+          node->InputFinished(source_node, static_cast<int>(data.batches.size()));\n+          std::unique_lock<std::mutex> lk(mutex);\n+          all_tasks_finished_cv.notify_one();\n+          return Status::OK();\n+        });\n+    scheduler->RegisterEnd();\n+\n+    arrow::compute::ThreadIndexer thread_indexer;\n+\n+    state.ResumeTiming();\n+    arrow::internal::ThreadPool* thread_pool = arrow::internal::GetCpuThreadPool();\n+    ASSERT_OK(scheduler->StartScheduling(\n+        thread_indexer(),\n+        [&](std::function<Status(size_t)> task) -> Status {\n+          return thread_pool->Spawn([&, task]() {\n+            size_t tid = thread_indexer();\n+            ARROW_DCHECK_OK(task(tid));\n+          });\n+        },\n+        thread_pool->GetCapacity(),\n+        /*use_sync_execution=*/false));\n+    std::unique_lock<std::mutex> lk(mutex);\n+    ASSERT_OK(scheduler->StartTaskGroup(thread_indexer(), task_group_id, num_batches));\n+    all_tasks_finished_cv.wait(lk);\n+    ASSERT_TRUE(node->finished().is_finished());\n+  }\n+  state.counters[\"rows_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches * batch_size),\n+      benchmark::Counter::kIsRate);\n+\n+  state.counters[\"batches_per_second\"] = benchmark::Counter(\n+      static_cast<double>(state.iterations() * num_batches), benchmark::Counter::kIsRate);\n+}\n+\n+/*\n\nReview Comment:\n   Prefer `//` over `/*`\n\n\n\n",
                    "created": "2022-06-29T16:30:39.448+0000",
                    "updated": "2022-06-29T16:30:39.448+0000",
                    "started": "2022-06-29T16:30:39.448+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "786035",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/786037",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#issuecomment-1170211854\n\n   > Hi @westonpace, was wondering if you could publish the changes you requested ",
                    "created": "2022-06-29T16:30:45.466+0000",
                    "updated": "2022-06-29T16:30:45.466+0000",
                    "started": "2022-06-29T16:30:45.466+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "786037",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/786148",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "iChauster commented on PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#issuecomment-1170274922\n\n   Excellent, if there's nothing else I think this is ready to go @westonpace!\n\n\n",
                    "created": "2022-06-29T17:31:15.539+0000",
                    "updated": "2022-06-29T17:31:15.539+0000",
                    "started": "2022-06-29T17:31:15.539+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "786148",
                    "issueId": "13449553"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/worklog/786156",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13366:\nURL: https://github.com/apache/arrow/pull/13366#discussion_r910249487\n\n\n##########\ncpp/src/arrow/util/benchmark_util.h:\n##########\n@@ -15,10 +15,24 @@\n // specific language governing permissions and limitations\n // under the License.\n \n+#include <condition_variable>\n+#include <mutex>\n\nReview Comment:\n   Ah, this is going to be a problem.  We can't include `mutex` in public headers due to a Windows compatibility issue.  Can you create a `benchmark_util.cc` and move the definition of these methods there?\n\n\n\n",
                    "created": "2022-06-29T17:53:42.851+0000",
                    "updated": "2022-06-29T17:53:42.851+0000",
                    "started": "2022-06-29T17:53:42.850+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "786156",
                    "issueId": "13449553"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 19200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@91f9b16[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@72ebaa79[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@182cdf36[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@373b0628[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@791daad[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@1be6cf99[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@654d66bc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@a28367b[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@365d121[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2e525cd3[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@20a4a723[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6bf4c6a2[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 19200,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Jul 08 23:17:05 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-07-08T23:17:05.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16809/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-06-10T17:34:17.000+0000",
        "updated": "2022-07-08T23:17:05.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 19200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Benchmarks] Create Filter Benchmark for Acero",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13449553/comment/17564477",
                    "id": "17564477",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 13366\n[https://github.com/apache/arrow/pull/13366]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-07-08T23:17:05.428+0000",
                    "updated": "2022-07-08T23:17:05.428+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z135bc:",
        "customfield_12314139": null
    }
}