{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13298951",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951",
    "key": "ARROW-8493",
    "fields": {
        "parent": {
            "id": "13107102",
            "key": "ARROW-1644",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13107102",
            "fields": {
                "summary": "[C++][Parquet] Read and write nested Parquet data with a mix of struct and list nesting levels",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345977",
                "id": "12345977",
                "description": "",
                "name": "2.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-10-19"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12592262",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12592262",
                "type": {
                    "id": "10020",
                    "name": "Cloners",
                    "inward": "is cloned by",
                    "outward": "is a clone of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10020"
                },
                "inwardIssue": {
                    "id": "13313904",
                    "key": "ARROW-9264",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13313904",
                    "fields": {
                        "summary": "[C++] Cleanup Parquet Arrow Schema code",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                            "id": "7",
                            "description": "The sub-task of the issue",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                            "name": "Sub-task",
                            "subtask": true,
                            "avatarId": 21146
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 10200,
            "total": 10200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 10200,
            "total": 10200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8493/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 17,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/471182",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield opened a new pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973\n\n\n   level\r\n   \r\n   - Also add additional check that list annotated fields aren't repeated\r\n   - Adds unit test for SchemaManifest::Make to verify rep/def/ancestor\r\n   levels.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-16T07:22:26.140+0000",
                    "updated": "2020-08-16T07:22:26.140+0000",
                    "started": "2020-08-16T07:22:26.139+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "471182",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/471189",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#issuecomment-674492185\n\n\n   https://issues.apache.org/jira/browse/ARROW-8493\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-16T07:32:16.668+0000",
                    "updated": "2020-08-16T07:32:16.668+0000",
                    "started": "2020-08-16T07:32:16.668+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "471189",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/471218",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#discussion_r471123867\n\n\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,235 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}  //  primitive field\n+                          ));\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n\nReview comment:\n       Need to double check this one\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-16T15:09:51.895+0000",
                    "updated": "2020-08-16T15:09:51.895+0000",
                    "started": "2020-08-16T15:09:51.895+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "471218",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/471654",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kiszk commented on pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#issuecomment-675087462\n\n\n   Is it better to create an issue in PARQUET instead of ARROW?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-17T20:09:39.519+0000",
                    "updated": "2020-08-17T20:09:39.519+0000",
                    "started": "2020-08-17T20:09:39.519+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "471654",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/472034",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#issuecomment-675585382\n\n\n   > Is it better to create an issue in PARQUET instead of ARROW?\r\n   \r\n   It is a fine line.  Generally, I use PARQUET for issues related to core parquet reading (i.e. not arrow specific) and ARROW when the functionality is used for the Parquet->Arrow path.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-18T16:34:58.519+0000",
                    "updated": "2020-08-18T16:34:58.519+0000",
                    "started": "2020-08-18T16:34:58.518+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "472034",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/472723",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#issuecomment-676927791\n\n\n   CC @wesm or @pitrou \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-20T03:19:40.659+0000",
                    "updated": "2020-08-20T03:19:40.659+0000",
                    "started": "2020-08-20T03:19:40.659+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "472723",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/472960",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#discussion_r474106190\n\n\n\n##########\nFile path: cpp/src/parquet/arrow/schema.cc\n##########\n@@ -410,21 +410,66 @@ ::arrow::Result<std::shared_ptr<ArrowType>> GetTypeForNode(\n   return storage_type;\n }\n \n-Status NodeToSchemaField(const Node& node, int16_t max_def_level, int16_t max_rep_level,\n+struct LevelInfo {\n+  int16_t def_level = 0;\n+  int16_t rep_level = 0;\n+  int16_t repeated_ancestor_def_level = 0;\n\nReview comment:\n       Structure with these three fields seem to be in multiple numbers now? Perhaps we should simply use `LevelInfo` as a plain datatype everywhere instead of copying all three fields by hand everytime?\n\n##########\nFile path: cpp/src/parquet/arrow/schema.cc\n##########\n@@ -410,21 +410,66 @@ ::arrow::Result<std::shared_ptr<ArrowType>> GetTypeForNode(\n   return storage_type;\n }\n \n-Status NodeToSchemaField(const Node& node, int16_t max_def_level, int16_t max_rep_level,\n+struct LevelInfo {\n+  int16_t def_level = 0;\n+  int16_t rep_level = 0;\n+  int16_t repeated_ancestor_def_level = 0;\n\nReview comment:\n       Structures with these three fields seem to be in multiple numbers now? Perhaps we should simply use `LevelInfo` as a plain datatype everywhere instead of copying all three fields by hand everytime?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-20T16:17:12.709+0000",
                    "updated": "2020-08-20T16:17:12.709+0000",
                    "started": "2020-08-20T16:17:12.709+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "472960",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/472961",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#issuecomment-677762828\n\n\n   \"Start populating\" means it's not fully populated yet? Or not always?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-20T16:18:16.510+0000",
                    "updated": "2020-08-20T16:18:16.510+0000",
                    "started": "2020-08-20T16:18:16.510+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "472961",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/472962",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#issuecomment-677763342\n\n\n   Not this PR, but I'd appreciate if you could explain this comment in `schema.h`:\r\n   ```c++\r\n     // The definition level indicating the level at which the closest\r\n     // repeated ancestor was not empty.  This is used to discrimate\r\n     // between a value less than |definition_level|\r\n     // being null or excluded entirely.\r\n     // TODO(ARROW-8493): Populate this value.\r\n   ```\r\n   \r\n   What is the difference between a null and excluded value here? I though null values were simply not encoded at all in Parquet, thus \"excluded\".\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-20T16:19:00.499+0000",
                    "updated": "2020-08-20T16:19:00.499+0000",
                    "started": "2020-08-20T16:19:00.498+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "472962",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/472963",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#issuecomment-677763466\n\n\n   (also, perhaps need to update the TODO in that comment)\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-20T16:19:13.622+0000",
                    "updated": "2020-08-20T16:19:13.622+0000",
                    "started": "2020-08-20T16:19:13.622+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "472963",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/472982",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#discussion_r474112279\n\n\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n\nReview comment:\n       This is `list(list(boolean))` in Arrow terms? Perhaps add comments as above?\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n\nReview comment:\n       Hmm... what is a null list?\r\n   What does it mean to have a def level that doesn't map to anything?\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n\nReview comment:\n       This would be `list(struct(child: list(boolean)))`?\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n\nReview comment:\n       Is it `struct(child: struct(inner: boolean)) not null`?\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n\nReview comment:\n       Is it `struct(child: struct(inner: boolean))`?\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n+}\n+\n+TEST_F(TestLevels, ListErrors) {\n+  {\n+    ::arrow::Status error = MaybeSetParquetSchema(GroupNode::Make(\n+        \"child_list\", Repetition::REPEATED,\n+        {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+        ConvertedType::LIST));\n+    EXPECT_TRUE(error.IsInvalid());\n\nReview comment:\n       `ASSERT_RAISES(Invalid, error)`\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n+}\n+\n+TEST_F(TestLevels, ListErrors) {\n+  {\n+    ::arrow::Status error = MaybeSetParquetSchema(GroupNode::Make(\n+        \"child_list\", Repetition::REPEATED,\n+        {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+        ConvertedType::LIST));\n+    EXPECT_TRUE(error.IsInvalid());\n+    std::string expected(\"LIST-annotated groups must not be repeated.\");\n+    EXPECT_EQ(error.message().substr(0, expected.size()), expected);\n+  }\n\nReview comment:\n       Why is it an error to have a repeated LIST-annotated group?\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n\nReview comment:\n       Do we want to test that it's actually mapped to an Arrow `list(boolean)`? Or is that done elsewhere in the tests?\r\n   (or is it `list(boolean not null)`?)\n\n##########\nFile path: cpp/src/parquet/arrow/schema.cc\n##########\n@@ -410,21 +410,66 @@ ::arrow::Result<std::shared_ptr<ArrowType>> GetTypeForNode(\n   return storage_type;\n }\n \n-Status NodeToSchemaField(const Node& node, int16_t max_def_level, int16_t max_rep_level,\n+struct LevelInfo {\n+  int16_t def_level = 0;\n+  int16_t rep_level = 0;\n+  int16_t repeated_ancestor_def_level = 0;\n+\n+  /// Copies current levels to the schema field.\n+  void Populate(SchemaField* out) {\n+    out->definition_level = def_level;\n+    out->repetition_level = rep_level;\n+    out->repeated_ancestor_definition_level = repeated_ancestor_def_level;\n+  }\n+\n+  /// Increments levels according to the cardinality of node.\n+  void Increment(const Node& node) {\n+    if (node.is_repeated()) {\n+      IncrementRepeated();\n+      return;\n+    }\n+    if (node.is_optional()) {\n+      IncrementOptional();\n+      return;\n+    }\n+  }\n+\n+  /// Incremetns level for a optional node.\n+  void IncrementOptional() { def_level++; }\n+\n+  /// Increments levels for the repeated node.  Returns\n+  /// the previous ancestor_list_def_level.\n+  int16_t IncrementRepeated() {\n+    int16_t last_repeated_ancestor = repeated_ancestor_def_level;\n+\n+    // Repeated fields add both a repetition and definition level. This is used\n+    // to distinguish between an empty list and a list with an item in it.\n+    ++rep_level;\n+    ++def_level;\n+    // For levels >= current_def_level it indicates the list was\n\nReview comment:\n       What is \"current_def_level\"?\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n\nReview comment:\n       Hmm... so the `ConvertedType::LIST` says that `child_list` is semantically a list even though it cannot be repeated, right? Is there a reason we don't use `LogicalType` instead? (AFAIU, `ConvertedType` is legacy?)\n\n##########\nFile path: cpp/src/parquet/arrow/schema.cc\n##########\n@@ -606,23 +652,27 @@ Status NodeToSchemaField(const Node& node, int16_t current_def_level,\n     if (node.is_repeated()) {\n       // One-level list encoding, e.g.\n       // a: repeated int32;\n+      int16_t repeated_ancestor_def_level = current_levels.IncrementRepeated();\n       out->children.resize(1);\n       auto child_field = ::arrow::field(node.name(), type, /*nullable=*/false);\n-      RETURN_NOT_OK(PopulateLeaf(column_index, child_field, current_def_level,\n-                                 current_rep_level, ctx, out, &out->children[0]));\n+      RETURN_NOT_OK(PopulateLeaf(column_index, child_field, current_levels, ctx, out,\n+                                 &out->children[0]));\n \n       out->field = ::arrow::field(node.name(), ::arrow::list(child_field),\n                                   /*nullable=*/false, FieldIdMetadata(node.field_id()));\n       // Is this right?\n\nReview comment:\n       Do we need to keep this comment?\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n\nReview comment:\n       You mean \"bool field\"?\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n\nReview comment:\n       Can you elaborate why it's legacy? What would be the non-legacy encoding?\n\n##########\nFile path: cpp/src/parquet/arrow/schema.cc\n##########\n@@ -554,41 +605,36 @@ Status GroupToSchemaField(const GroupNode& node, int16_t current_def_level,\n     // repeated group $NAME {\n     //   r/o TYPE[0] f0\n     //   r/o TYPE[1] f1\n-    // }\n\nReview comment:\n       Why?\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n+}\n+\n+TEST_F(TestLevels, ListErrors) {\n+  {\n+    ::arrow::Status error = MaybeSetParquetSchema(GroupNode::Make(\n+        \"child_list\", Repetition::REPEATED,\n+        {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+        ConvertedType::LIST));\n+    EXPECT_TRUE(error.IsInvalid());\n+    std::string expected(\"LIST-annotated groups must not be repeated.\");\n+    EXPECT_EQ(error.message().substr(0, expected.size()), expected);\n\nReview comment:\n       Or something like:\r\n   ```c++\r\n     EXPECT_THAT(\r\n         error.message(),\r\n         testing::StartsWith(\r\n             \"LIST-annotated groups must not be repeated\"));\r\n   ```\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n\nReview comment:\n       Or is it `struct(child: struct(inner: boolean not null))`?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-20T17:00:37.795+0000",
                    "updated": "2020-08-20T17:00:37.795+0000",
                    "started": "2020-08-20T17:00:37.794+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "472982",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/473185",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#discussion_r474391446\n\n\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n\nReview comment:\n       This is tested above.  There is also a JIRA open to ensure we have complete type coverage in conversion and we can add more tests if the ones already present aren't sufficient.  Added a comment this is `(non-null list(non-null bool)`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-21T03:43:01.983+0000",
                    "updated": "2020-08-21T03:43:01.983+0000",
                    "started": "2020-08-21T03:43:01.983+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "473185",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/473211",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#discussion_r474409559\n\n\n\n##########\nFile path: cpp/src/parquet/arrow/schema.cc\n##########\n@@ -410,21 +410,66 @@ ::arrow::Result<std::shared_ptr<ArrowType>> GetTypeForNode(\n   return storage_type;\n }\n \n-Status NodeToSchemaField(const Node& node, int16_t max_def_level, int16_t max_rep_level,\n+struct LevelInfo {\n+  int16_t def_level = 0;\n+  int16_t rep_level = 0;\n+  int16_t repeated_ancestor_def_level = 0;\n\nReview comment:\n       consolidated into 1 in level_conversions where ina follow-up PR will use it as an argument to the levels there.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n\nReview comment:\n       the latter. added comment.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n\nReview comment:\n       yes.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n\nReview comment:\n       yes.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n\nReview comment:\n       Non-legacy is three level encoding above.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n\nReview comment:\n       Yes.  The recommended standard to list types is 3 level encoding.  Which has an outer group indicating nullability of the \"list\" field.  A repeated child-group to indicate its repeatedness and an inner group to indicate nullabiity of elements.  Reference: https://github.com/apache/parquet-format/blob/master/LogicalTypes.md#nested-types\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n\nReview comment:\n       yes.  fixed.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n\nReview comment:\n       ConvertedType is legacy, correct, this was copy-pasta and should be fixed now.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n\nReview comment:\n       Legacy because it isn't recommended.  Gave a pointer to  https://github.com/apache/parquet-format/blob/master/LogicalTypes.md#nested-types\n\n##########\nFile path: cpp/src/parquet/arrow/schema.cc\n##########\n@@ -606,23 +652,27 @@ Status NodeToSchemaField(const Node& node, int16_t current_def_level,\n     if (node.is_repeated()) {\n       // One-level list encoding, e.g.\n       // a: repeated int32;\n+      int16_t repeated_ancestor_def_level = current_levels.IncrementRepeated();\n       out->children.resize(1);\n       auto child_field = ::arrow::field(node.name(), type, /*nullable=*/false);\n-      RETURN_NOT_OK(PopulateLeaf(column_index, child_field, current_def_level,\n-                                 current_rep_level, ctx, out, &out->children[0]));\n+      RETURN_NOT_OK(PopulateLeaf(column_index, child_field, current_levels, ctx, out,\n+                                 &out->children[0]));\n \n       out->field = ::arrow::field(node.name(), ::arrow::list(child_field),\n                                   /*nullable=*/false, FieldIdMetadata(node.field_id()));\n       // Is this right?\n\nReview comment:\n       probably not but I found it entertaining.  removed.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n+}\n+\n+TEST_F(TestLevels, ListErrors) {\n+  {\n+    ::arrow::Status error = MaybeSetParquetSchema(GroupNode::Make(\n+        \"child_list\", Repetition::REPEATED,\n+        {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+        ConvertedType::LIST));\n+    EXPECT_TRUE(error.IsInvalid());\n+    std::string expected(\"LIST-annotated groups must not be repeated.\");\n+    EXPECT_EQ(error.message().substr(0, expected.size()), expected);\n\nReview comment:\n       I was originally using testing::HasSubstr but it had linking issues on windows (I opened a JIRA for this) and didn't want to spend the time investigating.  I think it might be the same with StartsWith.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n+}\n+\n+TEST_F(TestLevels, ListErrors) {\n+  {\n+    ::arrow::Status error = MaybeSetParquetSchema(GroupNode::Make(\n+        \"child_list\", Repetition::REPEATED,\n+        {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+        ConvertedType::LIST));\n+    EXPECT_TRUE(error.IsInvalid());\n\nReview comment:\n       done.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n\nReview comment:\n       updated with a comment.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n\nReview comment:\n       Tried to rephrase.  Def level 2 and def level 3 are use to discriminate for the same field `child_list` which is a `nullable list`.  When decoding `def_level=2` indicates a non-null but empty list.  `def_level==3` indicates an element present in the list.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n+}\n+\n+TEST_F(TestLevels, ListErrors) {\n+  {\n+    ::arrow::Status error = MaybeSetParquetSchema(GroupNode::Make(\n+        \"child_list\", Repetition::REPEATED,\n+        {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+        ConvertedType::LIST));\n+    EXPECT_TRUE(error.IsInvalid());\n+    std::string expected(\"LIST-annotated groups must not be repeated.\");\n+    EXPECT_EQ(error.message().substr(0, expected.size()), expected);\n+  }\n\nReview comment:\n       From the spec:\r\n   \r\n   > The outer-most level must be a group annotated with LIST that contains a single field named list. The repetition of this level must be either optional or required and determines whether the list is nullable.\r\n   \r\n   I read that as it should never be repeated (I didn't see any exceptions under the 2-level encoding but maybe we should clarify on parquet-dev@)?\n\n##########\nFile path: cpp/src/parquet/arrow/schema.cc\n##########\n@@ -410,21 +410,66 @@ ::arrow::Result<std::shared_ptr<ArrowType>> GetTypeForNode(\n   return storage_type;\n }\n \n-Status NodeToSchemaField(const Node& node, int16_t max_def_level, int16_t max_rep_level,\n+struct LevelInfo {\n+  int16_t def_level = 0;\n+  int16_t rep_level = 0;\n+  int16_t repeated_ancestor_def_level = 0;\n+\n+  /// Copies current levels to the schema field.\n+  void Populate(SchemaField* out) {\n+    out->definition_level = def_level;\n+    out->repetition_level = rep_level;\n+    out->repeated_ancestor_definition_level = repeated_ancestor_def_level;\n+  }\n+\n+  /// Increments levels according to the cardinality of node.\n+  void Increment(const Node& node) {\n+    if (node.is_repeated()) {\n+      IncrementRepeated();\n+      return;\n+    }\n+    if (node.is_optional()) {\n+      IncrementOptional();\n+      return;\n+    }\n+  }\n+\n+  /// Incremetns level for a optional node.\n+  void IncrementOptional() { def_level++; }\n+\n+  /// Increments levels for the repeated node.  Returns\n+  /// the previous ancestor_list_def_level.\n+  int16_t IncrementRepeated() {\n+    int16_t last_repeated_ancestor = repeated_ancestor_def_level;\n+\n+    // Repeated fields add both a repetition and definition level. This is used\n+    // to distinguish between an empty list and a list with an item in it.\n+    ++rep_level;\n+    ++def_level;\n+    // For levels >= current_def_level it indicates the list was\n\nReview comment:\n       should be repeated_ancestor_def_level.\n\n##########\nFile path: cpp/src/parquet/arrow/schema.cc\n##########\n@@ -554,41 +605,36 @@ Status GroupToSchemaField(const GroupNode& node, int16_t current_def_level,\n     // repeated group $NAME {\n     //   r/o TYPE[0] f0\n     //   r/o TYPE[1] f1\n-    // }\n\nReview comment:\n       overzealous delete i think.  added back.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-21T05:53:55.579+0000",
                    "updated": "2020-08-21T05:53:55.579+0000",
                    "started": "2020-08-21T05:53:55.579+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "473211",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/474654",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#issuecomment-680594450\n\n\n   @pitrou does the updated PR look OK?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-26T04:35:24.178+0000",
                    "updated": "2020-08-26T04:35:24.178+0000",
                    "started": "2020-08-26T04:35:24.178+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "474654",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/474859",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#discussion_r477352114\n\n\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -20,10 +20,117 @@\n #include <cstdint>\n \n #include \"parquet/platform.h\"\n+#include \"parquet/schema.h\"\n \n namespace parquet {\n namespace internal {\n \n+struct PARQUET_EXPORT LevelInfo {\n+  LevelInfo()\n+      : null_slot_usage(1), def_level(0), rep_level(0), repeated_ancestor_def_level(0) {}\n+  LevelInfo(int32_t null_slots, int32_t definition_level, int32_t repitition_level,\n+            int32_t repeated_ancestor_definition_level)\n+      : null_slot_usage(null_slots),\n+        def_level(definition_level),\n+        rep_level(repitition_level),\n+        repeated_ancestor_def_level(repeated_ancestor_definition_level) {}\n+\n+  bool operator==(const LevelInfo& b) const {\n+    return null_slot_usage == b.null_slot_usage && def_level == b.def_level &&\n+           rep_level == b.rep_level &&\n+           repeated_ancestor_def_level == b.repeated_ancestor_def_level;\n+  }\n+\n+  // How many slots a null element consumes.\n+  // This is only ever >1 for descendents of\n+  // FixedSizeList.\n+  int32_t null_slot_usage = 1;\n+\n+  // The definition level at which the value for the field\n+  // is considered not null (definition levels greater than\n+  // or equal to indicate this value indicate a not-null\n+  // value for the field). For list fields definition levels\n+  // greater then or equal to this field indicate a present\n+  // , possibly null, element.\n+  int16_t def_level = 0;\n+\n+  // The repetition level corresponding to this element\n+  // or the closest repeated ancestor.  Any repetition\n+  // level less than this indicates either a new list OR\n+  // an empty list (which is determined in conjunction\n+  // definition_level).\n+  int16_t rep_level = 0;\n+\n+  // The definition level indicating the level at which the closest\n+  // repeated ancestor was not empty.  This is used to discriminate\n+  // between a value less than |definition_level|\n+  // being null or excluded entirely.\n+  // For instance if we have an arrow schema like:\n+  // list(struct(f0: int)).  Then then there are the following\n+  // definition levels:\n+  // 0 = null list\n+  // 1 = present but empty list.\n+  // 2 = a null value in the list\n+  // 3 = a non null struct but null integer.\n+  // 4 = a present integer.\n\nReview comment:\n       +1, thanks for this example!\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -20,10 +20,117 @@\n #include <cstdint>\n \n #include \"parquet/platform.h\"\n+#include \"parquet/schema.h\"\n \n namespace parquet {\n namespace internal {\n \n+struct PARQUET_EXPORT LevelInfo {\n+  LevelInfo()\n+      : null_slot_usage(1), def_level(0), rep_level(0), repeated_ancestor_def_level(0) {}\n+  LevelInfo(int32_t null_slots, int32_t definition_level, int32_t repitition_level,\n+            int32_t repeated_ancestor_definition_level)\n+      : null_slot_usage(null_slots),\n+        def_level(definition_level),\n+        rep_level(repitition_level),\n+        repeated_ancestor_def_level(repeated_ancestor_definition_level) {}\n+\n+  bool operator==(const LevelInfo& b) const {\n+    return null_slot_usage == b.null_slot_usage && def_level == b.def_level &&\n+           rep_level == b.rep_level &&\n+           repeated_ancestor_def_level == b.repeated_ancestor_def_level;\n+  }\n+\n+  // How many slots a null element consumes.\n+  // This is only ever >1 for descendents of\n+  // FixedSizeList.\n+  int32_t null_slot_usage = 1;\n+\n+  // The definition level at which the value for the field\n+  // is considered not null (definition levels greater than\n+  // or equal to indicate this value indicate a not-null\n+  // value for the field). For list fields definition levels\n+  // greater then or equal to this field indicate a present\n+  // , possibly null, element.\n+  int16_t def_level = 0;\n+\n+  // The repetition level corresponding to this element\n+  // or the closest repeated ancestor.  Any repetition\n+  // level less than this indicates either a new list OR\n+  // an empty list (which is determined in conjunction\n+  // definition_level).\n+  int16_t rep_level = 0;\n+\n+  // The definition level indicating the level at which the closest\n+  // repeated ancestor was not empty.  This is used to discriminate\n\nReview comment:\n       Do you mean logical ancestor (in Arrow terms)? Or physical ancestor (in Parquet nesting)?\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -20,10 +20,117 @@\n #include <cstdint>\n \n #include \"parquet/platform.h\"\n+#include \"parquet/schema.h\"\n \n namespace parquet {\n namespace internal {\n \n+struct PARQUET_EXPORT LevelInfo {\n+  LevelInfo()\n+      : null_slot_usage(1), def_level(0), rep_level(0), repeated_ancestor_def_level(0) {}\n+  LevelInfo(int32_t null_slots, int32_t definition_level, int32_t repitition_level,\n+            int32_t repeated_ancestor_definition_level)\n+      : null_slot_usage(null_slots),\n+        def_level(definition_level),\n+        rep_level(repitition_level),\n+        repeated_ancestor_def_level(repeated_ancestor_definition_level) {}\n+\n+  bool operator==(const LevelInfo& b) const {\n+    return null_slot_usage == b.null_slot_usage && def_level == b.def_level &&\n+           rep_level == b.rep_level &&\n+           repeated_ancestor_def_level == b.repeated_ancestor_def_level;\n+  }\n+\n+  // How many slots a null element consumes.\n+  // This is only ever >1 for descendents of\n+  // FixedSizeList.\n+  int32_t null_slot_usage = 1;\n+\n+  // The definition level at which the value for the field\n+  // is considered not null (definition levels greater than\n+  // or equal to indicate this value indicate a not-null\n\nReview comment:\n       \"or equal to this value\"?\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -20,10 +20,117 @@\n #include <cstdint>\n \n #include \"parquet/platform.h\"\n+#include \"parquet/schema.h\"\n \n namespace parquet {\n namespace internal {\n \n+struct PARQUET_EXPORT LevelInfo {\n+  LevelInfo()\n+      : null_slot_usage(1), def_level(0), rep_level(0), repeated_ancestor_def_level(0) {}\n+  LevelInfo(int32_t null_slots, int32_t definition_level, int32_t repitition_level,\n+            int32_t repeated_ancestor_definition_level)\n+      : null_slot_usage(null_slots),\n+        def_level(definition_level),\n+        rep_level(repitition_level),\n+        repeated_ancestor_def_level(repeated_ancestor_definition_level) {}\n+\n+  bool operator==(const LevelInfo& b) const {\n+    return null_slot_usage == b.null_slot_usage && def_level == b.def_level &&\n+           rep_level == b.rep_level &&\n+           repeated_ancestor_def_level == b.repeated_ancestor_def_level;\n+  }\n+\n+  // How many slots a null element consumes.\n+  // This is only ever >1 for descendents of\n+  // FixedSizeList.\n+  int32_t null_slot_usage = 1;\n+\n+  // The definition level at which the value for the field\n+  // is considered not null (definition levels greater than\n+  // or equal to indicate this value indicate a not-null\n+  // value for the field). For list fields definition levels\n+  // greater then or equal to this field indicate a present\n+  // , possibly null, element.\n+  int16_t def_level = 0;\n+\n+  // The repetition level corresponding to this element\n+  // or the closest repeated ancestor.  Any repetition\n+  // level less than this indicates either a new list OR\n+  // an empty list (which is determined in conjunction\n+  // definition_level).\n\nReview comment:\n       Do you mean \"def_level\"? Or \"repeated_ancestor_def_level\" perhaps?\n\n##########\nFile path: cpp/src/parquet/arrow/schema.cc\n##########\n@@ -477,12 +484,11 @@ Status ListToSchemaField(const GroupNode& group, int16_t current_def_level,\n   const Node& list_node = *group.field(0);\n \n   if (!list_node.is_repeated()) {\n-    return Status::NotImplemented(\n+    return Status::Invalid(\n         \"Non-repeated nodes in a LIST-annotated group are not supported.\");\n   }\n \n-  ++current_def_level;\n-  ++current_rep_level;\n+  int16_t repeated_ancesor_def_level = current_levels.IncrementRepeated();\n\nReview comment:\n       \"ancestor\"?\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,244 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+::arrow::Result<std::deque<LevelInfo>> RootToTreeLeafLevels(\n+    const SchemaManifest& manifest, int column_number) {\n+  std::deque<LevelInfo> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front(field->level_info);\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1,\n+                                            /*def_level=*/0, /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1,\n+                                            /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: list(bool not null) not null\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 0},  // List Field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  // Arrow schema: struct(child: struct(inner: boolean not null))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean ))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean)) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/0, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  // Arrow schema: list(struct(child: struct(list(bool not null) not null)) non null) not\n+  // null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},  // optional child struct\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // repeated field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // innter field\n\nReview comment:\n       \"inner\"\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,244 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+::arrow::Result<std::deque<LevelInfo>> RootToTreeLeafLevels(\n+    const SchemaManifest& manifest, int column_number) {\n+  std::deque<LevelInfo> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front(field->level_info);\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1,\n+                                            /*def_level=*/0, /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1,\n+                                            /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: list(bool not null) not null\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 0},  // List Field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  // Arrow schema: struct(child: struct(inner: boolean not null))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean ))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean)) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/0, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  // Arrow schema: list(struct(child: struct(list(bool not null) not null)) non null) not\n+  // null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},  // optional child struct\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // repeated field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  // Arrow schema: list(struct(child_list: list(struct(f0: bool f1: bool no-required )))\n+  // not null) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          LogicalType::List())}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  // Def_level=2 is handled together with def_level=3\n+                  // When decoding.  Def_level=2 indicate present but empty\n+                  // list.  def_level=3 indicates a present element in the\n+                  // list.\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // list field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/4, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/5, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // f0 bool field\n\nReview comment:\n       Hmm, ok, now I don't understand why 4 LevelInfo are returned. I would expect 5:\r\n   * for outer `list`\r\n   * for outer `list(struct)`\r\n   * for `list(struct(child: list))`\r\n   * for `list(struct(child: list(struct)))`\r\n   * for `list(struct(child: list(struct: f0)))`\r\n   \n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -20,10 +20,117 @@\n #include <cstdint>\n \n #include \"parquet/platform.h\"\n+#include \"parquet/schema.h\"\n \n namespace parquet {\n namespace internal {\n \n+struct PARQUET_EXPORT LevelInfo {\n+  LevelInfo()\n+      : null_slot_usage(1), def_level(0), rep_level(0), repeated_ancestor_def_level(0) {}\n+  LevelInfo(int32_t null_slots, int32_t definition_level, int32_t repitition_level,\n\nReview comment:\n       \"repetition_level\"\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -20,10 +20,117 @@\n #include <cstdint>\n \n #include \"parquet/platform.h\"\n+#include \"parquet/schema.h\"\n \n namespace parquet {\n namespace internal {\n \n+struct PARQUET_EXPORT LevelInfo {\n+  LevelInfo()\n+      : null_slot_usage(1), def_level(0), rep_level(0), repeated_ancestor_def_level(0) {}\n+  LevelInfo(int32_t null_slots, int32_t definition_level, int32_t repitition_level,\n+            int32_t repeated_ancestor_definition_level)\n+      : null_slot_usage(null_slots),\n+        def_level(definition_level),\n+        rep_level(repitition_level),\n+        repeated_ancestor_def_level(repeated_ancestor_definition_level) {}\n+\n+  bool operator==(const LevelInfo& b) const {\n+    return null_slot_usage == b.null_slot_usage && def_level == b.def_level &&\n+           rep_level == b.rep_level &&\n+           repeated_ancestor_def_level == b.repeated_ancestor_def_level;\n+  }\n+\n+  // How many slots a null element consumes.\n+  // This is only ever >1 for descendents of\n+  // FixedSizeList.\n+  int32_t null_slot_usage = 1;\n+\n+  // The definition level at which the value for the field\n+  // is considered not null (definition levels greater than\n+  // or equal to indicate this value indicate a not-null\n+  // value for the field). For list fields definition levels\n+  // greater then or equal to this field indicate a present\n+  // , possibly null, element.\n+  int16_t def_level = 0;\n+\n+  // The repetition level corresponding to this element\n+  // or the closest repeated ancestor.  Any repetition\n+  // level less than this indicates either a new list OR\n+  // an empty list (which is determined in conjunction\n+  // definition_level).\n+  int16_t rep_level = 0;\n+\n+  // The definition level indicating the level at which the closest\n+  // repeated ancestor was not empty.  This is used to discriminate\n+  // between a value less than |definition_level|\n+  // being null or excluded entirely.\n+  // For instance if we have an arrow schema like:\n+  // list(struct(f0: int)).  Then then there are the following\n+  // definition levels:\n+  // 0 = null list\n+  // 1 = present but empty list.\n+  // 2 = a null value in the list\n+  // 3 = a non null struct but null integer.\n+  // 4 = a present integer.\n+  // When reconstructing the struct and integer Array's\n+  // repeated_ancestor_def_level would be 2.  Any\n\nReview comment:\n       The sentence is not clear here, could you rephrase?\r\n   Do you mean something like:\r\n   > When reconstructing the struct and integer, their `repeated_ancestor_def_level` would be 2.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -20,10 +20,117 @@\n #include <cstdint>\n \n #include \"parquet/platform.h\"\n+#include \"parquet/schema.h\"\n \n namespace parquet {\n namespace internal {\n \n+struct PARQUET_EXPORT LevelInfo {\n+  LevelInfo()\n+      : null_slot_usage(1), def_level(0), rep_level(0), repeated_ancestor_def_level(0) {}\n+  LevelInfo(int32_t null_slots, int32_t definition_level, int32_t repitition_level,\n+            int32_t repeated_ancestor_definition_level)\n+      : null_slot_usage(null_slots),\n+        def_level(definition_level),\n+        rep_level(repitition_level),\n+        repeated_ancestor_def_level(repeated_ancestor_definition_level) {}\n+\n+  bool operator==(const LevelInfo& b) const {\n+    return null_slot_usage == b.null_slot_usage && def_level == b.def_level &&\n+           rep_level == b.rep_level &&\n+           repeated_ancestor_def_level == b.repeated_ancestor_def_level;\n+  }\n+\n+  // How many slots a null element consumes.\n\nReview comment:\n       In other words, is it the number of definition levels per null element?\r\n   (I assume \"slot\" doesn't mean \"value slot\" because nulls are not encoded in values)\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,244 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+::arrow::Result<std::deque<LevelInfo>> RootToTreeLeafLevels(\n+    const SchemaManifest& manifest, int column_number) {\n+  std::deque<LevelInfo> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front(field->level_info);\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1,\n+                                            /*def_level=*/0, /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1,\n+                                            /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: list(bool not null) not null\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 0},  // List Field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  // Arrow schema: struct(child: struct(inner: boolean not null))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean ))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean)) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/0, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  // Arrow schema: list(struct(child: struct(list(bool not null) not null)) non null) not\n\nReview comment:\n       The outer struct is nullable and there seem to be too many nesting levels, so I'd say\r\n   ```\r\n   list(struct(child: list(bool not null) not null)) not null\r\n   ```\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,244 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+::arrow::Result<std::deque<LevelInfo>> RootToTreeLeafLevels(\n+    const SchemaManifest& manifest, int column_number) {\n+  std::deque<LevelInfo> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front(field->level_info);\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1,\n+                                            /*def_level=*/0, /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1,\n+                                            /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: list(bool not null) not null\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 0},  // List Field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  // Arrow schema: struct(child: struct(inner: boolean not null))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean ))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean)) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/0, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n\nReview comment:\n       Sorry to ask more, but can we also have simpler tests with a single top-level list field?\r\n   (e.g. `list(bool not null)`, `list(bool)`, `list(bool) not null`...)\r\n   \r\n   Once we have that, it's easier to reason about the more complicated ones.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,244 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+::arrow::Result<std::deque<LevelInfo>> RootToTreeLeafLevels(\n+    const SchemaManifest& manifest, int column_number) {\n+  std::deque<LevelInfo> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front(field->level_info);\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1,\n+                                            /*def_level=*/0, /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1,\n+                                            /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: list(bool not null) not null\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 0},  // List Field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  // Arrow schema: struct(child: struct(inner: boolean not null))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean ))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean)) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/0, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  // Arrow schema: list(struct(child: struct(list(bool not null) not null)) non null) not\n+  // null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},  // optional child struct\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // repeated field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  // Arrow schema: list(struct(child_list: list(struct(f0: bool f1: bool no-required )))\n+  // not null) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          LogicalType::List())}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  // Def_level=2 is handled together with def_level=3\n+                  // When decoding.  Def_level=2 indicate present but empty\n+                  // list.  def_level=3 indicates a present element in the\n+                  // list.\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // list field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/4, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/5, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  // Def_level=2 is handled together with def_level=3\n+                  // When decoding.  Def_level=2 indicate present but empty\n+                  // list.  def_level=3 indicates a present element in the\n+                  // list.\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // list field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/4, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/4, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Arrow schema: list(struct(child_list: list(bool not null)) not null) not null\n+  // Legacy 2-level necoding (required for backwards compatibility.  See\n\nReview comment:\n       \"encoding\"\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,244 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+::arrow::Result<std::deque<LevelInfo>> RootToTreeLeafLevels(\n+    const SchemaManifest& manifest, int column_number) {\n+  std::deque<LevelInfo> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front(field->level_info);\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1,\n+                                            /*def_level=*/0, /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1,\n+                                            /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: list(bool not null) not null\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 0},  // List Field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  // Arrow schema: struct(child: struct(inner: boolean not null))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean ))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean)) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/0, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  // Arrow schema: list(struct(child: struct(list(bool not null) not null)) non null) not\n+  // null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},  // optional child struct\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // repeated field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  // Arrow schema: list(struct(child_list: list(struct(f0: bool f1: bool no-required )))\n+  // not null) not null\n\nReview comment:\n       The outer struct seems nullable, also can we use \"not null\" everywhere instead of \"no-required\"?\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n+}\n+\n+TEST_F(TestLevels, ListErrors) {\n+  {\n+    ::arrow::Status error = MaybeSetParquetSchema(GroupNode::Make(\n+        \"child_list\", Repetition::REPEATED,\n+        {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+        ConvertedType::LIST));\n+    EXPECT_TRUE(error.IsInvalid());\n+    std::string expected(\"LIST-annotated groups must not be repeated.\");\n+    EXPECT_EQ(error.message().substr(0, expected.size()), expected);\n+  }\n\nReview comment:\n       However, I see this kind of comments in `path_internal_test.cc`:\r\n   ```\r\n     // Translates to parquet schema:\r\n     // optional group bag {\r\n     //   repeated group [unseen] (List) {\r\n     //       required int64 Entries;\r\n     //   }\r\n     // }\r\n   ```\r\n   Should the List annotation be on the toplevel \"bag\" node, rather than on the middle \"[unseen]\" node?\r\n   (also, what does \"[unseen]\" mean? shouldn't it be named \"list\" as per the Parquet spec?)\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n+}\n+\n+TEST_F(TestLevels, ListErrors) {\n+  {\n+    ::arrow::Status error = MaybeSetParquetSchema(GroupNode::Make(\n+        \"child_list\", Repetition::REPEATED,\n+        {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+        ConvertedType::LIST));\n+    EXPECT_TRUE(error.IsInvalid());\n+    std::string expected(\"LIST-annotated groups must not be repeated.\");\n+    EXPECT_EQ(error.message().substr(0, expected.size()), expected);\n+  }\n\nReview comment:\n       Ok, I read the spec now, I understand better :-)\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n+}\n+\n+TEST_F(TestLevels, ListErrors) {\n+  {\n+    ::arrow::Status error = MaybeSetParquetSchema(GroupNode::Make(\n+        \"child_list\", Repetition::REPEATED,\n+        {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+        ConvertedType::LIST));\n+    EXPECT_TRUE(error.IsInvalid());\n+    std::string expected(\"LIST-annotated groups must not be repeated.\");\n+    EXPECT_EQ(error.message().substr(0, expected.size()), expected);\n\nReview comment:\n       I see, thank you.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-26T15:18:11.275+0000",
                    "updated": "2020-08-26T15:18:11.275+0000",
                    "started": "2020-08-26T15:18:11.275+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "474859",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/475140",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973#discussion_r478100513\n\n\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,244 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+::arrow::Result<std::deque<LevelInfo>> RootToTreeLeafLevels(\n+    const SchemaManifest& manifest, int column_number) {\n+  std::deque<LevelInfo> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front(field->level_info);\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1,\n+                                            /*def_level=*/0, /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1,\n+                                            /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: list(bool not null) not null\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 0},  // List Field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  // Arrow schema: struct(child: struct(inner: boolean not null))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean ))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean)) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/0, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  // Arrow schema: list(struct(child: struct(list(bool not null) not null)) non null) not\n+  // null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},  // optional child struct\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // repeated field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // innter field\n\nReview comment:\n       done\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -20,10 +20,117 @@\n #include <cstdint>\n \n #include \"parquet/platform.h\"\n+#include \"parquet/schema.h\"\n \n namespace parquet {\n namespace internal {\n \n+struct PARQUET_EXPORT LevelInfo {\n+  LevelInfo()\n+      : null_slot_usage(1), def_level(0), rep_level(0), repeated_ancestor_def_level(0) {}\n+  LevelInfo(int32_t null_slots, int32_t definition_level, int32_t repitition_level,\n+            int32_t repeated_ancestor_definition_level)\n+      : null_slot_usage(null_slots),\n+        def_level(definition_level),\n+        rep_level(repitition_level),\n+        repeated_ancestor_def_level(repeated_ancestor_definition_level) {}\n+\n+  bool operator==(const LevelInfo& b) const {\n+    return null_slot_usage == b.null_slot_usage && def_level == b.def_level &&\n+           rep_level == b.rep_level &&\n+           repeated_ancestor_def_level == b.repeated_ancestor_def_level;\n+  }\n+\n+  // How many slots a null element consumes.\n+  // This is only ever >1 for descendents of\n+  // FixedSizeList.\n+  int32_t null_slot_usage = 1;\n+\n+  // The definition level at which the value for the field\n+  // is considered not null (definition levels greater than\n+  // or equal to indicate this value indicate a not-null\n+  // value for the field). For list fields definition levels\n+  // greater then or equal to this field indicate a present\n+  // , possibly null, element.\n+  int16_t def_level = 0;\n+\n+  // The repetition level corresponding to this element\n+  // or the closest repeated ancestor.  Any repetition\n+  // level less than this indicates either a new list OR\n+  // an empty list (which is determined in conjunction\n+  // definition_level).\n+  int16_t rep_level = 0;\n+\n+  // The definition level indicating the level at which the closest\n+  // repeated ancestor was not empty.  This is used to discriminate\n\nReview comment:\n       I don't think I understand this question.  since this mentions definition level this is really a parquet construct.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,244 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+::arrow::Result<std::deque<LevelInfo>> RootToTreeLeafLevels(\n+    const SchemaManifest& manifest, int column_number) {\n+  std::deque<LevelInfo> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front(field->level_info);\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1,\n+                                            /*def_level=*/0, /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1,\n+                                            /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: list(bool not null) not null\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 0},  // List Field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  // Arrow schema: struct(child: struct(inner: boolean not null))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean ))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean)) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/0, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  // Arrow schema: list(struct(child: struct(list(bool not null) not null)) non null) not\n+  // null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},  // optional child struct\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // repeated field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  // Arrow schema: list(struct(child_list: list(struct(f0: bool f1: bool no-required )))\n+  // not null) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          LogicalType::List())}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  // Def_level=2 is handled together with def_level=3\n+                  // When decoding.  Def_level=2 indicate present but empty\n+                  // list.  def_level=3 indicates a present element in the\n+                  // list.\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // list field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/4, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/5, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // f0 bool field\n\nReview comment:\n       I agree, nice catch, there was in fact a bug in the linkages.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -20,10 +20,117 @@\n #include <cstdint>\n \n #include \"parquet/platform.h\"\n+#include \"parquet/schema.h\"\n \n namespace parquet {\n namespace internal {\n \n+struct PARQUET_EXPORT LevelInfo {\n+  LevelInfo()\n+      : null_slot_usage(1), def_level(0), rep_level(0), repeated_ancestor_def_level(0) {}\n+  LevelInfo(int32_t null_slots, int32_t definition_level, int32_t repitition_level,\n\nReview comment:\n       fixed.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n+}\n+\n+TEST_F(TestLevels, ListErrors) {\n+  {\n+    ::arrow::Status error = MaybeSetParquetSchema(GroupNode::Make(\n+        \"child_list\", Repetition::REPEATED,\n+        {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+        ConvertedType::LIST));\n+    EXPECT_TRUE(error.IsInvalid());\n+    std::string expected(\"LIST-annotated groups must not be repeated.\");\n+    EXPECT_EQ(error.message().substr(0, expected.size()), expected);\n+  }\n\nReview comment:\n       Yes it should be named \"list\"  unseen I think references that isn't modelled on the arrow side.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -20,10 +20,117 @@\n #include <cstdint>\n \n #include \"parquet/platform.h\"\n+#include \"parquet/schema.h\"\n \n namespace parquet {\n namespace internal {\n \n+struct PARQUET_EXPORT LevelInfo {\n+  LevelInfo()\n+      : null_slot_usage(1), def_level(0), rep_level(0), repeated_ancestor_def_level(0) {}\n+  LevelInfo(int32_t null_slots, int32_t definition_level, int32_t repitition_level,\n+            int32_t repeated_ancestor_definition_level)\n+      : null_slot_usage(null_slots),\n+        def_level(definition_level),\n+        rep_level(repitition_level),\n+        repeated_ancestor_def_level(repeated_ancestor_definition_level) {}\n+\n+  bool operator==(const LevelInfo& b) const {\n+    return null_slot_usage == b.null_slot_usage && def_level == b.def_level &&\n+           rep_level == b.rep_level &&\n+           repeated_ancestor_def_level == b.repeated_ancestor_def_level;\n+  }\n+\n+  // How many slots a null element consumes.\n+  // This is only ever >1 for descendents of\n+  // FixedSizeList.\n+  int32_t null_slot_usage = 1;\n+\n+  // The definition level at which the value for the field\n+  // is considered not null (definition levels greater than\n+  // or equal to indicate this value indicate a not-null\n+  // value for the field). For list fields definition levels\n+  // greater then or equal to this field indicate a present\n+  // , possibly null, element.\n+  int16_t def_level = 0;\n+\n+  // The repetition level corresponding to this element\n+  // or the closest repeated ancestor.  Any repetition\n+  // level less than this indicates either a new list OR\n+  // an empty list (which is determined in conjunction\n+  // definition_level).\n\nReview comment:\n       definition levels in general.  We only really care about where repetition level increases in which case the def_level of node should be sufficient to determine this.  \n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -20,10 +20,117 @@\n #include <cstdint>\n \n #include \"parquet/platform.h\"\n+#include \"parquet/schema.h\"\n \n namespace parquet {\n namespace internal {\n \n+struct PARQUET_EXPORT LevelInfo {\n+  LevelInfo()\n+      : null_slot_usage(1), def_level(0), rep_level(0), repeated_ancestor_def_level(0) {}\n+  LevelInfo(int32_t null_slots, int32_t definition_level, int32_t repitition_level,\n+            int32_t repeated_ancestor_definition_level)\n+      : null_slot_usage(null_slots),\n+        def_level(definition_level),\n+        rep_level(repitition_level),\n+        repeated_ancestor_def_level(repeated_ancestor_definition_level) {}\n+\n+  bool operator==(const LevelInfo& b) const {\n+    return null_slot_usage == b.null_slot_usage && def_level == b.def_level &&\n+           rep_level == b.rep_level &&\n+           repeated_ancestor_def_level == b.repeated_ancestor_def_level;\n+  }\n+\n+  // How many slots a null element consumes.\n+  // This is only ever >1 for descendents of\n+  // FixedSizeList.\n+  int32_t null_slot_usage = 1;\n+\n+  // The definition level at which the value for the field\n+  // is considered not null (definition levels greater than\n+  // or equal to indicate this value indicate a not-null\n\nReview comment:\n       yes. fixed.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1143,231 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+struct Levels {\n+  int16_t def_level;\n+  int16_t rep_level;\n+  int16_t repeated_ancestor_def;\n+  friend std::ostream& operator<<(std::ostream& os, const Levels& levels) {\n+    // This print method is to silence valgrind issues.  What's printed\n+    // is not important because all asserts happen directly on\n+    // members.\n+    os << \"{def=\" << levels.def_level << \", rep=\" << levels.rep_level\n+       << \", repeated_ancestor_def=\" << levels.repeated_ancestor_def << \"}\";\n+    return os;\n+  }\n+};\n+\n+bool operator==(const Levels& a, const Levels& b) {\n+  return a.def_level == b.def_level && a.rep_level == b.rep_level &&\n+         a.repeated_ancestor_def == b.repeated_ancestor_def;\n+}\n+\n+::arrow::Result<std::deque<Levels>> RootToTreeLeafLevels(const SchemaManifest& manifest,\n+                                                         int column_number) {\n+  std::deque<Levels> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front({field->definition_level, field->repetition_level,\n+                    field->repeated_ancestor_definition_level});\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 0},  // List Field\n+                          Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/3, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(Levels{/*def_level=*/0, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/1, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0},\n+                                  Levels{/*def_level=*/2, /*rep_level=*/0,\n+                                         /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<Levels> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          Levels{/*def_level=*/2, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},  // optional child struct\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // repeated field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          ConvertedType::LIST)}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/5, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                          Levels{/*def_level=*/4, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Legacy 2-level necoding\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+          ConvertedType::LIST)}));\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels,\n+              ElementsAre(Levels{/*def_level=*/1, /*rep_level=*/1,\n+                                 /*ancestor_list_def_level*/ 1},\n+                          // Def_ldevl=2 is skipped because it represents a null list.\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 1},  // list field\n+                          Levels{/*def_level=*/3, /*rep_level=*/2,\n+                                 /*ancestor_list_def_level*/ 3}));  // inner struct field\n+}\n+\n+TEST_F(TestLevels, ListErrors) {\n+  {\n+    ::arrow::Status error = MaybeSetParquetSchema(GroupNode::Make(\n+        \"child_list\", Repetition::REPEATED,\n+        {PrimitiveNode::Make(\"bool\", Repetition::REPEATED, ParquetType::BOOLEAN)},\n+        ConvertedType::LIST));\n+    EXPECT_TRUE(error.IsInvalid());\n+    std::string expected(\"LIST-annotated groups must not be repeated.\");\n+    EXPECT_EQ(error.message().substr(0, expected.size()), expected);\n+  }\n\nReview comment:\n       I think you are right this documention is off.  I think I mostly copy and pasted from existing code.\n\n##########\nFile path: cpp/src/parquet/arrow/schema.cc\n##########\n@@ -477,12 +484,11 @@ Status ListToSchemaField(const GroupNode& group, int16_t current_def_level,\n   const Node& list_node = *group.field(0);\n \n   if (!list_node.is_repeated()) {\n-    return Status::NotImplemented(\n+    return Status::Invalid(\n         \"Non-repeated nodes in a LIST-annotated group are not supported.\");\n   }\n \n-  ++current_def_level;\n-  ++current_rep_level;\n+  int16_t repeated_ancesor_def_level = current_levels.IncrementRepeated();\n\nReview comment:\n       yes.  fixed.\n\n##########\nFile path: cpp/src/parquet/level_conversion.h\n##########\n@@ -20,10 +20,117 @@\n #include <cstdint>\n \n #include \"parquet/platform.h\"\n+#include \"parquet/schema.h\"\n \n namespace parquet {\n namespace internal {\n \n+struct PARQUET_EXPORT LevelInfo {\n+  LevelInfo()\n+      : null_slot_usage(1), def_level(0), rep_level(0), repeated_ancestor_def_level(0) {}\n+  LevelInfo(int32_t null_slots, int32_t definition_level, int32_t repitition_level,\n+            int32_t repeated_ancestor_definition_level)\n+      : null_slot_usage(null_slots),\n+        def_level(definition_level),\n+        rep_level(repitition_level),\n+        repeated_ancestor_def_level(repeated_ancestor_definition_level) {}\n+\n+  bool operator==(const LevelInfo& b) const {\n+    return null_slot_usage == b.null_slot_usage && def_level == b.def_level &&\n+           rep_level == b.rep_level &&\n+           repeated_ancestor_def_level == b.repeated_ancestor_def_level;\n+  }\n+\n+  // How many slots a null element consumes.\n\nReview comment:\n       not quite, tried to reword.  This reflects when parquet has an undefined but present element (i.e. null in arrow) how many slots in arrow are used in the arrow array.  For fixed size lists a null fixed size list forces all of its non nested children to have N null slots where N is the length of the fixed size list.  Nested fixed size lists increases this number multiplicatively .\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,244 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+::arrow::Result<std::deque<LevelInfo>> RootToTreeLeafLevels(\n+    const SchemaManifest& manifest, int column_number) {\n+  std::deque<LevelInfo> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front(field->level_info);\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1,\n+                                            /*def_level=*/0, /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1,\n+                                            /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: list(bool not null) not null\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 0},  // List Field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  // Arrow schema: struct(child: struct(inner: boolean not null))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean ))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean)) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/0, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  // Arrow schema: list(struct(child: struct(list(bool not null) not null)) non null) not\n\nReview comment:\n       I don't believe the outer struct is nullable.  See comment below.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,244 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+::arrow::Result<std::deque<LevelInfo>> RootToTreeLeafLevels(\n+    const SchemaManifest& manifest, int column_number) {\n+  std::deque<LevelInfo> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front(field->level_info);\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1,\n+                                            /*def_level=*/0, /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1,\n+                                            /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: list(bool not null) not null\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 0},  // List Field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  // Arrow schema: struct(child: struct(inner: boolean not null))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean ))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean)) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/0, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  // Arrow schema: list(struct(child: struct(list(bool not null) not null)) non null) not\n+  // null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},  // optional child struct\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // repeated field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  // Arrow schema: list(struct(child_list: list(struct(f0: bool f1: bool no-required )))\n+  // not null) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child_list\", Repetition::OPTIONAL,\n+          {GroupNode::Make(\n+              \"list\", Repetition::REPEATED,\n+              {GroupNode::Make(\n+                  \"element\", Repetition::OPTIONAL,\n+                  {PrimitiveNode::Make(\"f0\", Repetition::OPTIONAL, ParquetType::BOOLEAN),\n+                   PrimitiveNode::Make(\"f1\", Repetition::REQUIRED,\n+                                       ParquetType::BOOLEAN)})})},\n+          LogicalType::List())}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  // Def_level=2 is handled together with def_level=3\n+                  // When decoding.  Def_level=2 indicate present but empty\n+                  // list.  def_level=3 indicates a present element in the\n+                  // list.\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // list field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/4, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/5, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // f0 bool field\n+\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/1));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  // Def_level=2 is handled together with def_level=3\n+                  // When decoding.  Def_level=2 indicate present but empty\n+                  // list.  def_level=3 indicates a present element in the\n+                  // list.\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // list field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/4, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3},  // inner struct field\n+\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/4, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // f1 bool field\n+\n+  // Arrow schema: list(struct(child_list: list(bool not null)) not null) not null\n+  // Legacy 2-level necoding (required for backwards compatibility.  See\n\nReview comment:\n       done.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,244 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+::arrow::Result<std::deque<LevelInfo>> RootToTreeLeafLevels(\n+    const SchemaManifest& manifest, int column_number) {\n+  std::deque<LevelInfo> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front(field->level_info);\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1,\n+                                            /*def_level=*/0, /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1,\n+                                            /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: list(bool not null) not null\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 0},  // List Field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  // Arrow schema: struct(child: struct(inner: boolean not null))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean ))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean)) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/0, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n\nReview comment:\n       Added a few more, let me know if you would like to see more.\n\n##########\nFile path: cpp/src/parquet/arrow/arrow_schema_test.cc\n##########\n@@ -1140,5 +1144,244 @@ TEST(TestFromParquetSchema, CorruptMetadata) {\n   ASSERT_RAISES(IOError, FromParquetSchema(parquet_schema, props, &arrow_schema));\n }\n \n+::arrow::Result<std::deque<LevelInfo>> RootToTreeLeafLevels(\n+    const SchemaManifest& manifest, int column_number) {\n+  std::deque<LevelInfo> out;\n+  const SchemaField* field;\n+  RETURN_NOT_OK(manifest.GetColumnField(column_number, &field));\n+  while (field != nullptr) {\n+    out.push_front(field->level_info);\n+    field = manifest.GetParent(field);\n+  }\n+  return out;\n+}\n+\n+class TestLevels : public ::testing::Test {\n+ public:\n+  virtual void SetUp() {}\n+\n+  ::arrow::Status MaybeSetParquetSchema(const NodePtr& column) {\n+    descriptor_.reset(new SchemaDescriptor());\n+    manifest_.reset(new SchemaManifest());\n+    descriptor_->Init(GroupNode::Make(\"root\", Repetition::REQUIRED, {column}));\n+    return SchemaManifest::Make(descriptor_.get(),\n+                                std::shared_ptr<const ::arrow::KeyValueMetadata>(),\n+                                ArrowReaderProperties(), manifest_.get());\n+  }\n+  void SetParquetSchema(const NodePtr& column) {\n+    ASSERT_OK(MaybeSetParquetSchema(column));\n+  }\n+\n+ protected:\n+  std::unique_ptr<SchemaDescriptor> descriptor_;\n+  std::unique_ptr<SchemaManifest> manifest_;\n+};\n+\n+TEST_F(TestLevels, TestPrimitive) {\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REQUIRED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1,\n+                                            /*def_level=*/0, /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::OPTIONAL, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(levels, ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1,\n+                                            /*rep_level=*/0,\n+                                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: list(bool not null) not null\n+  SetParquetSchema(\n+      PrimitiveNode::Make(\"node_name\", Repetition::REPEATED, ParquetType::BOOLEAN));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 0},  // List Field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1}));  //  primitive field\n+}\n+\n+TEST_F(TestLevels, TestSimpleGroups) {\n+  // Arrow schema: struct(child: struct(inner: boolean not null))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REQUIRED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean ))\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::OPTIONAL,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+\n+  // Arrow schema: struct(child: struct(inner: boolean)) not null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REQUIRED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::OPTIONAL, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(levels, RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/0, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/0,\n+                            /*ancestor_list_def_level*/ 0}));\n+}\n+\n+TEST_F(TestLevels, TestRepeatedGroups) {\n+  // Arrow schema: list(struct(child: struct(list(bool not null) not null)) non null) not\n+  // null\n+  SetParquetSchema(GroupNode::Make(\n+      \"parent\", Repetition::REPEATED,\n+      {GroupNode::Make(\n+          \"child\", Repetition::OPTIONAL,\n+          {PrimitiveNode::Make(\"inner\", Repetition::REPEATED, ParquetType::BOOLEAN)})}));\n+  ASSERT_OK_AND_ASSIGN(std::deque<LevelInfo> levels,\n+                       RootToTreeLeafLevels(*manifest_, /*column_number=*/0));\n+  EXPECT_THAT(\n+      levels,\n+      ElementsAre(LevelInfo{/*null_slot_usage=*/1, /*def_level=*/1, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/2, /*rep_level=*/1,\n+                            /*ancestor_list_def_level*/ 1},  // optional child struct\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 1},  // repeated field\n+                  LevelInfo{/*null_slot_usage=*/1, /*def_level=*/3, /*rep_level=*/2,\n+                            /*ancestor_list_def_level*/ 3}));  // innter field\n+\n+  // Arrow schema: list(struct(child_list: list(struct(f0: bool f1: bool no-required )))\n+  // not null) not null\n\nReview comment:\n       Hmm, I don't think the outer struct is nullable. \"parent\" ends up mapping to two arrow fields: list and struct.  they share the same def level, so it there is an element in list struct must be present.  But I could be misreading this.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-27T05:33:53.123+0000",
                    "updated": "2020-08-27T05:33:53.123+0000",
                    "started": "2020-08-27T05:33:53.123+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "475140",
                    "issueId": "13298951"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/worklog/476698",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson closed pull request #7973:\nURL: https://github.com/apache/arrow/pull/7973\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-31T17:21:34.368+0000",
                    "updated": "2020-08-31T17:21:34.368+0000",
                    "started": "2020-08-31T17:21:34.367+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "476698",
                    "issueId": "13298951"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 10200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@9255285[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@e4d38a3[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@70cb7fff[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@1724c965[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@61c069a2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7f743987[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@54eb8511[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@65351108[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@75ae975[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@593c4018[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@51778523[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@1c077354[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 10200,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Aug 31 17:22:01 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-08-31T17:22:01.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8493/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-04-17T04:07:44.000+0000",
        "updated": "2020-08-31T17:22:01.000+0000",
        "timeoriginalestimate": null,
        "description": "Augment SchemaField in SchemaManifest to track repeated ancestor definition level.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 10200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Create unified schema resolution code for Array reconstruction.",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13298951/comment/17187891",
                    "id": "17187891",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 7973\n[https://github.com/apache/arrow/pull/7973]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2020-08-31T17:22:01.364+0000",
                    "updated": "2020-08-31T17:22:01.364+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0dqc8:",
        "customfield_12314139": null
    }
}