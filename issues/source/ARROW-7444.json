{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13275671",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671",
    "key": "ARROW-7444",
    "fields": {
        "parent": {
            "id": "13275670",
            "key": "ARROW-7443",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13275670",
            "fields": {
                "summary": "[GLib] Add binding of arrow::fs",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12346687",
                "id": "12346687",
                "description": "",
                "name": "0.17.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-04-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=mrkn",
            "name": "mrkn",
            "key": "mrkn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Kenta Murata",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12332430",
                "id": "12332430",
                "name": "GLib"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=mrkn",
            "name": "mrkn",
            "key": "mrkn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Kenta Murata",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=mrkn",
            "name": "mrkn",
            "key": "mrkn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34044",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34044",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34044",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34044"
            },
            "displayName": "Kenta Murata",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 33000,
            "total": 33000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 33000,
            "total": 33000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-7444/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 95,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/363898",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mrkn commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105\n \n \n   TODO:\r\n   - [x] Implementation\r\n   - [ ] Write tests\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-27T09:02:45.795+0000",
                    "updated": "2019-12-27T09:02:45.795+0000",
                    "started": "2019-12-27T09:02:45.795+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "363898",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/363902",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on issue #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#issuecomment-569228488\n \n \n   https://issues.apache.org/jira/browse/ARROW-7444\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-27T09:16:35.700+0000",
                    "updated": "2019-12-27T09:16:35.700+0000",
                    "started": "2019-12-27T09:16:35.700+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "363902",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364090",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361768028\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n+     garrow_file_stats_get_instance_private(       \\\n+       GARROW_FILE_STATS(obj)))\n+\n+static void\n+garrow_file_stats_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  priv->file_stats = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_stats_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_stats_set_property(GObject *object,\n+                               guint prop_id,\n+                               const GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_STATS:\n+    priv->file_stats =\n+      *static_cast<std::shared_ptr<arrow::fs::FileStats> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_get_property(GObject *object,\n+                               guint prop_id,\n+                               GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_init(GArrowFileStats *object)\n+{\n+}\n+\n+static void\n+garrow_file_stats_class_init(GArrowFileStatsClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_stats_finalize;\n+  gobject_class->set_property = garrow_file_stats_set_property;\n+  gobject_class->get_property = garrow_file_stats_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_stats\",\n+                              \"FileStats\",\n+                              \"The raw std::shared<arrow::fs::FileStats> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_STATS, spec);\n+}\n+\n+/**\n+ * garrow_file_stats_new:\n+ *\n+ * Returns: A newly created #GArrowFileStats.\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_stats_new(void)\n+{\n+  auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>();\n+  return garrow_file_stats_new_raw(&arrow_file_stats);\n+}\n+\n+/**\n+ * garrow_file_stats_equal:\n+ * @file_stats: A #GArrowFileStats.\n+ * @other_file_stats: A #GArrowFileStats to be compared.\n+ *\n+ * Returns: %TRUE if both of them have the same data, %FALSE\n+ *   otherwise.\n+ *\n+ * Since: 1.0.0\n+ */\n+gboolean\n+garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                        GArrowFileStats *other_file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto arrow_other_file_stats = garrow_file_stats_get_raw(other_file_stats);\n+  return arrow_file_stats->Equals(*arrow_other_file_stats);\n+}\n+\n+GArrowFileType\n+garrow_file_stats_get_file_type(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return (GArrowFileType)arrow_file_stats->type();\n \n Review comment:\n   Could you use C++ style cast?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:55.414+0000",
                    "updated": "2019-12-28T02:18:55.414+0000",
                    "started": "2019-12-28T02:18:55.414+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364090",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364091",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361767281\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n+     garrow_file_stats_get_instance_private(       \\\n+       GARROW_FILE_STATS(obj)))\n+\n+static void\n+garrow_file_stats_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  priv->file_stats = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_stats_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_stats_set_property(GObject *object,\n+                               guint prop_id,\n+                               const GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_STATS:\n+    priv->file_stats =\n+      *static_cast<std::shared_ptr<arrow::fs::FileStats> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_get_property(GObject *object,\n+                               guint prop_id,\n+                               GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n \n Review comment:\n   We don't need to define `get_property()` that returns nothing.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:55.626+0000",
                    "updated": "2019-12-28T02:18:55.626+0000",
                    "started": "2019-12-28T02:18:55.626+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364091",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364092",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361770242\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n+     garrow_file_stats_get_instance_private(       \\\n+       GARROW_FILE_STATS(obj)))\n+\n+static void\n+garrow_file_stats_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  priv->file_stats = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_stats_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_stats_set_property(GObject *object,\n+                               guint prop_id,\n+                               const GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_STATS:\n+    priv->file_stats =\n+      *static_cast<std::shared_ptr<arrow::fs::FileStats> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_get_property(GObject *object,\n+                               guint prop_id,\n+                               GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_init(GArrowFileStats *object)\n+{\n+}\n+\n+static void\n+garrow_file_stats_class_init(GArrowFileStatsClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_stats_finalize;\n+  gobject_class->set_property = garrow_file_stats_set_property;\n+  gobject_class->get_property = garrow_file_stats_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_stats\",\n+                              \"FileStats\",\n+                              \"The raw std::shared<arrow::fs::FileStats> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_STATS, spec);\n+}\n+\n+/**\n+ * garrow_file_stats_new:\n+ *\n+ * Returns: A newly created #GArrowFileStats.\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_stats_new(void)\n+{\n+  auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>();\n+  return garrow_file_stats_new_raw(&arrow_file_stats);\n+}\n+\n+/**\n+ * garrow_file_stats_equal:\n+ * @file_stats: A #GArrowFileStats.\n+ * @other_file_stats: A #GArrowFileStats to be compared.\n+ *\n+ * Returns: %TRUE if both of them have the same data, %FALSE\n+ *   otherwise.\n+ *\n+ * Since: 1.0.0\n+ */\n+gboolean\n+garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                        GArrowFileStats *other_file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto arrow_other_file_stats = garrow_file_stats_get_raw(other_file_stats);\n+  return arrow_file_stats->Equals(*arrow_other_file_stats);\n+}\n+\n+GArrowFileType\n+garrow_file_stats_get_file_type(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return (GArrowFileType)arrow_file_stats->type();\n+}\n+\n+void\n+garrow_file_stats_set_file_type(GArrowFileStats *file_stats,\n+                                GArrowFileType file_type)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_type(arrow::fs::FileType(file_type));\n+}\n+\n+gboolean\n+garrow_file_stats_is_file(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsFile();\n+}\n+\n+gboolean\n+garrow_file_stats_is_directory(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsDirectory();\n+}\n+\n+const gchar *\n+garrow_file_stats_get_path(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->path().c_str();\n+}\n+\n+void\n+garrow_file_stats_set_path(GArrowFileStats *file_stats,\n+                           const gchar *path)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_path(path);\n+}\n+\n+gchar *\n+garrow_file_stats_get_base_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto base_name = std::move(arrow_file_stats->base_name());\n+  return g_strndup(base_name.c_str(), base_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_dir_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto dir_name = std::move(arrow_file_stats->dir_name());\n+  return g_strndup(dir_name.c_str(), dir_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_extension(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto extension = std::move(arrow_file_stats->extension());\n+  return g_strndup(extension.c_str(), extension.size());\n+}\n+\n+gint64\n+garrow_file_stats_get_size(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->size();\n+}\n+\n+void\n+garrow_file_stats_set_size(GArrowFileStats *file_stats,\n+                           gint64 size)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_size(size);\n+}\n+\n+GArrowTimePoint\n+garrow_file_stats_get_mtime(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto mtime = arrow_file_stats->mtime();\n+  return mtime.time_since_epoch().count();\n+}\n+\n+void\n+garrow_file_stats_set_mtime(GArrowFileStats *file_stats,\n+                            GArrowTimePoint mtime)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow::fs::TimePoint::duration duration(mtime);\n+  arrow_file_stats->set_mtime(arrow::fs::TimePoint(duration));\n+}\n+\n+/* arrow::fs::FileSelector */\n+\n+typedef struct GArrowFileSelectorPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSelector> file_selector;\n+} GArrowFileSelectorPrivate;\n+\n+enum {\n+  PROP_FILE_SELECTOR = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileSelector, garrow_file_selector, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SELECTOR_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSelectorPrivate *>(          \\\n+     garrow_file_selector_get_instance_private(       \\\n+       GARROW_FILE_SELECTOR(obj)))\n+\n+static void\n+garrow_file_selector_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  priv->file_selector = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_selector_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_selector_set_property(GObject *object,\n+                                  guint prop_id,\n+                                  const GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SELECTOR:\n+    priv->file_selector =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSelector> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_get_property(GObject *object,\n+                                  guint prop_id,\n+                                  GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_init(GArrowFileSelector *object)\n+{\n+}\n+\n+static void\n+garrow_file_selector_class_init(GArrowFileSelectorClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_selector_finalize;\n+  gobject_class->set_property = garrow_file_selector_set_property;\n+  gobject_class->get_property = garrow_file_selector_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_selector\",\n+                              \"FileSelector\",\n+                              \"The raw std::shared<arrow::fs::FileSelector> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SELECTOR, spec);\n+}\n+\n+const gchar *\n+garrow_file_selector_get_base_dir(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->base_dir.c_str();\n+}\n+\n+void\n+garrow_file_selector_set_base_dir(GArrowFileSelector *file_selector,\n+                                  const gchar *base_dir)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->base_dir.assign(base_dir);\n+}\n \n Review comment:\n   How about implementing them as properties like we did in `GArrow::CSVReadOptions`.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:55.737+0000",
                    "updated": "2019-12-28T02:18:55.737+0000",
                    "started": "2019-12-28T02:18:55.737+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364092",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364093",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361768274\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n \n Review comment:\n   One space is missing before `\\`.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:55.740+0000",
                    "updated": "2019-12-28T02:18:55.740+0000",
                    "started": "2019-12-28T02:18:55.740+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364093",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364094",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361768305\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n+     garrow_file_stats_get_instance_private(       \\\n+       GARROW_FILE_STATS(obj)))\n+\n+static void\n+garrow_file_stats_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  priv->file_stats = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_stats_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_stats_set_property(GObject *object,\n+                               guint prop_id,\n+                               const GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_STATS:\n+    priv->file_stats =\n+      *static_cast<std::shared_ptr<arrow::fs::FileStats> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_get_property(GObject *object,\n+                               guint prop_id,\n+                               GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_init(GArrowFileStats *object)\n+{\n+}\n+\n+static void\n+garrow_file_stats_class_init(GArrowFileStatsClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_stats_finalize;\n+  gobject_class->set_property = garrow_file_stats_set_property;\n+  gobject_class->get_property = garrow_file_stats_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_stats\",\n+                              \"FileStats\",\n+                              \"The raw std::shared<arrow::fs::FileStats> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_STATS, spec);\n+}\n+\n+/**\n+ * garrow_file_stats_new:\n+ *\n+ * Returns: A newly created #GArrowFileStats.\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_stats_new(void)\n+{\n+  auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>();\n+  return garrow_file_stats_new_raw(&arrow_file_stats);\n+}\n+\n+/**\n+ * garrow_file_stats_equal:\n+ * @file_stats: A #GArrowFileStats.\n+ * @other_file_stats: A #GArrowFileStats to be compared.\n+ *\n+ * Returns: %TRUE if both of them have the same data, %FALSE\n+ *   otherwise.\n+ *\n+ * Since: 1.0.0\n+ */\n+gboolean\n+garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                        GArrowFileStats *other_file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto arrow_other_file_stats = garrow_file_stats_get_raw(other_file_stats);\n+  return arrow_file_stats->Equals(*arrow_other_file_stats);\n+}\n+\n+GArrowFileType\n+garrow_file_stats_get_file_type(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return (GArrowFileType)arrow_file_stats->type();\n+}\n+\n+void\n+garrow_file_stats_set_file_type(GArrowFileStats *file_stats,\n+                                GArrowFileType file_type)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_type(arrow::fs::FileType(file_type));\n+}\n+\n+gboolean\n+garrow_file_stats_is_file(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsFile();\n+}\n+\n+gboolean\n+garrow_file_stats_is_directory(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsDirectory();\n+}\n+\n+const gchar *\n+garrow_file_stats_get_path(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->path().c_str();\n+}\n+\n+void\n+garrow_file_stats_set_path(GArrowFileStats *file_stats,\n+                           const gchar *path)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_path(path);\n+}\n+\n+gchar *\n+garrow_file_stats_get_base_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto base_name = std::move(arrow_file_stats->base_name());\n+  return g_strndup(base_name.c_str(), base_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_dir_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto dir_name = std::move(arrow_file_stats->dir_name());\n+  return g_strndup(dir_name.c_str(), dir_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_extension(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto extension = std::move(arrow_file_stats->extension());\n+  return g_strndup(extension.c_str(), extension.size());\n+}\n+\n+gint64\n+garrow_file_stats_get_size(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->size();\n+}\n+\n+void\n+garrow_file_stats_set_size(GArrowFileStats *file_stats,\n+                           gint64 size)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_size(size);\n+}\n+\n+GArrowTimePoint\n+garrow_file_stats_get_mtime(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto mtime = arrow_file_stats->mtime();\n+  return mtime.time_since_epoch().count();\n+}\n+\n+void\n+garrow_file_stats_set_mtime(GArrowFileStats *file_stats,\n+                            GArrowTimePoint mtime)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow::fs::TimePoint::duration duration(mtime);\n+  arrow_file_stats->set_mtime(arrow::fs::TimePoint(duration));\n+}\n+\n+/* arrow::fs::FileSelector */\n+\n+typedef struct GArrowFileSelectorPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSelector> file_selector;\n+} GArrowFileSelectorPrivate;\n+\n+enum {\n+  PROP_FILE_SELECTOR = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileSelector, garrow_file_selector, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SELECTOR_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSelectorPrivate *>(          \\\n \n Review comment:\n   One space is missing before `\\`.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:55.758+0000",
                    "updated": "2019-12-28T02:18:55.758+0000",
                    "started": "2019-12-28T02:18:55.757+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364094",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364095",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361768322\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n+     garrow_file_stats_get_instance_private(       \\\n+       GARROW_FILE_STATS(obj)))\n+\n+static void\n+garrow_file_stats_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  priv->file_stats = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_stats_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_stats_set_property(GObject *object,\n+                               guint prop_id,\n+                               const GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_STATS:\n+    priv->file_stats =\n+      *static_cast<std::shared_ptr<arrow::fs::FileStats> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_get_property(GObject *object,\n+                               guint prop_id,\n+                               GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_init(GArrowFileStats *object)\n+{\n+}\n+\n+static void\n+garrow_file_stats_class_init(GArrowFileStatsClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_stats_finalize;\n+  gobject_class->set_property = garrow_file_stats_set_property;\n+  gobject_class->get_property = garrow_file_stats_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_stats\",\n+                              \"FileStats\",\n+                              \"The raw std::shared<arrow::fs::FileStats> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_STATS, spec);\n+}\n+\n+/**\n+ * garrow_file_stats_new:\n+ *\n+ * Returns: A newly created #GArrowFileStats.\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_stats_new(void)\n+{\n+  auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>();\n+  return garrow_file_stats_new_raw(&arrow_file_stats);\n+}\n+\n+/**\n+ * garrow_file_stats_equal:\n+ * @file_stats: A #GArrowFileStats.\n+ * @other_file_stats: A #GArrowFileStats to be compared.\n+ *\n+ * Returns: %TRUE if both of them have the same data, %FALSE\n+ *   otherwise.\n+ *\n+ * Since: 1.0.0\n+ */\n+gboolean\n+garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                        GArrowFileStats *other_file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto arrow_other_file_stats = garrow_file_stats_get_raw(other_file_stats);\n+  return arrow_file_stats->Equals(*arrow_other_file_stats);\n+}\n+\n+GArrowFileType\n+garrow_file_stats_get_file_type(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return (GArrowFileType)arrow_file_stats->type();\n+}\n+\n+void\n+garrow_file_stats_set_file_type(GArrowFileStats *file_stats,\n+                                GArrowFileType file_type)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_type(arrow::fs::FileType(file_type));\n+}\n+\n+gboolean\n+garrow_file_stats_is_file(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsFile();\n+}\n+\n+gboolean\n+garrow_file_stats_is_directory(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsDirectory();\n+}\n+\n+const gchar *\n+garrow_file_stats_get_path(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->path().c_str();\n+}\n+\n+void\n+garrow_file_stats_set_path(GArrowFileStats *file_stats,\n+                           const gchar *path)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_path(path);\n+}\n+\n+gchar *\n+garrow_file_stats_get_base_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto base_name = std::move(arrow_file_stats->base_name());\n+  return g_strndup(base_name.c_str(), base_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_dir_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto dir_name = std::move(arrow_file_stats->dir_name());\n+  return g_strndup(dir_name.c_str(), dir_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_extension(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto extension = std::move(arrow_file_stats->extension());\n+  return g_strndup(extension.c_str(), extension.size());\n+}\n+\n+gint64\n+garrow_file_stats_get_size(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->size();\n+}\n+\n+void\n+garrow_file_stats_set_size(GArrowFileStats *file_stats,\n+                           gint64 size)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_size(size);\n+}\n+\n+GArrowTimePoint\n+garrow_file_stats_get_mtime(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto mtime = arrow_file_stats->mtime();\n+  return mtime.time_since_epoch().count();\n+}\n+\n+void\n+garrow_file_stats_set_mtime(GArrowFileStats *file_stats,\n+                            GArrowTimePoint mtime)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow::fs::TimePoint::duration duration(mtime);\n+  arrow_file_stats->set_mtime(arrow::fs::TimePoint(duration));\n+}\n+\n+/* arrow::fs::FileSelector */\n+\n+typedef struct GArrowFileSelectorPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSelector> file_selector;\n+} GArrowFileSelectorPrivate;\n+\n+enum {\n+  PROP_FILE_SELECTOR = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileSelector, garrow_file_selector, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SELECTOR_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSelectorPrivate *>(          \\\n+     garrow_file_selector_get_instance_private(       \\\n+       GARROW_FILE_SELECTOR(obj)))\n+\n+static void\n+garrow_file_selector_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  priv->file_selector = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_selector_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_selector_set_property(GObject *object,\n+                                  guint prop_id,\n+                                  const GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SELECTOR:\n+    priv->file_selector =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSelector> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_get_property(GObject *object,\n+                                  guint prop_id,\n+                                  GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n \n Review comment:\n   We don't need this.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:55.761+0000",
                    "updated": "2019-12-28T02:18:55.761+0000",
                    "started": "2019-12-28T02:18:55.761+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364095",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364096",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361770252\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n+     garrow_file_stats_get_instance_private(       \\\n+       GARROW_FILE_STATS(obj)))\n+\n+static void\n+garrow_file_stats_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  priv->file_stats = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_stats_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_stats_set_property(GObject *object,\n+                               guint prop_id,\n+                               const GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_STATS:\n+    priv->file_stats =\n+      *static_cast<std::shared_ptr<arrow::fs::FileStats> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_get_property(GObject *object,\n+                               guint prop_id,\n+                               GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_init(GArrowFileStats *object)\n+{\n+}\n+\n+static void\n+garrow_file_stats_class_init(GArrowFileStatsClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_stats_finalize;\n+  gobject_class->set_property = garrow_file_stats_set_property;\n+  gobject_class->get_property = garrow_file_stats_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_stats\",\n+                              \"FileStats\",\n+                              \"The raw std::shared<arrow::fs::FileStats> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_STATS, spec);\n+}\n+\n+/**\n+ * garrow_file_stats_new:\n+ *\n+ * Returns: A newly created #GArrowFileStats.\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_stats_new(void)\n+{\n+  auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>();\n+  return garrow_file_stats_new_raw(&arrow_file_stats);\n+}\n+\n+/**\n+ * garrow_file_stats_equal:\n+ * @file_stats: A #GArrowFileStats.\n+ * @other_file_stats: A #GArrowFileStats to be compared.\n+ *\n+ * Returns: %TRUE if both of them have the same data, %FALSE\n+ *   otherwise.\n+ *\n+ * Since: 1.0.0\n+ */\n+gboolean\n+garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                        GArrowFileStats *other_file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto arrow_other_file_stats = garrow_file_stats_get_raw(other_file_stats);\n+  return arrow_file_stats->Equals(*arrow_other_file_stats);\n+}\n+\n+GArrowFileType\n+garrow_file_stats_get_file_type(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return (GArrowFileType)arrow_file_stats->type();\n+}\n+\n+void\n+garrow_file_stats_set_file_type(GArrowFileStats *file_stats,\n+                                GArrowFileType file_type)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_type(arrow::fs::FileType(file_type));\n+}\n+\n+gboolean\n+garrow_file_stats_is_file(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsFile();\n+}\n+\n+gboolean\n+garrow_file_stats_is_directory(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsDirectory();\n+}\n+\n+const gchar *\n+garrow_file_stats_get_path(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->path().c_str();\n+}\n+\n+void\n+garrow_file_stats_set_path(GArrowFileStats *file_stats,\n+                           const gchar *path)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_path(path);\n+}\n+\n+gchar *\n+garrow_file_stats_get_base_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto base_name = std::move(arrow_file_stats->base_name());\n+  return g_strndup(base_name.c_str(), base_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_dir_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto dir_name = std::move(arrow_file_stats->dir_name());\n+  return g_strndup(dir_name.c_str(), dir_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_extension(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto extension = std::move(arrow_file_stats->extension());\n+  return g_strndup(extension.c_str(), extension.size());\n+}\n+\n+gint64\n+garrow_file_stats_get_size(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->size();\n+}\n+\n+void\n+garrow_file_stats_set_size(GArrowFileStats *file_stats,\n+                           gint64 size)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_size(size);\n+}\n+\n+GArrowTimePoint\n+garrow_file_stats_get_mtime(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto mtime = arrow_file_stats->mtime();\n+  return mtime.time_since_epoch().count();\n+}\n+\n+void\n+garrow_file_stats_set_mtime(GArrowFileStats *file_stats,\n+                            GArrowTimePoint mtime)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow::fs::TimePoint::duration duration(mtime);\n+  arrow_file_stats->set_mtime(arrow::fs::TimePoint(duration));\n+}\n+\n+/* arrow::fs::FileSelector */\n+\n+typedef struct GArrowFileSelectorPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSelector> file_selector;\n+} GArrowFileSelectorPrivate;\n+\n+enum {\n+  PROP_FILE_SELECTOR = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileSelector, garrow_file_selector, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SELECTOR_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSelectorPrivate *>(          \\\n+     garrow_file_selector_get_instance_private(       \\\n+       GARROW_FILE_SELECTOR(obj)))\n+\n+static void\n+garrow_file_selector_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  priv->file_selector = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_selector_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_selector_set_property(GObject *object,\n+                                  guint prop_id,\n+                                  const GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SELECTOR:\n+    priv->file_selector =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSelector> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_get_property(GObject *object,\n+                                  guint prop_id,\n+                                  GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_init(GArrowFileSelector *object)\n+{\n+}\n+\n+static void\n+garrow_file_selector_class_init(GArrowFileSelectorClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_selector_finalize;\n+  gobject_class->set_property = garrow_file_selector_set_property;\n+  gobject_class->get_property = garrow_file_selector_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_selector\",\n+                              \"FileSelector\",\n+                              \"The raw std::shared<arrow::fs::FileSelector> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SELECTOR, spec);\n+}\n+\n+const gchar *\n+garrow_file_selector_get_base_dir(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->base_dir.c_str();\n+}\n+\n+void\n+garrow_file_selector_set_base_dir(GArrowFileSelector *file_selector,\n+                                  const gchar *base_dir)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->base_dir.assign(base_dir);\n+}\n+\n+gboolean\n+garrow_file_selector_get_allow_non_existent(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->allow_non_existent;\n+}\n+\n+void\n+garrow_file_selector_set_allow_non_existent(GArrowFileSelector *file_selector,\n+                                            gboolean allow_non_existent)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->allow_non_existent = allow_non_existent;\n+}\n+\n+gboolean\n+garrow_file_selector_get_recursive(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->recursive;\n+}\n+\n+void\n+garrow_file_selector_set_recursive(GArrowFileSelector *file_selector,\n+                                   gboolean recursive)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->recursive = recursive;\n+}\n+\n+gint32\n+garrow_file_selector_get_max_recursion(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->max_recursion;\n+}\n+\n+void\n+garrow_file_selector_set_max_recursion(GArrowFileSelector *file_selector,\n+                                       gint32 max_recursion)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->max_recursion = max_recursion;\n+}\n+\n+\n+/* arrow::fs::FileSystem */\n+\n+typedef struct GArrowFileSystemPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSystem> file_system;\n+} GArrowFileSystemPrivate;\n+\n+enum {\n+  PROP_FILE_SYSTEM = 1\n+};\n+\n+G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE(GArrowFileSystem,\n+                                    garrow_file_system,\n+                                    G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SYSTEM_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSystemPrivate *>(          \\\n \n Review comment:\n   One space is missing before `\\`.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:56.006+0000",
                    "updated": "2019-12-28T02:18:56.006+0000",
                    "started": "2019-12-28T02:18:56.006+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364096",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364097",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361770668\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n \n Review comment:\n   How about removing `std::shared_ptr`?\r\n   It seems that `arrow::fs::FileStats` isn't shared.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:56.012+0000",
                    "updated": "2019-12-28T02:18:56.012+0000",
                    "started": "2019-12-28T02:18:56.012+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364097",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364099",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361770893\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n+     garrow_file_stats_get_instance_private(       \\\n+       GARROW_FILE_STATS(obj)))\n+\n+static void\n+garrow_file_stats_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  priv->file_stats = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_stats_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_stats_set_property(GObject *object,\n+                               guint prop_id,\n+                               const GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_STATS:\n+    priv->file_stats =\n+      *static_cast<std::shared_ptr<arrow::fs::FileStats> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_get_property(GObject *object,\n+                               guint prop_id,\n+                               GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_init(GArrowFileStats *object)\n+{\n+}\n+\n+static void\n+garrow_file_stats_class_init(GArrowFileStatsClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_stats_finalize;\n+  gobject_class->set_property = garrow_file_stats_set_property;\n+  gobject_class->get_property = garrow_file_stats_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_stats\",\n+                              \"FileStats\",\n+                              \"The raw std::shared<arrow::fs::FileStats> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_STATS, spec);\n+}\n+\n+/**\n+ * garrow_file_stats_new:\n+ *\n+ * Returns: A newly created #GArrowFileStats.\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_stats_new(void)\n+{\n+  auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>();\n+  return garrow_file_stats_new_raw(&arrow_file_stats);\n+}\n+\n+/**\n+ * garrow_file_stats_equal:\n+ * @file_stats: A #GArrowFileStats.\n+ * @other_file_stats: A #GArrowFileStats to be compared.\n+ *\n+ * Returns: %TRUE if both of them have the same data, %FALSE\n+ *   otherwise.\n+ *\n+ * Since: 1.0.0\n+ */\n+gboolean\n+garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                        GArrowFileStats *other_file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto arrow_other_file_stats = garrow_file_stats_get_raw(other_file_stats);\n+  return arrow_file_stats->Equals(*arrow_other_file_stats);\n+}\n+\n+GArrowFileType\n+garrow_file_stats_get_file_type(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return (GArrowFileType)arrow_file_stats->type();\n+}\n+\n+void\n+garrow_file_stats_set_file_type(GArrowFileStats *file_stats,\n+                                GArrowFileType file_type)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_type(arrow::fs::FileType(file_type));\n+}\n+\n+gboolean\n+garrow_file_stats_is_file(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsFile();\n+}\n+\n+gboolean\n+garrow_file_stats_is_directory(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsDirectory();\n+}\n+\n+const gchar *\n+garrow_file_stats_get_path(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->path().c_str();\n+}\n+\n+void\n+garrow_file_stats_set_path(GArrowFileStats *file_stats,\n+                           const gchar *path)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_path(path);\n+}\n+\n+gchar *\n+garrow_file_stats_get_base_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto base_name = std::move(arrow_file_stats->base_name());\n+  return g_strndup(base_name.c_str(), base_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_dir_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto dir_name = std::move(arrow_file_stats->dir_name());\n+  return g_strndup(dir_name.c_str(), dir_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_extension(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto extension = std::move(arrow_file_stats->extension());\n+  return g_strndup(extension.c_str(), extension.size());\n+}\n+\n+gint64\n+garrow_file_stats_get_size(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->size();\n+}\n+\n+void\n+garrow_file_stats_set_size(GArrowFileStats *file_stats,\n+                           gint64 size)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_size(size);\n+}\n+\n+GArrowTimePoint\n+garrow_file_stats_get_mtime(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto mtime = arrow_file_stats->mtime();\n+  return mtime.time_since_epoch().count();\n+}\n+\n+void\n+garrow_file_stats_set_mtime(GArrowFileStats *file_stats,\n+                            GArrowTimePoint mtime)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow::fs::TimePoint::duration duration(mtime);\n+  arrow_file_stats->set_mtime(arrow::fs::TimePoint(duration));\n+}\n+\n+/* arrow::fs::FileSelector */\n+\n+typedef struct GArrowFileSelectorPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSelector> file_selector;\n+} GArrowFileSelectorPrivate;\n+\n+enum {\n+  PROP_FILE_SELECTOR = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileSelector, garrow_file_selector, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SELECTOR_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSelectorPrivate *>(          \\\n+     garrow_file_selector_get_instance_private(       \\\n+       GARROW_FILE_SELECTOR(obj)))\n+\n+static void\n+garrow_file_selector_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  priv->file_selector = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_selector_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_selector_set_property(GObject *object,\n+                                  guint prop_id,\n+                                  const GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SELECTOR:\n+    priv->file_selector =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSelector> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_get_property(GObject *object,\n+                                  guint prop_id,\n+                                  GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_init(GArrowFileSelector *object)\n+{\n+}\n+\n+static void\n+garrow_file_selector_class_init(GArrowFileSelectorClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_selector_finalize;\n+  gobject_class->set_property = garrow_file_selector_set_property;\n+  gobject_class->get_property = garrow_file_selector_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_selector\",\n+                              \"FileSelector\",\n+                              \"The raw std::shared<arrow::fs::FileSelector> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SELECTOR, spec);\n+}\n+\n+const gchar *\n+garrow_file_selector_get_base_dir(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->base_dir.c_str();\n+}\n+\n+void\n+garrow_file_selector_set_base_dir(GArrowFileSelector *file_selector,\n+                                  const gchar *base_dir)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->base_dir.assign(base_dir);\n+}\n+\n+gboolean\n+garrow_file_selector_get_allow_non_existent(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->allow_non_existent;\n+}\n+\n+void\n+garrow_file_selector_set_allow_non_existent(GArrowFileSelector *file_selector,\n+                                            gboolean allow_non_existent)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->allow_non_existent = allow_non_existent;\n+}\n+\n+gboolean\n+garrow_file_selector_get_recursive(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->recursive;\n+}\n+\n+void\n+garrow_file_selector_set_recursive(GArrowFileSelector *file_selector,\n+                                   gboolean recursive)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->recursive = recursive;\n+}\n+\n+gint32\n+garrow_file_selector_get_max_recursion(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->max_recursion;\n+}\n+\n+void\n+garrow_file_selector_set_max_recursion(GArrowFileSelector *file_selector,\n+                                       gint32 max_recursion)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->max_recursion = max_recursion;\n+}\n+\n+\n+/* arrow::fs::FileSystem */\n+\n+typedef struct GArrowFileSystemPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSystem> file_system;\n+} GArrowFileSystemPrivate;\n+\n+enum {\n+  PROP_FILE_SYSTEM = 1\n+};\n+\n+G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE(GArrowFileSystem,\n+                                    garrow_file_system,\n+                                    G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SYSTEM_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSystemPrivate *>(          \\\n+     garrow_file_system_get_instance_private(       \\\n+       GARROW_FILE_SYSTEM(obj)))\n+\n+static void\n+garrow_file_system_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SYSTEM_GET_PRIVATE(object);\n+\n+  priv->file_system = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_system_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_system_set_property(GObject *object,\n+                                guint prop_id,\n+                                const GValue *value,\n+                                GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SYSTEM_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SYSTEM:\n+    priv->file_system =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSystem> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_system_get_property(GObject *object,\n+                                guint prop_id,\n+                                GValue *value,\n+                                GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_system_init(GArrowFileSystem *object)\n+{\n+}\n+\n+static void\n+garrow_file_system_class_init(GArrowFileSystemClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_system_finalize;\n+  gobject_class->set_property = garrow_file_system_set_property;\n+  gobject_class->get_property = garrow_file_system_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_system\",\n+                              \"FileSystem\",\n+                              \"The raw std::shared<arrow::fs::FileSystem> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SYSTEM, spec);\n+}\n+\n+/**\n+ * garrow_file_system_get_type_name:\n+ * @file_system: A #GArrowFileSystem.\n+ *\n+ * Returns: The name of file system type.\n+ *\n+ * Since: 1.0.0\n+ */\n+const gchar *\n+garrow_file_system_get_type_name(GArrowFileSystem *file_system)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  return arrow_file_system->type_name().c_str();\n+}\n+\n+/**\n+ * garrow_file_system_get_target_stats:\n+ * @file_system: A #GArrowFileSystem.\n+ * @path: The path of the target.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Get statistics for the given target.\n+ *\n+ * Any symlink is automatically dereferenced, recursively.\n+ * A non-existing or unreachable file returns an OK status and has\n+ * a #GArrowFileType of value %GARROW_FILE_TYPE_NON_EXISTENT.\n+ * An error status indicates a truly exceptional condition\n+ * (low-level I/O error, etc.).\n+ *\n+ * Returns: (nullable) (transfer full): A #GArrowFileStats\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_system_get_target_stats(GArrowFileSystem *file_system,\n \n Review comment:\n   We use suffix for function name that has some variants like `garrow_decimal128_new_string()` and `garrow_decimal128_new_integer()`.\r\n   How about `garrow_file_system_get_target_stats_path()`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:56.250+0000",
                    "updated": "2019-12-28T02:18:56.250+0000",
                    "started": "2019-12-28T02:18:56.250+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364099",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364098",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361770782\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n+     garrow_file_stats_get_instance_private(       \\\n+       GARROW_FILE_STATS(obj)))\n+\n+static void\n+garrow_file_stats_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  priv->file_stats = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_stats_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_stats_set_property(GObject *object,\n+                               guint prop_id,\n+                               const GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_STATS:\n+    priv->file_stats =\n+      *static_cast<std::shared_ptr<arrow::fs::FileStats> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_get_property(GObject *object,\n+                               guint prop_id,\n+                               GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_init(GArrowFileStats *object)\n+{\n+}\n+\n+static void\n+garrow_file_stats_class_init(GArrowFileStatsClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_stats_finalize;\n+  gobject_class->set_property = garrow_file_stats_set_property;\n+  gobject_class->get_property = garrow_file_stats_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_stats\",\n+                              \"FileStats\",\n+                              \"The raw std::shared<arrow::fs::FileStats> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_STATS, spec);\n+}\n+\n+/**\n+ * garrow_file_stats_new:\n+ *\n+ * Returns: A newly created #GArrowFileStats.\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_stats_new(void)\n+{\n+  auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>();\n+  return garrow_file_stats_new_raw(&arrow_file_stats);\n+}\n+\n+/**\n+ * garrow_file_stats_equal:\n+ * @file_stats: A #GArrowFileStats.\n+ * @other_file_stats: A #GArrowFileStats to be compared.\n+ *\n+ * Returns: %TRUE if both of them have the same data, %FALSE\n+ *   otherwise.\n+ *\n+ * Since: 1.0.0\n+ */\n+gboolean\n+garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                        GArrowFileStats *other_file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto arrow_other_file_stats = garrow_file_stats_get_raw(other_file_stats);\n+  return arrow_file_stats->Equals(*arrow_other_file_stats);\n+}\n+\n+GArrowFileType\n+garrow_file_stats_get_file_type(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return (GArrowFileType)arrow_file_stats->type();\n+}\n+\n+void\n+garrow_file_stats_set_file_type(GArrowFileStats *file_stats,\n+                                GArrowFileType file_type)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_type(arrow::fs::FileType(file_type));\n+}\n+\n+gboolean\n+garrow_file_stats_is_file(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsFile();\n+}\n+\n+gboolean\n+garrow_file_stats_is_directory(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsDirectory();\n+}\n+\n+const gchar *\n+garrow_file_stats_get_path(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->path().c_str();\n+}\n+\n+void\n+garrow_file_stats_set_path(GArrowFileStats *file_stats,\n+                           const gchar *path)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_path(path);\n+}\n+\n+gchar *\n+garrow_file_stats_get_base_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto base_name = std::move(arrow_file_stats->base_name());\n+  return g_strndup(base_name.c_str(), base_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_dir_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto dir_name = std::move(arrow_file_stats->dir_name());\n+  return g_strndup(dir_name.c_str(), dir_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_extension(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto extension = std::move(arrow_file_stats->extension());\n+  return g_strndup(extension.c_str(), extension.size());\n+}\n+\n+gint64\n+garrow_file_stats_get_size(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->size();\n+}\n+\n+void\n+garrow_file_stats_set_size(GArrowFileStats *file_stats,\n+                           gint64 size)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_size(size);\n+}\n+\n+GArrowTimePoint\n+garrow_file_stats_get_mtime(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto mtime = arrow_file_stats->mtime();\n+  return mtime.time_since_epoch().count();\n+}\n+\n+void\n+garrow_file_stats_set_mtime(GArrowFileStats *file_stats,\n+                            GArrowTimePoint mtime)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow::fs::TimePoint::duration duration(mtime);\n+  arrow_file_stats->set_mtime(arrow::fs::TimePoint(duration));\n+}\n+\n+/* arrow::fs::FileSelector */\n+\n+typedef struct GArrowFileSelectorPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSelector> file_selector;\n+} GArrowFileSelectorPrivate;\n+\n+enum {\n+  PROP_FILE_SELECTOR = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileSelector, garrow_file_selector, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SELECTOR_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSelectorPrivate *>(          \\\n+     garrow_file_selector_get_instance_private(       \\\n+       GARROW_FILE_SELECTOR(obj)))\n+\n+static void\n+garrow_file_selector_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  priv->file_selector = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_selector_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_selector_set_property(GObject *object,\n+                                  guint prop_id,\n+                                  const GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SELECTOR:\n+    priv->file_selector =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSelector> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_get_property(GObject *object,\n+                                  guint prop_id,\n+                                  GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_init(GArrowFileSelector *object)\n+{\n+}\n+\n+static void\n+garrow_file_selector_class_init(GArrowFileSelectorClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_selector_finalize;\n+  gobject_class->set_property = garrow_file_selector_set_property;\n+  gobject_class->get_property = garrow_file_selector_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_selector\",\n+                              \"FileSelector\",\n+                              \"The raw std::shared<arrow::fs::FileSelector> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SELECTOR, spec);\n+}\n+\n+const gchar *\n+garrow_file_selector_get_base_dir(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->base_dir.c_str();\n+}\n+\n+void\n+garrow_file_selector_set_base_dir(GArrowFileSelector *file_selector,\n+                                  const gchar *base_dir)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->base_dir.assign(base_dir);\n+}\n+\n+gboolean\n+garrow_file_selector_get_allow_non_existent(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->allow_non_existent;\n+}\n+\n+void\n+garrow_file_selector_set_allow_non_existent(GArrowFileSelector *file_selector,\n+                                            gboolean allow_non_existent)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->allow_non_existent = allow_non_existent;\n+}\n+\n+gboolean\n+garrow_file_selector_get_recursive(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->recursive;\n+}\n+\n+void\n+garrow_file_selector_set_recursive(GArrowFileSelector *file_selector,\n+                                   gboolean recursive)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->recursive = recursive;\n+}\n+\n+gint32\n+garrow_file_selector_get_max_recursion(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->max_recursion;\n+}\n+\n+void\n+garrow_file_selector_set_max_recursion(GArrowFileSelector *file_selector,\n+                                       gint32 max_recursion)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->max_recursion = max_recursion;\n+}\n+\n+\n+/* arrow::fs::FileSystem */\n+\n+typedef struct GArrowFileSystemPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSystem> file_system;\n+} GArrowFileSystemPrivate;\n+\n+enum {\n+  PROP_FILE_SYSTEM = 1\n+};\n+\n+G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE(GArrowFileSystem,\n+                                    garrow_file_system,\n+                                    G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SYSTEM_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSystemPrivate *>(          \\\n+     garrow_file_system_get_instance_private(       \\\n+       GARROW_FILE_SYSTEM(obj)))\n+\n+static void\n+garrow_file_system_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SYSTEM_GET_PRIVATE(object);\n+\n+  priv->file_system = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_system_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_system_set_property(GObject *object,\n+                                guint prop_id,\n+                                const GValue *value,\n+                                GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SYSTEM_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SYSTEM:\n+    priv->file_system =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSystem> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_system_get_property(GObject *object,\n+                                guint prop_id,\n+                                GValue *value,\n+                                GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_system_init(GArrowFileSystem *object)\n+{\n+}\n+\n+static void\n+garrow_file_system_class_init(GArrowFileSystemClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_system_finalize;\n+  gobject_class->set_property = garrow_file_system_set_property;\n+  gobject_class->get_property = garrow_file_system_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_system\",\n+                              \"FileSystem\",\n+                              \"The raw std::shared<arrow::fs::FileSystem> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SYSTEM, spec);\n+}\n+\n+/**\n+ * garrow_file_system_get_type_name:\n+ * @file_system: A #GArrowFileSystem.\n+ *\n+ * Returns: The name of file system type.\n+ *\n+ * Since: 1.0.0\n+ */\n+const gchar *\n+garrow_file_system_get_type_name(GArrowFileSystem *file_system)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  return arrow_file_system->type_name().c_str();\n+}\n+\n+/**\n+ * garrow_file_system_get_target_stats:\n+ * @file_system: A #GArrowFileSystem.\n+ * @path: The path of the target.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Get statistics for the given target.\n+ *\n+ * Any symlink is automatically dereferenced, recursively.\n+ * A non-existing or unreachable file returns an OK status and has\n+ * a #GArrowFileType of value %GARROW_FILE_TYPE_NON_EXISTENT.\n+ * An error status indicates a truly exceptional condition\n+ * (low-level I/O error, etc.).\n+ *\n+ * Returns: (nullable) (transfer full): A #GArrowFileStats\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_system_get_target_stats(GArrowFileSystem *file_system,\n+                                    const gchar *path,\n+                                    GError **error)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  auto arrow_result = arrow_file_system->GetTargetStats(path);\n+  if (garrow::check(error, arrow_result, \"[filesystem][get_target_stats]\")) {\n+    auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>(arrow_result.ValueOrDie());\n+    return garrow_file_stats_new_raw(&arrow_file_stats);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+namespace {\n+\n+inline GList *\n+garrow_file_stats_list_from_result(arrow::Result<std::vector<arrow::fs::FileStats>>&& arrow_result,\n+                                   GError **error,\n+                                   const gchar *context)\n+{\n+  if (garrow::check(error, arrow_result, context)) {\n+    auto arrow_file_stats_vector = arrow_result.ValueOrDie();\n+    GList *file_stats_list = NULL;\n+    for (auto arrow_file_stats : arrow_file_stats_vector) {\n+      auto arrow_file_stats_ptr = std::make_shared<decltype(arrow_file_stats)>(arrow_file_stats);\n+      auto file_stats = garrow_file_stats_new_raw(&arrow_file_stats_ptr);\n+      file_stats_list = g_list_prepend(file_stats_list, file_stats);\n+    }\n+    return g_list_reverse(file_stats_list);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+}\n+\n+/**\n+ * garrow_file_system_get_target_stats_list:\n+ * @file_system: A #GArrowFileSystem.\n+ * @paths: The paths of the targets.\n+ * @n_paths: The number of items in @paths.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Get statistics same as garrow_file_system_get_target_stats() for the\n+ * given many targets at once.\n+ *\n+ * Returns: (element-type GArrowFileStats) (transfer full):\n+ *   A list of #GArrowFileStats\n+ *\n+ * Since: 1.0.0\n+ */\n+GList *\n+garrow_file_system_get_target_stats_list(GArrowFileSystem *file_system,\n+                                         const gchar **paths,\n+                                         gsize n_paths,\n+                                         GError **error)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  std::vector<std::string> arrow_paths;\n+  for (gsize i = 0; i < n_paths; ++i) {\n+    arrow_paths.push_back(paths[i]);\n+  }\n+  return garrow_file_stats_list_from_result(arrow_file_system->GetTargetStats(arrow_paths),\n+                                            error, \"[filesystem][get_target_stats_list]\");\n \n Review comment:\n   Could you use \"-\" instead of \"_\" for word separator?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:56.250+0000",
                    "updated": "2019-12-28T02:18:56.250+0000",
                    "started": "2019-12-28T02:18:56.250+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364098",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364100",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361770906\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n+     garrow_file_stats_get_instance_private(       \\\n+       GARROW_FILE_STATS(obj)))\n+\n+static void\n+garrow_file_stats_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  priv->file_stats = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_stats_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_stats_set_property(GObject *object,\n+                               guint prop_id,\n+                               const GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_STATS:\n+    priv->file_stats =\n+      *static_cast<std::shared_ptr<arrow::fs::FileStats> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_get_property(GObject *object,\n+                               guint prop_id,\n+                               GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_init(GArrowFileStats *object)\n+{\n+}\n+\n+static void\n+garrow_file_stats_class_init(GArrowFileStatsClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_stats_finalize;\n+  gobject_class->set_property = garrow_file_stats_set_property;\n+  gobject_class->get_property = garrow_file_stats_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_stats\",\n+                              \"FileStats\",\n+                              \"The raw std::shared<arrow::fs::FileStats> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_STATS, spec);\n+}\n+\n+/**\n+ * garrow_file_stats_new:\n+ *\n+ * Returns: A newly created #GArrowFileStats.\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_stats_new(void)\n+{\n+  auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>();\n+  return garrow_file_stats_new_raw(&arrow_file_stats);\n+}\n+\n+/**\n+ * garrow_file_stats_equal:\n+ * @file_stats: A #GArrowFileStats.\n+ * @other_file_stats: A #GArrowFileStats to be compared.\n+ *\n+ * Returns: %TRUE if both of them have the same data, %FALSE\n+ *   otherwise.\n+ *\n+ * Since: 1.0.0\n+ */\n+gboolean\n+garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                        GArrowFileStats *other_file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto arrow_other_file_stats = garrow_file_stats_get_raw(other_file_stats);\n+  return arrow_file_stats->Equals(*arrow_other_file_stats);\n+}\n+\n+GArrowFileType\n+garrow_file_stats_get_file_type(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return (GArrowFileType)arrow_file_stats->type();\n+}\n+\n+void\n+garrow_file_stats_set_file_type(GArrowFileStats *file_stats,\n+                                GArrowFileType file_type)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_type(arrow::fs::FileType(file_type));\n+}\n+\n+gboolean\n+garrow_file_stats_is_file(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsFile();\n+}\n+\n+gboolean\n+garrow_file_stats_is_directory(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsDirectory();\n+}\n+\n+const gchar *\n+garrow_file_stats_get_path(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->path().c_str();\n+}\n+\n+void\n+garrow_file_stats_set_path(GArrowFileStats *file_stats,\n+                           const gchar *path)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_path(path);\n+}\n+\n+gchar *\n+garrow_file_stats_get_base_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto base_name = std::move(arrow_file_stats->base_name());\n+  return g_strndup(base_name.c_str(), base_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_dir_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto dir_name = std::move(arrow_file_stats->dir_name());\n+  return g_strndup(dir_name.c_str(), dir_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_extension(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto extension = std::move(arrow_file_stats->extension());\n+  return g_strndup(extension.c_str(), extension.size());\n+}\n+\n+gint64\n+garrow_file_stats_get_size(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->size();\n+}\n+\n+void\n+garrow_file_stats_set_size(GArrowFileStats *file_stats,\n+                           gint64 size)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_size(size);\n+}\n+\n+GArrowTimePoint\n+garrow_file_stats_get_mtime(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto mtime = arrow_file_stats->mtime();\n+  return mtime.time_since_epoch().count();\n+}\n+\n+void\n+garrow_file_stats_set_mtime(GArrowFileStats *file_stats,\n+                            GArrowTimePoint mtime)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow::fs::TimePoint::duration duration(mtime);\n+  arrow_file_stats->set_mtime(arrow::fs::TimePoint(duration));\n+}\n+\n+/* arrow::fs::FileSelector */\n+\n+typedef struct GArrowFileSelectorPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSelector> file_selector;\n+} GArrowFileSelectorPrivate;\n+\n+enum {\n+  PROP_FILE_SELECTOR = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileSelector, garrow_file_selector, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SELECTOR_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSelectorPrivate *>(          \\\n+     garrow_file_selector_get_instance_private(       \\\n+       GARROW_FILE_SELECTOR(obj)))\n+\n+static void\n+garrow_file_selector_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  priv->file_selector = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_selector_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_selector_set_property(GObject *object,\n+                                  guint prop_id,\n+                                  const GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SELECTOR:\n+    priv->file_selector =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSelector> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_get_property(GObject *object,\n+                                  guint prop_id,\n+                                  GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_init(GArrowFileSelector *object)\n+{\n+}\n+\n+static void\n+garrow_file_selector_class_init(GArrowFileSelectorClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_selector_finalize;\n+  gobject_class->set_property = garrow_file_selector_set_property;\n+  gobject_class->get_property = garrow_file_selector_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_selector\",\n+                              \"FileSelector\",\n+                              \"The raw std::shared<arrow::fs::FileSelector> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SELECTOR, spec);\n+}\n+\n+const gchar *\n+garrow_file_selector_get_base_dir(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->base_dir.c_str();\n+}\n+\n+void\n+garrow_file_selector_set_base_dir(GArrowFileSelector *file_selector,\n+                                  const gchar *base_dir)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->base_dir.assign(base_dir);\n+}\n+\n+gboolean\n+garrow_file_selector_get_allow_non_existent(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->allow_non_existent;\n+}\n+\n+void\n+garrow_file_selector_set_allow_non_existent(GArrowFileSelector *file_selector,\n+                                            gboolean allow_non_existent)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->allow_non_existent = allow_non_existent;\n+}\n+\n+gboolean\n+garrow_file_selector_get_recursive(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->recursive;\n+}\n+\n+void\n+garrow_file_selector_set_recursive(GArrowFileSelector *file_selector,\n+                                   gboolean recursive)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->recursive = recursive;\n+}\n+\n+gint32\n+garrow_file_selector_get_max_recursion(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->max_recursion;\n+}\n+\n+void\n+garrow_file_selector_set_max_recursion(GArrowFileSelector *file_selector,\n+                                       gint32 max_recursion)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->max_recursion = max_recursion;\n+}\n+\n+\n+/* arrow::fs::FileSystem */\n+\n+typedef struct GArrowFileSystemPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSystem> file_system;\n+} GArrowFileSystemPrivate;\n+\n+enum {\n+  PROP_FILE_SYSTEM = 1\n+};\n+\n+G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE(GArrowFileSystem,\n+                                    garrow_file_system,\n+                                    G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SYSTEM_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSystemPrivate *>(          \\\n+     garrow_file_system_get_instance_private(       \\\n+       GARROW_FILE_SYSTEM(obj)))\n+\n+static void\n+garrow_file_system_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SYSTEM_GET_PRIVATE(object);\n+\n+  priv->file_system = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_system_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_system_set_property(GObject *object,\n+                                guint prop_id,\n+                                const GValue *value,\n+                                GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SYSTEM_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SYSTEM:\n+    priv->file_system =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSystem> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_system_get_property(GObject *object,\n+                                guint prop_id,\n+                                GValue *value,\n+                                GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_system_init(GArrowFileSystem *object)\n+{\n+}\n+\n+static void\n+garrow_file_system_class_init(GArrowFileSystemClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_system_finalize;\n+  gobject_class->set_property = garrow_file_system_set_property;\n+  gobject_class->get_property = garrow_file_system_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_system\",\n+                              \"FileSystem\",\n+                              \"The raw std::shared<arrow::fs::FileSystem> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SYSTEM, spec);\n+}\n+\n+/**\n+ * garrow_file_system_get_type_name:\n+ * @file_system: A #GArrowFileSystem.\n+ *\n+ * Returns: The name of file system type.\n+ *\n+ * Since: 1.0.0\n+ */\n+const gchar *\n+garrow_file_system_get_type_name(GArrowFileSystem *file_system)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  return arrow_file_system->type_name().c_str();\n+}\n+\n+/**\n+ * garrow_file_system_get_target_stats:\n+ * @file_system: A #GArrowFileSystem.\n+ * @path: The path of the target.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Get statistics for the given target.\n+ *\n+ * Any symlink is automatically dereferenced, recursively.\n+ * A non-existing or unreachable file returns an OK status and has\n+ * a #GArrowFileType of value %GARROW_FILE_TYPE_NON_EXISTENT.\n+ * An error status indicates a truly exceptional condition\n+ * (low-level I/O error, etc.).\n+ *\n+ * Returns: (nullable) (transfer full): A #GArrowFileStats\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_system_get_target_stats(GArrowFileSystem *file_system,\n+                                    const gchar *path,\n+                                    GError **error)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  auto arrow_result = arrow_file_system->GetTargetStats(path);\n+  if (garrow::check(error, arrow_result, \"[filesystem][get_target_stats]\")) {\n+    auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>(arrow_result.ValueOrDie());\n+    return garrow_file_stats_new_raw(&arrow_file_stats);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+namespace {\n+\n+inline GList *\n+garrow_file_stats_list_from_result(arrow::Result<std::vector<arrow::fs::FileStats>>&& arrow_result,\n+                                   GError **error,\n+                                   const gchar *context)\n+{\n+  if (garrow::check(error, arrow_result, context)) {\n+    auto arrow_file_stats_vector = arrow_result.ValueOrDie();\n+    GList *file_stats_list = NULL;\n+    for (auto arrow_file_stats : arrow_file_stats_vector) {\n+      auto arrow_file_stats_ptr = std::make_shared<decltype(arrow_file_stats)>(arrow_file_stats);\n+      auto file_stats = garrow_file_stats_new_raw(&arrow_file_stats_ptr);\n+      file_stats_list = g_list_prepend(file_stats_list, file_stats);\n+    }\n+    return g_list_reverse(file_stats_list);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+}\n+\n+/**\n+ * garrow_file_system_get_target_stats_list:\n+ * @file_system: A #GArrowFileSystem.\n+ * @paths: The paths of the targets.\n+ * @n_paths: The number of items in @paths.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Get statistics same as garrow_file_system_get_target_stats() for the\n+ * given many targets at once.\n+ *\n+ * Returns: (element-type GArrowFileStats) (transfer full):\n+ *   A list of #GArrowFileStats\n+ *\n+ * Since: 1.0.0\n+ */\n+GList *\n+garrow_file_system_get_target_stats_list(GArrowFileSystem *file_system,\n+                                         const gchar **paths,\n+                                         gsize n_paths,\n+                                         GError **error)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  std::vector<std::string> arrow_paths;\n+  for (gsize i = 0; i < n_paths; ++i) {\n+    arrow_paths.push_back(paths[i]);\n+  }\n+  return garrow_file_stats_list_from_result(arrow_file_system->GetTargetStats(arrow_paths),\n+                                            error, \"[filesystem][get_target_stats_list]\");\n+}\n+\n+/**\n+ * garrow_file_system_get_target_stats_list_by_selector:\n+ * @file_system: A #GArrowFileSystem.\n+ * @file_selector: A #GArrowFileSelector.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Get statistics same as garrow_file_system_get_target_stats() according to\n+ * a selector.\n+ *\n+ * The selector's base directory will not be part of the results,\n+ * even if it exists.\n+ *\n+ * Returns: (element-type GArrowFileStats) (transfer full):\n+ *   A list of #GArrowFileStats\n+ *\n+ * Since: 1.0.0\n+ */\n+GList *\n+garrow_file_system_get_target_stats_list_by_selector(GArrowFileSystem *file_system,\n \n Review comment:\n   We use suffix for function name that has some variants like `garrow_decimal128_new_string()` and `garrow_decimal128_new_integer()`.\r\n   How about `garrow_file_system_get_target_stats_selector()`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:56.296+0000",
                    "updated": "2019-12-28T02:18:56.296+0000",
                    "started": "2019-12-28T02:18:56.296+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364100",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364101",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361770935\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n+     garrow_file_stats_get_instance_private(       \\\n+       GARROW_FILE_STATS(obj)))\n+\n+static void\n+garrow_file_stats_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  priv->file_stats = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_stats_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_stats_set_property(GObject *object,\n+                               guint prop_id,\n+                               const GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_STATS:\n+    priv->file_stats =\n+      *static_cast<std::shared_ptr<arrow::fs::FileStats> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_get_property(GObject *object,\n+                               guint prop_id,\n+                               GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_init(GArrowFileStats *object)\n+{\n+}\n+\n+static void\n+garrow_file_stats_class_init(GArrowFileStatsClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_stats_finalize;\n+  gobject_class->set_property = garrow_file_stats_set_property;\n+  gobject_class->get_property = garrow_file_stats_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_stats\",\n+                              \"FileStats\",\n+                              \"The raw std::shared<arrow::fs::FileStats> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_STATS, spec);\n+}\n+\n+/**\n+ * garrow_file_stats_new:\n+ *\n+ * Returns: A newly created #GArrowFileStats.\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_stats_new(void)\n+{\n+  auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>();\n+  return garrow_file_stats_new_raw(&arrow_file_stats);\n+}\n+\n+/**\n+ * garrow_file_stats_equal:\n+ * @file_stats: A #GArrowFileStats.\n+ * @other_file_stats: A #GArrowFileStats to be compared.\n+ *\n+ * Returns: %TRUE if both of them have the same data, %FALSE\n+ *   otherwise.\n+ *\n+ * Since: 1.0.0\n+ */\n+gboolean\n+garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                        GArrowFileStats *other_file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto arrow_other_file_stats = garrow_file_stats_get_raw(other_file_stats);\n+  return arrow_file_stats->Equals(*arrow_other_file_stats);\n+}\n+\n+GArrowFileType\n+garrow_file_stats_get_file_type(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return (GArrowFileType)arrow_file_stats->type();\n+}\n+\n+void\n+garrow_file_stats_set_file_type(GArrowFileStats *file_stats,\n+                                GArrowFileType file_type)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_type(arrow::fs::FileType(file_type));\n+}\n+\n+gboolean\n+garrow_file_stats_is_file(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsFile();\n+}\n+\n+gboolean\n+garrow_file_stats_is_directory(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsDirectory();\n+}\n+\n+const gchar *\n+garrow_file_stats_get_path(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->path().c_str();\n+}\n+\n+void\n+garrow_file_stats_set_path(GArrowFileStats *file_stats,\n+                           const gchar *path)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_path(path);\n+}\n+\n+gchar *\n+garrow_file_stats_get_base_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto base_name = std::move(arrow_file_stats->base_name());\n+  return g_strndup(base_name.c_str(), base_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_dir_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto dir_name = std::move(arrow_file_stats->dir_name());\n+  return g_strndup(dir_name.c_str(), dir_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_extension(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto extension = std::move(arrow_file_stats->extension());\n+  return g_strndup(extension.c_str(), extension.size());\n+}\n+\n+gint64\n+garrow_file_stats_get_size(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->size();\n+}\n+\n+void\n+garrow_file_stats_set_size(GArrowFileStats *file_stats,\n+                           gint64 size)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_size(size);\n+}\n+\n+GArrowTimePoint\n+garrow_file_stats_get_mtime(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto mtime = arrow_file_stats->mtime();\n+  return mtime.time_since_epoch().count();\n+}\n+\n+void\n+garrow_file_stats_set_mtime(GArrowFileStats *file_stats,\n+                            GArrowTimePoint mtime)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow::fs::TimePoint::duration duration(mtime);\n+  arrow_file_stats->set_mtime(arrow::fs::TimePoint(duration));\n+}\n+\n+/* arrow::fs::FileSelector */\n+\n+typedef struct GArrowFileSelectorPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSelector> file_selector;\n+} GArrowFileSelectorPrivate;\n+\n+enum {\n+  PROP_FILE_SELECTOR = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileSelector, garrow_file_selector, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SELECTOR_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSelectorPrivate *>(          \\\n+     garrow_file_selector_get_instance_private(       \\\n+       GARROW_FILE_SELECTOR(obj)))\n+\n+static void\n+garrow_file_selector_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  priv->file_selector = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_selector_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_selector_set_property(GObject *object,\n+                                  guint prop_id,\n+                                  const GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SELECTOR:\n+    priv->file_selector =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSelector> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_get_property(GObject *object,\n+                                  guint prop_id,\n+                                  GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_init(GArrowFileSelector *object)\n+{\n+}\n+\n+static void\n+garrow_file_selector_class_init(GArrowFileSelectorClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_selector_finalize;\n+  gobject_class->set_property = garrow_file_selector_set_property;\n+  gobject_class->get_property = garrow_file_selector_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_selector\",\n+                              \"FileSelector\",\n+                              \"The raw std::shared<arrow::fs::FileSelector> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SELECTOR, spec);\n+}\n+\n+const gchar *\n+garrow_file_selector_get_base_dir(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->base_dir.c_str();\n+}\n+\n+void\n+garrow_file_selector_set_base_dir(GArrowFileSelector *file_selector,\n+                                  const gchar *base_dir)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->base_dir.assign(base_dir);\n+}\n+\n+gboolean\n+garrow_file_selector_get_allow_non_existent(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->allow_non_existent;\n+}\n+\n+void\n+garrow_file_selector_set_allow_non_existent(GArrowFileSelector *file_selector,\n+                                            gboolean allow_non_existent)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->allow_non_existent = allow_non_existent;\n+}\n+\n+gboolean\n+garrow_file_selector_get_recursive(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->recursive;\n+}\n+\n+void\n+garrow_file_selector_set_recursive(GArrowFileSelector *file_selector,\n+                                   gboolean recursive)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->recursive = recursive;\n+}\n+\n+gint32\n+garrow_file_selector_get_max_recursion(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->max_recursion;\n+}\n+\n+void\n+garrow_file_selector_set_max_recursion(GArrowFileSelector *file_selector,\n+                                       gint32 max_recursion)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->max_recursion = max_recursion;\n+}\n+\n+\n+/* arrow::fs::FileSystem */\n+\n+typedef struct GArrowFileSystemPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSystem> file_system;\n+} GArrowFileSystemPrivate;\n+\n+enum {\n+  PROP_FILE_SYSTEM = 1\n+};\n+\n+G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE(GArrowFileSystem,\n+                                    garrow_file_system,\n+                                    G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SYSTEM_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSystemPrivate *>(          \\\n+     garrow_file_system_get_instance_private(       \\\n+       GARROW_FILE_SYSTEM(obj)))\n+\n+static void\n+garrow_file_system_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SYSTEM_GET_PRIVATE(object);\n+\n+  priv->file_system = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_system_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_system_set_property(GObject *object,\n+                                guint prop_id,\n+                                const GValue *value,\n+                                GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SYSTEM_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SYSTEM:\n+    priv->file_system =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSystem> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_system_get_property(GObject *object,\n+                                guint prop_id,\n+                                GValue *value,\n+                                GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_system_init(GArrowFileSystem *object)\n+{\n+}\n+\n+static void\n+garrow_file_system_class_init(GArrowFileSystemClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_system_finalize;\n+  gobject_class->set_property = garrow_file_system_set_property;\n+  gobject_class->get_property = garrow_file_system_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_system\",\n+                              \"FileSystem\",\n+                              \"The raw std::shared<arrow::fs::FileSystem> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SYSTEM, spec);\n+}\n+\n+/**\n+ * garrow_file_system_get_type_name:\n+ * @file_system: A #GArrowFileSystem.\n+ *\n+ * Returns: The name of file system type.\n+ *\n+ * Since: 1.0.0\n+ */\n+const gchar *\n+garrow_file_system_get_type_name(GArrowFileSystem *file_system)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  return arrow_file_system->type_name().c_str();\n+}\n+\n+/**\n+ * garrow_file_system_get_target_stats:\n+ * @file_system: A #GArrowFileSystem.\n+ * @path: The path of the target.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Get statistics for the given target.\n+ *\n+ * Any symlink is automatically dereferenced, recursively.\n+ * A non-existing or unreachable file returns an OK status and has\n+ * a #GArrowFileType of value %GARROW_FILE_TYPE_NON_EXISTENT.\n+ * An error status indicates a truly exceptional condition\n+ * (low-level I/O error, etc.).\n+ *\n+ * Returns: (nullable) (transfer full): A #GArrowFileStats\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_system_get_target_stats(GArrowFileSystem *file_system,\n+                                    const gchar *path,\n+                                    GError **error)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  auto arrow_result = arrow_file_system->GetTargetStats(path);\n+  if (garrow::check(error, arrow_result, \"[filesystem][get_target_stats]\")) {\n+    auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>(arrow_result.ValueOrDie());\n+    return garrow_file_stats_new_raw(&arrow_file_stats);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+namespace {\n+\n+inline GList *\n+garrow_file_stats_list_from_result(arrow::Result<std::vector<arrow::fs::FileStats>>&& arrow_result,\n+                                   GError **error,\n+                                   const gchar *context)\n+{\n+  if (garrow::check(error, arrow_result, context)) {\n+    auto arrow_file_stats_vector = arrow_result.ValueOrDie();\n+    GList *file_stats_list = NULL;\n+    for (auto arrow_file_stats : arrow_file_stats_vector) {\n+      auto arrow_file_stats_ptr = std::make_shared<decltype(arrow_file_stats)>(arrow_file_stats);\n+      auto file_stats = garrow_file_stats_new_raw(&arrow_file_stats_ptr);\n+      file_stats_list = g_list_prepend(file_stats_list, file_stats);\n+    }\n+    return g_list_reverse(file_stats_list);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+}\n+\n+/**\n+ * garrow_file_system_get_target_stats_list:\n+ * @file_system: A #GArrowFileSystem.\n+ * @paths: The paths of the targets.\n+ * @n_paths: The number of items in @paths.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Get statistics same as garrow_file_system_get_target_stats() for the\n+ * given many targets at once.\n+ *\n+ * Returns: (element-type GArrowFileStats) (transfer full):\n+ *   A list of #GArrowFileStats\n+ *\n+ * Since: 1.0.0\n+ */\n+GList *\n+garrow_file_system_get_target_stats_list(GArrowFileSystem *file_system,\n+                                         const gchar **paths,\n+                                         gsize n_paths,\n+                                         GError **error)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  std::vector<std::string> arrow_paths;\n+  for (gsize i = 0; i < n_paths; ++i) {\n+    arrow_paths.push_back(paths[i]);\n+  }\n+  return garrow_file_stats_list_from_result(arrow_file_system->GetTargetStats(arrow_paths),\n+                                            error, \"[filesystem][get_target_stats_list]\");\n+}\n+\n+/**\n+ * garrow_file_system_get_target_stats_list_by_selector:\n+ * @file_system: A #GArrowFileSystem.\n+ * @file_selector: A #GArrowFileSelector.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Get statistics same as garrow_file_system_get_target_stats() according to\n+ * a selector.\n+ *\n+ * The selector's base directory will not be part of the results,\n+ * even if it exists.\n+ *\n+ * Returns: (element-type GArrowFileStats) (transfer full):\n+ *   A list of #GArrowFileStats\n+ *\n+ * Since: 1.0.0\n+ */\n+GList *\n+garrow_file_system_get_target_stats_list_by_selector(GArrowFileSystem *file_system,\n+                                                     GArrowFileSelector *file_selector,\n+                                                     GError **error)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return garrow_file_stats_list_from_result(arrow_file_system->GetTargetStats(*arrow_file_selector),\n+                                            error, \"[filesystem][get_target_stats_list]\");\n+}\n+\n+/**\n+ * garrow_file_system_create_dir:\n+ * @file_system: A #GArrowFileSystem.\n+ * @path: The paths of the directory.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Create a directory and subdirectories.\n+ * This function succeeds if the directory already exists.\n+ *\n+ * Since: 1.0.0\n+ */\n+void\n+garrow_file_system_create_dir(GArrowFileSystem *file_system,\n+                              const gchar *path,\n+                              gboolean recursive,\n+                              GError **error)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  auto status = arrow_file_system->CreateDir(path, recursive);\n+  (void)garrow::check(error, status, \"[filesystem][create_dir]\");\n \n Review comment:\n   We return `gboolean` instead of `void`.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:56.300+0000",
                    "updated": "2019-12-28T02:18:56.300+0000",
                    "started": "2019-12-28T02:18:56.299+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364101",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364102",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361770764\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n+     garrow_file_stats_get_instance_private(       \\\n+       GARROW_FILE_STATS(obj)))\n+\n+static void\n+garrow_file_stats_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  priv->file_stats = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_stats_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_stats_set_property(GObject *object,\n+                               guint prop_id,\n+                               const GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_STATS:\n+    priv->file_stats =\n+      *static_cast<std::shared_ptr<arrow::fs::FileStats> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_get_property(GObject *object,\n+                               guint prop_id,\n+                               GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_init(GArrowFileStats *object)\n+{\n+}\n+\n+static void\n+garrow_file_stats_class_init(GArrowFileStatsClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_stats_finalize;\n+  gobject_class->set_property = garrow_file_stats_set_property;\n+  gobject_class->get_property = garrow_file_stats_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_stats\",\n+                              \"FileStats\",\n+                              \"The raw std::shared<arrow::fs::FileStats> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_STATS, spec);\n+}\n+\n+/**\n+ * garrow_file_stats_new:\n+ *\n+ * Returns: A newly created #GArrowFileStats.\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_stats_new(void)\n+{\n+  auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>();\n+  return garrow_file_stats_new_raw(&arrow_file_stats);\n+}\n+\n+/**\n+ * garrow_file_stats_equal:\n+ * @file_stats: A #GArrowFileStats.\n+ * @other_file_stats: A #GArrowFileStats to be compared.\n+ *\n+ * Returns: %TRUE if both of them have the same data, %FALSE\n+ *   otherwise.\n+ *\n+ * Since: 1.0.0\n+ */\n+gboolean\n+garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                        GArrowFileStats *other_file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto arrow_other_file_stats = garrow_file_stats_get_raw(other_file_stats);\n+  return arrow_file_stats->Equals(*arrow_other_file_stats);\n+}\n+\n+GArrowFileType\n+garrow_file_stats_get_file_type(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return (GArrowFileType)arrow_file_stats->type();\n+}\n+\n+void\n+garrow_file_stats_set_file_type(GArrowFileStats *file_stats,\n+                                GArrowFileType file_type)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_type(arrow::fs::FileType(file_type));\n+}\n+\n+gboolean\n+garrow_file_stats_is_file(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsFile();\n+}\n+\n+gboolean\n+garrow_file_stats_is_directory(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsDirectory();\n+}\n+\n+const gchar *\n+garrow_file_stats_get_path(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->path().c_str();\n+}\n+\n+void\n+garrow_file_stats_set_path(GArrowFileStats *file_stats,\n+                           const gchar *path)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_path(path);\n+}\n+\n+gchar *\n+garrow_file_stats_get_base_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto base_name = std::move(arrow_file_stats->base_name());\n+  return g_strndup(base_name.c_str(), base_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_dir_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto dir_name = std::move(arrow_file_stats->dir_name());\n+  return g_strndup(dir_name.c_str(), dir_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_extension(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto extension = std::move(arrow_file_stats->extension());\n+  return g_strndup(extension.c_str(), extension.size());\n+}\n+\n+gint64\n+garrow_file_stats_get_size(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->size();\n+}\n+\n+void\n+garrow_file_stats_set_size(GArrowFileStats *file_stats,\n+                           gint64 size)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_size(size);\n+}\n+\n+GArrowTimePoint\n+garrow_file_stats_get_mtime(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto mtime = arrow_file_stats->mtime();\n+  return mtime.time_since_epoch().count();\n+}\n+\n+void\n+garrow_file_stats_set_mtime(GArrowFileStats *file_stats,\n+                            GArrowTimePoint mtime)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow::fs::TimePoint::duration duration(mtime);\n+  arrow_file_stats->set_mtime(arrow::fs::TimePoint(duration));\n+}\n+\n+/* arrow::fs::FileSelector */\n+\n+typedef struct GArrowFileSelectorPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSelector> file_selector;\n+} GArrowFileSelectorPrivate;\n+\n+enum {\n+  PROP_FILE_SELECTOR = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileSelector, garrow_file_selector, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SELECTOR_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSelectorPrivate *>(          \\\n+     garrow_file_selector_get_instance_private(       \\\n+       GARROW_FILE_SELECTOR(obj)))\n+\n+static void\n+garrow_file_selector_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  priv->file_selector = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_selector_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_selector_set_property(GObject *object,\n+                                  guint prop_id,\n+                                  const GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SELECTOR:\n+    priv->file_selector =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSelector> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_get_property(GObject *object,\n+                                  guint prop_id,\n+                                  GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_init(GArrowFileSelector *object)\n+{\n+}\n+\n+static void\n+garrow_file_selector_class_init(GArrowFileSelectorClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_selector_finalize;\n+  gobject_class->set_property = garrow_file_selector_set_property;\n+  gobject_class->get_property = garrow_file_selector_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_selector\",\n+                              \"FileSelector\",\n+                              \"The raw std::shared<arrow::fs::FileSelector> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SELECTOR, spec);\n+}\n+\n+const gchar *\n+garrow_file_selector_get_base_dir(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->base_dir.c_str();\n+}\n+\n+void\n+garrow_file_selector_set_base_dir(GArrowFileSelector *file_selector,\n+                                  const gchar *base_dir)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->base_dir.assign(base_dir);\n+}\n+\n+gboolean\n+garrow_file_selector_get_allow_non_existent(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->allow_non_existent;\n+}\n+\n+void\n+garrow_file_selector_set_allow_non_existent(GArrowFileSelector *file_selector,\n+                                            gboolean allow_non_existent)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->allow_non_existent = allow_non_existent;\n+}\n+\n+gboolean\n+garrow_file_selector_get_recursive(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->recursive;\n+}\n+\n+void\n+garrow_file_selector_set_recursive(GArrowFileSelector *file_selector,\n+                                   gboolean recursive)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->recursive = recursive;\n+}\n+\n+gint32\n+garrow_file_selector_get_max_recursion(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->max_recursion;\n+}\n+\n+void\n+garrow_file_selector_set_max_recursion(GArrowFileSelector *file_selector,\n+                                       gint32 max_recursion)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->max_recursion = max_recursion;\n+}\n+\n+\n+/* arrow::fs::FileSystem */\n+\n+typedef struct GArrowFileSystemPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSystem> file_system;\n+} GArrowFileSystemPrivate;\n+\n+enum {\n+  PROP_FILE_SYSTEM = 1\n+};\n+\n+G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE(GArrowFileSystem,\n+                                    garrow_file_system,\n+                                    G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SYSTEM_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSystemPrivate *>(          \\\n+     garrow_file_system_get_instance_private(       \\\n+       GARROW_FILE_SYSTEM(obj)))\n+\n+static void\n+garrow_file_system_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SYSTEM_GET_PRIVATE(object);\n+\n+  priv->file_system = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_system_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_system_set_property(GObject *object,\n+                                guint prop_id,\n+                                const GValue *value,\n+                                GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SYSTEM_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SYSTEM:\n+    priv->file_system =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSystem> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_system_get_property(GObject *object,\n+                                guint prop_id,\n+                                GValue *value,\n+                                GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_system_init(GArrowFileSystem *object)\n+{\n+}\n+\n+static void\n+garrow_file_system_class_init(GArrowFileSystemClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_system_finalize;\n+  gobject_class->set_property = garrow_file_system_set_property;\n+  gobject_class->get_property = garrow_file_system_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_system\",\n+                              \"FileSystem\",\n+                              \"The raw std::shared<arrow::fs::FileSystem> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SYSTEM, spec);\n+}\n+\n+/**\n+ * garrow_file_system_get_type_name:\n+ * @file_system: A #GArrowFileSystem.\n+ *\n+ * Returns: The name of file system type.\n+ *\n+ * Since: 1.0.0\n+ */\n+const gchar *\n+garrow_file_system_get_type_name(GArrowFileSystem *file_system)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  return arrow_file_system->type_name().c_str();\n+}\n+\n+/**\n+ * garrow_file_system_get_target_stats:\n+ * @file_system: A #GArrowFileSystem.\n+ * @path: The path of the target.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Get statistics for the given target.\n+ *\n+ * Any symlink is automatically dereferenced, recursively.\n+ * A non-existing or unreachable file returns an OK status and has\n+ * a #GArrowFileType of value %GARROW_FILE_TYPE_NON_EXISTENT.\n+ * An error status indicates a truly exceptional condition\n+ * (low-level I/O error, etc.).\n+ *\n+ * Returns: (nullable) (transfer full): A #GArrowFileStats\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_system_get_target_stats(GArrowFileSystem *file_system,\n+                                    const gchar *path,\n+                                    GError **error)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  auto arrow_result = arrow_file_system->GetTargetStats(path);\n+  if (garrow::check(error, arrow_result, \"[filesystem][get_target_stats]\")) {\n+    auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>(arrow_result.ValueOrDie());\n+    return garrow_file_stats_new_raw(&arrow_file_stats);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+namespace {\n \n Review comment:\n   How about using `static` instead of anonymous namespace (without indent) only for one internal function?\r\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:56.310+0000",
                    "updated": "2019-12-28T02:18:56.310+0000",
                    "started": "2019-12-28T02:18:56.309+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364102",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/364103",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r361770881\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.cpp\n ##########\n @@ -0,0 +1,1050 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#include <arrow-glib/error.hpp>\n+#include <arrow-glib/file-system.hpp>\n+#include <arrow-glib/input-stream.hpp>\n+#include <arrow-glib/output-stream.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: file-system\n+ * @section_id: file-system-classes\n+ * @title: File system classes\n+ * @include: arrow-glib/arrow-glib.h\n+ *\n+ * #GArrowFileStats is a class for a stats of file system entry.\n+ *\n+ * #GArrowFileSelector is a class for a selector for filesystem APIs.\n+ *\n+ * #GArrowFileSystem is an interface for file system.\n+ *\n+ * #GArrowSubTreeFileSystem is a delegator to another file system that is\n+ * a logical view of a subtree of a file system, such as a directory in\n+ * a local file system.\n+ *\n+ * #GArrowSlowFileSystem is a delegator to another file system.\n+ * This inserts latencies at various points.\n+ *\n+ * #GArrowLocalFileSystem is a class for an implementation of a file system\n+ * that accesses files on the local machine.\n+ */\n+\n+/* arrow::fs::FileStats */\n+\n+typedef struct GArrowFileStatsPrivate_ {\n+  std::shared_ptr<arrow::fs::FileStats> file_stats;\n+} GArrowFileStatsPrivate;\n+\n+enum {\n+  PROP_FILE_STATS = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileStats, garrow_file_stats, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_STATS_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileStatsPrivate *>(          \\\n+     garrow_file_stats_get_instance_private(       \\\n+       GARROW_FILE_STATS(obj)))\n+\n+static void\n+garrow_file_stats_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  priv->file_stats = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_stats_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_stats_set_property(GObject *object,\n+                               guint prop_id,\n+                               const GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_STATS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_STATS:\n+    priv->file_stats =\n+      *static_cast<std::shared_ptr<arrow::fs::FileStats> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_get_property(GObject *object,\n+                               guint prop_id,\n+                               GValue *value,\n+                               GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_stats_init(GArrowFileStats *object)\n+{\n+}\n+\n+static void\n+garrow_file_stats_class_init(GArrowFileStatsClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_stats_finalize;\n+  gobject_class->set_property = garrow_file_stats_set_property;\n+  gobject_class->get_property = garrow_file_stats_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_stats\",\n+                              \"FileStats\",\n+                              \"The raw std::shared<arrow::fs::FileStats> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_STATS, spec);\n+}\n+\n+/**\n+ * garrow_file_stats_new:\n+ *\n+ * Returns: A newly created #GArrowFileStats.\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_stats_new(void)\n+{\n+  auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>();\n+  return garrow_file_stats_new_raw(&arrow_file_stats);\n+}\n+\n+/**\n+ * garrow_file_stats_equal:\n+ * @file_stats: A #GArrowFileStats.\n+ * @other_file_stats: A #GArrowFileStats to be compared.\n+ *\n+ * Returns: %TRUE if both of them have the same data, %FALSE\n+ *   otherwise.\n+ *\n+ * Since: 1.0.0\n+ */\n+gboolean\n+garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                        GArrowFileStats *other_file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto arrow_other_file_stats = garrow_file_stats_get_raw(other_file_stats);\n+  return arrow_file_stats->Equals(*arrow_other_file_stats);\n+}\n+\n+GArrowFileType\n+garrow_file_stats_get_file_type(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return (GArrowFileType)arrow_file_stats->type();\n+}\n+\n+void\n+garrow_file_stats_set_file_type(GArrowFileStats *file_stats,\n+                                GArrowFileType file_type)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_type(arrow::fs::FileType(file_type));\n+}\n+\n+gboolean\n+garrow_file_stats_is_file(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsFile();\n+}\n+\n+gboolean\n+garrow_file_stats_is_directory(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->IsDirectory();\n+}\n+\n+const gchar *\n+garrow_file_stats_get_path(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->path().c_str();\n+}\n+\n+void\n+garrow_file_stats_set_path(GArrowFileStats *file_stats,\n+                           const gchar *path)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_path(path);\n+}\n+\n+gchar *\n+garrow_file_stats_get_base_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto base_name = std::move(arrow_file_stats->base_name());\n+  return g_strndup(base_name.c_str(), base_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_dir_name(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto dir_name = std::move(arrow_file_stats->dir_name());\n+  return g_strndup(dir_name.c_str(), dir_name.size());\n+}\n+\n+gchar *\n+garrow_file_stats_get_extension(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto extension = std::move(arrow_file_stats->extension());\n+  return g_strndup(extension.c_str(), extension.size());\n+}\n+\n+gint64\n+garrow_file_stats_get_size(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  return arrow_file_stats->size();\n+}\n+\n+void\n+garrow_file_stats_set_size(GArrowFileStats *file_stats,\n+                           gint64 size)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow_file_stats->set_size(size);\n+}\n+\n+GArrowTimePoint\n+garrow_file_stats_get_mtime(GArrowFileStats *file_stats)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  auto mtime = arrow_file_stats->mtime();\n+  return mtime.time_since_epoch().count();\n+}\n+\n+void\n+garrow_file_stats_set_mtime(GArrowFileStats *file_stats,\n+                            GArrowTimePoint mtime)\n+{\n+  auto arrow_file_stats = garrow_file_stats_get_raw(file_stats);\n+  arrow::fs::TimePoint::duration duration(mtime);\n+  arrow_file_stats->set_mtime(arrow::fs::TimePoint(duration));\n+}\n+\n+/* arrow::fs::FileSelector */\n+\n+typedef struct GArrowFileSelectorPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSelector> file_selector;\n+} GArrowFileSelectorPrivate;\n+\n+enum {\n+  PROP_FILE_SELECTOR = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GArrowFileSelector, garrow_file_selector, G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SELECTOR_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSelectorPrivate *>(          \\\n+     garrow_file_selector_get_instance_private(       \\\n+       GARROW_FILE_SELECTOR(obj)))\n+\n+static void\n+garrow_file_selector_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  priv->file_selector = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_selector_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_selector_set_property(GObject *object,\n+                                  guint prop_id,\n+                                  const GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SELECTOR_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SELECTOR:\n+    priv->file_selector =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSelector> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_get_property(GObject *object,\n+                                  guint prop_id,\n+                                  GValue *value,\n+                                  GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_selector_init(GArrowFileSelector *object)\n+{\n+}\n+\n+static void\n+garrow_file_selector_class_init(GArrowFileSelectorClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_selector_finalize;\n+  gobject_class->set_property = garrow_file_selector_set_property;\n+  gobject_class->get_property = garrow_file_selector_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_selector\",\n+                              \"FileSelector\",\n+                              \"The raw std::shared<arrow::fs::FileSelector> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SELECTOR, spec);\n+}\n+\n+const gchar *\n+garrow_file_selector_get_base_dir(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->base_dir.c_str();\n+}\n+\n+void\n+garrow_file_selector_set_base_dir(GArrowFileSelector *file_selector,\n+                                  const gchar *base_dir)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->base_dir.assign(base_dir);\n+}\n+\n+gboolean\n+garrow_file_selector_get_allow_non_existent(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->allow_non_existent;\n+}\n+\n+void\n+garrow_file_selector_set_allow_non_existent(GArrowFileSelector *file_selector,\n+                                            gboolean allow_non_existent)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->allow_non_existent = allow_non_existent;\n+}\n+\n+gboolean\n+garrow_file_selector_get_recursive(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->recursive;\n+}\n+\n+void\n+garrow_file_selector_set_recursive(GArrowFileSelector *file_selector,\n+                                   gboolean recursive)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->recursive = recursive;\n+}\n+\n+gint32\n+garrow_file_selector_get_max_recursion(GArrowFileSelector *file_selector)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  return arrow_file_selector->max_recursion;\n+}\n+\n+void\n+garrow_file_selector_set_max_recursion(GArrowFileSelector *file_selector,\n+                                       gint32 max_recursion)\n+{\n+  auto arrow_file_selector = garrow_file_selector_get_raw(file_selector);\n+  arrow_file_selector->max_recursion = max_recursion;\n+}\n+\n+\n+/* arrow::fs::FileSystem */\n+\n+typedef struct GArrowFileSystemPrivate_ {\n+  std::shared_ptr<arrow::fs::FileSystem> file_system;\n+} GArrowFileSystemPrivate;\n+\n+enum {\n+  PROP_FILE_SYSTEM = 1\n+};\n+\n+G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE(GArrowFileSystem,\n+                                    garrow_file_system,\n+                                    G_TYPE_OBJECT)\n+\n+#define GARROW_FILE_SYSTEM_GET_PRIVATE(obj)         \\\n+  static_cast<GArrowFileSystemPrivate *>(          \\\n+     garrow_file_system_get_instance_private(       \\\n+       GARROW_FILE_SYSTEM(obj)))\n+\n+static void\n+garrow_file_system_finalize(GObject *object)\n+{\n+  auto priv = GARROW_FILE_SYSTEM_GET_PRIVATE(object);\n+\n+  priv->file_system = nullptr;\n+\n+  G_OBJECT_CLASS(garrow_file_system_parent_class)->finalize(object);\n+}\n+\n+static void\n+garrow_file_system_set_property(GObject *object,\n+                                guint prop_id,\n+                                const GValue *value,\n+                                GParamSpec *pspec)\n+{\n+  auto priv = GARROW_FILE_SYSTEM_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_FILE_SYSTEM:\n+    priv->file_system =\n+      *static_cast<std::shared_ptr<arrow::fs::FileSystem> *>(g_value_get_pointer(value));\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_system_get_property(GObject *object,\n+                                guint prop_id,\n+                                GValue *value,\n+                                GParamSpec *pspec)\n+{\n+  switch (prop_id) {\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+garrow_file_system_init(GArrowFileSystem *object)\n+{\n+}\n+\n+static void\n+garrow_file_system_class_init(GArrowFileSystemClass *klass)\n+{\n+  GParamSpec *spec;\n+\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->finalize     = garrow_file_system_finalize;\n+  gobject_class->set_property = garrow_file_system_set_property;\n+  gobject_class->get_property = garrow_file_system_get_property;\n+\n+  spec = g_param_spec_pointer(\"file_system\",\n+                              \"FileSystem\",\n+                              \"The raw std::shared<arrow::fs::FileSystem> *\",\n+                              static_cast<GParamFlags>(G_PARAM_WRITABLE |\n+                                                       G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_FILE_SYSTEM, spec);\n+}\n+\n+/**\n+ * garrow_file_system_get_type_name:\n+ * @file_system: A #GArrowFileSystem.\n+ *\n+ * Returns: The name of file system type.\n+ *\n+ * Since: 1.0.0\n+ */\n+const gchar *\n+garrow_file_system_get_type_name(GArrowFileSystem *file_system)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  return arrow_file_system->type_name().c_str();\n+}\n+\n+/**\n+ * garrow_file_system_get_target_stats:\n+ * @file_system: A #GArrowFileSystem.\n+ * @path: The path of the target.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Get statistics for the given target.\n+ *\n+ * Any symlink is automatically dereferenced, recursively.\n+ * A non-existing or unreachable file returns an OK status and has\n+ * a #GArrowFileType of value %GARROW_FILE_TYPE_NON_EXISTENT.\n+ * An error status indicates a truly exceptional condition\n+ * (low-level I/O error, etc.).\n+ *\n+ * Returns: (nullable) (transfer full): A #GArrowFileStats\n+ *\n+ * Since: 1.0.0\n+ */\n+GArrowFileStats *\n+garrow_file_system_get_target_stats(GArrowFileSystem *file_system,\n+                                    const gchar *path,\n+                                    GError **error)\n+{\n+  auto arrow_file_system = garrow_file_system_get_raw(file_system);\n+  auto arrow_result = arrow_file_system->GetTargetStats(path);\n+  if (garrow::check(error, arrow_result, \"[filesystem][get_target_stats]\")) {\n+    auto arrow_file_stats = std::make_shared<arrow::fs::FileStats>(arrow_result.ValueOrDie());\n+    return garrow_file_stats_new_raw(&arrow_file_stats);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+namespace {\n+\n+inline GList *\n+garrow_file_stats_list_from_result(arrow::Result<std::vector<arrow::fs::FileStats>>&& arrow_result,\n+                                   GError **error,\n+                                   const gchar *context)\n+{\n+  if (garrow::check(error, arrow_result, context)) {\n+    auto arrow_file_stats_vector = arrow_result.ValueOrDie();\n+    GList *file_stats_list = NULL;\n+    for (auto arrow_file_stats : arrow_file_stats_vector) {\n+      auto arrow_file_stats_ptr = std::make_shared<decltype(arrow_file_stats)>(arrow_file_stats);\n+      auto file_stats = garrow_file_stats_new_raw(&arrow_file_stats_ptr);\n+      file_stats_list = g_list_prepend(file_stats_list, file_stats);\n+    }\n+    return g_list_reverse(file_stats_list);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+}\n+\n+/**\n+ * garrow_file_system_get_target_stats_list:\n+ * @file_system: A #GArrowFileSystem.\n+ * @paths: The paths of the targets.\n+ * @n_paths: The number of items in @paths.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Get statistics same as garrow_file_system_get_target_stats() for the\n+ * given many targets at once.\n+ *\n+ * Returns: (element-type GArrowFileStats) (transfer full):\n+ *   A list of #GArrowFileStats\n+ *\n+ * Since: 1.0.0\n+ */\n+GList *\n+garrow_file_system_get_target_stats_list(GArrowFileSystem *file_system,\n \n Review comment:\n   We use suffix for function name that has some variants like `garrow_decimal128_new_string()` and `garrow_decimal128_new_integer()`.\r\n   How about `garrow_file_system_get_target_stats_paths()`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-28T02:18:56.336+0000",
                    "updated": "2019-12-28T02:18:56.336+0000",
                    "started": "2019-12-28T02:18:56.336+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "364103",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/374857",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mrkn commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r368884742\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.h\n ##########\n @@ -0,0 +1,236 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#pragma once\n+\n+#include <glib-object.h>\n+\n+#include <arrow-glib/input-stream.h>\n+#include <arrow-glib/output-stream.h>\n+#include <arrow-glib/version.h>\n+\n+G_BEGIN_DECLS\n+\n+/* arrow::fs::TimePoint */\n+typedef gint64 GArrowTimePoint;\n+\n+/* arrow::fs::FileType */\n+\n+/**\n+ * GArrowFileType\n+ * @GARROW_FILE_TYPE_NON_EXISTENT: Entry does not exist\n+ * @GARROW_FILE_TYPE_UNKNOWN: Entry exists but its type is unknown\n+ * @GARROW_FILE_TYPE_FILE: Entry is a regular file\n+ * @GARROW_FILE_TYPE_DIRECTORY: Entry is a directory\n+ *\n+ * They are corresponding to `arrow::fs::FileType` values.\n+ */\n+typedef enum {\n+  GARROW_FILE_TYPE_NON_EXISTENT,\n+  GARROW_FILE_TYPE_UNKNOWN,\n+  GARROW_FILE_TYPE_FILE,\n+  GARROW_FILE_TYPE_DIRECTORY\n+} GArrowFileType;\n+\n+\n+/* arrow::fs::FileStats */\n+\n+#define GARROW_TYPE_FILE_STATS (garrow_file_stats_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFileStats,\n+                         garrow_file_stats,\n+                         GARROW,\n+                         FILE_STATS,\n+                         GObject)\n+struct _GArrowFileStatsClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+GARROW_AVAILABLE_IN_1_0\n+GArrowFileStats *garrow_file_stats_new(void);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                                 GArrowFileStats *other_file_stats);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_stats_is_file(GArrowFileStats *file_stats);\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_stats_is_directory(GArrowFileStats *file_stats);\n+\n+/* arrow::fs::FileSelector */\n+\n+#define GARROW_TYPE_FILE_SELECTOR (garrow_file_selector_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFileSelector,\n+                         garrow_file_selector,\n+                         GARROW,\n+                         FILE_SELECTOR,\n+                         GObject)\n+struct _GArrowFileSelectorClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+/* arrow::fs::FileSystem */\n+\n+#define GARROW_TYPE_FILE_SYSTEM (garrow_file_system_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFileSystem,\n+                         garrow_file_system,\n+                         GARROW,\n+                         FILE_SYSTEM,\n+                         GObject)\n+struct _GArrowFileSystemClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+GARROW_AVAILABLE_IN_1_0\n+const gchar *garrow_file_system_get_type_name(GArrowFileSystem *file_system);\n+\n+GARROW_AVAILABLE_IN_1_0\n+GArrowFileStats *garrow_file_system_get_target_stats_path(GArrowFileSystem *file_system,\n+                                                          const gchar *path,\n+                                                          GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+GList *garrow_file_system_get_target_stats_paths(GArrowFileSystem *file_system,\n+                                                 const gchar **paths,\n+                                                 gsize n_paths,\n+                                                 GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+GList *garrow_file_system_get_target_stats_selector(GArrowFileSystem *file_system,\n+                                                    GArrowFileSelector *file_selector,\n+                                                    GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_create_dir(GArrowFileSystem *file_system,\n+                                       const gchar *path,\n+                                       gboolean recursive,\n+                                       GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_delete_dir(GArrowFileSystem *file_system,\n+                                       const gchar *path,\n+                                       GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_delete_dir_contents(GArrowFileSystem *file_system,\n+                                                const gchar *path,\n+                                                GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_delete_file(GArrowFileSystem *file_system,\n+                                        const gchar *path,\n+                                        GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_delete_files(GArrowFileSystem *file_system,\n+                                        const gchar **paths,\n \n Review comment:\n   @kou Should we use `GList *` for the type of `paths` here because this function cannot be called from Ruby due to ArgumentError?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-21T09:16:56.012+0000",
                    "updated": "2020-01-21T09:16:56.012+0000",
                    "started": "2020-01-21T09:16:56.011+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "374857",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/374859",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mrkn commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r368885086\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.h\n ##########\n @@ -0,0 +1,236 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#pragma once\n+\n+#include <glib-object.h>\n+\n+#include <arrow-glib/input-stream.h>\n+#include <arrow-glib/output-stream.h>\n+#include <arrow-glib/version.h>\n+\n+G_BEGIN_DECLS\n+\n+/* arrow::fs::TimePoint */\n+typedef gint64 GArrowTimePoint;\n+\n+/* arrow::fs::FileType */\n+\n+/**\n+ * GArrowFileType\n+ * @GARROW_FILE_TYPE_NON_EXISTENT: Entry does not exist\n+ * @GARROW_FILE_TYPE_UNKNOWN: Entry exists but its type is unknown\n+ * @GARROW_FILE_TYPE_FILE: Entry is a regular file\n+ * @GARROW_FILE_TYPE_DIRECTORY: Entry is a directory\n+ *\n+ * They are corresponding to `arrow::fs::FileType` values.\n+ */\n+typedef enum {\n+  GARROW_FILE_TYPE_NON_EXISTENT,\n+  GARROW_FILE_TYPE_UNKNOWN,\n+  GARROW_FILE_TYPE_FILE,\n+  GARROW_FILE_TYPE_DIRECTORY\n+} GArrowFileType;\n+\n+\n+/* arrow::fs::FileStats */\n+\n+#define GARROW_TYPE_FILE_STATS (garrow_file_stats_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFileStats,\n+                         garrow_file_stats,\n+                         GARROW,\n+                         FILE_STATS,\n+                         GObject)\n+struct _GArrowFileStatsClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+GARROW_AVAILABLE_IN_1_0\n+GArrowFileStats *garrow_file_stats_new(void);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                                 GArrowFileStats *other_file_stats);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_stats_is_file(GArrowFileStats *file_stats);\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_stats_is_directory(GArrowFileStats *file_stats);\n+\n+/* arrow::fs::FileSelector */\n+\n+#define GARROW_TYPE_FILE_SELECTOR (garrow_file_selector_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFileSelector,\n+                         garrow_file_selector,\n+                         GARROW,\n+                         FILE_SELECTOR,\n+                         GObject)\n+struct _GArrowFileSelectorClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+/* arrow::fs::FileSystem */\n+\n+#define GARROW_TYPE_FILE_SYSTEM (garrow_file_system_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFileSystem,\n+                         garrow_file_system,\n+                         GARROW,\n+                         FILE_SYSTEM,\n+                         GObject)\n+struct _GArrowFileSystemClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+GARROW_AVAILABLE_IN_1_0\n+const gchar *garrow_file_system_get_type_name(GArrowFileSystem *file_system);\n+\n+GARROW_AVAILABLE_IN_1_0\n+GArrowFileStats *garrow_file_system_get_target_stats_path(GArrowFileSystem *file_system,\n+                                                          const gchar *path,\n+                                                          GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+GList *garrow_file_system_get_target_stats_paths(GArrowFileSystem *file_system,\n+                                                 const gchar **paths,\n \n Review comment:\n   There is the same issue as `garrow_file_system_delete_files` here.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-21T09:17:43.235+0000",
                    "updated": "2020-01-21T09:17:43.235+0000",
                    "started": "2020-01-21T09:17:43.235+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "374859",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/374868",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r368887179\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.h\n ##########\n @@ -0,0 +1,236 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#pragma once\n+\n+#include <glib-object.h>\n+\n+#include <arrow-glib/input-stream.h>\n+#include <arrow-glib/output-stream.h>\n+#include <arrow-glib/version.h>\n+\n+G_BEGIN_DECLS\n+\n+/* arrow::fs::TimePoint */\n+typedef gint64 GArrowTimePoint;\n+\n+/* arrow::fs::FileType */\n+\n+/**\n+ * GArrowFileType\n+ * @GARROW_FILE_TYPE_NON_EXISTENT: Entry does not exist\n+ * @GARROW_FILE_TYPE_UNKNOWN: Entry exists but its type is unknown\n+ * @GARROW_FILE_TYPE_FILE: Entry is a regular file\n+ * @GARROW_FILE_TYPE_DIRECTORY: Entry is a directory\n+ *\n+ * They are corresponding to `arrow::fs::FileType` values.\n+ */\n+typedef enum {\n+  GARROW_FILE_TYPE_NON_EXISTENT,\n+  GARROW_FILE_TYPE_UNKNOWN,\n+  GARROW_FILE_TYPE_FILE,\n+  GARROW_FILE_TYPE_DIRECTORY\n+} GArrowFileType;\n+\n+\n+/* arrow::fs::FileStats */\n+\n+#define GARROW_TYPE_FILE_STATS (garrow_file_stats_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFileStats,\n+                         garrow_file_stats,\n+                         GARROW,\n+                         FILE_STATS,\n+                         GObject)\n+struct _GArrowFileStatsClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+GARROW_AVAILABLE_IN_1_0\n+GArrowFileStats *garrow_file_stats_new(void);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                                 GArrowFileStats *other_file_stats);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_stats_is_file(GArrowFileStats *file_stats);\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_stats_is_directory(GArrowFileStats *file_stats);\n+\n+/* arrow::fs::FileSelector */\n+\n+#define GARROW_TYPE_FILE_SELECTOR (garrow_file_selector_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFileSelector,\n+                         garrow_file_selector,\n+                         GARROW,\n+                         FILE_SELECTOR,\n+                         GObject)\n+struct _GArrowFileSelectorClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+/* arrow::fs::FileSystem */\n+\n+#define GARROW_TYPE_FILE_SYSTEM (garrow_file_system_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFileSystem,\n+                         garrow_file_system,\n+                         GARROW,\n+                         FILE_SYSTEM,\n+                         GObject)\n+struct _GArrowFileSystemClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+GARROW_AVAILABLE_IN_1_0\n+const gchar *garrow_file_system_get_type_name(GArrowFileSystem *file_system);\n+\n+GARROW_AVAILABLE_IN_1_0\n+GArrowFileStats *garrow_file_system_get_target_stats_path(GArrowFileSystem *file_system,\n+                                                          const gchar *path,\n+                                                          GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+GList *garrow_file_system_get_target_stats_paths(GArrowFileSystem *file_system,\n+                                                 const gchar **paths,\n+                                                 gsize n_paths,\n+                                                 GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+GList *garrow_file_system_get_target_stats_selector(GArrowFileSystem *file_system,\n+                                                    GArrowFileSelector *file_selector,\n+                                                    GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_create_dir(GArrowFileSystem *file_system,\n+                                       const gchar *path,\n+                                       gboolean recursive,\n+                                       GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_delete_dir(GArrowFileSystem *file_system,\n+                                       const gchar *path,\n+                                       GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_delete_dir_contents(GArrowFileSystem *file_system,\n+                                                const gchar *path,\n+                                                GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_delete_file(GArrowFileSystem *file_system,\n+                                        const gchar *path,\n+                                        GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_delete_files(GArrowFileSystem *file_system,\n+                                        const gchar **paths,\n \n Review comment:\n   `(array length=n_paths)` annotation is missing for `@paths`.\r\n   See `garrow_csv_read_options_set_null_values()` documentation for details.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-21T09:21:52.243+0000",
                    "updated": "2020-01-21T09:21:52.243+0000",
                    "started": "2020-01-21T09:21:52.243+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "374868",
                    "issueId": "13275671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/worklog/374872",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mrkn commented on pull request #6105: ARROW-7444: [GLib] Add LocalFileSystem support\nURL: https://github.com/apache/arrow/pull/6105#discussion_r368889671\n \n \n\n ##########\n File path: c_glib/arrow-glib/file-system.h\n ##########\n @@ -0,0 +1,236 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#pragma once\n+\n+#include <glib-object.h>\n+\n+#include <arrow-glib/input-stream.h>\n+#include <arrow-glib/output-stream.h>\n+#include <arrow-glib/version.h>\n+\n+G_BEGIN_DECLS\n+\n+/* arrow::fs::TimePoint */\n+typedef gint64 GArrowTimePoint;\n+\n+/* arrow::fs::FileType */\n+\n+/**\n+ * GArrowFileType\n+ * @GARROW_FILE_TYPE_NON_EXISTENT: Entry does not exist\n+ * @GARROW_FILE_TYPE_UNKNOWN: Entry exists but its type is unknown\n+ * @GARROW_FILE_TYPE_FILE: Entry is a regular file\n+ * @GARROW_FILE_TYPE_DIRECTORY: Entry is a directory\n+ *\n+ * They are corresponding to `arrow::fs::FileType` values.\n+ */\n+typedef enum {\n+  GARROW_FILE_TYPE_NON_EXISTENT,\n+  GARROW_FILE_TYPE_UNKNOWN,\n+  GARROW_FILE_TYPE_FILE,\n+  GARROW_FILE_TYPE_DIRECTORY\n+} GArrowFileType;\n+\n+\n+/* arrow::fs::FileStats */\n+\n+#define GARROW_TYPE_FILE_STATS (garrow_file_stats_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFileStats,\n+                         garrow_file_stats,\n+                         GARROW,\n+                         FILE_STATS,\n+                         GObject)\n+struct _GArrowFileStatsClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+GARROW_AVAILABLE_IN_1_0\n+GArrowFileStats *garrow_file_stats_new(void);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_stats_equal(GArrowFileStats *file_stats,\n+                                 GArrowFileStats *other_file_stats);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_stats_is_file(GArrowFileStats *file_stats);\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_stats_is_directory(GArrowFileStats *file_stats);\n+\n+/* arrow::fs::FileSelector */\n+\n+#define GARROW_TYPE_FILE_SELECTOR (garrow_file_selector_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFileSelector,\n+                         garrow_file_selector,\n+                         GARROW,\n+                         FILE_SELECTOR,\n+                         GObject)\n+struct _GArrowFileSelectorClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+/* arrow::fs::FileSystem */\n+\n+#define GARROW_TYPE_FILE_SYSTEM (garrow_file_system_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GArrowFileSystem,\n+                         garrow_file_system,\n+                         GARROW,\n+                         FILE_SYSTEM,\n+                         GObject)\n+struct _GArrowFileSystemClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+GARROW_AVAILABLE_IN_1_0\n+const gchar *garrow_file_system_get_type_name(GArrowFileSystem *file_system);\n+\n+GARROW_AVAILABLE_IN_1_0\n+GArrowFileStats *garrow_file_system_get_target_stats_path(GArrowFileSystem *file_system,\n+                                                          const gchar *path,\n+                                                          GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+GList *garrow_file_system_get_target_stats_paths(GArrowFileSystem *file_system,\n+                                                 const gchar **paths,\n+                                                 gsize n_paths,\n+                                                 GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+GList *garrow_file_system_get_target_stats_selector(GArrowFileSystem *file_system,\n+                                                    GArrowFileSelector *file_selector,\n+                                                    GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_create_dir(GArrowFileSystem *file_system,\n+                                       const gchar *path,\n+                                       gboolean recursive,\n+                                       GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_delete_dir(GArrowFileSystem *file_system,\n+                                       const gchar *path,\n+                                       GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_delete_dir_contents(GArrowFileSystem *file_system,\n+                                                const gchar *path,\n+                                                GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_delete_file(GArrowFileSystem *file_system,\n+                                        const gchar *path,\n+                                        GError **error);\n+\n+GARROW_AVAILABLE_IN_1_0\n+gboolean garrow_file_system_delete_files(GArrowFileSystem *file_system,\n+                                        const gchar **paths,\n \n Review comment:\n   Resolved.  Thank you very much!\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-21T09:27:05.538+0000",
                    "updated": "2020-01-21T09:27:05.538+0000",
                    "started": "2020-01-21T09:27:05.538+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "374872",
                    "issueId": "13275671"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 33000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@643d3294[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@41a7df4c[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3dae3c9c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@420cd9da[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@171cf749[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@77faaa68[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3bfc32d7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@1f9afe7b[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6f4cf47e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@4d47aa15[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@17f743e0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@5fd61e43[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 33000,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Mar 07 09:37:42 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-03-07T09:37:42.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-7444/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2019-12-20T07:45:37.000+0000",
        "updated": "2020-03-07T09:37:42.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "9h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 33000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[GLib] Add LocalFileSystem support",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13275671/comment/17053957",
                    "id": "17053957",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
                        "name": "kou",
                        "key": "kou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
                        },
                        "displayName": "Kouhei Sutou",
                        "active": true,
                        "timeZone": "Asia/Tokyo"
                    },
                    "body": "Issue resolved by pull request 6105\n[https://github.com/apache/arrow/pull/6105]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
                        "name": "kou",
                        "key": "kou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
                        },
                        "displayName": "Kouhei Sutou",
                        "active": true,
                        "timeZone": "Asia/Tokyo"
                    },
                    "created": "2020-03-07T09:37:42.174+0000",
                    "updated": "2020-03-07T09:37:42.174+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z09vgg:",
        "customfield_12314139": null
    }
}