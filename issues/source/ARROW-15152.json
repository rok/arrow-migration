{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13418478",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478",
    "key": "ARROW-15152",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351051",
                "id": "12351051",
                "description": "",
                "name": "8.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-05-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "good-second-issue",
            "kernel",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350712",
                "id": "12350712",
                "description": "",
                "name": "6.0.1",
                "archived": false,
                "released": true,
                "releaseDate": "2021-11-18"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=dhruv9vats",
            "name": "dhruv9vats",
            "key": "dhruv9vats",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34058",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34058",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34058",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34058"
            },
            "displayName": "Dhruv Vats",
            "active": true,
            "timeZone": "Asia/Kolkata"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=coady",
            "name": "coady",
            "key": "coady",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "A. Coady",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=coady",
            "name": "coady",
            "key": "coady",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "A. Coady",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 22800,
            "total": 22800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 22800,
            "total": 22800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15152/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 38,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/730696",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats opened a new pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484\n\n\n   `hash_list` gathers the grouped values into a list array.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-22T08:42:02.854+0000",
                    "updated": "2022-02-22T08:42:02.854+0000",
                    "started": "2022-02-22T08:42:02.854+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "730696",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/730697",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#issuecomment-1047552262\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-22T08:42:25.500+0000",
                    "updated": "2022-02-22T08:42:25.500+0000",
                    "started": "2022-02-22T08:42:25.500+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "730697",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/730804",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r811834476\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,318 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, CType val) -> Status {\n+          RETURN_NOT_OK(values_.Append(val));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(false));\n+          ++num_args_;\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    auto other_raw_values = other->values_.mutable_data();\n+    uint32_t* other_raw_groups = other->groups_.mutable_data();\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      if (bit_util::GetBit(other->values_bitmap_.data(), other_g)) {\n+        RETURN_NOT_OK(values_.Append(GetSet::Get(other_raw_values, other_g)));\n+        RETURN_NOT_OK(values_bitmap_.Append(true));\n+      } else {\n+        RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+        RETURN_NOT_OK(values_bitmap_.Append(false));\n+      }\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+      ++num_args_;\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto values_buffer, values_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data = ArrayData::Make(\n+        out_type_, num_args_, {std::move(null_bitmap_buffer), std::move(values_buffer)});\n+    auto values = MakeArray(values_array_data);\n\nReview comment:\n       What would be a more concise way to do this?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,318 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, CType val) -> Status {\n+          RETURN_NOT_OK(values_.Append(val));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(false));\n+          ++num_args_;\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    auto other_raw_values = other->values_.mutable_data();\n+    uint32_t* other_raw_groups = other->groups_.mutable_data();\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      if (bit_util::GetBit(other->values_bitmap_.data(), other_g)) {\n+        RETURN_NOT_OK(values_.Append(GetSet::Get(other_raw_values, other_g)));\n+        RETURN_NOT_OK(values_bitmap_.Append(true));\n+      } else {\n+        RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+        RETURN_NOT_OK(values_bitmap_.Append(false));\n+      }\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+      ++num_args_;\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto values_buffer, values_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data = ArrayData::Make(\n+        out_type_, num_args_, {std::move(null_bitmap_buffer), std::move(values_buffer)});\n+    auto values = MakeArray(values_array_data);\n+    return Grouper::ApplyGroupings(*groupings, *values);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return list(out_type_); }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_, num_args_ = 0;\n+  TypedBufferBuilder<CType> values_;\n+  TypedBufferBuilder<uint32_t> groups_;\n+  TypedBufferBuilder<bool> values_bitmap_;\n+  std::shared_ptr<DataType> out_type_;\n+};\n+\n+template <typename Type>\n+struct GroupedListImpl<Type, enable_if_t<is_base_binary_type<Type>::value ||\n+                                         std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  using Allocator = arrow::stl::allocator<char>;\n+  using StringType = std::basic_string<char, std::char_traits<char>, Allocator>;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    allocator_ = Allocator(ctx->memory_pool());\n+    // out_type_ initialized by GroupedListInit\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, util::string_view val) -> Status {\n+          values_.emplace_back(val);\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          values_.emplace_back(util::string_view{});\n\nReview comment:\n       Is this appropriate?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,318 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, CType val) -> Status {\n+          RETURN_NOT_OK(values_.Append(val));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(false));\n+          ++num_args_;\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    auto other_raw_values = other->values_.mutable_data();\n+    uint32_t* other_raw_groups = other->groups_.mutable_data();\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      if (bit_util::GetBit(other->values_bitmap_.data(), other_g)) {\n+        RETURN_NOT_OK(values_.Append(GetSet::Get(other_raw_values, other_g)));\n+        RETURN_NOT_OK(values_bitmap_.Append(true));\n+      } else {\n+        RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+        RETURN_NOT_OK(values_bitmap_.Append(false));\n+      }\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+      ++num_args_;\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto values_buffer, values_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data = ArrayData::Make(\n+        out_type_, num_args_, {std::move(null_bitmap_buffer), std::move(values_buffer)});\n+    auto values = MakeArray(values_array_data);\n+    return Grouper::ApplyGroupings(*groupings, *values);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return list(out_type_); }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_, num_args_ = 0;\n+  TypedBufferBuilder<CType> values_;\n+  TypedBufferBuilder<uint32_t> groups_;\n+  TypedBufferBuilder<bool> values_bitmap_;\n+  std::shared_ptr<DataType> out_type_;\n+};\n+\n+template <typename Type>\n+struct GroupedListImpl<Type, enable_if_t<is_base_binary_type<Type>::value ||\n+                                         std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  using Allocator = arrow::stl::allocator<char>;\n+  using StringType = std::basic_string<char, std::char_traits<char>, Allocator>;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    allocator_ = Allocator(ctx->memory_pool());\n+    // out_type_ initialized by GroupedListInit\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, util::string_view val) -> Status {\n+          values_.emplace_back(val);\n\nReview comment:\n       Have simply used `emplace_back` as opposed to `emplace` as used here:\r\n   https://github.com/apache/arrow/blob/5216c2bb3e4f9298230e2e38f29ff9889b5a152d/cpp/src/arrow/compute/kernels/hash_aggregate.cc#L1853\r\n   Is this valid or will something like resizing and then using `emplace` will have to be used? (As `allocator_` is not used explicitly in `emplace_back`)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-22T11:21:23.933+0000",
                    "updated": "2022-02-22T11:21:23.933+0000",
                    "started": "2022-02-22T11:21:23.933+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "730804",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/732270",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats commented on pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#issuecomment-1049832936\n\n\n   Will probably use something similar to `hash_count` for the `null` type. Is this the correct general direction @lidavidm ?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-24T12:58:13.789+0000",
                    "updated": "2022-02-24T12:58:13.789+0000",
                    "started": "2022-02-24T12:58:13.788+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "732270",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/732302",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#issuecomment-1049879462\n\n\n   For `null`, yes, you just need to count how many values were seen.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-24T13:50:08.578+0000",
                    "updated": "2022-02-24T13:50:08.578+0000",
                    "started": "2022-02-24T13:50:08.578+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "732302",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/732318",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r813900617\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,318 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, CType val) -> Status {\n+          RETURN_NOT_OK(values_.Append(val));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(false));\n+          ++num_args_;\n+          return Status::OK();\n\nReview comment:\n       The same goes here: is there a way to just concat the array's buffers with ours? Since we're dealing only with primitive types here?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,318 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, CType val) -> Status {\n+          RETURN_NOT_OK(values_.Append(val));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(false));\n+          ++num_args_;\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    auto other_raw_values = other->values_.mutable_data();\n+    uint32_t* other_raw_groups = other->groups_.mutable_data();\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      if (bit_util::GetBit(other->values_bitmap_.data(), other_g)) {\n+        RETURN_NOT_OK(values_.Append(GetSet::Get(other_raw_values, other_g)));\n+        RETURN_NOT_OK(values_bitmap_.Append(true));\n+      } else {\n+        RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+        RETURN_NOT_OK(values_bitmap_.Append(false));\n+      }\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+      ++num_args_;\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto values_buffer, values_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data = ArrayData::Make(\n+        out_type_, num_args_, {std::move(null_bitmap_buffer), std::move(values_buffer)});\n+    auto values = MakeArray(values_array_data);\n\nReview comment:\n       This is probably as good as it gets\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,318 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, CType val) -> Status {\n+          RETURN_NOT_OK(values_.Append(val));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(false));\n+          ++num_args_;\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    auto other_raw_values = other->values_.mutable_data();\n+    uint32_t* other_raw_groups = other->groups_.mutable_data();\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      if (bit_util::GetBit(other->values_bitmap_.data(), other_g)) {\n\nReview comment:\n       Or really: the `else` block is appending _the exact same values already in the other arrays_, so if we can just concatenate the two arrays and avoid the branching, that should presumably be much faster. (At least for values and values_bitmap, groups_ probably still has to be done element-by-element unfortunately. Even then, you could perhaps reserve enough capacity in groups_, then use TransposeInts to do it all in one go.)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,318 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, CType val) -> Status {\n+          RETURN_NOT_OK(values_.Append(val));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(false));\n+          ++num_args_;\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    auto other_raw_values = other->values_.mutable_data();\n+    uint32_t* other_raw_groups = other->groups_.mutable_data();\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      if (bit_util::GetBit(other->values_bitmap_.data(), other_g)) {\n+        RETURN_NOT_OK(values_.Append(GetSet::Get(other_raw_values, other_g)));\n+        RETURN_NOT_OK(values_bitmap_.Append(true));\n+      } else {\n+        RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+        RETURN_NOT_OK(values_bitmap_.Append(false));\n+      }\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+      ++num_args_;\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto values_buffer, values_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data = ArrayData::Make(\n+        out_type_, num_args_, {std::move(null_bitmap_buffer), std::move(values_buffer)});\n+    auto values = MakeArray(values_array_data);\n+    return Grouper::ApplyGroupings(*groupings, *values);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return list(out_type_); }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_, num_args_ = 0;\n+  TypedBufferBuilder<CType> values_;\n+  TypedBufferBuilder<uint32_t> groups_;\n+  TypedBufferBuilder<bool> values_bitmap_;\n+  std::shared_ptr<DataType> out_type_;\n+};\n+\n+template <typename Type>\n+struct GroupedListImpl<Type, enable_if_t<is_base_binary_type<Type>::value ||\n+                                         std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  using Allocator = arrow::stl::allocator<char>;\n+  using StringType = std::basic_string<char, std::char_traits<char>, Allocator>;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    allocator_ = Allocator(ctx->memory_pool());\n+    // out_type_ initialized by GroupedListInit\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, util::string_view val) -> Status {\n+          values_.emplace_back(val);\n\nReview comment:\n       allocator_ is not a parameter of emplace in the first place. emplace/emplace_back forward their arguments so really it's part of the std::basic_string constructor. And hence allocator_ should still work here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,318 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, CType val) -> Status {\n+          RETURN_NOT_OK(values_.Append(val));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(false));\n+          ++num_args_;\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    auto other_raw_values = other->values_.mutable_data();\n+    uint32_t* other_raw_groups = other->groups_.mutable_data();\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      if (bit_util::GetBit(other->values_bitmap_.data(), other_g)) {\n+        RETURN_NOT_OK(values_.Append(GetSet::Get(other_raw_values, other_g)));\n+        RETURN_NOT_OK(values_bitmap_.Append(true));\n+      } else {\n+        RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+        RETURN_NOT_OK(values_bitmap_.Append(false));\n+      }\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+      ++num_args_;\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto values_buffer, values_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data = ArrayData::Make(\n+        out_type_, num_args_, {std::move(null_bitmap_buffer), std::move(values_buffer)});\n+    auto values = MakeArray(values_array_data);\n+    return Grouper::ApplyGroupings(*groupings, *values);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return list(out_type_); }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_, num_args_ = 0;\n+  TypedBufferBuilder<CType> values_;\n+  TypedBufferBuilder<uint32_t> groups_;\n+  TypedBufferBuilder<bool> values_bitmap_;\n+  std::shared_ptr<DataType> out_type_;\n+};\n+\n+template <typename Type>\n+struct GroupedListImpl<Type, enable_if_t<is_base_binary_type<Type>::value ||\n+                                         std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  using Allocator = arrow::stl::allocator<char>;\n+  using StringType = std::basic_string<char, std::char_traits<char>, Allocator>;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    allocator_ = Allocator(ctx->memory_pool());\n+    // out_type_ initialized by GroupedListInit\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, util::string_view val) -> Status {\n+          values_.emplace_back(val);\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          values_.emplace_back(util::string_view{});\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(false));\n+          ++num_args_;\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    uint32_t* other_raw_groups = other->groups_.mutable_data();\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      if (bit_util::GetBit(other->values_bitmap_.data(), other_g)) {\n\nReview comment:\n       I think here we can just concatenate vectors as with above\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,318 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, CType val) -> Status {\n+          RETURN_NOT_OK(values_.Append(val));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(false));\n+          ++num_args_;\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    auto other_raw_values = other->values_.mutable_data();\n+    uint32_t* other_raw_groups = other->groups_.mutable_data();\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      if (bit_util::GetBit(other->values_bitmap_.data(), other_g)) {\n\nReview comment:\n       I would assume we want to preserve null values seen in the other group, no? If we do, is there a way to just concat two arrays instead of copying values one-by-one?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,318 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, CType val) -> Status {\n+          RETURN_NOT_OK(values_.Append(val));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(false));\n+          ++num_args_;\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    auto other_raw_values = other->values_.mutable_data();\n+    uint32_t* other_raw_groups = other->groups_.mutable_data();\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      if (bit_util::GetBit(other->values_bitmap_.data(), other_g)) {\n+        RETURN_NOT_OK(values_.Append(GetSet::Get(other_raw_values, other_g)));\n+        RETURN_NOT_OK(values_bitmap_.Append(true));\n+      } else {\n+        RETURN_NOT_OK(values_.Append(static_cast<CType>(0)));\n+        RETURN_NOT_OK(values_bitmap_.Append(false));\n+      }\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+      ++num_args_;\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto values_buffer, values_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data = ArrayData::Make(\n+        out_type_, num_args_, {std::move(null_bitmap_buffer), std::move(values_buffer)});\n+    auto values = MakeArray(values_array_data);\n+    return Grouper::ApplyGroupings(*groupings, *values);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return list(out_type_); }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_, num_args_ = 0;\n+  TypedBufferBuilder<CType> values_;\n+  TypedBufferBuilder<uint32_t> groups_;\n+  TypedBufferBuilder<bool> values_bitmap_;\n+  std::shared_ptr<DataType> out_type_;\n+};\n+\n+template <typename Type>\n+struct GroupedListImpl<Type, enable_if_t<is_base_binary_type<Type>::value ||\n+                                         std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  using Allocator = arrow::stl::allocator<char>;\n+  using StringType = std::basic_string<char, std::char_traits<char>, Allocator>;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    allocator_ = Allocator(ctx->memory_pool());\n+    // out_type_ initialized by GroupedListInit\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, util::string_view val) -> Status {\n+          values_.emplace_back(val);\n+          RETURN_NOT_OK(groups_.Append(group));\n+          RETURN_NOT_OK(values_bitmap_.Append(true));\n+          ++num_args_;\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          values_.emplace_back(util::string_view{});\n\nReview comment:\n       Or just \"\".\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-24T13:59:25.945+0000",
                    "updated": "2022-02-24T13:59:25.945+0000",
                    "started": "2022-02-24T13:59:25.945+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "732318",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/737420",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r820457521\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n+\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n+\n+    RETURN_NOT_OK(values_.Append(other->values_.data(), other->num_args_));\n+    RETURN_NOT_OK(values_bitmap_.Reserve(other->num_args_));\n+    values_bitmap_.UnsafeAppend(other->values_bitmap_.data(), 0, other->num_args_);\n+    num_args_ += other->num_args_;\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto values_buffer, values_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data = ArrayData::Make(\n+        out_type_, num_args_, {std::move(null_bitmap_buffer), std::move(values_buffer)});\n+    auto values = MakeArray(values_array_data);\n+    return Grouper::ApplyGroupings(*groupings, *values);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return list(out_type_); }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_, num_args_ = 0;\n+  TypedBufferBuilder<CType> values_;\n+  TypedBufferBuilder<uint32_t> groups_;\n+  TypedBufferBuilder<bool> values_bitmap_;\n+  std::shared_ptr<DataType> out_type_;\n+};\n+\n+template <typename Type>\n+struct GroupedListImpl<Type, enable_if_t<is_base_binary_type<Type>::value ||\n+                                         std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  using Allocator = arrow::stl::allocator<char>;\n+  using StringType = std::basic_string<char, std::char_traits<char>, Allocator>;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    allocator_ = Allocator(ctx->memory_pool());\n+    // out_type_ initialized by GroupedListInit\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, util::string_view val) -> Status {\n+          values_.emplace_back(StringType(val.data(), val.size(), allocator_));\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          values_.emplace_back(\"\");\n+          return Status::OK();\n+        });\n+  }\n\nReview comment:\n       Is there a way to achieve what we have for primitive types for binary types, i.e., the append-whole-buffers logic?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n+\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n\nReview comment:\n       Did give `TransposeInts` a try, but it needed raw `uint8_t*` pointers. So if using it if preferred, how would one retrieve the raw pointers from TypedBufferBuilder, as doing something like:\r\n   ```\r\n   reinterpret_cast<uint8_t*>(groups_.data());\r\n   ```\r\n   throws this error:\r\n   ```\r\n   Reinterpret_cast from 'const unsigned int *' to 'uint8_t *' (aka 'unsigned char *') casts away qualifiers\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n+\n+    if (values_bitmap == nullptr) {\n\nReview comment:\n       As we don't know if future batches will contain `null`s or not, appending all `true`'s here, but in the case when there is no `null` in any batch, this might be a waste.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n\nReview comment:\n       This line does not work for `bool` type. So if this append-whole-buffers approach is to be followed, should we make a different implementation for `bool`, inheriting from the current `GroupedListImpl`, like in CountDistinct/Distinct (but just overriding the `Consume` & `Merge` methods), or is there some conditional logic that can be used here?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n+\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n+\n+    RETURN_NOT_OK(values_.Append(other->values_.data(), other->num_args_));\n+    RETURN_NOT_OK(values_bitmap_.Reserve(other->num_args_));\n+    values_bitmap_.UnsafeAppend(other->values_bitmap_.data(), 0, other->num_args_);\n+    num_args_ += other->num_args_;\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto values_buffer, values_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data = ArrayData::Make(\n+        out_type_, num_args_, {std::move(null_bitmap_buffer), std::move(values_buffer)});\n+    auto values = MakeArray(values_array_data);\n+    return Grouper::ApplyGroupings(*groupings, *values);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return list(out_type_); }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_, num_args_ = 0;\n+  TypedBufferBuilder<CType> values_;\n+  TypedBufferBuilder<uint32_t> groups_;\n+  TypedBufferBuilder<bool> values_bitmap_;\n+  std::shared_ptr<DataType> out_type_;\n+};\n+\n+template <typename Type>\n+struct GroupedListImpl<Type, enable_if_t<is_base_binary_type<Type>::value ||\n+                                         std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  using Allocator = arrow::stl::allocator<char>;\n+  using StringType = std::basic_string<char, std::char_traits<char>, Allocator>;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    allocator_ = Allocator(ctx->memory_pool());\n+    // out_type_ initialized by GroupedListInit\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, util::string_view val) -> Status {\n+          values_.emplace_back(StringType(val.data(), val.size(), allocator_));\n\nReview comment:\n       Had to explicitly call `StringType` to get `allocator_` to work. Is this appropriate?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-07T08:23:24.699+0000",
                    "updated": "2022-03-07T08:23:24.699+0000",
                    "started": "2022-03-07T08:23:24.699+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "737420",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/737422",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r820456106\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n+\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n\nReview comment:\n       Did give `TransposeInts` a try, but it needed raw `uint8_t*` pointers. So if using it is preferred, how would one retrieve the raw pointers from TypedBufferBuilder, as doing something like:\r\n   ```\r\n   reinterpret_cast<uint8_t*>(groups_.data());\r\n   ```\r\n   throws this error:\r\n   ```\r\n   Reinterpret_cast from 'const unsigned int *' to 'uint8_t *' (aka 'unsigned char *') casts away qualifiers\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-07T08:24:10.056+0000",
                    "updated": "2022-03-07T08:24:10.056+0000",
                    "started": "2022-03-07T08:24:10.056+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "737422",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/737500",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r820713662\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n\nReview comment:\n       I would maybe `DCHECK_EQ(batch[0].array()->offset, 0);` just to be safe (and make explicit the assumption here)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n+\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n\nReview comment:\n       There's `mutable_data()` too.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n+\n+    if (values_bitmap == nullptr) {\n\nReview comment:\n       You can check `batch[0].GetNullCount()` or whatever the method is, and only allocate a bitmap if there are any nulls.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n+\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n+\n+    RETURN_NOT_OK(values_.Append(other->values_.data(), other->num_args_));\n+    RETURN_NOT_OK(values_bitmap_.Reserve(other->num_args_));\n+    values_bitmap_.UnsafeAppend(other->values_bitmap_.data(), 0, other->num_args_);\n+    num_args_ += other->num_args_;\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto values_buffer, values_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data = ArrayData::Make(\n+        out_type_, num_args_, {std::move(null_bitmap_buffer), std::move(values_buffer)});\n+    auto values = MakeArray(values_array_data);\n+    return Grouper::ApplyGroupings(*groupings, *values);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return list(out_type_); }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_, num_args_ = 0;\n+  TypedBufferBuilder<CType> values_;\n+  TypedBufferBuilder<uint32_t> groups_;\n+  TypedBufferBuilder<bool> values_bitmap_;\n+  std::shared_ptr<DataType> out_type_;\n+};\n+\n+template <typename Type>\n+struct GroupedListImpl<Type, enable_if_t<is_base_binary_type<Type>::value ||\n+                                         std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  using Allocator = arrow::stl::allocator<char>;\n+  using StringType = std::basic_string<char, std::char_traits<char>, Allocator>;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    allocator_ = Allocator(ctx->memory_pool());\n+    // out_type_ initialized by GroupedListInit\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, util::string_view val) -> Status {\n+          values_.emplace_back(StringType(val.data(), val.size(), allocator_));\n\nReview comment:\n       should be fine\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n+\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n\nReview comment:\n       Also, `TransposeInts` is templated and should be instantiated for uint32_t too. However, it's not that big a deal and this loop is fine. All the other kernels have something like this anyways.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n+\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n\nReview comment:\n       Er, aren't we using a `nullptr` value here? Shouldn't we allocate a bitmap first?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n+\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n+\n+    RETURN_NOT_OK(values_.Append(other->values_.data(), other->num_args_));\n+    RETURN_NOT_OK(values_bitmap_.Reserve(other->num_args_));\n+    values_bitmap_.UnsafeAppend(other->values_bitmap_.data(), 0, other->num_args_);\n+    num_args_ += other->num_args_;\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto values_buffer, values_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data = ArrayData::Make(\n+        out_type_, num_args_, {std::move(null_bitmap_buffer), std::move(values_buffer)});\n+    auto values = MakeArray(values_array_data);\n+    return Grouper::ApplyGroupings(*groupings, *values);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return list(out_type_); }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_, num_args_ = 0;\n+  TypedBufferBuilder<CType> values_;\n+  TypedBufferBuilder<uint32_t> groups_;\n+  TypedBufferBuilder<bool> values_bitmap_;\n+  std::shared_ptr<DataType> out_type_;\n+};\n+\n+template <typename Type>\n+struct GroupedListImpl<Type, enable_if_t<is_base_binary_type<Type>::value ||\n+                                         std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  using Allocator = arrow::stl::allocator<char>;\n+  using StringType = std::basic_string<char, std::char_traits<char>, Allocator>;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    allocator_ = Allocator(ctx->memory_pool());\n+    // out_type_ initialized by GroupedListInit\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, util::string_view val) -> Status {\n+          values_.emplace_back(StringType(val.data(), val.size(), allocator_));\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          values_.emplace_back(\"\");\n+          return Status::OK();\n+        });\n+  }\n\nReview comment:\n       Probably, but we'd have to specialize fixed-width binary separately from variable-width binary, I think\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n\nReview comment:\n       You can extend this trait: https://github.com/apache/arrow/blob/253303ec96499d4b1e333d5c7e7783f3c96de78b/cpp/src/arrow/compute/kernels/hash_aggregate.cc#L615-L633\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-07T13:48:16.694+0000",
                    "updated": "2022-03-07T13:48:16.694+0000",
                    "started": "2022-03-07T13:48:16.694+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "737500",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/738638",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r822454763\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n\nReview comment:\n       Can you elaborate more on the assumption you suggest here? Because say for example:\r\n   ```cpp\r\n   auto in_schema = schema({\r\n         field(\"floats\", float64()),\r\n         //      field(\"nulls\", null()),\r\n         field(\"booleans\", boolean()),\r\n         field(\"decimal128\", decimal128(3, 2)),\r\n         field(\"decimal256\", decimal256(3, 2)),\r\n         field(\"fixed_binary\", fixed_size_binary(3)),\r\n         field(\"key\", int64()),\r\n     });\r\n   auto table = TableFromJSON(in_schema, {R\"([\r\n       [null, true,   null,    null,    null,  1],\r\n       [1.0,  true,   \"1.01\",  \"1.01\",  \"aaa\", 1]\r\n   ])\",\r\n                                                R\"([\r\n       [0.0,   false, \"0.00\",  \"0.00\",  \"bac\", 2],\r\n       [null,  false, null,    null,    null,  3],\r\n       [4.0,   null,  \"4.01\",  \"4.01\",  \"234\", null],\r\n       [3.25,  true,  \"3.25\",  \"3.25\",  \"ddd\", 1],\r\n       [0.125, false, \"0.12\",  \"0.12\",  \"bcd\", 2]\r\n   ])\",\r\n                                                R\"([\r\n       [-0.25, false, \"-0.25\", \"-0.25\", \"bab\", 2],\r\n       [0.75,  true,  \"0.75\",  \"0.75\",  \"123\", null],\r\n       [null,  true,  null,    null,    null,  3]\r\n   ])\"});\r\n   ```\r\n    The 2nd batch of the above table on my local machine is sometimes received in chunks as:\r\n   ```cpp\r\n   // with offset 0\r\n    [0.0,   false, \"0.00\",  \"0.00\",  \"bac\", 2],\r\n    [null,  false, null,    null,    null,  3],\r\n   ```\r\n   ```cpp\r\n   // with offset 2\r\n   [4.0,   null,  \"4.01\",  \"4.01\",  \"234\", null],\r\n   [3.25,  true,  \"3.25\",  \"3.25\",  \"ddd\", 1],\r\n   ```\r\n   ```cpp\r\n   // with offset 4\r\n    [0.125, false, \"0.12\",  \"0.12\",  \"bcd\", 2]\r\n   ```\r\n   \r\n   And the kernel works correctly _without_ DCHECK (and of course fails with it).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -630,6 +635,12 @@ struct GroupedValueTraits<BooleanType> {\n   static void Set(uint8_t* values, uint32_t g, bool v) {\n     bit_util::SetBitTo(values, g, v);\n   }\n+  static Status AppendBuffers(TypedBufferBuilder<bool>& destination, const bool* values,\n+                              int64_t num_values) {\n+    RETURN_NOT_OK(destination.Reserve(num_values));\n+    destination.UnsafeAppend(reinterpret_cast<const uint8_t*>(values), 0, num_values);\n+    return Status::OK();\n+  }\n\nReview comment:\n       Is this similar to what you had in mind?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-09T09:36:06.146+0000",
                    "updated": "2022-03-09T09:36:06.146+0000",
                    "started": "2022-03-09T09:36:06.146+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "738638",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/738702",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r822585993\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n\nReview comment:\n       Is this somehow related to this?\r\n   For columns 1 and 4 (zero indexed) in the table above for `use_exec_plan = true` I get:\r\n   ```cpp\r\n   // col 1 - boolean\r\n   [\r\n     true,\r\n     true,\r\n     false,\r\n     false,\r\n     null,\r\n     null,\r\n     false,\r\n     false,\r\n     true,\r\n     false\r\n   ]\r\n   \r\n   // col 4 fixed size binary\r\n   [\r\n     null,\r\n     616161,\r\n     626163,\r\n     null,\r\n     null,\r\n     null,\r\n     null,\r\n     626162,\r\n     313233,\r\n     null\r\n   ]\r\n   ```\r\n   \r\n   While it appears to be correct with `use_exec_plan = false`:\r\n   ```cpp\r\n   // col 1 - boolean\r\n   [\r\n     true,\r\n     true,\r\n     false,\r\n     false,\r\n     null,\r\n     true,\r\n     false,\r\n     false,\r\n     true,\r\n     true\r\n   ]\r\n   \r\n   // col 4 - fixed sized binary\r\n   [\r\n     null,\r\n     616161,\r\n     626163,\r\n     null,\r\n     323334,\r\n     646464,\r\n     626364,\r\n     626162,\r\n     313233,\r\n     null\r\n   ]\r\n   ```\r\n   \r\n   Am I handling these type incorrectly in the implementation? (These are without the `DCHECK_EQ`)\r\n   What am I missing?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-09T12:14:42.089+0000",
                    "updated": "2022-03-09T12:14:42.089+0000",
                    "started": "2022-03-09T12:14:42.089+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "738702",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/738703",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r822588437\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2769,333 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    DCHECK_EQ(batch[0].array()->offset, 0);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(GetSet::AppendBuffers(values_, values, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    } else if (has_nulls_) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    }\n+    num_args_ += num_values;\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n+\n+    RETURN_NOT_OK(values_.Append(other->values_.data(), other->num_args_));\n+    if (other->has_nulls_) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      RETURN_NOT_OK(values_bitmap_.Reserve(other->num_args_));\n+      values_bitmap_.UnsafeAppend(other->values_bitmap_.data(), 0, other->num_args_);\n+    } else if (has_nulls_) {\n+      RETURN_NOT_OK(values_bitmap_.Append(other->num_args_, true));\n+    }\n+    num_args_ += other->num_args_;\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto values_buffer, values_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data = ArrayData::Make(\n+        out_type_, num_args_,\n+        {has_nulls_ ? std::move(null_bitmap_buffer) : nullptr, std::move(values_buffer)});\n+    auto values = MakeArray(values_array_data);\n+    return Grouper::ApplyGroupings(*groupings, *values);\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override { return list(out_type_); }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_, num_args_ = 0;\n+  bool has_nulls_ = false;\n+  TypedBufferBuilder<CType> values_;\n+  TypedBufferBuilder<uint32_t> groups_;\n+  TypedBufferBuilder<bool> values_bitmap_;\n+  std::shared_ptr<DataType> out_type_;\n+};\n+\n+template <typename Type>\n+struct GroupedListImpl<Type, enable_if_t<is_base_binary_type<Type>::value ||\n+                                         std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  using Allocator = arrow::stl::allocator<char>;\n+  using StringType = std::basic_string<char, std::char_traits<char>, Allocator>;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    allocator_ = Allocator(ctx->memory_pool());\n+    // out_type_ initialized by GroupedListInit\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    } else {\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    }\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t group, util::string_view val) -> Status {\n+          values_.emplace_back(StringType(val.data(), val.size(), allocator_));\n+          return Status::OK();\n+        },\n+        [&](uint32_t group) -> Status {\n+          values_.emplace_back(\"\");\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n+\n+    values_.insert(values_.end(), other->values_.begin(), other->values_.end());\n+    RETURN_NOT_OK(values_bitmap_.Reserve(other->num_args_));\n+    values_bitmap_.UnsafeAppend(other->values_bitmap_.data(), 0, other->num_args_);\n+    num_args_ += other->num_args_;\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    ARROW_ASSIGN_OR_RAISE(auto groups_buffer, groups_.Finish());\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap_buffer, values_bitmap_.Finish());\n+\n+    auto groups = UInt32Array(num_args_, std::move(groups_buffer));\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto groupings,\n+        Grouper::MakeGroupings(groups, static_cast<uint32_t>(num_groups_), ctx_));\n+\n+    auto values_array_data =\n+        ArrayData::Make(out_type_, num_args_, {std::move(null_bitmap_buffer), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(values_array_data.get(), values_));\n+    auto values = MakeArray(values_array_data);\n+    return Grouper::ApplyGroupings(*groupings, *values);\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<util::optional<StringType>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    auto* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n\nReview comment:\n       This is the reason I've not included the optional-null-bitmap logic into binary type implementation. I've refrained myself from altering these `MakeOffsetsValues` methods as they are carry overs from MinMax.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate_test.cc\n##########\n@@ -2747,6 +2747,288 @@ TEST(GroupBy, OneScalar) {\n   }\n }\n \n+TEST(GroupBy, ListNumeric) {\n+  for (const auto& type : NumericTypes()) {\n+    for (auto use_threads : {true, false}) {\n+      SCOPED_TRACE(use_threads ? \"parallel/merged\" : \"serial\");\n+      {  // With nulls\n+        SCOPED_TRACE(\"with nulls\");\n+        auto table =\n+            TableFromJSON(schema({field(\"argument\", type), field(\"key\", int64())}), {R\"([\n+    [99,  1],\n+    [99,  1]\n+])\",\n+                                                                                     R\"([\n+    [88,  2],\n+    [null,   3],\n+    [null,   3]\n+])\",\n+                                                                                     R\"([\n+    [null,   4],\n+    [null,   4]\n+])\",\n+                                                                                     R\"([\n+    [77,  null],\n+    [99,  3]\n+])\",\n+                                                                                     R\"([\n+    [88,  2],\n+    [66, 2]\n+])\",\n+                                                                                     R\"([\n+    [55, null],\n+    [44,  3]\n+  ])\",\n+                                                                                     R\"([\n+    [33,    null],\n+    [22,    null]\n+  ])\"});\n+\n+        ASSERT_OK_AND_ASSIGN(auto aggregated_and_grouped,\n+                             internal::GroupBy(\n+                                 {\n+                                     table->GetColumnByName(\"argument\"),\n+                                 },\n+                                 {\n+                                     table->GetColumnByName(\"key\"),\n+                                 },\n+                                 {\n+                                     {\"hash_list\", nullptr},\n+                                 },\n+                                 use_threads));\n+        ValidateOutput(aggregated_and_grouped);\n+        SortBy({\"key_0\"}, &aggregated_and_grouped);\n+\n+        // Order of sub-arrays is not stable\n+        auto sort = [](const Array& arr) -> std::shared_ptr<Array> {\n+          EXPECT_OK_AND_ASSIGN(auto indices, SortIndices(arr));\n+          EXPECT_OK_AND_ASSIGN(auto sorted, Take(arr, indices));\n+          return sorted.make_array();\n+        };\n+\n+        auto struct_arr = aggregated_and_grouped.array_as<StructArray>();\n+\n+        auto list_arr = checked_pointer_cast<ListArray>(struct_arr->field(0));\n+        AssertDatumsEqual(ArrayFromJSON(type, R\"([99, 99])\"),\n+                          sort(*list_arr->value_slice(0)),\n+                          /*verbose=*/true);\n+        AssertDatumsEqual(ArrayFromJSON(type, R\"([66, 88, 88])\"),\n+                          sort(*list_arr->value_slice(1)), /*verbose=*/true);\n+        AssertDatumsEqual(ArrayFromJSON(type, R\"([44, 99, null, null])\"),\n+                          sort(*list_arr->value_slice(2)), /*verbose=*/true);\n+        AssertDatumsEqual(ArrayFromJSON(type, R\"([null, null])\"),\n+                          sort(*list_arr->value_slice(3)),\n+                          /*verbose=*/true);\n+        AssertDatumsEqual(ArrayFromJSON(type, R\"([22, 33, 55, 77])\"),\n+                          sort(*list_arr->value_slice(4)), /*verbose=*/true);\n+      }\n+      {  // Without nulls\n\nReview comment:\n       Added these for the time-being to test the optional-null-bitmap logic. Will remove or consolidate them as necessary later?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2769,333 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    DCHECK_EQ(batch[0].array()->offset, 0);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(GetSet::AppendBuffers(values_, values, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    } else if (has_nulls_) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    }\n+    num_args_ += num_values;\n\nReview comment:\n       This seems a little messy at first sight. Are there better ways to do this?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-09T12:22:26.413+0000",
                    "updated": "2022-03-09T12:22:26.413+0000",
                    "started": "2022-03-09T12:22:26.413+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "738703",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/738707",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r822585993\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n\nReview comment:\n       Is this somehow related to this?\r\n   For columns 1 and 4 (zero indexed) in the table above for `use_exec_plan = true` I get incorrect `values` Array in the `Finalize` step:\r\n   ```cpp\r\n   // col 1 - boolean\r\n   [\r\n     true,\r\n     true,\r\n     false,\r\n     false,\r\n     null,\r\n     null,\r\n     false,\r\n     false,\r\n     true,\r\n     false\r\n   ]\r\n   \r\n   // col 4 fixed size binary\r\n   [\r\n     null,\r\n     616161,\r\n     626163,\r\n     null,\r\n     null,\r\n     null,\r\n     null,\r\n     626162,\r\n     313233,\r\n     null\r\n   ]\r\n   ```\r\n   \r\n   While it appears to be correct with `use_exec_plan = false`:\r\n   ```cpp\r\n   // col 1 - boolean\r\n   [\r\n     true,\r\n     true,\r\n     false,\r\n     false,\r\n     null,\r\n     true,\r\n     false,\r\n     false,\r\n     true,\r\n     true\r\n   ]\r\n   \r\n   // col 4 - fixed sized binary\r\n   [\r\n     null,\r\n     616161,\r\n     626163,\r\n     null,\r\n     323334,\r\n     646464,\r\n     626364,\r\n     626162,\r\n     313233,\r\n     null\r\n   ]\r\n   ```\r\n   \r\n   Am I handling these type incorrectly in the implementation? (These are without the `DCHECK_EQ`)\r\n   What am I missing?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-09T12:25:11.309+0000",
                    "updated": "2022-03-09T12:25:11.309+0000",
                    "started": "2022-03-09T12:25:11.308+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "738707",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/738712",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r822606737\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n\nReview comment:\n       Also, boolean type also has problems with `use_threads = true`:\r\n   ```cpp\r\n   [\r\n     true,\r\n     true,\r\n     true,\r\n     false,\r\n     null,\r\n     false,\r\n     false,\r\n     true,\r\n     false,\r\n     false\r\n   ]\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-09T12:39:56.323+0000",
                    "updated": "2022-03-09T12:39:56.323+0000",
                    "started": "2022-03-09T12:39:56.323+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "738712",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/738750",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r822673661\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2770,336 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    //    DCHECK_EQ(batch[0].array()->offset, 0);\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    int64_t num_values = batch[0].array()->length;\n+\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(GetSet::AppendBuffers(values_, values, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n\nReview comment:\n       bitmaps should have offsets handled manually, something like this (untested)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -621,6 +622,11 @@ struct GroupedValueTraits {\n \n   static CType Get(const CType* values, uint32_t g) { return values[g]; }\n   static void Set(CType* values, uint32_t g, CType v) { values[g] = v; }\n+  static Status AppendBuffers(TypedBufferBuilder<CType>& destination, const CType* values,\n\nReview comment:\n       nit: prefer raw pointers over mutable references (`TypedBufferBuilder<CType>*`), while the style guide we use no longer requires this, our codebase was written with this rule in place so let's be consistent\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2770,336 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    //    DCHECK_EQ(batch[0].array()->offset, 0);\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    int64_t num_values = batch[0].array()->length;\n+\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(GetSet::AppendBuffers(values_, values, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n\nReview comment:\n       There's no point doing reserve-then-unsafe-append unless you know the entire size to reserve up front, because append will just do the reserve for you\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n\nReview comment:\n       GetValues<CType> naively tries to adjust the returned pointer to account for the offset but it is unable to do this for boolean type. So we should use `GetValues<CType>(1, 0)` to prevent it from adjusting the offset, and then our code needs to handle the offset itself (e.g. AppendBuffers needs to take an offset)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2769,333 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    DCHECK_EQ(batch[0].array()->offset, 0);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(GetSet::AppendBuffers(values_, values, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n+    } else if (has_nulls_) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    }\n+    num_args_ += num_values;\n\nReview comment:\n       Doesn't really seem that big a deal to me\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -630,6 +635,12 @@ struct GroupedValueTraits<BooleanType> {\n   static void Set(uint8_t* values, uint32_t g, bool v) {\n     bit_util::SetBitTo(values, g, v);\n   }\n+  static Status AppendBuffers(TypedBufferBuilder<bool>& destination, const bool* values,\n+                              int64_t num_values) {\n+    RETURN_NOT_OK(destination.Reserve(num_values));\n+    destination.UnsafeAppend(reinterpret_cast<const uint8_t*>(values), 0, num_values);\n+    return Status::OK();\n+  }\n\nReview comment:\n       Yes.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n\nReview comment:\n       Well then the assumption is incorrect, and we need to handle offsets.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2770,336 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    //    DCHECK_EQ(batch[0].array()->offset, 0);\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    int64_t num_values = batch[0].array()->length;\n+\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(GetSet::AppendBuffers(values_, values, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n\nReview comment:\n       ```suggestion\r\n         const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0, 0);\r\n         RETURN_NOT_OK(values_bitmap_.Append(values_bitmap, batch[0].array()->offset, num_values));\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2770,336 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    //    DCHECK_EQ(batch[0].array()->offset, 0);\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    int64_t num_values = batch[0].array()->length;\n+\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(GetSet::AppendBuffers(values_, values, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n\nReview comment:\n       also this is probably what's causing issues down below for fixed-size binary, and the fact that other types didn't fail just means we have a gap in our testing\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2770,336 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    //    DCHECK_EQ(batch[0].array()->offset, 0);\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    int64_t num_values = batch[0].array()->length;\n+\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(GetSet::AppendBuffers(values_, values, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n\nReview comment:\n       also maybe considering saving a `const auto& values = *batch[0].array();` up top so we aren't unboxing this repeatedly (though compiler probably optimizes that) and so it's clear what batch[0] is (I always forget)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-09T14:00:27.684+0000",
                    "updated": "2022-03-09T14:00:27.684+0000",
                    "started": "2022-03-09T14:00:27.684+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "738750",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/739539",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r823833874\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2771,343 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    int64_t num_values = batch[0].array()->length;\n+    int64_t offset = batch[0].array()->offset;\n+\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1, 0);\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+\n+    const auto* values = batch[0].array()->GetValues<CType>(1, 0);\n+    RETURN_NOT_OK(GetSet::AppendBuffers(&values_, values, offset, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<bool>(0, 0);\n+      RETURN_NOT_OK(GroupedValueTraits<BooleanType>::AppendBuffers(\n+          &values_bitmap_, values_bitmap, offset, num_values));\n+    } else if (has_nulls_) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    }\n+    num_args_ += num_values;\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n+\n+    const auto* values = reinterpret_cast<const CType*>(other->values_.data());\n\nReview comment:\n       Casting here and below as `AppendBuffers` takes `const CType*` while `data()` gives `uint8_t*`, and when tried overloading `AppendBuffers` for `uint8_t*`, there becomes two viable options for the `uint8_t` type. So just wanted to get your thoughts on this. Also, have made `AppendBuffers` take `const CType*` and `const bool*` because `GetValues(1, 0)`(used in Consume) returns them this way.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2771,343 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    int64_t num_values = batch[0].array()->length;\n+    int64_t offset = batch[0].array()->offset;\n+\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1, 0);\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+\n+    const auto* values = batch[0].array()->GetValues<CType>(1, 0);\n+    RETURN_NOT_OK(GetSet::AppendBuffers(&values_, values, offset, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<bool>(0, 0);\n+      RETURN_NOT_OK(GroupedValueTraits<BooleanType>::AppendBuffers(\n+          &values_bitmap_, values_bitmap, offset, num_values));\n+    } else if (has_nulls_) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    }\n+    num_args_ += num_values;\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n+\n+    const auto* values = reinterpret_cast<const CType*>(other->values_.data());\n\nReview comment:\n       Should we consider using `buffers[1].data()` instead of `GetValues(1, 0)` and make `AppendBuffers` accept `uint8_t*` while doing the casting to `CType*` internally?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2771,343 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    int64_t num_values = batch[0].array()->length;\n+    int64_t offset = batch[0].array()->offset;\n+\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1, 0);\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n\nReview comment:\n       Is this okay?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2770,336 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    //    DCHECK_EQ(batch[0].array()->offset, 0);\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    int64_t num_values = batch[0].array()->length;\n+\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(GetSet::AppendBuffers(values_, values, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n\nReview comment:\n       I couldn't find an `Append` counterpart of https://github.com/apache/arrow/blob/55b7bb85de7bc66720367532407d8a86da693ddf/cpp/src/arrow/buffer_builder.h#L355-L361 for bool type.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-10T15:27:03.459+0000",
                    "updated": "2022-03-10T15:27:03.459+0000",
                    "started": "2022-03-10T15:27:03.459+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "739539",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/739543",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r823845893\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2758,317 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+    int64_t num_values = batch[1].array()->length;\n+\n+    num_args_ += num_values;\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(values_.Append(values, num_values));\n+\n+    if (values_bitmap == nullptr) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n\nReview comment:\n       I guess `values_bitmap` and `values_bitmap_` were different. \ud83e\udd14  \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-10T15:30:50.209+0000",
                    "updated": "2022-03-10T15:30:50.209+0000",
                    "started": "2022-03-10T15:30:50.209+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "739543",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/739546",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhruv9vats commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r823847455\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2770,336 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    //    DCHECK_EQ(batch[0].array()->offset, 0);\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    int64_t num_values = batch[0].array()->length;\n+\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(GetSet::AppendBuffers(values_, values, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n\nReview comment:\n       Does the current structure look somewhat correct? Also, please suggest a more rigorous way of testing.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-10T15:32:08.158+0000",
                    "updated": "2022-03-10T15:32:08.158+0000",
                    "started": "2022-03-10T15:32:08.157+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "739546",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/739568",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r823887982\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2771,343 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    int64_t num_values = batch[0].array()->length;\n+    int64_t offset = batch[0].array()->offset;\n+\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1, 0);\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n\nReview comment:\n       What's not okay?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2771,343 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    int64_t num_values = batch[0].array()->length;\n+    int64_t offset = batch[0].array()->offset;\n+\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1, 0);\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+\n+    const auto* values = batch[0].array()->GetValues<CType>(1, 0);\n+    RETURN_NOT_OK(GetSet::AppendBuffers(&values_, values, offset, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<bool>(0, 0);\n\nReview comment:\n       ```suggestion\r\n         const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0, 0);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2771,343 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    int64_t num_values = batch[0].array()->length;\n+    int64_t offset = batch[0].array()->offset;\n+\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1, 0);\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+\n+    const auto* values = batch[0].array()->GetValues<CType>(1, 0);\n+    RETURN_NOT_OK(GetSet::AppendBuffers(&values_, values, offset, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<bool>(0, 0);\n+      RETURN_NOT_OK(GroupedValueTraits<BooleanType>::AppendBuffers(\n+          &values_bitmap_, values_bitmap, offset, num_values));\n+    } else if (has_nulls_) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    }\n+    num_args_ += num_values;\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n+\n+    const auto* values = reinterpret_cast<const CType*>(other->values_.data());\n\nReview comment:\n       Yes, GetSet::AppendBuffers should take uint8_t* uniformly, casting to `bool*` in one case is something we should avoid.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2771,343 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    int64_t num_values = batch[0].array()->length;\n+    int64_t offset = batch[0].array()->offset;\n+\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1, 0);\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+\n+    const auto* values = batch[0].array()->GetValues<CType>(1, 0);\n+    RETURN_NOT_OK(GetSet::AppendBuffers(&values_, values, offset, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<bool>(0, 0);\n+      RETURN_NOT_OK(GroupedValueTraits<BooleanType>::AppendBuffers(\n+          &values_bitmap_, values_bitmap, offset, num_values));\n+    } else if (has_nulls_) {\n+      RETURN_NOT_OK(values_bitmap_.Append(num_values, true));\n+    }\n+    num_args_ += num_values;\n+    return Status::OK();\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedListImpl*>(&raw_other);\n+    const auto* other_raw_groups = other->groups_.data();\n+    const auto* g = group_id_mapping.GetValues<uint32_t>(1);\n+\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < other->num_args_;\n+         ++other_g) {\n+      RETURN_NOT_OK(groups_.Append(g[other_raw_groups[other_g]]));\n+    }\n+\n+    const auto* values = reinterpret_cast<const CType*>(other->values_.data());\n\nReview comment:\n       Note you'll have to take the type as well, so you can compute the bit/byte width. That has the added bonus, however, that you _should_ be able to use it for FixedSizeBinaryType now too. (Though, it may be tricky to get everything else to line up in the templates.)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-10T16:13:05.849+0000",
                    "updated": "2022-03-10T16:13:05.849+0000",
                    "started": "2022-03-10T16:13:05.848+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "739568",
                    "issueId": "13418478"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/worklog/739570",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #12484:\nURL: https://github.com/apache/arrow/pull/12484#discussion_r823892107\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -2758,6 +2770,336 @@ struct GroupedOneFactory {\n   InputType argument_type;\n };\n \n+// ----------------------------------------------------------------------\n+// List implementation\n+\n+template <typename Type, typename Enable = void>\n+struct GroupedListImpl final : public GroupedAggregator {\n+  using CType = typename TypeTraits<Type>::CType;\n+  using GetSet = GroupedValueTraits<Type>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    has_nulls_ = false;\n+    // out_type_ initialized by GroupedListInit\n+    values_ = TypedBufferBuilder<CType>(ctx_->memory_pool());\n+    groups_ = TypedBufferBuilder<uint32_t>(ctx_->memory_pool());\n+    values_bitmap_ = TypedBufferBuilder<bool>(ctx_->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    num_groups_ = new_num_groups;\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    //    DCHECK_EQ(batch[0].array()->offset, 0);\n+    const auto* groups = batch[1].array()->GetValues<uint32_t>(1);\n+    const auto* values = batch[0].array()->GetValues<CType>(1);\n+    int64_t num_values = batch[0].array()->length;\n+\n+    RETURN_NOT_OK(groups_.Append(groups, num_values));\n+    RETURN_NOT_OK(GetSet::AppendBuffers(values_, values, num_values));\n+\n+    if (batch[0].null_count() > 0) {\n+      if (!has_nulls_) {\n+        has_nulls_ = true;\n+        RETURN_NOT_OK(values_bitmap_.Append(num_args_, true));\n+      }\n+      const auto* values_bitmap = batch[0].array()->GetValues<uint8_t>(0);\n+      RETURN_NOT_OK(values_bitmap_.Reserve(num_values));\n+      values_bitmap_.UnsafeAppend(values_bitmap, 0, num_values);\n\nReview comment:\n       This seems on the right track.\r\n   \r\n   This is generally what we do for tests, it gets annoying quickly to test different permutations - we probably need to come up with a reasonable test helper\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-03-10T16:14:01.904+0000",
                    "updated": "2022-03-10T16:14:01.904+0000",
                    "started": "2022-03-10T16:14:01.904+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "739570",
                    "issueId": "13418478"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 22800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@52fc1ff[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@523376e3[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@299a8a47[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@60d775f9[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6ee1592a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@30b08a6e[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4d05f68d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@16a63a69[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@726a099e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@463d1e47[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@24ee2993[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@33c3a15[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 22800,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Mar 15 14:43:58 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-03-15T14:43:58.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15152/watchers",
            "watchCount": 6,
            "isWatching": false
        },
        "created": "2021-12-19T23:21:09.000+0000",
        "updated": "2022-03-15T22:42:37.000+0000",
        "timeoriginalestimate": null,
        "description": "For more advanced aggregations, it's helpful to be able to gather the grouped values into a list array. Pandas and Polars both have that feature. And `hash_distinct` already aggregates to lists, so all the building blocks are there.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "6h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 22800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement a `hash_list` aggregate function",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/comment/17494757",
                    "id": "17494757",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=dhruv9vats",
                        "name": "dhruv9vats",
                        "key": "dhruv9vats",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34058",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34058",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34058",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34058"
                        },
                        "displayName": "Dhruv Vats",
                        "active": true,
                        "timeZone": "Asia/Kolkata"
                    },
                    "body": "It isn't super obvious to me what is being asked. Could someone give an example of sorts? That'll be very helpful.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=dhruv9vats",
                        "name": "dhruv9vats",
                        "key": "dhruv9vats",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34058",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34058",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34058",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34058"
                        },
                        "displayName": "Dhruv Vats",
                        "active": true,
                        "timeZone": "Asia/Kolkata"
                    },
                    "created": "2022-02-18T17:34:13.775+0000",
                    "updated": "2022-02-18T17:34:13.775+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/comment/17494761",
                    "id": "17494761",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=dhruv9vats",
                        "name": "dhruv9vats",
                        "key": "dhruv9vats",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34058",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34058",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34058",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34058"
                        },
                        "displayName": "Dhruv Vats",
                        "active": true,
                        "timeZone": "Asia/Kolkata"
                    },
                    "body": "Is it something like:\r\n||Arg||Key||\r\n|Yo|1|\r\n|Hello|2|\r\n|Howdy|2|\r\n|Wassup|1|\r\n|Yolo|3|\r\n\r\nWhen {{hash_list}} is applied as aggregate to group by\u00a0{{{}Key{}}}, the above table\u00a0becomes:\r\n||hash_list(Arg)||Key||\r\n|[Yo, Wassup]|1|\r\n|[Hello, Howdy]|2|\r\n|[Yolo]|3|\r\n\r\n?\r\n\r\n\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=dhruv9vats",
                        "name": "dhruv9vats",
                        "key": "dhruv9vats",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34058",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34058",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34058",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34058"
                        },
                        "displayName": "Dhruv Vats",
                        "active": true,
                        "timeZone": "Asia/Kolkata"
                    },
                    "created": "2022-02-18T17:46:11.655+0000",
                    "updated": "2022-02-18T17:47:02.533+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/comment/17494773",
                    "id": "17494773",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=coady",
                        "name": "coady",
                        "key": "coady",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "A. Coady",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "\u00a0\r\nYes. Here's an example with a duplicate arg, just to distinguish it from `hash_distinct`.\r\n||Arg||Key||\r\n|Yo|1|\r\n|Hello|2|\r\n|Howdy|2|\r\n|Wassup|1|\r\n|Yolo|3|\r\n|Yolo|3|\r\n||hash_list(Arg)||Key||\r\n|[Yo, Wassup]|1|\r\n|[Hello, Howdy]|2|\r\n|[Yolo, Yolo]|3|\r\n\r\nAn alternative proposal: internally it's probably more efficient to have `hash_indices`, since those could be applied to any other array later.\r\n||Key||\r\n||1||\r\n||2||\r\n||2||\r\n||1||\r\n||3||\r\n||3||\r\n||hash_indices||Key||\r\n|[0, 3]|1|\r\n|[1, 2]|2|\r\n|[4, 5]|3|\r\n\r\nBut maybe that doesn't fit well with the current grouping interface, since there'd be no need for the \"arg\" input.\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=coady",
                        "name": "coady",
                        "key": "coady",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "A. Coady",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-02-18T18:32:39.558+0000",
                    "updated": "2022-02-18T18:32:39.558+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13418478/comment/17506943",
                    "id": "17506943",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 12484\n[https://github.com/apache/arrow/pull/12484]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-03-15T14:43:58.427+0000",
                    "updated": "2022-03-15T14:43:58.427+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|z0xvb4:",
        "customfield_12314139": null
    }
}