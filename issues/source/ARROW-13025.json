{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13382999",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999",
    "key": "ARROW-13025",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349983",
                "id": "12349983",
                "description": "",
                "name": "5.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-07-28"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12617694",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12617694",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13306872",
                    "key": "ARROW-8894",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13306872",
                    "fields": {
                        "summary": "[C++] C++ array kernels framework and execution buildout (umbrella issue)",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 21600,
            "total": 21600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 21600,
            "total": 21600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13025/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 36,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/609948",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm opened a new pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511\n\n\n   This is a draft of adding more utility methods to FunctionOptions. It's not fully implemented (it needs rebasing + serialization isn't implemented for most options, plus there are various TODOs scattered). But before I proceed further, I wanted to get some feedback.\r\n   \r\n   Some concerns I have:\r\n   - I don't like adding protected methods to a struct, and it's inconsistent with how equality is implemented for other structs (via a visitor or otherwise centralized in a single location). However ARROW-8891 will require that we be able to define kernels - and presumably their options - in a separate shared library, so I don't think we can do much better than this.\r\n   - But for (de)serialization, we'll still need some way to dynamically register the mapping between a type_name and the actual struct, so maybe this is a moot point.\r\n   - I've exposed the fact that serialization uses StructScalars to support Expression - but maybe this is too much to commit to in the API?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-10T21:28:34.833+0000",
                    "updated": "2021-06-10T21:28:34.833+0000",
                    "started": "2021-06-10T21:28:34.832+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "609948",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/609949",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-859086061\n\n\n   https://issues.apache.org/jira/browse/ARROW-13025\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-10T21:28:48.496+0000",
                    "updated": "2021-06-10T21:28:48.496+0000",
                    "started": "2021-06-10T21:28:48.496+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "609949",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/609950",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-859086060\n\n\n   @bkietz I'd appreciate if you had any feedback on the approach here/if this was in line with what you were thinking.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-10T21:28:51.591+0000",
                    "updated": "2021-06-10T21:28:51.591+0000",
                    "started": "2021-06-10T21:28:51.591+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "609950",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/610775",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-860852122\n\n\n   @lidavidm thanks for working on this!\r\n   \r\n   >    I don't like adding protected methods to a struct, and it's inconsistent with how equality is implemented for other structs (via a visitor or otherwise centralized in a single location). However ARROW-8891 will require that we be able to define kernels - and presumably their options - in a separate shared library, so I don't think we can do much better than this.\r\n   \r\n   I agree that it's unfortunately necessary in this case: `FunctionOptions` is an extension point (unlike `Array` or `Scalar`, where we own the full enumeration of subclasses). In light of that: `FunctionOptions` should be promoted from struct to class (same for its subclasses).\r\n   \r\n   >    But for (de)serialization, we'll still need some way to dynamically register the mapping between a type_name and the actual struct, so maybe this is a moot point.\r\n   \r\n   We could add this to `FunctionRegistry`, I think:\r\n   ```c++\r\n   class FunctionOptionsType {\r\n    public:\r\n     virtual std::string name() const = 0;\r\n   \r\n     virtual bool Compare(const FunctionOptions&, const FunctionOptions&) const = 0;\r\n     virtual std::string Stringify(const FunctionOptions&) const = 0;\r\n     virtual Result<std::unique_ptr<Buffer>> Serialize(const FunctionOptions&) const = 0;\r\n     virtual Result<std::unique_ptr<FunctionOptions>> Deserialize(const Buffer&) const = 0;\r\n   };\r\n   \r\n   class FunctionOptions {\r\n    public:\r\n     virtual ~FunctionOptions() = default;\r\n     const FunctionOptionsType* options_type() const { return type_; }\r\n   \r\n     bool Equals(const FunctionOptions& other) const {\r\n       return type_ = other.type_ && type_->Compare(*this, other);\r\n     }\r\n     // forward other methods to type_ as well\r\n   \r\n    protected:\r\n     explicit FunctionOptions(const FunctionOptionsType* type) : type_(type) {}\r\n     const FunctionOptionsType* type_;\r\n   };\r\n   \r\n   class FunctionRegistry {\r\n    public:\r\n     // Called alongside AddFunction\r\n     // will raise if another options type with the same name exists\r\n     Status AddFunctionOptionsType(const FunctionOptionsType*);\r\n   };\r\n   \r\n   class Function {\r\n    public:\r\n     // nullptr if the function does not take options.\r\n     // This is also nice since we can assert correctly typed FunctionOptions\r\n     const FunctionOptionsType* options_type() const;\r\n   };\r\n   ```\r\n   \r\n   >    I've exposed the fact that serialization uses StructScalars to support Expression - but maybe this is too much to commit to in the API?\r\n   \r\n   Yes, I'd prefer that implementation detail be kept internal. Please ensure ToScalar/FromScalar can't be accessed without including an _internal header.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-14T17:16:24.437+0000",
                    "updated": "2021-06-14T17:16:24.437+0000",
                    "started": "2021-06-14T17:16:24.437+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "610775",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/611829",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-862209026\n\n\n   Can we explain the objectives and design constraints here?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-16T09:36:06.445+0000",
                    "updated": "2021-06-16T09:36:06.445+0000",
                    "started": "2021-06-16T09:36:06.444+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "611829",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/611830",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-862209404\n\n\n   Also, if the goal is to serialize function options as a struct scalar using the IPC format, it would be good to check performance, because I fear there may be a lot of overhead doing so.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-16T09:36:41.532+0000",
                    "updated": "2021-06-16T09:36:41.532+0000",
                    "started": "2021-06-16T09:36:41.532+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "611830",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/611831",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-862210218\n\n\n   One more thought: we should try to minimize the hand-writing of boilerplate. Is it possible to somehow define a subclass of `std::tuple<Args...>` that would automatically generate at least some of the methods (such as comparison and serialization)?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-16T09:38:04.697+0000",
                    "updated": "2021-06-16T09:38:04.697+0000",
                    "started": "2021-06-16T09:38:04.697+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "611831",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/611845",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-862219528\n\n\n   There's an intriguing thing in Boost which seems to allow to treat a `struct` as a tuple, but the doc is obnoxious:\r\n   https://www.boost.org/doc/libs/1_76_0/libs/fusion/doc/html/fusion/adapted/adapt_struct.html\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-16T09:52:11.860+0000",
                    "updated": "2021-06-16T09:52:11.860+0000",
                    "started": "2021-06-16T09:52:11.860+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "611845",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/611847",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou edited a comment on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-862219528\n\n\n   There's an intriguing thing in Boost which seems to allow to treat a `struct` as a tuple, but the doc is obnoxious:\r\n   https://www.boost.org/doc/libs/1_76_0/libs/fusion/doc/html/fusion/adapted/adapt_struct.html\r\n   \r\n   Another intriguing thing when looking for \"C++ named tuple\":\r\n   https://stackoverflow.com/a/17072195/10194\r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-16T09:56:24.048+0000",
                    "updated": "2021-06-16T09:56:24.048+0000",
                    "started": "2021-06-16T09:56:24.048+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "611847",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/611883",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#discussion_r653899327\n\n\n\n##########\nFile path: cpp/src/arrow/compute/function_test.cc\n##########\n@@ -31,6 +35,89 @@\n namespace arrow {\n namespace compute {\n \n+TEST(FunctionOptions, Equality) {\n+  std::vector<std::shared_ptr<FunctionOptions>> options;\n+  options.emplace_back(new ScalarAggregateOptions());\n+  options.emplace_back(new ScalarAggregateOptions(/*skip_nulls=*/false, /*min_count=*/1));\n+  options.emplace_back(new ModeOptions());\n+  options.emplace_back(new ModeOptions(/*n=*/2));\n+  options.emplace_back(new VarianceOptions());\n+  options.emplace_back(new VarianceOptions(/*ddof=*/2));\n+  options.emplace_back(new QuantileOptions());\n+  options.emplace_back(\n+      new QuantileOptions(/*q=*/0.75, QuantileOptions::Interpolation::MIDPOINT));\n+  options.emplace_back(new TDigestOptions());\n+  options.emplace_back(\n+      new TDigestOptions(/*q=*/0.75, /*delta=*/50, /*buffer_size=*/1024));\n+  options.emplace_back(new IndexOptions(ScalarFromJSON(int64(), \"16\")));\n+  options.emplace_back(new IndexOptions(ScalarFromJSON(boolean(), \"true\")));\n+  options.emplace_back(new IndexOptions(ScalarFromJSON(boolean(), \"null\")));\n+  options.emplace_back(new ArithmeticOptions());\n+  options.emplace_back(new ArithmeticOptions(/*check_overflow=*/true));\n+  options.emplace_back(new ElementWiseAggregateOptions());\n+  options.emplace_back(new ElementWiseAggregateOptions(/*skip_nulls=*/false));\n+  options.emplace_back(new MatchSubstringOptions(\"pattern\"));\n+  options.emplace_back(new MatchSubstringOptions(\"pattern\", /*ignore_case=*/true));\n+  options.emplace_back(new SplitOptions());\n+  options.emplace_back(new SplitOptions(/*max_splits=*/2, /*reverse=*/true));\n+  options.emplace_back(new SplitPatternOptions(\"pattern\"));\n+  options.emplace_back(\n+      new SplitPatternOptions(\"pattern\", /*max_splits=*/2, /*reverse=*/true));\n+  options.emplace_back(new ReplaceSubstringOptions(\"pattern\", \"replacement\"));\n+  options.emplace_back(\n+      new ReplaceSubstringOptions(\"pattern\", \"replacement\", /*max_replacements=*/2));\n+  options.emplace_back(new ExtractRegexOptions(\"pattern\"));\n+  options.emplace_back(new ExtractRegexOptions(\"pattern2\"));\n+  options.emplace_back(new SetLookupOptions(ArrayFromJSON(int64(), \"[1, 2, 3, 4]\")));\n+  options.emplace_back(new SetLookupOptions(ArrayFromJSON(boolean(), \"[true, false]\")));\n+  options.emplace_back(new StrptimeOptions(\"%Y\", TimeUnit::type::MILLI));\n+  options.emplace_back(new StrptimeOptions(\"%Y\", TimeUnit::type::NANO));\n+  options.emplace_back(new TrimOptions(\" \"));\n+  options.emplace_back(new TrimOptions(\"abc\"));\n+  options.emplace_back(new SliceOptions(/*start=*/1));\n+  options.emplace_back(new SliceOptions(/*start=*/1, /*stop=*/-5, /*step=*/-2));\n+  options.emplace_back(new CompareOptions(CompareOperator::EQUAL));\n+  options.emplace_back(new CompareOptions(CompareOperator::NOT_EQUAL));\n+  // N.B. we never actually use field_nullability or field_metadata in Arrow\n+  options.emplace_back(new ProjectOptions({\"col1\"}, {true}, {}));\n+  options.emplace_back(new ProjectOptions({\"col1\"}, {false}, {}));\n+  options.emplace_back(new CastOptions(CastOptions::Safe(boolean())));\n+  options.emplace_back(new CastOptions(CastOptions::Unsafe(int64())));\n+  options.emplace_back(new FilterOptions());\n+  options.emplace_back(\n+      new FilterOptions(FilterOptions::NullSelectionBehavior::EMIT_NULL));\n+  options.emplace_back(new TakeOptions());\n+  options.emplace_back(new TakeOptions(/*boundscheck=*/false));\n+  options.emplace_back(new DictionaryEncodeOptions());\n+  options.emplace_back(\n+      new DictionaryEncodeOptions(DictionaryEncodeOptions::NullEncodingBehavior::ENCODE));\n+  options.emplace_back(new ArraySortOptions());\n+  options.emplace_back(new ArraySortOptions(SortOrder::Descending));\n+  options.emplace_back(new SortOptions());\n+  options.emplace_back(new SortOptions({SortKey(\"key\", SortOrder::Ascending)}));\n+  options.emplace_back(new SortOptions({SortKey(\"key\", SortOrder::Descending)}));\n+  options.emplace_back(new PartitionNthOptions(/*pivot=*/0));\n+  options.emplace_back(new PartitionNthOptions(/*pivot=*/42));\n+\n+  for (size_t i = 0; i < options.size(); i++) {\n+    const size_t prev_i = i == 0 ? options.size() - 1 : i - 1;\n+    const FunctionOptions& cur = *options[i];\n+    const FunctionOptions& prev = *options[prev_i];\n+    ASSERT_TRUE(cur.Equals(cur)) << cur.ToString();\n\nReview comment:\n       Could you add `operator==` and `PrintTo` so these can just be written\r\n   ```suggestion\r\n       ASSERT_EQ(cur, cur);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/registry.h\n##########\n@@ -32,6 +32,9 @@ namespace arrow {\n namespace compute {\n \n class Function;\n+namespace internal {\n+class FunctionOptionsType;\n\nReview comment:\n       I don't think FunctionOptionsType itself needs to be internal/opaque. Instead we can have the public methods  be Serialize/Deserialize and let To/FromStructScalar be the internal details\n\n##########\nFile path: cpp/src/arrow/compute/cast.cc\n##########\n@@ -38,6 +40,93 @@ using internal::ToTypeName;\n namespace compute {\n namespace internal {\n \n+// ----------------------------------------------------------------------\n+// Function options\n+\n+namespace {\n+class CastOptionsType : public internal::FunctionOptionsType {\n+ public:\n+  static const internal::FunctionOptionsType* GetInstance() {\n+    static std::unique_ptr<internal::FunctionOptionsType> instance(new CastOptionsType());\n+    return instance.get();\n\nReview comment:\n       ```suggestion\r\n       static const CastOptionsType instance;\r\n       return &instance;\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-18T20:53:03.096+0000",
                    "updated": "2021-06-18T20:53:03.096+0000",
                    "started": "2021-06-18T20:53:03.096+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "611883",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/612830",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-865277706\n\n\n   @lidavidm https://github.com/apache/arrow/commit/676c9020e87c5f8d1f4d325794931df9f0481ec4\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-21T19:10:04.536+0000",
                    "updated": "2021-06-21T19:10:04.536+0000",
                    "started": "2021-06-21T19:10:04.536+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "612830",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/612831",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-865278168\n\n\n   Thanks! I'll circle back to this soon\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-21T19:10:47.704+0000",
                    "updated": "2021-06-21T19:10:47.704+0000",
                    "started": "2021-06-21T19:10:47.704+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "612831",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/613102",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-865277706\n\n\n   @lidavidm https://github.com/apache/arrow/commit/676c9020e87c5f8d1f4d325794931df9f0481ec4\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-22T07:47:48.164+0000",
                    "updated": "2021-06-22T07:47:48.164+0000",
                    "started": "2021-06-22T07:47:48.163+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "613102",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/613223",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-865278168\n\n\n   Thanks! I'll circle back to this soon\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-22T08:03:17.857+0000",
                    "updated": "2021-06-22T08:03:17.857+0000",
                    "started": "2021-06-22T08:03:17.857+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "613223",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/613667",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-866268714\n\n\n   Alright, I've pushed half a stab at this - I'm going to pick up ARROW-11932 so I can write a generic serialization for `vector<T>` (where `T` itself is serializable to Scalar). We'll also probably want some way to cut down on the boilerplate for enums - right now I have a set of partially specialized traits to handle enums, which are a little tedious to implement; a macro would probably help there.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-22T19:24:37.463+0000",
                    "updated": "2021-06-22T19:24:37.463+0000",
                    "started": "2021-06-22T19:24:37.463+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "613667",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/615741",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#discussion_r659950211\n\n\n\n##########\nFile path: cpp/src/arrow/array/builder_base.cc\n##########\n@@ -92,6 +95,119 @@ Status ArrayBuilder::Advance(int64_t elements) {\n   return null_bitmap_builder_.Advance(elements);\n }\n \n+struct AppendScalarImpl {\n+  template <typename T, typename AppendScalar,\n+            typename BuilderType = typename TypeTraits<T>::BuilderType,\n+            typename ScalarType = typename TypeTraits<T>::ScalarType>\n+  Status UseBuilder(const AppendScalar& append) {\n+    for (const auto scalar : scalars_) {\n+      if (scalar->is_valid) {\n+        RETURN_NOT_OK(append(internal::checked_cast<const ScalarType&>(*scalar),\n+                             static_cast<BuilderType*>(builder_)));\n+      } else {\n+        RETURN_NOT_OK(builder_->AppendNull());\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  struct AppendValue {\n+    template <typename BuilderType, typename ScalarType>\n+    Status operator()(const ScalarType& s, BuilderType* builder) const {\n+      return builder->Append(s.value);\n+    }\n+  };\n+\n+  struct AppendBuffer {\n+    template <typename BuilderType, typename ScalarType>\n+    Status operator()(const ScalarType& s, BuilderType* builder) const {\n+      const Buffer& buffer = *s.value;\n+      return builder->Append(util::string_view{buffer});\n+    }\n+  };\n+\n+  struct AppendList {\n+    template <typename BuilderType, typename ScalarType>\n+    Status operator()(const ScalarType& s, BuilderType* builder) const {\n+      RETURN_NOT_OK(builder->Append());\n+      const Array& list = *s.value;\n+      for (int64_t i = 0; i < list.length(); i++) {\n+        ARROW_ASSIGN_OR_RAISE(auto scalar, list.GetScalar(i));\n+        RETURN_NOT_OK(builder->value_builder()->AppendScalar(*scalar));\n+      }\n+      return Status::OK();\n+    }\n+  };\n+\n+  template <typename T>\n+  enable_if_has_c_type<T, Status> Visit(const T&) {\n+    return UseBuilder<T>(AppendValue{});\n+  }\n+\n+  template <typename T>\n+  enable_if_has_string_view<T, Status> Visit(const T&) {\n+    return UseBuilder<T>(AppendBuffer{});\n+  }\n+\n+  template <typename T>\n+  enable_if_decimal<T, Status> Visit(const T&) {\n+    return UseBuilder<T>(AppendValue{});\n+  }\n+\n+  template <typename T>\n+  enable_if_list_like<T, Status> Visit(const T&) {\n+    return UseBuilder<T>(AppendList{});\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    auto* builder = static_cast<StructBuilder*>(builder_);\n+    for (const auto s : scalars_) {\n+      const auto& scalar = internal::checked_cast<const StructScalar&>(*s);\n+      for (int field_index = 0; field_index < type.num_fields(); ++field_index) {\n+        if (!scalar.is_valid || !scalar.value[field_index]) {\n+          RETURN_NOT_OK(builder->field_builder(field_index)->AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder->field_builder(field_index)\n+                            ->AppendScalar(*scalar.value[field_index]));\n+        }\n+      }\n+      RETURN_NOT_OK(builder->Append(scalar.is_valid));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"AppendScalar for type \", type);\n+  }\n+\n+  Status Convert() { return VisitTypeInline(*scalars_[0]->type, this); }\n+\n+  std::vector<const Scalar*> scalars_;\n+  ArrayBuilder* builder_;\n+};\n+\n+Status ArrayBuilder::AppendScalar(const Scalar& scalar) {\n+  if (!scalar.type->Equals(type())) {\n+    return Status::Invalid(\"Cannot append scalar of type \", scalar.type->ToString(),\n+                           \" to builder for type \", type()->ToString());\n+  }\n+  return AppendScalarImpl{{&scalar}, this}.Convert();\n+}\n+\n+Status ArrayBuilder::AppendScalars(const ScalarVector& scalars) {\n+  if (scalars.empty()) return Status::OK();\n+  std::vector<const Scalar*> refs;\n+  refs.reserve(scalars.size());\n+  for (const auto& scalar : scalars) {\n+    if (!scalar->type->Equals(type())) {\n\nReview comment:\n       `ArrayBuilder::type` is virtual, so it should be kept out of loops when possible\r\n   \r\n   ```suggestion\r\n     auto builder_type = type();\r\n     for (const auto& scalar : scalars) {\r\n       if (!scalar->type->Equals(*builder_type)) {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/array/builder_base.cc\n##########\n@@ -92,6 +95,119 @@ Status ArrayBuilder::Advance(int64_t elements) {\n   return null_bitmap_builder_.Advance(elements);\n }\n \n+struct AppendScalarImpl {\n+  template <typename T, typename AppendScalar,\n+            typename BuilderType = typename TypeTraits<T>::BuilderType,\n+            typename ScalarType = typename TypeTraits<T>::ScalarType>\n+  Status UseBuilder(const AppendScalar& append) {\n+    for (const auto scalar : scalars_) {\n+      if (scalar->is_valid) {\n+        RETURN_NOT_OK(append(internal::checked_cast<const ScalarType&>(*scalar),\n+                             static_cast<BuilderType*>(builder_)));\n+      } else {\n+        RETURN_NOT_OK(builder_->AppendNull());\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  struct AppendValue {\n+    template <typename BuilderType, typename ScalarType>\n+    Status operator()(const ScalarType& s, BuilderType* builder) const {\n+      return builder->Append(s.value);\n+    }\n+  };\n+\n+  struct AppendBuffer {\n+    template <typename BuilderType, typename ScalarType>\n+    Status operator()(const ScalarType& s, BuilderType* builder) const {\n+      const Buffer& buffer = *s.value;\n+      return builder->Append(util::string_view{buffer});\n+    }\n+  };\n+\n+  struct AppendList {\n+    template <typename BuilderType, typename ScalarType>\n+    Status operator()(const ScalarType& s, BuilderType* builder) const {\n+      RETURN_NOT_OK(builder->Append());\n+      const Array& list = *s.value;\n+      for (int64_t i = 0; i < list.length(); i++) {\n+        ARROW_ASSIGN_OR_RAISE(auto scalar, list.GetScalar(i));\n+        RETURN_NOT_OK(builder->value_builder()->AppendScalar(*scalar));\n+      }\n+      return Status::OK();\n+    }\n+  };\n+\n+  template <typename T>\n+  enable_if_has_c_type<T, Status> Visit(const T&) {\n+    return UseBuilder<T>(AppendValue{});\n+  }\n+\n+  template <typename T>\n+  enable_if_has_string_view<T, Status> Visit(const T&) {\n+    return UseBuilder<T>(AppendBuffer{});\n+  }\n+\n+  template <typename T>\n+  enable_if_decimal<T, Status> Visit(const T&) {\n+    return UseBuilder<T>(AppendValue{});\n+  }\n+\n+  template <typename T>\n+  enable_if_list_like<T, Status> Visit(const T&) {\n+    return UseBuilder<T>(AppendList{});\n+  }\n+\n+  Status Visit(const StructType& type) {\n+    auto* builder = static_cast<StructBuilder*>(builder_);\n+    for (const auto s : scalars_) {\n+      const auto& scalar = internal::checked_cast<const StructScalar&>(*s);\n+      for (int field_index = 0; field_index < type.num_fields(); ++field_index) {\n+        if (!scalar.is_valid || !scalar.value[field_index]) {\n+          RETURN_NOT_OK(builder->field_builder(field_index)->AppendNull());\n+        } else {\n+          RETURN_NOT_OK(builder->field_builder(field_index)\n+                            ->AppendScalar(*scalar.value[field_index]));\n+        }\n+      }\n+      RETURN_NOT_OK(builder->Append(scalar.is_valid));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DataType& type) {\n+    return Status::NotImplemented(\"AppendScalar for type \", type);\n+  }\n+\n+  Status Convert() { return VisitTypeInline(*scalars_[0]->type, this); }\n+\n+  std::vector<const Scalar*> scalars_;\n\nReview comment:\n       Instead, let's ensure the ScalarVector case doesn't incur allocation or other O(N) costs:\r\n   ```suggestion\r\n     const std::shared_ptr<Scalar>* scalars_begin_;\r\n     const std::shared_ptr<Scalar>* scalars_end_;\r\n   ```\r\n   \r\n   We can accommodate `ArrayBuilder::AppendScalar(const Scalar& scalar)` by declaring a shared pointer with an empty destructor:\r\n   \r\n   ```c++\r\n   Status ArrayBuilder::AppendScalar(const Scalar& scalar) {\r\n     // ...\r\n     std::shared_ptr<Scalar> shared{&scalar, [](Scalar*) {}};\r\n     return AppendScalarImpl{&shared, &shared + 1, this}.Convert();\r\n   }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/util_internal.h\n##########\n@@ -17,6 +17,9 @@\n \n #pragma once\n \n+#include <iosfwd>\n+#include <vector>\n+\n\nReview comment:\n       ```suggestion\r\n   ```\r\n   \r\n   These headers should be included directly by the files which need them\n\n##########\nFile path: cpp/src/arrow/compute/function.h\n##########\n@@ -39,12 +40,49 @@ namespace compute {\n ///\n /// @{\n \n+/// \\brief Extension point for defining options outside libarrow (but\n+/// still within this project).\n+class ARROW_EXPORT FunctionOptionsType {\n+ public:\n+  virtual ~FunctionOptionsType() = default;\n+\n+  virtual const char* type_name() const = 0;\n+  virtual std::string Stringify(const FunctionOptions&) const = 0;\n+  virtual bool Compare(const FunctionOptions&, const FunctionOptions&) const = 0;\n+  /// \\brief Convert this options struct into a Struct scalar.\n+  virtual Status ToStructScalar(const FunctionOptions&,\n+                                std::vector<std::string>* field_names,\n+                                std::vector<std::shared_ptr<Scalar>>* values) const;\n+  /// \\brief Deserialize an options struct from a Struct scalar.\n+  virtual Result<std::unique_ptr<FunctionOptions>> FromStructScalar(\n+      const StructScalar& scalar) const;\n+};\n+\n /// \\brief Base class for specifying options configuring a function's behavior,\n /// such as error handling.\n-struct ARROW_EXPORT FunctionOptions {\n+class ARROW_EXPORT FunctionOptions : public util::EqualityComparable<FunctionOptions> {\n+ public:\n   virtual ~FunctionOptions() = default;\n+\n+  const FunctionOptionsType* options_type() const { return options_type_; }\n\nReview comment:\n       ```suggestion\r\n     const FunctionOptionsType* options_type() const { return options_type_; }\r\n     const char* type_name() const { return options_type()->type_name(); }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/api_scalar.h\n##########\n@@ -178,23 +206,22 @@ enum CompareOperator : int8_t {\n   LESS_EQUAL,\n };\n \n-struct CompareOptions : public FunctionOptions {\n-  explicit CompareOptions(CompareOperator op) : op(op) {}\n+class ARROW_EXPORT CompareOptions : public FunctionOptions {\n\nReview comment:\n       CompareOptions are not actually used by any compute::Function and should probably not inherit `FunctionOptions` at all\n\n##########\nFile path: cpp/src/arrow/compute/exec/expression.cc\n##########\n@@ -994,86 +936,14 @@ Result<Expression> SimplifyWithGuarantee(Expression expr,\n \n namespace {\n \n-Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n-    const Expression::Call& call) {\n-  if (call.options == nullptr) {\n-    return nullptr;\n-  }\n-\n-  if (auto options = GetSetLookupOptions(call)) {\n-    if (!options->value_set.is_array()) {\n-      return Status::NotImplemented(\"chunked value_set\");\n-    }\n-    return StructScalar::Make(\n-        {\n-            std::make_shared<ListScalar>(options->value_set.make_array()),\n-            MakeScalar(options->skip_nulls),\n-        },\n-        {\"value_set\", \"skip_nulls\"});\n-  }\n-\n-  if (auto options = GetCastOptions(call)) {\n-    return StructScalar::Make(\n-        {\n-            MakeNullScalar(options->to_type),\n-            MakeScalar(options->allow_int_overflow),\n-            MakeScalar(options->allow_time_truncate),\n-            MakeScalar(options->allow_time_overflow),\n-            MakeScalar(options->allow_decimal_truncate),\n-            MakeScalar(options->allow_float_truncate),\n-            MakeScalar(options->allow_invalid_utf8),\n-        },\n-        {\n-            \"to_type_holder\",\n-            \"allow_int_overflow\",\n-            \"allow_time_truncate\",\n-            \"allow_time_overflow\",\n-            \"allow_decimal_truncate\",\n-            \"allow_float_truncate\",\n-            \"allow_invalid_utf8\",\n-        });\n-  }\n-\n-  return Status::NotImplemented(\"conversion of options for \", call.function_name);\n-}\n-\n Status FunctionOptionsFromStructScalar(const StructScalar* repr, Expression::Call* call) {\n\nReview comment:\n       This can just be inlined now\n\n##########\nFile path: cpp/src/arrow/compute/function_internal.h\n##########\n@@ -0,0 +1,565 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/builder_base.h\"\n+#include \"arrow/array/builder_binary.h\"\n+#include \"arrow/array/builder_nested.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+struct Scalar;\n+struct StructScalar;\n+using ::arrow::internal::checked_cast;\n+namespace compute {\n+namespace internal {\n+ARROW_EXPORT\n+Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const FunctionOptions&);\n+ARROW_EXPORT\n+Result<std::unique_ptr<FunctionOptions>> FunctionOptionsFromStructScalar(\n+    const StructScalar&);\n+\n+template <typename T>\n+struct PropertyToString {\n+  static std::string ToString(const T& value) {\n+    std::stringstream ss;\n+    ss << value;\n+    return ss.str();\n+  }\n+};\n\nReview comment:\n       Instead of being trait structures, these should probably be free functions like\r\n   ```suggestion\r\n   template <typename T>\r\n   static std::string GenericToString(const T& value) {\r\n     std::stringstream ss;\r\n     ss << value;\r\n     return ss.str();\r\n   }\r\n   ```\r\n   \r\n   which will be less boilerplate\n\n##########\nFile path: cpp/src/arrow/compute/function_internal.h\n##########\n@@ -0,0 +1,565 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/builder_base.h\"\n+#include \"arrow/array/builder_binary.h\"\n+#include \"arrow/array/builder_nested.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+struct Scalar;\n+struct StructScalar;\n+using ::arrow::internal::checked_cast;\n+namespace compute {\n+namespace internal {\n+ARROW_EXPORT\n+Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const FunctionOptions&);\n+ARROW_EXPORT\n+Result<std::unique_ptr<FunctionOptions>> FunctionOptionsFromStructScalar(\n+    const StructScalar&);\n+\n+template <typename T>\n+struct PropertyToString {\n+  static std::string ToString(const T& value) {\n+    std::stringstream ss;\n+    ss << value;\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<bool> {\n+  static std::string ToString(bool value) { return value ? \"true\" : \"false\"; }\n+};\n+template <>\n+struct PropertyToString<std::string> {\n+  static std::string ToString(const std::string& value) {\n+    std::stringstream ss;\n+    ss << '\"' << value << '\"';\n+    return ss.str();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::shared_ptr<T>> {\n+  static std::string ToString(const std::shared_ptr<T>& value) {\n+    std::stringstream ss;\n+    return value ? value->ToString() : \"<NULLPTR>\";\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<Scalar>> {\n+  static std::string ToString(const std::shared_ptr<Scalar>& value) {\n+    std::stringstream ss;\n+    ss << value->type->ToString() << \":\" << value->ToString();\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<const KeyValueMetadata>> {\n+  static std::string ToString(const std::shared_ptr<const KeyValueMetadata>& value) {\n+    std::stringstream ss;\n+    ss << \"KeyValueMetadata{\";\n+    if (value) {\n+      bool first = true;\n+      for (const auto& pair : value->sorted_pairs()) {\n+        if (!first) ss << \", \";\n+        first = false;\n+        ss << pair.first << ':' << pair.second;\n+      }\n+    }\n+    ss << '}';\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<Datum> {\n+  static std::string ToString(const Datum& value) {\n+    switch (value.kind()) {\n+      case Datum::NONE:\n+        return \"<NULL DATUM>\";\n+      case Datum::SCALAR:\n+        return PropertyToString<std::shared_ptr<Scalar>>::ToString(value.scalar());\n+      case Datum::ARRAY: {\n+        std::stringstream ss;\n+        ss << value.type()->ToString() << ':' << value.make_array()->ToString();\n+        return ss.str();\n+      }\n+      case Datum::CHUNKED_ARRAY:\n+      case Datum::RECORD_BATCH:\n+      case Datum::TABLE:\n+      case Datum::COLLECTION:\n+        return value.ToString();\n+    }\n+    return value.ToString();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::vector<T>> {\n+  static std::string ToString(const std::vector<T>& value) {\n+    std::stringstream ss;\n+    ss << \"[\";\n+    bool first = true;\n+    // Don't use range-for with auto& to avoid Clang -Wrange-loop-analysis\n+    for (auto it = value.begin(); it != value.end(); it++) {\n+      if (!first) ss << \", \";\n+      first = false;\n+      ss << PropertyToString<T>::ToString(*it);\n+    }\n+    ss << ']';\n+    return ss.str();\n+  }\n+};\n+\n+template <typename T>\n+struct PropertyEquals {\n+  static bool Equals(const T& left, const T& right) { return left == right; }\n+};\n+template <typename T>\n+struct PropertyEquals<std::shared_ptr<T>> {\n+  static bool Equals(const std::shared_ptr<T>& left, const std::shared_ptr<T>& right) {\n+    return (!left && !right) || (left && right && left->Equals(*right));\n+  }\n+};\n+template <>\n+struct PropertyEquals<std::shared_ptr<const KeyValueMetadata>> {\n+  static bool Equals(const std::shared_ptr<const KeyValueMetadata>& left,\n+                     const std::shared_ptr<const KeyValueMetadata>& right) {\n+    // Special case since we serialize a null metadata into an empty one\n\nReview comment:\n       ```suggestion\r\n       // Special case since null metadata is considered equivalent to empty\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/function_internal.h\n##########\n@@ -0,0 +1,565 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/builder_base.h\"\n+#include \"arrow/array/builder_binary.h\"\n+#include \"arrow/array/builder_nested.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+struct Scalar;\n+struct StructScalar;\n+using ::arrow::internal::checked_cast;\n+namespace compute {\n+namespace internal {\n+ARROW_EXPORT\n+Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const FunctionOptions&);\n+ARROW_EXPORT\n+Result<std::unique_ptr<FunctionOptions>> FunctionOptionsFromStructScalar(\n+    const StructScalar&);\n+\n+template <typename T>\n+struct PropertyToString {\n+  static std::string ToString(const T& value) {\n+    std::stringstream ss;\n+    ss << value;\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<bool> {\n+  static std::string ToString(bool value) { return value ? \"true\" : \"false\"; }\n+};\n+template <>\n+struct PropertyToString<std::string> {\n+  static std::string ToString(const std::string& value) {\n+    std::stringstream ss;\n+    ss << '\"' << value << '\"';\n+    return ss.str();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::shared_ptr<T>> {\n+  static std::string ToString(const std::shared_ptr<T>& value) {\n+    std::stringstream ss;\n+    return value ? value->ToString() : \"<NULLPTR>\";\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<Scalar>> {\n+  static std::string ToString(const std::shared_ptr<Scalar>& value) {\n+    std::stringstream ss;\n+    ss << value->type->ToString() << \":\" << value->ToString();\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<const KeyValueMetadata>> {\n+  static std::string ToString(const std::shared_ptr<const KeyValueMetadata>& value) {\n+    std::stringstream ss;\n+    ss << \"KeyValueMetadata{\";\n+    if (value) {\n+      bool first = true;\n+      for (const auto& pair : value->sorted_pairs()) {\n+        if (!first) ss << \", \";\n+        first = false;\n+        ss << pair.first << ':' << pair.second;\n+      }\n+    }\n+    ss << '}';\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<Datum> {\n+  static std::string ToString(const Datum& value) {\n+    switch (value.kind()) {\n+      case Datum::NONE:\n+        return \"<NULL DATUM>\";\n+      case Datum::SCALAR:\n+        return PropertyToString<std::shared_ptr<Scalar>>::ToString(value.scalar());\n+      case Datum::ARRAY: {\n+        std::stringstream ss;\n+        ss << value.type()->ToString() << ':' << value.make_array()->ToString();\n+        return ss.str();\n+      }\n+      case Datum::CHUNKED_ARRAY:\n+      case Datum::RECORD_BATCH:\n+      case Datum::TABLE:\n+      case Datum::COLLECTION:\n+        return value.ToString();\n+    }\n+    return value.ToString();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::vector<T>> {\n+  static std::string ToString(const std::vector<T>& value) {\n+    std::stringstream ss;\n+    ss << \"[\";\n+    bool first = true;\n+    // Don't use range-for with auto& to avoid Clang -Wrange-loop-analysis\n+    for (auto it = value.begin(); it != value.end(); it++) {\n+      if (!first) ss << \", \";\n+      first = false;\n+      ss << PropertyToString<T>::ToString(*it);\n+    }\n+    ss << ']';\n+    return ss.str();\n+  }\n+};\n+\n+template <typename T>\n+struct PropertyEquals {\n+  static bool Equals(const T& left, const T& right) { return left == right; }\n+};\n+template <typename T>\n+struct PropertyEquals<std::shared_ptr<T>> {\n+  static bool Equals(const std::shared_ptr<T>& left, const std::shared_ptr<T>& right) {\n+    return (!left && !right) || (left && right && left->Equals(*right));\n+  }\n+};\n+template <>\n+struct PropertyEquals<std::shared_ptr<const KeyValueMetadata>> {\n+  static bool Equals(const std::shared_ptr<const KeyValueMetadata>& left,\n+                     const std::shared_ptr<const KeyValueMetadata>& right) {\n+    // Special case since we serialize a null metadata into an empty one\n+    return (!left && !right) || (left && right && left->Equals(*right)) ||\n+           (!left && right && right->size() == 0) ||\n+           (left && !right && left->size() == 0);\n+  }\n+};\n+template <typename T>\n+struct PropertyEquals<std::vector<T>> {\n+  static bool Equals(const std::vector<T>& left, const std::vector<T>& right) {\n+    if (left.size() != right.size()) return false;\n+    for (size_t i = 0; i < left.size(); i++) {\n+      if (!PropertyEquals<T>::Equals(left[i], right[i])) return false;\n+    }\n+    return true;\n+  }\n+};\n+\n+template <typename T, typename Enable = void>\n+struct PropertyToScalar {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const T& value) {\n+    return Status::NotImplemented(\"Cannot serialize field\");\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+template <typename T>\n+struct PropertyToScalar<\n+    T, arrow::internal::void_t<decltype(MakeScalar(std::declval<T>()))>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const T& value) {\n+    return MakeScalar(value);\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return TypeTraits<typename CTypeTraits<T>::ArrowType>::type_singleton();\n+  }\n+};\n+template <typename T>\n+struct PropertyToScalar<std::vector<T>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const std::vector<T>& value) {\n+    std::shared_ptr<DataType> type;\n+    if (value.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(type, PropertyToScalar<T>::GetTypeSingleton());\n+    }\n+    std::vector<std::shared_ptr<Scalar>> scalars;\n+    scalars.reserve(value.size());\n+    // Don't use range-for with auto& to avoid Clang -Wrange-loop-analysis\n+    for (auto it = value.begin(); it != value.end(); it++) {\n+      ARROW_ASSIGN_OR_RAISE(auto scalar, PropertyToScalar<T>::ToScalar(*it));\n+      scalars.push_back(std::move(scalar));\n+    }\n+    std::unique_ptr<ArrayBuilder> builder;\n+    RETURN_NOT_OK(\n+        MakeBuilder(default_memory_pool(), type ? type : scalars[0]->type, &builder));\n+    RETURN_NOT_OK(builder->AppendScalars(scalars));\n+    std::shared_ptr<Array> out;\n+    RETURN_NOT_OK(builder->Finish(&out));\n+    return std::make_shared<ListScalar>(std::move(out));\n+  }\n+};\n+template <>\n+struct PropertyToScalar<std::shared_ptr<const KeyValueMetadata>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(\n+      const std::shared_ptr<const KeyValueMetadata>& value) {\n+    ARROW_ASSIGN_OR_RAISE(auto ty, GetTypeSingleton());\n+    std::unique_ptr<ArrayBuilder> builder;\n+    RETURN_NOT_OK(MakeBuilder(default_memory_pool(), ty, &builder));\n+    auto* map_builder = checked_cast<MapBuilder*>(builder.get());\n+    auto* key_builder = checked_cast<BinaryBuilder*>(map_builder->key_builder());\n+    auto* item_builder = checked_cast<BinaryBuilder*>(map_builder->item_builder());\n+    RETURN_NOT_OK(map_builder->Append());\n+    if (value) {\n+      RETURN_NOT_OK(key_builder->AppendValues(value->keys()));\n+      RETURN_NOT_OK(item_builder->AppendValues(value->values()));\n+    }\n+    std::shared_ptr<Array> arr;\n+    RETURN_NOT_OK(map_builder->Finish(&arr));\n+    return arr->GetScalar(0);\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return map(binary(), binary());\n+  }\n+};\n+template <>\n+struct PropertyToScalar<std::shared_ptr<DataType>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(\n+      const std::shared_ptr<DataType>& value) {\n+    if (!value) {\n+      return Status::Invalid(\"shared_ptr<DataType> is nullptr\");\n+    }\n+    return MakeNullScalar(value);\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+template <>\n+struct PropertyToScalar<std::shared_ptr<Scalar>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const std::shared_ptr<Scalar>& value) {\n+    return value;\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+template <>\n+struct PropertyToScalar<std::shared_ptr<Array>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const std::shared_ptr<Array>& value) {\n+    return std::make_shared<ListScalar>(value);\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+template <>\n+struct PropertyToScalar<Datum> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const Datum& value) {\n+    // TODO(ARROW-9434): store in a union instead.\n+    switch (value.kind()) {\n+      case Datum::ARRAY:\n+        return PropertyToScalar<std::shared_ptr<Array>>::ToScalar(value.make_array());\n+        break;\n+      default:\n+        return Status::NotImplemented(\"Cannot serialize Datum kind \", value.kind());\n+    }\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+\n+template <typename T, typename Enable = void>\n+struct PropertyFromScalar {\n+  static Result<T> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    return Status::NotImplemented(\"Cannot deserialize field\");\n+  }\n+};\n+template <typename T>\n+struct PropertyFromScalar<T,\n+                          enable_if_primitive_ctype<typename CTypeTraits<T>::ArrowType>> {\n+  using ArrowType = typename CTypeTraits<T>::ArrowType;\n+  using ScalarType = typename TypeTraits<ArrowType>::ScalarType;\n+  static Result<T> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    if (value->type->id() != ArrowType::type_id) {\n+      return Status::Invalid(\"Expected type \", ArrowType::type_id, \" but got \",\n+                             value->type->ToString());\n+    }\n+    const auto& holder = checked_cast<const ScalarType&>(*value);\n+    if (!holder.is_valid) return Status::Invalid(\"Got null scalar\");\n+    return holder.value;\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<std::string> {\n+  static Result<std::string> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    if (!is_base_binary_like(value->type->id())) {\n+      return Status::Invalid(\"Expected binary-like type but got \",\n+                             value->type->ToString());\n+    }\n+    const auto& holder = checked_cast<const BaseBinaryScalar&>(*value);\n+    if (!holder.is_valid) return Status::Invalid(\"Got null scalar\");\n+    return holder.value->ToString();\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<std::shared_ptr<DataType>> {\n+  static Result<std::shared_ptr<DataType>> FromScalar(\n+      const std::shared_ptr<Scalar>& value) {\n+    return value->type;\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<std::shared_ptr<Scalar>> {\n+  static Result<std::shared_ptr<Scalar>> FromScalar(\n+      const std::shared_ptr<Scalar>& value) {\n+    return value;\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<std::shared_ptr<const KeyValueMetadata>> {\n+  static Result<std::shared_ptr<const KeyValueMetadata>> FromScalar(\n+      const std::shared_ptr<Scalar>& value) {\n+    ARROW_ASSIGN_OR_RAISE(\n+        const auto ty,\n+        PropertyToScalar<std::shared_ptr<const KeyValueMetadata>>::GetTypeSingleton());\n+    if (!value->type->Equals(ty)) {\n+      return Status::Invalid(\"Expected \", ty->ToString(), \" but got \",\n+                             value->type->ToString());\n+    }\n+    const auto& holder = checked_cast<const MapScalar&>(*value);\n+    std::vector<std::string> keys;\n+    std::vector<std::string> values;\n+    const auto& list = checked_cast<const StructArray&>(*holder.value);\n+    const auto& key_arr = checked_cast<const BinaryArray&>(*list.field(0));\n+    const auto& value_arr = checked_cast<const BinaryArray&>(*list.field(1));\n+    for (int64_t i = 0; i < list.length(); i++) {\n+      keys.push_back(key_arr.GetString(i));\n+      values.push_back(value_arr.GetString(i));\n+    }\n+    return key_value_metadata(std::move(keys), std::move(values));\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<Datum> {\n+  static Result<Datum> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    if (value->type->id() == Type::LIST) {\n+      const auto& holder = checked_cast<const BaseListScalar&>(*value);\n+      return holder.value;\n+    }\n+    // TODO(ARROW-9434): handle other possible datum kinds by looking for a union\n+    return Status::Invalid(\"Cannot deserialize Datum from \", value->ToString());\n+  }\n+};\n+\n+template <typename T>\n+struct PropertyFromScalar<std::vector<T>> {\n+  static Result<std::vector<T>> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    if (value->type->id() != Type::LIST) {\n+      return Status::Invalid(\"Expected type LIST but got \", value->type->ToString());\n+    }\n+    const auto& holder = checked_cast<const BaseListScalar&>(*value);\n+    if (!holder.is_valid) return Status::Invalid(\"Got null scalar\");\n+    std::vector<T> result;\n+    for (int i = 0; i < holder.value->length(); i++) {\n+      ARROW_ASSIGN_OR_RAISE(auto scalar, holder.value->GetScalar(i));\n+      ARROW_ASSIGN_OR_RAISE(auto v, PropertyFromScalar<T>::FromScalar(scalar));\n+      result.push_back(std::move(v));\n+    }\n+    return result;\n+  }\n+};\n+\n+// Helper to quickly define serialization for a C-style enum\n+#define MAKE_ENUM_PROPERTY(ENUM, TYPE, MIN, MAX)                                        \\\n\nReview comment:\n       Instead, let's add some enum utilities to `reflection_internal.h`:\r\n   \r\n   ```c++\r\n   // reflection_internal.h\r\n   template <typename Enum>\r\n   struct EnumTraits;\r\n   \r\n   template <typename Enum,\r\n             typename CType = typename std::underlying_type<Enum>::type>\r\n   Status ValidateEnumValue(CType raw) {\r\n     for (auto valid : EnumTraits<Enum>::kValues) {\r\n       if (raw == static_cast<CType>(valid)) return Status::OK();\r\n     }\r\n     return Status::Invalid(\"Invalid value for \", EnumTraits<Enum>::kName, \": \", raw);\r\n   }\r\n   \r\n   template <typename Enum, Enum... E>\r\n   struct BasicEnumTraits {\r\n     static const std::array<Enum, sizeof...(E)> kValues = {E...};\r\n   };\r\n   \r\n   template <typename Enum,\r\n             typename CType = typename std::underlying_type<Enum>::type,\r\n             typename Type = typename CTypeTraits<T>::ArrowType>\r\n   static std::shared_ptr<DataType> UnderlyingType() {\r\n     return TypeTraits<Type>::type_singleton();\r\n   }\r\n   \r\n   template <>\r\n   struct EnumTraits<JoinOptions::NullHandlingBehavior>\r\n       : BasicEnumTraits<JoinOptions::NullHandlingBehavior,\r\n                             JoinOptions::NullHandlingBehavior::EMIT_NULL,\r\n                             JoinOptions::NullHandlingBehavior::SKIP,\r\n                             JoinOptions::NullHandlingBehavior::REPLACE> {\r\n     static constexpr char kName[] = \"JoinOptions::NullHandlingBehavior\";\r\n   };\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/api_aggregate.cc\n##########\n@@ -17,11 +17,112 @@\n \n #include \"arrow/compute/api_aggregate.h\"\n \n+#include <sstream>\n\nReview comment:\n       ```suggestion\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/function_internal.h\n##########\n@@ -0,0 +1,565 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/builder_base.h\"\n+#include \"arrow/array/builder_binary.h\"\n+#include \"arrow/array/builder_nested.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+struct Scalar;\n+struct StructScalar;\n+using ::arrow::internal::checked_cast;\n+namespace compute {\n+namespace internal {\n+ARROW_EXPORT\n+Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const FunctionOptions&);\n+ARROW_EXPORT\n+Result<std::unique_ptr<FunctionOptions>> FunctionOptionsFromStructScalar(\n+    const StructScalar&);\n+\n+template <typename T>\n+struct PropertyToString {\n+  static std::string ToString(const T& value) {\n+    std::stringstream ss;\n+    ss << value;\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<bool> {\n+  static std::string ToString(bool value) { return value ? \"true\" : \"false\"; }\n+};\n+template <>\n+struct PropertyToString<std::string> {\n+  static std::string ToString(const std::string& value) {\n+    std::stringstream ss;\n+    ss << '\"' << value << '\"';\n+    return ss.str();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::shared_ptr<T>> {\n+  static std::string ToString(const std::shared_ptr<T>& value) {\n+    std::stringstream ss;\n+    return value ? value->ToString() : \"<NULLPTR>\";\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<Scalar>> {\n+  static std::string ToString(const std::shared_ptr<Scalar>& value) {\n+    std::stringstream ss;\n+    ss << value->type->ToString() << \":\" << value->ToString();\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<const KeyValueMetadata>> {\n+  static std::string ToString(const std::shared_ptr<const KeyValueMetadata>& value) {\n+    std::stringstream ss;\n+    ss << \"KeyValueMetadata{\";\n+    if (value) {\n+      bool first = true;\n+      for (const auto& pair : value->sorted_pairs()) {\n+        if (!first) ss << \", \";\n+        first = false;\n+        ss << pair.first << ':' << pair.second;\n+      }\n+    }\n+    ss << '}';\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<Datum> {\n+  static std::string ToString(const Datum& value) {\n+    switch (value.kind()) {\n+      case Datum::NONE:\n+        return \"<NULL DATUM>\";\n+      case Datum::SCALAR:\n+        return PropertyToString<std::shared_ptr<Scalar>>::ToString(value.scalar());\n+      case Datum::ARRAY: {\n+        std::stringstream ss;\n+        ss << value.type()->ToString() << ':' << value.make_array()->ToString();\n+        return ss.str();\n+      }\n+      case Datum::CHUNKED_ARRAY:\n+      case Datum::RECORD_BATCH:\n+      case Datum::TABLE:\n+      case Datum::COLLECTION:\n+        return value.ToString();\n+    }\n+    return value.ToString();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::vector<T>> {\n+  static std::string ToString(const std::vector<T>& value) {\n+    std::stringstream ss;\n+    ss << \"[\";\n+    bool first = true;\n+    // Don't use range-for with auto& to avoid Clang -Wrange-loop-analysis\n+    for (auto it = value.begin(); it != value.end(); it++) {\n+      if (!first) ss << \", \";\n+      first = false;\n+      ss << PropertyToString<T>::ToString(*it);\n+    }\n+    ss << ']';\n+    return ss.str();\n+  }\n+};\n+\n+template <typename T>\n+struct PropertyEquals {\n+  static bool Equals(const T& left, const T& right) { return left == right; }\n+};\n+template <typename T>\n+struct PropertyEquals<std::shared_ptr<T>> {\n+  static bool Equals(const std::shared_ptr<T>& left, const std::shared_ptr<T>& right) {\n+    return (!left && !right) || (left && right && left->Equals(*right));\n\nReview comment:\n       ```suggestion\r\n       if (left && right) {\r\n         return left->Equals(*right);\r\n       }\r\n       return left == right;\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/function_test.cc\n##########\n@@ -21,16 +21,110 @@\n \n #include <gtest/gtest.h>\n \n+#include \"arrow/compute/api_aggregate.h\"\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/cast.h\"\n #include \"arrow/compute/function.h\"\n #include \"arrow/compute/kernel.h\"\n #include \"arrow/datum.h\"\n #include \"arrow/status.h\"\n #include \"arrow/testing/gtest_util.h\"\n #include \"arrow/type.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n \n namespace arrow {\n namespace compute {\n \n+TEST(FunctionOptions, Equality) {\n+  std::vector<std::shared_ptr<FunctionOptions>> options;\n+  options.emplace_back(new ScalarAggregateOptions());\n+  options.emplace_back(new ScalarAggregateOptions(/*skip_nulls=*/false, /*min_count=*/1));\n+  options.emplace_back(new ModeOptions());\n+  options.emplace_back(new ModeOptions(/*n=*/2));\n+  options.emplace_back(new VarianceOptions());\n+  options.emplace_back(new VarianceOptions(/*ddof=*/2));\n+  options.emplace_back(new QuantileOptions());\n+  options.emplace_back(\n+      new QuantileOptions(/*q=*/0.75, QuantileOptions::Interpolation::MIDPOINT));\n+  options.emplace_back(new TDigestOptions());\n+  options.emplace_back(\n+      new TDigestOptions(/*q=*/0.75, /*delta=*/50, /*buffer_size=*/1024));\n+  options.emplace_back(new IndexOptions(ScalarFromJSON(int64(), \"16\")));\n+  options.emplace_back(new IndexOptions(ScalarFromJSON(boolean(), \"true\")));\n+  options.emplace_back(new IndexOptions(ScalarFromJSON(boolean(), \"null\")));\n+  options.emplace_back(new ArithmeticOptions());\n+  options.emplace_back(new ArithmeticOptions(/*check_overflow=*/true));\n+  options.emplace_back(new ElementWiseAggregateOptions());\n+  options.emplace_back(new ElementWiseAggregateOptions(/*skip_nulls=*/false));\n+  options.emplace_back(new JoinOptions());\n+  options.emplace_back(new JoinOptions(JoinOptions::REPLACE, \"replacement\"));\n+  options.emplace_back(new MatchSubstringOptions(\"pattern\"));\n+  options.emplace_back(new MatchSubstringOptions(\"pattern\", /*ignore_case=*/true));\n+  options.emplace_back(new SplitOptions());\n+  options.emplace_back(new SplitOptions(/*max_splits=*/2, /*reverse=*/true));\n+  options.emplace_back(new SplitPatternOptions(\"pattern\"));\n+  options.emplace_back(\n+      new SplitPatternOptions(\"pattern\", /*max_splits=*/2, /*reverse=*/true));\n+  options.emplace_back(new ReplaceSubstringOptions(\"pattern\", \"replacement\"));\n+  options.emplace_back(\n+      new ReplaceSubstringOptions(\"pattern\", \"replacement\", /*max_replacements=*/2));\n+  options.emplace_back(new ReplaceSliceOptions(0, 1, \"foo\"));\n+  options.emplace_back(new ReplaceSliceOptions(1, -1, \"bar\"));\n+  options.emplace_back(new ExtractRegexOptions(\"pattern\"));\n+  options.emplace_back(new ExtractRegexOptions(\"pattern2\"));\n+  options.emplace_back(new SetLookupOptions(ArrayFromJSON(int64(), \"[1, 2, 3, 4]\")));\n+  options.emplace_back(new SetLookupOptions(ArrayFromJSON(boolean(), \"[true, false]\")));\n+  options.emplace_back(new StrptimeOptions(\"%Y\", TimeUnit::type::MILLI));\n+  options.emplace_back(new StrptimeOptions(\"%Y\", TimeUnit::type::NANO));\n+  options.emplace_back(new TrimOptions(\" \"));\n+  options.emplace_back(new TrimOptions(\"abc\"));\n+  options.emplace_back(new SliceOptions(/*start=*/1));\n+  options.emplace_back(new SliceOptions(/*start=*/1, /*stop=*/-5, /*step=*/-2));\n+  options.emplace_back(new CompareOptions(CompareOperator::EQUAL));\n+  options.emplace_back(new CompareOptions(CompareOperator::NOT_EQUAL));\n+  // N.B. we never actually use field_nullability or field_metadata in Arrow\n+  options.emplace_back(new ProjectOptions({\"col1\"}, {true}, {}));\n+  options.emplace_back(new ProjectOptions({\"col1\"}, {false}, {}));\n+  options.emplace_back(\n+      new ProjectOptions({\"col1\"}, {false}, {key_value_metadata({{\"key\", \"val\"}})}));\n+  options.emplace_back(new CastOptions(CastOptions::Safe(boolean())));\n+  options.emplace_back(new CastOptions(CastOptions::Unsafe(int64())));\n+  options.emplace_back(new FilterOptions());\n+  options.emplace_back(\n+      new FilterOptions(FilterOptions::NullSelectionBehavior::EMIT_NULL));\n+  options.emplace_back(new TakeOptions());\n+  options.emplace_back(new TakeOptions(/*boundscheck=*/false));\n+  options.emplace_back(new DictionaryEncodeOptions());\n+  options.emplace_back(\n+      new DictionaryEncodeOptions(DictionaryEncodeOptions::NullEncodingBehavior::ENCODE));\n+  options.emplace_back(new ArraySortOptions());\n+  options.emplace_back(new ArraySortOptions(SortOrder::Descending));\n+  options.emplace_back(new SortOptions());\n+  options.emplace_back(new SortOptions({SortKey(\"key\", SortOrder::Ascending)}));\n+  options.emplace_back(new SortOptions({SortKey(\"key\", SortOrder::Descending)}));\n+  options.emplace_back(new PartitionNthOptions(/*pivot=*/0));\n+  options.emplace_back(new PartitionNthOptions(/*pivot=*/42));\n+\n+  for (size_t i = 0; i < options.size(); i++) {\n+    const size_t prev_i = i == 0 ? options.size() - 1 : i - 1;\n+    const FunctionOptions& cur = *options[i];\n+    const FunctionOptions& prev = *options[prev_i];\n+    SCOPED_TRACE(cur.options_type()->type_name());\n+    SCOPED_TRACE(cur.ToString());\n+    ASSERT_TRUE(cur == cur);\n\nReview comment:\n       ```suggestion\r\n       ASSERT_EQ(cur, cur);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/function.h\n##########\n@@ -39,12 +40,49 @@ namespace compute {\n ///\n /// @{\n \n+/// \\brief Extension point for defining options outside libarrow (but\n+/// still within this project).\n+class ARROW_EXPORT FunctionOptionsType {\n+ public:\n+  virtual ~FunctionOptionsType() = default;\n+\n+  virtual const char* type_name() const = 0;\n+  virtual std::string Stringify(const FunctionOptions&) const = 0;\n+  virtual bool Compare(const FunctionOptions&, const FunctionOptions&) const = 0;\n+  /// \\brief Convert this options struct into a Struct scalar.\n+  virtual Status ToStructScalar(const FunctionOptions&,\n+                                std::vector<std::string>* field_names,\n+                                std::vector<std::shared_ptr<Scalar>>* values) const;\n\nReview comment:\n       Again, the public methods should be serialize/deserialize and from/to struct scalar can be details of `GenericOptionsType`\n\n##########\nFile path: cpp/src/arrow/compute/function_internal.h\n##########\n@@ -0,0 +1,565 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/builder_base.h\"\n+#include \"arrow/array/builder_binary.h\"\n+#include \"arrow/array/builder_nested.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+struct Scalar;\n+struct StructScalar;\n+using ::arrow::internal::checked_cast;\n+namespace compute {\n+namespace internal {\n+ARROW_EXPORT\n+Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const FunctionOptions&);\n+ARROW_EXPORT\n+Result<std::unique_ptr<FunctionOptions>> FunctionOptionsFromStructScalar(\n+    const StructScalar&);\n+\n+template <typename T>\n+struct PropertyToString {\n+  static std::string ToString(const T& value) {\n+    std::stringstream ss;\n+    ss << value;\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<bool> {\n+  static std::string ToString(bool value) { return value ? \"true\" : \"false\"; }\n+};\n+template <>\n+struct PropertyToString<std::string> {\n+  static std::string ToString(const std::string& value) {\n+    std::stringstream ss;\n+    ss << '\"' << value << '\"';\n+    return ss.str();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::shared_ptr<T>> {\n+  static std::string ToString(const std::shared_ptr<T>& value) {\n+    std::stringstream ss;\n+    return value ? value->ToString() : \"<NULLPTR>\";\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<Scalar>> {\n+  static std::string ToString(const std::shared_ptr<Scalar>& value) {\n+    std::stringstream ss;\n+    ss << value->type->ToString() << \":\" << value->ToString();\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<const KeyValueMetadata>> {\n+  static std::string ToString(const std::shared_ptr<const KeyValueMetadata>& value) {\n+    std::stringstream ss;\n+    ss << \"KeyValueMetadata{\";\n+    if (value) {\n+      bool first = true;\n+      for (const auto& pair : value->sorted_pairs()) {\n+        if (!first) ss << \", \";\n+        first = false;\n+        ss << pair.first << ':' << pair.second;\n+      }\n+    }\n+    ss << '}';\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<Datum> {\n+  static std::string ToString(const Datum& value) {\n+    switch (value.kind()) {\n+      case Datum::NONE:\n+        return \"<NULL DATUM>\";\n+      case Datum::SCALAR:\n+        return PropertyToString<std::shared_ptr<Scalar>>::ToString(value.scalar());\n+      case Datum::ARRAY: {\n+        std::stringstream ss;\n+        ss << value.type()->ToString() << ':' << value.make_array()->ToString();\n+        return ss.str();\n+      }\n+      case Datum::CHUNKED_ARRAY:\n+      case Datum::RECORD_BATCH:\n+      case Datum::TABLE:\n+      case Datum::COLLECTION:\n+        return value.ToString();\n+    }\n+    return value.ToString();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::vector<T>> {\n+  static std::string ToString(const std::vector<T>& value) {\n+    std::stringstream ss;\n+    ss << \"[\";\n+    bool first = true;\n+    // Don't use range-for with auto& to avoid Clang -Wrange-loop-analysis\n+    for (auto it = value.begin(); it != value.end(); it++) {\n+      if (!first) ss << \", \";\n+      first = false;\n+      ss << PropertyToString<T>::ToString(*it);\n+    }\n+    ss << ']';\n+    return ss.str();\n+  }\n+};\n+\n+template <typename T>\n+struct PropertyEquals {\n+  static bool Equals(const T& left, const T& right) { return left == right; }\n+};\n+template <typename T>\n+struct PropertyEquals<std::shared_ptr<T>> {\n+  static bool Equals(const std::shared_ptr<T>& left, const std::shared_ptr<T>& right) {\n+    return (!left && !right) || (left && right && left->Equals(*right));\n+  }\n+};\n+template <>\n+struct PropertyEquals<std::shared_ptr<const KeyValueMetadata>> {\n+  static bool Equals(const std::shared_ptr<const KeyValueMetadata>& left,\n+                     const std::shared_ptr<const KeyValueMetadata>& right) {\n+    // Special case since we serialize a null metadata into an empty one\n+    return (!left && !right) || (left && right && left->Equals(*right)) ||\n+           (!left && right && right->size() == 0) ||\n+           (left && !right && left->size() == 0);\n+  }\n\nReview comment:\n       ```suggestion\r\n       if (IsEmpty(left) || IsEmpty(right)) {\r\n         return IsEmpty(left) && IsEmpty(right);\r\n       }\r\n       return left->Equals(*right);\r\n     }\r\n     static bool IsEmpty(const std::shared_ptr<const KeyValueMetadata>& meta) {\r\n       return meta == nullptr || meta->size() == 0;\r\n     }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/function_internal.h\n##########\n@@ -0,0 +1,565 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/builder_base.h\"\n+#include \"arrow/array/builder_binary.h\"\n+#include \"arrow/array/builder_nested.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+struct Scalar;\n+struct StructScalar;\n+using ::arrow::internal::checked_cast;\n+namespace compute {\n+namespace internal {\n+ARROW_EXPORT\n+Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const FunctionOptions&);\n+ARROW_EXPORT\n+Result<std::unique_ptr<FunctionOptions>> FunctionOptionsFromStructScalar(\n+    const StructScalar&);\n+\n+template <typename T>\n+struct PropertyToString {\n+  static std::string ToString(const T& value) {\n+    std::stringstream ss;\n+    ss << value;\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<bool> {\n+  static std::string ToString(bool value) { return value ? \"true\" : \"false\"; }\n+};\n+template <>\n+struct PropertyToString<std::string> {\n+  static std::string ToString(const std::string& value) {\n+    std::stringstream ss;\n+    ss << '\"' << value << '\"';\n+    return ss.str();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::shared_ptr<T>> {\n+  static std::string ToString(const std::shared_ptr<T>& value) {\n+    std::stringstream ss;\n+    return value ? value->ToString() : \"<NULLPTR>\";\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<Scalar>> {\n+  static std::string ToString(const std::shared_ptr<Scalar>& value) {\n+    std::stringstream ss;\n+    ss << value->type->ToString() << \":\" << value->ToString();\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<const KeyValueMetadata>> {\n+  static std::string ToString(const std::shared_ptr<const KeyValueMetadata>& value) {\n+    std::stringstream ss;\n+    ss << \"KeyValueMetadata{\";\n+    if (value) {\n+      bool first = true;\n+      for (const auto& pair : value->sorted_pairs()) {\n+        if (!first) ss << \", \";\n+        first = false;\n+        ss << pair.first << ':' << pair.second;\n+      }\n+    }\n+    ss << '}';\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<Datum> {\n+  static std::string ToString(const Datum& value) {\n+    switch (value.kind()) {\n+      case Datum::NONE:\n+        return \"<NULL DATUM>\";\n+      case Datum::SCALAR:\n+        return PropertyToString<std::shared_ptr<Scalar>>::ToString(value.scalar());\n+      case Datum::ARRAY: {\n+        std::stringstream ss;\n+        ss << value.type()->ToString() << ':' << value.make_array()->ToString();\n+        return ss.str();\n+      }\n+      case Datum::CHUNKED_ARRAY:\n+      case Datum::RECORD_BATCH:\n+      case Datum::TABLE:\n+      case Datum::COLLECTION:\n+        return value.ToString();\n+    }\n+    return value.ToString();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::vector<T>> {\n+  static std::string ToString(const std::vector<T>& value) {\n+    std::stringstream ss;\n+    ss << \"[\";\n+    bool first = true;\n+    // Don't use range-for with auto& to avoid Clang -Wrange-loop-analysis\n\nReview comment:\n       I'm not sure why this needed to be avoided; shouldn't it be alright to use `const auto&`?\n\n##########\nFile path: cpp/src/arrow/compute/function_internal.h\n##########\n@@ -0,0 +1,565 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/builder_base.h\"\n+#include \"arrow/array/builder_binary.h\"\n+#include \"arrow/array/builder_nested.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+struct Scalar;\n+struct StructScalar;\n+using ::arrow::internal::checked_cast;\n+namespace compute {\n+namespace internal {\n+ARROW_EXPORT\n+Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const FunctionOptions&);\n+ARROW_EXPORT\n+Result<std::unique_ptr<FunctionOptions>> FunctionOptionsFromStructScalar(\n+    const StructScalar&);\n+\n+template <typename T>\n+struct PropertyToString {\n+  static std::string ToString(const T& value) {\n+    std::stringstream ss;\n+    ss << value;\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<bool> {\n+  static std::string ToString(bool value) { return value ? \"true\" : \"false\"; }\n+};\n+template <>\n+struct PropertyToString<std::string> {\n+  static std::string ToString(const std::string& value) {\n+    std::stringstream ss;\n+    ss << '\"' << value << '\"';\n+    return ss.str();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::shared_ptr<T>> {\n+  static std::string ToString(const std::shared_ptr<T>& value) {\n+    std::stringstream ss;\n+    return value ? value->ToString() : \"<NULLPTR>\";\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<Scalar>> {\n+  static std::string ToString(const std::shared_ptr<Scalar>& value) {\n+    std::stringstream ss;\n+    ss << value->type->ToString() << \":\" << value->ToString();\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<const KeyValueMetadata>> {\n+  static std::string ToString(const std::shared_ptr<const KeyValueMetadata>& value) {\n+    std::stringstream ss;\n+    ss << \"KeyValueMetadata{\";\n+    if (value) {\n+      bool first = true;\n+      for (const auto& pair : value->sorted_pairs()) {\n+        if (!first) ss << \", \";\n+        first = false;\n+        ss << pair.first << ':' << pair.second;\n+      }\n+    }\n+    ss << '}';\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<Datum> {\n+  static std::string ToString(const Datum& value) {\n+    switch (value.kind()) {\n+      case Datum::NONE:\n+        return \"<NULL DATUM>\";\n+      case Datum::SCALAR:\n+        return PropertyToString<std::shared_ptr<Scalar>>::ToString(value.scalar());\n+      case Datum::ARRAY: {\n+        std::stringstream ss;\n+        ss << value.type()->ToString() << ':' << value.make_array()->ToString();\n+        return ss.str();\n+      }\n+      case Datum::CHUNKED_ARRAY:\n+      case Datum::RECORD_BATCH:\n+      case Datum::TABLE:\n+      case Datum::COLLECTION:\n+        return value.ToString();\n+    }\n+    return value.ToString();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::vector<T>> {\n+  static std::string ToString(const std::vector<T>& value) {\n+    std::stringstream ss;\n+    ss << \"[\";\n+    bool first = true;\n+    // Don't use range-for with auto& to avoid Clang -Wrange-loop-analysis\n+    for (auto it = value.begin(); it != value.end(); it++) {\n+      if (!first) ss << \", \";\n+      first = false;\n+      ss << PropertyToString<T>::ToString(*it);\n+    }\n+    ss << ']';\n+    return ss.str();\n+  }\n+};\n+\n+template <typename T>\n+struct PropertyEquals {\n+  static bool Equals(const T& left, const T& right) { return left == right; }\n+};\n+template <typename T>\n+struct PropertyEquals<std::shared_ptr<T>> {\n+  static bool Equals(const std::shared_ptr<T>& left, const std::shared_ptr<T>& right) {\n+    return (!left && !right) || (left && right && left->Equals(*right));\n+  }\n+};\n+template <>\n+struct PropertyEquals<std::shared_ptr<const KeyValueMetadata>> {\n+  static bool Equals(const std::shared_ptr<const KeyValueMetadata>& left,\n+                     const std::shared_ptr<const KeyValueMetadata>& right) {\n+    // Special case since we serialize a null metadata into an empty one\n+    return (!left && !right) || (left && right && left->Equals(*right)) ||\n+           (!left && right && right->size() == 0) ||\n+           (left && !right && left->size() == 0);\n+  }\n+};\n+template <typename T>\n+struct PropertyEquals<std::vector<T>> {\n+  static bool Equals(const std::vector<T>& left, const std::vector<T>& right) {\n+    if (left.size() != right.size()) return false;\n+    for (size_t i = 0; i < left.size(); i++) {\n+      if (!PropertyEquals<T>::Equals(left[i], right[i])) return false;\n+    }\n+    return true;\n+  }\n+};\n+\n+template <typename T, typename Enable = void>\n+struct PropertyToScalar {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const T& value) {\n+    return Status::NotImplemented(\"Cannot serialize field\");\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+template <typename T>\n+struct PropertyToScalar<\n+    T, arrow::internal::void_t<decltype(MakeScalar(std::declval<T>()))>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const T& value) {\n+    return MakeScalar(value);\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return TypeTraits<typename CTypeTraits<T>::ArrowType>::type_singleton();\n+  }\n+};\n+template <typename T>\n+struct PropertyToScalar<std::vector<T>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const std::vector<T>& value) {\n+    std::shared_ptr<DataType> type;\n+    if (value.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(type, PropertyToScalar<T>::GetTypeSingleton());\n+    }\n+    std::vector<std::shared_ptr<Scalar>> scalars;\n+    scalars.reserve(value.size());\n+    // Don't use range-for with auto& to avoid Clang -Wrange-loop-analysis\n+    for (auto it = value.begin(); it != value.end(); it++) {\n+      ARROW_ASSIGN_OR_RAISE(auto scalar, PropertyToScalar<T>::ToScalar(*it));\n+      scalars.push_back(std::move(scalar));\n+    }\n+    std::unique_ptr<ArrayBuilder> builder;\n+    RETURN_NOT_OK(\n+        MakeBuilder(default_memory_pool(), type ? type : scalars[0]->type, &builder));\n+    RETURN_NOT_OK(builder->AppendScalars(scalars));\n+    std::shared_ptr<Array> out;\n+    RETURN_NOT_OK(builder->Finish(&out));\n+    return std::make_shared<ListScalar>(std::move(out));\n+  }\n+};\n+template <>\n+struct PropertyToScalar<std::shared_ptr<const KeyValueMetadata>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(\n+      const std::shared_ptr<const KeyValueMetadata>& value) {\n+    ARROW_ASSIGN_OR_RAISE(auto ty, GetTypeSingleton());\n+    std::unique_ptr<ArrayBuilder> builder;\n+    RETURN_NOT_OK(MakeBuilder(default_memory_pool(), ty, &builder));\n+    auto* map_builder = checked_cast<MapBuilder*>(builder.get());\n+    auto* key_builder = checked_cast<BinaryBuilder*>(map_builder->key_builder());\n+    auto* item_builder = checked_cast<BinaryBuilder*>(map_builder->item_builder());\n+    RETURN_NOT_OK(map_builder->Append());\n+    if (value) {\n+      RETURN_NOT_OK(key_builder->AppendValues(value->keys()));\n+      RETURN_NOT_OK(item_builder->AppendValues(value->values()));\n+    }\n+    std::shared_ptr<Array> arr;\n+    RETURN_NOT_OK(map_builder->Finish(&arr));\n+    return arr->GetScalar(0);\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return map(binary(), binary());\n+  }\n+};\n+template <>\n+struct PropertyToScalar<std::shared_ptr<DataType>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(\n+      const std::shared_ptr<DataType>& value) {\n+    if (!value) {\n+      return Status::Invalid(\"shared_ptr<DataType> is nullptr\");\n+    }\n+    return MakeNullScalar(value);\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+template <>\n+struct PropertyToScalar<std::shared_ptr<Scalar>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const std::shared_ptr<Scalar>& value) {\n+    return value;\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+template <>\n+struct PropertyToScalar<std::shared_ptr<Array>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const std::shared_ptr<Array>& value) {\n+    return std::make_shared<ListScalar>(value);\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+template <>\n+struct PropertyToScalar<Datum> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const Datum& value) {\n+    // TODO(ARROW-9434): store in a union instead.\n+    switch (value.kind()) {\n+      case Datum::ARRAY:\n+        return PropertyToScalar<std::shared_ptr<Array>>::ToScalar(value.make_array());\n+        break;\n+      default:\n+        return Status::NotImplemented(\"Cannot serialize Datum kind \", value.kind());\n+    }\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+\n+template <typename T, typename Enable = void>\n+struct PropertyFromScalar {\n+  static Result<T> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    return Status::NotImplemented(\"Cannot deserialize field\");\n+  }\n+};\n+template <typename T>\n+struct PropertyFromScalar<T,\n+                          enable_if_primitive_ctype<typename CTypeTraits<T>::ArrowType>> {\n+  using ArrowType = typename CTypeTraits<T>::ArrowType;\n+  using ScalarType = typename TypeTraits<ArrowType>::ScalarType;\n+  static Result<T> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    if (value->type->id() != ArrowType::type_id) {\n+      return Status::Invalid(\"Expected type \", ArrowType::type_id, \" but got \",\n+                             value->type->ToString());\n+    }\n+    const auto& holder = checked_cast<const ScalarType&>(*value);\n+    if (!holder.is_valid) return Status::Invalid(\"Got null scalar\");\n+    return holder.value;\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<std::string> {\n+  static Result<std::string> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    if (!is_base_binary_like(value->type->id())) {\n+      return Status::Invalid(\"Expected binary-like type but got \",\n+                             value->type->ToString());\n+    }\n+    const auto& holder = checked_cast<const BaseBinaryScalar&>(*value);\n+    if (!holder.is_valid) return Status::Invalid(\"Got null scalar\");\n+    return holder.value->ToString();\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<std::shared_ptr<DataType>> {\n+  static Result<std::shared_ptr<DataType>> FromScalar(\n+      const std::shared_ptr<Scalar>& value) {\n+    return value->type;\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<std::shared_ptr<Scalar>> {\n+  static Result<std::shared_ptr<Scalar>> FromScalar(\n+      const std::shared_ptr<Scalar>& value) {\n+    return value;\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<std::shared_ptr<const KeyValueMetadata>> {\n+  static Result<std::shared_ptr<const KeyValueMetadata>> FromScalar(\n+      const std::shared_ptr<Scalar>& value) {\n+    ARROW_ASSIGN_OR_RAISE(\n+        const auto ty,\n+        PropertyToScalar<std::shared_ptr<const KeyValueMetadata>>::GetTypeSingleton());\n+    if (!value->type->Equals(ty)) {\n+      return Status::Invalid(\"Expected \", ty->ToString(), \" but got \",\n+                             value->type->ToString());\n+    }\n+    const auto& holder = checked_cast<const MapScalar&>(*value);\n+    std::vector<std::string> keys;\n+    std::vector<std::string> values;\n+    const auto& list = checked_cast<const StructArray&>(*holder.value);\n+    const auto& key_arr = checked_cast<const BinaryArray&>(*list.field(0));\n+    const auto& value_arr = checked_cast<const BinaryArray&>(*list.field(1));\n+    for (int64_t i = 0; i < list.length(); i++) {\n+      keys.push_back(key_arr.GetString(i));\n+      values.push_back(value_arr.GetString(i));\n+    }\n+    return key_value_metadata(std::move(keys), std::move(values));\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<Datum> {\n+  static Result<Datum> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    if (value->type->id() == Type::LIST) {\n+      const auto& holder = checked_cast<const BaseListScalar&>(*value);\n+      return holder.value;\n+    }\n+    // TODO(ARROW-9434): handle other possible datum kinds by looking for a union\n+    return Status::Invalid(\"Cannot deserialize Datum from \", value->ToString());\n+  }\n+};\n+\n+template <typename T>\n+struct PropertyFromScalar<std::vector<T>> {\n+  static Result<std::vector<T>> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    if (value->type->id() != Type::LIST) {\n+      return Status::Invalid(\"Expected type LIST but got \", value->type->ToString());\n+    }\n+    const auto& holder = checked_cast<const BaseListScalar&>(*value);\n+    if (!holder.is_valid) return Status::Invalid(\"Got null scalar\");\n+    std::vector<T> result;\n+    for (int i = 0; i < holder.value->length(); i++) {\n+      ARROW_ASSIGN_OR_RAISE(auto scalar, holder.value->GetScalar(i));\n+      ARROW_ASSIGN_OR_RAISE(auto v, PropertyFromScalar<T>::FromScalar(scalar));\n+      result.push_back(std::move(v));\n+    }\n+    return result;\n+  }\n+};\n+\n+// Helper to quickly define serialization for a C-style enum\n+#define MAKE_ENUM_PROPERTY(ENUM, TYPE, MIN, MAX)                                        \\\n+  template <>                                                                           \\\n+  struct PropertyToScalar<ENUM> {                                                       \\\n+    static Result<std::shared_ptr<Scalar>> ToScalar(const ENUM value) {                 \\\n+      return PropertyToScalar<TYPE>::ToScalar(static_cast<TYPE>(value));                \\\n+    }                                                                                   \\\n+    static Result<std::shared_ptr<DataType>> GetTypeSingleton() {                       \\\n+      return PropertyToScalar<TYPE>::GetTypeSingleton();                                \\\n+    }                                                                                   \\\n+  };                                                                                    \\\n+  template <>                                                                           \\\n+  struct PropertyFromScalar<ENUM> {                                                     \\\n+    static Result<ENUM> FromScalar(const std::shared_ptr<Scalar>& value) {              \\\n+      ARROW_ASSIGN_OR_RAISE(auto raw_val, PropertyFromScalar<TYPE>::FromScalar(value)); \\\n+      if (raw_val < static_cast<TYPE>(MIN) || raw_val > static_cast<TYPE>(MAX)) {       \\\n+        return Status::Invalid(\"Got invalid value for \", ARROW_STRINGIFY(ENUM), \": \",   \\\n+                               raw_val);                                                \\\n+      }                                                                                 \\\n+      return static_cast<ENUM>(raw_val);                                                \\\n+    }                                                                                   \\\n+  };\n+\n+#define MAKE_OPTIONS_TYPE(OPTIONS, CLASS, GETTER, PROPERTIES)                   \\\n+  using CLASS = decltype(PROPERTIES)::Apply<GenericOptionsType, OPTIONS>::type; \\\n+  const FunctionOptionsType* GETTER() {                                         \\\n+    static const CLASS instance(PROPERTIES);                                    \\\n+    return &instance;                                                           \\\n+  }\n+\n\nReview comment:\n       ```suggestion\r\n   template <typename Options, typename... Properties>\r\n   const FunctionOptionsType* GetFunctionOptionsType(const Properties&... properties) {\r\n     static const struct : GenericOptionsType<Options, Properties...> {\r\n       using GenericOptionsType<Options, Properties>::GenericOptionsType;\r\n     } instance(arrow::internal::MakeProperties(properties...));\r\n   \r\n     return &instance;\r\n   }\r\n   ```\r\n   \r\n   (It'd probably be fine to inline `GenericOptionsType` there, actually.) Then this can be used later like so:\r\n   \r\n   ```c++\r\n   static auto kCastOptionsType = GetFunctionOptionsType<CastOptions>(\r\n       arrow::internal::DataMember(\"to_type\", &CastOptions::to_type),\r\n       arrow::internal::DataMember(\"allow_int_overflow\", &CastOptions::allow_int_overflow),\r\n       /*...*/);\r\n   }  // namespace\r\n   \r\n   void RegisterScalarCast(FunctionRegistry* registry) {\r\n     DCHECK_OK(registry->AddFunction(std::make_shared<CastMetaFunction>()));\r\n     DCHECK_OK(registry->AddFunctionOptionsType(kCastOptionsType));\r\n   }\r\n   }  // namespace internal\r\n   \r\n   CastOptions::CastOptions(bool safe)\r\n       : FunctionOptions(kCastOptionsType),\r\n         allow_int_overflow(!safe),\r\n         //...\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-28T18:36:14.019+0000",
                    "updated": "2021-06-28T18:36:14.019+0000",
                    "started": "2021-06-28T18:36:14.019+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "615741",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/615764",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#issuecomment-869956690\n\n\n   Thanks. Some of this applies to #10579 so I'll address that there and rebase.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-28T19:19:06.599+0000",
                    "updated": "2021-06-28T19:19:06.599+0000",
                    "started": "2021-06-28T19:19:06.599+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "615764",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/615777",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#discussion_r660071017\n\n\n\n##########\nFile path: cpp/src/arrow/compute/function_internal.h\n##########\n@@ -0,0 +1,565 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/builder_base.h\"\n+#include \"arrow/array/builder_binary.h\"\n+#include \"arrow/array/builder_nested.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+struct Scalar;\n+struct StructScalar;\n+using ::arrow::internal::checked_cast;\n+namespace compute {\n+namespace internal {\n+ARROW_EXPORT\n+Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const FunctionOptions&);\n+ARROW_EXPORT\n+Result<std::unique_ptr<FunctionOptions>> FunctionOptionsFromStructScalar(\n+    const StructScalar&);\n+\n+template <typename T>\n+struct PropertyToString {\n+  static std::string ToString(const T& value) {\n+    std::stringstream ss;\n+    ss << value;\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<bool> {\n+  static std::string ToString(bool value) { return value ? \"true\" : \"false\"; }\n+};\n+template <>\n+struct PropertyToString<std::string> {\n+  static std::string ToString(const std::string& value) {\n+    std::stringstream ss;\n+    ss << '\"' << value << '\"';\n+    return ss.str();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::shared_ptr<T>> {\n+  static std::string ToString(const std::shared_ptr<T>& value) {\n+    std::stringstream ss;\n+    return value ? value->ToString() : \"<NULLPTR>\";\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<Scalar>> {\n+  static std::string ToString(const std::shared_ptr<Scalar>& value) {\n+    std::stringstream ss;\n+    ss << value->type->ToString() << \":\" << value->ToString();\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<const KeyValueMetadata>> {\n+  static std::string ToString(const std::shared_ptr<const KeyValueMetadata>& value) {\n+    std::stringstream ss;\n+    ss << \"KeyValueMetadata{\";\n+    if (value) {\n+      bool first = true;\n+      for (const auto& pair : value->sorted_pairs()) {\n+        if (!first) ss << \", \";\n+        first = false;\n+        ss << pair.first << ':' << pair.second;\n+      }\n+    }\n+    ss << '}';\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<Datum> {\n+  static std::string ToString(const Datum& value) {\n+    switch (value.kind()) {\n+      case Datum::NONE:\n+        return \"<NULL DATUM>\";\n+      case Datum::SCALAR:\n+        return PropertyToString<std::shared_ptr<Scalar>>::ToString(value.scalar());\n+      case Datum::ARRAY: {\n+        std::stringstream ss;\n+        ss << value.type()->ToString() << ':' << value.make_array()->ToString();\n+        return ss.str();\n+      }\n+      case Datum::CHUNKED_ARRAY:\n+      case Datum::RECORD_BATCH:\n+      case Datum::TABLE:\n+      case Datum::COLLECTION:\n+        return value.ToString();\n+    }\n+    return value.ToString();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::vector<T>> {\n+  static std::string ToString(const std::vector<T>& value) {\n+    std::stringstream ss;\n+    ss << \"[\";\n+    bool first = true;\n+    // Don't use range-for with auto& to avoid Clang -Wrange-loop-analysis\n\nReview comment:\n       Clang complains when that gets instantiated with `std::vector<bool>` because, well vector<bool> is special :upside_down_face:  \n\n##########\nFile path: cpp/src/arrow/compute/util_internal.h\n##########\n@@ -17,6 +17,9 @@\n \n #pragma once\n \n+#include <iosfwd>\n+#include <vector>\n+\n\nReview comment:\n       Sorry, these were left over from a change I didn't back out fully\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-28T19:49:01.169+0000",
                    "updated": "2021-06-28T19:49:01.169+0000",
                    "started": "2021-06-28T19:49:01.168+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "615777",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/615815",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#discussion_r660099591\n\n\n\n##########\nFile path: cpp/src/arrow/compute/function.h\n##########\n@@ -39,12 +40,49 @@ namespace compute {\n ///\n /// @{\n \n+/// \\brief Extension point for defining options outside libarrow (but\n+/// still within this project).\n+class ARROW_EXPORT FunctionOptionsType {\n+ public:\n+  virtual ~FunctionOptionsType() = default;\n+\n+  virtual const char* type_name() const = 0;\n+  virtual std::string Stringify(const FunctionOptions&) const = 0;\n+  virtual bool Compare(const FunctionOptions&, const FunctionOptions&) const = 0;\n+  /// \\brief Convert this options struct into a Struct scalar.\n+  virtual Status ToStructScalar(const FunctionOptions&,\n+                                std::vector<std::string>* field_names,\n+                                std::vector<std::shared_ptr<Scalar>>* values) const;\n\nReview comment:\n       Ah, sorry, I misunderstood before. This raises a question though: to know the type_name to deserialize, we need to make some assumption about the serialized data. (Or, as before, we need to register a mapping between function and options type.)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-28T20:36:37.435+0000",
                    "updated": "2021-06-28T20:36:37.435+0000",
                    "started": "2021-06-28T20:36:37.434+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "615815",
                    "issueId": "13382999"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/worklog/615907",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10511:\nURL: https://github.com/apache/arrow/pull/10511#discussion_r660173570\n\n\n\n##########\nFile path: cpp/src/arrow/compute/function_internal.h\n##########\n@@ -0,0 +1,565 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+\n+#include \"arrow/array/builder_base.h\"\n+#include \"arrow/array/builder_binary.h\"\n+#include \"arrow/array/builder_nested.h\"\n+#include \"arrow/compute/function.h\"\n+#include \"arrow/compute/type_fwd.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/reflection_internal.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/visibility.h\"\n+\n+namespace arrow {\n+struct Scalar;\n+struct StructScalar;\n+using ::arrow::internal::checked_cast;\n+namespace compute {\n+namespace internal {\n+ARROW_EXPORT\n+Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const FunctionOptions&);\n+ARROW_EXPORT\n+Result<std::unique_ptr<FunctionOptions>> FunctionOptionsFromStructScalar(\n+    const StructScalar&);\n+\n+template <typename T>\n+struct PropertyToString {\n+  static std::string ToString(const T& value) {\n+    std::stringstream ss;\n+    ss << value;\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<bool> {\n+  static std::string ToString(bool value) { return value ? \"true\" : \"false\"; }\n+};\n+template <>\n+struct PropertyToString<std::string> {\n+  static std::string ToString(const std::string& value) {\n+    std::stringstream ss;\n+    ss << '\"' << value << '\"';\n+    return ss.str();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::shared_ptr<T>> {\n+  static std::string ToString(const std::shared_ptr<T>& value) {\n+    std::stringstream ss;\n+    return value ? value->ToString() : \"<NULLPTR>\";\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<Scalar>> {\n+  static std::string ToString(const std::shared_ptr<Scalar>& value) {\n+    std::stringstream ss;\n+    ss << value->type->ToString() << \":\" << value->ToString();\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<std::shared_ptr<const KeyValueMetadata>> {\n+  static std::string ToString(const std::shared_ptr<const KeyValueMetadata>& value) {\n+    std::stringstream ss;\n+    ss << \"KeyValueMetadata{\";\n+    if (value) {\n+      bool first = true;\n+      for (const auto& pair : value->sorted_pairs()) {\n+        if (!first) ss << \", \";\n+        first = false;\n+        ss << pair.first << ':' << pair.second;\n+      }\n+    }\n+    ss << '}';\n+    return ss.str();\n+  }\n+};\n+template <>\n+struct PropertyToString<Datum> {\n+  static std::string ToString(const Datum& value) {\n+    switch (value.kind()) {\n+      case Datum::NONE:\n+        return \"<NULL DATUM>\";\n+      case Datum::SCALAR:\n+        return PropertyToString<std::shared_ptr<Scalar>>::ToString(value.scalar());\n+      case Datum::ARRAY: {\n+        std::stringstream ss;\n+        ss << value.type()->ToString() << ':' << value.make_array()->ToString();\n+        return ss.str();\n+      }\n+      case Datum::CHUNKED_ARRAY:\n+      case Datum::RECORD_BATCH:\n+      case Datum::TABLE:\n+      case Datum::COLLECTION:\n+        return value.ToString();\n+    }\n+    return value.ToString();\n+  }\n+};\n+template <typename T>\n+struct PropertyToString<std::vector<T>> {\n+  static std::string ToString(const std::vector<T>& value) {\n+    std::stringstream ss;\n+    ss << \"[\";\n+    bool first = true;\n+    // Don't use range-for with auto& to avoid Clang -Wrange-loop-analysis\n+    for (auto it = value.begin(); it != value.end(); it++) {\n+      if (!first) ss << \", \";\n+      first = false;\n+      ss << PropertyToString<T>::ToString(*it);\n+    }\n+    ss << ']';\n+    return ss.str();\n+  }\n+};\n+\n+template <typename T>\n+struct PropertyEquals {\n+  static bool Equals(const T& left, const T& right) { return left == right; }\n+};\n+template <typename T>\n+struct PropertyEquals<std::shared_ptr<T>> {\n+  static bool Equals(const std::shared_ptr<T>& left, const std::shared_ptr<T>& right) {\n+    return (!left && !right) || (left && right && left->Equals(*right));\n+  }\n+};\n+template <>\n+struct PropertyEquals<std::shared_ptr<const KeyValueMetadata>> {\n+  static bool Equals(const std::shared_ptr<const KeyValueMetadata>& left,\n+                     const std::shared_ptr<const KeyValueMetadata>& right) {\n+    // Special case since we serialize a null metadata into an empty one\n+    return (!left && !right) || (left && right && left->Equals(*right)) ||\n+           (!left && right && right->size() == 0) ||\n+           (left && !right && left->size() == 0);\n+  }\n+};\n+template <typename T>\n+struct PropertyEquals<std::vector<T>> {\n+  static bool Equals(const std::vector<T>& left, const std::vector<T>& right) {\n+    if (left.size() != right.size()) return false;\n+    for (size_t i = 0; i < left.size(); i++) {\n+      if (!PropertyEquals<T>::Equals(left[i], right[i])) return false;\n+    }\n+    return true;\n+  }\n+};\n+\n+template <typename T, typename Enable = void>\n+struct PropertyToScalar {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const T& value) {\n+    return Status::NotImplemented(\"Cannot serialize field\");\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+template <typename T>\n+struct PropertyToScalar<\n+    T, arrow::internal::void_t<decltype(MakeScalar(std::declval<T>()))>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const T& value) {\n+    return MakeScalar(value);\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return TypeTraits<typename CTypeTraits<T>::ArrowType>::type_singleton();\n+  }\n+};\n+template <typename T>\n+struct PropertyToScalar<std::vector<T>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const std::vector<T>& value) {\n+    std::shared_ptr<DataType> type;\n+    if (value.empty()) {\n+      ARROW_ASSIGN_OR_RAISE(type, PropertyToScalar<T>::GetTypeSingleton());\n+    }\n+    std::vector<std::shared_ptr<Scalar>> scalars;\n+    scalars.reserve(value.size());\n+    // Don't use range-for with auto& to avoid Clang -Wrange-loop-analysis\n+    for (auto it = value.begin(); it != value.end(); it++) {\n+      ARROW_ASSIGN_OR_RAISE(auto scalar, PropertyToScalar<T>::ToScalar(*it));\n+      scalars.push_back(std::move(scalar));\n+    }\n+    std::unique_ptr<ArrayBuilder> builder;\n+    RETURN_NOT_OK(\n+        MakeBuilder(default_memory_pool(), type ? type : scalars[0]->type, &builder));\n+    RETURN_NOT_OK(builder->AppendScalars(scalars));\n+    std::shared_ptr<Array> out;\n+    RETURN_NOT_OK(builder->Finish(&out));\n+    return std::make_shared<ListScalar>(std::move(out));\n+  }\n+};\n+template <>\n+struct PropertyToScalar<std::shared_ptr<const KeyValueMetadata>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(\n+      const std::shared_ptr<const KeyValueMetadata>& value) {\n+    ARROW_ASSIGN_OR_RAISE(auto ty, GetTypeSingleton());\n+    std::unique_ptr<ArrayBuilder> builder;\n+    RETURN_NOT_OK(MakeBuilder(default_memory_pool(), ty, &builder));\n+    auto* map_builder = checked_cast<MapBuilder*>(builder.get());\n+    auto* key_builder = checked_cast<BinaryBuilder*>(map_builder->key_builder());\n+    auto* item_builder = checked_cast<BinaryBuilder*>(map_builder->item_builder());\n+    RETURN_NOT_OK(map_builder->Append());\n+    if (value) {\n+      RETURN_NOT_OK(key_builder->AppendValues(value->keys()));\n+      RETURN_NOT_OK(item_builder->AppendValues(value->values()));\n+    }\n+    std::shared_ptr<Array> arr;\n+    RETURN_NOT_OK(map_builder->Finish(&arr));\n+    return arr->GetScalar(0);\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return map(binary(), binary());\n+  }\n+};\n+template <>\n+struct PropertyToScalar<std::shared_ptr<DataType>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(\n+      const std::shared_ptr<DataType>& value) {\n+    if (!value) {\n+      return Status::Invalid(\"shared_ptr<DataType> is nullptr\");\n+    }\n+    return MakeNullScalar(value);\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+template <>\n+struct PropertyToScalar<std::shared_ptr<Scalar>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const std::shared_ptr<Scalar>& value) {\n+    return value;\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+template <>\n+struct PropertyToScalar<std::shared_ptr<Array>> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const std::shared_ptr<Array>& value) {\n+    return std::make_shared<ListScalar>(value);\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+template <>\n+struct PropertyToScalar<Datum> {\n+  static Result<std::shared_ptr<Scalar>> ToScalar(const Datum& value) {\n+    // TODO(ARROW-9434): store in a union instead.\n+    switch (value.kind()) {\n+      case Datum::ARRAY:\n+        return PropertyToScalar<std::shared_ptr<Array>>::ToScalar(value.make_array());\n+        break;\n+      default:\n+        return Status::NotImplemented(\"Cannot serialize Datum kind \", value.kind());\n+    }\n+  }\n+\n+  static Result<std::shared_ptr<DataType>> GetTypeSingleton() {\n+    return Status::NotImplemented(\"Cannot get type for field\");\n+  }\n+};\n+\n+template <typename T, typename Enable = void>\n+struct PropertyFromScalar {\n+  static Result<T> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    return Status::NotImplemented(\"Cannot deserialize field\");\n+  }\n+};\n+template <typename T>\n+struct PropertyFromScalar<T,\n+                          enable_if_primitive_ctype<typename CTypeTraits<T>::ArrowType>> {\n+  using ArrowType = typename CTypeTraits<T>::ArrowType;\n+  using ScalarType = typename TypeTraits<ArrowType>::ScalarType;\n+  static Result<T> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    if (value->type->id() != ArrowType::type_id) {\n+      return Status::Invalid(\"Expected type \", ArrowType::type_id, \" but got \",\n+                             value->type->ToString());\n+    }\n+    const auto& holder = checked_cast<const ScalarType&>(*value);\n+    if (!holder.is_valid) return Status::Invalid(\"Got null scalar\");\n+    return holder.value;\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<std::string> {\n+  static Result<std::string> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    if (!is_base_binary_like(value->type->id())) {\n+      return Status::Invalid(\"Expected binary-like type but got \",\n+                             value->type->ToString());\n+    }\n+    const auto& holder = checked_cast<const BaseBinaryScalar&>(*value);\n+    if (!holder.is_valid) return Status::Invalid(\"Got null scalar\");\n+    return holder.value->ToString();\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<std::shared_ptr<DataType>> {\n+  static Result<std::shared_ptr<DataType>> FromScalar(\n+      const std::shared_ptr<Scalar>& value) {\n+    return value->type;\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<std::shared_ptr<Scalar>> {\n+  static Result<std::shared_ptr<Scalar>> FromScalar(\n+      const std::shared_ptr<Scalar>& value) {\n+    return value;\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<std::shared_ptr<const KeyValueMetadata>> {\n+  static Result<std::shared_ptr<const KeyValueMetadata>> FromScalar(\n+      const std::shared_ptr<Scalar>& value) {\n+    ARROW_ASSIGN_OR_RAISE(\n+        const auto ty,\n+        PropertyToScalar<std::shared_ptr<const KeyValueMetadata>>::GetTypeSingleton());\n+    if (!value->type->Equals(ty)) {\n+      return Status::Invalid(\"Expected \", ty->ToString(), \" but got \",\n+                             value->type->ToString());\n+    }\n+    const auto& holder = checked_cast<const MapScalar&>(*value);\n+    std::vector<std::string> keys;\n+    std::vector<std::string> values;\n+    const auto& list = checked_cast<const StructArray&>(*holder.value);\n+    const auto& key_arr = checked_cast<const BinaryArray&>(*list.field(0));\n+    const auto& value_arr = checked_cast<const BinaryArray&>(*list.field(1));\n+    for (int64_t i = 0; i < list.length(); i++) {\n+      keys.push_back(key_arr.GetString(i));\n+      values.push_back(value_arr.GetString(i));\n+    }\n+    return key_value_metadata(std::move(keys), std::move(values));\n+  }\n+};\n+template <>\n+struct PropertyFromScalar<Datum> {\n+  static Result<Datum> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    if (value->type->id() == Type::LIST) {\n+      const auto& holder = checked_cast<const BaseListScalar&>(*value);\n+      return holder.value;\n+    }\n+    // TODO(ARROW-9434): handle other possible datum kinds by looking for a union\n+    return Status::Invalid(\"Cannot deserialize Datum from \", value->ToString());\n+  }\n+};\n+\n+template <typename T>\n+struct PropertyFromScalar<std::vector<T>> {\n+  static Result<std::vector<T>> FromScalar(const std::shared_ptr<Scalar>& value) {\n+    if (value->type->id() != Type::LIST) {\n+      return Status::Invalid(\"Expected type LIST but got \", value->type->ToString());\n+    }\n+    const auto& holder = checked_cast<const BaseListScalar&>(*value);\n+    if (!holder.is_valid) return Status::Invalid(\"Got null scalar\");\n+    std::vector<T> result;\n+    for (int i = 0; i < holder.value->length(); i++) {\n+      ARROW_ASSIGN_OR_RAISE(auto scalar, holder.value->GetScalar(i));\n+      ARROW_ASSIGN_OR_RAISE(auto v, PropertyFromScalar<T>::FromScalar(scalar));\n+      result.push_back(std::move(v));\n+    }\n+    return result;\n+  }\n+};\n+\n+// Helper to quickly define serialization for a C-style enum\n+#define MAKE_ENUM_PROPERTY(ENUM, TYPE, MIN, MAX)                                        \\\n\nReview comment:\n       This leads to some more boilerplate because 1) kValues needs to be constexpr to be initialized like so and 2) then kValues and kName need separate declarations outside the struct or the linker will complain about a missing symbol. (So every specialization needs a `static constexpr std::array<...> BasicEnumTraits<..., ..., ...>::kValues;`).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-28T23:15:11.279+0000",
                    "updated": "2021-06-28T23:15:11.279+0000",
                    "started": "2021-06-28T23:15:11.279+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "615907",
                    "issueId": "13382999"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 21600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@10ca7b39[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3064c11a[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6bb85b1d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7dc22b61[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3338892a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5c4b3d69[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7582e54e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@197741bc[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6ef1fa61[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@6b5422a3[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@91e1212[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@2a47d82c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 21600,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Jun 30 18:23:33 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-06-30T18:23:33.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13025/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2021-06-09T16:27:10.000+0000",
        "updated": "2021-07-01T12:42:58.000+0000",
        "timeoriginalestimate": null,
        "description": "Currently the {{FunctionOptions}} interface is entirely opaque. It would be useful to add \r\n\r\n- equality comparability {code}\r\n    bool FunctionOptions::Equals(const FunctionOptions& other) const\r\n    {code}\r\n- debug representation {code}\r\n    std::string FunctionOptions::ToString() const\r\n    {code}\r\n- serializability {code}\r\n    Status FunctionOptions::Serialize(io::OutputStream*) const\r\n\r\n    Result<std::unique_ptr<FunctionOptions>>\r\n        FunctionOptions::Deserialize(io::InputStream*)\r\n    {code} (or similar)\r\n\r\nThese are already implemented for common instances of {{FunctionOptions}} in expression.cc, since {{Expression}} has the above capabilities and may contain a {{FunctionOptions}}. Making these explicit virtual functions will formalize this ad-hoc\r\ncode and expose it for direct unit testing.\r\n\r\nAs an added bonus, if options can serialize themselves to JSON then that can be used by Python and other bindings to generate wrappers instead of the current hand-written listing of wrapper classes for each {{FunctionOptions}} subclass",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "6h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 21600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Compute] Enhance FunctionOptions with equality, debug representability, and serializability",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/comment/17360237",
                    "id": "17360237",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "+1 for the additional methods. I'm skeptical about JSON serialization, though.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-06-09T17:22:32.582+0000",
                    "updated": "2021-06-09T17:22:32.582+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13382999/comment/17372148",
                    "id": "17372148",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 10511\n[https://github.com/apache/arrow/pull/10511]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-06-30T18:23:33.098+0000",
                    "updated": "2021-06-30T18:23:33.098+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0rt6o:",
        "customfield_12314139": null
    }
}