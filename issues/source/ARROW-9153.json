{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13311826",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311826",
    "key": "ARROW-9153",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12347769",
                "id": "12347769",
                "description": "",
                "name": "1.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-07-24"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
            "name": "kszucs",
            "key": "kszucs",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Krisztian Szucs",
            "active": true,
            "timeZone": "Europe/Budapest"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 2400,
            "total": 2400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 2400,
            "total": 2400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9153/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 4,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311826/worklog/449476",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs opened a new pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-22T20:17:23.467+0000",
                    "updated": "2020-06-22T20:17:23.467+0000",
                    "started": "2020-06-22T20:17:23.466+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "449476",
                    "issueId": "13311826"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311826/worklog/449478",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#issuecomment-647754455\n\n\n   https://issues.apache.org/jira/browse/ARROW-9153\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-22T20:31:58.017+0000",
                    "updated": "2020-06-22T20:31:58.017+0000",
                    "started": "2020-06-22T20:31:58.017+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "449478",
                    "issueId": "13311826"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311826/worklog/450669",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kszucs commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r445194648\n\n\n\n##########\nFile path: python/pyarrow/tests/test_misc.py\n##########\n@@ -120,7 +120,6 @@ def test_cpu_count():\n     pa.LargeListValue,\n     pa.MapValue,\n     pa.FixedSizeListValue,\n-    pa.UnionValue,\n\nReview comment:\n       Restore it\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-24T21:57:02.166+0000",
                    "updated": "2020-06-24T21:57:02.166+0000",
                    "started": "2020-06-24T21:57:02.166+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "450669",
                    "issueId": "13311826"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311826/worklog/451029",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorisvandenbossche commented on a change in pull request #7519:\nURL: https://github.com/apache/arrow/pull/7519#discussion_r445523294\n\n\n\n##########\nFile path: python/pyarrow/_dataset.pyx\n##########\n@@ -216,22 +216,18 @@ cdef class Expression:\n     @staticmethod\n     def _scalar(value):\n         cdef:\n-            shared_ptr[CScalar] scalar\n-\n-        if value is None:\n-            scalar.reset(new CNullScalar())\n-        elif isinstance(value, bool):\n-            scalar = MakeScalar(<c_bool>value)\n-        elif isinstance(value, float):\n-            scalar = MakeScalar(<double>value)\n-        elif isinstance(value, int):\n-            scalar = MakeScalar(<int64_t>value)\n-        elif isinstance(value, (bytes, str)):\n-            scalar = MakeStringScalar(tobytes(value))\n\nReview comment:\n       I think the `MakeStringScalar` included in libarrow.pxd can then be removed (I don't see any other usage of it)\n\n##########\nFile path: python/pyarrow/tests/test_parquet.py\n##########\n@@ -2028,7 +2028,7 @@ def test_filters_invalid_pred_op(tempdir, use_legacy_dataset):\n                                     use_legacy_dataset=use_legacy_dataset)\n         assert dataset.read().num_rows == 0\n \n-    with pytest.raises(ValueError if use_legacy_dataset else TypeError):\n+    with pytest.raises(ValueError if use_legacy_dataset else pa.ArrowInvalid):\n         # dataset API returns TypeError when trying create invalid comparison\n\nReview comment:\n       ```suggestion\r\n       with pytest.raises(ValueError):\r\n   ```\r\n   \r\n   ArrowInvalid is a ValueError, I think, so if this changed, the above should be sufficient\n\n##########\nFile path: python/pyarrow/util.py\n##########\n@@ -41,6 +41,24 @@ def wrapper(*args, **kwargs):\n     return wrapper\n \n \n+def _deprecate_class(old_name, new_class, next_version,\n+                     instancecheck=True):\n+    \"\"\"\n+    Raise warning if a deprecated class is used in an isinstance check.\n\nReview comment:\n       Shouldn't it also raise when instantiated?\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,704 @@\n # under the License.\n \n \n-_NULL = NA = None\n-\n-\n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n \n-        self.type = null()\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n \n     def __eq__(self, other):\n-        return NA\n+        # TODO(kszucs): use c++ Equals\n+        if isinstance(other, Scalar):\n+            other = other.as_py()\n+        return self.as_py() == other\n \n+    def __hash__(self):\n+        # TODO(kszucs): use C++ hash if implemented for the type\n+        return hash(self.as_py())\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n-_NULL = NA = NullType()\n+\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n-\n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __init__(self):\n+        pass\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __eq__(self, other):\n+        return NA\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n+\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class DecimalScalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n-\n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n-\n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n-\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n \n-cdef class HalfFloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float16 array elements.\n-    \"\"\"\n+        if not sp.is_valid:\n+            return None\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class FloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float32 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n-\n-\n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DecimalValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for decimal128 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python Decimal.\n-        \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n \n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n \n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n \n-cdef class LargeStringValue(ArrayValue):\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for large string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    cdef array(self):\n\nReview comment:\n       do we want to expose this in some form publicly as well? (like you have the \"raw\" `value` for timestamps)\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,704 @@\n # under the License.\n \n \n-_NULL = NA = None\n-\n-\n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n \n-        self.type = null()\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n\nReview comment:\n       Big +1 on this better repr! Just showing the repr of the as_py value was always very confusing :)\n\n##########\nFile path: python/pyarrow/tests/test_scalars.py\n##########\n@@ -17,426 +17,395 @@\n \n import datetime\n import pytest\n-import unittest\n \n import numpy as np\n \n import pyarrow as pa\n \n \n-class TestScalars(unittest.TestCase):\n-\n-    def test_null_singleton(self):\n-        with pytest.raises(Exception):\n-            pa.NAType()\n+@pytest.mark.parametrize(['value', 'ty', 'klass', 'deprecated'], [\n+    (None, None, pa.NullScalar, pa.NullType),\n+    (False, None, pa.BooleanScalar, pa.BooleanValue),\n+    (True, None, pa.BooleanScalar, pa.BooleanValue),\n+    (1, None, pa.Int64Scalar, pa.Int64Value),\n+    (-1, None, pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.int8(), pa.Int8Scalar, pa.Int8Value),\n+    (1, pa.uint8(), pa.UInt8Scalar, pa.UInt8Value),\n+    (1, pa.int16(), pa.Int16Scalar, pa.Int16Value),\n+    (1, pa.uint16(), pa.UInt16Scalar, pa.UInt16Value),\n+    (1, pa.int32(), pa.Int32Scalar, pa.Int32Value),\n+    (1, pa.uint32(), pa.UInt32Scalar, pa.UInt32Value),\n+    (1, pa.int64(), pa.Int64Scalar, pa.Int64Value),\n+    (1, pa.uint64(), pa.UInt64Scalar, pa.UInt64Value),\n+    (1.0, None, pa.DoubleScalar, pa.DoubleValue),\n+    (np.float16(1.0), pa.float16(), pa.HalfFloatScalar, pa.HalfFloatValue),\n+    (1.0, pa.float32(), pa.FloatScalar, pa.FloatValue),\n+    (\"string\", None, pa.StringScalar, pa.StringValue),\n+    (b\"bytes\", None, pa.BinaryScalar, pa.BinaryValue),\n+    ([1, 2, 3], None, pa.ListScalar, pa.ListValue),\n+    ([1, 2, 3, 4], pa.large_list(pa.int8()), pa.LargeListScalar,\n+     pa.LargeListValue),\n+    # date\n+    # time\n+])\n+def test_type_inference(value, ty, klass, deprecated):\n+    s = pa.scalar(value, type=ty)\n+    assert isinstance(s, klass)\n+    assert s == value\n+    with pytest.warns(FutureWarning):\n+        isinstance(s, deprecated)\n+\n+\n+def test_null_singleton():\n+    with pytest.raises(Exception):\n+        pa.NullScalar()\n+\n+\n+def test_nulls():\n+    arr = pa.array([None, None])\n+    for v in arr:\n+        assert v is pa.NA\n+        assert v.as_py() is None\n+\n+\n+def test_null_equality():\n+    assert (pa.NA == pa.NA) is pa.NA\n+    assert (pa.NA == 1) is pa.NA\n\nReview comment:\n       I don't know to what extent we want to fully work out the scalars (so can certainly be a follow-up), but so the typed null scalars (not pa.NA), should probably behave the same as pa.NA, eg when it comes to equality (`pa.NA == 1` gives pa.NA, but `pa.scalar(None, pa.int64()) == 1` gives False)\n\n##########\nFile path: python/pyarrow/scalar.pxi\n##########\n@@ -16,1198 +16,704 @@\n # under the License.\n \n \n-_NULL = NA = None\n-\n-\n cdef class Scalar:\n     \"\"\"\n-    The base class for all array elements.\n+    The base class for scalars.\n     \"\"\"\n \n+    def __init__(self):\n+        raise TypeError(\"Do not call {}'s constructor directly, use \"\n+                        \"pa.scalar() instead.\".format(self.__class__.__name__))\n \n-cdef class NullType(Scalar):\n-    \"\"\"\n-    Singleton for null array elements.\n-    \"\"\"\n-    # TODO rename this NullValue?\n+    cdef void init(self, const shared_ptr[CScalar]& wrapped):\n+        self.wrapped = wrapped\n \n-    def __cinit__(self):\n-        global NA\n-        if NA is not None:\n-            raise Exception('Cannot create multiple NAType instances')\n+    @staticmethod\n+    cdef wrap(const shared_ptr[CScalar]& wrapped):\n+        cdef:\n+            Scalar self\n+            Type type_id = wrapped.get().type.get().id()\n+\n+        if type_id == _Type_NA:\n+            return _NULL\n+\n+        typ = _scalar_classes[type_id]\n+        self = typ.__new__(typ)\n+        self.init(wrapped)\n+\n+        return self\n+\n+    cdef inline shared_ptr[CScalar] unwrap(self) nogil:\n+        return self.wrapped\n \n-        self.type = null()\n+    @property\n+    def type(self):\n+        return pyarrow_wrap_data_type(self.wrapped.get().type)\n \n     def __repr__(self):\n-        return 'NULL'\n+        return '<pyarrow.{}: {!r}>'.format(\n+            self.__class__.__name__, self.as_py()\n+        )\n \n-    def as_py(self):\n-        \"\"\"\n-        Return None\n-        \"\"\"\n-        return None\n+    def __str__(self):\n+        return str(self.as_py())\n \n     def __eq__(self, other):\n-        return NA\n+        # TODO(kszucs): use c++ Equals\n+        if isinstance(other, Scalar):\n+            other = other.as_py()\n+        return self.as_py() == other\n \n+    def __hash__(self):\n+        # TODO(kszucs): use C++ hash if implemented for the type\n+        return hash(self.as_py())\n+\n+    def as_py(self):\n+        raise NotImplementedError()\n \n-_NULL = NA = NullType()\n+\n+_NULL = NA = None\n \n \n-cdef class ArrayValue(Scalar):\n+cdef class NullScalar(Scalar):\n     \"\"\"\n-    The base class for non-null array elements.\n+    Concrete class for null scalars.\n     \"\"\"\n \n-    def __init__(self):\n-        raise TypeError(\"Do not call {}'s constructor directly, use array \"\n-                        \"subscription instead.\"\n-                        .format(self.__class__.__name__))\n-\n-    cdef void init(self, DataType type, const shared_ptr[CArray]& sp_array,\n-                   int64_t index):\n-        self.type = type\n-        self.index = index\n-        self._set_array(sp_array)\n+    def __cinit__(self):\n+        global NA\n+        if NA is not None:\n+            raise Exception('Cannot create multiple NAType instances')\n+        self.init(shared_ptr[CScalar](new CNullScalar()))\n \n-    cdef void _set_array(self, const shared_ptr[CArray]& sp_array):\n-        self.sp_array = sp_array\n+    def __init__(self):\n+        pass\n \n-    def __repr__(self):\n-        if hasattr(self, 'as_py'):\n-            return repr(self.as_py())\n-        else:\n-            return super(Scalar, self).__repr__()\n+    def __eq__(self, other):\n+        return NA\n \n-    def __str__(self):\n-        if hasattr(self, 'as_py'):\n-            return str(self.as_py())\n-        else:\n-            return super(Scalar, self).__str__()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python None.\n+        \"\"\"\n+        return None\n \n-    def __eq__(self, other):\n-        if hasattr(self, 'as_py'):\n-            if isinstance(other, ArrayValue):\n-                other = other.as_py()\n-            return self.as_py() == other\n-        else:\n-            raise NotImplementedError(\n-                \"Cannot compare Arrow values that don't support as_py()\")\n \n-    def __hash__(self):\n-        return hash(self.as_py())\n+_NULL = NA = NullScalar()\n \n \n-cdef class BooleanValue(ArrayValue):\n+cdef class BooleanScalar(Scalar):\n     \"\"\"\n-    Concrete class for boolean array elements.\n+    Concrete class for boolean scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python bool.\n         \"\"\"\n-        cdef CBooleanArray* ap = <CBooleanArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CBooleanScalar* sp = <CBooleanScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int8Value(ArrayValue):\n+cdef class UInt8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int8 array elements.\n+    Concrete class for uint8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt8Array* ap = <CInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt8Scalar* sp = <CUInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt8Value(ArrayValue):\n+cdef class Int8Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint8 array elements.\n+    Concrete class for int8 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt8Array* ap = <CUInt8Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt8Scalar* sp = <CInt8Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int16Value(ArrayValue):\n+cdef class UInt16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int16 array elements.\n+    Concrete class for uint16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt16Array* ap = <CInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt16Scalar* sp = <CUInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt16Value(ArrayValue):\n+cdef class Int16Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint16 array elements.\n+    Concrete class for int16 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt16Array* ap = <CUInt16Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt16Scalar* sp = <CInt16Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int32Value(ArrayValue):\n+cdef class UInt32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int32 array elements.\n+    Concrete class for uint32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt32Array* ap = <CInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt32Scalar* sp = <CUInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt32Value(ArrayValue):\n+cdef class Int32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint32 array elements.\n+    Concrete class for int32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt32Array* ap = <CUInt32Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt32Scalar* sp = <CInt32Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Int64Value(ArrayValue):\n+cdef class UInt64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for int64 array elements.\n+    Concrete class for uint64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CInt64Array* ap = <CInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CUInt64Scalar* sp = <CUInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class UInt64Value(ArrayValue):\n+cdef class Int64Scalar(Scalar):\n     \"\"\"\n-    Concrete class for uint64 array elements.\n+    Concrete class for int64 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Python int.\n         \"\"\"\n-        cdef CUInt64Array* ap = <CUInt64Array*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CInt64Scalar* sp = <CInt64Scalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date32Value(ArrayValue):\n+cdef class HalfFloatScalar(Scalar):\n     \"\"\"\n-    Concrete class for date32 array elements.\n+    Concrete class for float scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate32Array* ap = <CDate32Array*> self.sp_array.get()\n+        cdef CHalfFloatScalar* sp = <CHalfFloatScalar*> self.wrapped.get()\n+        return PyHalf_FromHalf(sp.value) if sp.is_valid else None\n+\n+\n+cdef class FloatScalar(Scalar):\n+    \"\"\"\n+    Concrete class for float scalars.\n+    \"\"\"\n \n-        # Shift to seconds since epoch\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(days=ap.Value(self.index)))\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python float.\n+        \"\"\"\n+        cdef CFloatScalar* sp = <CFloatScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Date64Value(ArrayValue):\n+cdef class DoubleScalar(Scalar):\n     \"\"\"\n-    Concrete class for date64 array elements.\n+    Concrete class for double scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.datetime instance.\n+        Return this value as a Python float.\n         \"\"\"\n-        cdef CDate64Array* ap = <CDate64Array*> self.sp_array.get()\n-        return (datetime.date(1970, 1, 1) +\n-                datetime.timedelta(\n-                    days=ap.Value(self.index) / 86400000))\n+        cdef CDoubleScalar* sp = <CDoubleScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n \n-cdef class Time32Value(ArrayValue):\n+cdef class DecimalScalar(Scalar):\n     \"\"\"\n-    Concrete class for time32 array elements.\n+    Concrete class for decimal128 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python Decimal.\n         \"\"\"\n         cdef:\n-            CTime32Array* ap = <CTime32Array*> self.sp_array.get()\n-            CTime32Type* dtype = <CTime32Type*> ap.type().get()\n-\n-        if dtype.unit() == TimeUnit_SECOND:\n-            delta = datetime.timedelta(seconds=ap.Value(self.index))\n-            return (datetime.datetime(1970, 1, 1) + delta).time()\n+            CDecimal128Scalar* sp = <CDecimal128Scalar*> self.wrapped.get()\n+            CDecimal128Type* dtype = <CDecimal128Type*> sp.type.get()\n+        if sp.is_valid:\n+            return _pydecimal.Decimal(\n+                frombytes(sp.value.ToString(dtype.scale()))\n+            )\n         else:\n-            return _box_time_milli(ap.Value(self.index))\n+            return None\n \n \n-cdef class Time64Value(ArrayValue):\n+cdef class Date32Scalar(Scalar):\n     \"\"\"\n-    Concrete class for time64 array elements.\n+    Concrete class for date32 scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python datetime.timedelta instance.\n+        Return this value as a Python datetime.datetime instance.\n         \"\"\"\n-        cdef:\n-            CTime64Array* ap = <CTime64Array*> self.sp_array.get()\n-            CTime64Type* dtype = <CTime64Type*> ap.type().get()\n+        cdef CDate32Scalar* sp = <CDate32Scalar*> self.wrapped.get()\n \n-        cdef int64_t val = ap.Value(self.index)\n-        if dtype.unit() == TimeUnit_MICRO:\n-            return _box_time_micro(val)\n+        if sp.is_valid:\n+            # shift to seconds since epoch\n+            return (\n+                datetime.date(1970, 1, 1) + datetime.timedelta(days=sp.value)\n+            )\n         else:\n-            return (datetime.datetime(1970, 1, 1) +\n-                    datetime.timedelta(microseconds=val / 1000)).time()\n-\n+            return None\n \n-cpdef _box_time_milli(int64_t val):\n-    delta = datetime.timedelta(milliseconds=val)\n-    return (datetime.datetime(1970, 1, 1) + delta).time()\n \n+cdef class Date64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for date64 scalars.\n+    \"\"\"\n \n-cpdef _box_time_micro(int64_t val):\n-    return (datetime.datetime(1970, 1, 1) +\n-            datetime.timedelta(microseconds=val)).time()\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.datetime instance.\n+        \"\"\"\n+        cdef CDate64Scalar* sp = <CDate64Scalar*> self.wrapped.get()\n \n+        if sp.is_valid:\n+            return (\n+                datetime.date(1970, 1, 1) +\n+                datetime.timedelta(days=sp.value / 86400000)\n+            )\n+        else:\n+            return None\n \n-cdef dict _DATETIME_CONVERSION_FUNCTIONS = {}\n-cdef c_bool _datetime_conversion_initialized = False\n \n+def _datetime_from_int(int64_t value, TimeUnit unit, tzinfo=None):\n+    if unit == TimeUnit_SECOND:\n+        delta = datetime.timedelta(seconds=value)\n+    elif unit == TimeUnit_MILLI:\n+        delta = datetime.timedelta(milliseconds=value)\n+    elif unit == TimeUnit_MICRO:\n+        delta = datetime.timedelta(microseconds=value)\n+    else:\n+        # TimeUnit_NANO: prefer pandas timestamps if available\n+        if _pandas_api.have_pandas:\n+            return _pandas_api.pd.Timestamp(value, tz=tzinfo, unit='ns')\n+        # otherwise safely truncate to microsecond resolution datetime\n+        if value % 1000 != 0:\n+            raise ValueError(\n+                \"Nanosecond resolution temporal type {} is not safely \"\n+                \"convertible to microseconds to convert to datetime.datetime. \"\n+                \"Install pandas to return as Timestamp with nanosecond \"\n+                \"support or access the .value attribute.\".format(value)\n+            )\n+        delta = datetime.timedelta(microseconds=value)\n \n-cdef _add_micros_maybe_localize(dt, micros, tzinfo):\n-    import pytz\n-    dt = dt.replace(microsecond=micros)\n+    dt = datetime.datetime(1970, 1, 1) + delta\n+    # adjust timezone if set to the datatype\n     if tzinfo is not None:\n-        if not isinstance(tzinfo, datetime.tzinfo):\n-            tzinfo = string_to_tzinfo(tzinfo)\n         dt = tzinfo.fromutc(dt)\n-    return dt\n-\n-\n-cdef _datetime_from_seconds(int64_t v):\n-    return datetime.datetime(1970, 1, 1) + datetime.timedelta(seconds=v)\n-\n-\n-def _nanoseconds_to_datetime_safe(v, tzinfo):\n-    if v % 1000 != 0:\n-        raise ValueError(\"Nanosecond timestamp {} is not safely convertible \"\n-                         \" to microseconds to convert to datetime.datetime.\"\n-                         \" Install pandas to return as Timestamp with \"\n-                         \" nanosecond support or access the .value attribute.\")\n-    v = v // 1000\n-    micros = v % 1_000_000\n-\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n-\n-\n-def _microseconds_to_datetime(v, tzinfo):\n-    micros = v % 1_000_000\n-    dt = _datetime_from_seconds(v // 1_000_000)\n-    return _add_micros_maybe_localize(dt, micros, tzinfo)\n \n+    return dt\n \n-def _millis_to_datetime(v, tzinfo):\n-    millis = v % 1_000\n-    dt = _datetime_from_seconds(v // 1000)\n-    return _add_micros_maybe_localize(dt, millis * 1000, tzinfo)\n \n+cdef class Time32Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time32 scalars.\n+    \"\"\"\n \n-def _seconds_to_datetime(v, tzinfo):\n-    dt = _datetime_from_seconds(v)\n-    return _add_micros_maybe_localize(dt, 0, tzinfo)\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime32Scalar* sp = <CTime32Scalar*> self.wrapped.get()\n+            CTime32Type* dtype = <CTime32Type*> sp.type.get()\n \n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n-def _datetime_conversion_functions():\n-    global _datetime_conversion_initialized\n-    if _datetime_conversion_initialized:\n-        return _DATETIME_CONVERSION_FUNCTIONS\n \n-    _DATETIME_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: _seconds_to_datetime,\n-        TimeUnit_MILLI: _millis_to_datetime,\n-        TimeUnit_MICRO: _microseconds_to_datetime,\n-        TimeUnit_NANO: _nanoseconds_to_datetime_safe\n-    })\n+cdef class Time64Scalar(Scalar):\n+    \"\"\"\n+    Concrete class for time64 scalars.\n+    \"\"\"\n \n-    try:\n-        import pandas as pd\n-        _DATETIME_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda x, tzinfo: pd.Timestamp(\n-                x, tz=tzinfo, unit='ns',\n-            )\n-        )\n-    except ImportError:\n-        pass\n+    def as_py(self):\n+        \"\"\"\n+        Return this value as a Python datetime.timedelta instance.\n+        \"\"\"\n+        cdef:\n+            CTime64Scalar* sp = <CTime64Scalar*> self.wrapped.get()\n+            CTime64Type* dtype = <CTime64Type*> sp.type.get()\n \n-    _datetime_conversion_initialized = True\n-    return _DATETIME_CONVERSION_FUNCTIONS\n+        if sp.is_valid:\n+            return _datetime_from_int(sp.value, unit=dtype.unit()).time()\n+        else:\n+            return None\n \n \n-cdef class TimestampValue(ArrayValue):\n+cdef class TimestampScalar(Scalar):\n     \"\"\"\n-    Concrete class for timestamp array elements.\n+    Concrete class for timestamp scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n-        return ap.Value(self.index)\n+        cdef CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CTimestampArray* ap = <CTimestampArray*> self.sp_array.get()\n-        cdef CTimestampType* dtype = <CTimestampType*> ap.type().get()\n+        cdef:\n+            CTimestampScalar* sp = <CTimestampScalar*> self.wrapped.get()\n+            CTimestampType* dtype = <CTimestampType*> sp.type.get()\n \n-        value = self.value\n+        if not sp.is_valid:\n+            return None\n \n         if not dtype.timezone().empty():\n             tzinfo = string_to_tzinfo(frombytes(dtype.timezone()))\n+            if not isinstance(tzinfo, datetime.tzinfo):\n+                tzinfo = string_to_tzinfo(tzinfo)\n         else:\n             tzinfo = None\n \n-        try:\n-            converter = _datetime_conversion_functions()[dtype.unit()]\n-        except KeyError:\n-            raise ValueError(\n-                'Cannot convert nanosecond timestamps without pandas'\n-            )\n-        return converter(value, tzinfo=tzinfo)\n-\n-\n-cdef dict _TIMEDELTA_CONVERSION_FUNCTIONS = {}\n-\n-\n-def _nanoseconds_to_timedelta_safe(v):\n-    if v % 1000 != 0:\n-        raise ValueError(\n-            \"Nanosecond duration {} is not safely convertible to microseconds \"\n-            \"to convert to datetime.timedelta. Install pandas to return as \"\n-            \"Timedelta with nanosecond support or access the .value \"\n-            \"attribute.\".format(v))\n-    micros = v // 1000\n-\n-    return datetime.timedelta(microseconds=micros)\n-\n+        return _datetime_from_int(sp.value, unit=dtype.unit(), tzinfo=tzinfo)\n \n-def _timedelta_conversion_functions():\n-    if _TIMEDELTA_CONVERSION_FUNCTIONS:\n-        return _TIMEDELTA_CONVERSION_FUNCTIONS\n \n-    _TIMEDELTA_CONVERSION_FUNCTIONS.update({\n-        TimeUnit_SECOND: lambda v: datetime.timedelta(seconds=v),\n-        TimeUnit_MILLI: lambda v: datetime.timedelta(milliseconds=v),\n-        TimeUnit_MICRO: lambda v: datetime.timedelta(microseconds=v),\n-        TimeUnit_NANO: _nanoseconds_to_timedelta_safe\n-    })\n-\n-    try:\n-        import pandas as pd\n-        _TIMEDELTA_CONVERSION_FUNCTIONS[TimeUnit_NANO] = (\n-            lambda v: pd.Timedelta(v, unit='ns')\n-        )\n-    except ImportError:\n-        pass\n-\n-    return _TIMEDELTA_CONVERSION_FUNCTIONS\n-\n-\n-cdef class DurationValue(ArrayValue):\n+cdef class DurationScalar(Scalar):\n     \"\"\"\n-    Concrete class for duration array elements.\n+    Concrete class for duration scalars.\n     \"\"\"\n \n     @property\n     def value(self):\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        cdef CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+        return sp.value if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n         Return this value as a Pandas Timestamp instance (if available),\n         otherwise as a Python datetime.timedelta instance.\n         \"\"\"\n-        cdef CDurationArray* ap = <CDurationArray*> self.sp_array.get()\n-        cdef CDurationType* dtype = <CDurationType*> ap.type().get()\n-\n-        cdef int64_t value = ap.Value(self.index)\n-        converter = _timedelta_conversion_functions()[dtype.unit()]\n-        return converter(value)\n-\n+        cdef:\n+            CDurationScalar* sp = <CDurationScalar*> self.wrapped.get()\n+            CDurationType* dtype = <CDurationType*> sp.type.get()\n+            TimeUnit unit = dtype.unit()\n \n-cdef class HalfFloatValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float16 array elements.\n-    \"\"\"\n+        if not sp.is_valid:\n+            return None\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python float.\n-        \"\"\"\n-        cdef CHalfFloatArray* ap = <CHalfFloatArray*> self.sp_array.get()\n-        return PyHalf_FromHalf(ap.Value(self.index))\n+        if unit == TimeUnit_SECOND:\n+            return datetime.timedelta(seconds=sp.value)\n+        elif unit == TimeUnit_MILLI:\n+            return datetime.timedelta(milliseconds=sp.value)\n+        elif unit == TimeUnit_MICRO:\n+            return datetime.timedelta(microseconds=sp.value)\n+        else:\n+            # TimeUnit_NANO: prefer pandas timestamps if available\n+            if _pandas_api.have_pandas:\n+                return _pandas_api.pd.Timedelta(sp.value, unit='ns')\n+            # otherwise safely truncate to microsecond resolution timedelta\n+            if sp.value % 1000 != 0:\n+                raise ValueError(\n+                    \"Nanosecond duration {} is not safely convertible to \"\n+                    \"microseconds to convert to datetime.timedelta. Install \"\n+                    \"pandas to return as Timedelta with nanosecond support or \"\n+                    \"access the .value attribute.\".format(sp.value)\n+                )\n+            return datetime.timedelta(microseconds=sp.value // 1000)\n \n \n-cdef class FloatValue(ArrayValue):\n+cdef class BinaryScalar(Scalar):\n     \"\"\"\n-    Concrete class for float32 array elements.\n+    Concrete class for binary-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def as_buffer(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return a view over this value as a Buffer object.\n         \"\"\"\n-        cdef CFloatArray* ap = <CFloatArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n-\n-\n-cdef class DoubleValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for float64 array elements.\n-    \"\"\"\n+        cdef CBinaryScalar* sp = <CBinaryScalar*> self.wrapped.get()\n+        return pyarrow_wrap_buffer(sp.value) if sp.is_valid else None\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python float.\n+        Return this value as a Python bytes.\n         \"\"\"\n-        cdef CDoubleArray* ap = <CDoubleArray*> self.sp_array.get()\n-        return ap.Value(self.index)\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return self.as_buffer().to_pybytes()\n+        else:\n+            return None\n \n \n-cdef class DecimalValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for decimal128 array elements.\n-    \"\"\"\n+cdef class LargeBinaryScalar(BinaryScalar):\n+    pass\n \n-    def as_py(self):\n-        \"\"\"\n-        Return this value as a Python Decimal.\n-        \"\"\"\n-        cdef:\n-            CDecimal128Array* ap = <CDecimal128Array*> self.sp_array.get()\n-            c_string s = ap.FormatValue(self.index)\n-        return _pydecimal.Decimal(s.decode('utf8'))\n \n+cdef class FixedSizeBinaryScalar(BinaryScalar):\n+    pass\n \n-cdef class StringValue(ArrayValue):\n+\n+cdef class StringScalar(BinaryScalar):\n     \"\"\"\n-    Concrete class for string (utf8) array elements.\n+    Concrete class for string-like (utf8) scalars.\n     \"\"\"\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return this value as a Python string.\n         \"\"\"\n-        cdef CStringArray* ap = <CStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        buffer = self.as_buffer()\n+        if buffer is not None:\n+            return frombytes(self.as_buffer().to_pybytes())\n+        else:\n+            return None\n \n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CStringArray* ap = <CStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+cdef class LargeStringScalar(StringScalar):\n+    pass\n \n \n-cdef class LargeStringValue(ArrayValue):\n+cdef class ListScalar(Scalar):\n     \"\"\"\n-    Concrete class for large string (utf8) array elements.\n+    Concrete class for list-like scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    cdef array(self):\n+        cdef CListScalar* sp = <CListScalar*> self.wrapped.get()\n+        if sp.is_valid:\n+            return pyarrow_wrap_array(sp.value)\n+        else:\n+            return None\n+\n+    def __len__(self):\n         \"\"\"\n-        Return this value as a Python unicode string.\n+        Return the number of values.\n         \"\"\"\n-        cdef CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-        return ap.GetString(self.index).decode('utf-8')\n+        return len(self.array())\n \n-    def as_buffer(self):\n+    def __getitem__(self, i):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return the value at the given index.\n         \"\"\"\n-        cdef:\n-            CLargeStringArray* ap = <CLargeStringArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n-\n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+        return self.array()[_normalize_index(i, len(self))]\n \n-\n-cdef class BinaryValue(ArrayValue):\n-    \"\"\"\n-    Concrete class for variable-sized binary array elements.\n-    \"\"\"\n+    def __iter__(self):\n+        \"\"\"\n+        Iterate over this element's values.\n+        \"\"\"\n+        return iter(self.array())\n \n     def as_py(self):\n         \"\"\"\n-        Return this value as a Python bytes object.\n+        Return this value as a Python list.\n         \"\"\"\n-        cdef:\n-            const uint8_t* ptr\n-            int32_t length\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n+        arr = self.array()\n+        return None if arr is None else arr.to_pylist()\n \n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n \n-    def as_buffer(self):\n-        \"\"\"\n-        Return a view over this value as a Buffer object.\n-        \"\"\"\n-        cdef:\n-            CBinaryArray* ap = <CBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+cdef class FixedSizeListScalar(ListScalar):\n+    pass\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n \n+cdef class LargeListScalar(ListScalar):\n+    pass\n \n-cdef class LargeBinaryValue(ArrayValue):\n+\n+cdef class StructScalar(Scalar):\n     \"\"\"\n-    Concrete class for large variable-sized binary array elements.\n+    Concrete class for struct scalars.\n     \"\"\"\n \n-    def as_py(self):\n+    def __len__(self):\n+        cdef CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+        return sp.value.size()\n+\n+    def __getitem__(self, key):\n         \"\"\"\n-        Return this value as a Python bytes object.\n+        Return the child value for the given field.\n+\n+        Parameters\n+        ----------\n+        index : Union[int, str]\n+            Index / position or name of the field.\n+\n+        Returns\n+        -------\n+        result : Scalar\n         \"\"\"\n         cdef:\n-            const uint8_t* ptr\n-            int64_t length\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n+            CFieldRef ref\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+\n+        if isinstance(key, (bytes, str)):\n+            ref = CFieldRef(<c_string> tobytes(key))\n+        elif isinstance(key, int):\n+            ref = CFieldRef(<int> key)\n+        else:\n+            raise TypeError('Expected integer or string index')\n \n-        ptr = ap.GetValue(self.index, &length)\n-        return cp.PyBytes_FromStringAndSize(<const char*>(ptr), length)\n+        try:\n+            return Scalar.wrap(GetResultValue(sp.field(ref)))\n+        except ArrowInvalid:\n+            raise IndexError(key)\n \n-    def as_buffer(self):\n+    def as_py(self):\n         \"\"\"\n-        Return a view over this value as a Buffer object.\n+        Return this value as a Python dict.\n         \"\"\"\n         cdef:\n-            CLargeBinaryArray* ap = <CLargeBinaryArray*> self.sp_array.get()\n-            shared_ptr[CBuffer] buf\n+            CStructScalar* sp = <CStructScalar*> self.wrapped.get()\n+            CStructType* dtype = <CStructType*> sp.type.get()\n+            vector[shared_ptr[CField]] fields = dtype.fields()\n \n-        buf = SliceBuffer(ap.value_data(), ap.value_offset(self.index),\n-                          ap.value_length(self.index))\n-        return pyarrow_wrap_buffer(buf)\n+        if sp.is_valid:\n+            return {frombytes(fields[i].get().name()): Scalar.wrap(sp.value[i])\n\nReview comment:\n       Should we directly take the `as_py` from the values in the dict as well?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-06-25T13:34:00.541+0000",
                    "updated": "2020-06-25T13:34:00.541+0000",
                    "started": "2020-06-25T13:34:00.541+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "451029",
                    "issueId": "13311826"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 2400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@40d8462e[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2941506e[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3912f96d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@1a730c01[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@54a3eae[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@77c9beec[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@593ee8e9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5bafe4cb[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@f441e5e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@35c0ff84[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1b973075[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3f3a1670[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 2400,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Jul 07 11:55:22 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-07-07T11:55:22.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9153/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2020-06-16T21:37:13.000+0000",
        "updated": "2020-07-07T11:55:22.000+0000",
        "timeoriginalestimate": null,
        "description": "follow up to ARROW-8769",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 2400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Python] Add bindings for StructScalar",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13311826/comment/17152690",
                    "id": "17152690",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
                        "name": "kszucs",
                        "key": "kszucs",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Krisztian Szucs",
                        "active": true,
                        "timeZone": "Europe/Budapest"
                    },
                    "body": "Resolved by https://github.com/apache/arrow/pull/7519",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
                        "name": "kszucs",
                        "key": "kszucs",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Krisztian Szucs",
                        "active": true,
                        "timeZone": "Europe/Budapest"
                    },
                    "created": "2020-07-07T11:55:22.098+0000",
                    "updated": "2020-07-07T11:55:22.098+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0fwzs:",
        "customfield_12314139": null
    }
}