{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13317615",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615",
    "key": "ARROW-9523",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345977",
                "id": "12345977",
                "description": "",
                "name": "2.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-10-19"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348202",
                "id": "12348202",
                "name": "0.17.1",
                "archived": false,
                "released": true,
                "releaseDate": "2020-05-18"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": null,
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yordan-pavlov",
            "name": "yordan-pavlov",
            "key": "yordan-pavlov",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Yordan Pavlov",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yordan-pavlov",
            "name": "yordan-pavlov",
            "key": "yordan-pavlov",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Yordan Pavlov",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 12000,
            "total": 12000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 12000,
            "total": 12000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9523/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 20,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/460802",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov opened a new pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798\n\n\n   The filter kernel located here\u00a0https://github.com/apache/arrow/blob/master/rust/arrow/src/compute/kernels/filter.rs\r\n   \r\n   currently has the following performance:\r\n   \r\n   filter old u8 low selectivity time: [1.7782 ms 1.7790 ms 1.7801 ms]\r\n   filter old u8 high selectivity time: [815.58 us 816.58 us 817.57 us]\r\n   filter old u8 w NULLs low selectivity time: [1.8131 ms 1.8231 ms 1.8336 ms]\r\n   filter old u8 w NULLs high selectivity time:\u00a0[817.41 us 820.01 us 823.05 us]\r\n   \r\n   I have been working on a new implementation which performs\u00a0between approximately 14 and 480 times faster depending mostly on filter selectivity. Here are the benchmark results:\r\n   \r\n   filter u8 low selectivity time: [127.30 us 128.06 us 128.88 us]\r\n   filter u8 high selectivity time: [5.4215 us 5.5778 us 5.7335 us]\r\n   filter context u8 low selectivity time: [124.21 us 126.21 us 128.38 us]\r\n   filter context u8 high selectivity time: [1.6707 us 1.7052 us 1.7476 us]\r\n   filter context u8 w NULLs low selectivity time: [142.40 us 142.83 us 143.37 us]\r\n   filter context u8 w NULLs high selectivity time: [2.3338 us 2.3788 us 2.4304 us]\r\n   filter context f32 low selectivity time: [132.59 us 132.91 us 133.29 us]\r\n   filter context f32 high selectivity time: [1.6864 us 1.7026 us 1.7212 us]\r\n   \r\n   This new implementation is based on a few key ideas:\r\n   \r\n   (1) if the data array being filtered doesn't have a null bitmap, no time should be wasted to copy or create a null bitmap in the resulting filtered data array - this is implemented using the\u00a0CopyNullBit trait which has a no-op implementation and an actual implementation\r\n   \r\n   (2) when the filter is highly selective, e.g. only a small number of values from the data array are selected, the filter implementation should efficiently skip entire batches of 0s in the filter array - this is implemented by transmuting the filter array to u64 which allows to quickly check and skip entire batches of 64 bits\u00a0\r\n   \r\n   (3) when an entire record batch is filtered, any computation which only depends on the filter array is done once and then shared for filtering all the data arrays in the record batch - this is implemented using the\u00a0FilterContext\u00a0struct\r\n   \r\n   This pull request also implements support for filtering dictionary arrays.\u00a0\r\n   \r\n   @paddyhoran @andygrove \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-19T11:33:39.558+0000",
                    "updated": "2020-07-19T11:33:39.558+0000",
                    "started": "2020-07-19T11:33:39.557+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "460802",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/460806",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-660631547\n\n\n   https://issues.apache.org/jira/browse/ARROW-9523\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-19T11:46:58.892+0000",
                    "updated": "2020-07-19T11:46:58.892+0000",
                    "started": "2020-07-19T11:46:58.892+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "460806",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/460827",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-660678597\n\n\n   I refer you all to the work that we've recently done in C++ where we use popcount on 64 bits at a time to efficiently compute the size of the filter output as well as quickly compute the filtered output. It might be worth replicating the \"BitBlockCounter\" concept in Rust\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-19T17:17:53.418+0000",
                    "updated": "2020-07-19T17:17:53.418+0000",
                    "started": "2020-07-19T17:17:53.418+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "460827",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/461200",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-661255507\n\n\n   @yordan-pavlov This is exciting! I will start reviewing this later today.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-20T18:22:03.988+0000",
                    "updated": "2020-07-20T18:22:03.988+0000",
                    "started": "2020-07-20T18:22:03.988+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "461200",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/463125",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov commented on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-663718817\n\n\n   just for reference, I think the relevant C++ filter implementation (which wesm is referring to) is in the PrimitiveFilterImpl class here https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernels/vector_selection.cc#L558 \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-24T20:24:07.106+0000",
                    "updated": "2020-07-24T20:24:07.106+0000",
                    "started": "2020-07-24T20:24:07.106+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463125",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/463216",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#discussion_r460365103\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/filter.rs\n##########\n@@ -17,139 +17,443 @@\n \n //! Defines miscellaneous array kernels.\n \n-use std::sync::Arc;\n-\n use crate::array::*;\n use crate::datatypes::{ArrowNumericType, DataType, TimeUnit};\n use crate::error::{ArrowError, Result};\n+use crate::record_batch::RecordBatch;\n+use crate::{\n+    bitmap::Bitmap,\n+    buffer::{Buffer, MutableBuffer},\n+    memory,\n+    util::bit_util,\n+};\n+use std::{mem, sync::Arc};\n \n-/// Helper function to perform boolean lambda function on values from two arrays.\n-fn bool_op<T, F>(\n-    left: &PrimitiveArray<T>,\n-    right: &PrimitiveArray<T>,\n-    op: F,\n-) -> Result<BooleanArray>\n-where\n-    T: ArrowNumericType,\n-    F: Fn(Option<T::Native>, Option<T::Native>) -> bool,\n-{\n-    if left.len() != right.len() {\n-        return Err(ArrowError::ComputeError(\n-            \"Cannot perform math operation on arrays of different length\".to_string(),\n-        ));\n+/// trait for copying filtered null bitmap bits\n+trait CopyNullBit {\n+    fn copy_null_bit(&mut self, source_index: usize);\n+    fn null_count(&self) -> usize;\n+    fn null_buffer(&mut self) -> Buffer;\n+}\n+\n+/// no-op null bitmap copy implementation,\n+/// used when the filtered data array doesn't have a null bitmap\n+struct NullBitNoop {}\n+\n+impl NullBitNoop {\n+    fn new() -> Self {\n+        NullBitNoop {}\n     }\n-    let mut b = BooleanArray::builder(left.len());\n-    for i in 0..left.len() {\n-        let index = i;\n-        let l = if left.is_null(i) {\n-            None\n-        } else {\n-            Some(left.value(index))\n-        };\n-        let r = if right.is_null(i) {\n-            None\n-        } else {\n-            Some(right.value(index))\n-        };\n-        b.append_value(op(l, r))?;\n+}\n+\n+impl CopyNullBit for NullBitNoop {\n+    #[inline]\n+    fn copy_null_bit(&mut self, _source_index: usize) {\n+        // do nothing\n+    }\n+\n+    fn null_count(&self) -> usize {\n+        0\n+    }\n+\n+    fn null_buffer(&mut self) -> Buffer {\n+        Buffer::from([0u8; 0])\n     }\n-    Ok(b.finish())\n }\n \n-macro_rules! filter_array {\n-    ($array:expr, $filter:expr, $array_type:ident) => {{\n-        let b = $array.as_any().downcast_ref::<$array_type>().unwrap();\n-        let mut builder = $array_type::builder(b.len());\n-        for i in 0..b.len() {\n-            if $filter.value(i) {\n-                if b.is_null(i) {\n-                    builder.append_null()?;\n-                } else {\n-                    builder.append_value(b.value(i))?;\n-                }\n-            }\n-        }\n-        Ok(Arc::new(builder.finish()))\n-    }};\n+/// null bitmap copy implementation,\n+/// used when the filtered data array has a null bitmap\n+struct NullBitSetter<'a> {\n+    target_buffer: MutableBuffer,\n+    source_bytes: &'a [u8],\n+    target_index: usize,\n+    null_count: usize,\n }\n \n-/// Returns the array, taking only the elements matching the filter\n-pub fn filter(array: &Array, filter: &BooleanArray) -> Result<ArrayRef> {\n-    match array.data_type() {\n-        DataType::UInt8 => filter_array!(array, filter, UInt8Array),\n-        DataType::UInt16 => filter_array!(array, filter, UInt16Array),\n-        DataType::UInt32 => filter_array!(array, filter, UInt32Array),\n-        DataType::UInt64 => filter_array!(array, filter, UInt64Array),\n-        DataType::Int8 => filter_array!(array, filter, Int8Array),\n-        DataType::Int16 => filter_array!(array, filter, Int16Array),\n-        DataType::Int32 => filter_array!(array, filter, Int32Array),\n-        DataType::Int64 => filter_array!(array, filter, Int64Array),\n-        DataType::Float32 => filter_array!(array, filter, Float32Array),\n-        DataType::Float64 => filter_array!(array, filter, Float64Array),\n-        DataType::Boolean => filter_array!(array, filter, BooleanArray),\n-        DataType::Date32(_) => filter_array!(array, filter, Date32Array),\n-        DataType::Date64(_) => filter_array!(array, filter, Date64Array),\n-        DataType::Time32(TimeUnit::Second) => {\n-            filter_array!(array, filter, Time32SecondArray)\n-        }\n-        DataType::Time32(TimeUnit::Millisecond) => {\n-            filter_array!(array, filter, Time32MillisecondArray)\n-        }\n-        DataType::Time64(TimeUnit::Microsecond) => {\n-            filter_array!(array, filter, Time64MicrosecondArray)\n-        }\n-        DataType::Time64(TimeUnit::Nanosecond) => {\n-            filter_array!(array, filter, Time64NanosecondArray)\n-        }\n-        DataType::Duration(TimeUnit::Second) => {\n-            filter_array!(array, filter, DurationSecondArray)\n-        }\n-        DataType::Duration(TimeUnit::Millisecond) => {\n-            filter_array!(array, filter, DurationMillisecondArray)\n+impl<'a> NullBitSetter<'a> {\n+    fn new(null_bitmap: &'a Bitmap) -> Self {\n+        let null_bytes = null_bitmap.buffer_ref().data();\n+        // create null bitmap buffer with same length and initialize null bitmap buffer to 1s\n+        let null_buffer =\n+            MutableBuffer::new(null_bytes.len()).with_bitset(null_bytes.len(), true);\n+        NullBitSetter {\n+            source_bytes: null_bytes,\n+            target_buffer: null_buffer,\n+            target_index: 0,\n+            null_count: 0,\n         }\n-        DataType::Duration(TimeUnit::Microsecond) => {\n-            filter_array!(array, filter, DurationMicrosecondArray)\n-        }\n-        DataType::Duration(TimeUnit::Nanosecond) => {\n-            filter_array!(array, filter, DurationNanosecondArray)\n-        }\n-        DataType::Timestamp(TimeUnit::Second, _) => {\n-            filter_array!(array, filter, TimestampSecondArray)\n+    }\n+}\n+\n+impl<'a> CopyNullBit for NullBitSetter<'a> {\n+    #[inline]\n+    fn copy_null_bit(&mut self, source_index: usize) {\n+        if !bit_util::get_bit(self.source_bytes, source_index) {\n+            // this is not actually unsafe because of the condition above + target_buffer.len() == source_bytes.len()\n+            unsafe {\n+                bit_util::unset_bit_raw(\n+                    self.target_buffer.raw_data_mut(),\n+                    self.target_index,\n+                );\n+            }\n+            self.null_count += 1;\n         }\n-        DataType::Timestamp(TimeUnit::Millisecond, _) => {\n-            filter_array!(array, filter, TimestampMillisecondArray)\n+        self.target_index += 1;\n+    }\n+\n+    fn null_count(&self) -> usize {\n+        self.null_count\n+    }\n+\n+    fn null_buffer(&mut self) -> Buffer {\n+        self.target_buffer.resize(self.target_index).unwrap();\n+        // use mem::replace to detach self.target_buffer from self so that it can be returned\n+        let target_buffer = mem::replace(&mut self.target_buffer, MutableBuffer::new(0));\n+        target_buffer.freeze()\n+    }\n+}\n+\n+fn get_null_bit_setter<'a>(data_array: &'a impl Array) -> Box<CopyNullBit + 'a> {\n+    if let Some(null_bitmap) = data_array.data_ref().null_bitmap() {\n+        // only return an actual null bit copy implementation if null_bitmap is set\n+        Box::new(NullBitSetter::new(null_bitmap))\n+    } else {\n+        // otherwise return a no-op copy null bit implementation\n+        // for improved performance when the filtered array doesn't contain NULLs\n+        Box::new(NullBitNoop::new())\n+    }\n+}\n+\n+// transmute filter array to u64\n+// - optimize filtering with highly selective filters by skipping entire batches of 64 filter bits\n+// - if the data array being filtered doesn't have a null bitmap, no time is wasted to copy a null bitmap\n+fn filter_array_impl(\n+    filter_context: &FilterContext,\n+    data_array: &impl Array,\n+    array_type: DataType,\n+    value_size: usize,\n+) -> Result<ArrayDataBuilder> {\n+    if filter_context.filter_len > data_array.len() {\n+        return Err(ArrowError::ComputeError(\n+            \"Filter array cannot be larger than data array\".to_string(),\n+        ));\n+    }\n+    let filtered_count = filter_context.filtered_count;\n+    let filter_mask = &filter_context.filter_mask;\n+    let filter_u64 = &filter_context.filter_u64;\n+    let data_start = data_array.data_ref().buffers()[0].raw_data();\n+    let mut value_buffer = MutableBuffer::new(filtered_count * value_size);\n+    value_buffer.resize(filtered_count * value_size)?;\n+    let mut value_position = value_buffer.raw_data_mut();\n+    let mut null_bit_setter = get_null_bit_setter(data_array);\n+    let null_bit_setter = null_bit_setter.as_mut();\n+\n+    for (i, filter_batch) in filter_u64.iter().enumerate() {\n+        // foreach u64 batch\n+        let filter_batch = *filter_batch;\n+        if filter_batch == 0 {\n+            // if batch == 0: skip\n+            continue;\n         }\n-        DataType::Timestamp(TimeUnit::Microsecond, _) => {\n-            filter_array!(array, filter, TimestampMicrosecondArray)\n+        for (j, filter_mask) in filter_mask.iter().enumerate() {\n+            // foreach bit in batch:\n+            if (filter_batch & *filter_mask) != 0 {\n+                let data_index = (i * 64) + j;\n+                null_bit_setter.copy_null_bit(data_index);\n+                // if filter bit == 1: copy data value to temp array\n+                unsafe {\n+                    // this should be safe because of the data_array.len() check at the beginning of the method\n+                    memory::memcpy(\n+                        value_position,\n+                        data_start.add(value_size * data_index),\n+                        value_size,\n+                    );\n+                    value_position = value_position.add(value_size);\n+                }\n+            }\n         }\n-        DataType::Timestamp(TimeUnit::Nanosecond, _) => {\n-            filter_array!(array, filter, TimestampNanosecondArray)\n+    }\n+\n+    let mut array_data_builder = ArrayDataBuilder::new(array_type)\n+        .len(filtered_count)\n+        .add_buffer(value_buffer.freeze());\n+    if null_bit_setter.null_count() > 0 {\n+        array_data_builder = array_data_builder\n+            .null_count(null_bit_setter.null_count())\n+            .null_bit_buffer(null_bit_setter.null_buffer());\n+    }\n+\n+    Ok(array_data_builder)\n+}\n+\n+/// FilterContext can be used to improve performance when\n+/// filtering multiple data arrays with the same filter array.\n+#[derive(Debug)]\n+pub struct FilterContext {\n+    filter_u64: Vec<u64>,\n+    filter_len: usize,\n+    filtered_count: usize,\n+    filter_mask: Vec<u64>,\n+}\n+\n+macro_rules! filter_primitive_array {\n+    ($context:expr, $array:expr, $array_type:ident) => {{\n+        let input_array = $array.as_any().downcast_ref::<$array_type>().unwrap();\n+        let output_array = $context.filter_primitive_array(input_array)?;\n+        Ok(Arc::new(output_array))\n+    }};\n+}\n+\n+macro_rules! filter_dictionary_array {\n+    ($context:expr, $array:expr, $array_type:ident) => {{\n+        let input_array = $array.as_any().downcast_ref::<$array_type>().unwrap();\n+        let output_array = $context.filter_dictionary_array(input_array)?;\n+        Ok(Arc::new(output_array))\n+    }};\n+}\n+\n+impl FilterContext {\n+    /// Returns a new instance of FilterContext\n+    pub fn new(filter_array: &BooleanArray) -> Self {\n+        let filter_mask: Vec<u64> = (0..64).map(|x| 1u64 << x).collect();\n+        let filter_bytes = filter_array.data_ref().buffers()[0].data();\n+        let filtered_count = bit_util::count_set_bits(filter_bytes);\n+        // transmute filter_bytes to &[u64]\n+        let mut u64_buffer = MutableBuffer::new(filter_bytes.len());\n+        u64_buffer\n+            .write_bytes(filter_bytes, u64_buffer.capacity() - filter_bytes.len())\n+            .unwrap();\n+        let filter_u64 = u64_buffer.typed_data_mut::<u64>().to_owned();\n+        FilterContext {\n+            filter_u64,\n+            filter_len: filter_array.len(),\n+            filtered_count,\n+            filter_mask,\n         }\n-        DataType::Binary => {\n-            let b = array.as_any().downcast_ref::<BinaryArray>().unwrap();\n-            let mut values: Vec<&[u8]> = Vec::with_capacity(b.len());\n-            for i in 0..b.len() {\n-                if filter.value(i) {\n-                    values.push(b.value(i));\n+    }\n+\n+    /// Returns a new array, containing only the elements matching the filter\n+    pub fn filter(&self, array: &Array) -> Result<ArrayRef> {\n+        match array.data_type() {\n+            DataType::UInt8 => filter_primitive_array!(self, array, UInt8Array),\n+            DataType::UInt16 => filter_primitive_array!(self, array, UInt16Array),\n+            DataType::UInt32 => filter_primitive_array!(self, array, UInt32Array),\n+            DataType::UInt64 => filter_primitive_array!(self, array, UInt64Array),\n+            DataType::Int8 => filter_primitive_array!(self, array, Int8Array),\n+            DataType::Int16 => filter_primitive_array!(self, array, Int16Array),\n+            DataType::Int32 => filter_primitive_array!(self, array, Int32Array),\n+            DataType::Int64 => filter_primitive_array!(self, array, Int64Array),\n+            DataType::Float32 => filter_primitive_array!(self, array, Float32Array),\n+            DataType::Float64 => filter_primitive_array!(self, array, Float64Array),\n+            DataType::Boolean => {\n+                let input_array = array.as_any().downcast_ref::<BooleanArray>().unwrap();\n+                let mut builder = BooleanArray::builder(self.filtered_count);\n+                for i in 0..self.filter_u64.len() {\n+                    // foreach u64 batch\n+                    let filter_batch = self.filter_u64[i];\n+                    if filter_batch == 0 {\n+                        // if batch == 0: skip\n+                        continue;\n+                    }\n+                    for j in 0..64 {\n+                        // foreach bit in batch:\n+                        if (filter_batch & self.filter_mask[j]) != 0 {\n+                            let data_index = (i * 64) + j;\n+                            if input_array.is_null(data_index) {\n+                                builder.append_null()?;\n+                            } else {\n+                                builder.append_value(input_array.value(data_index))?;\n+                            }\n+                        }\n+                    }\n                 }\n+                Ok(Arc::new(builder.finish()))\n+            },\n+            DataType::Date32(_) => filter_primitive_array!(self, array, Date32Array),\n+            DataType::Date64(_) => filter_primitive_array!(self, array, Date64Array),\n+            DataType::Time32(TimeUnit::Second) => {\n+                filter_primitive_array!(self, array, Time32SecondArray)\n             }\n-            Ok(Arc::new(BinaryArray::from(values)))\n-        }\n-        DataType::Utf8 => {\n-            let b = array.as_any().downcast_ref::<StringArray>().unwrap();\n-            let mut values: Vec<&str> = Vec::with_capacity(b.len());\n-            for i in 0..b.len() {\n-                if filter.value(i) {\n-                    values.push(b.value(i));\n+            DataType::Time32(TimeUnit::Millisecond) => {\n+                filter_primitive_array!(self, array, Time32MillisecondArray)\n+            }\n+            DataType::Time64(TimeUnit::Microsecond) => {\n+                filter_primitive_array!(self, array, Time64MicrosecondArray)\n+            }\n+            DataType::Time64(TimeUnit::Nanosecond) => {\n+                filter_primitive_array!(self, array, Time64NanosecondArray)\n+            }\n+            DataType::Duration(TimeUnit::Second) => {\n+                filter_primitive_array!(self, array, DurationSecondArray)\n+            }\n+            DataType::Duration(TimeUnit::Millisecond) => {\n+                filter_primitive_array!(self, array, DurationMillisecondArray)\n+            }\n+            DataType::Duration(TimeUnit::Microsecond) => {\n+                filter_primitive_array!(self, array, DurationMicrosecondArray)\n+            }\n+            DataType::Duration(TimeUnit::Nanosecond) => {\n+                filter_primitive_array!(self, array, DurationNanosecondArray)\n+            }\n+            DataType::Timestamp(TimeUnit::Second, _) => {\n+                filter_primitive_array!(self, array, TimestampSecondArray)\n+            }\n+            DataType::Timestamp(TimeUnit::Millisecond, _) => {\n+                filter_primitive_array!(self, array, TimestampMillisecondArray)\n+            }\n+            DataType::Timestamp(TimeUnit::Microsecond, _) => {\n+                filter_primitive_array!(self, array, TimestampMicrosecondArray)\n+            }\n+            DataType::Timestamp(TimeUnit::Nanosecond, _) => {\n+                filter_primitive_array!(self, array, TimestampNanosecondArray)\n+            }\n+            DataType::Binary => {\n+                let input_array = array.as_any().downcast_ref::<BinaryArray>().unwrap();\n+                let mut values: Vec<&[u8]> = Vec::with_capacity(self.filtered_count);\n+                for i in 0..self.filter_u64.len() {\n+                    // foreach u64 batch\n+                    let filter_batch = self.filter_u64[i];\n+                    if filter_batch == 0 {\n+                        // if batch == 0: skip\n+                        continue;\n+                    }\n+                    for j in 0..64 {\n+                        // foreach bit in batch:\n+                        if (filter_batch & self.filter_mask[j]) != 0 {\n+                            let data_index = (i * 64) + j;\n+                            values.push(input_array.value(data_index));\n+                        }\n+                    }\n                 }\n+                Ok(Arc::new(BinaryArray::from(values)))\n             }\n-            Ok(Arc::new(StringArray::from(values)))\n+            DataType::Utf8 => {\n+                let input_array = array.as_any().downcast_ref::<StringArray>().unwrap();\n+                let mut values: Vec<&str> = Vec::with_capacity(self.filtered_count);\n+                for i in 0..self.filter_u64.len() {\n+                    // foreach u64 batch\n+                    let filter_batch = self.filter_u64[i];\n+                    if filter_batch == 0 {\n+                        // if batch == 0: skip\n+                        continue;\n+                    }\n+                    for j in 0..64 {\n+                        // foreach bit in batch:\n+                        if (filter_batch & self.filter_mask[j]) != 0 {\n+                            let data_index = (i * 64) + j;\n+                            values.push(input_array.value(data_index));\n+                        }\n+                    }\n+                }\n+                Ok(Arc::new(StringArray::from(values)))\n+            }\n+            DataType::Dictionary(ref key_type, ref value_type) => match (key_type.as_ref(), value_type.as_ref()) {\n+                (key_type, DataType::Utf8) => match key_type {\n+                    DataType::UInt8 => filter_dictionary_array!(self, array, UInt8DictionaryArray),\n+                    DataType::UInt16 => filter_dictionary_array!(self, array, UInt16DictionaryArray),\n+                    DataType::UInt32 => filter_dictionary_array!(self, array, UInt32DictionaryArray),\n+                    DataType::UInt64 => filter_dictionary_array!(self, array, UInt64DictionaryArray),\n+                    DataType::Int8 => filter_dictionary_array!(self, array, Int8DictionaryArray),\n+                    DataType::Int16 => filter_dictionary_array!(self, array, Int16DictionaryArray),\n+                    DataType::Int32 => filter_dictionary_array!(self, array, Int32DictionaryArray),\n+                    DataType::Int64 => filter_dictionary_array!(self, array, Int64DictionaryArray),\n+                    other => Err(ArrowError::ComputeError(format!(\n+                        \"filter not supported for string dictionary with key of type {:?}\",\n+                        other\n+                    )))\n+                }\n+                (key_type, value_type) => Err(ArrowError::ComputeError(format!(\n+                    \"filter not supported for Dictionary({:?}, {:?})\",\n+                    key_type, value_type\n+                )))\n+            }\n+            other => Err(ArrowError::ComputeError(format!(\n+                \"filter not supported for {:?}\",\n+                other\n+            ))),\n         }\n-        other => Err(ArrowError::ComputeError(format!(\n-            \"filter not supported for {:?}\",\n-            other\n-        ))),\n     }\n+\n+    /// Returns a new PrimitiveArray<T> containing only those values from the array passed as the data_array parameter,\n+    /// selected by the BooleanArray passed as the filter_array parameter\n+    pub fn filter_primitive_array<T>(\n+        &self,\n+        data_array: &PrimitiveArray<T>,\n+    ) -> Result<PrimitiveArray<T>>\n+    where\n+        T: ArrowNumericType,\n+    {\n+        let array_type = T::get_data_type();\n+        let value_size = mem::size_of::<T::Native>();\n+        let array_data_builder =\n+            filter_array_impl(self, data_array, array_type, value_size)?;\n+        let data = array_data_builder.build();\n+        Ok(PrimitiveArray::<T>::from(data))\n+    }\n+\n+    /// Returns a new DictionaryArray<T> containing only those keys from the array passed as the data_array parameter,\n+    /// selected by the BooleanArray passed as the filter_array parameter. The values are cloned from the data_array.\n+    pub fn filter_dictionary_array<T>(\n+        &self,\n+        data_array: &DictionaryArray<T>,\n+    ) -> Result<DictionaryArray<T>>\n+    where\n+        T: ArrowNumericType,\n+    {\n+        let array_type = data_array.data_type().clone();\n+        let value_size = mem::size_of::<T::Native>();\n+        let mut array_data_builder =\n+            filter_array_impl(self, data_array, array_type, value_size)?;\n+        // copy dictionary values from input array\n+        array_data_builder =\n+            array_data_builder.add_child_data(data_array.values().data());\n+        let data = array_data_builder.build();\n+        Ok(DictionaryArray::<T>::from(data))\n+    }\n+}\n+\n+/// Returns a new array, containing only the elements matching the filter.\n+pub fn filter(array: &Array, filter: &BooleanArray) -> Result<ArrayRef> {\n+    FilterContext::new(filter).filter(array)\n+}\n+\n+/// Returns a new PrimitiveArray<T> containing only those values from the array passed as the data_array parameter,\n+/// selected by the BooleanArray passed as the filter_array parameter\n+pub fn filter_primitive_array<T>(\n+    data_array: &PrimitiveArray<T>,\n+    filter_array: &BooleanArray,\n+) -> Result<PrimitiveArray<T>>\n+where\n+    T: ArrowNumericType,\n+{\n+    FilterContext::new(filter_array).filter_primitive_array(data_array)\n+}\n+\n+/// Returns a new DictionaryArray<T> containing only those keys from the array passed as the data_array parameter,\n+/// selected by the BooleanArray passed as the filter_array parameter. The values are cloned from the data_array.\n+pub fn filter_dictionary_array<T>(\n+    data_array: &DictionaryArray<T>,\n+    filter_array: &BooleanArray,\n+) -> Result<DictionaryArray<T>>\n+where\n+    T: ArrowNumericType,\n+{\n+    FilterContext::new(filter_array).filter_dictionary_array(data_array)\n+}\n+\n+/// Returns a new RecordBatch with arrays containing only values matching the filter.\n+/// The same FilterContext is re-used when filtering arrays in the RecordBatch for better performance.\n+pub fn filter_record_batch(\n+    record_batch: &RecordBatch,\n+    filter_array: &BooleanArray,\n+) -> Result<RecordBatch> {\n+    let filter_context = FilterContext::new(filter_array);\n+    let filtered_arrays = record_batch\n+        .columns()\n+        .iter()\n+        .map(|a| filter_context.filter(a.as_ref()).unwrap())\n\nReview comment:\n       Isn't this `.unwrap()`\"hiding\" errors related with unsupported data types?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-25T05:04:13.364+0000",
                    "updated": "2020-07-25T05:04:13.364+0000",
                    "started": "2020-07-25T05:04:13.364+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463216",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/463279",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov commented on a change in pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#discussion_r460432008\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/filter.rs\n##########\n@@ -17,139 +17,443 @@\n \n //! Defines miscellaneous array kernels.\n \n-use std::sync::Arc;\n-\n use crate::array::*;\n use crate::datatypes::{ArrowNumericType, DataType, TimeUnit};\n use crate::error::{ArrowError, Result};\n+use crate::record_batch::RecordBatch;\n+use crate::{\n+    bitmap::Bitmap,\n+    buffer::{Buffer, MutableBuffer},\n+    memory,\n+    util::bit_util,\n+};\n+use std::{mem, sync::Arc};\n \n-/// Helper function to perform boolean lambda function on values from two arrays.\n-fn bool_op<T, F>(\n-    left: &PrimitiveArray<T>,\n-    right: &PrimitiveArray<T>,\n-    op: F,\n-) -> Result<BooleanArray>\n-where\n-    T: ArrowNumericType,\n-    F: Fn(Option<T::Native>, Option<T::Native>) -> bool,\n-{\n-    if left.len() != right.len() {\n-        return Err(ArrowError::ComputeError(\n-            \"Cannot perform math operation on arrays of different length\".to_string(),\n-        ));\n+/// trait for copying filtered null bitmap bits\n+trait CopyNullBit {\n+    fn copy_null_bit(&mut self, source_index: usize);\n+    fn null_count(&self) -> usize;\n+    fn null_buffer(&mut self) -> Buffer;\n+}\n+\n+/// no-op null bitmap copy implementation,\n+/// used when the filtered data array doesn't have a null bitmap\n+struct NullBitNoop {}\n+\n+impl NullBitNoop {\n+    fn new() -> Self {\n+        NullBitNoop {}\n     }\n-    let mut b = BooleanArray::builder(left.len());\n-    for i in 0..left.len() {\n-        let index = i;\n-        let l = if left.is_null(i) {\n-            None\n-        } else {\n-            Some(left.value(index))\n-        };\n-        let r = if right.is_null(i) {\n-            None\n-        } else {\n-            Some(right.value(index))\n-        };\n-        b.append_value(op(l, r))?;\n+}\n+\n+impl CopyNullBit for NullBitNoop {\n+    #[inline]\n+    fn copy_null_bit(&mut self, _source_index: usize) {\n+        // do nothing\n+    }\n+\n+    fn null_count(&self) -> usize {\n+        0\n+    }\n+\n+    fn null_buffer(&mut self) -> Buffer {\n+        Buffer::from([0u8; 0])\n     }\n-    Ok(b.finish())\n }\n \n-macro_rules! filter_array {\n-    ($array:expr, $filter:expr, $array_type:ident) => {{\n-        let b = $array.as_any().downcast_ref::<$array_type>().unwrap();\n-        let mut builder = $array_type::builder(b.len());\n-        for i in 0..b.len() {\n-            if $filter.value(i) {\n-                if b.is_null(i) {\n-                    builder.append_null()?;\n-                } else {\n-                    builder.append_value(b.value(i))?;\n-                }\n-            }\n-        }\n-        Ok(Arc::new(builder.finish()))\n-    }};\n+/// null bitmap copy implementation,\n+/// used when the filtered data array has a null bitmap\n+struct NullBitSetter<'a> {\n+    target_buffer: MutableBuffer,\n+    source_bytes: &'a [u8],\n+    target_index: usize,\n+    null_count: usize,\n }\n \n-/// Returns the array, taking only the elements matching the filter\n-pub fn filter(array: &Array, filter: &BooleanArray) -> Result<ArrayRef> {\n-    match array.data_type() {\n-        DataType::UInt8 => filter_array!(array, filter, UInt8Array),\n-        DataType::UInt16 => filter_array!(array, filter, UInt16Array),\n-        DataType::UInt32 => filter_array!(array, filter, UInt32Array),\n-        DataType::UInt64 => filter_array!(array, filter, UInt64Array),\n-        DataType::Int8 => filter_array!(array, filter, Int8Array),\n-        DataType::Int16 => filter_array!(array, filter, Int16Array),\n-        DataType::Int32 => filter_array!(array, filter, Int32Array),\n-        DataType::Int64 => filter_array!(array, filter, Int64Array),\n-        DataType::Float32 => filter_array!(array, filter, Float32Array),\n-        DataType::Float64 => filter_array!(array, filter, Float64Array),\n-        DataType::Boolean => filter_array!(array, filter, BooleanArray),\n-        DataType::Date32(_) => filter_array!(array, filter, Date32Array),\n-        DataType::Date64(_) => filter_array!(array, filter, Date64Array),\n-        DataType::Time32(TimeUnit::Second) => {\n-            filter_array!(array, filter, Time32SecondArray)\n-        }\n-        DataType::Time32(TimeUnit::Millisecond) => {\n-            filter_array!(array, filter, Time32MillisecondArray)\n-        }\n-        DataType::Time64(TimeUnit::Microsecond) => {\n-            filter_array!(array, filter, Time64MicrosecondArray)\n-        }\n-        DataType::Time64(TimeUnit::Nanosecond) => {\n-            filter_array!(array, filter, Time64NanosecondArray)\n-        }\n-        DataType::Duration(TimeUnit::Second) => {\n-            filter_array!(array, filter, DurationSecondArray)\n-        }\n-        DataType::Duration(TimeUnit::Millisecond) => {\n-            filter_array!(array, filter, DurationMillisecondArray)\n+impl<'a> NullBitSetter<'a> {\n+    fn new(null_bitmap: &'a Bitmap) -> Self {\n+        let null_bytes = null_bitmap.buffer_ref().data();\n+        // create null bitmap buffer with same length and initialize null bitmap buffer to 1s\n+        let null_buffer =\n+            MutableBuffer::new(null_bytes.len()).with_bitset(null_bytes.len(), true);\n+        NullBitSetter {\n+            source_bytes: null_bytes,\n+            target_buffer: null_buffer,\n+            target_index: 0,\n+            null_count: 0,\n         }\n-        DataType::Duration(TimeUnit::Microsecond) => {\n-            filter_array!(array, filter, DurationMicrosecondArray)\n-        }\n-        DataType::Duration(TimeUnit::Nanosecond) => {\n-            filter_array!(array, filter, DurationNanosecondArray)\n-        }\n-        DataType::Timestamp(TimeUnit::Second, _) => {\n-            filter_array!(array, filter, TimestampSecondArray)\n+    }\n+}\n+\n+impl<'a> CopyNullBit for NullBitSetter<'a> {\n+    #[inline]\n+    fn copy_null_bit(&mut self, source_index: usize) {\n+        if !bit_util::get_bit(self.source_bytes, source_index) {\n+            // this is not actually unsafe because of the condition above + target_buffer.len() == source_bytes.len()\n+            unsafe {\n+                bit_util::unset_bit_raw(\n+                    self.target_buffer.raw_data_mut(),\n+                    self.target_index,\n+                );\n+            }\n+            self.null_count += 1;\n         }\n-        DataType::Timestamp(TimeUnit::Millisecond, _) => {\n-            filter_array!(array, filter, TimestampMillisecondArray)\n+        self.target_index += 1;\n+    }\n+\n+    fn null_count(&self) -> usize {\n+        self.null_count\n+    }\n+\n+    fn null_buffer(&mut self) -> Buffer {\n+        self.target_buffer.resize(self.target_index).unwrap();\n+        // use mem::replace to detach self.target_buffer from self so that it can be returned\n+        let target_buffer = mem::replace(&mut self.target_buffer, MutableBuffer::new(0));\n+        target_buffer.freeze()\n+    }\n+}\n+\n+fn get_null_bit_setter<'a>(data_array: &'a impl Array) -> Box<CopyNullBit + 'a> {\n+    if let Some(null_bitmap) = data_array.data_ref().null_bitmap() {\n+        // only return an actual null bit copy implementation if null_bitmap is set\n+        Box::new(NullBitSetter::new(null_bitmap))\n+    } else {\n+        // otherwise return a no-op copy null bit implementation\n+        // for improved performance when the filtered array doesn't contain NULLs\n+        Box::new(NullBitNoop::new())\n+    }\n+}\n+\n+// transmute filter array to u64\n+// - optimize filtering with highly selective filters by skipping entire batches of 64 filter bits\n+// - if the data array being filtered doesn't have a null bitmap, no time is wasted to copy a null bitmap\n+fn filter_array_impl(\n+    filter_context: &FilterContext,\n+    data_array: &impl Array,\n+    array_type: DataType,\n+    value_size: usize,\n+) -> Result<ArrayDataBuilder> {\n+    if filter_context.filter_len > data_array.len() {\n+        return Err(ArrowError::ComputeError(\n+            \"Filter array cannot be larger than data array\".to_string(),\n+        ));\n+    }\n+    let filtered_count = filter_context.filtered_count;\n+    let filter_mask = &filter_context.filter_mask;\n+    let filter_u64 = &filter_context.filter_u64;\n+    let data_start = data_array.data_ref().buffers()[0].raw_data();\n+    let mut value_buffer = MutableBuffer::new(filtered_count * value_size);\n+    value_buffer.resize(filtered_count * value_size)?;\n+    let mut value_position = value_buffer.raw_data_mut();\n+    let mut null_bit_setter = get_null_bit_setter(data_array);\n+    let null_bit_setter = null_bit_setter.as_mut();\n+\n+    for (i, filter_batch) in filter_u64.iter().enumerate() {\n+        // foreach u64 batch\n+        let filter_batch = *filter_batch;\n+        if filter_batch == 0 {\n+            // if batch == 0: skip\n+            continue;\n         }\n-        DataType::Timestamp(TimeUnit::Microsecond, _) => {\n-            filter_array!(array, filter, TimestampMicrosecondArray)\n+        for (j, filter_mask) in filter_mask.iter().enumerate() {\n+            // foreach bit in batch:\n+            if (filter_batch & *filter_mask) != 0 {\n+                let data_index = (i * 64) + j;\n+                null_bit_setter.copy_null_bit(data_index);\n+                // if filter bit == 1: copy data value to temp array\n+                unsafe {\n+                    // this should be safe because of the data_array.len() check at the beginning of the method\n+                    memory::memcpy(\n+                        value_position,\n+                        data_start.add(value_size * data_index),\n+                        value_size,\n+                    );\n+                    value_position = value_position.add(value_size);\n+                }\n+            }\n         }\n-        DataType::Timestamp(TimeUnit::Nanosecond, _) => {\n-            filter_array!(array, filter, TimestampNanosecondArray)\n+    }\n+\n+    let mut array_data_builder = ArrayDataBuilder::new(array_type)\n+        .len(filtered_count)\n+        .add_buffer(value_buffer.freeze());\n+    if null_bit_setter.null_count() > 0 {\n+        array_data_builder = array_data_builder\n+            .null_count(null_bit_setter.null_count())\n+            .null_bit_buffer(null_bit_setter.null_buffer());\n+    }\n+\n+    Ok(array_data_builder)\n+}\n+\n+/// FilterContext can be used to improve performance when\n+/// filtering multiple data arrays with the same filter array.\n+#[derive(Debug)]\n+pub struct FilterContext {\n+    filter_u64: Vec<u64>,\n+    filter_len: usize,\n+    filtered_count: usize,\n+    filter_mask: Vec<u64>,\n+}\n+\n+macro_rules! filter_primitive_array {\n+    ($context:expr, $array:expr, $array_type:ident) => {{\n+        let input_array = $array.as_any().downcast_ref::<$array_type>().unwrap();\n+        let output_array = $context.filter_primitive_array(input_array)?;\n+        Ok(Arc::new(output_array))\n+    }};\n+}\n+\n+macro_rules! filter_dictionary_array {\n+    ($context:expr, $array:expr, $array_type:ident) => {{\n+        let input_array = $array.as_any().downcast_ref::<$array_type>().unwrap();\n+        let output_array = $context.filter_dictionary_array(input_array)?;\n+        Ok(Arc::new(output_array))\n+    }};\n+}\n+\n+impl FilterContext {\n+    /// Returns a new instance of FilterContext\n+    pub fn new(filter_array: &BooleanArray) -> Self {\n+        let filter_mask: Vec<u64> = (0..64).map(|x| 1u64 << x).collect();\n+        let filter_bytes = filter_array.data_ref().buffers()[0].data();\n+        let filtered_count = bit_util::count_set_bits(filter_bytes);\n+        // transmute filter_bytes to &[u64]\n+        let mut u64_buffer = MutableBuffer::new(filter_bytes.len());\n+        u64_buffer\n+            .write_bytes(filter_bytes, u64_buffer.capacity() - filter_bytes.len())\n+            .unwrap();\n+        let filter_u64 = u64_buffer.typed_data_mut::<u64>().to_owned();\n+        FilterContext {\n+            filter_u64,\n+            filter_len: filter_array.len(),\n+            filtered_count,\n+            filter_mask,\n         }\n-        DataType::Binary => {\n-            let b = array.as_any().downcast_ref::<BinaryArray>().unwrap();\n-            let mut values: Vec<&[u8]> = Vec::with_capacity(b.len());\n-            for i in 0..b.len() {\n-                if filter.value(i) {\n-                    values.push(b.value(i));\n+    }\n+\n+    /// Returns a new array, containing only the elements matching the filter\n+    pub fn filter(&self, array: &Array) -> Result<ArrayRef> {\n+        match array.data_type() {\n+            DataType::UInt8 => filter_primitive_array!(self, array, UInt8Array),\n+            DataType::UInt16 => filter_primitive_array!(self, array, UInt16Array),\n+            DataType::UInt32 => filter_primitive_array!(self, array, UInt32Array),\n+            DataType::UInt64 => filter_primitive_array!(self, array, UInt64Array),\n+            DataType::Int8 => filter_primitive_array!(self, array, Int8Array),\n+            DataType::Int16 => filter_primitive_array!(self, array, Int16Array),\n+            DataType::Int32 => filter_primitive_array!(self, array, Int32Array),\n+            DataType::Int64 => filter_primitive_array!(self, array, Int64Array),\n+            DataType::Float32 => filter_primitive_array!(self, array, Float32Array),\n+            DataType::Float64 => filter_primitive_array!(self, array, Float64Array),\n+            DataType::Boolean => {\n+                let input_array = array.as_any().downcast_ref::<BooleanArray>().unwrap();\n+                let mut builder = BooleanArray::builder(self.filtered_count);\n+                for i in 0..self.filter_u64.len() {\n+                    // foreach u64 batch\n+                    let filter_batch = self.filter_u64[i];\n+                    if filter_batch == 0 {\n+                        // if batch == 0: skip\n+                        continue;\n+                    }\n+                    for j in 0..64 {\n+                        // foreach bit in batch:\n+                        if (filter_batch & self.filter_mask[j]) != 0 {\n+                            let data_index = (i * 64) + j;\n+                            if input_array.is_null(data_index) {\n+                                builder.append_null()?;\n+                            } else {\n+                                builder.append_value(input_array.value(data_index))?;\n+                            }\n+                        }\n+                    }\n                 }\n+                Ok(Arc::new(builder.finish()))\n+            },\n+            DataType::Date32(_) => filter_primitive_array!(self, array, Date32Array),\n+            DataType::Date64(_) => filter_primitive_array!(self, array, Date64Array),\n+            DataType::Time32(TimeUnit::Second) => {\n+                filter_primitive_array!(self, array, Time32SecondArray)\n             }\n-            Ok(Arc::new(BinaryArray::from(values)))\n-        }\n-        DataType::Utf8 => {\n-            let b = array.as_any().downcast_ref::<StringArray>().unwrap();\n-            let mut values: Vec<&str> = Vec::with_capacity(b.len());\n-            for i in 0..b.len() {\n-                if filter.value(i) {\n-                    values.push(b.value(i));\n+            DataType::Time32(TimeUnit::Millisecond) => {\n+                filter_primitive_array!(self, array, Time32MillisecondArray)\n+            }\n+            DataType::Time64(TimeUnit::Microsecond) => {\n+                filter_primitive_array!(self, array, Time64MicrosecondArray)\n+            }\n+            DataType::Time64(TimeUnit::Nanosecond) => {\n+                filter_primitive_array!(self, array, Time64NanosecondArray)\n+            }\n+            DataType::Duration(TimeUnit::Second) => {\n+                filter_primitive_array!(self, array, DurationSecondArray)\n+            }\n+            DataType::Duration(TimeUnit::Millisecond) => {\n+                filter_primitive_array!(self, array, DurationMillisecondArray)\n+            }\n+            DataType::Duration(TimeUnit::Microsecond) => {\n+                filter_primitive_array!(self, array, DurationMicrosecondArray)\n+            }\n+            DataType::Duration(TimeUnit::Nanosecond) => {\n+                filter_primitive_array!(self, array, DurationNanosecondArray)\n+            }\n+            DataType::Timestamp(TimeUnit::Second, _) => {\n+                filter_primitive_array!(self, array, TimestampSecondArray)\n+            }\n+            DataType::Timestamp(TimeUnit::Millisecond, _) => {\n+                filter_primitive_array!(self, array, TimestampMillisecondArray)\n+            }\n+            DataType::Timestamp(TimeUnit::Microsecond, _) => {\n+                filter_primitive_array!(self, array, TimestampMicrosecondArray)\n+            }\n+            DataType::Timestamp(TimeUnit::Nanosecond, _) => {\n+                filter_primitive_array!(self, array, TimestampNanosecondArray)\n+            }\n+            DataType::Binary => {\n+                let input_array = array.as_any().downcast_ref::<BinaryArray>().unwrap();\n+                let mut values: Vec<&[u8]> = Vec::with_capacity(self.filtered_count);\n+                for i in 0..self.filter_u64.len() {\n+                    // foreach u64 batch\n+                    let filter_batch = self.filter_u64[i];\n+                    if filter_batch == 0 {\n+                        // if batch == 0: skip\n+                        continue;\n+                    }\n+                    for j in 0..64 {\n+                        // foreach bit in batch:\n+                        if (filter_batch & self.filter_mask[j]) != 0 {\n+                            let data_index = (i * 64) + j;\n+                            values.push(input_array.value(data_index));\n+                        }\n+                    }\n                 }\n+                Ok(Arc::new(BinaryArray::from(values)))\n             }\n-            Ok(Arc::new(StringArray::from(values)))\n+            DataType::Utf8 => {\n+                let input_array = array.as_any().downcast_ref::<StringArray>().unwrap();\n+                let mut values: Vec<&str> = Vec::with_capacity(self.filtered_count);\n+                for i in 0..self.filter_u64.len() {\n+                    // foreach u64 batch\n+                    let filter_batch = self.filter_u64[i];\n+                    if filter_batch == 0 {\n+                        // if batch == 0: skip\n+                        continue;\n+                    }\n+                    for j in 0..64 {\n+                        // foreach bit in batch:\n+                        if (filter_batch & self.filter_mask[j]) != 0 {\n+                            let data_index = (i * 64) + j;\n+                            values.push(input_array.value(data_index));\n+                        }\n+                    }\n+                }\n+                Ok(Arc::new(StringArray::from(values)))\n+            }\n+            DataType::Dictionary(ref key_type, ref value_type) => match (key_type.as_ref(), value_type.as_ref()) {\n+                (key_type, DataType::Utf8) => match key_type {\n+                    DataType::UInt8 => filter_dictionary_array!(self, array, UInt8DictionaryArray),\n+                    DataType::UInt16 => filter_dictionary_array!(self, array, UInt16DictionaryArray),\n+                    DataType::UInt32 => filter_dictionary_array!(self, array, UInt32DictionaryArray),\n+                    DataType::UInt64 => filter_dictionary_array!(self, array, UInt64DictionaryArray),\n+                    DataType::Int8 => filter_dictionary_array!(self, array, Int8DictionaryArray),\n+                    DataType::Int16 => filter_dictionary_array!(self, array, Int16DictionaryArray),\n+                    DataType::Int32 => filter_dictionary_array!(self, array, Int32DictionaryArray),\n+                    DataType::Int64 => filter_dictionary_array!(self, array, Int64DictionaryArray),\n+                    other => Err(ArrowError::ComputeError(format!(\n+                        \"filter not supported for string dictionary with key of type {:?}\",\n+                        other\n+                    )))\n+                }\n+                (key_type, value_type) => Err(ArrowError::ComputeError(format!(\n+                    \"filter not supported for Dictionary({:?}, {:?})\",\n+                    key_type, value_type\n+                )))\n+            }\n+            other => Err(ArrowError::ComputeError(format!(\n+                \"filter not supported for {:?}\",\n+                other\n+            ))),\n         }\n-        other => Err(ArrowError::ComputeError(format!(\n-            \"filter not supported for {:?}\",\n-            other\n-        ))),\n     }\n+\n+    /// Returns a new PrimitiveArray<T> containing only those values from the array passed as the data_array parameter,\n+    /// selected by the BooleanArray passed as the filter_array parameter\n+    pub fn filter_primitive_array<T>(\n+        &self,\n+        data_array: &PrimitiveArray<T>,\n+    ) -> Result<PrimitiveArray<T>>\n+    where\n+        T: ArrowNumericType,\n+    {\n+        let array_type = T::get_data_type();\n+        let value_size = mem::size_of::<T::Native>();\n+        let array_data_builder =\n+            filter_array_impl(self, data_array, array_type, value_size)?;\n+        let data = array_data_builder.build();\n+        Ok(PrimitiveArray::<T>::from(data))\n+    }\n+\n+    /// Returns a new DictionaryArray<T> containing only those keys from the array passed as the data_array parameter,\n+    /// selected by the BooleanArray passed as the filter_array parameter. The values are cloned from the data_array.\n+    pub fn filter_dictionary_array<T>(\n+        &self,\n+        data_array: &DictionaryArray<T>,\n+    ) -> Result<DictionaryArray<T>>\n+    where\n+        T: ArrowNumericType,\n+    {\n+        let array_type = data_array.data_type().clone();\n+        let value_size = mem::size_of::<T::Native>();\n+        let mut array_data_builder =\n+            filter_array_impl(self, data_array, array_type, value_size)?;\n+        // copy dictionary values from input array\n+        array_data_builder =\n+            array_data_builder.add_child_data(data_array.values().data());\n+        let data = array_data_builder.build();\n+        Ok(DictionaryArray::<T>::from(data))\n+    }\n+}\n+\n+/// Returns a new array, containing only the elements matching the filter.\n+pub fn filter(array: &Array, filter: &BooleanArray) -> Result<ArrayRef> {\n+    FilterContext::new(filter).filter(array)\n+}\n+\n+/// Returns a new PrimitiveArray<T> containing only those values from the array passed as the data_array parameter,\n+/// selected by the BooleanArray passed as the filter_array parameter\n+pub fn filter_primitive_array<T>(\n+    data_array: &PrimitiveArray<T>,\n+    filter_array: &BooleanArray,\n+) -> Result<PrimitiveArray<T>>\n+where\n+    T: ArrowNumericType,\n+{\n+    FilterContext::new(filter_array).filter_primitive_array(data_array)\n+}\n+\n+/// Returns a new DictionaryArray<T> containing only those keys from the array passed as the data_array parameter,\n+/// selected by the BooleanArray passed as the filter_array parameter. The values are cloned from the data_array.\n+pub fn filter_dictionary_array<T>(\n+    data_array: &DictionaryArray<T>,\n+    filter_array: &BooleanArray,\n+) -> Result<DictionaryArray<T>>\n+where\n+    T: ArrowNumericType,\n+{\n+    FilterContext::new(filter_array).filter_dictionary_array(data_array)\n+}\n+\n+/// Returns a new RecordBatch with arrays containing only values matching the filter.\n+/// The same FilterContext is re-used when filtering arrays in the RecordBatch for better performance.\n+pub fn filter_record_batch(\n+    record_batch: &RecordBatch,\n+    filter_array: &BooleanArray,\n+) -> Result<RecordBatch> {\n+    let filter_context = FilterContext::new(filter_array);\n+    let filtered_arrays = record_batch\n+        .columns()\n+        .iter()\n+        .map(|a| filter_context.filter(a.as_ref()).unwrap())\n\nReview comment:\n       good spot, I have changed the filter_record_batch method to remove the unwrap() and use `.collect::<Result<Vec<ArrayRef>>>()?;` instead\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-25T18:38:25.391+0000",
                    "updated": "2020-07-25T18:38:25.391+0000",
                    "started": "2020-07-25T18:38:25.391+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463279",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/463280",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov commented on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-663888189\n\n\n   @jorgecarleitao thanks for the feedback\r\n   \r\n   I did some more profiling specifically around the unsafe parts of code and found that the safe version of `copy_null_bit` is just as fast so have removed that unsafe section; here are some benchmark results:\r\n   \r\n   copy_null_bit unsafe:\r\n   filter context u8 w NULLs low selectivity  time:   [142.05 us 142.35 us 142.68 us]\r\n   filter context u8 w NULLs high selectivity time:   [2.0915 us 2.1015 us 2.1127 us]\r\n   \r\n   copy_null_bit safe:\r\n   filter context u8 w NULLs low selectivity  time:   [134.74 us 134.86 us 134.98 us]\r\n   filter context u8 w NULLs high selectivity time:   [2.0536 us 2.0613 us 2.0707 us]\r\n   \r\n   I also benchmarked replacing the unsafe section in the `filter_array_impl` method with `value_buffer.write()` but this results in approximately 17% drop in performance with sparse filter arrays as can be seen from the benchmark results below:\r\n   \r\n   filter u8 low selectivity\r\n                           time:   [131.08 us 132.46 us 134.27 us]\r\n                           change: [+13.141% +17.189% +22.115%] (p = 0.00 < 0.05)\r\n   \r\n   filter context u8 low selectivity\r\n                           time:   [127.47 us 129.27 us 131.56 us]\r\n                           change: [+12.008% +19.674% +27.939%] (p = 0.00 < 0.05)\r\n   \r\n   filter context u8 w NULLs low selectivity\r\n                           time:   [154.32 us 155.27 us 156.79 us]\r\n                           change: [+15.444% +17.846% +22.268%] (p = 0.00 < 0.05)\r\n   \r\n   filter context f32 low selectivity\r\n                           time:   [137.62 us 138.01 us 138.52 us]\r\n                           change: [+12.495% +18.180% +23.088%] (p = 0.00 < 0.05)\r\n   \r\n   finally, looking at the C++ implementation inspired me to change the `filter_array_impl` method to add a special case where the 64bit filter batch is all 1s and this doesn't appear to reduce performance in other cases but improves performance of filtering with very dense filter arrays (almost all 1s) by about 20 times; here are the latest benchmark results:\r\n   \r\n   filter u8 low selectivity                      time:   [109.75 us 110.30 us 111.02 us]\r\n   filter u8 high selectivity                     time:   [4.8372 us 4.8433 us 4.8502 us]\r\n   filter u8 very low selectivity                 time:   [11.782 us 11.798 us 11.816 us]\r\n   filter context u8 low selectivity              time:   [109.07 us 109.65 us 110.66 us]\r\n   filter context u8 high selectivity             time:   [1.4704 us 1.4762 us 1.4842 us]\r\n   filter context u8 very low selectivity         time:   [8.8455 us 9.0530 us 9.3171 us]\r\n   filter context u8 w NULLs low selectivity      time:   [135.32 us 135.49 us 135.66 us]\r\n   filter context u8 w NULLs high selectivity     time:   [2.0579 us 2.0680 us 2.0796 us]\r\n   filter context u8 w NULLs very low selectivity time:   [11.583 us 11.668 us 11.780 us]\r\n   filter context f32 low selectivity             time:   [138.71 us 139.83 us 141.41 us]\r\n   filter context f32 high selectivity            time:   [1.6111 us 1.6342 us 1.6605 us]\r\n   filter context f32 very low selectivity        time:   [19.719 us 19.865 us 20.045 us]\r\n   \r\n   @andygrove  any thoughts?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-25T18:49:22.793+0000",
                    "updated": "2020-07-25T18:49:22.793+0000",
                    "started": "2020-07-25T18:49:22.793+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463280",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/463281",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov edited a comment on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-663888189\n\n\n   @jorgecarleitao thanks for the feedback\r\n   \r\n   I did some more profiling specifically around the unsafe parts of the code and found that the safe version of `copy_null_bit` is just as fast so have removed that unsafe section; here are some benchmark results:\r\n   \r\n   copy_null_bit unsafe:\r\n   filter context u8 w NULLs low selectivity  time:   [142.05 us 142.35 us 142.68 us]\r\n   filter context u8 w NULLs high selectivity time:   [2.0915 us 2.1015 us 2.1127 us]\r\n   \r\n   copy_null_bit safe:\r\n   filter context u8 w NULLs low selectivity  time:   [134.74 us 134.86 us 134.98 us]\r\n   filter context u8 w NULLs high selectivity time:   [2.0536 us 2.0613 us 2.0707 us]\r\n   \r\n   I also benchmarked replacing the unsafe section in the `filter_array_impl` method with `value_buffer.write()` but this results in approximately 17% drop in performance with sparse filter arrays as can be seen from the benchmark results below:\r\n   \r\n   filter u8 low selectivity\r\n                           time:   [131.08 us 132.46 us 134.27 us]\r\n                           change: [+13.141% +17.189% +22.115%] (p = 0.00 < 0.05)\r\n   \r\n   filter context u8 low selectivity\r\n                           time:   [127.47 us 129.27 us 131.56 us]\r\n                           change: [+12.008% +19.674% +27.939%] (p = 0.00 < 0.05)\r\n   \r\n   filter context u8 w NULLs low selectivity\r\n                           time:   [154.32 us 155.27 us 156.79 us]\r\n                           change: [+15.444% +17.846% +22.268%] (p = 0.00 < 0.05)\r\n   \r\n   filter context f32 low selectivity\r\n                           time:   [137.62 us 138.01 us 138.52 us]\r\n                           change: [+12.495% +18.180% +23.088%] (p = 0.00 < 0.05)\r\n   \r\n   finally, looking at the C++ implementation inspired me to change the `filter_array_impl` method to add a special case where the 64bit filter batch is all 1s and this doesn't appear to reduce performance in other cases but improves performance of filtering with very dense filter arrays (almost all 1s) by about 20 times; here are the latest benchmark results:\r\n   \r\n   filter u8 low selectivity                      time:   [109.75 us 110.30 us 111.02 us]\r\n   filter u8 high selectivity                     time:   [4.8372 us 4.8433 us 4.8502 us]\r\n   filter u8 very low selectivity                 time:   [11.782 us 11.798 us 11.816 us]\r\n   filter context u8 low selectivity              time:   [109.07 us 109.65 us 110.66 us]\r\n   filter context u8 high selectivity             time:   [1.4704 us 1.4762 us 1.4842 us]\r\n   filter context u8 very low selectivity         time:   [8.8455 us 9.0530 us 9.3171 us]\r\n   filter context u8 w NULLs low selectivity      time:   [135.32 us 135.49 us 135.66 us]\r\n   filter context u8 w NULLs high selectivity     time:   [2.0579 us 2.0680 us 2.0796 us]\r\n   filter context u8 w NULLs very low selectivity time:   [11.583 us 11.668 us 11.780 us]\r\n   filter context f32 low selectivity             time:   [138.71 us 139.83 us 141.41 us]\r\n   filter context f32 high selectivity            time:   [1.6111 us 1.6342 us 1.6605 us]\r\n   filter context f32 very low selectivity        time:   [19.719 us 19.865 us 20.045 us]\r\n   \r\n   @andygrove  any thoughts?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-25T18:51:36.228+0000",
                    "updated": "2020-07-25T18:51:36.228+0000",
                    "started": "2020-07-25T18:51:36.227+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463281",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/463282",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov edited a comment on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-663888189\n\n\n   @jorgecarleitao thanks for the feedback\r\n   \r\n   I did some more profiling specifically around the unsafe parts of the code and found that the safe version of `copy_null_bit` is just as fast so have removed that unsafe section; here are some benchmark results:\r\n   \r\n   copy_null_bit unsafe:\r\n   filter context u8 w NULLs low selectivity  time:   [142.05 us 142.35 us 142.68 us]\r\n   filter context u8 w NULLs high selectivity time:   [2.0915 us 2.1015 us 2.1127 us]\r\n   \r\n   copy_null_bit safe:\r\n   filter context u8 w NULLs low selectivity  time:   [134.74 us 134.86 us 134.98 us]\r\n   filter context u8 w NULLs high selectivity time:   [2.0536 us 2.0613 us 2.0707 us]\r\n   \r\n   I also benchmarked replacing the unsafe section in the `filter_array_impl` method with `value_buffer.write()` but this results in approximately 18% drop in performance with sparse filter arrays as can be seen from the benchmark results below:\r\n   \r\n   filter u8 low selectivity\r\n                           time:   [131.08 us 132.46 us 134.27 us]\r\n                           change: [+13.141% +17.189% +22.115%] (p = 0.00 < 0.05)\r\n   \r\n   filter context u8 low selectivity\r\n                           time:   [127.47 us 129.27 us 131.56 us]\r\n                           change: [+12.008% +19.674% +27.939%] (p = 0.00 < 0.05)\r\n   \r\n   filter context u8 w NULLs low selectivity\r\n                           time:   [154.32 us 155.27 us 156.79 us]\r\n                           change: [+15.444% +17.846% +22.268%] (p = 0.00 < 0.05)\r\n   \r\n   filter context f32 low selectivity\r\n                           time:   [137.62 us 138.01 us 138.52 us]\r\n                           change: [+12.495% +18.180% +23.088%] (p = 0.00 < 0.05)\r\n   \r\n   finally, looking at the C++ implementation inspired me to change the `filter_array_impl` method to add a special case where the 64bit filter batch is all 1s and this doesn't appear to reduce performance in other cases but improves performance of filtering with very dense filter arrays (almost all 1s) by about 20 times; here are the latest benchmark results:\r\n   \r\n   filter u8 low selectivity                      time:   [109.75 us 110.30 us 111.02 us]\r\n   filter u8 high selectivity                     time:   [4.8372 us 4.8433 us 4.8502 us]\r\n   filter u8 very low selectivity                 time:   [11.782 us 11.798 us 11.816 us]\r\n   filter context u8 low selectivity              time:   [109.07 us 109.65 us 110.66 us]\r\n   filter context u8 high selectivity             time:   [1.4704 us 1.4762 us 1.4842 us]\r\n   filter context u8 very low selectivity         time:   [8.8455 us 9.0530 us 9.3171 us]\r\n   filter context u8 w NULLs low selectivity      time:   [135.32 us 135.49 us 135.66 us]\r\n   filter context u8 w NULLs high selectivity     time:   [2.0579 us 2.0680 us 2.0796 us]\r\n   filter context u8 w NULLs very low selectivity time:   [11.583 us 11.668 us 11.780 us]\r\n   filter context f32 low selectivity             time:   [138.71 us 139.83 us 141.41 us]\r\n   filter context f32 high selectivity            time:   [1.6111 us 1.6342 us 1.6605 us]\r\n   filter context f32 very low selectivity        time:   [19.719 us 19.865 us 20.045 us]\r\n   \r\n   @andygrove  any thoughts?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-25T18:52:19.208+0000",
                    "updated": "2020-07-25T18:52:19.208+0000",
                    "started": "2020-07-25T18:52:19.208+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463282",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/463316",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-663933810\n\n\n   Sorry @yordan-pavlov but I didn't get a chance to review yet. I hope to get to it soon.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-26T04:19:52.053+0000",
                    "updated": "2020-07-26T04:19:52.053+0000",
                    "started": "2020-07-26T04:19:52.053+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463316",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/463330",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov edited a comment on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-663888189\n\n\n   @jorgecarleitao thanks for the feedback\r\n   \r\n   I did some more profiling specifically around the unsafe parts of the code and found that the safe version of `copy_null_bit` is just as fast so have removed that unsafe section; here are some benchmark results:\r\n   \r\n   copy_null_bit unsafe:\r\n   filter context u8 w NULLs low selectivity  time:   [142.05 us 142.35 us 142.68 us]\r\n   filter context u8 w NULLs high selectivity time:   [2.0915 us 2.1015 us 2.1127 us]\r\n   \r\n   copy_null_bit safe:\r\n   filter context u8 w NULLs low selectivity  time:   [134.74 us 134.86 us 134.98 us]\r\n   filter context u8 w NULLs high selectivity time:   [2.0536 us 2.0613 us 2.0707 us]\r\n   \r\n   I also benchmarked replacing the unsafe section in the `filter_array_impl` method with `value_buffer.write()` but this results in approximately 18% drop in performance with sparse filter arrays as can be seen from the benchmark results below:\r\n   \r\n   filter u8 low selectivity\r\n                           time:   [131.08 us 132.46 us 134.27 us]\r\n                           change: [+13.141% +17.189% +22.115%] (p = 0.00 < 0.05)\r\n   \r\n   filter context u8 low selectivity\r\n                           time:   [127.47 us 129.27 us 131.56 us]\r\n                           change: [+12.008% +19.674% +27.939%] (p = 0.00 < 0.05)\r\n   \r\n   filter context u8 w NULLs low selectivity\r\n                           time:   [154.32 us 155.27 us 156.79 us]\r\n                           change: [+15.444% +17.846% +22.268%] (p = 0.00 < 0.05)\r\n   \r\n   filter context f32 low selectivity\r\n                           time:   [137.62 us 138.01 us 138.52 us]\r\n                           change: [+12.495% +18.180% +23.088%] (p = 0.00 < 0.05)\r\n   \r\n   finally, looking at the C++ implementation inspired me to change the `filter_array_impl` method to add a special case where the 64bit filter batch is all 1s and this doesn't appear to reduce performance in other cases but improves performance of filtering with very dense filter arrays (almost all 1s) by about 20 times; here are the latest benchmark results:\r\n   \r\n   filter u8 low selectivity                      time:   [109.75 us 110.30 us 111.02 us]\r\n   filter u8 high selectivity                     time:   [4.8372 us 4.8433 us 4.8502 us]\r\n   filter u8 very low selectivity                 time:   [11.782 us 11.798 us 11.816 us]\r\n   \r\n   filter context u8 low selectivity              time:   [109.07 us 109.65 us 110.66 us]\r\n   filter context u8 high selectivity             time:   [1.4704 us 1.4762 us 1.4842 us]\r\n   filter context u8 very low selectivity         time:   [8.8455 us 9.0530 us 9.3171 us]\r\n   \r\n   filter context u8 w NULLs low selectivity      time:   [142.65 us 143.53 us 144.81 us]\r\n   filter context u8 w NULLs high selectivity     time:   [2.2111 us 2.2297 us 2.2514 us]\r\n   filter context u8 w NULLs very low selectivity time:   [161.89 us 167.90 us 175.02 us]\r\n   \r\n   filter context f32 low selectivity             time:   [138.71 us 139.83 us 141.41 us]\r\n   filter context f32 high selectivity            time:   [1.6111 us 1.6342 us 1.6605 us]\r\n   filter context f32 very low selectivity        time:   [19.719 us 19.865 us 20.045 us]\r\n   \r\n   @andygrove  any thoughts?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-26T11:09:47.615+0000",
                    "updated": "2020-07-26T11:09:47.615+0000",
                    "started": "2020-07-26T11:09:47.615+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463330",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/463413",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov edited a comment on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-663888189\n\n\n   @jorgecarleitao thanks for the feedback\r\n   \r\n   I did some more profiling specifically around the unsafe parts of the code and found that the safe version of `copy_null_bit` is just as fast so have removed that unsafe section; here are some benchmark results:\r\n   \r\n   copy_null_bit unsafe:\r\n   filter context u8 w NULLs low selectivity  time:   [142.05 us 142.35 us 142.68 us]\r\n   filter context u8 w NULLs high selectivity time:   [2.0915 us 2.1015 us 2.1127 us]\r\n   \r\n   copy_null_bit safe:\r\n   filter context u8 w NULLs low selectivity  time:   [134.74 us 134.86 us 134.98 us]\r\n   filter context u8 w NULLs high selectivity time:   [2.0536 us 2.0613 us 2.0707 us]\r\n   \r\n   I also benchmarked replacing the unsafe section in the `filter_array_impl` method with `value_buffer.write()` but this results in approximately 18% drop in performance with sparse filter arrays as can be seen from the benchmark results below:\r\n   \r\n   filter u8 low selectivity\r\n                           time:   [131.08 us 132.46 us 134.27 us]\r\n                           change: [+13.141% +17.189% +22.115%] (p = 0.00 < 0.05)\r\n   \r\n   filter context u8 low selectivity\r\n                           time:   [127.47 us 129.27 us 131.56 us]\r\n                           change: [+12.008% +19.674% +27.939%] (p = 0.00 < 0.05)\r\n   \r\n   filter context u8 w NULLs low selectivity\r\n                           time:   [154.32 us 155.27 us 156.79 us]\r\n                           change: [+15.444% +17.846% +22.268%] (p = 0.00 < 0.05)\r\n   \r\n   filter context f32 low selectivity\r\n                           time:   [137.62 us 138.01 us 138.52 us]\r\n                           change: [+12.495% +18.180% +23.088%] (p = 0.00 < 0.05)\r\n   \r\n   finally, looking at the C++ implementation inspired me to change the `filter_array_impl` method to add a special case where the 64bit filter batch is all 1s and this doesn't appear to reduce performance in other cases but improves performance of filtering with very dense filter arrays (almost all 1s) by about 20 times; here are the latest benchmark results:\r\n   \r\n   filter u8 low selectivity                      time:   [118.21 us 118.82 us 119.61 us]\r\n   filter u8 high selectivity                     time:   [4.9893 us 4.9941 us 4.9998 us]\r\n   filter u8 very low selectivity                 time:   [11.861 us 11.919 us 11.987 us]\r\n   \r\n   filter context u8 low selectivity              time:   [115.22 us 115.77 us 116.36 us]\r\n   filter context u8 high selectivity             time:   [1.6571 us 1.6784 us 1.7033 us]\r\n   filter context u8 very low selectivity         time:   [8.4205 us 8.4370 us 8.4590 us]\r\n   \r\n   filter context u8 w NULLs low selectivity      time:   [132.49 us 132.78 us 133.10 us]\r\n   filter context u8 w NULLs high selectivity     time:   [2.1935 us 2.1979 us 2.2030 us]\r\n   filter context u8 w NULLs very low selectivity time:   [161.64 us 162.12 us 162.55 us]\r\n   \r\n   filter context f32 low selectivity             time:   [158.81 us 161.58 us 164.61 us]\r\n   filter context f32 high selectivity            time:   [1.8318 us 1.8371 us 1.8436 us]\r\n   filter context f32 very low selectivity        time:   [18.658 us 18.785 us 18.935 us]\r\n   \r\n   @andygrove  any thoughts?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-26T22:01:40.055+0000",
                    "updated": "2020-07-26T22:01:40.055+0000",
                    "started": "2020-07-26T22:01:40.055+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463413",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/463655",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov commented on a change in pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#discussion_r461149342\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/filter.rs\n##########\n@@ -17,139 +17,466 @@\n \n //! Defines miscellaneous array kernels.\n \n-use std::sync::Arc;\n-\n use crate::array::*;\n use crate::datatypes::{ArrowNumericType, DataType, TimeUnit};\n use crate::error::{ArrowError, Result};\n+use crate::record_batch::RecordBatch;\n+use crate::{\n+    bitmap::Bitmap,\n+    buffer::{Buffer, MutableBuffer},\n+    memory,\n+    util::bit_util,\n+};\n+use std::{mem, sync::Arc};\n \n-/// Helper function to perform boolean lambda function on values from two arrays.\n-fn bool_op<T, F>(\n-    left: &PrimitiveArray<T>,\n-    right: &PrimitiveArray<T>,\n-    op: F,\n-) -> Result<BooleanArray>\n-where\n-    T: ArrowNumericType,\n-    F: Fn(Option<T::Native>, Option<T::Native>) -> bool,\n-{\n-    if left.len() != right.len() {\n-        return Err(ArrowError::ComputeError(\n-            \"Cannot perform math operation on arrays of different length\".to_string(),\n-        ));\n+/// trait for copying filtered null bitmap bits\n+trait CopyNullBit {\n+    fn copy_null_bit(&mut self, source_index: usize);\n+    fn copy_null_bits(&mut self, source_index: usize, count: usize);\n+    fn null_count(&self) -> usize;\n+    fn null_buffer(&mut self) -> Buffer;\n+}\n+\n+/// no-op null bitmap copy implementation,\n+/// used when the filtered data array doesn't have a null bitmap\n+struct NullBitNoop {}\n+\n+impl NullBitNoop {\n+    fn new() -> Self {\n+        NullBitNoop {}\n     }\n-    let mut b = BooleanArray::builder(left.len());\n-    for i in 0..left.len() {\n-        let index = i;\n-        let l = if left.is_null(i) {\n-            None\n-        } else {\n-            Some(left.value(index))\n-        };\n-        let r = if right.is_null(i) {\n-            None\n-        } else {\n-            Some(right.value(index))\n-        };\n-        b.append_value(op(l, r))?;\n+}\n+\n+impl CopyNullBit for NullBitNoop {\n+    #[inline]\n+    fn copy_null_bit(&mut self, _source_index: usize) {\n+        // do nothing\n+    }\n+\n+    #[inline]\n+    fn copy_null_bits(&mut self, _source_index: usize, _count: usize) {\n+        // do nothing\n+    }\n+\n+    fn null_count(&self) -> usize {\n+        0\n+    }\n+\n+    fn null_buffer(&mut self) -> Buffer {\n+        Buffer::from([0u8; 0])\n     }\n-    Ok(b.finish())\n }\n \n-macro_rules! filter_array {\n-    ($array:expr, $filter:expr, $array_type:ident) => {{\n-        let b = $array.as_any().downcast_ref::<$array_type>().unwrap();\n-        let mut builder = $array_type::builder(b.len());\n-        for i in 0..b.len() {\n-            if $filter.value(i) {\n-                if b.is_null(i) {\n-                    builder.append_null()?;\n-                } else {\n-                    builder.append_value(b.value(i))?;\n-                }\n-            }\n-        }\n-        Ok(Arc::new(builder.finish()))\n-    }};\n+/// null bitmap copy implementation,\n+/// used when the filtered data array has a null bitmap\n+struct NullBitSetter<'a> {\n+    target_buffer: MutableBuffer,\n+    source_bytes: &'a [u8],\n+    target_index: usize,\n+    null_count: usize,\n }\n \n-/// Returns the array, taking only the elements matching the filter\n-pub fn filter(array: &Array, filter: &BooleanArray) -> Result<ArrayRef> {\n-    match array.data_type() {\n-        DataType::UInt8 => filter_array!(array, filter, UInt8Array),\n-        DataType::UInt16 => filter_array!(array, filter, UInt16Array),\n-        DataType::UInt32 => filter_array!(array, filter, UInt32Array),\n-        DataType::UInt64 => filter_array!(array, filter, UInt64Array),\n-        DataType::Int8 => filter_array!(array, filter, Int8Array),\n-        DataType::Int16 => filter_array!(array, filter, Int16Array),\n-        DataType::Int32 => filter_array!(array, filter, Int32Array),\n-        DataType::Int64 => filter_array!(array, filter, Int64Array),\n-        DataType::Float32 => filter_array!(array, filter, Float32Array),\n-        DataType::Float64 => filter_array!(array, filter, Float64Array),\n-        DataType::Boolean => filter_array!(array, filter, BooleanArray),\n-        DataType::Date32(_) => filter_array!(array, filter, Date32Array),\n-        DataType::Date64(_) => filter_array!(array, filter, Date64Array),\n-        DataType::Time32(TimeUnit::Second) => {\n-            filter_array!(array, filter, Time32SecondArray)\n-        }\n-        DataType::Time32(TimeUnit::Millisecond) => {\n-            filter_array!(array, filter, Time32MillisecondArray)\n-        }\n-        DataType::Time64(TimeUnit::Microsecond) => {\n-            filter_array!(array, filter, Time64MicrosecondArray)\n-        }\n-        DataType::Time64(TimeUnit::Nanosecond) => {\n-            filter_array!(array, filter, Time64NanosecondArray)\n-        }\n-        DataType::Duration(TimeUnit::Second) => {\n-            filter_array!(array, filter, DurationSecondArray)\n-        }\n-        DataType::Duration(TimeUnit::Millisecond) => {\n-            filter_array!(array, filter, DurationMillisecondArray)\n-        }\n-        DataType::Duration(TimeUnit::Microsecond) => {\n-            filter_array!(array, filter, DurationMicrosecondArray)\n+impl<'a> NullBitSetter<'a> {\n+    fn new(null_bitmap: &'a Bitmap) -> Self {\n+        let null_bytes = null_bitmap.buffer_ref().data();\n+        // create null bitmap buffer with same length and initialize null bitmap buffer to 1s\n+        let null_buffer =\n+            MutableBuffer::new(null_bytes.len()).with_bitset(null_bytes.len(), true);\n+        NullBitSetter {\n+            source_bytes: null_bytes,\n+            target_buffer: null_buffer,\n+            target_index: 0,\n+            null_count: 0,\n         }\n-        DataType::Duration(TimeUnit::Nanosecond) => {\n-            filter_array!(array, filter, DurationNanosecondArray)\n+    }\n+}\n+\n+impl<'a> CopyNullBit for NullBitSetter<'a> {\n+    #[inline]\n+    fn copy_null_bit(&mut self, source_index: usize) {\n+        if !bit_util::get_bit(self.source_bytes, source_index) {\n+            bit_util::unset_bit(self.target_buffer.data_mut(), self.target_index);\n+            self.null_count += 1;\n         }\n-        DataType::Timestamp(TimeUnit::Second, _) => {\n-            filter_array!(array, filter, TimestampSecondArray)\n+        self.target_index += 1;\n+    }\n+\n+    #[inline]\n+    fn copy_null_bits(&mut self, source_index: usize, count: usize) {\n+        for i in 0..count {\n+            self.copy_null_bit(source_index + i);\n         }\n-        DataType::Timestamp(TimeUnit::Millisecond, _) => {\n-            filter_array!(array, filter, TimestampMillisecondArray)\n+    }\n+\n+    fn null_count(&self) -> usize {\n+        self.null_count\n+    }\n+\n+    fn null_buffer(&mut self) -> Buffer {\n+        self.target_buffer.resize(self.target_index).unwrap();\n+        // use mem::replace to detach self.target_buffer from self so that it can be returned\n+        let target_buffer = mem::replace(&mut self.target_buffer, MutableBuffer::new(0));\n+        target_buffer.freeze()\n+    }\n+}\n+\n+fn get_null_bit_setter<'a>(data_array: &'a impl Array) -> Box<CopyNullBit + 'a> {\n+    if let Some(null_bitmap) = data_array.data_ref().null_bitmap() {\n+        // only return an actual null bit copy implementation if null_bitmap is set\n+        Box::new(NullBitSetter::new(null_bitmap))\n+    } else {\n+        // otherwise return a no-op copy null bit implementation\n+        // for improved performance when the filtered array doesn't contain NULLs\n+        Box::new(NullBitNoop::new())\n+    }\n+}\n+\n+// transmute filter array to u64\n+// - optimize filtering with highly selective filters by skipping entire batches of 64 filter bits\n+// - if the data array being filtered doesn't have a null bitmap, no time is wasted to copy a null bitmap\n+fn filter_array_impl(\n+    filter_context: &FilterContext,\n+    data_array: &impl Array,\n+    array_type: DataType,\n+    value_size: usize,\n+) -> Result<ArrayDataBuilder> {\n+    if filter_context.filter_len > data_array.len() {\n+        return Err(ArrowError::ComputeError(\n+            \"Filter array cannot be larger than data array\".to_string(),\n+        ));\n+    }\n+    let filtered_count = filter_context.filtered_count;\n+    let filter_mask = &filter_context.filter_mask;\n+    let filter_u64 = &filter_context.filter_u64;\n+    let data_start = data_array.data_ref().buffers()[0].raw_data();\n+    let mut value_buffer = MutableBuffer::new(filtered_count * value_size);\n+    value_buffer.resize(filtered_count * value_size)?;\n+    let mut value_position = value_buffer.raw_data_mut();\n+    let mut null_bit_setter = get_null_bit_setter(data_array);\n+    let null_bit_setter = null_bit_setter.as_mut();\n+    let all_ones_batch = !0u64;\n+\n+    for (i, filter_batch) in filter_u64.iter().enumerate() {\n+        // foreach u64 batch\n+        let filter_batch = *filter_batch;\n+        if filter_batch == 0 {\n+            // if batch == 0: skip\n+            continue;\n+        } else if filter_batch == all_ones_batch {\n+            // if batch == all 1s: copy all 64 values in one go\n+            let data_index = i * 64;\n+            let data_len = value_size * 64;\n+            null_bit_setter.copy_null_bits(data_index, 64);\n+            unsafe {\n\nReview comment:\n       @andygrove  I have replaced the use of unsafe memcpy with copy_from_slice - this does reduce performance (by about 12%) but it is still much faster than the old implementation; here are the latest benchmark results:\r\n   \r\n   filter u8 low selectivity                      time:   [130.74 us 131.37 us 132.19 us]\r\n   filter u8 high selectivity                     time:   [5.2031 us 5.2366 us 5.2764 us]\r\n   filter u8 very low selectivity                 time:   [12.353 us 12.542 us 12.759 us]\r\n   \r\n   filter context u8 low selectivity              time:   [129.54 us 129.88 us 130.30 us]\r\n   filter context u8 high selectivity             time:   [1.7926 us 1.7974 us 1.8046 us]\r\n   filter context u8 very low selectivity         time:   [8.7700 us 8.7987 us 8.8342 us]\r\n   \r\n   filter context u8 w NULLs low selectivity      time:   [150.36 us 151.09 us 152.01 us]\r\n   filter context u8 w NULLs high selectivity     time:   [2.4173 us 2.4882 us 2.5703 us]\r\n   filter context u8 w NULLs very low selectivity time:   [158.86 us 160.32 us 162.26 us]\r\n   \r\n   filter context f32 low selectivity             time:   [123.38 us 124.34 us 126.18 us]\r\n   filter context f32 high selectivity            time:   [1.4836 us 1.4994 us 1.5297 us]\r\n   filter context f32 very low selectivity        time:   [19.422 us 19.653 us 19.932 us]\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-29T07:19:15.161+0000",
                    "updated": "2020-07-29T07:19:15.161+0000",
                    "started": "2020-07-29T07:19:15.160+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463655",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/463776",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on a change in pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#discussion_r461228050\n\n\n\n##########\nFile path: rust/arrow/src/compute/kernels/filter.rs\n##########\n@@ -17,139 +17,466 @@\n \n //! Defines miscellaneous array kernels.\n \n-use std::sync::Arc;\n-\n use crate::array::*;\n use crate::datatypes::{ArrowNumericType, DataType, TimeUnit};\n use crate::error::{ArrowError, Result};\n+use crate::record_batch::RecordBatch;\n+use crate::{\n+    bitmap::Bitmap,\n+    buffer::{Buffer, MutableBuffer},\n+    memory,\n+    util::bit_util,\n+};\n+use std::{mem, sync::Arc};\n \n-/// Helper function to perform boolean lambda function on values from two arrays.\n-fn bool_op<T, F>(\n-    left: &PrimitiveArray<T>,\n-    right: &PrimitiveArray<T>,\n-    op: F,\n-) -> Result<BooleanArray>\n-where\n-    T: ArrowNumericType,\n-    F: Fn(Option<T::Native>, Option<T::Native>) -> bool,\n-{\n-    if left.len() != right.len() {\n-        return Err(ArrowError::ComputeError(\n-            \"Cannot perform math operation on arrays of different length\".to_string(),\n-        ));\n+/// trait for copying filtered null bitmap bits\n+trait CopyNullBit {\n+    fn copy_null_bit(&mut self, source_index: usize);\n+    fn copy_null_bits(&mut self, source_index: usize, count: usize);\n+    fn null_count(&self) -> usize;\n+    fn null_buffer(&mut self) -> Buffer;\n+}\n+\n+/// no-op null bitmap copy implementation,\n+/// used when the filtered data array doesn't have a null bitmap\n+struct NullBitNoop {}\n+\n+impl NullBitNoop {\n+    fn new() -> Self {\n+        NullBitNoop {}\n     }\n-    let mut b = BooleanArray::builder(left.len());\n-    for i in 0..left.len() {\n-        let index = i;\n-        let l = if left.is_null(i) {\n-            None\n-        } else {\n-            Some(left.value(index))\n-        };\n-        let r = if right.is_null(i) {\n-            None\n-        } else {\n-            Some(right.value(index))\n-        };\n-        b.append_value(op(l, r))?;\n+}\n+\n+impl CopyNullBit for NullBitNoop {\n+    #[inline]\n+    fn copy_null_bit(&mut self, _source_index: usize) {\n+        // do nothing\n+    }\n+\n+    #[inline]\n+    fn copy_null_bits(&mut self, _source_index: usize, _count: usize) {\n+        // do nothing\n+    }\n+\n+    fn null_count(&self) -> usize {\n+        0\n+    }\n+\n+    fn null_buffer(&mut self) -> Buffer {\n+        Buffer::from([0u8; 0])\n     }\n-    Ok(b.finish())\n }\n \n-macro_rules! filter_array {\n-    ($array:expr, $filter:expr, $array_type:ident) => {{\n-        let b = $array.as_any().downcast_ref::<$array_type>().unwrap();\n-        let mut builder = $array_type::builder(b.len());\n-        for i in 0..b.len() {\n-            if $filter.value(i) {\n-                if b.is_null(i) {\n-                    builder.append_null()?;\n-                } else {\n-                    builder.append_value(b.value(i))?;\n-                }\n-            }\n-        }\n-        Ok(Arc::new(builder.finish()))\n-    }};\n+/// null bitmap copy implementation,\n+/// used when the filtered data array has a null bitmap\n+struct NullBitSetter<'a> {\n+    target_buffer: MutableBuffer,\n+    source_bytes: &'a [u8],\n+    target_index: usize,\n+    null_count: usize,\n }\n \n-/// Returns the array, taking only the elements matching the filter\n-pub fn filter(array: &Array, filter: &BooleanArray) -> Result<ArrayRef> {\n-    match array.data_type() {\n-        DataType::UInt8 => filter_array!(array, filter, UInt8Array),\n-        DataType::UInt16 => filter_array!(array, filter, UInt16Array),\n-        DataType::UInt32 => filter_array!(array, filter, UInt32Array),\n-        DataType::UInt64 => filter_array!(array, filter, UInt64Array),\n-        DataType::Int8 => filter_array!(array, filter, Int8Array),\n-        DataType::Int16 => filter_array!(array, filter, Int16Array),\n-        DataType::Int32 => filter_array!(array, filter, Int32Array),\n-        DataType::Int64 => filter_array!(array, filter, Int64Array),\n-        DataType::Float32 => filter_array!(array, filter, Float32Array),\n-        DataType::Float64 => filter_array!(array, filter, Float64Array),\n-        DataType::Boolean => filter_array!(array, filter, BooleanArray),\n-        DataType::Date32(_) => filter_array!(array, filter, Date32Array),\n-        DataType::Date64(_) => filter_array!(array, filter, Date64Array),\n-        DataType::Time32(TimeUnit::Second) => {\n-            filter_array!(array, filter, Time32SecondArray)\n-        }\n-        DataType::Time32(TimeUnit::Millisecond) => {\n-            filter_array!(array, filter, Time32MillisecondArray)\n-        }\n-        DataType::Time64(TimeUnit::Microsecond) => {\n-            filter_array!(array, filter, Time64MicrosecondArray)\n-        }\n-        DataType::Time64(TimeUnit::Nanosecond) => {\n-            filter_array!(array, filter, Time64NanosecondArray)\n-        }\n-        DataType::Duration(TimeUnit::Second) => {\n-            filter_array!(array, filter, DurationSecondArray)\n-        }\n-        DataType::Duration(TimeUnit::Millisecond) => {\n-            filter_array!(array, filter, DurationMillisecondArray)\n-        }\n-        DataType::Duration(TimeUnit::Microsecond) => {\n-            filter_array!(array, filter, DurationMicrosecondArray)\n+impl<'a> NullBitSetter<'a> {\n+    fn new(null_bitmap: &'a Bitmap) -> Self {\n+        let null_bytes = null_bitmap.buffer_ref().data();\n+        // create null bitmap buffer with same length and initialize null bitmap buffer to 1s\n+        let null_buffer =\n+            MutableBuffer::new(null_bytes.len()).with_bitset(null_bytes.len(), true);\n+        NullBitSetter {\n+            source_bytes: null_bytes,\n+            target_buffer: null_buffer,\n+            target_index: 0,\n+            null_count: 0,\n         }\n-        DataType::Duration(TimeUnit::Nanosecond) => {\n-            filter_array!(array, filter, DurationNanosecondArray)\n+    }\n+}\n+\n+impl<'a> CopyNullBit for NullBitSetter<'a> {\n+    #[inline]\n+    fn copy_null_bit(&mut self, source_index: usize) {\n+        if !bit_util::get_bit(self.source_bytes, source_index) {\n+            bit_util::unset_bit(self.target_buffer.data_mut(), self.target_index);\n+            self.null_count += 1;\n         }\n-        DataType::Timestamp(TimeUnit::Second, _) => {\n-            filter_array!(array, filter, TimestampSecondArray)\n+        self.target_index += 1;\n+    }\n+\n+    #[inline]\n+    fn copy_null_bits(&mut self, source_index: usize, count: usize) {\n+        for i in 0..count {\n+            self.copy_null_bit(source_index + i);\n         }\n-        DataType::Timestamp(TimeUnit::Millisecond, _) => {\n-            filter_array!(array, filter, TimestampMillisecondArray)\n+    }\n+\n+    fn null_count(&self) -> usize {\n+        self.null_count\n+    }\n+\n+    fn null_buffer(&mut self) -> Buffer {\n+        self.target_buffer.resize(self.target_index).unwrap();\n+        // use mem::replace to detach self.target_buffer from self so that it can be returned\n+        let target_buffer = mem::replace(&mut self.target_buffer, MutableBuffer::new(0));\n+        target_buffer.freeze()\n+    }\n+}\n+\n+fn get_null_bit_setter<'a>(data_array: &'a impl Array) -> Box<CopyNullBit + 'a> {\n+    if let Some(null_bitmap) = data_array.data_ref().null_bitmap() {\n+        // only return an actual null bit copy implementation if null_bitmap is set\n+        Box::new(NullBitSetter::new(null_bitmap))\n+    } else {\n+        // otherwise return a no-op copy null bit implementation\n+        // for improved performance when the filtered array doesn't contain NULLs\n+        Box::new(NullBitNoop::new())\n+    }\n+}\n+\n+// transmute filter array to u64\n+// - optimize filtering with highly selective filters by skipping entire batches of 64 filter bits\n+// - if the data array being filtered doesn't have a null bitmap, no time is wasted to copy a null bitmap\n+fn filter_array_impl(\n+    filter_context: &FilterContext,\n+    data_array: &impl Array,\n+    array_type: DataType,\n+    value_size: usize,\n+) -> Result<ArrayDataBuilder> {\n+    if filter_context.filter_len > data_array.len() {\n+        return Err(ArrowError::ComputeError(\n+            \"Filter array cannot be larger than data array\".to_string(),\n+        ));\n+    }\n+    let filtered_count = filter_context.filtered_count;\n+    let filter_mask = &filter_context.filter_mask;\n+    let filter_u64 = &filter_context.filter_u64;\n+    let data_start = data_array.data_ref().buffers()[0].raw_data();\n+    let mut value_buffer = MutableBuffer::new(filtered_count * value_size);\n+    value_buffer.resize(filtered_count * value_size)?;\n+    let mut value_position = value_buffer.raw_data_mut();\n+    let mut null_bit_setter = get_null_bit_setter(data_array);\n+    let null_bit_setter = null_bit_setter.as_mut();\n+    let all_ones_batch = !0u64;\n+\n+    for (i, filter_batch) in filter_u64.iter().enumerate() {\n+        // foreach u64 batch\n+        let filter_batch = *filter_batch;\n+        if filter_batch == 0 {\n+            // if batch == 0: skip\n+            continue;\n+        } else if filter_batch == all_ones_batch {\n+            // if batch == all 1s: copy all 64 values in one go\n+            let data_index = i * 64;\n+            let data_len = value_size * 64;\n+            null_bit_setter.copy_null_bits(data_index, 64);\n+            unsafe {\n\nReview comment:\n       Thanks @yordan-pavlov We can always consider the unsafe changes in a future PR, but removing them for now makes it much easier to get these changes merged.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-29T07:31:40.121+0000",
                    "updated": "2020-07-29T07:31:40.121+0000",
                    "started": "2020-07-29T07:31:40.121+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "463776",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/465158",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov commented on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-667344474\n\n\n   @paddyhoran yes, you are right, I added a couple more tests for sliced arrays and they didn't pass so seeing that the PR was not yet merged I added a few small changes to \r\n   (1) implement support for filtering of sliced / offset data arrays\r\n   (2) return an error if the filter array is offset - I thought it better to make this obvious rather than hide it\r\n   \r\n   I looked briefly into implementing support for offset filter arrays but I couldn't figure out how to do it quickly - I might have to have another look at the C++ implementation and submit a separate PR for that.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-31T20:32:45.592+0000",
                    "updated": "2020-07-31T20:32:45.592+0000",
                    "started": "2020-07-31T20:32:45.592+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "465158",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/465290",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "yordan-pavlov edited a comment on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-667344474\n\n\n   @paddyhoran yes, you are right, I added a couple more tests for sliced arrays and they didn't pass so seeing that the PR was not yet merged I added a few small changes to \r\n   (1) implement support for filtering of sliced / offset data arrays\r\n   (2) return an error if the filter array is offset - I thought it better to make this obvious rather than silently process the offset filter array incorrectly\r\n   \r\n   I looked briefly into implementing support for offset filter arrays but I couldn't figure out how to do it quickly - I might have to take another look at the C++ implementation and submit a separate PR for that.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-01T09:09:18.299+0000",
                    "updated": "2020-08-01T09:09:18.299+0000",
                    "started": "2020-08-01T09:09:18.299+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "465290",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/467331",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove closed pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-06T14:44:33.394+0000",
                    "updated": "2020-08-06T14:44:33.394+0000",
                    "started": "2020-08-06T14:44:33.393+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "467331",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/468045",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-670723322\n\n\n   This PR makes me think that at some point (when someone gets really motivated), it would be interesting to implement a non-language-dependent benchmark harness for certain operations (such that can be represented using e.g. a standard protobuf serialized operation/expression) so that we can get apples-to-apples numbers for certain operations across implementations. It would be interesting to know e.g. how the Rust implementation of filtering compares with the C++\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-07T21:38:47.364+0000",
                    "updated": "2020-08-07T21:38:47.364+0000",
                    "started": "2020-08-07T21:38:47.364+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "468045",
                    "issueId": "13317615"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/worklog/468050",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on pull request #7798:\nURL: https://github.com/apache/arrow/pull/7798#issuecomment-670725220\n\n\n   I completely agree. I just happen to have a protobuf definition for plans and expressions as well as serde code for Java and Rust that I would be happy to contribute. We would need to implement for C++.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-07T21:45:40.766+0000",
                    "updated": "2020-08-07T21:45:40.766+0000",
                    "started": "2020-08-07T21:45:40.766+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "468050",
                    "issueId": "13317615"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 12000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@6dc8170c[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6869405c[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1b776303[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@393eab91[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5ac41cca[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@3f9ea2a5[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1f51b12e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@53ffe376[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@29a7878f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@63e68394[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@712c8607[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@5d642f07[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 12000,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Aug 06 14:44:29 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-08-06T14:44:29.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9523/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-07-19T11:26:03.000+0000",
        "updated": "2020-08-07T21:45:41.000+0000",
        "timeoriginalestimate": null,
        "description": "The filter kernel located here\u00a0[https://github.com/apache/arrow/blob/master/rust/arrow/src/compute/kernels/filter.rs]\r\n\r\ncurrently has the following performance:\r\n\r\nfilter old u8 low selectivity time: [1.7782 ms 1.7790 ms 1.7801 ms]\r\nfilter old u8 high selectivity time: [815.58 us 816.58 us 817.57 us]\r\nfilter old u8 w NULLs low selectivity time: [1.8131 ms 1.8231 ms 1.8336 ms]\r\nfilter old u8 w NULLs high selectivity time:\u00a0[817.41 us 820.01 us 823.05 us]\r\n\r\nI have been working on a new implementation which performs\u00a0between approximately 14 and 480 times faster depending mostly on filter selectivity. Here are the benchmark results:\r\n\r\nfilter u8 low selectivity time: [127.30 us 128.06 us 128.88 us]\r\nfilter u8 high selectivity time: [5.4215 us 5.5778 us 5.7335 us]\r\nfilter context u8 low selectivity time: [124.21 us 126.21 us 128.38 us]\r\nfilter context u8 high selectivity time: [1.6707 us 1.7052 us 1.7476 us]\r\nfilter context u8 w NULLs low selectivity time: [142.40 us 142.83 us 143.37 us]\r\nfilter context u8 w NULLs high selectivity time: [2.3338 us 2.3788 us 2.4304 us]\r\nfilter context f32 low selectivity time: [132.59 us 132.91 us 133.29 us]\r\nfilter context f32 high selectivity time: [1.6864 us 1.7026 us 1.7212 us]\r\n\r\nThis new implementation is based on a few key ideas:\r\n\r\n(1) if the data array being filtered doesn't have a null bitmap, no time should be wasted to copy or create a null bitmap in the resulting filtered data array - this is implemented using the\u00a0CopyNullBit trait which has a no-op implementation and an actual implementation\r\n\r\n(2) when the filter is highly selective, e.g. only a small number of values from the data array are selected, the filter implementation should efficiently skip entire batches of 0s in the filter array - this is implemented by transmuting the filter array to u64 which allows to quickly check and skip entire batches of 64 bits\u00a0\r\n\r\n(3) when an entire record batch is filtered, any computation which only depends on the filter array is done once and then shared for filtering all the data arrays in the record batch - this is implemented using the\u00a0FilterContext\u00a0struct\r\n\r\n\u00a0\r\n\r\n[~paddyhoran], [~andygrove]\u00a0let me know what you think",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 12000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] improve performance of filter kernel",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13317615/comment/17172427",
                    "id": "17172427",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "body": "Issue resolved by pull request 7798\n[https://github.com/apache/arrow/pull/7798]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "created": "2020-08-06T14:44:29.202+0000",
                    "updated": "2020-08-06T14:44:29.202+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0gwh4:",
        "customfield_12314139": null
    }
}