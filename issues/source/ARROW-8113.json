{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13291560",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560",
    "key": "ARROW-8113",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12340948",
                "id": "12340948",
                "description": "",
                "name": "0.16.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-02-07"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 19800,
            "total": 19800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 19800,
            "total": 19800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8113/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 33,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501204",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz opened a new pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472\n\n\n   - [ ] Unit tests for `util::Variant<>`\r\n   - [ ] Benchmark comparison to ensure compute and nested parquet are not impacted\r\n   - [ ] More docstrings and comments\r\n   \r\n   Locally:\r\n   \r\n   ```\r\n   $ ninja\r\n   ninja: no work to do.\r\n   $ export OBJS=`ls src/arrow/CMakeFiles/arrow_objlib.dir/compute/**/*.o`\r\n   \r\n   $ git checkout master && rm $OBJS && time ninja $OBJS\r\n   real\t0m6.137s\r\n   user\t1m6.760s\r\n   sys\t0m2.975s\r\n   \r\n   $ git checkout 8113-Implement-a-lighter-weigh && rm $OBJS && time ninja $OBJS\r\n   real\t0m0.032s\r\n   user\t0m0.123s\r\n   sys\t0m0.140s\r\n   ```\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-15T17:51:41.668+0000",
                    "updated": "2020-10-15T17:51:41.668+0000",
                    "started": "2020-10-15T17:51:41.668+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501204",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501212",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#issuecomment-709498987\n\n\n   https://issues.apache.org/jira/browse/ARROW-8113\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-15T18:07:26.460+0000",
                    "updated": "2020-10-15T18:07:26.460+0000",
                    "started": "2020-10-15T18:07:26.460+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501212",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501226",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#discussion_r505758011\n\n\n\n##########\nFile path: cpp/src/arrow/util/variant.h\n##########\n@@ -17,17 +17,363 @@\n \n #pragma once\n \n-#include \"arrow/vendored/variant.hpp\"  // IWYU pragma: export\n+#include <array>\n+#include <cstddef>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"arrow/util/macros.h\"\n \n namespace arrow {\n namespace util {\n \n-using ::mpark::bad_variant_access;\n-using ::mpark::get;\n-using ::mpark::get_if;\n-using ::mpark::holds_alternative;\n-using ::mpark::variant;\n-using ::mpark::visit;\n+/// \\brief a std::variant-like discriminated union\n+///\n+/// Simplifications from std::variant:\n+///\n+/// - Strictly defaultable. The first type of T... must be nothrow default constructible\n+///   and it will be used for default Variants.\n+///\n+/// - Never valueless_by_exception. std::variant supports a state outside those specified\n+///   by T... to which it can return in the event that a constructor throws. If a Variant\n+///   would become valueless_by_exception it will instead return to its default state.\n+///\n+/// - Strictly nothrow move constructible and assignable, which is also required of each\n+///   of T...\n+///\n+/// - Less sophisticated type deduction. std::variant<bool, std::string>(\"hello\") will\n+///   intelligently construct std::string while Variant will construct bool.\n+///\n+/// - Either both copy constructible and assignable or neither (std::variant independently\n+///   enables copy construction and copy assignment). Variant is copy constructible if\n+///   each of T... is copy constructible and assignable.\n+///\n+/// - Slimmer interface; several members of std::variant are omitted.\n+///\n+/// - Throws no exceptions; if a bad_variant_access would be thrown Variant will instead\n+///   segfault (nullptr dereference).\n+///\n+/// - Mutable visit takes a pointer instead of mutable reference or rvalue reference,\n+///   which is more conformant with our code style.\n+template <typename... T>\n+class Variant;\n+\n+namespace detail {\n+\n+template <typename T, typename = void>\n+struct is_equality_comparable : std::false_type {};\n+\n+template <typename T>\n+struct is_equality_comparable<\n+    T, typename std::enable_if<std::is_convertible<\n+           decltype(std::declval<T>() == std::declval<T>()), bool>::value>::type>\n+    : std::true_type {};\n+\n+template <bool C, typename T, typename E>\n+using conditional_t = typename std::conditional<C, T, E>::type;\n+\n+template <typename T>\n+struct type_constant {\n+  using type = T;\n+};\n+\n+template <typename...>\n+struct first;\n+\n+template <typename H, typename... T>\n+struct first<H, T...> {\n+  using type = H;\n+};\n+\n+template <typename T>\n+using decay_t = typename std::decay<T>::type;\n+\n+template <bool...>\n+struct all : std::true_type {};\n+\n+template <bool H, bool... T>\n+struct all<H, T...> : conditional_t<H, all<T...>, std::false_type> {};\n+\n+template <typename T>\n+void copy_construct(void* ptr, const void* other) {\n+  new (ptr) T(*static_cast<const T*>(other));\n+}\n+\n+template <typename T>\n+void move_construct(void* ptr, void* other) {\n+  new (ptr) T(std::move(*static_cast<T*>(other)));\n+}\n+\n+template <typename T>\n+void explicit_destroy(void* ptr) {\n+  static_cast<T*>(ptr)->~T();\n+}\n+\n+inline void trivial_destroy(void*) {}\n+\n+template <typename T>\n+bool equal(const void* l, const void* r) {\n+  return *static_cast<const T*>(l) == *static_cast<const T*>(r);\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<const T&>())) visit_const_ref(\n+    Visitor&& visitor, const void* ptr) {\n+  return std::forward<Visitor>(visitor)(*static_cast<const T*>(ptr));\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<T*>())) visit_mutable_ptr(\n+    Visitor&& visitor, void* ptr) {\n+  return std::forward<Visitor>(visitor)(static_cast<T*>(ptr));\n+}\n+\n+template <typename... T>\n+struct variant_storage {\n+  variant_storage() = default;\n+  variant_storage(const variant_storage&) {}\n+  variant_storage& operator=(const variant_storage&) { return *this; }\n+  variant_storage(variant_storage&&) {}\n+  variant_storage& operator=(variant_storage&&) { return *this; }\n+  ~variant_storage() {\n+    static_assert(offsetof(variant_storage, data_) == 0,\n+                  \"(void*)&variant_storage::data_ == (void*)this\");\n+  }\n+\n+  typename std::aligned_union<0, T...>::type data_;\n+  uint8_t index_ = 0;\n+};\n+\n+struct delete_copy_constructor {\n+  template <typename>\n+  struct type {\n+    type() = default;\n+    type(const type& other) = delete;\n+    type& operator=(const type& other) = delete;\n+  };\n+};\n+\n+struct explicit_copy_constructor {\n+  template <typename Copyable>\n+  struct type {\n+    type() = default;\n+    type(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/false);\n+    }\n+    type& operator=(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/true);\n+      return *this;\n+    }\n+  };\n+};\n+\n+template <typename V, uint8_t I, typename...>\n+struct member_constructor {\n+  static void index_of() {}\n+};\n+\n+template <typename V, uint8_t I, typename H, typename... T>\n+struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\n+  member_constructor() = default;\n+\n+  using member_constructor<V, I + 1, T...>::member_constructor;\n+  using member_constructor<V, I + 1, T...>::operator=;\n+  using member_constructor<V, I + 1, T...>::index_of;\n+\n+  explicit member_constructor(H value) {\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+  }\n+\n+  member_constructor& operator=(H value) {\n+    static_cast<V*>(this)->destroy();\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+    return *this;\n+  }\n+\n+  static constexpr std::integral_constant<uint8_t, I> index_of(const type_constant<H>&) {\n+    return {};\n+  }\n+};\n+\n+}  // namespace detail\n+\n+template <typename... T>\n+class Variant : detail::variant_storage<T...>,\n+                detail::conditional_t<\n+                    detail::all<(std::is_copy_constructible<T>::value &&\n+                                 std::is_copy_assignable<T>::value)...>::value,\n+                    detail::explicit_copy_constructor,\n+                    detail::delete_copy_constructor>::template type<Variant<T...>>,\n+                detail::member_constructor<Variant<T...>, 0, T...> {\n+  static_assert(detail::all<(std::is_nothrow_move_constructible<T>::value &&\n+                             std::is_nothrow_move_assignable<T>::value)...>::value,\n+                \"valueless_by_exception is not supported\");\n+\n+  template <typename U>\n+  static constexpr uint8_t index_of() {\n+    return detail::member_constructor<Variant<T...>, 0, T...>::index_of(\n+        detail::type_constant<U>{});\n+  }\n+\n+ public:\n+  using default_type = typename util::detail::first<T...>::type;\n+  static_assert(std::is_nothrow_default_constructible<default_type>::value,\n+                \"valueless_by_exception, non-default constructible are not supported\");\n+\n+  Variant() noexcept { construct_default(); }\n+\n+  Variant(const Variant& other) = default;\n+  Variant& operator=(const Variant& other) = default;\n+\n+  using detail::member_constructor<Variant<T...>, 0, T...>::member_constructor;\n+  using detail::member_constructor<Variant<T...>, 0, T...>::operator=;\n+\n+  Variant(Variant&& other) noexcept { move(&other, /*assignment=*/false); }\n+\n+  Variant& operator=(Variant&& other) noexcept {\n+    move(&other, /*assignment=*/true);\n+    return *this;\n+  }\n+\n+  ~Variant() {\n+    static_assert(offsetof(Variant, data_) == 0, \"(void*)&Variant::data_ == (void*)this\");\n+    this->destroy();\n+  }\n+\n+  uint8_t index() const noexcept { return this->index_; }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  const U* get() const noexcept {\n+    return index() == I ? reinterpret_cast<const U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  U* get() noexcept {\n+    return index() == I ? reinterpret_cast<U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, typename... A, uint8_t I = index_of<U>()>\n+  void emplace(A&&... args) try {\n+    this->destroy();\n+    new (this) U(std::forward<A>(args)...);\n+    this->index_ = I;\n+  } catch (...) {\n+    construct_default();\n+    throw;\n+  }\n+\n+  void swap(Variant& other) noexcept {  // NOLINT google-runtime-references\n+    Variant tmp = std::move(other);\n+    other = std::move(*this);\n+    *this = std::move(tmp);\n+  }\n+\n+ private:\n+  void move(Variant* other, bool assignment) noexcept {\n+    using impl_t = void(void*, void*);\n+    static std::array<impl_t*, sizeof...(T)> impl = {detail::move_construct<T>...};\n\nReview comment:\n       `constexpr`, no?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-15T18:34:18.783+0000",
                    "updated": "2020-10-15T18:34:18.783+0000",
                    "started": "2020-10-15T18:34:18.783+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501226",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501227",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#discussion_r505758582\n\n\n\n##########\nFile path: cpp/src/arrow/util/variant.h\n##########\n@@ -17,17 +17,363 @@\n \n #pragma once\n \n-#include \"arrow/vendored/variant.hpp\"  // IWYU pragma: export\n+#include <array>\n+#include <cstddef>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"arrow/util/macros.h\"\n \n namespace arrow {\n namespace util {\n \n-using ::mpark::bad_variant_access;\n-using ::mpark::get;\n-using ::mpark::get_if;\n-using ::mpark::holds_alternative;\n-using ::mpark::variant;\n-using ::mpark::visit;\n+/// \\brief a std::variant-like discriminated union\n+///\n+/// Simplifications from std::variant:\n+///\n+/// - Strictly defaultable. The first type of T... must be nothrow default constructible\n+///   and it will be used for default Variants.\n+///\n+/// - Never valueless_by_exception. std::variant supports a state outside those specified\n+///   by T... to which it can return in the event that a constructor throws. If a Variant\n+///   would become valueless_by_exception it will instead return to its default state.\n+///\n+/// - Strictly nothrow move constructible and assignable, which is also required of each\n+///   of T...\n+///\n+/// - Less sophisticated type deduction. std::variant<bool, std::string>(\"hello\") will\n+///   intelligently construct std::string while Variant will construct bool.\n+///\n+/// - Either both copy constructible and assignable or neither (std::variant independently\n+///   enables copy construction and copy assignment). Variant is copy constructible if\n+///   each of T... is copy constructible and assignable.\n+///\n+/// - Slimmer interface; several members of std::variant are omitted.\n+///\n+/// - Throws no exceptions; if a bad_variant_access would be thrown Variant will instead\n+///   segfault (nullptr dereference).\n+///\n+/// - Mutable visit takes a pointer instead of mutable reference or rvalue reference,\n+///   which is more conformant with our code style.\n+template <typename... T>\n+class Variant;\n+\n+namespace detail {\n+\n+template <typename T, typename = void>\n+struct is_equality_comparable : std::false_type {};\n+\n+template <typename T>\n+struct is_equality_comparable<\n+    T, typename std::enable_if<std::is_convertible<\n+           decltype(std::declval<T>() == std::declval<T>()), bool>::value>::type>\n+    : std::true_type {};\n+\n+template <bool C, typename T, typename E>\n+using conditional_t = typename std::conditional<C, T, E>::type;\n+\n+template <typename T>\n+struct type_constant {\n+  using type = T;\n+};\n+\n+template <typename...>\n+struct first;\n+\n+template <typename H, typename... T>\n+struct first<H, T...> {\n+  using type = H;\n+};\n+\n+template <typename T>\n+using decay_t = typename std::decay<T>::type;\n+\n+template <bool...>\n+struct all : std::true_type {};\n+\n+template <bool H, bool... T>\n+struct all<H, T...> : conditional_t<H, all<T...>, std::false_type> {};\n+\n+template <typename T>\n+void copy_construct(void* ptr, const void* other) {\n+  new (ptr) T(*static_cast<const T*>(other));\n+}\n+\n+template <typename T>\n+void move_construct(void* ptr, void* other) {\n+  new (ptr) T(std::move(*static_cast<T*>(other)));\n+}\n+\n+template <typename T>\n+void explicit_destroy(void* ptr) {\n+  static_cast<T*>(ptr)->~T();\n+}\n+\n+inline void trivial_destroy(void*) {}\n+\n+template <typename T>\n+bool equal(const void* l, const void* r) {\n+  return *static_cast<const T*>(l) == *static_cast<const T*>(r);\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<const T&>())) visit_const_ref(\n+    Visitor&& visitor, const void* ptr) {\n+  return std::forward<Visitor>(visitor)(*static_cast<const T*>(ptr));\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<T*>())) visit_mutable_ptr(\n+    Visitor&& visitor, void* ptr) {\n+  return std::forward<Visitor>(visitor)(static_cast<T*>(ptr));\n+}\n+\n+template <typename... T>\n+struct variant_storage {\n+  variant_storage() = default;\n+  variant_storage(const variant_storage&) {}\n+  variant_storage& operator=(const variant_storage&) { return *this; }\n+  variant_storage(variant_storage&&) {}\n+  variant_storage& operator=(variant_storage&&) { return *this; }\n+  ~variant_storage() {\n+    static_assert(offsetof(variant_storage, data_) == 0,\n+                  \"(void*)&variant_storage::data_ == (void*)this\");\n+  }\n+\n+  typename std::aligned_union<0, T...>::type data_;\n+  uint8_t index_ = 0;\n+};\n+\n+struct delete_copy_constructor {\n+  template <typename>\n+  struct type {\n+    type() = default;\n+    type(const type& other) = delete;\n+    type& operator=(const type& other) = delete;\n+  };\n+};\n+\n+struct explicit_copy_constructor {\n+  template <typename Copyable>\n+  struct type {\n+    type() = default;\n+    type(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/false);\n+    }\n+    type& operator=(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/true);\n+      return *this;\n+    }\n+  };\n+};\n+\n+template <typename V, uint8_t I, typename...>\n+struct member_constructor {\n+  static void index_of() {}\n+};\n+\n+template <typename V, uint8_t I, typename H, typename... T>\n+struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\n+  member_constructor() = default;\n+\n+  using member_constructor<V, I + 1, T...>::member_constructor;\n+  using member_constructor<V, I + 1, T...>::operator=;\n+  using member_constructor<V, I + 1, T...>::index_of;\n+\n+  explicit member_constructor(H value) {\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+  }\n+\n+  member_constructor& operator=(H value) {\n+    static_cast<V*>(this)->destroy();\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+    return *this;\n+  }\n+\n+  static constexpr std::integral_constant<uint8_t, I> index_of(const type_constant<H>&) {\n+    return {};\n+  }\n+};\n+\n+}  // namespace detail\n+\n+template <typename... T>\n+class Variant : detail::variant_storage<T...>,\n+                detail::conditional_t<\n+                    detail::all<(std::is_copy_constructible<T>::value &&\n+                                 std::is_copy_assignable<T>::value)...>::value,\n+                    detail::explicit_copy_constructor,\n+                    detail::delete_copy_constructor>::template type<Variant<T...>>,\n+                detail::member_constructor<Variant<T...>, 0, T...> {\n+  static_assert(detail::all<(std::is_nothrow_move_constructible<T>::value &&\n+                             std::is_nothrow_move_assignable<T>::value)...>::value,\n+                \"valueless_by_exception is not supported\");\n+\n+  template <typename U>\n+  static constexpr uint8_t index_of() {\n+    return detail::member_constructor<Variant<T...>, 0, T...>::index_of(\n+        detail::type_constant<U>{});\n+  }\n+\n+ public:\n+  using default_type = typename util::detail::first<T...>::type;\n+  static_assert(std::is_nothrow_default_constructible<default_type>::value,\n+                \"valueless_by_exception, non-default constructible are not supported\");\n+\n+  Variant() noexcept { construct_default(); }\n+\n+  Variant(const Variant& other) = default;\n+  Variant& operator=(const Variant& other) = default;\n+\n+  using detail::member_constructor<Variant<T...>, 0, T...>::member_constructor;\n+  using detail::member_constructor<Variant<T...>, 0, T...>::operator=;\n+\n+  Variant(Variant&& other) noexcept { move(&other, /*assignment=*/false); }\n+\n+  Variant& operator=(Variant&& other) noexcept {\n+    move(&other, /*assignment=*/true);\n+    return *this;\n+  }\n+\n+  ~Variant() {\n+    static_assert(offsetof(Variant, data_) == 0, \"(void*)&Variant::data_ == (void*)this\");\n+    this->destroy();\n+  }\n+\n+  uint8_t index() const noexcept { return this->index_; }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  const U* get() const noexcept {\n+    return index() == I ? reinterpret_cast<const U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  U* get() noexcept {\n+    return index() == I ? reinterpret_cast<U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, typename... A, uint8_t I = index_of<U>()>\n+  void emplace(A&&... args) try {\n+    this->destroy();\n+    new (this) U(std::forward<A>(args)...);\n+    this->index_ = I;\n+  } catch (...) {\n+    construct_default();\n+    throw;\n+  }\n+\n+  void swap(Variant& other) noexcept {  // NOLINT google-runtime-references\n+    Variant tmp = std::move(other);\n+    other = std::move(*this);\n+    *this = std::move(tmp);\n+  }\n+\n+ private:\n+  void move(Variant* other, bool assignment) noexcept {\n+    using impl_t = void(void*, void*);\n+    static std::array<impl_t*, sizeof...(T)> impl = {detail::move_construct<T>...};\n+\n+    if (assignment) {\n+      this->destroy();\n+    }\n+\n+    auto index = other->index_;\n+    impl[index](this, other);\n\nReview comment:\n       Are you sure this kind of function table access will be inlined by the compiler as a switch/case?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-15T18:35:16.216+0000",
                    "updated": "2020-10-15T18:35:16.216+0000",
                    "started": "2020-10-15T18:35:16.215+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501227",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501233",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#discussion_r505766872\n\n\n\n##########\nFile path: cpp/src/arrow/util/variant.h\n##########\n@@ -17,17 +17,363 @@\n \n #pragma once\n \n-#include \"arrow/vendored/variant.hpp\"  // IWYU pragma: export\n+#include <array>\n+#include <cstddef>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"arrow/util/macros.h\"\n \n namespace arrow {\n namespace util {\n \n-using ::mpark::bad_variant_access;\n-using ::mpark::get;\n-using ::mpark::get_if;\n-using ::mpark::holds_alternative;\n-using ::mpark::variant;\n-using ::mpark::visit;\n+/// \\brief a std::variant-like discriminated union\n+///\n+/// Simplifications from std::variant:\n+///\n+/// - Strictly defaultable. The first type of T... must be nothrow default constructible\n+///   and it will be used for default Variants.\n+///\n+/// - Never valueless_by_exception. std::variant supports a state outside those specified\n+///   by T... to which it can return in the event that a constructor throws. If a Variant\n+///   would become valueless_by_exception it will instead return to its default state.\n+///\n+/// - Strictly nothrow move constructible and assignable, which is also required of each\n+///   of T...\n+///\n+/// - Less sophisticated type deduction. std::variant<bool, std::string>(\"hello\") will\n+///   intelligently construct std::string while Variant will construct bool.\n+///\n+/// - Either both copy constructible and assignable or neither (std::variant independently\n+///   enables copy construction and copy assignment). Variant is copy constructible if\n+///   each of T... is copy constructible and assignable.\n+///\n+/// - Slimmer interface; several members of std::variant are omitted.\n+///\n+/// - Throws no exceptions; if a bad_variant_access would be thrown Variant will instead\n+///   segfault (nullptr dereference).\n+///\n+/// - Mutable visit takes a pointer instead of mutable reference or rvalue reference,\n+///   which is more conformant with our code style.\n+template <typename... T>\n+class Variant;\n+\n+namespace detail {\n+\n+template <typename T, typename = void>\n+struct is_equality_comparable : std::false_type {};\n+\n+template <typename T>\n+struct is_equality_comparable<\n+    T, typename std::enable_if<std::is_convertible<\n+           decltype(std::declval<T>() == std::declval<T>()), bool>::value>::type>\n+    : std::true_type {};\n+\n+template <bool C, typename T, typename E>\n+using conditional_t = typename std::conditional<C, T, E>::type;\n+\n+template <typename T>\n+struct type_constant {\n+  using type = T;\n+};\n+\n+template <typename...>\n+struct first;\n+\n+template <typename H, typename... T>\n+struct first<H, T...> {\n+  using type = H;\n+};\n+\n+template <typename T>\n+using decay_t = typename std::decay<T>::type;\n+\n+template <bool...>\n+struct all : std::true_type {};\n+\n+template <bool H, bool... T>\n+struct all<H, T...> : conditional_t<H, all<T...>, std::false_type> {};\n+\n+template <typename T>\n+void copy_construct(void* ptr, const void* other) {\n+  new (ptr) T(*static_cast<const T*>(other));\n+}\n+\n+template <typename T>\n+void move_construct(void* ptr, void* other) {\n+  new (ptr) T(std::move(*static_cast<T*>(other)));\n+}\n+\n+template <typename T>\n+void explicit_destroy(void* ptr) {\n+  static_cast<T*>(ptr)->~T();\n+}\n+\n+inline void trivial_destroy(void*) {}\n+\n+template <typename T>\n+bool equal(const void* l, const void* r) {\n+  return *static_cast<const T*>(l) == *static_cast<const T*>(r);\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<const T&>())) visit_const_ref(\n+    Visitor&& visitor, const void* ptr) {\n+  return std::forward<Visitor>(visitor)(*static_cast<const T*>(ptr));\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<T*>())) visit_mutable_ptr(\n+    Visitor&& visitor, void* ptr) {\n+  return std::forward<Visitor>(visitor)(static_cast<T*>(ptr));\n+}\n+\n+template <typename... T>\n+struct variant_storage {\n+  variant_storage() = default;\n+  variant_storage(const variant_storage&) {}\n+  variant_storage& operator=(const variant_storage&) { return *this; }\n+  variant_storage(variant_storage&&) {}\n+  variant_storage& operator=(variant_storage&&) { return *this; }\n+  ~variant_storage() {\n+    static_assert(offsetof(variant_storage, data_) == 0,\n+                  \"(void*)&variant_storage::data_ == (void*)this\");\n+  }\n+\n+  typename std::aligned_union<0, T...>::type data_;\n+  uint8_t index_ = 0;\n+};\n+\n+struct delete_copy_constructor {\n+  template <typename>\n+  struct type {\n+    type() = default;\n+    type(const type& other) = delete;\n+    type& operator=(const type& other) = delete;\n+  };\n+};\n+\n+struct explicit_copy_constructor {\n+  template <typename Copyable>\n+  struct type {\n+    type() = default;\n+    type(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/false);\n+    }\n+    type& operator=(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/true);\n+      return *this;\n+    }\n+  };\n+};\n+\n+template <typename V, uint8_t I, typename...>\n+struct member_constructor {\n+  static void index_of() {}\n+};\n+\n+template <typename V, uint8_t I, typename H, typename... T>\n+struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\n+  member_constructor() = default;\n+\n+  using member_constructor<V, I + 1, T...>::member_constructor;\n+  using member_constructor<V, I + 1, T...>::operator=;\n+  using member_constructor<V, I + 1, T...>::index_of;\n+\n+  explicit member_constructor(H value) {\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+  }\n+\n+  member_constructor& operator=(H value) {\n+    static_cast<V*>(this)->destroy();\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+    return *this;\n+  }\n+\n+  static constexpr std::integral_constant<uint8_t, I> index_of(const type_constant<H>&) {\n+    return {};\n+  }\n+};\n+\n+}  // namespace detail\n+\n+template <typename... T>\n+class Variant : detail::variant_storage<T...>,\n+                detail::conditional_t<\n+                    detail::all<(std::is_copy_constructible<T>::value &&\n+                                 std::is_copy_assignable<T>::value)...>::value,\n+                    detail::explicit_copy_constructor,\n+                    detail::delete_copy_constructor>::template type<Variant<T...>>,\n+                detail::member_constructor<Variant<T...>, 0, T...> {\n+  static_assert(detail::all<(std::is_nothrow_move_constructible<T>::value &&\n+                             std::is_nothrow_move_assignable<T>::value)...>::value,\n+                \"valueless_by_exception is not supported\");\n+\n+  template <typename U>\n+  static constexpr uint8_t index_of() {\n+    return detail::member_constructor<Variant<T...>, 0, T...>::index_of(\n+        detail::type_constant<U>{});\n+  }\n+\n+ public:\n+  using default_type = typename util::detail::first<T...>::type;\n+  static_assert(std::is_nothrow_default_constructible<default_type>::value,\n+                \"valueless_by_exception, non-default constructible are not supported\");\n+\n+  Variant() noexcept { construct_default(); }\n+\n+  Variant(const Variant& other) = default;\n+  Variant& operator=(const Variant& other) = default;\n+\n+  using detail::member_constructor<Variant<T...>, 0, T...>::member_constructor;\n+  using detail::member_constructor<Variant<T...>, 0, T...>::operator=;\n+\n+  Variant(Variant&& other) noexcept { move(&other, /*assignment=*/false); }\n+\n+  Variant& operator=(Variant&& other) noexcept {\n+    move(&other, /*assignment=*/true);\n+    return *this;\n+  }\n+\n+  ~Variant() {\n+    static_assert(offsetof(Variant, data_) == 0, \"(void*)&Variant::data_ == (void*)this\");\n+    this->destroy();\n+  }\n+\n+  uint8_t index() const noexcept { return this->index_; }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  const U* get() const noexcept {\n+    return index() == I ? reinterpret_cast<const U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  U* get() noexcept {\n+    return index() == I ? reinterpret_cast<U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, typename... A, uint8_t I = index_of<U>()>\n+  void emplace(A&&... args) try {\n+    this->destroy();\n+    new (this) U(std::forward<A>(args)...);\n+    this->index_ = I;\n+  } catch (...) {\n+    construct_default();\n+    throw;\n+  }\n+\n+  void swap(Variant& other) noexcept {  // NOLINT google-runtime-references\n+    Variant tmp = std::move(other);\n+    other = std::move(*this);\n+    *this = std::move(tmp);\n+  }\n+\n+ private:\n+  void move(Variant* other, bool assignment) noexcept {\n+    using impl_t = void(void*, void*);\n+    static std::array<impl_t*, sizeof...(T)> impl = {detail::move_construct<T>...};\n\nReview comment:\n       Whoops, correct\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-15T18:49:59.598+0000",
                    "updated": "2020-10-15T18:49:59.598+0000",
                    "started": "2020-10-15T18:49:59.597+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501233",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501242",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#discussion_r505774708\n\n\n\n##########\nFile path: cpp/src/arrow/util/variant.h\n##########\n@@ -17,17 +17,363 @@\n \n #pragma once\n \n-#include \"arrow/vendored/variant.hpp\"  // IWYU pragma: export\n+#include <array>\n+#include <cstddef>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"arrow/util/macros.h\"\n \n namespace arrow {\n namespace util {\n \n-using ::mpark::bad_variant_access;\n-using ::mpark::get;\n-using ::mpark::get_if;\n-using ::mpark::holds_alternative;\n-using ::mpark::variant;\n-using ::mpark::visit;\n+/// \\brief a std::variant-like discriminated union\n+///\n+/// Simplifications from std::variant:\n+///\n+/// - Strictly defaultable. The first type of T... must be nothrow default constructible\n+///   and it will be used for default Variants.\n+///\n+/// - Never valueless_by_exception. std::variant supports a state outside those specified\n+///   by T... to which it can return in the event that a constructor throws. If a Variant\n+///   would become valueless_by_exception it will instead return to its default state.\n+///\n+/// - Strictly nothrow move constructible and assignable, which is also required of each\n+///   of T...\n+///\n+/// - Less sophisticated type deduction. std::variant<bool, std::string>(\"hello\") will\n+///   intelligently construct std::string while Variant will construct bool.\n+///\n+/// - Either both copy constructible and assignable or neither (std::variant independently\n+///   enables copy construction and copy assignment). Variant is copy constructible if\n+///   each of T... is copy constructible and assignable.\n+///\n+/// - Slimmer interface; several members of std::variant are omitted.\n+///\n+/// - Throws no exceptions; if a bad_variant_access would be thrown Variant will instead\n+///   segfault (nullptr dereference).\n+///\n+/// - Mutable visit takes a pointer instead of mutable reference or rvalue reference,\n+///   which is more conformant with our code style.\n+template <typename... T>\n+class Variant;\n+\n+namespace detail {\n+\n+template <typename T, typename = void>\n+struct is_equality_comparable : std::false_type {};\n+\n+template <typename T>\n+struct is_equality_comparable<\n+    T, typename std::enable_if<std::is_convertible<\n+           decltype(std::declval<T>() == std::declval<T>()), bool>::value>::type>\n+    : std::true_type {};\n+\n+template <bool C, typename T, typename E>\n+using conditional_t = typename std::conditional<C, T, E>::type;\n+\n+template <typename T>\n+struct type_constant {\n+  using type = T;\n+};\n+\n+template <typename...>\n+struct first;\n+\n+template <typename H, typename... T>\n+struct first<H, T...> {\n+  using type = H;\n+};\n+\n+template <typename T>\n+using decay_t = typename std::decay<T>::type;\n+\n+template <bool...>\n+struct all : std::true_type {};\n+\n+template <bool H, bool... T>\n+struct all<H, T...> : conditional_t<H, all<T...>, std::false_type> {};\n+\n+template <typename T>\n+void copy_construct(void* ptr, const void* other) {\n+  new (ptr) T(*static_cast<const T*>(other));\n+}\n+\n+template <typename T>\n+void move_construct(void* ptr, void* other) {\n+  new (ptr) T(std::move(*static_cast<T*>(other)));\n+}\n+\n+template <typename T>\n+void explicit_destroy(void* ptr) {\n+  static_cast<T*>(ptr)->~T();\n+}\n+\n+inline void trivial_destroy(void*) {}\n+\n+template <typename T>\n+bool equal(const void* l, const void* r) {\n+  return *static_cast<const T*>(l) == *static_cast<const T*>(r);\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<const T&>())) visit_const_ref(\n+    Visitor&& visitor, const void* ptr) {\n+  return std::forward<Visitor>(visitor)(*static_cast<const T*>(ptr));\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<T*>())) visit_mutable_ptr(\n+    Visitor&& visitor, void* ptr) {\n+  return std::forward<Visitor>(visitor)(static_cast<T*>(ptr));\n+}\n+\n+template <typename... T>\n+struct variant_storage {\n+  variant_storage() = default;\n+  variant_storage(const variant_storage&) {}\n+  variant_storage& operator=(const variant_storage&) { return *this; }\n+  variant_storage(variant_storage&&) {}\n+  variant_storage& operator=(variant_storage&&) { return *this; }\n+  ~variant_storage() {\n+    static_assert(offsetof(variant_storage, data_) == 0,\n+                  \"(void*)&variant_storage::data_ == (void*)this\");\n+  }\n+\n+  typename std::aligned_union<0, T...>::type data_;\n+  uint8_t index_ = 0;\n+};\n+\n+struct delete_copy_constructor {\n+  template <typename>\n+  struct type {\n+    type() = default;\n+    type(const type& other) = delete;\n+    type& operator=(const type& other) = delete;\n+  };\n+};\n+\n+struct explicit_copy_constructor {\n+  template <typename Copyable>\n+  struct type {\n+    type() = default;\n+    type(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/false);\n+    }\n+    type& operator=(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/true);\n+      return *this;\n+    }\n+  };\n+};\n+\n+template <typename V, uint8_t I, typename...>\n+struct member_constructor {\n+  static void index_of() {}\n+};\n+\n+template <typename V, uint8_t I, typename H, typename... T>\n+struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\n+  member_constructor() = default;\n+\n+  using member_constructor<V, I + 1, T...>::member_constructor;\n+  using member_constructor<V, I + 1, T...>::operator=;\n+  using member_constructor<V, I + 1, T...>::index_of;\n+\n+  explicit member_constructor(H value) {\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+  }\n+\n+  member_constructor& operator=(H value) {\n+    static_cast<V*>(this)->destroy();\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+    return *this;\n+  }\n+\n+  static constexpr std::integral_constant<uint8_t, I> index_of(const type_constant<H>&) {\n+    return {};\n+  }\n+};\n+\n+}  // namespace detail\n+\n+template <typename... T>\n+class Variant : detail::variant_storage<T...>,\n+                detail::conditional_t<\n+                    detail::all<(std::is_copy_constructible<T>::value &&\n+                                 std::is_copy_assignable<T>::value)...>::value,\n+                    detail::explicit_copy_constructor,\n+                    detail::delete_copy_constructor>::template type<Variant<T...>>,\n+                detail::member_constructor<Variant<T...>, 0, T...> {\n+  static_assert(detail::all<(std::is_nothrow_move_constructible<T>::value &&\n+                             std::is_nothrow_move_assignable<T>::value)...>::value,\n+                \"valueless_by_exception is not supported\");\n+\n+  template <typename U>\n+  static constexpr uint8_t index_of() {\n+    return detail::member_constructor<Variant<T...>, 0, T...>::index_of(\n+        detail::type_constant<U>{});\n+  }\n+\n+ public:\n+  using default_type = typename util::detail::first<T...>::type;\n+  static_assert(std::is_nothrow_default_constructible<default_type>::value,\n+                \"valueless_by_exception, non-default constructible are not supported\");\n+\n+  Variant() noexcept { construct_default(); }\n+\n+  Variant(const Variant& other) = default;\n+  Variant& operator=(const Variant& other) = default;\n+\n+  using detail::member_constructor<Variant<T...>, 0, T...>::member_constructor;\n+  using detail::member_constructor<Variant<T...>, 0, T...>::operator=;\n+\n+  Variant(Variant&& other) noexcept { move(&other, /*assignment=*/false); }\n+\n+  Variant& operator=(Variant&& other) noexcept {\n+    move(&other, /*assignment=*/true);\n+    return *this;\n+  }\n+\n+  ~Variant() {\n+    static_assert(offsetof(Variant, data_) == 0, \"(void*)&Variant::data_ == (void*)this\");\n+    this->destroy();\n+  }\n+\n+  uint8_t index() const noexcept { return this->index_; }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  const U* get() const noexcept {\n+    return index() == I ? reinterpret_cast<const U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  U* get() noexcept {\n+    return index() == I ? reinterpret_cast<U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, typename... A, uint8_t I = index_of<U>()>\n+  void emplace(A&&... args) try {\n+    this->destroy();\n+    new (this) U(std::forward<A>(args)...);\n+    this->index_ = I;\n+  } catch (...) {\n+    construct_default();\n+    throw;\n+  }\n+\n+  void swap(Variant& other) noexcept {  // NOLINT google-runtime-references\n+    Variant tmp = std::move(other);\n+    other = std::move(*this);\n+    *this = std::move(tmp);\n+  }\n+\n+ private:\n+  void move(Variant* other, bool assignment) noexcept {\n+    using impl_t = void(void*, void*);\n+    static std::array<impl_t*, sizeof...(T)> impl = {detail::move_construct<T>...};\n+\n+    if (assignment) {\n+      this->destroy();\n+    }\n+\n+    auto index = other->index_;\n+    impl[index](this, other);\n\nReview comment:\n       Clang 10 succeeds: https://godbolt.org/z/ab8Gaf\r\n   \r\n   Moreover, function tables are also the approach taken by vendored/variant.hpp for c++11 when last I checked\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-15T19:04:15.765+0000",
                    "updated": "2020-10-15T19:04:15.765+0000",
                    "started": "2020-10-15T19:04:15.764+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501242",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501245",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#discussion_r505776377\n\n\n\n##########\nFile path: cpp/src/arrow/util/variant.h\n##########\n@@ -17,17 +17,363 @@\n \n #pragma once\n \n-#include \"arrow/vendored/variant.hpp\"  // IWYU pragma: export\n+#include <array>\n+#include <cstddef>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"arrow/util/macros.h\"\n \n namespace arrow {\n namespace util {\n \n-using ::mpark::bad_variant_access;\n-using ::mpark::get;\n-using ::mpark::get_if;\n-using ::mpark::holds_alternative;\n-using ::mpark::variant;\n-using ::mpark::visit;\n+/// \\brief a std::variant-like discriminated union\n+///\n+/// Simplifications from std::variant:\n+///\n+/// - Strictly defaultable. The first type of T... must be nothrow default constructible\n+///   and it will be used for default Variants.\n+///\n+/// - Never valueless_by_exception. std::variant supports a state outside those specified\n+///   by T... to which it can return in the event that a constructor throws. If a Variant\n+///   would become valueless_by_exception it will instead return to its default state.\n+///\n+/// - Strictly nothrow move constructible and assignable, which is also required of each\n+///   of T...\n+///\n+/// - Less sophisticated type deduction. std::variant<bool, std::string>(\"hello\") will\n+///   intelligently construct std::string while Variant will construct bool.\n+///\n+/// - Either both copy constructible and assignable or neither (std::variant independently\n+///   enables copy construction and copy assignment). Variant is copy constructible if\n+///   each of T... is copy constructible and assignable.\n+///\n+/// - Slimmer interface; several members of std::variant are omitted.\n+///\n+/// - Throws no exceptions; if a bad_variant_access would be thrown Variant will instead\n+///   segfault (nullptr dereference).\n+///\n+/// - Mutable visit takes a pointer instead of mutable reference or rvalue reference,\n+///   which is more conformant with our code style.\n+template <typename... T>\n+class Variant;\n+\n+namespace detail {\n+\n+template <typename T, typename = void>\n+struct is_equality_comparable : std::false_type {};\n+\n+template <typename T>\n+struct is_equality_comparable<\n+    T, typename std::enable_if<std::is_convertible<\n+           decltype(std::declval<T>() == std::declval<T>()), bool>::value>::type>\n+    : std::true_type {};\n+\n+template <bool C, typename T, typename E>\n+using conditional_t = typename std::conditional<C, T, E>::type;\n+\n+template <typename T>\n+struct type_constant {\n+  using type = T;\n+};\n+\n+template <typename...>\n+struct first;\n+\n+template <typename H, typename... T>\n+struct first<H, T...> {\n+  using type = H;\n+};\n+\n+template <typename T>\n+using decay_t = typename std::decay<T>::type;\n+\n+template <bool...>\n+struct all : std::true_type {};\n+\n+template <bool H, bool... T>\n+struct all<H, T...> : conditional_t<H, all<T...>, std::false_type> {};\n+\n+template <typename T>\n+void copy_construct(void* ptr, const void* other) {\n+  new (ptr) T(*static_cast<const T*>(other));\n+}\n+\n+template <typename T>\n+void move_construct(void* ptr, void* other) {\n+  new (ptr) T(std::move(*static_cast<T*>(other)));\n+}\n+\n+template <typename T>\n+void explicit_destroy(void* ptr) {\n+  static_cast<T*>(ptr)->~T();\n+}\n+\n+inline void trivial_destroy(void*) {}\n+\n+template <typename T>\n+bool equal(const void* l, const void* r) {\n+  return *static_cast<const T*>(l) == *static_cast<const T*>(r);\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<const T&>())) visit_const_ref(\n+    Visitor&& visitor, const void* ptr) {\n+  return std::forward<Visitor>(visitor)(*static_cast<const T*>(ptr));\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<T*>())) visit_mutable_ptr(\n+    Visitor&& visitor, void* ptr) {\n+  return std::forward<Visitor>(visitor)(static_cast<T*>(ptr));\n+}\n+\n+template <typename... T>\n+struct variant_storage {\n+  variant_storage() = default;\n+  variant_storage(const variant_storage&) {}\n+  variant_storage& operator=(const variant_storage&) { return *this; }\n+  variant_storage(variant_storage&&) {}\n+  variant_storage& operator=(variant_storage&&) { return *this; }\n+  ~variant_storage() {\n+    static_assert(offsetof(variant_storage, data_) == 0,\n+                  \"(void*)&variant_storage::data_ == (void*)this\");\n+  }\n+\n+  typename std::aligned_union<0, T...>::type data_;\n+  uint8_t index_ = 0;\n+};\n+\n+struct delete_copy_constructor {\n+  template <typename>\n+  struct type {\n+    type() = default;\n+    type(const type& other) = delete;\n+    type& operator=(const type& other) = delete;\n+  };\n+};\n+\n+struct explicit_copy_constructor {\n+  template <typename Copyable>\n+  struct type {\n+    type() = default;\n+    type(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/false);\n+    }\n+    type& operator=(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/true);\n+      return *this;\n+    }\n+  };\n+};\n+\n+template <typename V, uint8_t I, typename...>\n+struct member_constructor {\n+  static void index_of() {}\n+};\n+\n+template <typename V, uint8_t I, typename H, typename... T>\n+struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\n+  member_constructor() = default;\n+\n+  using member_constructor<V, I + 1, T...>::member_constructor;\n+  using member_constructor<V, I + 1, T...>::operator=;\n+  using member_constructor<V, I + 1, T...>::index_of;\n+\n+  explicit member_constructor(H value) {\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+  }\n+\n+  member_constructor& operator=(H value) {\n+    static_cast<V*>(this)->destroy();\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+    return *this;\n+  }\n+\n+  static constexpr std::integral_constant<uint8_t, I> index_of(const type_constant<H>&) {\n+    return {};\n+  }\n+};\n+\n+}  // namespace detail\n+\n+template <typename... T>\n+class Variant : detail::variant_storage<T...>,\n+                detail::conditional_t<\n+                    detail::all<(std::is_copy_constructible<T>::value &&\n+                                 std::is_copy_assignable<T>::value)...>::value,\n+                    detail::explicit_copy_constructor,\n+                    detail::delete_copy_constructor>::template type<Variant<T...>>,\n+                detail::member_constructor<Variant<T...>, 0, T...> {\n+  static_assert(detail::all<(std::is_nothrow_move_constructible<T>::value &&\n+                             std::is_nothrow_move_assignable<T>::value)...>::value,\n+                \"valueless_by_exception is not supported\");\n+\n+  template <typename U>\n+  static constexpr uint8_t index_of() {\n+    return detail::member_constructor<Variant<T...>, 0, T...>::index_of(\n+        detail::type_constant<U>{});\n+  }\n+\n+ public:\n+  using default_type = typename util::detail::first<T...>::type;\n+  static_assert(std::is_nothrow_default_constructible<default_type>::value,\n+                \"valueless_by_exception, non-default constructible are not supported\");\n+\n+  Variant() noexcept { construct_default(); }\n+\n+  Variant(const Variant& other) = default;\n+  Variant& operator=(const Variant& other) = default;\n+\n+  using detail::member_constructor<Variant<T...>, 0, T...>::member_constructor;\n+  using detail::member_constructor<Variant<T...>, 0, T...>::operator=;\n+\n+  Variant(Variant&& other) noexcept { move(&other, /*assignment=*/false); }\n+\n+  Variant& operator=(Variant&& other) noexcept {\n+    move(&other, /*assignment=*/true);\n+    return *this;\n+  }\n+\n+  ~Variant() {\n+    static_assert(offsetof(Variant, data_) == 0, \"(void*)&Variant::data_ == (void*)this\");\n+    this->destroy();\n+  }\n+\n+  uint8_t index() const noexcept { return this->index_; }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  const U* get() const noexcept {\n+    return index() == I ? reinterpret_cast<const U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  U* get() noexcept {\n+    return index() == I ? reinterpret_cast<U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, typename... A, uint8_t I = index_of<U>()>\n+  void emplace(A&&... args) try {\n+    this->destroy();\n+    new (this) U(std::forward<A>(args)...);\n+    this->index_ = I;\n+  } catch (...) {\n+    construct_default();\n+    throw;\n+  }\n+\n+  void swap(Variant& other) noexcept {  // NOLINT google-runtime-references\n+    Variant tmp = std::move(other);\n+    other = std::move(*this);\n+    *this = std::move(tmp);\n+  }\n+\n+ private:\n+  void move(Variant* other, bool assignment) noexcept {\n+    using impl_t = void(void*, void*);\n+    static std::array<impl_t*, sizeof...(T)> impl = {detail::move_construct<T>...};\n+\n+    if (assignment) {\n+      this->destroy();\n+    }\n+\n+    auto index = other->index_;\n+    impl[index](this, other);\n\nReview comment:\n       I wouldn't call that succeed. `print_using_table` uses an indirect jump while `print_using_switch` does inline comparisons. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-15T19:07:27.297+0000",
                    "updated": "2020-10-15T19:07:27.297+0000",
                    "started": "2020-10-15T19:07:27.297+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501245",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501247",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#discussion_r505778397\n\n\n\n##########\nFile path: cpp/src/arrow/util/variant.h\n##########\n@@ -17,17 +17,363 @@\n \n #pragma once\n \n-#include \"arrow/vendored/variant.hpp\"  // IWYU pragma: export\n+#include <array>\n+#include <cstddef>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"arrow/util/macros.h\"\n \n namespace arrow {\n namespace util {\n \n-using ::mpark::bad_variant_access;\n-using ::mpark::get;\n-using ::mpark::get_if;\n-using ::mpark::holds_alternative;\n-using ::mpark::variant;\n-using ::mpark::visit;\n+/// \\brief a std::variant-like discriminated union\n+///\n+/// Simplifications from std::variant:\n+///\n+/// - Strictly defaultable. The first type of T... must be nothrow default constructible\n+///   and it will be used for default Variants.\n+///\n+/// - Never valueless_by_exception. std::variant supports a state outside those specified\n+///   by T... to which it can return in the event that a constructor throws. If a Variant\n+///   would become valueless_by_exception it will instead return to its default state.\n+///\n+/// - Strictly nothrow move constructible and assignable, which is also required of each\n+///   of T...\n+///\n+/// - Less sophisticated type deduction. std::variant<bool, std::string>(\"hello\") will\n+///   intelligently construct std::string while Variant will construct bool.\n+///\n+/// - Either both copy constructible and assignable or neither (std::variant independently\n+///   enables copy construction and copy assignment). Variant is copy constructible if\n+///   each of T... is copy constructible and assignable.\n+///\n+/// - Slimmer interface; several members of std::variant are omitted.\n+///\n+/// - Throws no exceptions; if a bad_variant_access would be thrown Variant will instead\n+///   segfault (nullptr dereference).\n+///\n+/// - Mutable visit takes a pointer instead of mutable reference or rvalue reference,\n+///   which is more conformant with our code style.\n+template <typename... T>\n+class Variant;\n+\n+namespace detail {\n+\n+template <typename T, typename = void>\n+struct is_equality_comparable : std::false_type {};\n+\n+template <typename T>\n+struct is_equality_comparable<\n+    T, typename std::enable_if<std::is_convertible<\n+           decltype(std::declval<T>() == std::declval<T>()), bool>::value>::type>\n+    : std::true_type {};\n+\n+template <bool C, typename T, typename E>\n+using conditional_t = typename std::conditional<C, T, E>::type;\n+\n+template <typename T>\n+struct type_constant {\n+  using type = T;\n+};\n+\n+template <typename...>\n+struct first;\n+\n+template <typename H, typename... T>\n+struct first<H, T...> {\n+  using type = H;\n+};\n+\n+template <typename T>\n+using decay_t = typename std::decay<T>::type;\n+\n+template <bool...>\n+struct all : std::true_type {};\n+\n+template <bool H, bool... T>\n+struct all<H, T...> : conditional_t<H, all<T...>, std::false_type> {};\n+\n+template <typename T>\n+void copy_construct(void* ptr, const void* other) {\n+  new (ptr) T(*static_cast<const T*>(other));\n+}\n+\n+template <typename T>\n+void move_construct(void* ptr, void* other) {\n+  new (ptr) T(std::move(*static_cast<T*>(other)));\n+}\n+\n+template <typename T>\n+void explicit_destroy(void* ptr) {\n+  static_cast<T*>(ptr)->~T();\n+}\n+\n+inline void trivial_destroy(void*) {}\n+\n+template <typename T>\n+bool equal(const void* l, const void* r) {\n+  return *static_cast<const T*>(l) == *static_cast<const T*>(r);\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<const T&>())) visit_const_ref(\n+    Visitor&& visitor, const void* ptr) {\n+  return std::forward<Visitor>(visitor)(*static_cast<const T*>(ptr));\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<T*>())) visit_mutable_ptr(\n+    Visitor&& visitor, void* ptr) {\n+  return std::forward<Visitor>(visitor)(static_cast<T*>(ptr));\n+}\n+\n+template <typename... T>\n+struct variant_storage {\n+  variant_storage() = default;\n+  variant_storage(const variant_storage&) {}\n+  variant_storage& operator=(const variant_storage&) { return *this; }\n+  variant_storage(variant_storage&&) {}\n+  variant_storage& operator=(variant_storage&&) { return *this; }\n+  ~variant_storage() {\n+    static_assert(offsetof(variant_storage, data_) == 0,\n+                  \"(void*)&variant_storage::data_ == (void*)this\");\n+  }\n+\n+  typename std::aligned_union<0, T...>::type data_;\n+  uint8_t index_ = 0;\n+};\n+\n+struct delete_copy_constructor {\n+  template <typename>\n+  struct type {\n+    type() = default;\n+    type(const type& other) = delete;\n+    type& operator=(const type& other) = delete;\n+  };\n+};\n+\n+struct explicit_copy_constructor {\n+  template <typename Copyable>\n+  struct type {\n+    type() = default;\n+    type(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/false);\n+    }\n+    type& operator=(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/true);\n+      return *this;\n+    }\n+  };\n+};\n+\n+template <typename V, uint8_t I, typename...>\n+struct member_constructor {\n+  static void index_of() {}\n+};\n+\n+template <typename V, uint8_t I, typename H, typename... T>\n+struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\n+  member_constructor() = default;\n+\n+  using member_constructor<V, I + 1, T...>::member_constructor;\n+  using member_constructor<V, I + 1, T...>::operator=;\n+  using member_constructor<V, I + 1, T...>::index_of;\n+\n+  explicit member_constructor(H value) {\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+  }\n+\n+  member_constructor& operator=(H value) {\n+    static_cast<V*>(this)->destroy();\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+    return *this;\n+  }\n+\n+  static constexpr std::integral_constant<uint8_t, I> index_of(const type_constant<H>&) {\n+    return {};\n+  }\n+};\n+\n+}  // namespace detail\n+\n+template <typename... T>\n+class Variant : detail::variant_storage<T...>,\n+                detail::conditional_t<\n+                    detail::all<(std::is_copy_constructible<T>::value &&\n+                                 std::is_copy_assignable<T>::value)...>::value,\n+                    detail::explicit_copy_constructor,\n+                    detail::delete_copy_constructor>::template type<Variant<T...>>,\n+                detail::member_constructor<Variant<T...>, 0, T...> {\n+  static_assert(detail::all<(std::is_nothrow_move_constructible<T>::value &&\n+                             std::is_nothrow_move_assignable<T>::value)...>::value,\n+                \"valueless_by_exception is not supported\");\n+\n+  template <typename U>\n+  static constexpr uint8_t index_of() {\n+    return detail::member_constructor<Variant<T...>, 0, T...>::index_of(\n+        detail::type_constant<U>{});\n+  }\n+\n+ public:\n+  using default_type = typename util::detail::first<T...>::type;\n+  static_assert(std::is_nothrow_default_constructible<default_type>::value,\n+                \"valueless_by_exception, non-default constructible are not supported\");\n+\n+  Variant() noexcept { construct_default(); }\n+\n+  Variant(const Variant& other) = default;\n+  Variant& operator=(const Variant& other) = default;\n+\n+  using detail::member_constructor<Variant<T...>, 0, T...>::member_constructor;\n+  using detail::member_constructor<Variant<T...>, 0, T...>::operator=;\n+\n+  Variant(Variant&& other) noexcept { move(&other, /*assignment=*/false); }\n+\n+  Variant& operator=(Variant&& other) noexcept {\n+    move(&other, /*assignment=*/true);\n+    return *this;\n+  }\n+\n+  ~Variant() {\n+    static_assert(offsetof(Variant, data_) == 0, \"(void*)&Variant::data_ == (void*)this\");\n+    this->destroy();\n+  }\n+\n+  uint8_t index() const noexcept { return this->index_; }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  const U* get() const noexcept {\n+    return index() == I ? reinterpret_cast<const U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  U* get() noexcept {\n+    return index() == I ? reinterpret_cast<U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, typename... A, uint8_t I = index_of<U>()>\n+  void emplace(A&&... args) try {\n+    this->destroy();\n+    new (this) U(std::forward<A>(args)...);\n+    this->index_ = I;\n+  } catch (...) {\n+    construct_default();\n+    throw;\n+  }\n+\n+  void swap(Variant& other) noexcept {  // NOLINT google-runtime-references\n+    Variant tmp = std::move(other);\n+    other = std::move(*this);\n+    *this = std::move(tmp);\n+  }\n+\n+ private:\n+  void move(Variant* other, bool assignment) noexcept {\n+    using impl_t = void(void*, void*);\n+    static std::array<impl_t*, sizeof...(T)> impl = {detail::move_construct<T>...};\n+\n+    if (assignment) {\n+      this->destroy();\n+    }\n+\n+    auto index = other->index_;\n+    impl[index](this, other);\n\nReview comment:\n       You could do something like:\r\n   ```c++\r\n   template <typename V, uint8_t I, typename H, typename... T>\r\n   struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\r\n   // ...\r\n   void move_to(uint8_t index, Variant* target) {\r\n     if (index == I) {\r\n       detail::move_construct(target, this);\r\n     } else {\r\n       member_constructor<V, I + 1, T...>::move_to(index, target);\r\n     }\r\n   }\r\n   ```\r\n   \r\n   ```\r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-15T19:11:15.725+0000",
                    "updated": "2020-10-15T19:11:15.725+0000",
                    "started": "2020-10-15T19:11:15.724+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501247",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501248",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#discussion_r505778397\n\n\n\n##########\nFile path: cpp/src/arrow/util/variant.h\n##########\n@@ -17,17 +17,363 @@\n \n #pragma once\n \n-#include \"arrow/vendored/variant.hpp\"  // IWYU pragma: export\n+#include <array>\n+#include <cstddef>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"arrow/util/macros.h\"\n \n namespace arrow {\n namespace util {\n \n-using ::mpark::bad_variant_access;\n-using ::mpark::get;\n-using ::mpark::get_if;\n-using ::mpark::holds_alternative;\n-using ::mpark::variant;\n-using ::mpark::visit;\n+/// \\brief a std::variant-like discriminated union\n+///\n+/// Simplifications from std::variant:\n+///\n+/// - Strictly defaultable. The first type of T... must be nothrow default constructible\n+///   and it will be used for default Variants.\n+///\n+/// - Never valueless_by_exception. std::variant supports a state outside those specified\n+///   by T... to which it can return in the event that a constructor throws. If a Variant\n+///   would become valueless_by_exception it will instead return to its default state.\n+///\n+/// - Strictly nothrow move constructible and assignable, which is also required of each\n+///   of T...\n+///\n+/// - Less sophisticated type deduction. std::variant<bool, std::string>(\"hello\") will\n+///   intelligently construct std::string while Variant will construct bool.\n+///\n+/// - Either both copy constructible and assignable or neither (std::variant independently\n+///   enables copy construction and copy assignment). Variant is copy constructible if\n+///   each of T... is copy constructible and assignable.\n+///\n+/// - Slimmer interface; several members of std::variant are omitted.\n+///\n+/// - Throws no exceptions; if a bad_variant_access would be thrown Variant will instead\n+///   segfault (nullptr dereference).\n+///\n+/// - Mutable visit takes a pointer instead of mutable reference or rvalue reference,\n+///   which is more conformant with our code style.\n+template <typename... T>\n+class Variant;\n+\n+namespace detail {\n+\n+template <typename T, typename = void>\n+struct is_equality_comparable : std::false_type {};\n+\n+template <typename T>\n+struct is_equality_comparable<\n+    T, typename std::enable_if<std::is_convertible<\n+           decltype(std::declval<T>() == std::declval<T>()), bool>::value>::type>\n+    : std::true_type {};\n+\n+template <bool C, typename T, typename E>\n+using conditional_t = typename std::conditional<C, T, E>::type;\n+\n+template <typename T>\n+struct type_constant {\n+  using type = T;\n+};\n+\n+template <typename...>\n+struct first;\n+\n+template <typename H, typename... T>\n+struct first<H, T...> {\n+  using type = H;\n+};\n+\n+template <typename T>\n+using decay_t = typename std::decay<T>::type;\n+\n+template <bool...>\n+struct all : std::true_type {};\n+\n+template <bool H, bool... T>\n+struct all<H, T...> : conditional_t<H, all<T...>, std::false_type> {};\n+\n+template <typename T>\n+void copy_construct(void* ptr, const void* other) {\n+  new (ptr) T(*static_cast<const T*>(other));\n+}\n+\n+template <typename T>\n+void move_construct(void* ptr, void* other) {\n+  new (ptr) T(std::move(*static_cast<T*>(other)));\n+}\n+\n+template <typename T>\n+void explicit_destroy(void* ptr) {\n+  static_cast<T*>(ptr)->~T();\n+}\n+\n+inline void trivial_destroy(void*) {}\n+\n+template <typename T>\n+bool equal(const void* l, const void* r) {\n+  return *static_cast<const T*>(l) == *static_cast<const T*>(r);\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<const T&>())) visit_const_ref(\n+    Visitor&& visitor, const void* ptr) {\n+  return std::forward<Visitor>(visitor)(*static_cast<const T*>(ptr));\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<T*>())) visit_mutable_ptr(\n+    Visitor&& visitor, void* ptr) {\n+  return std::forward<Visitor>(visitor)(static_cast<T*>(ptr));\n+}\n+\n+template <typename... T>\n+struct variant_storage {\n+  variant_storage() = default;\n+  variant_storage(const variant_storage&) {}\n+  variant_storage& operator=(const variant_storage&) { return *this; }\n+  variant_storage(variant_storage&&) {}\n+  variant_storage& operator=(variant_storage&&) { return *this; }\n+  ~variant_storage() {\n+    static_assert(offsetof(variant_storage, data_) == 0,\n+                  \"(void*)&variant_storage::data_ == (void*)this\");\n+  }\n+\n+  typename std::aligned_union<0, T...>::type data_;\n+  uint8_t index_ = 0;\n+};\n+\n+struct delete_copy_constructor {\n+  template <typename>\n+  struct type {\n+    type() = default;\n+    type(const type& other) = delete;\n+    type& operator=(const type& other) = delete;\n+  };\n+};\n+\n+struct explicit_copy_constructor {\n+  template <typename Copyable>\n+  struct type {\n+    type() = default;\n+    type(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/false);\n+    }\n+    type& operator=(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/true);\n+      return *this;\n+    }\n+  };\n+};\n+\n+template <typename V, uint8_t I, typename...>\n+struct member_constructor {\n+  static void index_of() {}\n+};\n+\n+template <typename V, uint8_t I, typename H, typename... T>\n+struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\n+  member_constructor() = default;\n+\n+  using member_constructor<V, I + 1, T...>::member_constructor;\n+  using member_constructor<V, I + 1, T...>::operator=;\n+  using member_constructor<V, I + 1, T...>::index_of;\n+\n+  explicit member_constructor(H value) {\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+  }\n+\n+  member_constructor& operator=(H value) {\n+    static_cast<V*>(this)->destroy();\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+    return *this;\n+  }\n+\n+  static constexpr std::integral_constant<uint8_t, I> index_of(const type_constant<H>&) {\n+    return {};\n+  }\n+};\n+\n+}  // namespace detail\n+\n+template <typename... T>\n+class Variant : detail::variant_storage<T...>,\n+                detail::conditional_t<\n+                    detail::all<(std::is_copy_constructible<T>::value &&\n+                                 std::is_copy_assignable<T>::value)...>::value,\n+                    detail::explicit_copy_constructor,\n+                    detail::delete_copy_constructor>::template type<Variant<T...>>,\n+                detail::member_constructor<Variant<T...>, 0, T...> {\n+  static_assert(detail::all<(std::is_nothrow_move_constructible<T>::value &&\n+                             std::is_nothrow_move_assignable<T>::value)...>::value,\n+                \"valueless_by_exception is not supported\");\n+\n+  template <typename U>\n+  static constexpr uint8_t index_of() {\n+    return detail::member_constructor<Variant<T...>, 0, T...>::index_of(\n+        detail::type_constant<U>{});\n+  }\n+\n+ public:\n+  using default_type = typename util::detail::first<T...>::type;\n+  static_assert(std::is_nothrow_default_constructible<default_type>::value,\n+                \"valueless_by_exception, non-default constructible are not supported\");\n+\n+  Variant() noexcept { construct_default(); }\n+\n+  Variant(const Variant& other) = default;\n+  Variant& operator=(const Variant& other) = default;\n+\n+  using detail::member_constructor<Variant<T...>, 0, T...>::member_constructor;\n+  using detail::member_constructor<Variant<T...>, 0, T...>::operator=;\n+\n+  Variant(Variant&& other) noexcept { move(&other, /*assignment=*/false); }\n+\n+  Variant& operator=(Variant&& other) noexcept {\n+    move(&other, /*assignment=*/true);\n+    return *this;\n+  }\n+\n+  ~Variant() {\n+    static_assert(offsetof(Variant, data_) == 0, \"(void*)&Variant::data_ == (void*)this\");\n+    this->destroy();\n+  }\n+\n+  uint8_t index() const noexcept { return this->index_; }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  const U* get() const noexcept {\n+    return index() == I ? reinterpret_cast<const U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  U* get() noexcept {\n+    return index() == I ? reinterpret_cast<U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, typename... A, uint8_t I = index_of<U>()>\n+  void emplace(A&&... args) try {\n+    this->destroy();\n+    new (this) U(std::forward<A>(args)...);\n+    this->index_ = I;\n+  } catch (...) {\n+    construct_default();\n+    throw;\n+  }\n+\n+  void swap(Variant& other) noexcept {  // NOLINT google-runtime-references\n+    Variant tmp = std::move(other);\n+    other = std::move(*this);\n+    *this = std::move(tmp);\n+  }\n+\n+ private:\n+  void move(Variant* other, bool assignment) noexcept {\n+    using impl_t = void(void*, void*);\n+    static std::array<impl_t*, sizeof...(T)> impl = {detail::move_construct<T>...};\n+\n+    if (assignment) {\n+      this->destroy();\n+    }\n+\n+    auto index = other->index_;\n+    impl[index](this, other);\n\nReview comment:\n       You could do something like:\r\n   ```c++\r\n   template <typename V, uint8_t I, typename H, typename... T>\r\n   struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\r\n     // ...\r\n     void move_to(uint8_t index, Variant* target) {\r\n       if (index == I) {\r\n         detail::move_construct(target, this);\r\n       } else {\r\n         member_constructor<V, I + 1, T...>::move_to(index, target);\r\n       }\r\n     }\r\n   ```\r\n   \r\n   ```\r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-15T19:12:00.296+0000",
                    "updated": "2020-10-15T19:12:00.296+0000",
                    "started": "2020-10-15T19:12:00.296+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501248",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501249",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#discussion_r505778397\n\n\n\n##########\nFile path: cpp/src/arrow/util/variant.h\n##########\n@@ -17,17 +17,363 @@\n \n #pragma once\n \n-#include \"arrow/vendored/variant.hpp\"  // IWYU pragma: export\n+#include <array>\n+#include <cstddef>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"arrow/util/macros.h\"\n \n namespace arrow {\n namespace util {\n \n-using ::mpark::bad_variant_access;\n-using ::mpark::get;\n-using ::mpark::get_if;\n-using ::mpark::holds_alternative;\n-using ::mpark::variant;\n-using ::mpark::visit;\n+/// \\brief a std::variant-like discriminated union\n+///\n+/// Simplifications from std::variant:\n+///\n+/// - Strictly defaultable. The first type of T... must be nothrow default constructible\n+///   and it will be used for default Variants.\n+///\n+/// - Never valueless_by_exception. std::variant supports a state outside those specified\n+///   by T... to which it can return in the event that a constructor throws. If a Variant\n+///   would become valueless_by_exception it will instead return to its default state.\n+///\n+/// - Strictly nothrow move constructible and assignable, which is also required of each\n+///   of T...\n+///\n+/// - Less sophisticated type deduction. std::variant<bool, std::string>(\"hello\") will\n+///   intelligently construct std::string while Variant will construct bool.\n+///\n+/// - Either both copy constructible and assignable or neither (std::variant independently\n+///   enables copy construction and copy assignment). Variant is copy constructible if\n+///   each of T... is copy constructible and assignable.\n+///\n+/// - Slimmer interface; several members of std::variant are omitted.\n+///\n+/// - Throws no exceptions; if a bad_variant_access would be thrown Variant will instead\n+///   segfault (nullptr dereference).\n+///\n+/// - Mutable visit takes a pointer instead of mutable reference or rvalue reference,\n+///   which is more conformant with our code style.\n+template <typename... T>\n+class Variant;\n+\n+namespace detail {\n+\n+template <typename T, typename = void>\n+struct is_equality_comparable : std::false_type {};\n+\n+template <typename T>\n+struct is_equality_comparable<\n+    T, typename std::enable_if<std::is_convertible<\n+           decltype(std::declval<T>() == std::declval<T>()), bool>::value>::type>\n+    : std::true_type {};\n+\n+template <bool C, typename T, typename E>\n+using conditional_t = typename std::conditional<C, T, E>::type;\n+\n+template <typename T>\n+struct type_constant {\n+  using type = T;\n+};\n+\n+template <typename...>\n+struct first;\n+\n+template <typename H, typename... T>\n+struct first<H, T...> {\n+  using type = H;\n+};\n+\n+template <typename T>\n+using decay_t = typename std::decay<T>::type;\n+\n+template <bool...>\n+struct all : std::true_type {};\n+\n+template <bool H, bool... T>\n+struct all<H, T...> : conditional_t<H, all<T...>, std::false_type> {};\n+\n+template <typename T>\n+void copy_construct(void* ptr, const void* other) {\n+  new (ptr) T(*static_cast<const T*>(other));\n+}\n+\n+template <typename T>\n+void move_construct(void* ptr, void* other) {\n+  new (ptr) T(std::move(*static_cast<T*>(other)));\n+}\n+\n+template <typename T>\n+void explicit_destroy(void* ptr) {\n+  static_cast<T*>(ptr)->~T();\n+}\n+\n+inline void trivial_destroy(void*) {}\n+\n+template <typename T>\n+bool equal(const void* l, const void* r) {\n+  return *static_cast<const T*>(l) == *static_cast<const T*>(r);\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<const T&>())) visit_const_ref(\n+    Visitor&& visitor, const void* ptr) {\n+  return std::forward<Visitor>(visitor)(*static_cast<const T*>(ptr));\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<T*>())) visit_mutable_ptr(\n+    Visitor&& visitor, void* ptr) {\n+  return std::forward<Visitor>(visitor)(static_cast<T*>(ptr));\n+}\n+\n+template <typename... T>\n+struct variant_storage {\n+  variant_storage() = default;\n+  variant_storage(const variant_storage&) {}\n+  variant_storage& operator=(const variant_storage&) { return *this; }\n+  variant_storage(variant_storage&&) {}\n+  variant_storage& operator=(variant_storage&&) { return *this; }\n+  ~variant_storage() {\n+    static_assert(offsetof(variant_storage, data_) == 0,\n+                  \"(void*)&variant_storage::data_ == (void*)this\");\n+  }\n+\n+  typename std::aligned_union<0, T...>::type data_;\n+  uint8_t index_ = 0;\n+};\n+\n+struct delete_copy_constructor {\n+  template <typename>\n+  struct type {\n+    type() = default;\n+    type(const type& other) = delete;\n+    type& operator=(const type& other) = delete;\n+  };\n+};\n+\n+struct explicit_copy_constructor {\n+  template <typename Copyable>\n+  struct type {\n+    type() = default;\n+    type(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/false);\n+    }\n+    type& operator=(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/true);\n+      return *this;\n+    }\n+  };\n+};\n+\n+template <typename V, uint8_t I, typename...>\n+struct member_constructor {\n+  static void index_of() {}\n+};\n+\n+template <typename V, uint8_t I, typename H, typename... T>\n+struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\n+  member_constructor() = default;\n+\n+  using member_constructor<V, I + 1, T...>::member_constructor;\n+  using member_constructor<V, I + 1, T...>::operator=;\n+  using member_constructor<V, I + 1, T...>::index_of;\n+\n+  explicit member_constructor(H value) {\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+  }\n+\n+  member_constructor& operator=(H value) {\n+    static_cast<V*>(this)->destroy();\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+    return *this;\n+  }\n+\n+  static constexpr std::integral_constant<uint8_t, I> index_of(const type_constant<H>&) {\n+    return {};\n+  }\n+};\n+\n+}  // namespace detail\n+\n+template <typename... T>\n+class Variant : detail::variant_storage<T...>,\n+                detail::conditional_t<\n+                    detail::all<(std::is_copy_constructible<T>::value &&\n+                                 std::is_copy_assignable<T>::value)...>::value,\n+                    detail::explicit_copy_constructor,\n+                    detail::delete_copy_constructor>::template type<Variant<T...>>,\n+                detail::member_constructor<Variant<T...>, 0, T...> {\n+  static_assert(detail::all<(std::is_nothrow_move_constructible<T>::value &&\n+                             std::is_nothrow_move_assignable<T>::value)...>::value,\n+                \"valueless_by_exception is not supported\");\n+\n+  template <typename U>\n+  static constexpr uint8_t index_of() {\n+    return detail::member_constructor<Variant<T...>, 0, T...>::index_of(\n+        detail::type_constant<U>{});\n+  }\n+\n+ public:\n+  using default_type = typename util::detail::first<T...>::type;\n+  static_assert(std::is_nothrow_default_constructible<default_type>::value,\n+                \"valueless_by_exception, non-default constructible are not supported\");\n+\n+  Variant() noexcept { construct_default(); }\n+\n+  Variant(const Variant& other) = default;\n+  Variant& operator=(const Variant& other) = default;\n+\n+  using detail::member_constructor<Variant<T...>, 0, T...>::member_constructor;\n+  using detail::member_constructor<Variant<T...>, 0, T...>::operator=;\n+\n+  Variant(Variant&& other) noexcept { move(&other, /*assignment=*/false); }\n+\n+  Variant& operator=(Variant&& other) noexcept {\n+    move(&other, /*assignment=*/true);\n+    return *this;\n+  }\n+\n+  ~Variant() {\n+    static_assert(offsetof(Variant, data_) == 0, \"(void*)&Variant::data_ == (void*)this\");\n+    this->destroy();\n+  }\n+\n+  uint8_t index() const noexcept { return this->index_; }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  const U* get() const noexcept {\n+    return index() == I ? reinterpret_cast<const U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  U* get() noexcept {\n+    return index() == I ? reinterpret_cast<U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, typename... A, uint8_t I = index_of<U>()>\n+  void emplace(A&&... args) try {\n+    this->destroy();\n+    new (this) U(std::forward<A>(args)...);\n+    this->index_ = I;\n+  } catch (...) {\n+    construct_default();\n+    throw;\n+  }\n+\n+  void swap(Variant& other) noexcept {  // NOLINT google-runtime-references\n+    Variant tmp = std::move(other);\n+    other = std::move(*this);\n+    *this = std::move(tmp);\n+  }\n+\n+ private:\n+  void move(Variant* other, bool assignment) noexcept {\n+    using impl_t = void(void*, void*);\n+    static std::array<impl_t*, sizeof...(T)> impl = {detail::move_construct<T>...};\n+\n+    if (assignment) {\n+      this->destroy();\n+    }\n+\n+    auto index = other->index_;\n+    impl[index](this, other);\n\nReview comment:\n       You could do something like:\r\n   ```c++\r\n   template <typename V, uint8_t I, typename H, typename... T>\r\n   struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\r\n     // ...\r\n     void move_to(uint8_t index, Variant* target) {\r\n       if (index == I) {\r\n         detail::move_construct(target, this);\r\n       } else {\r\n         member_constructor<V, I + 1, T...>::move_to(index, target);\r\n       }\r\n     }\r\n   ```\r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-15T19:12:33.722+0000",
                    "updated": "2020-10-15T19:12:33.722+0000",
                    "started": "2020-10-15T19:12:33.722+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501249",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501259",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#discussion_r505794791\n\n\n\n##########\nFile path: cpp/src/arrow/util/variant.h\n##########\n@@ -17,17 +17,363 @@\n \n #pragma once\n \n-#include \"arrow/vendored/variant.hpp\"  // IWYU pragma: export\n+#include <array>\n+#include <cstddef>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"arrow/util/macros.h\"\n \n namespace arrow {\n namespace util {\n \n-using ::mpark::bad_variant_access;\n-using ::mpark::get;\n-using ::mpark::get_if;\n-using ::mpark::holds_alternative;\n-using ::mpark::variant;\n-using ::mpark::visit;\n+/// \\brief a std::variant-like discriminated union\n+///\n+/// Simplifications from std::variant:\n+///\n+/// - Strictly defaultable. The first type of T... must be nothrow default constructible\n+///   and it will be used for default Variants.\n+///\n+/// - Never valueless_by_exception. std::variant supports a state outside those specified\n+///   by T... to which it can return in the event that a constructor throws. If a Variant\n+///   would become valueless_by_exception it will instead return to its default state.\n+///\n+/// - Strictly nothrow move constructible and assignable, which is also required of each\n+///   of T...\n+///\n+/// - Less sophisticated type deduction. std::variant<bool, std::string>(\"hello\") will\n+///   intelligently construct std::string while Variant will construct bool.\n+///\n+/// - Either both copy constructible and assignable or neither (std::variant independently\n+///   enables copy construction and copy assignment). Variant is copy constructible if\n+///   each of T... is copy constructible and assignable.\n+///\n+/// - Slimmer interface; several members of std::variant are omitted.\n+///\n+/// - Throws no exceptions; if a bad_variant_access would be thrown Variant will instead\n+///   segfault (nullptr dereference).\n+///\n+/// - Mutable visit takes a pointer instead of mutable reference or rvalue reference,\n+///   which is more conformant with our code style.\n+template <typename... T>\n+class Variant;\n+\n+namespace detail {\n+\n+template <typename T, typename = void>\n+struct is_equality_comparable : std::false_type {};\n+\n+template <typename T>\n+struct is_equality_comparable<\n+    T, typename std::enable_if<std::is_convertible<\n+           decltype(std::declval<T>() == std::declval<T>()), bool>::value>::type>\n+    : std::true_type {};\n+\n+template <bool C, typename T, typename E>\n+using conditional_t = typename std::conditional<C, T, E>::type;\n+\n+template <typename T>\n+struct type_constant {\n+  using type = T;\n+};\n+\n+template <typename...>\n+struct first;\n+\n+template <typename H, typename... T>\n+struct first<H, T...> {\n+  using type = H;\n+};\n+\n+template <typename T>\n+using decay_t = typename std::decay<T>::type;\n+\n+template <bool...>\n+struct all : std::true_type {};\n+\n+template <bool H, bool... T>\n+struct all<H, T...> : conditional_t<H, all<T...>, std::false_type> {};\n+\n+template <typename T>\n+void copy_construct(void* ptr, const void* other) {\n+  new (ptr) T(*static_cast<const T*>(other));\n+}\n+\n+template <typename T>\n+void move_construct(void* ptr, void* other) {\n+  new (ptr) T(std::move(*static_cast<T*>(other)));\n+}\n+\n+template <typename T>\n+void explicit_destroy(void* ptr) {\n+  static_cast<T*>(ptr)->~T();\n+}\n+\n+inline void trivial_destroy(void*) {}\n+\n+template <typename T>\n+bool equal(const void* l, const void* r) {\n+  return *static_cast<const T*>(l) == *static_cast<const T*>(r);\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<const T&>())) visit_const_ref(\n+    Visitor&& visitor, const void* ptr) {\n+  return std::forward<Visitor>(visitor)(*static_cast<const T*>(ptr));\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<T*>())) visit_mutable_ptr(\n+    Visitor&& visitor, void* ptr) {\n+  return std::forward<Visitor>(visitor)(static_cast<T*>(ptr));\n+}\n+\n+template <typename... T>\n+struct variant_storage {\n+  variant_storage() = default;\n+  variant_storage(const variant_storage&) {}\n+  variant_storage& operator=(const variant_storage&) { return *this; }\n+  variant_storage(variant_storage&&) {}\n+  variant_storage& operator=(variant_storage&&) { return *this; }\n+  ~variant_storage() {\n+    static_assert(offsetof(variant_storage, data_) == 0,\n+                  \"(void*)&variant_storage::data_ == (void*)this\");\n+  }\n+\n+  typename std::aligned_union<0, T...>::type data_;\n+  uint8_t index_ = 0;\n+};\n+\n+struct delete_copy_constructor {\n+  template <typename>\n+  struct type {\n+    type() = default;\n+    type(const type& other) = delete;\n+    type& operator=(const type& other) = delete;\n+  };\n+};\n+\n+struct explicit_copy_constructor {\n+  template <typename Copyable>\n+  struct type {\n+    type() = default;\n+    type(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/false);\n+    }\n+    type& operator=(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/true);\n+      return *this;\n+    }\n+  };\n+};\n+\n+template <typename V, uint8_t I, typename...>\n+struct member_constructor {\n+  static void index_of() {}\n+};\n+\n+template <typename V, uint8_t I, typename H, typename... T>\n+struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\n+  member_constructor() = default;\n+\n+  using member_constructor<V, I + 1, T...>::member_constructor;\n+  using member_constructor<V, I + 1, T...>::operator=;\n+  using member_constructor<V, I + 1, T...>::index_of;\n+\n+  explicit member_constructor(H value) {\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+  }\n+\n+  member_constructor& operator=(H value) {\n+    static_cast<V*>(this)->destroy();\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+    return *this;\n+  }\n+\n+  static constexpr std::integral_constant<uint8_t, I> index_of(const type_constant<H>&) {\n+    return {};\n+  }\n+};\n+\n+}  // namespace detail\n+\n+template <typename... T>\n+class Variant : detail::variant_storage<T...>,\n+                detail::conditional_t<\n+                    detail::all<(std::is_copy_constructible<T>::value &&\n+                                 std::is_copy_assignable<T>::value)...>::value,\n+                    detail::explicit_copy_constructor,\n+                    detail::delete_copy_constructor>::template type<Variant<T...>>,\n+                detail::member_constructor<Variant<T...>, 0, T...> {\n+  static_assert(detail::all<(std::is_nothrow_move_constructible<T>::value &&\n+                             std::is_nothrow_move_assignable<T>::value)...>::value,\n+                \"valueless_by_exception is not supported\");\n+\n+  template <typename U>\n+  static constexpr uint8_t index_of() {\n+    return detail::member_constructor<Variant<T...>, 0, T...>::index_of(\n+        detail::type_constant<U>{});\n+  }\n+\n+ public:\n+  using default_type = typename util::detail::first<T...>::type;\n+  static_assert(std::is_nothrow_default_constructible<default_type>::value,\n+                \"valueless_by_exception, non-default constructible are not supported\");\n+\n+  Variant() noexcept { construct_default(); }\n+\n+  Variant(const Variant& other) = default;\n+  Variant& operator=(const Variant& other) = default;\n+\n+  using detail::member_constructor<Variant<T...>, 0, T...>::member_constructor;\n+  using detail::member_constructor<Variant<T...>, 0, T...>::operator=;\n+\n+  Variant(Variant&& other) noexcept { move(&other, /*assignment=*/false); }\n+\n+  Variant& operator=(Variant&& other) noexcept {\n+    move(&other, /*assignment=*/true);\n+    return *this;\n+  }\n+\n+  ~Variant() {\n+    static_assert(offsetof(Variant, data_) == 0, \"(void*)&Variant::data_ == (void*)this\");\n+    this->destroy();\n+  }\n+\n+  uint8_t index() const noexcept { return this->index_; }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  const U* get() const noexcept {\n+    return index() == I ? reinterpret_cast<const U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  U* get() noexcept {\n+    return index() == I ? reinterpret_cast<U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, typename... A, uint8_t I = index_of<U>()>\n+  void emplace(A&&... args) try {\n+    this->destroy();\n+    new (this) U(std::forward<A>(args)...);\n+    this->index_ = I;\n+  } catch (...) {\n+    construct_default();\n+    throw;\n+  }\n+\n+  void swap(Variant& other) noexcept {  // NOLINT google-runtime-references\n+    Variant tmp = std::move(other);\n+    other = std::move(*this);\n+    *this = std::move(tmp);\n+  }\n+\n+ private:\n+  void move(Variant* other, bool assignment) noexcept {\n+    using impl_t = void(void*, void*);\n+    static std::array<impl_t*, sizeof...(T)> impl = {detail::move_construct<T>...};\n+\n+    if (assignment) {\n+      this->destroy();\n+    }\n+\n+    auto index = other->index_;\n+    impl[index](this, other);\n\nReview comment:\n       https://godbolt.org/z/jM6Tzx\r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-15T19:42:00.725+0000",
                    "updated": "2020-10-15T19:42:00.725+0000",
                    "started": "2020-10-15T19:42:00.725+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501259",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501555",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#discussion_r506422416\n\n\n\n##########\nFile path: cpp/src/arrow/util/variant.h\n##########\n@@ -17,17 +17,363 @@\n \n #pragma once\n \n-#include \"arrow/vendored/variant.hpp\"  // IWYU pragma: export\n+#include <array>\n+#include <cstddef>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"arrow/util/macros.h\"\n \n namespace arrow {\n namespace util {\n \n-using ::mpark::bad_variant_access;\n-using ::mpark::get;\n-using ::mpark::get_if;\n-using ::mpark::holds_alternative;\n-using ::mpark::variant;\n-using ::mpark::visit;\n+/// \\brief a std::variant-like discriminated union\n+///\n+/// Simplifications from std::variant:\n+///\n+/// - Strictly defaultable. The first type of T... must be nothrow default constructible\n+///   and it will be used for default Variants.\n+///\n+/// - Never valueless_by_exception. std::variant supports a state outside those specified\n+///   by T... to which it can return in the event that a constructor throws. If a Variant\n+///   would become valueless_by_exception it will instead return to its default state.\n+///\n+/// - Strictly nothrow move constructible and assignable, which is also required of each\n+///   of T...\n+///\n+/// - Less sophisticated type deduction. std::variant<bool, std::string>(\"hello\") will\n+///   intelligently construct std::string while Variant will construct bool.\n+///\n+/// - Either both copy constructible and assignable or neither (std::variant independently\n+///   enables copy construction and copy assignment). Variant is copy constructible if\n+///   each of T... is copy constructible and assignable.\n+///\n+/// - Slimmer interface; several members of std::variant are omitted.\n+///\n+/// - Throws no exceptions; if a bad_variant_access would be thrown Variant will instead\n+///   segfault (nullptr dereference).\n+///\n+/// - Mutable visit takes a pointer instead of mutable reference or rvalue reference,\n+///   which is more conformant with our code style.\n+template <typename... T>\n+class Variant;\n+\n+namespace detail {\n+\n+template <typename T, typename = void>\n+struct is_equality_comparable : std::false_type {};\n+\n+template <typename T>\n+struct is_equality_comparable<\n+    T, typename std::enable_if<std::is_convertible<\n+           decltype(std::declval<T>() == std::declval<T>()), bool>::value>::type>\n+    : std::true_type {};\n+\n+template <bool C, typename T, typename E>\n+using conditional_t = typename std::conditional<C, T, E>::type;\n+\n+template <typename T>\n+struct type_constant {\n+  using type = T;\n+};\n+\n+template <typename...>\n+struct first;\n+\n+template <typename H, typename... T>\n+struct first<H, T...> {\n+  using type = H;\n+};\n+\n+template <typename T>\n+using decay_t = typename std::decay<T>::type;\n+\n+template <bool...>\n+struct all : std::true_type {};\n+\n+template <bool H, bool... T>\n+struct all<H, T...> : conditional_t<H, all<T...>, std::false_type> {};\n+\n+template <typename T>\n+void copy_construct(void* ptr, const void* other) {\n+  new (ptr) T(*static_cast<const T*>(other));\n+}\n+\n+template <typename T>\n+void move_construct(void* ptr, void* other) {\n+  new (ptr) T(std::move(*static_cast<T*>(other)));\n+}\n+\n+template <typename T>\n+void explicit_destroy(void* ptr) {\n+  static_cast<T*>(ptr)->~T();\n+}\n+\n+inline void trivial_destroy(void*) {}\n+\n+template <typename T>\n+bool equal(const void* l, const void* r) {\n+  return *static_cast<const T*>(l) == *static_cast<const T*>(r);\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<const T&>())) visit_const_ref(\n+    Visitor&& visitor, const void* ptr) {\n+  return std::forward<Visitor>(visitor)(*static_cast<const T*>(ptr));\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<T*>())) visit_mutable_ptr(\n+    Visitor&& visitor, void* ptr) {\n+  return std::forward<Visitor>(visitor)(static_cast<T*>(ptr));\n+}\n+\n+template <typename... T>\n+struct variant_storage {\n+  variant_storage() = default;\n+  variant_storage(const variant_storage&) {}\n+  variant_storage& operator=(const variant_storage&) { return *this; }\n+  variant_storage(variant_storage&&) {}\n+  variant_storage& operator=(variant_storage&&) { return *this; }\n+  ~variant_storage() {\n+    static_assert(offsetof(variant_storage, data_) == 0,\n+                  \"(void*)&variant_storage::data_ == (void*)this\");\n+  }\n+\n+  typename std::aligned_union<0, T...>::type data_;\n+  uint8_t index_ = 0;\n+};\n+\n+struct delete_copy_constructor {\n+  template <typename>\n+  struct type {\n+    type() = default;\n+    type(const type& other) = delete;\n+    type& operator=(const type& other) = delete;\n+  };\n+};\n+\n+struct explicit_copy_constructor {\n+  template <typename Copyable>\n+  struct type {\n+    type() = default;\n+    type(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/false);\n+    }\n+    type& operator=(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/true);\n+      return *this;\n+    }\n+  };\n+};\n+\n+template <typename V, uint8_t I, typename...>\n+struct member_constructor {\n+  static void index_of() {}\n+};\n+\n+template <typename V, uint8_t I, typename H, typename... T>\n+struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\n+  member_constructor() = default;\n+\n+  using member_constructor<V, I + 1, T...>::member_constructor;\n+  using member_constructor<V, I + 1, T...>::operator=;\n+  using member_constructor<V, I + 1, T...>::index_of;\n+\n+  explicit member_constructor(H value) {\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+  }\n+\n+  member_constructor& operator=(H value) {\n+    static_cast<V*>(this)->destroy();\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+    return *this;\n+  }\n+\n+  static constexpr std::integral_constant<uint8_t, I> index_of(const type_constant<H>&) {\n+    return {};\n+  }\n+};\n+\n+}  // namespace detail\n+\n+template <typename... T>\n+class Variant : detail::variant_storage<T...>,\n+                detail::conditional_t<\n+                    detail::all<(std::is_copy_constructible<T>::value &&\n+                                 std::is_copy_assignable<T>::value)...>::value,\n+                    detail::explicit_copy_constructor,\n+                    detail::delete_copy_constructor>::template type<Variant<T...>>,\n+                detail::member_constructor<Variant<T...>, 0, T...> {\n+  static_assert(detail::all<(std::is_nothrow_move_constructible<T>::value &&\n+                             std::is_nothrow_move_assignable<T>::value)...>::value,\n+                \"valueless_by_exception is not supported\");\n+\n+  template <typename U>\n+  static constexpr uint8_t index_of() {\n+    return detail::member_constructor<Variant<T...>, 0, T...>::index_of(\n+        detail::type_constant<U>{});\n+  }\n+\n+ public:\n+  using default_type = typename util::detail::first<T...>::type;\n+  static_assert(std::is_nothrow_default_constructible<default_type>::value,\n+                \"valueless_by_exception, non-default constructible are not supported\");\n+\n+  Variant() noexcept { construct_default(); }\n+\n+  Variant(const Variant& other) = default;\n+  Variant& operator=(const Variant& other) = default;\n+\n+  using detail::member_constructor<Variant<T...>, 0, T...>::member_constructor;\n+  using detail::member_constructor<Variant<T...>, 0, T...>::operator=;\n+\n+  Variant(Variant&& other) noexcept { move(&other, /*assignment=*/false); }\n+\n+  Variant& operator=(Variant&& other) noexcept {\n+    move(&other, /*assignment=*/true);\n+    return *this;\n+  }\n+\n+  ~Variant() {\n+    static_assert(offsetof(Variant, data_) == 0, \"(void*)&Variant::data_ == (void*)this\");\n+    this->destroy();\n+  }\n+\n+  uint8_t index() const noexcept { return this->index_; }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  const U* get() const noexcept {\n+    return index() == I ? reinterpret_cast<const U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, uint8_t I = index_of<U>()>\n+  U* get() noexcept {\n+    return index() == I ? reinterpret_cast<U*>(this) : NULLPTR;\n+  }\n+\n+  template <typename U, typename... A, uint8_t I = index_of<U>()>\n+  void emplace(A&&... args) try {\n+    this->destroy();\n+    new (this) U(std::forward<A>(args)...);\n+    this->index_ = I;\n+  } catch (...) {\n+    construct_default();\n+    throw;\n+  }\n+\n+  void swap(Variant& other) noexcept {  // NOLINT google-runtime-references\n+    Variant tmp = std::move(other);\n+    other = std::move(*this);\n+    *this = std::move(tmp);\n+  }\n+\n+ private:\n+  void move(Variant* other, bool assignment) noexcept {\n+    using impl_t = void(void*, void*);\n+    static std::array<impl_t*, sizeof...(T)> impl = {detail::move_construct<T>...};\n+\n+    if (assignment) {\n+      this->destroy();\n+    }\n+\n+    auto index = other->index_;\n+    impl[index](this, other);\n\nReview comment:\n       Will do, thanks\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-16T13:29:50.616+0000",
                    "updated": "2020-10-16T13:29:50.616+0000",
                    "started": "2020-10-16T13:29:50.616+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501555",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501573",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#discussion_r506498924\n\n\n\n##########\nFile path: cpp/src/arrow/util/variant.h\n##########\n@@ -17,17 +17,363 @@\n \n #pragma once\n \n-#include \"arrow/vendored/variant.hpp\"  // IWYU pragma: export\n+#include <array>\n+#include <cstddef>\n+#include <type_traits>\n+#include <utility>\n+\n+#include \"arrow/util/macros.h\"\n \n namespace arrow {\n namespace util {\n \n-using ::mpark::bad_variant_access;\n-using ::mpark::get;\n-using ::mpark::get_if;\n-using ::mpark::holds_alternative;\n-using ::mpark::variant;\n-using ::mpark::visit;\n+/// \\brief a std::variant-like discriminated union\n+///\n+/// Simplifications from std::variant:\n+///\n+/// - Strictly defaultable. The first type of T... must be nothrow default constructible\n+///   and it will be used for default Variants.\n+///\n+/// - Never valueless_by_exception. std::variant supports a state outside those specified\n+///   by T... to which it can return in the event that a constructor throws. If a Variant\n+///   would become valueless_by_exception it will instead return to its default state.\n+///\n+/// - Strictly nothrow move constructible and assignable, which is also required of each\n+///   of T...\n+///\n+/// - Less sophisticated type deduction. std::variant<bool, std::string>(\"hello\") will\n+///   intelligently construct std::string while Variant will construct bool.\n+///\n+/// - Either both copy constructible and assignable or neither (std::variant independently\n+///   enables copy construction and copy assignment). Variant is copy constructible if\n+///   each of T... is copy constructible and assignable.\n+///\n+/// - Slimmer interface; several members of std::variant are omitted.\n+///\n+/// - Throws no exceptions; if a bad_variant_access would be thrown Variant will instead\n+///   segfault (nullptr dereference).\n+///\n+/// - Mutable visit takes a pointer instead of mutable reference or rvalue reference,\n+///   which is more conformant with our code style.\n+template <typename... T>\n+class Variant;\n+\n+namespace detail {\n+\n+template <typename T, typename = void>\n+struct is_equality_comparable : std::false_type {};\n+\n+template <typename T>\n+struct is_equality_comparable<\n+    T, typename std::enable_if<std::is_convertible<\n+           decltype(std::declval<T>() == std::declval<T>()), bool>::value>::type>\n+    : std::true_type {};\n+\n+template <bool C, typename T, typename E>\n+using conditional_t = typename std::conditional<C, T, E>::type;\n+\n+template <typename T>\n+struct type_constant {\n+  using type = T;\n+};\n+\n+template <typename...>\n+struct first;\n+\n+template <typename H, typename... T>\n+struct first<H, T...> {\n+  using type = H;\n+};\n+\n+template <typename T>\n+using decay_t = typename std::decay<T>::type;\n+\n+template <bool...>\n+struct all : std::true_type {};\n+\n+template <bool H, bool... T>\n+struct all<H, T...> : conditional_t<H, all<T...>, std::false_type> {};\n+\n+template <typename T>\n+void copy_construct(void* ptr, const void* other) {\n+  new (ptr) T(*static_cast<const T*>(other));\n+}\n+\n+template <typename T>\n+void move_construct(void* ptr, void* other) {\n+  new (ptr) T(std::move(*static_cast<T*>(other)));\n+}\n+\n+template <typename T>\n+void explicit_destroy(void* ptr) {\n+  static_cast<T*>(ptr)->~T();\n+}\n+\n+inline void trivial_destroy(void*) {}\n+\n+template <typename T>\n+bool equal(const void* l, const void* r) {\n+  return *static_cast<const T*>(l) == *static_cast<const T*>(r);\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<const T&>())) visit_const_ref(\n+    Visitor&& visitor, const void* ptr) {\n+  return std::forward<Visitor>(visitor)(*static_cast<const T*>(ptr));\n+}\n+\n+template <typename Visitor, typename T>\n+decltype(std::declval<Visitor&&>()(std::declval<T*>())) visit_mutable_ptr(\n+    Visitor&& visitor, void* ptr) {\n+  return std::forward<Visitor>(visitor)(static_cast<T*>(ptr));\n+}\n+\n+template <typename... T>\n+struct variant_storage {\n+  variant_storage() = default;\n+  variant_storage(const variant_storage&) {}\n+  variant_storage& operator=(const variant_storage&) { return *this; }\n+  variant_storage(variant_storage&&) {}\n+  variant_storage& operator=(variant_storage&&) { return *this; }\n+  ~variant_storage() {\n+    static_assert(offsetof(variant_storage, data_) == 0,\n+                  \"(void*)&variant_storage::data_ == (void*)this\");\n+  }\n+\n+  typename std::aligned_union<0, T...>::type data_;\n+  uint8_t index_ = 0;\n+};\n+\n+struct delete_copy_constructor {\n+  template <typename>\n+  struct type {\n+    type() = default;\n+    type(const type& other) = delete;\n+    type& operator=(const type& other) = delete;\n+  };\n+};\n+\n+struct explicit_copy_constructor {\n+  template <typename Copyable>\n+  struct type {\n+    type() = default;\n+    type(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/false);\n+    }\n+    type& operator=(const type& other) {\n+      static_cast<Copyable*>(this)->copy(other, /*assignment=*/true);\n+      return *this;\n+    }\n+  };\n+};\n+\n+template <typename V, uint8_t I, typename...>\n+struct member_constructor {\n+  static void index_of() {}\n+};\n+\n+template <typename V, uint8_t I, typename H, typename... T>\n+struct member_constructor<V, I, H, T...> : member_constructor<V, I + 1, T...> {\n+  static_assert(std::is_nothrow_move_constructible<H>::value &&\n+                    std::is_nothrow_move_assignable<H>::value,\n+                \"All members must be nothrow move constructible and assignable.\");\n+\n+  member_constructor() = default;\n+\n+  using member_constructor<V, I + 1, T...>::member_constructor;\n+  using member_constructor<V, I + 1, T...>::operator=;\n+  using member_constructor<V, I + 1, T...>::index_of;\n+\n+  explicit member_constructor(H value) {\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+  }\n+\n+  member_constructor& operator=(H value) {\n+    static_cast<V*>(this)->destroy();\n+    new (this) H(std::move(value));\n+    static_cast<V*>(this)->index_ = I;\n+    return *this;\n+  }\n+\n+  static constexpr std::integral_constant<uint8_t, I> index_of(const type_constant<H>&) {\n+    return {};\n+  }\n+};\n+\n+}  // namespace detail\n+\n+template <typename... T>\n+class Variant : detail::variant_storage<T...>,\n+                detail::conditional_t<\n+                    detail::all<(std::is_copy_constructible<T>::value &&\n+                                 std::is_copy_assignable<T>::value)...>::value,\n+                    detail::explicit_copy_constructor,\n+                    detail::delete_copy_constructor>::template type<Variant<T...>>,\n\nReview comment:\n       We might want to borrow this idiom to disable copy construction for `Result<std::unique_ptr<T>>`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-16T14:42:41.837+0000",
                    "updated": "2020-10-16T14:42:41.837+0000",
                    "started": "2020-10-16T14:42:41.837+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501573",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/501857",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#issuecomment-711116750\n\n\n   drive by comment.  just want to make sure we aren't using the same idioms for variant (i.e. they are compatible with C++ std)?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-18T04:56:06.023+0000",
                    "updated": "2020-10-18T04:56:06.023+0000",
                    "started": "2020-10-18T04:56:06.023+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "501857",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/502281",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#issuecomment-712233535\n\n\n   @emkornfield I'm implementing a subset of `std::variant`'s functionality but all members which are present are compatible; if we switch to using `std::variant` at some point no code will break. We will need to keep the mutable-pointer visit overload since that's non standard, but IMHO that's acceptable overhead\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-19T15:11:13.792+0000",
                    "updated": "2020-10-19T15:11:13.792+0000",
                    "started": "2020-10-19T15:11:13.792+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "502281",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/502474",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#issuecomment-712563172\n\n\n   @bkietz presumably this yields smaller code size, too? \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-20T03:21:44.552+0000",
                    "updated": "2020-10-20T03:21:44.552+0000",
                    "started": "2020-10-20T03:21:44.552+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "502474",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/502752",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#issuecomment-712950634\n\n\n   Updated description with build times and code sizes for a release build\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-20T15:50:41.691+0000",
                    "updated": "2020-10-20T15:50:41.691+0000",
                    "started": "2020-10-20T15:50:41.691+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "502752",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/503806",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#issuecomment-714625854\n\n\n   This seems to speed up the compute layer a bit.\r\n   * Before:\r\n   ```\r\n   ArrayArrayKernel<Add, Int64Type>/32768/100       3781 ns         3780 ns       738685 bytes_per_second=8.07385G/s items_per_second=1083.65M/s null_percent=1 size=32.768k\r\n   ```\r\n   * After:\r\n   ```\r\n   ArrayArrayKernel<Add, Int64Type>/32768/100       3615 ns         3614 ns       777365 bytes_per_second=8.44344G/s items_per_second=1.13326G/s null_percent=1 size=32.768k\r\n   ```\r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-10-22T16:53:49.920+0000",
                    "updated": "2020-10-22T16:53:49.920+0000",
                    "started": "2020-10-22T16:53:49.920+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "503806",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/509757",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#issuecomment-724772910\n\n\n   @bkietz Do you plan to update this?\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-10T15:24:00.502+0000",
                    "updated": "2020-11-10T15:24:00.502+0000",
                    "started": "2020-11-10T15:24:00.502+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "509757",
                    "issueId": "13291560"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/worklog/511387",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #8472:\nURL: https://github.com/apache/arrow/pull/8472#issuecomment-726799854\n\n\n   @pitrou yes but not soon\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-13T14:37:40.034+0000",
                    "updated": "2020-11-13T14:37:40.034+0000",
                    "started": "2020-11-13T14:37:40.034+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "511387",
                    "issueId": "13291560"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 19800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@519ab222[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5a4570ed[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2f7ec3e0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@5e4d0cfa[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7bc719d3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5bee102a[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2d6b974[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@34ca4f08[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7700c1c3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@5c44f049[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6beeefac[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@d3a5fd6[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 19800,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Dec 08 12:19:17 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-12-08T12:19:17.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8113/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2020-03-13T14:13:59.000+0000",
        "updated": "2020-12-10T00:08:55.000+0000",
        "timeoriginalestimate": null,
        "description": "{{util::variant}} is an extremely useful structure but its header slows compilation significantly, so using it in public headers is questionable https://github.com/apache/arrow/pull/6545#discussion_r388406246\r\n\r\nI'll try writing a lighter weight version.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 19800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement a lighter-weight variant",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13291560/comment/17245857",
                    "id": "17245857",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 8472\n[https://github.com/apache/arrow/pull/8472]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2020-12-08T12:19:17.520+0000",
                    "updated": "2020-12-08T12:19:17.520+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0ci5s:",
        "customfield_12314139": null
    }
}