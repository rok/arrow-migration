{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13204153",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204153",
    "key": "ARROW-4015",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343858",
                "id": "12343858",
                "description": "",
                "name": "0.12.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-01-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
            "name": "Minor",
            "id": "4"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=zhijunfu",
            "name": "zhijunfu",
            "key": "zhijunfu",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34055",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34055",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34055",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34055"
            },
            "displayName": "Zhijun Fu",
            "active": true,
            "timeZone": "Asia/Shanghai"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12332956",
                "id": "12332956",
                "name": "C++ - Plasma"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=zhijunfu",
            "name": "zhijunfu",
            "key": "zhijunfu",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34055",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34055",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34055",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34055"
            },
            "displayName": "Zhijun Fu",
            "active": true,
            "timeZone": "Asia/Shanghai"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=zhijunfu",
            "name": "zhijunfu",
            "key": "zhijunfu",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34055",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34055",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34055",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34055"
            },
            "displayName": "Zhijun Fu",
            "active": true,
            "timeZone": "Asia/Shanghai"
        },
        "aggregateprogress": {
            "progress": 6000,
            "total": 6000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 6000,
            "total": 6000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4015/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 10,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204153/worklog/174783",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zhijunfu opened a new pull request #3167: ARROW-4015: [Plasma] remove unused interfaces for plasma manager\nURL: https://github.com/apache/arrow/pull/3167\n \n \n   https://github.com/apache/arrow/issues/3154\r\n   \r\n   This removes unused plasma interfaces Fetch(), Wait(), Transfer() and Info(), which depend on plasma manager which has already been removed from ray.\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-13T06:59:47.821+0000",
                    "updated": "2018-12-13T06:59:47.821+0000",
                    "started": "2018-12-13T06:59:47.820+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "174783",
                    "issueId": "13204153"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204153/worklog/175124",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "robertnishihara commented on issue #3167: ARROW-4015: [Plasma] remove unused interfaces for plasma manager\nURL: https://github.com/apache/arrow/pull/3167#issuecomment-447179844\n \n \n   In\r\n   \r\n   ```\r\n   def connect(store_socket_name, manager_socket_name, int release_delay=0, int num_retries=-1):\r\n   ```\r\n   \r\n   Can we make `manager_socket_name` an optional argument and print a deprecation warning if the argument is provided?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-14T01:19:25.765+0000",
                    "updated": "2018-12-14T01:19:25.765+0000",
                    "started": "2018-12-14T01:19:25.764+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175124",
                    "issueId": "13204153"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204153/worklog/175125",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "robertnishihara edited a comment on issue #3167: ARROW-4015: [Plasma] remove unused interfaces for plasma manager\nURL: https://github.com/apache/arrow/pull/3167#issuecomment-447179844\n \n \n   In `_plasma.pyx` in\r\n   \r\n   ```\r\n   def connect(store_socket_name, manager_socket_name, int release_delay=0, int num_retries=-1):\r\n   ```\r\n   \r\n   Can we make `manager_socket_name` an optional argument and print a deprecation warning if the argument is provided?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-14T01:19:42.099+0000",
                    "updated": "2018-12-14T01:19:42.099+0000",
                    "started": "2018-12-14T01:19:42.099+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175125",
                    "issueId": "13204153"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204153/worklog/175126",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "robertnishihara commented on issue #3167: ARROW-4015: [Plasma] remove unused interfaces for plasma manager\nURL: https://github.com/apache/arrow/pull/3167#issuecomment-447180314\n \n \n   In the docs at https://arrow.apache.org/docs/python/plasma.html, please remove all plasma_manager arguments.\r\n   \r\n   Also in https://arrow.apache.org/docs/cpp/md_tutorials_plasma.html, please remove all plasma_manager arguments.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-14T01:22:01.222+0000",
                    "updated": "2018-12-14T01:22:01.222+0000",
                    "started": "2018-12-14T01:22:01.221+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175126",
                    "issueId": "13204153"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204153/worklog/175197",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zhijunfu commented on issue #3167: ARROW-4015: [Plasma] remove unused interfaces for plasma manager\nURL: https://github.com/apache/arrow/pull/3167#issuecomment-447212141\n \n \n   Updated. Please kindly take another look. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-14T04:48:24.702+0000",
                    "updated": "2018-12-14T04:48:24.702+0000",
                    "started": "2018-12-14T04:48:24.702+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175197",
                    "issueId": "13204153"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204153/worklog/175228",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "robertnishihara commented on issue #3167: ARROW-4015: [Plasma] remove unused interfaces for plasma manager\nURL: https://github.com/apache/arrow/pull/3167#issuecomment-447243614\n \n \n   Thanks! Looks good to me pending tests passing.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-14T07:49:42.409+0000",
                    "updated": "2018-12-14T07:49:42.409+0000",
                    "started": "2018-12-14T07:49:42.408+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175228",
                    "issueId": "13204153"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204153/worklog/175241",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "robertnishihara commented on issue #3167: ARROW-4015: [Plasma] remove unused interfaces for plasma manager\nURL: https://github.com/apache/arrow/pull/3167#issuecomment-447252496\n \n \n   @zhijunfu I pushed some changes. Can you take a look?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-14T08:28:51.223+0000",
                    "updated": "2018-12-14T08:28:51.223+0000",
                    "started": "2018-12-14T08:28:51.222+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175241",
                    "issueId": "13204153"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204153/worklog/175270",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "zhijunfu commented on issue #3167: ARROW-4015: [Plasma] remove unused interfaces for plasma manager\nURL: https://github.com/apache/arrow/pull/3167#issuecomment-447285952\n \n \n   @robertnishihara Looks good to me. Thanks. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-14T10:38:20.964+0000",
                    "updated": "2018-12-14T10:38:20.964+0000",
                    "started": "2018-12-14T10:38:20.963+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175270",
                    "issueId": "13204153"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204153/worklog/175375",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz closed pull request #3167: ARROW-4015: [Plasma] remove unused interfaces for plasma manager\nURL: https://github.com/apache/arrow/pull/3167\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/c_glib/plasma-glib/client.cpp b/c_glib/plasma-glib/client.cpp\nindex c05a71085d..9591a0a714 100644\n--- a/c_glib/plasma-glib/client.cpp\n+++ b/c_glib/plasma-glib/client.cpp\n@@ -41,8 +41,7 @@ G_BEGIN_DECLS\n  *\n  * #GPlasmaClientCreateOptions is a class for customizing object creation.\n  *\n- * #GPlasmaClient is a class for an interface with a plasma store\n- * and a plasma manager.\n+ * #GPlasmaClient is a class for an interface with a plasma store.\n  *\n  * Since: 0.12.0\n  */\ndiff --git a/cpp/apidoc/tutorials/plasma.md b/cpp/apidoc/tutorials/plasma.md\nindex 472d479c4b..b9046d50bc 100644\n--- a/cpp/apidoc/tutorials/plasma.md\n+++ b/cpp/apidoc/tutorials/plasma.md\n@@ -80,7 +80,7 @@ using namespace plasma;\n int main(int argc, char** argv) {\n   // Start up and connect a Plasma client.\n   PlasmaClient client;\n-  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\", \"\"));\n+  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\"));\n   // Disconnect the Plasma client.\n   ARROW_CHECK_OK(client.Disconnect());\n }\n@@ -226,7 +226,7 @@ using namespace plasma;\n int main(int argc, char** argv) {\n   // Start up and connect a Plasma client.\n   PlasmaClient client;\n-  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\", \"\"));\n+  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\"));\n   // Create an object with a fixed ObjectID.\n   ObjectID object_id = ObjectID::from_binary(\"00000000000000000000\");\n   int64_t data_size = 1000;\n@@ -332,7 +332,7 @@ using namespace plasma;\n int main(int argc, char** argv) {\n   // Start up and connect a Plasma client.\n   PlasmaClient client;\n-  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\", \"\"));\n+  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\"));\n   ObjectID object_id = ObjectID::from_binary(\"00000000000000000000\");\n   ObjectBuffer object_buffer;\n   ARROW_CHECK_OK(client.Get(&object_id, 1, -1, &object_buffer));\n@@ -421,7 +421,7 @@ using namespace plasma;\n int main(int argc, char** argv) {\n   // Start up and connect a Plasma client.\n   PlasmaClient client;\n-  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\", \"\"));\n+  ARROW_CHECK_OK(client.Connect(\"/tmp/plasma\"));\n \n   int fd;\n   ARROW_CHECK_OK(client.Subscribe(&fd));\ndiff --git a/cpp/apidoc/tutorials/tensor_to_py.md b/cpp/apidoc/tutorials/tensor_to_py.md\nindex 0be973a4f3..cd191fea07 100644\n--- a/cpp/apidoc/tutorials/tensor_to_py.md\n+++ b/cpp/apidoc/tutorials/tensor_to_py.md\n@@ -105,7 +105,7 @@ The `inputs` variable will be a list of Object IDs in their raw byte string form\n import pyarrow as pa\n import pyarrow.plasma as plasma\n \n-plasma_client = plasma.connect('/tmp/plasma', '', 0)\n+plasma_client = plasma.connect('/tmp/plasma')\n \n # inputs: a list of object ids\n inputs = [20 * b'1']\ndiff --git a/cpp/src/plasma/client.cc b/cpp/src/plasma/client.cc\nindex 2dbe2b4147..4215399c0b 100644\n--- a/cpp/src/plasma/client.cc\n+++ b/cpp/src/plasma/client.cc\n@@ -198,17 +198,6 @@ class PlasmaClient::Impl : public std::enable_shared_from_this<PlasmaClient::Imp\n \n   Status Disconnect();\n \n-  Status Fetch(int num_object_ids, const ObjectID* object_ids);\n-\n-  Status Wait(int64_t num_object_requests, ObjectRequest* object_requests,\n-              int num_ready_objects, int64_t timeout_ms, int* num_objects_ready);\n-\n-  Status Transfer(const char* addr, int port, const ObjectID& object_id);\n-\n-  Status Info(const ObjectID& object_id, int* object_status);\n-\n-  int get_manager_fd() const;\n-\n   bool IsInUse(const ObjectID& object_id);\n \n  private:\n@@ -250,8 +239,6 @@ class PlasmaClient::Impl : public std::enable_shared_from_this<PlasmaClient::Imp\n \n   /// File descriptor of the Unix domain socket that connects to the store.\n   int store_conn_;\n-  /// File descriptor of the Unix domain socket that connects to the manager.\n-  int manager_conn_;\n   /// Table of dlmalloc buffer files that have been memory mapped so far. This\n   /// is a hash table mapping a file descriptor to a struct containing the\n   /// address of the corresponding memory-mapped file.\n@@ -872,10 +859,7 @@ Status PlasmaClient::Impl::Connect(const std::string& store_socket_name,\n                                    int release_delay, int num_retries) {\n   RETURN_NOT_OK(ConnectIpcSocketRetry(store_socket_name, num_retries, -1, &store_conn_));\n   if (manager_socket_name != \"\") {\n-    RETURN_NOT_OK(\n-        ConnectIpcSocketRetry(manager_socket_name, num_retries, -1, &manager_conn_));\n-  } else {\n-    manager_conn_ = -1;\n+    return Status::NotImplemented(\"plasma manager is no longer supported\");\n   }\n   if (release_delay != 0) {\n     ARROW_LOG(WARNING) << \"The release_delay parameter in PlasmaClient::Connect \"\n@@ -898,78 +882,6 @@ Status PlasmaClient::Impl::Disconnect() {\n   // that were in use by us when handling the SIGPIPE.\n   close(store_conn_);\n   store_conn_ = -1;\n-  if (manager_conn_ >= 0) {\n-    close(manager_conn_);\n-    manager_conn_ = -1;\n-  }\n-  return Status::OK();\n-}\n-\n-Status PlasmaClient::Impl::Transfer(const char* address, int port,\n-                                    const ObjectID& object_id) {\n-  return SendDataRequest(manager_conn_, object_id, address, port);\n-}\n-\n-Status PlasmaClient::Impl::Fetch(int num_object_ids, const ObjectID* object_ids) {\n-  ARROW_CHECK(manager_conn_ >= 0);\n-  return SendFetchRequest(manager_conn_, object_ids, num_object_ids);\n-}\n-\n-int PlasmaClient::Impl::get_manager_fd() const { return manager_conn_; }\n-\n-Status PlasmaClient::Impl::Info(const ObjectID& object_id, int* object_status) {\n-  ARROW_CHECK(manager_conn_ >= 0);\n-\n-  RETURN_NOT_OK(SendStatusRequest(manager_conn_, &object_id, 1));\n-  std::vector<uint8_t> buffer;\n-  RETURN_NOT_OK(PlasmaReceive(manager_conn_, MessageType::PlasmaStatusReply, &buffer));\n-  ObjectID id;\n-  RETURN_NOT_OK(ReadStatusReply(buffer.data(), buffer.size(), &id, object_status, 1));\n-  ARROW_CHECK(object_id == id);\n-  return Status::OK();\n-}\n-\n-Status PlasmaClient::Impl::Wait(int64_t num_object_requests,\n-                                ObjectRequest* object_requests, int num_ready_objects,\n-                                int64_t timeout_ms, int* num_objects_ready) {\n-  ARROW_CHECK(manager_conn_ >= 0);\n-  ARROW_CHECK(num_object_requests > 0);\n-  ARROW_CHECK(num_ready_objects > 0);\n-  ARROW_CHECK(num_ready_objects <= num_object_requests);\n-\n-  for (int i = 0; i < num_object_requests; ++i) {\n-    ARROW_CHECK(object_requests[i].type == ObjectRequestType::PLASMA_QUERY_LOCAL ||\n-                object_requests[i].type == ObjectRequestType::PLASMA_QUERY_ANYWHERE);\n-  }\n-\n-  RETURN_NOT_OK(SendWaitRequest(manager_conn_, object_requests, num_object_requests,\n-                                num_ready_objects, timeout_ms));\n-  std::vector<uint8_t> buffer;\n-  RETURN_NOT_OK(PlasmaReceive(manager_conn_, MessageType::PlasmaWaitReply, &buffer));\n-  RETURN_NOT_OK(\n-      ReadWaitReply(buffer.data(), buffer.size(), object_requests, &num_ready_objects));\n-\n-  *num_objects_ready = 0;\n-  for (int i = 0; i < num_object_requests; ++i) {\n-    ObjectRequestType type = object_requests[i].type;\n-    auto status = static_cast<fb::ObjectStatus>(object_requests[i].location);\n-    switch (type) {\n-      case ObjectRequestType::PLASMA_QUERY_LOCAL:\n-        if (status == fb::ObjectStatus::Local) {\n-          *num_objects_ready += 1;\n-        }\n-        break;\n-      case ObjectRequestType::PLASMA_QUERY_ANYWHERE:\n-        if (status == fb::ObjectStatus::Local || status == fb::ObjectStatus::Remote) {\n-          *num_objects_ready += 1;\n-        } else {\n-          ARROW_CHECK(status == fb::ObjectStatus::Nonexistent);\n-        }\n-        break;\n-      default:\n-        ARROW_LOG(FATAL) << \"This code should be unreachable.\";\n-    }\n-  }\n   return Status::OK();\n }\n \n@@ -1052,27 +964,6 @@ Status PlasmaClient::DecodeNotification(const uint8_t* buffer, ObjectID* object_\n \n Status PlasmaClient::Disconnect() { return impl_->Disconnect(); }\n \n-Status PlasmaClient::Fetch(int num_object_ids, const ObjectID* object_ids) {\n-  return impl_->Fetch(num_object_ids, object_ids);\n-}\n-\n-Status PlasmaClient::Wait(int64_t num_object_requests, ObjectRequest* object_requests,\n-                          int num_ready_objects, int64_t timeout_ms,\n-                          int* num_objects_ready) {\n-  return impl_->Wait(num_object_requests, object_requests, num_ready_objects, timeout_ms,\n-                     num_objects_ready);\n-}\n-\n-Status PlasmaClient::Transfer(const char* addr, int port, const ObjectID& object_id) {\n-  return impl_->Transfer(addr, port, object_id);\n-}\n-\n-Status PlasmaClient::Info(const ObjectID& object_id, int* object_status) {\n-  return impl_->Info(object_id, object_status);\n-}\n-\n-int PlasmaClient::get_manager_fd() const { return impl_->get_manager_fd(); }\n-\n bool PlasmaClient::IsInUse(const ObjectID& object_id) {\n   return impl_->IsInUse(object_id);\n }\ndiff --git a/cpp/src/plasma/client.h b/cpp/src/plasma/client.h\nindex 514d2bd0d6..ac9e8eb0fe 100644\n--- a/cpp/src/plasma/client.h\n+++ b/cpp/src/plasma/client.h\n@@ -49,19 +49,20 @@ class ARROW_EXPORT PlasmaClient {\n   PlasmaClient();\n   ~PlasmaClient();\n \n-  /// Connect to the local plasma store and plasma manager. Return\n-  /// the resulting connection.\n+  /// Connect to the local plasma store. Return the resulting connection.\n   ///\n   /// \\param store_socket_name The name of the UNIX domain socket to use to\n   ///        connect to the Plasma store.\n   /// \\param manager_socket_name The name of the UNIX domain socket to use to\n   ///        connect to the local Plasma manager. If this is \"\", then this\n   ///        function will not connect to a manager.\n+  ///        Note that plasma manager is no longer supported, this function\n+  ///        will return failure if this is not \"\".\n   /// \\param release_delay Deprecated (not used).\n   /// \\param num_retries number of attempts to connect to IPC socket, default 50\n   /// \\return The return status.\n   Status Connect(const std::string& store_socket_name,\n-                 const std::string& manager_socket_name, int release_delay = 0,\n+                 const std::string& manager_socket_name = \"\", int release_delay = 0,\n                  int num_retries = -1);\n \n   /// Create an object in the Plasma Store. Any metadata for this object must be\n@@ -249,99 +250,6 @@ class ARROW_EXPORT PlasmaClient {\n   /// \\return The return status.\n   Status Disconnect();\n \n-  /// Attempt to initiate the transfer of some objects from remote Plasma\n-  /// Stores.\n-  /// This method does not guarantee that the fetched objects will arrive\n-  /// locally.\n-  ///\n-  /// For an object that is available in the local Plasma Store, this method\n-  /// will\n-  /// not do anything. For an object that is not available locally, it will\n-  /// check\n-  /// if the object are already being fetched. If so, it will not do anything.\n-  /// If\n-  /// not, it will query the object table for a list of Plasma Managers that\n-  /// have\n-  /// the object. The object table will return a non-empty list, and this Plasma\n-  /// Manager will attempt to initiate transfers from one of those Plasma\n-  /// Managers.\n-  ///\n-  /// This function is non-blocking.\n-  ///\n-  /// This method is idempotent in the sense that it is ok to call it multiple\n-  /// times.\n-  ///\n-  /// \\param num_object_ids The number of object IDs fetch is being called on.\n-  /// \\param object_ids The IDs of the objects that fetch is being called on.\n-  /// \\return The return status.\n-  Status Fetch(int num_object_ids, const ObjectID* object_ids);\n-\n-  /// Wait for (1) a specified number of objects to be available (sealed) in the\n-  /// local Plasma Store or in a remote Plasma Store, or (2) for a timeout to\n-  /// expire. This is a blocking call.\n-  ///\n-  /// \\param num_object_requests Size of the object_requests array.\n-  /// \\param object_requests Object event array. Each element contains a request\n-  ///        for a particular object_id. The type of request is specified in the\n-  ///        \"type\" field.\n-  ///        - A PLASMA_QUERY_LOCAL request is satisfied when object_id becomes\n-  ///          available in the local Plasma Store. In this case, this function\n-  ///          sets the \"status\" field to ObjectStatus::Local. Note, if the\n-  ///          status\n-  ///          is not ObjectStatus::Local, it will be ObjectStatus::Nonexistent,\n-  ///          but it may exist elsewhere in the system.\n-  ///        - A PLASMA_QUERY_ANYWHERE request is satisfied when object_id\n-  ///        becomes\n-  ///          available either at the local Plasma Store or on a remote Plasma\n-  ///          Store. In this case, the functions sets the \"status\" field to\n-  ///          ObjectStatus::Local or ObjectStatus::Remote.\n-  /// \\param num_ready_objects The number of requests in object_requests array\n-  /// that\n-  ///        must be satisfied before the function returns, unless it timeouts.\n-  ///        The num_ready_objects should be no larger than num_object_requests.\n-  /// \\param timeout_ms Timeout value in milliseconds. If this timeout expires\n-  ///        before min_num_ready_objects of requests are satisfied, the\n-  ///        function\n-  ///        returns.\n-  /// \\param num_objects_ready Out parameter for number of satisfied requests in\n-  ///        the object_requests list. If the returned number is less than\n-  ///        min_num_ready_objects this means that timeout expired.\n-  /// \\return The return status.\n-  Status Wait(int64_t num_object_requests, ObjectRequest* object_requests,\n-              int num_ready_objects, int64_t timeout_ms, int* num_objects_ready);\n-\n-  /// Transfer local object to a different plasma manager.\n-  ///\n-  /// \\param addr IP address of the plasma manager we are transfering to.\n-  /// \\param port Port of the plasma manager we are transfering to.\n-  /// \\param object_id ObjectID of the object we are transfering.\n-  /// \\return The return status.\n-  Status Transfer(const char* addr, int port, const ObjectID& object_id);\n-\n-  /// Return the status of a given object. This method may query the object\n-  /// table.\n-  ///\n-  /// \\param object_id The ID of the object whose status we query.\n-  /// \\param object_status Out parameter for object status. Can take the\n-  ///         following values.\n-  ///         - PLASMA_CLIENT_LOCAL, if object is stored in the local Plasma\n-  ///         Store.\n-  ///           has been already scheduled by the Plasma Manager.\n-  ///         - PLASMA_CLIENT_TRANSFER, if the object is either currently being\n-  ///           transferred or just scheduled.\n-  ///         - PLASMA_CLIENT_REMOTE, if the object is stored at a remote\n-  ///           Plasma Store.\n-  ///         - PLASMA_CLIENT_DOES_NOT_EXIST, if the object doesn\u2019t exist in the\n-  ///           system.\n-  /// \\return The return status.\n-  Status Info(const ObjectID& object_id, int* object_status);\n-\n-  /// Get the file descriptor for the socket connection to the plasma manager.\n-  ///\n-  /// \\return The file descriptor for the manager connection. If there is no\n-  ///         connection to the manager, this is -1.\n-  int get_manager_fd() const;\n-\n  private:\n   friend class PlasmaBuffer;\n   FRIEND_TEST(TestPlasmaStore, GetTest);\ndiff --git a/cpp/src/plasma/common.cc b/cpp/src/plasma/common.cc\nindex 0ca17cf814..1b86fd80b4 100644\n--- a/cpp/src/plasma/common.cc\n+++ b/cpp/src/plasma/common.cc\n@@ -107,9 +107,6 @@ bool UniqueID::operator==(const UniqueID& rhs) const {\n   return std::memcmp(data(), rhs.data(), kUniqueIDSize) == 0;\n }\n \n-ARROW_EXPORT fb::ObjectStatus ObjectStatusLocal = fb::ObjectStatus::Local;\n-ARROW_EXPORT fb::ObjectStatus ObjectStatusRemote = fb::ObjectStatus::Remote;\n-\n const PlasmaStoreInfo* plasma_config;\n \n }  // namespace plasma\ndiff --git a/cpp/src/plasma/common.h b/cpp/src/plasma/common.h\nindex 7090428ff4..38925fef92 100644\n--- a/cpp/src/plasma/common.h\n+++ b/cpp/src/plasma/common.h\n@@ -66,30 +66,6 @@ typedef UniqueID ObjectID;\n /// Size of object hash digests.\n constexpr int64_t kDigestSize = sizeof(uint64_t);\n \n-enum class ObjectRequestType : int {\n-  /// Query for object in the local plasma store.\n-  PLASMA_QUERY_LOCAL = 1,\n-  /// Query for object in the local plasma store or in a remote plasma store.\n-  PLASMA_QUERY_ANYWHERE\n-};\n-\n-/// Object request data structure. Used for Wait.\n-struct ObjectRequest {\n-  /// The ID of the requested object. If ID_NIL request any object.\n-  ObjectID object_id;\n-  /// Request associated to the object. It can take one of the following values:\n-  ///  - PLASMA_QUERY_LOCAL: return if or when the object is available in the\n-  ///    local Plasma Store.\n-  ///  - PLASMA_QUERY_ANYWHERE: return if or when the object is available in\n-  ///    the system (i.e., either in the local or a remote Plasma Store).\n-  ObjectRequestType type;\n-  /// Object location. This can be\n-  ///  - ObjectLocation::Local: object is ready at the local Plasma Store.\n-  ///  - ObjectLocation::Remote: object is ready at a remote Plasma Store.\n-  ///  - ObjectLocation::Nonexistent: object does not exist in the system.\n-  ObjectLocation location;\n-};\n-\n enum class ObjectState : int {\n   /// Object was created but not sealed in the local Plasma Store.\n   PLASMA_CREATED = 1,\ndiff --git a/cpp/src/plasma/format/plasma.fbs b/cpp/src/plasma/format/plasma.fbs\nindex ef934fbd81..b3c8903918 100644\n--- a/cpp/src/plasma/format/plasma.fbs\n+++ b/cpp/src/plasma/format/plasma.fbs\n@@ -42,9 +42,6 @@ enum MessageType:long {\n   // Delete an object.\n   PlasmaDeleteRequest,\n   PlasmaDeleteReply,\n-  // Get status of an object.\n-  PlasmaStatusRequest,\n-  PlasmaStatusReply,\n   // See if the store contains an object (will be deprecated).\n   PlasmaContainsRequest,\n   PlasmaContainsReply,\n@@ -57,11 +54,6 @@ enum MessageType:long {\n   // Make room for new objects in the plasma store.\n   PlasmaEvictRequest,\n   PlasmaEvictReply,\n-  // Fetch objects from remote Plasma stores.\n-  PlasmaFetchRequest,\n-  // Wait for objects to be ready either from local or remote Plasma stores.\n-  PlasmaWaitRequest,\n-  PlasmaWaitReply,\n   // Subscribe to a list of objects or to all objects.\n   PlasmaSubscribeRequest,\n   // Unsubscribe.\n@@ -239,35 +231,6 @@ table PlasmaDeleteReply {\n   errors: [PlasmaError];\n }\n \n-table PlasmaStatusRequest {\n-  // IDs of the objects stored at local Plasma store we request the status of.\n-  object_ids: [string];\n-}\n-\n-enum ObjectStatus:int {\n-  // Object is stored in the local Plasma Store.\n-  Local,\n-  // Object is stored on a remote Plasma store, and it is not stored on the\n-  // local Plasma Store.\n-  Remote,\n-  // Object is not stored in the system.\n-  Nonexistent,\n-  // Object is currently transferred from a remote Plasma store the local\n-  // Plasma Store.\n-  Transfer\n-}\n-\n-table PlasmaStatusReply {\n-  // IDs of the objects being returned.\n-  object_ids: [string];\n-  // Status of the object.\n-  status: [ObjectStatus];\n-}\n-\n-// PlasmaContains is a subset of PlasmaStatus which does not\n-// involve the plasma manager, only the store. We should consider\n-// unifying them in the future and deprecating PlasmaContains.\n-\n table PlasmaContainsRequest {\n   // ID of the object we are querying.\n   object_id: string;\n@@ -309,43 +272,6 @@ table PlasmaEvictReply {\n   num_bytes: ulong;\n }\n \n-table PlasmaFetchRequest {\n-  // IDs of objects to be gotten.\n-  object_ids: [string];\n-}\n-\n-table ObjectRequestSpec {\n-  // ID of the object.\n-  object_id: string;\n-  // The type of the object. This specifies whether we\n-  // will be waiting for an object store in the local or\n-  // global Plasma store.\n-  type: int;\n-}\n-\n-table PlasmaWaitRequest {\n-  // Array of object requests whose status we are asking for.\n-  object_requests: [ObjectRequestSpec];\n-  // Number of objects expected to be returned, if available.\n-  num_ready_objects: int;\n-  // timeout\n-  timeout: long;\n-}\n-\n-table ObjectReply {\n-  // ID of the object.\n-  object_id: string;\n-  // The object status. This specifies where the object is stored.\n-  status: ObjectStatus;\n-}\n-\n-table PlasmaWaitReply {\n-  // Array of object requests being returned.\n-  object_requests: [ObjectReply];\n-  // Number of objects expected to be returned, if available.\n-  num_ready_objects: int;\n-}\n-\n table PlasmaSubscribeRequest {\n }\n \ndiff --git a/cpp/src/plasma/lib/java/org_apache_arrow_plasma_PlasmaClientJNI.cc b/cpp/src/plasma/lib/java/org_apache_arrow_plasma_PlasmaClientJNI.cc\nindex 7cd2f35744..fa376ec43c 100644\n--- a/cpp/src/plasma/lib/java/org_apache_arrow_plasma_PlasmaClientJNI.cc\n+++ b/cpp/src/plasma/lib/java/org_apache_arrow_plasma_PlasmaClientJNI.cc\n@@ -220,79 +220,6 @@ JNIEXPORT jboolean JNICALL Java_org_apache_arrow_plasma_PlasmaClientJNI_contains\n   return has_object;\n }\n \n-JNIEXPORT void JNICALL Java_org_apache_arrow_plasma_PlasmaClientJNI_fetch(\n-    JNIEnv* env, jclass cls, jlong conn, jobjectArray object_ids) {\n-  plasma::PlasmaClient* client = reinterpret_cast<plasma::PlasmaClient*>(conn);\n-  jsize num_oids = env->GetArrayLength(object_ids);\n-\n-  std::vector<plasma::ObjectID> oids(num_oids);\n-  for (int i = 0; i < num_oids; ++i) {\n-    jbyteArray_to_object_id(\n-        env, reinterpret_cast<jbyteArray>(env->GetObjectArrayElement(object_ids, i)),\n-        &oids[i]);\n-  }\n-\n-  ARROW_CHECK_OK(client->Fetch(static_cast<int>(num_oids), oids.data()));\n-\n-  return;\n-}\n-\n-JNIEXPORT jobjectArray JNICALL Java_org_apache_arrow_plasma_PlasmaClientJNI_wait(\n-    JNIEnv* env, jclass cls, jlong conn, jobjectArray object_ids, jint timeout_ms,\n-    jint num_returns) {\n-  plasma::PlasmaClient* client = reinterpret_cast<plasma::PlasmaClient*>(conn);\n-  jsize num_oids = env->GetArrayLength(object_ids);\n-\n-  if (num_returns < 0) {\n-    jclass Exception = env->FindClass(\"java/lang/RuntimeException\");\n-    env->ThrowNew(Exception, \"The argument num_returns cannot be less than zero.\");\n-    return nullptr;\n-  }\n-  if (num_returns > num_oids) {\n-    jclass Exception = env->FindClass(\"java/lang/RuntimeException\");\n-    env->ThrowNew(Exception,\n-                  \"The argument num_returns cannot be greater than len(object_ids).\");\n-    return nullptr;\n-  }\n-\n-  std::vector<plasma::ObjectRequest> oreqs(num_oids);\n-\n-  for (int i = 0; i < num_oids; ++i) {\n-    jbyteArray_to_object_id(\n-        env, reinterpret_cast<jbyteArray>(env->GetObjectArrayElement(object_ids, i)),\n-        &oreqs[i].object_id);\n-    oreqs[i].type = plasma::ObjectRequestType::PLASMA_QUERY_ANYWHERE;\n-  }\n-\n-  int num_return_objects;\n-  // TODO: may be blocked. consider to add the thread support\n-  ARROW_CHECK_OK(client->Wait(static_cast<int>(num_oids), oreqs.data(), num_returns,\n-                              static_cast<uint64_t>(timeout_ms), &num_return_objects));\n-\n-  int num_to_return = std::min(num_return_objects, num_returns);\n-  jclass clsByteArray = env->FindClass(\"[B\");\n-  jobjectArray ret = env->NewObjectArray(num_to_return, clsByteArray, nullptr);\n-\n-  int num_returned = 0;\n-  jbyteArray oid = nullptr;\n-  for (int i = 0; i < num_oids; ++i) {\n-    if (num_returned >= num_to_return) {\n-      break;\n-    }\n-\n-    if (oreqs[i].location == plasma::ObjectLocation::Local ||\n-        oreqs[i].location == plasma::ObjectLocation::Remote) {\n-      oid = env->NewByteArray(OBJECT_ID_SIZE);\n-      object_id_to_jbyteArray(env, oid, &oreqs[i].object_id);\n-      env->SetObjectArrayElement(ret, num_returned, oid);\n-      num_returned++;\n-    }\n-  }\n-  ARROW_CHECK(num_returned == num_to_return);\n-\n-  return ret;\n-}\n-\n JNIEXPORT jlong JNICALL Java_org_apache_arrow_plasma_PlasmaClientJNI_evict(\n     JNIEnv* env, jclass cls, jlong conn, jlong num_bytes) {\n   plasma::PlasmaClient* client = reinterpret_cast<plasma::PlasmaClient*>(conn);\ndiff --git a/cpp/src/plasma/plasma.h b/cpp/src/plasma/plasma.h\nindex 83caec7ee4..aafe527466 100644\n--- a/cpp/src/plasma/plasma.h\n+++ b/cpp/src/plasma/plasma.h\n@@ -68,9 +68,6 @@ constexpr int64_t kBlockSize = 64;\n \n struct Client;\n \n-/// Mapping from object IDs to type and status of the request.\n-typedef std::unordered_map<ObjectID, ObjectRequest> ObjectRequestMap;\n-\n // TODO(pcm): Replace this by the flatbuffers message PlasmaObjectSpec.\n struct PlasmaObject {\n #ifdef PLASMA_CUDA\ndiff --git a/cpp/src/plasma/protocol.cc b/cpp/src/plasma/protocol.cc\nindex c437840874..a878647718 100644\n--- a/cpp/src/plasma/protocol.cc\n+++ b/cpp/src/plasma/protocol.cc\n@@ -42,10 +42,6 @@ using flatbuffers::uoffset_t;\n #define PLASMA_CHECK_ENUM(x, y) \\\n   static_assert(static_cast<int>(x) == static_cast<int>(y), \"protocol mismatch\")\n \n-PLASMA_CHECK_ENUM(ObjectLocation::Local, fb::ObjectStatus::Local);\n-PLASMA_CHECK_ENUM(ObjectLocation::Remote, fb::ObjectStatus::Remote);\n-PLASMA_CHECK_ENUM(ObjectLocation::Nonexistent, fb::ObjectStatus::Nonexistent);\n-\n flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>>\n ToFlatbuffer(flatbuffers::FlatBufferBuilder* fbb, const ObjectID* object_ids,\n              int64_t num_objects) {\n@@ -367,56 +363,6 @@ Status ReadDeleteReply(uint8_t* data, size_t size, std::vector<ObjectID>* object\n   return Status::OK();\n }\n \n-// Satus messages.\n-\n-Status SendStatusRequest(int sock, const ObjectID* object_ids, int64_t num_objects) {\n-  flatbuffers::FlatBufferBuilder fbb;\n-  auto message =\n-      fb::CreatePlasmaStatusRequest(fbb, ToFlatbuffer(&fbb, object_ids, num_objects));\n-  return PlasmaSend(sock, MessageType::PlasmaStatusRequest, &fbb, message);\n-}\n-\n-Status ReadStatusRequest(uint8_t* data, size_t size, ObjectID object_ids[],\n-                         int64_t num_objects) {\n-  DCHECK(data);\n-  auto message = flatbuffers::GetRoot<fb::PlasmaStatusRequest>(data);\n-  DCHECK(VerifyFlatbuffer(message, data, size));\n-  for (uoffset_t i = 0; i < num_objects; ++i) {\n-    object_ids[i] = ObjectID::from_binary(message->object_ids()->Get(i)->str());\n-  }\n-  return Status::OK();\n-}\n-\n-Status SendStatusReply(int sock, ObjectID object_ids[], int object_status[],\n-                       int64_t num_objects) {\n-  flatbuffers::FlatBufferBuilder fbb;\n-  auto message =\n-      fb::CreatePlasmaStatusReply(fbb, ToFlatbuffer(&fbb, object_ids, num_objects),\n-                                  fbb.CreateVector(object_status, num_objects));\n-  return PlasmaSend(sock, MessageType::PlasmaStatusReply, &fbb, message);\n-}\n-\n-int64_t ReadStatusReply_num_objects(uint8_t* data, size_t size) {\n-  DCHECK(data);\n-  auto message = flatbuffers::GetRoot<fb::PlasmaStatusReply>(data);\n-  DCHECK(VerifyFlatbuffer(message, data, size));\n-  return message->object_ids()->size();\n-}\n-\n-Status ReadStatusReply(uint8_t* data, size_t size, ObjectID object_ids[],\n-                       int object_status[], int64_t num_objects) {\n-  DCHECK(data);\n-  auto message = flatbuffers::GetRoot<fb::PlasmaStatusReply>(data);\n-  DCHECK(VerifyFlatbuffer(message, data, size));\n-  for (uoffset_t i = 0; i < num_objects; ++i) {\n-    object_ids[i] = ObjectID::from_binary(message->object_ids()->Get(i)->str());\n-  }\n-  for (uoffset_t i = 0; i < num_objects; ++i) {\n-    object_status[i] = message->status()->data()[i];\n-  }\n-  return Status::OK();\n-}\n-\n // Contains messages.\n \n Status SendContainsRequest(int sock, ObjectID object_id) {\n@@ -640,95 +586,6 @@ Status ReadGetReply(uint8_t* data, size_t size, ObjectID object_ids[],\n   }\n   return Status::OK();\n }\n-// Fetch messages.\n-\n-Status SendFetchRequest(int sock, const ObjectID* object_ids, int64_t num_objects) {\n-  flatbuffers::FlatBufferBuilder fbb;\n-  auto message =\n-      fb::CreatePlasmaFetchRequest(fbb, ToFlatbuffer(&fbb, object_ids, num_objects));\n-  return PlasmaSend(sock, MessageType::PlasmaFetchRequest, &fbb, message);\n-}\n-\n-Status ReadFetchRequest(uint8_t* data, size_t size, std::vector<ObjectID>& object_ids) {\n-  DCHECK(data);\n-  auto message = flatbuffers::GetRoot<fb::PlasmaFetchRequest>(data);\n-  DCHECK(VerifyFlatbuffer(message, data, size));\n-  for (uoffset_t i = 0; i < message->object_ids()->size(); ++i) {\n-    object_ids.push_back(ObjectID::from_binary(message->object_ids()->Get(i)->str()));\n-  }\n-  return Status::OK();\n-}\n-\n-// Wait messages.\n-\n-Status SendWaitRequest(int sock, ObjectRequest object_requests[], int64_t num_requests,\n-                       int num_ready_objects, int64_t timeout_ms) {\n-  flatbuffers::FlatBufferBuilder fbb;\n-\n-  std::vector<flatbuffers::Offset<fb::ObjectRequestSpec>> object_request_specs;\n-  for (int i = 0; i < num_requests; i++) {\n-    object_request_specs.push_back(fb::CreateObjectRequestSpec(\n-        fbb, fbb.CreateString(object_requests[i].object_id.binary()),\n-        static_cast<int>(object_requests[i].type)));\n-  }\n-\n-  auto message = fb::CreatePlasmaWaitRequest(fbb, fbb.CreateVector(object_request_specs),\n-                                             num_ready_objects, timeout_ms);\n-  return PlasmaSend(sock, MessageType::PlasmaWaitRequest, &fbb, message);\n-}\n-\n-Status ReadWaitRequest(uint8_t* data, size_t size, ObjectRequestMap& object_requests,\n-                       int64_t* timeout_ms, int* num_ready_objects) {\n-  DCHECK(data);\n-  auto message = flatbuffers::GetRoot<fb::PlasmaWaitRequest>(data);\n-  DCHECK(VerifyFlatbuffer(message, data, size));\n-  *num_ready_objects = message->num_ready_objects();\n-  *timeout_ms = message->timeout();\n-\n-  for (uoffset_t i = 0; i < message->object_requests()->size(); i++) {\n-    ObjectID object_id =\n-        ObjectID::from_binary(message->object_requests()->Get(i)->object_id()->str());\n-    ObjectRequest object_request(\n-        {object_id,\n-         static_cast<ObjectRequestType>(message->object_requests()->Get(i)->type()),\n-         ObjectLocation::Nonexistent});\n-    object_requests[object_id] = object_request;\n-  }\n-  return Status::OK();\n-}\n-\n-Status SendWaitReply(int sock, const ObjectRequestMap& object_requests,\n-                     int num_ready_objects) {\n-  flatbuffers::FlatBufferBuilder fbb;\n-\n-  std::vector<flatbuffers::Offset<fb::ObjectReply>> object_replies;\n-  for (const auto& entry : object_requests) {\n-    const auto& object_request = entry.second;\n-    object_replies.push_back(\n-        fb::CreateObjectReply(fbb, fbb.CreateString(object_request.object_id.binary()),\n-                              static_cast<fb::ObjectStatus>(object_request.location)));\n-  }\n-\n-  auto message = fb::CreatePlasmaWaitReply(\n-      fbb, fbb.CreateVector(object_replies.data(), num_ready_objects), num_ready_objects);\n-  return PlasmaSend(sock, MessageType::PlasmaWaitReply, &fbb, message);\n-}\n-\n-Status ReadWaitReply(uint8_t* data, size_t size, ObjectRequest object_requests[],\n-                     int* num_ready_objects) {\n-  DCHECK(data);\n-\n-  auto message = flatbuffers::GetRoot<fb::PlasmaWaitReply>(data);\n-  DCHECK(VerifyFlatbuffer(message, data, size));\n-  *num_ready_objects = message->num_ready_objects();\n-  for (int i = 0; i < *num_ready_objects; i++) {\n-    object_requests[i].object_id =\n-        ObjectID::from_binary(message->object_requests()->Get(i)->object_id()->str());\n-    object_requests[i].location =\n-        static_cast<ObjectLocation>(message->object_requests()->Get(i)->status());\n-  }\n-  return Status::OK();\n-}\n \n // Subscribe messages.\n \ndiff --git a/cpp/src/plasma/protocol.h b/cpp/src/plasma/protocol.h\nindex c8204584b8..0362bd4779 100644\n--- a/cpp/src/plasma/protocol.h\n+++ b/cpp/src/plasma/protocol.h\n@@ -128,21 +128,6 @@ Status SendDeleteReply(int sock, const std::vector<ObjectID>& object_ids,\n Status ReadDeleteReply(uint8_t* data, size_t size, std::vector<ObjectID>* object_ids,\n                        std::vector<PlasmaError>* errors);\n \n-/* Satus messages. */\n-\n-Status SendStatusRequest(int sock, const ObjectID* object_ids, int64_t num_objects);\n-\n-Status ReadStatusRequest(uint8_t* data, size_t size, ObjectID object_ids[],\n-                         int64_t num_objects);\n-\n-Status SendStatusReply(int sock, ObjectID object_ids[], int object_status[],\n-                       int64_t num_objects);\n-\n-int64_t ReadStatusReply_num_objects(uint8_t* data, size_t size);\n-\n-Status ReadStatusReply(uint8_t* data, size_t size, ObjectID object_ids[],\n-                       int object_status[], int64_t num_objects);\n-\n /* Plasma Constains message functions. */\n \n Status SendContainsRequest(int sock, ObjectID object_id);\n@@ -184,26 +169,6 @@ Status SendEvictReply(int sock, int64_t num_bytes);\n \n Status ReadEvictReply(uint8_t* data, size_t size, int64_t& num_bytes);\n \n-/* Plasma Fetch Remote message functions. */\n-\n-Status SendFetchRequest(int sock, const ObjectID* object_ids, int64_t num_objects);\n-\n-Status ReadFetchRequest(uint8_t* data, size_t size, std::vector<ObjectID>& object_ids);\n-\n-/* Plasma Wait message functions. */\n-\n-Status SendWaitRequest(int sock, ObjectRequest object_requests[], int64_t num_requests,\n-                       int num_ready_objects, int64_t timeout_ms);\n-\n-Status ReadWaitRequest(uint8_t* data, size_t size, ObjectRequestMap& object_requests,\n-                       int64_t* timeout_ms, int* num_ready_objects);\n-\n-Status SendWaitReply(int sock, const ObjectRequestMap& object_requests,\n-                     int num_ready_objects);\n-\n-Status ReadWaitReply(uint8_t* data, size_t size, ObjectRequest object_requests[],\n-                     int* num_ready_objects);\n-\n /* Plasma Subscribe message functions. */\n \n Status SendSubscribeRequest(int sock);\ndiff --git a/cpp/src/plasma/test/client_tests.cc b/cpp/src/plasma/test/client_tests.cc\nindex 65a9b71b7f..30dc6850cd 100644\n--- a/cpp/src/plasma/test/client_tests.cc\n+++ b/cpp/src/plasma/test/client_tests.cc\n@@ -187,7 +187,6 @@ TEST_F(TestPlasmaStore, DeleteTest) {\n   ARROW_CHECK_OK(client_.Contains(object_id, &has_object));\n   ASSERT_TRUE(has_object);\n \n-  // Avoid race condition of Plasma Manager waiting for notification.\n   ARROW_CHECK_OK(client_.Release(object_id));\n   // object_id is marked as to-be-deleted, when it is not in use, it will be deleted.\n   ARROW_CHECK_OK(client_.Contains(object_id, &has_object));\n@@ -251,7 +250,6 @@ TEST_F(TestPlasmaStore, ContainsTest) {\n   // First create object.\n   std::vector<uint8_t> data(100, 0);\n   CreateObject(client_, object_id, {42}, data);\n-  // Avoid race condition of Plasma Manager waiting for notification.\n   std::vector<ObjectBuffer> object_buffers;\n   ARROW_CHECK_OK(client_.Get({object_id}, -1, &object_buffers));\n   ARROW_CHECK_OK(client_.Contains(object_id, &has_object));\ndiff --git a/cpp/src/plasma/test/serialization_tests.cc b/cpp/src/plasma/test/serialization_tests.cc\nindex 085ae97db9..66d651d292 100644\n--- a/cpp/src/plasma/test/serialization_tests.cc\n+++ b/cpp/src/plasma/test/serialization_tests.cc\n@@ -254,44 +254,6 @@ TEST(PlasmaSerialization, DeleteReply) {\n   close(fd);\n }\n \n-TEST(PlasmaSerialization, StatusRequest) {\n-  int fd = create_temp_file();\n-  constexpr int64_t num_objects = 2;\n-  ObjectID object_ids[num_objects];\n-  object_ids[0] = random_object_id();\n-  object_ids[1] = random_object_id();\n-  ARROW_CHECK_OK(SendStatusRequest(fd, object_ids, num_objects));\n-  std::vector<uint8_t> data =\n-      read_message_from_file(fd, MessageType::PlasmaStatusRequest);\n-  ObjectID object_ids_read[num_objects];\n-  ARROW_CHECK_OK(\n-      ReadStatusRequest(data.data(), data.size(), object_ids_read, num_objects));\n-  ASSERT_EQ(object_ids[0], object_ids_read[0]);\n-  ASSERT_EQ(object_ids[1], object_ids_read[1]);\n-  close(fd);\n-}\n-\n-TEST(PlasmaSerialization, StatusReply) {\n-  int fd = create_temp_file();\n-  ObjectID object_ids[2];\n-  object_ids[0] = random_object_id();\n-  object_ids[1] = random_object_id();\n-  int object_statuses[2] = {42, 43};\n-  ARROW_CHECK_OK(SendStatusReply(fd, object_ids, object_statuses, 2));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaStatusReply);\n-  int64_t num_objects = ReadStatusReply_num_objects(data.data(), data.size());\n-\n-  std::vector<ObjectID> object_ids_read(num_objects);\n-  std::vector<int> object_statuses_read(num_objects);\n-  ARROW_CHECK_OK(ReadStatusReply(data.data(), data.size(), object_ids_read.data(),\n-                                 object_statuses_read.data(), num_objects));\n-  ASSERT_EQ(object_ids[0], object_ids_read[0]);\n-  ASSERT_EQ(object_ids[1], object_ids_read[1]);\n-  ASSERT_EQ(object_statuses[0], object_statuses_read[0]);\n-  ASSERT_EQ(object_statuses[1], object_statuses_read[1]);\n-  close(fd);\n-}\n-\n TEST(PlasmaSerialization, EvictRequest) {\n   int fd = create_temp_file();\n   int64_t num_bytes = 111;\n@@ -314,84 +276,6 @@ TEST(PlasmaSerialization, EvictReply) {\n   close(fd);\n }\n \n-TEST(PlasmaSerialization, FetchRequest) {\n-  int fd = create_temp_file();\n-  ObjectID object_ids[2];\n-  object_ids[0] = random_object_id();\n-  object_ids[1] = random_object_id();\n-  ARROW_CHECK_OK(SendFetchRequest(fd, object_ids, 2));\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaFetchRequest);\n-  std::vector<ObjectID> object_ids_read;\n-  ARROW_CHECK_OK(ReadFetchRequest(data.data(), data.size(), object_ids_read));\n-  ASSERT_EQ(object_ids[0], object_ids_read[0]);\n-  ASSERT_EQ(object_ids[1], object_ids_read[1]);\n-  close(fd);\n-}\n-\n-TEST(PlasmaSerialization, WaitRequest) {\n-  int fd = create_temp_file();\n-  const int num_objects_in = 2;\n-  ObjectRequest object_requests_in[num_objects_in] = {\n-      ObjectRequest({random_object_id(), ObjectRequestType::PLASMA_QUERY_ANYWHERE,\n-                     ObjectLocation::Local}),\n-      ObjectRequest({random_object_id(), ObjectRequestType::PLASMA_QUERY_LOCAL,\n-                     ObjectLocation::Local})};\n-  const int num_ready_objects_in = 1;\n-  int64_t timeout_ms = 1000;\n-\n-  ARROW_CHECK_OK(SendWaitRequest(fd, &object_requests_in[0], num_objects_in,\n-                                 num_ready_objects_in, timeout_ms));\n-  /* Read message back. */\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaWaitRequest);\n-  int num_ready_objects_out;\n-  int64_t timeout_ms_read;\n-  ObjectRequestMap object_requests_out;\n-  ARROW_CHECK_OK(ReadWaitRequest(data.data(), data.size(), object_requests_out,\n-                                 &timeout_ms_read, &num_ready_objects_out));\n-  ASSERT_EQ(num_objects_in, object_requests_out.size());\n-  ASSERT_EQ(num_ready_objects_out, num_ready_objects_in);\n-  for (int i = 0; i < num_objects_in; i++) {\n-    const ObjectID& object_id = object_requests_in[i].object_id;\n-    ASSERT_EQ(1, object_requests_out.count(object_id));\n-    const auto& entry = object_requests_out.find(object_id);\n-    ASSERT_TRUE(entry != object_requests_out.end());\n-    ASSERT_EQ(entry->second.object_id, object_requests_in[i].object_id);\n-    ASSERT_EQ(entry->second.type, object_requests_in[i].type);\n-  }\n-  close(fd);\n-}\n-\n-TEST(PlasmaSerialization, WaitReply) {\n-  int fd = create_temp_file();\n-  const int num_objects_in = 2;\n-  /* Create a map with two ObjectRequests in it. */\n-  ObjectRequestMap objects_in(num_objects_in);\n-  ObjectID id1 = random_object_id();\n-  objects_in[id1] =\n-      ObjectRequest({id1, ObjectRequestType::PLASMA_QUERY_LOCAL, ObjectLocation::Local});\n-  ObjectID id2 = random_object_id();\n-  objects_in[id2] = ObjectRequest(\n-      {id2, ObjectRequestType::PLASMA_QUERY_LOCAL, ObjectLocation::Nonexistent});\n-\n-  ARROW_CHECK_OK(SendWaitReply(fd, objects_in, num_objects_in));\n-  /* Read message back. */\n-  std::vector<uint8_t> data = read_message_from_file(fd, MessageType::PlasmaWaitReply);\n-  ObjectRequest objects_out[2];\n-  int num_objects_out;\n-  ARROW_CHECK_OK(\n-      ReadWaitReply(data.data(), data.size(), &objects_out[0], &num_objects_out));\n-  ASSERT_EQ(num_objects_in, num_objects_out);\n-  for (int i = 0; i < num_objects_out; i++) {\n-    /* Each object request must appear exactly once. */\n-    ASSERT_EQ(objects_in.count(objects_out[i].object_id), 1);\n-    const auto& entry = objects_in.find(objects_out[i].object_id);\n-    ASSERT_TRUE(entry != objects_in.end());\n-    ASSERT_EQ(entry->second.object_id, objects_out[i].object_id);\n-    ASSERT_EQ(entry->second.location, objects_out[i].location);\n-  }\n-  close(fd);\n-}\n-\n TEST(PlasmaSerialization, DataRequest) {\n   int fd = create_temp_file();\n   ObjectID object_id1 = random_object_id();\ndiff --git a/docs/source/python/plasma.rst b/docs/source/python/plasma.rst\nindex 3df68eff59..660c5fbba7 100644\n--- a/docs/source/python/plasma.rst\n+++ b/docs/source/python/plasma.rst\n@@ -60,7 +60,7 @@ socket name:\n .. code-block:: python\n \n   import pyarrow.plasma as plasma\n-  client = plasma.connect(\"/tmp/plasma\", \"\")\n+  client = plasma.connect(\"/tmp/plasma\")\n \n If the following error occurs from running the above Python code, that\n means that either the socket given is incorrect, or the ``./plasma_store`` is\n@@ -68,7 +68,7 @@ not currently running. Check to see if the Plasma store is still running.\n \n .. code-block:: shell\n \n-  >>> client = plasma.connect(\"/tmp/plasma\", \"\")\n+  >>> client = plasma.connect(\"/tmp/plasma\")\n   Connection to socket failed for pathname /tmp/plasma\n   Could not connect to socket /tmp/plasma\n \n@@ -179,7 +179,7 @@ the object buffer.\n \n   # Create a different client. Note that this second client could be\n   # created in the same or in a separate, concurrent Python session.\n-  client2 = plasma.connect(\"/tmp/plasma\", \"\")\n+  client2 = plasma.connect(\"/tmp/plasma\")\n \n   # Get the object in the second client. This blocks until the object has been sealed.\n   object_id2 = plasma.ObjectID(20 * b\"a\")\n@@ -221,7 +221,7 @@ of the object info might change in the future):\n   import pyarrow.plasma as plasma\n   import time\n \n-  client = plasma.connect(\"/tmp/plasma\", \"\")\n+  client = plasma.connect(\"/tmp/plasma\")\n \n   client.put(\"hello, world\")\n   # Sleep a little so we get different creation times\n@@ -452,7 +452,7 @@ You can test this with the following script:\n   import pyarrow.plasma as plasma\n   import time\n \n-  client = plasma.connect(\"/tmp/plasma\", \"\")\n+  client = plasma.connect(\"/tmp/plasma\")\n \n   data = np.random.randn(100000000)\n   tensor = pa.Tensor.from_numpy(data)\ndiff --git a/java/plasma/src/main/java/org/apache/arrow/plasma/ObjectStoreLink.java b/java/plasma/src/main/java/org/apache/arrow/plasma/ObjectStoreLink.java\nindex 3b67bc08ec..8d6eec02e7 100644\n--- a/java/plasma/src/main/java/org/apache/arrow/plasma/ObjectStoreLink.java\n+++ b/java/plasma/src/main/java/org/apache/arrow/plasma/ObjectStoreLink.java\n@@ -79,16 +79,6 @@\n    */\n   List<ObjectStoreData> get(byte[][] objectIds, int timeoutMs);\n \n-  /**\n-   * Wait until <tt>numReturns</tt> objects in <tt>objectIds</tt> are ready.\n-   *\n-   * @param objectIds List of object IDs to wait for.\n-   * @param timeoutMs Return to the caller after <tt>timeoutMs</tt> milliseconds.\n-   * @param numReturns We are waiting for this number of objects to be ready.\n-   * @return List of object IDs that are ready\n-   */\n-  List<byte[]> wait(byte[][] objectIds, int timeoutMs, int numReturns);\n-\n   /**\n    * Compute the hash of an object in the object store.\n    *\n@@ -98,23 +88,6 @@\n    */\n   byte[] hash(byte[] objectId);\n \n-  /**\n-   * Fetch the object with the given ID from other plasma manager instances.\n-   *\n-   * @param objectId The object ID used to identify the object.\n-   */\n-  default void fetch(byte[] objectId) {\n-    byte[][] objectIds = {objectId};\n-    fetch(objectIds);\n-  }\n-\n-  /**\n-   * Fetch the objects with the given IDs from other plasma manager instances.\n-   *\n-   * @param objectIds List of object IDs used to identify the objects.\n-   */\n-  void fetch(byte[][] objectIds);\n-\n   /**\n    * Evict some objects to recover given count of bytes.\n    *\ndiff --git a/java/plasma/src/main/java/org/apache/arrow/plasma/PlasmaClient.java b/java/plasma/src/main/java/org/apache/arrow/plasma/PlasmaClient.java\nindex db1f35e164..d69b54df05 100644\n--- a/java/plasma/src/main/java/org/apache/arrow/plasma/PlasmaClient.java\n+++ b/java/plasma/src/main/java/org/apache/arrow/plasma/PlasmaClient.java\n@@ -81,34 +81,11 @@ public void put(byte[] objectId, byte[] value, byte[] metadata) {\n     return ret;\n   }\n \n-  @Override\n-  public List<byte[]> wait(byte[][] objectIds, int timeoutMs, int numReturns) {\n-    byte[][] readys = PlasmaClientJNI.wait(conn, objectIds, timeoutMs, numReturns);\n-\n-    List<byte[]> ret = new ArrayList<>();\n-    for (byte[] ready : readys) {\n-      for (byte[] id : objectIds) {\n-        if (Arrays.equals(ready, id)) {\n-          ret.add(id);\n-          break;\n-        }\n-      }\n-    }\n-\n-    assert (ret.size() == readys.length);\n-    return ret;\n-  }\n-\n   @Override\n   public byte[] hash(byte[] objectId) {\n     return PlasmaClientJNI.hash(conn, objectId);\n   }\n \n-  @Override\n-  public void fetch(byte[][] objectIds) {\n-    PlasmaClientJNI.fetch(conn, objectIds);\n-  }\n-\n   @Override\n   public List<ObjectStoreData> get(byte[][] objectIds, int timeoutMs) {\n     ByteBuffer[][] bufs = PlasmaClientJNI.get(conn, objectIds, timeoutMs);\ndiff --git a/python/benchmarks/plasma.py b/python/benchmarks/plasma.py\nindex 7cefcdffad..398ec72561 100644\n--- a/python/benchmarks/plasma.py\n+++ b/python/benchmarks/plasma.py\n@@ -32,7 +32,7 @@ def setup(self, size):\n         self.plasma_store_ctx = plasma.start_plasma_store(\n             plasma_store_memory=10**9)\n         plasma_store_name, p = self.plasma_store_ctx.__enter__()\n-        self.plasma_client = plasma.connect(plasma_store_name, \"\", 64)\n+        self.plasma_client = plasma.connect(plasma_store_name)\n \n         self.data = np.random.randn(size // 8)\n \n@@ -52,7 +52,7 @@ def setup(self):\n         self.plasma_store_ctx = plasma.start_plasma_store(\n             plasma_store_memory=10**9)\n         plasma_store_name, p = self.plasma_store_ctx.__enter__()\n-        self.plasma_client = plasma.connect(plasma_store_name, \"\", 64)\n+        self.plasma_client = plasma.connect(plasma_store_name)\n \n     def teardown(self):\n         self.plasma_store_ctx.__exit__(None, None, None)\ndiff --git a/python/examples/plasma/sorting/sort_df.py b/python/examples/plasma/sorting/sort_df.py\nindex 2e4df589ee..2a51759a67 100644\n--- a/python/examples/plasma/sorting/sort_df.py\n+++ b/python/examples/plasma/sorting/sort_df.py\n@@ -49,7 +49,7 @@\n # Connect to clients\n def connect():\n     global client\n-    client = plasma.connect('/tmp/store', '', 0)\n+    client = plasma.connect('/tmp/store')\n     np.random.seed(int(time.time() * 10e7) % 10000000)\n \n \ndiff --git a/python/pyarrow/_plasma.pyx b/python/pyarrow/_plasma.pyx\nindex f7db3b4e0f..cfaa39c96e 100644\n--- a/python/pyarrow/_plasma.pyx\n+++ b/python/pyarrow/_plasma.pyx\n@@ -63,11 +63,6 @@ cdef extern from \"plasma/common.h\" nogil:\n         @staticmethod\n         int64_t size()\n \n-    cdef struct CObjectRequest\" plasma::ObjectRequest\":\n-        CUniqueID object_id\n-        int type\n-        int location\n-\n     cdef enum CObjectState\" plasma::ObjectState\":\n         PLASMA_CREATED\" plasma::ObjectState::PLASMA_CREATED\"\n         PLASMA_SEALED\" plasma::ObjectState::PLASMA_SEALED\"\n@@ -92,14 +87,6 @@ cdef extern from \"plasma/common.h\" nogil:\n cdef extern from \"plasma/common.h\":\n     cdef int64_t kDigestSize\" plasma::kDigestSize\"\n \n-    cdef enum ObjectRequestType:\n-        PLASMA_QUERY_LOCAL\"plasma::ObjectRequestType::PLASMA_QUERY_LOCAL\",\n-        PLASMA_QUERY_ANYWHERE\"plasma::ObjectRequestType::PLASMA_QUERY_ANYWHERE\"\n-\n-    cdef enum ObjectLocation:\n-        ObjectStatusLocal\"plasma::ObjectLocation::Local\"\n-        ObjectStatusRemote\"plasma::ObjectLocation::Remote\"\n-\n cdef extern from \"plasma/client.h\" nogil:\n \n     cdef cppclass CPlasmaClient\" plasma::PlasmaClient\":\n@@ -143,16 +130,6 @@ cdef extern from \"plasma/client.h\" nogil:\n \n         CStatus Disconnect()\n \n-        CStatus Fetch(int num_object_ids, const CUniqueID* object_ids)\n-\n-        CStatus Wait(int64_t num_object_requests,\n-                     CObjectRequest* object_requests,\n-                     int num_ready_objects, int64_t timeout_ms,\n-                     int* num_objects_ready)\n-\n-        CStatus Transfer(const char* addr, int port,\n-                         const CUniqueID& object_id)\n-\n         CStatus Delete(const c_vector[CUniqueID] object_ids)\n \n cdef extern from \"plasma/client.h\" nogil:\n@@ -285,13 +262,11 @@ cdef class PlasmaClient:\n         shared_ptr[CPlasmaClient] client\n         int notification_fd\n         c_string store_socket_name\n-        c_string manager_socket_name\n \n     def __cinit__(self):\n         self.client.reset(new CPlasmaClient())\n         self.notification_fd = -1\n         self.store_socket_name = b\"\"\n-        self.manager_socket_name = b\"\"\n \n     cdef _get_object_buffers(self, object_ids, int64_t timeout_ms,\n                              c_vector[CObjectBuffer]* result):\n@@ -315,10 +290,6 @@ cdef class PlasmaClient:\n     def store_socket_name(self):\n         return self.store_socket_name.decode()\n \n-    @property\n-    def manager_socket_name(self):\n-        return self.manager_socket_name.decode()\n-\n     def create(self, ObjectID object_id, int64_t data_size,\n                c_string metadata=b\"\"):\n         \"\"\"\n@@ -642,95 +613,6 @@ cdef class PlasmaClient:\n             check_status(self.client.get().Evict(num_bytes, num_bytes_evicted))\n         return num_bytes_evicted\n \n-    def transfer(self, address, int port, ObjectID object_id):\n-        \"\"\"\n-        Transfer local object with id object_id to another plasma instance\n-\n-        Parameters\n-        ----------\n-        addr : str\n-            IPv4 address of the plasma instance the object is sent to.\n-        port : int\n-            Port number of the plasma instance the object is sent to.\n-        object_id : str\n-            A string used to identify an object.\n-        \"\"\"\n-        cdef c_string addr = address.encode()\n-        with nogil:\n-            check_status(self.client.get()\n-                         .Transfer(addr.c_str(), port, object_id.data))\n-\n-    def fetch(self, object_ids):\n-        \"\"\"\n-        Fetch the objects with the given IDs from other plasma managers.\n-\n-        Parameters\n-        ----------\n-        object_ids : list\n-            A list of strings used to identify the objects.\n-        \"\"\"\n-        cdef c_vector[CUniqueID] ids\n-        cdef ObjectID object_id\n-        for object_id in object_ids:\n-            ids.push_back(object_id.data)\n-        with nogil:\n-            check_status(self.client.get().Fetch(ids.size(), ids.data()))\n-\n-    def wait(self, object_ids, int64_t timeout=PLASMA_WAIT_TIMEOUT,\n-             int num_returns=1):\n-        \"\"\"\n-        Wait until num_returns objects in object_ids are ready.\n-        Currently, the object ID arguments to wait must be unique.\n-\n-        Parameters\n-        ----------\n-        object_ids : list\n-            List of object IDs to wait for.\n-        timeout :int\n-            Return to the caller after timeout milliseconds.\n-        num_returns : int\n-            We are waiting for this number of objects to be ready.\n-\n-        Returns\n-        -------\n-        list\n-            List of object IDs that are ready.\n-        list\n-            List of object IDs we might still wait on.\n-        \"\"\"\n-        # Check that the object ID arguments are unique. The plasma manager\n-        # currently crashes if given duplicate object IDs.\n-        if len(object_ids) != len(set(object_ids)):\n-            raise Exception(\"Wait requires a list of unique object IDs.\")\n-        cdef int64_t num_object_requests = len(object_ids)\n-        cdef c_vector[CObjectRequest] object_requests = (\n-            c_vector[CObjectRequest](num_object_requests))\n-        cdef int num_objects_ready = 0\n-        cdef ObjectID object_id\n-        for i, object_id in enumerate(object_ids):\n-            object_requests[i].object_id = object_id.data\n-            object_requests[i].type = PLASMA_QUERY_ANYWHERE\n-        with nogil:\n-            check_status(self.client.get().Wait(num_object_requests,\n-                                                object_requests.data(),\n-                                                num_returns, timeout,\n-                                                &num_objects_ready))\n-        cdef int num_to_return = min(num_objects_ready, num_returns)\n-        ready_ids = []\n-        waiting_ids = set(object_ids)\n-        cdef int num_returned = 0\n-        for i in range(len(object_ids)):\n-            if num_returned == num_to_return:\n-                break\n-            if (object_requests[i].location == ObjectStatusLocal or\n-                    object_requests[i].location == ObjectStatusRemote):\n-                ready_ids.append(\n-                    ObjectID(object_requests[i].object_id.binary()))\n-                waiting_ids.discard(\n-                    ObjectID(object_requests[i].object_id.binary()))\n-                num_returned += 1\n-        return ready_ids, list(waiting_ids)\n-\n     def subscribe(self):\n         \"\"\"Subscribe to notifications about sealed objects.\"\"\"\n         with nogil:\n@@ -873,7 +755,7 @@ cdef class PlasmaClient:\n         return result\n \n \n-def connect(store_socket_name, manager_socket_name, int release_delay=0,\n+def connect(store_socket_name, manager_socket_name=None, int release_delay=0,\n             int num_retries=-1):\n     \"\"\"\n     Return a new PlasmaClient that is connected a plasma store and\n@@ -884,22 +766,24 @@ def connect(store_socket_name, manager_socket_name, int release_delay=0,\n     store_socket_name : str\n         Name of the socket the plasma store is listening at.\n     manager_socket_name : str\n-        Name of the socket the plasma manager is listening at.\n+        This parameter is deprecated and has no effect.\n     release_delay : int\n         This parameter is deprecated and has no effect.\n     num_retries : int, default -1\n         Number of times to try to connect to plasma store. Default value of -1\n         uses the default (50)\n     \"\"\"\n+    if manager_socket_name is not None:\n+        warnings.warn(\n+            \"manager_socket_name in PlasmaClient.connect is deprecated\",\n+            FutureWarning)\n     cdef PlasmaClient result = PlasmaClient()\n     result.store_socket_name = store_socket_name.encode()\n-    result.manager_socket_name = manager_socket_name.encode()\n     if release_delay != 0:\n         warnings.warn(\"release_delay in PlasmaClient.connect is deprecated\",\n                       FutureWarning)\n     with nogil:\n         check_status(result.client.get()\n-                     .Connect(result.store_socket_name,\n-                              result.manager_socket_name,\n+                     .Connect(result.store_socket_name, b\"\",\n                               release_delay, num_retries))\n     return result\ndiff --git a/python/pyarrow/tensorflow/plasma_op.cc b/python/pyarrow/tensorflow/plasma_op.cc\nindex 4e6449adfc..852be33938 100644\n--- a/python/pyarrow/tensorflow/plasma_op.cc\n+++ b/python/pyarrow/tensorflow/plasma_op.cc\n@@ -71,13 +71,10 @@ class TensorToPlasmaOp : public tf::AsyncOpKernel {\n   explicit TensorToPlasmaOp(tf::OpKernelConstruction* context) : tf::AsyncOpKernel(context) {\n     OP_REQUIRES_OK(context, context->GetAttr(\"plasma_store_socket_name\",\n                                              &plasma_store_socket_name_));\n-    OP_REQUIRES_OK(context, context->GetAttr(\"plasma_manager_socket_name\",\n-                                             &plasma_manager_socket_name_));\n     tf::mutex_lock lock(mu_);\n     if (!connected_) {\n       VLOG(1) << \"Connecting to Plasma...\";\n-      ARROW_CHECK_OK(client_.Connect(plasma_store_socket_name_,\n-                                     plasma_manager_socket_name_));\n+      ARROW_CHECK_OK(client_.Connect(plasma_store_socket_name_));\n       VLOG(1) << \"Connected!\";\n       connected_ = true;\n     }\n@@ -226,7 +223,6 @@ class TensorToPlasmaOp : public tf::AsyncOpKernel {\n \n  private:\n   std::string plasma_store_socket_name_;\n-  std::string plasma_manager_socket_name_;\n \n   tf::mutex mu_;\n   bool connected_ = false;\n@@ -243,13 +239,10 @@ class PlasmaToTensorOp : public tf::AsyncOpKernel {\n   explicit PlasmaToTensorOp(tf::OpKernelConstruction* context) : tf::AsyncOpKernel(context) {\n     OP_REQUIRES_OK(context, context->GetAttr(\"plasma_store_socket_name\",\n                                              &plasma_store_socket_name_));\n-    OP_REQUIRES_OK(context, context->GetAttr(\"plasma_manager_socket_name\",\n-                                             &plasma_manager_socket_name_));\n     tf::mutex_lock lock(mu_);\n     if (!connected_) {\n       VLOG(1) << \"Connecting to Plasma...\";\n-      ARROW_CHECK_OK(client_.Connect(plasma_store_socket_name_,\n-                                     plasma_manager_socket_name_));\n+      ARROW_CHECK_OK(client_.Connect(plasma_store_socket_name_));\n       VLOG(1) << \"Connected!\";\n       connected_ = true;\n     }\n@@ -364,7 +357,6 @@ class PlasmaToTensorOp : public tf::AsyncOpKernel {\n \n  private:\n   std::string plasma_store_socket_name_;\n-  std::string plasma_manager_socket_name_;\n \n   tf::mutex mu_;\n   bool connected_ = false;\n@@ -375,8 +367,7 @@ REGISTER_OP(\"TensorToPlasma\")\n     .Input(\"input_tensor: dtypes\")\n     .Input(\"plasma_object_id: string\")\n     .Attr(\"dtypes: list(type)\")\n-    .Attr(\"plasma_store_socket_name: string\")\n-    .Attr(\"plasma_manager_socket_name: string\");\n+    .Attr(\"plasma_store_socket_name: string\");\n \n REGISTER_KERNEL_BUILDER(Name(\"TensorToPlasma\").Device(tf::DEVICE_CPU),\n                         TensorToPlasmaOp<CPUDevice>);\n@@ -389,8 +380,7 @@ REGISTER_OP(\"PlasmaToTensor\")\n     .Input(\"plasma_object_id: string\")\n     .Output(\"tensor: dtype\")\n     .Attr(\"dtype: type\")\n-    .Attr(\"plasma_store_socket_name: string\")\n-    .Attr(\"plasma_manager_socket_name: string\");\n+    .Attr(\"plasma_store_socket_name: string\");\n \n REGISTER_KERNEL_BUILDER(Name(\"PlasmaToTensor\").Device(tf::DEVICE_CPU),\n                         PlasmaToTensorOp<CPUDevice>);\ndiff --git a/python/pyarrow/tests/test_plasma.py b/python/pyarrow/tests/test_plasma.py\nindex 66449e6dba..05375d7b65 100644\n--- a/python/pyarrow/tests/test_plasma.py\n+++ b/python/pyarrow/tests/test_plasma.py\n@@ -121,8 +121,8 @@ def setup_method(self, test_method):\n             use_one_memory_mapped_file=use_one_memory_mapped_file)\n         self.plasma_store_name, self.p = self.plasma_store_ctx.__enter__()\n         # Connect to Plasma.\n-        self.plasma_client = plasma.connect(self.plasma_store_name, \"\")\n-        self.plasma_client2 = plasma.connect(self.plasma_store_name, \"\")\n+        self.plasma_client = plasma.connect(self.plasma_store_name)\n+        self.plasma_client2 = plasma.connect(self.plasma_store_name)\n \n     def teardown_method(self, test_method):\n         try:\n@@ -147,7 +147,7 @@ def test_connection_failure_raises_exception(self):\n         import pyarrow.plasma as plasma\n         # ARROW-1264\n         with pytest.raises(IOError):\n-            plasma.connect('unknown-store-name', '', 0, 1)\n+            plasma.connect('unknown-store-name', num_retries=1)\n \n     def test_create(self):\n         # Create an object id string.\n@@ -860,7 +860,7 @@ def test_client_death_during_get(self):\n         object_id = random_object_id()\n \n         def client_blocked_in_get(plasma_store_name):\n-            client = plasma.connect(self.plasma_store_name, \"\", 0)\n+            client = plasma.connect(self.plasma_store_name)\n             # Try to get an object ID that doesn't exist. This should block.\n             client.get([object_id])\n \n@@ -889,7 +889,7 @@ def test_client_getting_multiple_objects(self):\n         object_ids = [random_object_id() for _ in range(10)]\n \n         def client_get_multiple(plasma_store_name):\n-            client = plasma.connect(self.plasma_store_name, \"\", 0)\n+            client = plasma.connect(self.plasma_store_name)\n             # Try to get an object ID that doesn't exist. This should block.\n             client.get(object_ids)\n \n@@ -948,7 +948,7 @@ def test_use_huge_pages():\n             plasma_store_memory=2*10**9,\n             plasma_directory=\"/mnt/hugepages\",\n             use_hugepages=True) as (plasma_store_name, p):\n-        plasma_client = plasma.connect(plasma_store_name, \"\")\n+        plasma_client = plasma.connect(plasma_store_name)\n         create_object(plasma_client, 10**8)\n \n \n@@ -962,7 +962,7 @@ def test_plasma_client_sharing():\n     with plasma.start_plasma_store(\n             plasma_store_memory=DEFAULT_PLASMA_STORE_MEMORY) \\\n             as (plasma_store_name, p):\n-        plasma_client = plasma.connect(plasma_store_name, \"\")\n+        plasma_client = plasma.connect(plasma_store_name)\n         object_id = plasma_client.put(np.zeros(3))\n         buf = plasma_client.get(object_id)\n         del plasma_client\n@@ -977,7 +977,7 @@ def test_plasma_list():\n     with plasma.start_plasma_store(\n             plasma_store_memory=DEFAULT_PLASMA_STORE_MEMORY) \\\n             as (plasma_store_name, p):\n-        plasma_client = plasma.connect(plasma_store_name, \"\", 0)\n+        plasma_client = plasma.connect(plasma_store_name)\n \n         # Test sizes\n         u, _, _ = create_object(plasma_client, 11, metadata_size=7, seal=False)\ndiff --git a/python/pyarrow/tests/test_plasma_tf_op.py b/python/pyarrow/tests/test_plasma_tf_op.py\nindex 51e8b283e0..e239055209 100644\n--- a/python/pyarrow/tests/test_plasma_tf_op.py\n+++ b/python/pyarrow/tests/test_plasma_tf_op.py\n@@ -37,15 +37,13 @@ def ToPlasma():\n         return plasma.tf_plasma_op.tensor_to_plasma(\n             [data_tensor, ones_tensor],\n             object_id,\n-            plasma_store_socket_name=plasma_store_name,\n-            plasma_manager_socket_name=\"\")\n+            plasma_store_socket_name=plasma_store_name)\n \n     def FromPlasma():\n         return plasma.tf_plasma_op.plasma_to_tensor(\n             object_id,\n             dtype=tf.as_dtype(dtype),\n-            plasma_store_socket_name=plasma_store_name,\n-            plasma_manager_socket_name=\"\")\n+            plasma_store_socket_name=plasma_store_name)\n \n     with tf.device(FORCE_DEVICE):\n         to_plasma = ToPlasma()\n@@ -94,7 +92,7 @@ def test_plasma_tf_op(use_gpu=False):\n         pytest.skip(\"TensorFlow Op not found\")\n \n     with plasma.start_plasma_store(10**8) as (plasma_store_name, p):\n-        client = plasma.connect(plasma_store_name, \"\")\n+        client = plasma.connect(plasma_store_name)\n         for dtype in [np.float32, np.float64,\n                       np.int8, np.int16, np.int32, np.int64]:\n             run_tensorflow_test_with_dtype(tf, plasma, plasma_store_name,\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-14T15:27:31.941+0000",
                    "updated": "2018-12-14T15:27:31.941+0000",
                    "started": "2018-12-14T15:27:31.941+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175375",
                    "issueId": "13204153"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204153/worklog/175401",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz commented on issue #3167: ARROW-4015: [Plasma] remove unused interfaces for plasma manager\nURL: https://github.com/apache/arrow/pull/3167#issuecomment-447361128\n \n \n   @zhijunfu Thanks a lot for fixing this!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-14T15:36:18.362+0000",
                    "updated": "2018-12-14T15:36:18.362+0000",
                    "started": "2018-12-14T15:36:18.361+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "175401",
                    "issueId": "13204153"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 6000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@128b00bd[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@700a4d24[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@57d26863[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@75136cd0[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1a10aa78[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@37c77e03[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@739289e8[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@1d891ea6[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2553405[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@eee752a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@69d460d6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3cfd2f64[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 6000,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Dec 14 15:27:24 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-12-14T15:27:24.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-4015/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2018-12-13T05:59:37.000+0000",
        "updated": "2018-12-14T15:36:18.000+0000",
        "timeoriginalestimate": null,
        "description": "[https://github.com/apache/arrow/issues/3154]\r\n\r\nIn legacy ray, interacting with remote plasma stores is done via plasma manager, which is part of ray, and plasma has a few interfaces to support it - namely Fetch() and Wait().\r\nCurrently the legacy ray code has already been removed, and the new raylet uses object manager to interface with remote machine, and these legacy plasma interfaces are no longer used. I think we could remove these legacy interfaces to cleanup code and avoid confusion.\r\n\r\n\u00a0",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 6000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Plasma] remove legacy interfaces for plasma manager",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13204153/comment/16721525",
                    "id": "16721525",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
                        "name": "pcmoritz",
                        "key": "pcmoritz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Philipp Moritz",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 3167\n[https://github.com/apache/arrow/pull/3167]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
                        "name": "pcmoritz",
                        "key": "pcmoritz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Philipp Moritz",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-12-14T15:27:24.205+0000",
                    "updated": "2018-12-14T15:27:24.205+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|s01gzk:",
        "customfield_12314139": null
    }
}