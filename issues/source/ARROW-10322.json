{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13335691",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691",
    "key": "ARROW-10322",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348647",
                "id": "12348647",
                "name": "1.0.1",
                "archived": false,
                "released": true,
                "releaseDate": "2020-08-21"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12606166",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12606166",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13306325",
                    "key": "ARROW-8876",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13306325",
                    "fields": {
                        "summary": "[C++] Implement casts from date types to Timestamp",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12606165",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12606165",
                "type": {
                    "id": "12310660",
                    "name": "Completes",
                    "inward": "is fixed by",
                    "outward": "fixes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310660"
                },
                "outwardIssue": {
                    "id": "13329477",
                    "key": "ARROW-10097",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13329477",
                    "fields": {
                        "summary": "[C++] Persist SetLookupState in between usages of IsIn when filtering dataset batches",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12605093",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12605093",
                "type": {
                    "id": "12310051",
                    "name": "Supercedes",
                    "inward": "is superceded by",
                    "outward": "supercedes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"
                },
                "outwardIssue": {
                    "id": "13326519",
                    "key": "ARROW-9945",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13326519",
                    "fields": {
                        "summary": "[C++][Dataset] Refactor Expression::Assume to return a Result",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 64800,
            "total": 64800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 64800,
            "total": 64800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10322/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 108,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/522935",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz opened a new pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-10T23:02:50.099+0000",
                    "updated": "2020-12-10T23:02:50.099+0000",
                    "started": "2020-12-10T23:02:50.098+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "522935",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/522937",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#issuecomment-742856776\n\n\n   https://issues.apache.org/jira/browse/ARROW-10322\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-10T23:06:47.577+0000",
                    "updated": "2020-12-10T23:06:47.577+0000",
                    "started": "2020-12-10T23:06:47.577+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "522937",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/523269",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r541147763\n\n\n\n##########\nFile path: r/src/expression.cpp\n##########\n@@ -19,93 +19,98 @@\n \n #if defined(ARROW_R_WITH_ARROW)\n \n+#include <arrow/compute/api_scalar.h>\n #include <arrow/dataset/api.h>\n namespace ds = ::arrow::dataset;\n \n+std::shared_ptr<ds::Expression> Share(ds::Expression expr) {\n+  return std::make_shared<ds::Expression>(std::move(expr));\n+}\n+\n\nReview comment:\n       Would it be appropriate in this PR to add the `compute::CallFunction` equivalent for dataset expressions? Before I can add any new expressions, we'll need it. \r\n   \r\n   I'm guessing it looks like:\r\n   \r\n   ```\r\n   std::shared_ptr<ds::Expression> dataset___expr(std::string func_name, cpp11::list args, cpp11::list options)\r\n   ```\r\n   \r\n   and calls `ds::call()` inside it?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-11T18:35:17.715+0000",
                    "updated": "2020-12-11T18:35:17.715+0000",
                    "started": "2020-12-11T18:35:17.715+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "523269",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/523270",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r541148851\n\n\n\n##########\nFile path: r/src/expression.cpp\n##########\n@@ -19,93 +19,98 @@\n \n #if defined(ARROW_R_WITH_ARROW)\n \n+#include <arrow/compute/api_scalar.h>\n #include <arrow/dataset/api.h>\n namespace ds = ::arrow::dataset;\n \n+std::shared_ptr<ds::Expression> Share(ds::Expression expr) {\n+  return std::make_shared<ds::Expression>(std::move(expr));\n+}\n+\n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__field_ref(std::string name) {\n-  return ds::field_ref(std::move(name));\n+  return Share(ds::field_ref(std::move(name)));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__equal(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<ds::Expression>& rhs) {\n-  return ds::equal(lhs, rhs);\n+  return Share(ds::equal(*lhs, *rhs));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__not_equal(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<ds::Expression>& rhs) {\n-  return ds::not_equal(lhs, rhs);\n+  return Share(ds::not_equal(*lhs, *rhs));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__greater(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<ds::Expression>& rhs) {\n-  return ds::greater(lhs, rhs);\n+  return Share(ds::greater(*lhs, *rhs));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__greater_equal(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<ds::Expression>& rhs) {\n-  return ds::greater_equal(lhs, rhs);\n+  return Share(ds::greater_equal(*lhs, *rhs));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__less(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<ds::Expression>& rhs) {\n-  return ds::less(lhs, rhs);\n+  return Share(ds::less(*lhs, *rhs));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__less_equal(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<ds::Expression>& rhs) {\n-  return ds::less_equal(lhs, rhs);\n+  return Share(ds::less_equal(*lhs, *rhs));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__in(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<arrow::Array>& rhs) {\n-  return lhs->In(rhs).Copy();\n+  return Share(ds::call(\"is_in\", {*lhs}, arrow::compute::SetLookupOptions{rhs}));\n\nReview comment:\n       In the compute module, there is a `binary` version of `is_in` that takes `{lhs, rhs}` instead of requiring you to pass rhs in options.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-11T18:37:12.900+0000",
                    "updated": "2020-12-11T18:37:12.900+0000",
                    "started": "2020-12-11T18:37:12.900+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "523270",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/523357",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r541472214\n\n\n\n##########\nFile path: r/src/expression.cpp\n##########\n@@ -19,93 +19,98 @@\n \n #if defined(ARROW_R_WITH_ARROW)\n \n+#include <arrow/compute/api_scalar.h>\n #include <arrow/dataset/api.h>\n namespace ds = ::arrow::dataset;\n \n+std::shared_ptr<ds::Expression> Share(ds::Expression expr) {\n+  return std::make_shared<ds::Expression>(std::move(expr));\n+}\n+\n\nReview comment:\n       I'll add that, thanks\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-12T01:47:36.509+0000",
                    "updated": "2020-12-12T01:47:36.509+0000",
                    "started": "2020-12-12T01:47:36.508+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "523357",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/523923",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r542462619\n\n\n\n##########\nFile path: r/src/expression.cpp\n##########\n@@ -19,93 +19,98 @@\n \n #if defined(ARROW_R_WITH_ARROW)\n \n+#include <arrow/compute/api_scalar.h>\n #include <arrow/dataset/api.h>\n namespace ds = ::arrow::dataset;\n \n+std::shared_ptr<ds::Expression> Share(ds::Expression expr) {\n+  return std::make_shared<ds::Expression>(std::move(expr));\n+}\n+\n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__field_ref(std::string name) {\n-  return ds::field_ref(std::move(name));\n+  return Share(ds::field_ref(std::move(name)));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__equal(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<ds::Expression>& rhs) {\n-  return ds::equal(lhs, rhs);\n+  return Share(ds::equal(*lhs, *rhs));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__not_equal(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<ds::Expression>& rhs) {\n-  return ds::not_equal(lhs, rhs);\n+  return Share(ds::not_equal(*lhs, *rhs));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__greater(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<ds::Expression>& rhs) {\n-  return ds::greater(lhs, rhs);\n+  return Share(ds::greater(*lhs, *rhs));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__greater_equal(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<ds::Expression>& rhs) {\n-  return ds::greater_equal(lhs, rhs);\n+  return Share(ds::greater_equal(*lhs, *rhs));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__less(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<ds::Expression>& rhs) {\n-  return ds::less(lhs, rhs);\n+  return Share(ds::less(*lhs, *rhs));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__less_equal(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<ds::Expression>& rhs) {\n-  return ds::less_equal(lhs, rhs);\n+  return Share(ds::less_equal(*lhs, *rhs));\n }\n \n // [[arrow::export]]\n std::shared_ptr<ds::Expression> dataset___expr__in(\n     const std::shared_ptr<ds::Expression>& lhs,\n     const std::shared_ptr<arrow::Array>& rhs) {\n-  return lhs->In(rhs).Copy();\n+  return Share(ds::call(\"is_in\", {*lhs}, arrow::compute::SetLookupOptions{rhs}));\n\nReview comment:\n       The binary version (`is_in_meta_binary`) would be less performant in the context of datasets: `is_in` will reuse a single hash table across all batches, while `is_in_meta_binary` will recompute the hash table for each batch. The added flexibility would enable expressions like `column_1 %in% column_2`, but even if we want to support that I think it should wait for a follow up.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-14T15:15:05.165+0000",
                    "updated": "2020-12-14T15:15:05.165+0000",
                    "started": "2020-12-14T15:15:05.164+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "523923",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525672",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#issuecomment-747607867\n\n\n   R centos-7 (gcc 4.8) compilation fails: https://github.com/apache/arrow/pull/8894/checks?check_run_id=1572105784#step:9:513\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T18:11:05.391+0000",
                    "updated": "2020-12-17T18:11:05.391+0000",
                    "started": "2020-12-17T18:11:05.390+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525672",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525689",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545168758\n\n\n\n##########\nFile path: cpp/src/arrow/array/array_struct_test.cc\n##########\n@@ -582,4 +583,39 @@ TEST_F(TestStructBuilder, TestSlice) {\n   ASSERT_EQ(list_field->null_count(), 1);\n }\n \n+TEST(TestFieldRef, GetChildren) {\n+  auto struct_array = ArrayFromJSON(struct_({field(\"a\", float64())}), R\"([\n+    {\"a\": 6.125},\n+    {\"a\": 0.0},\n+    {\"a\": -1}\n+  ])\");\n+\n+  ASSERT_OK_AND_ASSIGN(auto a, FieldRef(\"a\").GetOne(*struct_array));\n+  auto expected_a = ArrayFromJSON(float64(), \"[6.125, 0.0, -1]\");\n+  AssertArraysEqual(*a, *expected_a);\n+\n+  auto ToChunked = [struct_array](int64_t midpoint) {\n+    return ChunkedArray(\n+        ArrayVector{\n+            struct_array->Slice(0, midpoint),\n+            struct_array->Slice(midpoint),\n+        },\n+        struct_array->type());\n+  };\n+  AssertChunkedEquivalent(ToChunked(1), ToChunked(2));\n\nReview comment:\n       It's not clear to me why this test is here. Was there a particular slicing bug with `FieldRef::GetOne`?\n\n##########\nFile path: cpp/examples/arrow/dataset-parquet-scan-example.cc\n##########\n@@ -62,7 +60,8 @@ struct Configuration {\n \n   // Indicates the filter by which rows will be filtered. This optimization can\n   // make use of partition information and/or file metadata if possible.\n-  std::shared_ptr<ds::Expression> filter = (\"total_amount\"_ > 1000.0f).Copy();\n+  ds::Expression filter =\n+      ds::greater(ds::field_ref(\"total_amount\"), ds::literal(1000.0f));\n\nReview comment:\n       Are we going to bring back the syntactic sugar operators or is it just not useful enough?\n\n##########\nFile path: cpp/src/arrow/compute/cast.cc\n##########\n@@ -118,8 +118,86 @@ class CastMetaFunction : public MetaFunction {\n \n }  // namespace\n \n+const FunctionDoc struct_doc{\"Wrap Arrays into a StructArray\",\n+                             (\"Names of the StructArray's fields are\\n\"\n+                              \"specified through StructOptions.\"),\n+                             {},\n+                             \"StructOptions\"};\n+\n+Result<ValueDescr> StructResolve(KernelContext* ctx,\n+                                 const std::vector<ValueDescr>& descrs) {\n+  const auto& names = OptionsWrapper<StructOptions>::Get(ctx).field_names;\n+  if (names.size() != descrs.size()) {\n+    return Status::Invalid(\"Struct() was passed \", names.size(), \" field \", \"names but \",\n+                           descrs.size(), \" arguments\");\n+  }\n+\n+  size_t i = 0;\n+  FieldVector fields(descrs.size());\n+\n+  ValueDescr::Shape shape = ValueDescr::SCALAR;\n+  for (const ValueDescr& descr : descrs) {\n+    if (descr.shape != ValueDescr::SCALAR) {\n+      shape = ValueDescr::ARRAY;\n+    } else {\n+      switch (descr.type->id()) {\n+        case Type::EXTENSION:\n+        case Type::DENSE_UNION:\n+        case Type::SPARSE_UNION:\n+          return Status::NotImplemented(\"Broadcasting scalars of type \", *descr.type);\n\nReview comment:\n       It seems this error will be raised even if all inputs are scalars, hence no broadcasting?\n\n##########\nFile path: cpp/src/arrow/compute/cast.cc\n##########\n@@ -118,8 +118,86 @@ class CastMetaFunction : public MetaFunction {\n \n }  // namespace\n \n+const FunctionDoc struct_doc{\"Wrap Arrays into a StructArray\",\n+                             (\"Names of the StructArray's fields are\\n\"\n+                              \"specified through StructOptions.\"),\n+                             {},\n+                             \"StructOptions\"};\n+\n+Result<ValueDescr> StructResolve(KernelContext* ctx,\n+                                 const std::vector<ValueDescr>& descrs) {\n+  const auto& names = OptionsWrapper<StructOptions>::Get(ctx).field_names;\n+  if (names.size() != descrs.size()) {\n+    return Status::Invalid(\"Struct() was passed \", names.size(), \" field \", \"names but \",\n+                           descrs.size(), \" arguments\");\n+  }\n+\n+  size_t i = 0;\n+  FieldVector fields(descrs.size());\n+\n+  ValueDescr::Shape shape = ValueDescr::SCALAR;\n+  for (const ValueDescr& descr : descrs) {\n+    if (descr.shape != ValueDescr::SCALAR) {\n+      shape = ValueDescr::ARRAY;\n+    } else {\n+      switch (descr.type->id()) {\n+        case Type::EXTENSION:\n+        case Type::DENSE_UNION:\n+        case Type::SPARSE_UNION:\n+          return Status::NotImplemented(\"Broadcasting scalars of type \", *descr.type);\n+        default:\n+          break;\n+      }\n+    }\n+\n+    fields[i] = field(names[i], descr.type);\n+    ++i;\n+  }\n+\n+  return ValueDescr{struct_(std::move(fields)), shape};\n+}\n+\n+void StructExec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  KERNEL_ASSIGN_OR_RAISE(auto descr, ctx, StructResolve(ctx, batch.GetDescriptors()));\n+\n+  if (descr.shape == ValueDescr::SCALAR) {\n+    ScalarVector scalars(batch.num_values());\n+    for (int i = 0; i < batch.num_values(); ++i) {\n+      scalars[i] = batch[i].scalar();\n+    }\n+\n+    *out =\n+        Datum(std::make_shared<StructScalar>(std::move(scalars), std::move(descr.type)));\n+    return;\n+  }\n+\n+  ArrayVector arrays(batch.num_values());\n+  for (int i = 0; i < batch.num_values(); ++i) {\n+    if (batch[i].is_array()) {\n+      arrays[i] = batch[i].make_array();\n+      continue;\n+    }\n+\n+    KERNEL_ASSIGN_OR_RAISE(\n+        arrays[i], ctx,\n+        MakeArrayFromScalar(*batch[i].scalar(), batch.length, ctx->memory_pool()));\n+  }\n+\n+  *out = std::make_shared<StructArray>(descr.type, batch.length, std::move(arrays));\n+}\n+\n void RegisterScalarCast(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::make_shared<CastMetaFunction>()));\n+\n+  auto struct_function =\n+      std::make_shared<ScalarFunction>(\"struct\", Arity::VarArgs(), &struct_doc);\n\nReview comment:\n       Should we have a more explicit name? Perhaps \"make_struct\", \"struct_wrap\", \"struct_of\"...\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_cast_test.cc\n##########\n@@ -1892,5 +1896,48 @@ TEST_F(TestCast, ExtensionTypeToIntDowncast) {\n   ASSERT_OK(UnregisterExtensionType(\"smallint\"));\n }\n \n+class TestStruct : public TestBase {\n+ public:\n+  Result<Datum> Struct(std::vector<Datum> args) {\n+    StructOptions opts{field_names};\n+    return CallFunction(\"struct\", args, &opts);\n\nReview comment:\n       I wouldn't expect to find this test in `scalar_cast_test.cc`. It would be better in its own test file (or a \"misc\" test file). All scalar kernel tests should be compiled into `arrow-compute-scalar-test` anyway.\n\n##########\nFile path: cpp/src/arrow/dataset/expression.h\n##########\n@@ -0,0 +1,234 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/dataset/type_fwd.h\"\n+#include \"arrow/dataset/visibility.h\"\n+#include \"arrow/datum.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/scalar.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace dataset {\n+\n+/// An unbound expression which maps a single Datum to another Datum.\n+/// An expression is one of\n+/// - A literal Datum.\n+/// - A reference to a single (potentially nested) field of the input Datum.\n+/// - A call to a compute function, with arguments specified by other Expressions.\n+class ARROW_DS_EXPORT Expression {\n+ public:\n+  struct Call {\n+    std::string function_name;\n+    std::vector<Expression> arguments;\n+    std::shared_ptr<compute::FunctionOptions> options;\n+\n+    // post-Bind properties:\n+    const compute::Kernel* kernel = NULLPTR;\n+    std::shared_ptr<compute::Function> function;\n+    std::shared_ptr<compute::KernelState> kernel_state;\n+    ValueDescr descr;\n+  };\n+\n+  std::string ToString() const;\n+  bool Equals(const Expression& other) const;\n+  size_t hash() const;\n+  struct Hash {\n+    size_t operator()(const Expression& expr) const { return expr.hash(); }\n+  };\n+\n+  /// Bind this expression to the given input type, looking up Kernels and field types.\n+  /// Some expression simplification may be performed and implicit casts will be inserted.\n+  /// Any state necessary for execution will be initialized and returned.\n+  Result<Expression> Bind(ValueDescr in, compute::ExecContext* = NULLPTR) const;\n+  Result<Expression> Bind(const Schema& in_schema, compute::ExecContext* = NULLPTR) const;\n+\n+  // XXX someday\n+  // Clone all KernelState in this bound expression. If any function referenced by this\n+  // expression has mutable KernelState, it is not safe to execute or apply simplification\n+  // passes to it (or copies of it!) from multiple threads. Cloning state produces new\n+  // KernelStates where necessary to ensure that Expressions may be manipulated safely\n+  // on multiple threads.\n+  // Result<ExpressionState> CloneState() const;\n+  // Status SetState(ExpressionState);\n+\n+  /// Return true if all an expression's field references have explicit ValueDescr and all\n+  /// of its functions' kernels are looked up.\n+  bool IsBound() const;\n+\n+  /// Return true if this expression is composed only of Scalar literals, field\n+  /// references, and calls to ScalarFunctions.\n+  bool IsScalarExpression() const;\n+\n+  /// Return true if this expression is literal and entirely null.\n+  bool IsNullLiteral() const;\n+\n+  /// Return true if this expression could evaluate to true.\n+  bool IsSatisfiable() const;\n+\n+  // XXX someday\n+  // Result<PipelineGraph> GetPipelines();\n+\n+  const Call* call() const;\n+  const Datum* literal() const;\n+  const FieldRef* field_ref() const;\n\nReview comment:\n       Is this for the `Parameter` variant?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.h\n##########\n@@ -0,0 +1,234 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/chunked_array.h\"\n\nReview comment:\n       Are all those includes required?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.h\n##########\n@@ -0,0 +1,234 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/dataset/type_fwd.h\"\n+#include \"arrow/dataset/visibility.h\"\n+#include \"arrow/datum.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/scalar.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace dataset {\n+\n+/// An unbound expression which maps a single Datum to another Datum.\n+/// An expression is one of\n+/// - A literal Datum.\n+/// - A reference to a single (potentially nested) field of the input Datum.\n+/// - A call to a compute function, with arguments specified by other Expressions.\n+class ARROW_DS_EXPORT Expression {\n+ public:\n+  struct Call {\n+    std::string function_name;\n+    std::vector<Expression> arguments;\n+    std::shared_ptr<compute::FunctionOptions> options;\n+\n+    // post-Bind properties:\n+    const compute::Kernel* kernel = NULLPTR;\n+    std::shared_ptr<compute::Function> function;\n+    std::shared_ptr<compute::KernelState> kernel_state;\n+    ValueDescr descr;\n+  };\n+\n+  std::string ToString() const;\n+  bool Equals(const Expression& other) const;\n+  size_t hash() const;\n+  struct Hash {\n+    size_t operator()(const Expression& expr) const { return expr.hash(); }\n+  };\n+\n+  /// Bind this expression to the given input type, looking up Kernels and field types.\n+  /// Some expression simplification may be performed and implicit casts will be inserted.\n+  /// Any state necessary for execution will be initialized and returned.\n+  Result<Expression> Bind(ValueDescr in, compute::ExecContext* = NULLPTR) const;\n+  Result<Expression> Bind(const Schema& in_schema, compute::ExecContext* = NULLPTR) const;\n+\n+  // XXX someday\n+  // Clone all KernelState in this bound expression. If any function referenced by this\n+  // expression has mutable KernelState, it is not safe to execute or apply simplification\n+  // passes to it (or copies of it!) from multiple threads. Cloning state produces new\n+  // KernelStates where necessary to ensure that Expressions may be manipulated safely\n+  // on multiple threads.\n+  // Result<ExpressionState> CloneState() const;\n+  // Status SetState(ExpressionState);\n+\n+  /// Return true if all an expression's field references have explicit ValueDescr and all\n+  /// of its functions' kernels are looked up.\n+  bool IsBound() const;\n+\n+  /// Return true if this expression is composed only of Scalar literals, field\n+  /// references, and calls to ScalarFunctions.\n+  bool IsScalarExpression() const;\n+\n+  /// Return true if this expression is literal and entirely null.\n+  bool IsNullLiteral() const;\n+\n+  /// Return true if this expression could evaluate to true.\n+  bool IsSatisfiable() const;\n+\n+  // XXX someday\n+  // Result<PipelineGraph> GetPipelines();\n+\n+  const Call* call() const;\n+  const Datum* literal() const;\n+  const FieldRef* field_ref() const;\n+\n+  ValueDescr descr() const;\n+  // XXX someday\n+  // NullGeneralization::type nullable() const;\n+\n+  struct Parameter {\n+    FieldRef ref;\n+    ValueDescr descr;\n+  };\n+\n+  Expression() = default;\n+  explicit Expression(Call call);\n+  explicit Expression(Datum literal);\n+  explicit Expression(Parameter parameter);\n+\n+ private:\n+  using Impl = util::Variant<Datum, Parameter, Call>;\n+  std::shared_ptr<Impl> impl_;\n+\n+  ARROW_EXPORT friend bool Identical(const Expression& l, const Expression& r);\n+\n+  ARROW_EXPORT friend void PrintTo(const Expression&, std::ostream*);\n+};\n+\n+inline bool operator==(const Expression& l, const Expression& r) { return l.Equals(r); }\n+inline bool operator!=(const Expression& l, const Expression& r) { return !l.Equals(r); }\n+\n+// Factories\n+\n+ARROW_DS_EXPORT\n+Expression literal(Datum lit);\n+\n+template <typename Arg>\n+Expression literal(Arg&& arg) {\n+  return literal(Datum(std::forward<Arg>(arg)));\n+}\n+\n+ARROW_DS_EXPORT\n+Expression field_ref(FieldRef ref);\n+\n+ARROW_DS_EXPORT\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options = NULLPTR);\n+\n+template <typename Options, typename = typename std::enable_if<std::is_base_of<\n+                                compute::FunctionOptions, Options>::value>::type>\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                Options options) {\n+  return call(std::move(function), std::move(arguments),\n+              std::make_shared<Options>(std::move(options)));\n+}\n+\n+ARROW_DS_EXPORT\n+std::vector<FieldRef> FieldsInExpression(const Expression&);\n+\n+ARROW_DS_EXPORT\n+Result<std::unordered_map<FieldRef, Datum, FieldRef::Hash>> ExtractKnownFieldValues(\n\nReview comment:\n       I'm not sure I understand why this is returned as an unordered_map rather than (far cheaper) vector of pairs.\n\n##########\nFile path: cpp/src/arrow/dataset/expression.h\n##########\n@@ -0,0 +1,234 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/dataset/type_fwd.h\"\n+#include \"arrow/dataset/visibility.h\"\n+#include \"arrow/datum.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/scalar.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace dataset {\n+\n+/// An unbound expression which maps a single Datum to another Datum.\n+/// An expression is one of\n+/// - A literal Datum.\n+/// - A reference to a single (potentially nested) field of the input Datum.\n+/// - A call to a compute function, with arguments specified by other Expressions.\n+class ARROW_DS_EXPORT Expression {\n+ public:\n+  struct Call {\n+    std::string function_name;\n+    std::vector<Expression> arguments;\n+    std::shared_ptr<compute::FunctionOptions> options;\n+\n+    // post-Bind properties:\n+    const compute::Kernel* kernel = NULLPTR;\n+    std::shared_ptr<compute::Function> function;\n+    std::shared_ptr<compute::KernelState> kernel_state;\n+    ValueDescr descr;\n+  };\n+\n+  std::string ToString() const;\n+  bool Equals(const Expression& other) const;\n+  size_t hash() const;\n+  struct Hash {\n+    size_t operator()(const Expression& expr) const { return expr.hash(); }\n+  };\n+\n+  /// Bind this expression to the given input type, looking up Kernels and field types.\n+  /// Some expression simplification may be performed and implicit casts will be inserted.\n+  /// Any state necessary for execution will be initialized and returned.\n+  Result<Expression> Bind(ValueDescr in, compute::ExecContext* = NULLPTR) const;\n+  Result<Expression> Bind(const Schema& in_schema, compute::ExecContext* = NULLPTR) const;\n+\n+  // XXX someday\n+  // Clone all KernelState in this bound expression. If any function referenced by this\n+  // expression has mutable KernelState, it is not safe to execute or apply simplification\n+  // passes to it (or copies of it!) from multiple threads. Cloning state produces new\n+  // KernelStates where necessary to ensure that Expressions may be manipulated safely\n+  // on multiple threads.\n+  // Result<ExpressionState> CloneState() const;\n+  // Status SetState(ExpressionState);\n+\n+  /// Return true if all an expression's field references have explicit ValueDescr and all\n+  /// of its functions' kernels are looked up.\n+  bool IsBound() const;\n+\n+  /// Return true if this expression is composed only of Scalar literals, field\n+  /// references, and calls to ScalarFunctions.\n+  bool IsScalarExpression() const;\n+\n+  /// Return true if this expression is literal and entirely null.\n+  bool IsNullLiteral() const;\n+\n+  /// Return true if this expression could evaluate to true.\n+  bool IsSatisfiable() const;\n+\n+  // XXX someday\n+  // Result<PipelineGraph> GetPipelines();\n+\n+  const Call* call() const;\n+  const Datum* literal() const;\n+  const FieldRef* field_ref() const;\n+\n+  ValueDescr descr() const;\n+  // XXX someday\n+  // NullGeneralization::type nullable() const;\n+\n+  struct Parameter {\n+    FieldRef ref;\n+    ValueDescr descr;\n+  };\n+\n+  Expression() = default;\n+  explicit Expression(Call call);\n+  explicit Expression(Datum literal);\n+  explicit Expression(Parameter parameter);\n+\n+ private:\n+  using Impl = util::Variant<Datum, Parameter, Call>;\n+  std::shared_ptr<Impl> impl_;\n+\n+  ARROW_EXPORT friend bool Identical(const Expression& l, const Expression& r);\n+\n+  ARROW_EXPORT friend void PrintTo(const Expression&, std::ostream*);\n+};\n+\n+inline bool operator==(const Expression& l, const Expression& r) { return l.Equals(r); }\n+inline bool operator!=(const Expression& l, const Expression& r) { return !l.Equals(r); }\n+\n+// Factories\n+\n+ARROW_DS_EXPORT\n+Expression literal(Datum lit);\n+\n+template <typename Arg>\n+Expression literal(Arg&& arg) {\n+  return literal(Datum(std::forward<Arg>(arg)));\n+}\n+\n+ARROW_DS_EXPORT\n+Expression field_ref(FieldRef ref);\n+\n+ARROW_DS_EXPORT\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options = NULLPTR);\n+\n+template <typename Options, typename = typename std::enable_if<std::is_base_of<\n+                                compute::FunctionOptions, Options>::value>::type>\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                Options options) {\n+  return call(std::move(function), std::move(arguments),\n+              std::make_shared<Options>(std::move(options)));\n+}\n+\n+ARROW_DS_EXPORT\n+std::vector<FieldRef> FieldsInExpression(const Expression&);\n+\n+ARROW_DS_EXPORT\n+Result<std::unordered_map<FieldRef, Datum, FieldRef::Hash>> ExtractKnownFieldValues(\n+    const Expression& guaranteed_true_predicate);\n+\n+/// \\defgroup expression-passes Functions for modification of Expressions\n+///\n+/// @{\n+///\n+/// These operate on bound expressions.\n+\n+/// Weak canonicalization which establishes guarantees for subsequent passes. Even\n+/// equivalent Expressions may result in different canonicalized expressions.\n+/// TODO this could be a strong canonicalization\n+ARROW_DS_EXPORT\n+Result<Expression> Canonicalize(Expression, compute::ExecContext* = NULLPTR);\n+\n+/// Simplify Expressions based on literal arguments (for example, add(null, x) will always\n+/// be null so replace the call with a null literal). Includes early evaluation of all\n+/// calls whose arguments are entirely literal.\n+ARROW_DS_EXPORT\n+Result<Expression> FoldConstants(Expression);\n+\n+ARROW_DS_EXPORT\n+Result<Expression> ReplaceFieldsWithKnownValues(\n+    const std::unordered_map<FieldRef, Datum, FieldRef::Hash>& known_values, Expression);\n\nReview comment:\n       Same question wrt. unordered_map. The implementation may use unordered_map internally but I'm not sure it makes sense to expose this detail in the API.\n\n##########\nFile path: cpp/src/arrow/dataset/partition.cc\n##########\n@@ -573,5 +530,192 @@ Result<std::shared_ptr<Schema>> PartitioningOrFactory::GetOrInferSchema(\n   return factory()->Inspect(paths);\n }\n \n+// Transform an array of counts to offsets which will divide a ListArray\n+// into an equal number of slices with corresponding lengths.\n+inline Result<std::shared_ptr<Array>> CountsToOffsets(\n+    std::shared_ptr<Int64Array> counts) {\n+  Int32Builder offset_builder;\n+  RETURN_NOT_OK(offset_builder.Resize(counts->length() + 1));\n+  offset_builder.UnsafeAppend(0);\n+\n+  for (int64_t i = 0; i < counts->length(); ++i) {\n+    DCHECK_NE(counts->Value(i), 0);\n+    auto next_offset = static_cast<int32_t>(offset_builder[i] + counts->Value(i));\n+    offset_builder.UnsafeAppend(next_offset);\n+  }\n+\n+  std::shared_ptr<Array> offsets;\n+  RETURN_NOT_OK(offset_builder.Finish(&offsets));\n+  return offsets;\n+}\n+\n+// Helper for simultaneous dictionary encoding of multiple arrays.\n+//\n+// The fused dictionary is the Cartesian product of the individual dictionaries.\n+// For example given two arrays A, B where A has unique values [\"ex\", \"why\"]\n+// and B has unique values [0, 1] the fused dictionary is the set of tuples\n+// [[\"ex\", 0], [\"ex\", 1], [\"why\", 0], [\"ex\", 1]].\n+//\n+// TODO(bkietz) this capability belongs in an Action of the hash kernels, where\n+// it can be used to group aggregates without materializing a grouped batch.\n+// For the purposes of writing we need the materialized grouped batch anyway\n+// since no Writers accept a selection vector.\n+class StructDictionary {\n+ public:\n+  struct Encoded {\n+    std::shared_ptr<Int32Array> indices;\n+    std::shared_ptr<StructDictionary> dictionary;\n+  };\n+\n+  static Result<Encoded> Encode(const ArrayVector& columns) {\n+    Encoded out{nullptr, std::make_shared<StructDictionary>()};\n+\n+    for (const auto& column : columns) {\n+      if (column->null_count() != 0) {\n+        return Status::NotImplemented(\"Grouping on a field with nulls\");\n+      }\n+\n+      RETURN_NOT_OK(out.dictionary->AddOne(column, &out.indices));\n+    }\n+\n+    return out;\n+  }\n+\n+  Result<std::shared_ptr<StructArray>> Decode(std::shared_ptr<Int32Array> fused_indices,\n+                                              FieldVector fields) {\n+    std::vector<Int32Builder> builders(dictionaries_.size());\n+    for (Int32Builder& b : builders) {\n+      RETURN_NOT_OK(b.Resize(fused_indices->length()));\n+    }\n+\n+    std::vector<int32_t> codes(dictionaries_.size());\n+    for (int64_t i = 0; i < fused_indices->length(); ++i) {\n+      Expand(fused_indices->Value(i), codes.data());\n+\n+      auto builder_it = builders.begin();\n+      for (int32_t index : codes) {\n+        builder_it++->UnsafeAppend(index);\n+      }\n+    }\n+\n+    ArrayVector columns(dictionaries_.size());\n+    for (size_t i = 0; i < dictionaries_.size(); ++i) {\n+      std::shared_ptr<ArrayData> indices;\n+      RETURN_NOT_OK(builders[i].FinishInternal(&indices));\n+\n+      ARROW_ASSIGN_OR_RAISE(Datum column, compute::Take(dictionaries_[i], indices));\n+      columns[i] = column.make_array();\n+    }\n+\n+    return StructArray::Make(std::move(columns), std::move(fields));\n+  }\n+\n+ private:\n+  Status AddOne(Datum column, std::shared_ptr<Int32Array>* fused_indices) {\n+    ArrayData* encoded;\n+    if (column.type()->id() != Type::DICTIONARY) {\n+      ARROW_ASSIGN_OR_RAISE(column, compute::DictionaryEncode(column));\n+    }\n+    encoded = column.mutable_array();\n+\n+    auto indices =\n+        std::make_shared<Int32Array>(encoded->length, std::move(encoded->buffers[1]));\n+\n+    dictionaries_.push_back(MakeArray(std::move(encoded->dictionary)));\n+    auto dictionary_size = static_cast<int32_t>(dictionaries_.back()->length());\n+\n+    if (*fused_indices == nullptr) {\n+      *fused_indices = std::move(indices);\n+      size_ = dictionary_size;\n+      return Status::OK();\n+    }\n+\n+    // It's useful to think about the case where each of dictionaries_ has size 10.\n+    // In this case the decimal digit in the ones place is the code in dictionaries_[0],\n+    // the tens place corresponds to dictionaries_[1], etc.\n+    // The incumbent indices must be shifted to the hundreds place so as not to collide.\n+    ARROW_ASSIGN_OR_RAISE(Datum new_fused_indices,\n+                          compute::Multiply(indices, MakeScalar(size_)));\n+\n+    ARROW_ASSIGN_OR_RAISE(new_fused_indices,\n+                          compute::Add(new_fused_indices, *fused_indices));\n+\n+    *fused_indices = checked_pointer_cast<Int32Array>(new_fused_indices.make_array());\n+\n+    // XXX should probably cap this at 2**15 or so\n+    ARROW_CHECK(!internal::MultiplyWithOverflow(size_, dictionary_size, &size_));\n\nReview comment:\n       Why not return an error instead of aborting?\r\n   (also, why the comment \"cap at 2**15\"?).\n\n##########\nFile path: cpp/src/arrow/type.cc\n##########\n@@ -1039,13 +1042,31 @@ Result<std::shared_ptr<Field>> FieldPath::Get(const FieldVector& fields) const {\n \n Result<std::shared_ptr<Array>> FieldPath::Get(const RecordBatch& batch) const {\n   ARROW_ASSIGN_OR_RAISE(auto data, FieldPathGetImpl::Get(this, batch.column_data()));\n-  return MakeArray(data);\n+  return MakeArray(std::move(data));\n }\n \n Result<std::shared_ptr<ChunkedArray>> FieldPath::Get(const Table& table) const {\n   return FieldPathGetImpl::Get(this, table.columns());\n }\n \n+Result<std::shared_ptr<Array>> FieldPath::Get(const Array& array) const {\n+  ARROW_ASSIGN_OR_RAISE(auto data, Get(*array.data()));\n+  return MakeArray(std::move(data));\n+}\n+\n+Result<std::shared_ptr<ArrayData>> FieldPath::Get(const ArrayData& data) const {\n+  return FieldPathGetImpl::Get(this, data.child_data);\n+}\n+\n+Result<std::shared_ptr<ChunkedArray>> FieldPath::Get(const ChunkedArray& array) const {\n+  FieldPath prefixed_with_0 = *this;\n+  prefixed_with_0.indices_.insert(prefixed_with_0.indices_.begin(), 0);\n+\n+  ChunkedArrayVector vec;\n+  vec.emplace_back(const_cast<ChunkedArray*>(&array), [](...) {});\n\nReview comment:\n       I can't parse what this does. Would you mind leaving a comment or perhaps finding a nicer spelling?\n\n##########\nFile path: cpp/src/arrow/dataset/expression_internal.h\n##########\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace dataset {\n+\n+bool Identical(const Expression& l, const Expression& r) { return l.impl_ == r.impl_; }\n+\n+const Expression::Call* CallNotNull(const Expression& expr) {\n+  auto call = expr.call();\n+  DCHECK_NE(call, nullptr);\n+  return call;\n+}\n+\n+inline void GetAllFieldRefs(const Expression& expr,\n+                            std::unordered_set<FieldRef, FieldRef::Hash>* refs) {\n+  if (auto lit = expr.literal()) return;\n+\n+  if (auto ref = expr.field_ref()) {\n+    refs->emplace(*ref);\n+    return;\n+  }\n+\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    GetAllFieldRefs(arg, refs);\n+  }\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Expression>& exprs) {\n+  std::vector<ValueDescr> descrs(exprs.size());\n+  for (size_t i = 0; i < exprs.size(); ++i) {\n+    DCHECK(exprs[i].IsBound());\n+    descrs[i] = exprs[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Datum>& values) {\n+  std::vector<ValueDescr> descrs(values.size());\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    descrs[i] = values[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+struct FieldPathGetDatumImpl {\n\nReview comment:\n       Shouldn't this go into `type.cc`?\n\n##########\nFile path: cpp/src/arrow/dataset/expression_internal.h\n##########\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace dataset {\n+\n+bool Identical(const Expression& l, const Expression& r) { return l.impl_ == r.impl_; }\n+\n+const Expression::Call* CallNotNull(const Expression& expr) {\n+  auto call = expr.call();\n+  DCHECK_NE(call, nullptr);\n+  return call;\n+}\n+\n+inline void GetAllFieldRefs(const Expression& expr,\n+                            std::unordered_set<FieldRef, FieldRef::Hash>* refs) {\n+  if (auto lit = expr.literal()) return;\n+\n+  if (auto ref = expr.field_ref()) {\n+    refs->emplace(*ref);\n+    return;\n+  }\n+\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    GetAllFieldRefs(arg, refs);\n+  }\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Expression>& exprs) {\n+  std::vector<ValueDescr> descrs(exprs.size());\n+  for (size_t i = 0; i < exprs.size(); ++i) {\n+    DCHECK(exprs[i].IsBound());\n+    descrs[i] = exprs[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Datum>& values) {\n+  std::vector<ValueDescr> descrs(values.size());\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    descrs[i] = values[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+struct FieldPathGetDatumImpl {\n+  template <typename T, typename = decltype(FieldPath{}.Get(std::declval<const T&>()))>\n+  Result<Datum> operator()(const std::shared_ptr<T>& ptr) {\n+    return path_.Get(*ptr).template As<Datum>();\n+  }\n+\n+  template <typename T>\n+  Result<Datum> operator()(const T&) {\n+    return Status::NotImplemented(\"FieldPath::Get() into Datum \", datum_.ToString());\n+  }\n+\n+  const Datum& datum_;\n+  const FieldPath& path_;\n+};\n+\n+inline Result<Datum> GetDatumField(const FieldRef& ref, const Datum& input) {\n+  Datum field;\n+\n+  FieldPath path;\n+  if (auto type = input.type()) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.type()));\n+  } else if (input.kind() == Datum::RECORD_BATCH) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.record_batch()->schema()));\n+  } else if (input.kind() == Datum::TABLE) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.table()->schema()));\n+  }\n+\n+  if (path) {\n+    ARROW_ASSIGN_OR_RAISE(field,\n+                          util::visit(FieldPathGetDatumImpl{input, path}, input.value));\n+  }\n+\n+  if (field == Datum{}) {\n+    field = Datum(std::make_shared<NullScalar>());\n+  }\n+\n+  return field;\n+}\n+\n+struct Comparison {\n+  enum type {\n+    NA = 0,\n+    EQUAL = 1,\n+    LESS = 2,\n+    GREATER = 4,\n+    NOT_EQUAL = LESS | GREATER,\n+    LESS_EQUAL = LESS | EQUAL,\n+    GREATER_EQUAL = GREATER | EQUAL,\n+  };\n+\n+  static const type* Get(const std::string& function) {\n+    static std::unordered_map<std::string, type> flipped_comparisons{\n+        {\"equal\", EQUAL},     {\"not_equal\", NOT_EQUAL},\n+        {\"less\", LESS},       {\"less_equal\", LESS_EQUAL},\n+        {\"greater\", GREATER}, {\"greater_equal\", GREATER_EQUAL},\n+    };\n+\n+    auto it = flipped_comparisons.find(function);\n+    return it != flipped_comparisons.end() ? &it->second : nullptr;\n+  }\n+\n+  static const type* Get(const Expression& expr) {\n+    if (auto call = expr.call()) {\n+      return Comparison::Get(call->function_name);\n+    }\n+    return nullptr;\n+  }\n+\n+  // Execute a simple Comparison between scalars, casting the RHS if types disagree\n+  static Result<type> Execute(Datum l, Datum r) {\n+    if (!l.is_scalar() || !r.is_scalar()) {\n+      return Status::Invalid(\"Cannot Execute Comparison on non-scalars\");\n+    }\n+\n+    if (!l.type()->Equals(r.type())) {\n+      ARROW_ASSIGN_OR_RAISE(r, compute::Cast(r, l.type()));\n+    }\n+\n+    std::vector<Datum> arguments{std::move(l), std::move(r)};\n+\n+    ARROW_ASSIGN_OR_RAISE(auto equal, compute::CallFunction(\"equal\", arguments));\n+\n+    if (!equal.scalar()->is_valid) return NA;\n+    if (equal.scalar_as<BooleanScalar>().value) return EQUAL;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto less, compute::CallFunction(\"less\", arguments));\n+\n+    if (!less.scalar()->is_valid) return NA;\n+    return less.scalar_as<BooleanScalar>().value ? LESS : GREATER;\n+  }\n+\n+  static type GetFlipped(type op) {\n+    switch (op) {\n+      case NA:\n+        return NA;\n+      case EQUAL:\n+        return EQUAL;\n+      case LESS:\n+        return GREATER;\n+      case GREATER:\n+        return LESS;\n+      case NOT_EQUAL:\n+        return NOT_EQUAL;\n+      case LESS_EQUAL:\n+        return GREATER_EQUAL;\n+      case GREATER_EQUAL:\n+        return LESS_EQUAL;\n+    }\n+    DCHECK(false);\n+    return NA;\n+  }\n+\n+  static std::string GetName(type op) {\n+    switch (op) {\n+      case NA:\n+        DCHECK(false) << \"unreachable\";\n+        break;\n+      case EQUAL:\n+        return \"equal\";\n+      case LESS:\n+        return \"less\";\n+      case GREATER:\n+        return \"greater\";\n+      case NOT_EQUAL:\n+        return \"not_equal\";\n+      case LESS_EQUAL:\n+        return \"less_equal\";\n+      case GREATER_EQUAL:\n+        return \"greater_equal\";\n+    }\n+    DCHECK(false);\n+    return \"na\";\n+  }\n+\n+  static std::string GetOp(type op) {\n+    switch (op) {\n+      case NA:\n+        DCHECK(false) << \"unreachable\";\n+        break;\n+      case EQUAL:\n+        return \"==\";\n+      case LESS:\n+        return \"<\";\n+      case GREATER:\n+        return \">\";\n+      case NOT_EQUAL:\n+        return \"!=\";\n+      case LESS_EQUAL:\n+        return \"<=\";\n+      case GREATER_EQUAL:\n+        return \">=\";\n+    }\n+    DCHECK(false);\n+    return \"\";\n+  }\n+};\n+\n+inline const compute::CastOptions* GetCastOptions(const Expression::Call& call) {\n+  if (call.function_name != \"cast\") return nullptr;\n+  return checked_cast<const compute::CastOptions*>(call.options.get());\n+}\n+\n+inline bool IsSetLookup(const std::string& function) {\n+  return function == \"is_in\" || function == \"index_in\";\n+}\n+\n+inline bool IsSameTypesBinary(const std::string& function) {\n+  if (Comparison::Get(function)) return true;\n+\n+  static std::unordered_set<std::string> set{\"add\", \"subtract\", \"multiply\", \"divide\"};\n+\n+  return set.find(function) != set.end();\n+}\n+\n+inline const compute::SetLookupOptions* GetSetLookupOptions(\n+    const Expression::Call& call) {\n+  if (!IsSetLookup(call.function_name)) return nullptr;\n+  return checked_cast<const compute::SetLookupOptions*>(call.options.get());\n+}\n+\n+inline const compute::StructOptions* GetStructOptions(const Expression::Call& call) {\n+  if (call.function_name != \"struct\") return nullptr;\n+  return checked_cast<const compute::StructOptions*>(call.options.get());\n+}\n+\n+inline const compute::StrptimeOptions* GetStrptimeOptions(const Expression::Call& call) {\n+  if (call.function_name != \"strptime\") return nullptr;\n+  return checked_cast<const compute::StrptimeOptions*>(call.options.get());\n+}\n+\n+inline const std::shared_ptr<DataType>& GetDictionaryValueType(\n\nReview comment:\n       It seems there's no point in returning a const-ref as all callers take a copy.\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n\nReview comment:\n       Might check this first before recursing into the expression tree?\n\n##########\nFile path: cpp/src/arrow/dataset/expression_internal.h\n##########\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace dataset {\n+\n+bool Identical(const Expression& l, const Expression& r) { return l.impl_ == r.impl_; }\n+\n+const Expression::Call* CallNotNull(const Expression& expr) {\n+  auto call = expr.call();\n+  DCHECK_NE(call, nullptr);\n+  return call;\n+}\n+\n+inline void GetAllFieldRefs(const Expression& expr,\n+                            std::unordered_set<FieldRef, FieldRef::Hash>* refs) {\n+  if (auto lit = expr.literal()) return;\n+\n+  if (auto ref = expr.field_ref()) {\n+    refs->emplace(*ref);\n+    return;\n+  }\n+\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    GetAllFieldRefs(arg, refs);\n+  }\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Expression>& exprs) {\n+  std::vector<ValueDescr> descrs(exprs.size());\n+  for (size_t i = 0; i < exprs.size(); ++i) {\n+    DCHECK(exprs[i].IsBound());\n+    descrs[i] = exprs[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Datum>& values) {\n+  std::vector<ValueDescr> descrs(values.size());\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    descrs[i] = values[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+struct FieldPathGetDatumImpl {\n+  template <typename T, typename = decltype(FieldPath{}.Get(std::declval<const T&>()))>\n+  Result<Datum> operator()(const std::shared_ptr<T>& ptr) {\n+    return path_.Get(*ptr).template As<Datum>();\n+  }\n+\n+  template <typename T>\n+  Result<Datum> operator()(const T&) {\n+    return Status::NotImplemented(\"FieldPath::Get() into Datum \", datum_.ToString());\n+  }\n+\n+  const Datum& datum_;\n+  const FieldPath& path_;\n+};\n+\n+inline Result<Datum> GetDatumField(const FieldRef& ref, const Datum& input) {\n+  Datum field;\n+\n+  FieldPath path;\n+  if (auto type = input.type()) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.type()));\n+  } else if (input.kind() == Datum::RECORD_BATCH) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.record_batch()->schema()));\n+  } else if (input.kind() == Datum::TABLE) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.table()->schema()));\n+  }\n+\n+  if (path) {\n+    ARROW_ASSIGN_OR_RAISE(field,\n+                          util::visit(FieldPathGetDatumImpl{input, path}, input.value));\n+  }\n+\n+  if (field == Datum{}) {\n+    field = Datum(std::make_shared<NullScalar>());\n+  }\n+\n+  return field;\n+}\n+\n+struct Comparison {\n+  enum type {\n+    NA = 0,\n+    EQUAL = 1,\n+    LESS = 2,\n+    GREATER = 4,\n+    NOT_EQUAL = LESS | GREATER,\n+    LESS_EQUAL = LESS | EQUAL,\n+    GREATER_EQUAL = GREATER | EQUAL,\n+  };\n+\n+  static const type* Get(const std::string& function) {\n+    static std::unordered_map<std::string, type> flipped_comparisons{\n+        {\"equal\", EQUAL},     {\"not_equal\", NOT_EQUAL},\n+        {\"less\", LESS},       {\"less_equal\", LESS_EQUAL},\n+        {\"greater\", GREATER}, {\"greater_equal\", GREATER_EQUAL},\n+    };\n+\n+    auto it = flipped_comparisons.find(function);\n+    return it != flipped_comparisons.end() ? &it->second : nullptr;\n+  }\n+\n+  static const type* Get(const Expression& expr) {\n+    if (auto call = expr.call()) {\n+      return Comparison::Get(call->function_name);\n+    }\n+    return nullptr;\n+  }\n+\n+  // Execute a simple Comparison between scalars, casting the RHS if types disagree\n+  static Result<type> Execute(Datum l, Datum r) {\n+    if (!l.is_scalar() || !r.is_scalar()) {\n+      return Status::Invalid(\"Cannot Execute Comparison on non-scalars\");\n+    }\n+\n+    if (!l.type()->Equals(r.type())) {\n+      ARROW_ASSIGN_OR_RAISE(r, compute::Cast(r, l.type()));\n+    }\n+\n+    std::vector<Datum> arguments{std::move(l), std::move(r)};\n+\n+    ARROW_ASSIGN_OR_RAISE(auto equal, compute::CallFunction(\"equal\", arguments));\n+\n+    if (!equal.scalar()->is_valid) return NA;\n+    if (equal.scalar_as<BooleanScalar>().value) return EQUAL;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto less, compute::CallFunction(\"less\", arguments));\n+\n+    if (!less.scalar()->is_valid) return NA;\n+    return less.scalar_as<BooleanScalar>().value ? LESS : GREATER;\n+  }\n+\n+  static type GetFlipped(type op) {\n+    switch (op) {\n+      case NA:\n+        return NA;\n+      case EQUAL:\n+        return EQUAL;\n+      case LESS:\n+        return GREATER;\n+      case GREATER:\n+        return LESS;\n+      case NOT_EQUAL:\n+        return NOT_EQUAL;\n+      case LESS_EQUAL:\n+        return GREATER_EQUAL;\n+      case GREATER_EQUAL:\n+        return LESS_EQUAL;\n+    }\n+    DCHECK(false);\n+    return NA;\n+  }\n+\n+  static std::string GetName(type op) {\n+    switch (op) {\n+      case NA:\n+        DCHECK(false) << \"unreachable\";\n+        break;\n+      case EQUAL:\n+        return \"equal\";\n+      case LESS:\n+        return \"less\";\n+      case GREATER:\n+        return \"greater\";\n+      case NOT_EQUAL:\n+        return \"not_equal\";\n+      case LESS_EQUAL:\n+        return \"less_equal\";\n+      case GREATER_EQUAL:\n+        return \"greater_equal\";\n+    }\n+    DCHECK(false);\n+    return \"na\";\n+  }\n+\n+  static std::string GetOp(type op) {\n+    switch (op) {\n+      case NA:\n+        DCHECK(false) << \"unreachable\";\n+        break;\n+      case EQUAL:\n+        return \"==\";\n+      case LESS:\n+        return \"<\";\n+      case GREATER:\n+        return \">\";\n+      case NOT_EQUAL:\n+        return \"!=\";\n+      case LESS_EQUAL:\n+        return \"<=\";\n+      case GREATER_EQUAL:\n+        return \">=\";\n+    }\n+    DCHECK(false);\n+    return \"\";\n+  }\n+};\n+\n+inline const compute::CastOptions* GetCastOptions(const Expression::Call& call) {\n+  if (call.function_name != \"cast\") return nullptr;\n+  return checked_cast<const compute::CastOptions*>(call.options.get());\n+}\n+\n+inline bool IsSetLookup(const std::string& function) {\n+  return function == \"is_in\" || function == \"index_in\";\n+}\n+\n+inline bool IsSameTypesBinary(const std::string& function) {\n+  if (Comparison::Get(function)) return true;\n+\n+  static std::unordered_set<std::string> set{\"add\", \"subtract\", \"multiply\", \"divide\"};\n+\n+  return set.find(function) != set.end();\n+}\n+\n+inline const compute::SetLookupOptions* GetSetLookupOptions(\n+    const Expression::Call& call) {\n+  if (!IsSetLookup(call.function_name)) return nullptr;\n+  return checked_cast<const compute::SetLookupOptions*>(call.options.get());\n+}\n+\n+inline const compute::StructOptions* GetStructOptions(const Expression::Call& call) {\n+  if (call.function_name != \"struct\") return nullptr;\n+  return checked_cast<const compute::StructOptions*>(call.options.get());\n+}\n+\n+inline const compute::StrptimeOptions* GetStrptimeOptions(const Expression::Call& call) {\n+  if (call.function_name != \"strptime\") return nullptr;\n+  return checked_cast<const compute::StrptimeOptions*>(call.options.get());\n+}\n+\n+inline const std::shared_ptr<DataType>& GetDictionaryValueType(\n+    const std::shared_ptr<DataType>& type) {\n+  if (type && type->id() == Type::DICTIONARY) {\n+    return checked_cast<const DictionaryType&>(*type).value_type();\n+  }\n+  static std::shared_ptr<DataType> null;\n+  return null;\n+}\n+\n+inline Status EnsureNotDictionary(ValueDescr* descr) {\n+  if (auto value_type = GetDictionaryValueType(descr->type)) {\n+    descr->type = std::move(value_type);\n+  }\n+  return Status::OK();\n+}\n+\n+inline Status EnsureNotDictionary(Datum* datum) {\n+  if (datum->type()->id() == Type::DICTIONARY) {\n+    const auto& type = checked_cast<const DictionaryType&>(*datum->type()).value_type();\n+    ARROW_ASSIGN_OR_RAISE(*datum, compute::Cast(*datum, type));\n+  }\n+  return Status::OK();\n+}\n+\n+inline Status EnsureNotDictionary(Expression::Call* call) {\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto new_options = *options;\n+    RETURN_NOT_OK(EnsureNotDictionary(&new_options.value_set));\n+    call->options.reset(new compute::SetLookupOptions(std::move(new_options)));\n+  }\n+  return Status::OK();\n+}\n+\n+inline Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const Expression::Call& call) {\n+  if (call.options == nullptr) {\n+    return nullptr;\n+  }\n+\n+  auto Finish = [](ScalarVector values, std::vector<std::string> names) {\n+    FieldVector fields(names.size());\n+    for (size_t i = 0; i < fields.size(); ++i) {\n+      fields[i] = field(std::move(names[i]), values[i]->type);\n+    }\n+    return std::make_shared<StructScalar>(std::move(values), struct_(std::move(fields)));\n+  };\n+\n+  if (auto options = GetSetLookupOptions(call)) {\n+    if (!options->value_set.is_array()) {\n+      return Status::NotImplemented(\"chunked value_set\");\n+    }\n+    return Finish(\n+        {\n+            std::make_shared<ListScalar>(options->value_set.make_array()),\n+            MakeScalar(options->skip_nulls),\n+        },\n+        {\"value_set\", \"skip_nulls\"});\n+  }\n+\n+  if (call.function_name == \"cast\") {\n+    auto options = checked_cast<const compute::CastOptions*>(call.options.get());\n+    return Finish(\n+        {\n+            MakeNullScalar(options->to_type),\n+            MakeScalar(options->allow_int_overflow),\n+            MakeScalar(options->allow_time_truncate),\n+            MakeScalar(options->allow_time_overflow),\n+            MakeScalar(options->allow_decimal_truncate),\n+            MakeScalar(options->allow_float_truncate),\n+            MakeScalar(options->allow_invalid_utf8),\n+        },\n+        {\n+            \"to_type_holder\",\n+            \"allow_int_overflow\",\n+            \"allow_time_truncate\",\n+            \"allow_time_overflow\",\n+            \"allow_decimal_truncate\",\n+            \"allow_float_truncate\",\n+            \"allow_invalid_utf8\",\n+        });\n+  }\n+\n+  return Status::NotImplemented(\"conversion of options for \", call.function_name);\n+}\n+\n+inline Status FunctionOptionsFromStructScalar(const StructScalar* repr,\n+                                              Expression::Call* call) {\n+  if (repr == nullptr) {\n+    call->options = nullptr;\n+    return Status::OK();\n+  }\n+\n+  if (IsSetLookup(call->function_name)) {\n+    ARROW_ASSIGN_OR_RAISE(auto value_set, repr->field(\"value_set\"));\n+    ARROW_ASSIGN_OR_RAISE(auto skip_nulls, repr->field(\"skip_nulls\"));\n+    call->options = std::make_shared<compute::SetLookupOptions>(\n+        checked_cast<const ListScalar&>(*value_set).value,\n+        checked_cast<const BooleanScalar&>(*skip_nulls).value);\n+    return Status::OK();\n+  }\n+\n+  if (call->function_name == \"cast\") {\n+    auto options = std::make_shared<compute::CastOptions>();\n+    ARROW_ASSIGN_OR_RAISE(auto to_type_holder, repr->field(\"to_type_holder\"));\n+    options->to_type = to_type_holder->type;\n+\n+    int i = 1;\n+    for (bool* opt : {\n+             &options->allow_int_overflow,\n+             &options->allow_time_truncate,\n+             &options->allow_time_overflow,\n+             &options->allow_decimal_truncate,\n+             &options->allow_float_truncate,\n+             &options->allow_invalid_utf8,\n+         }) {\n+      *opt = checked_cast<const BooleanScalar&>(*repr->value[i++]).value;\n+    }\n+\n+    call->options = std::move(options);\n+    return Status::OK();\n+  }\n+\n+  return Status::NotImplemented(\"conversion of options for \", call->function_name);\n+}\n+\n+struct FlattenedAssociativeChain {\n+  bool was_left_folded = true;\n+  std::vector<Expression> exprs, fringe;\n+\n+  explicit FlattenedAssociativeChain(Expression expr) : exprs{std::move(expr)} {\n+    auto call = CallNotNull(exprs.back());\n+    fringe = call->arguments;\n+\n+    auto it = fringe.begin();\n+\n+    while (it != fringe.end()) {\n+      auto sub_call = it->call();\n+      if (!sub_call || sub_call->function_name != call->function_name) {\n+        ++it;\n+        continue;\n+      }\n+\n+      if (it != fringe.begin()) {\n+        was_left_folded = false;\n+      }\n+\n+      exprs.push_back(std::move(*it));\n+      it = fringe.erase(it);\n+      it = fringe.insert(it, sub_call->arguments.begin(), sub_call->arguments.end());\n+      // NB: no increment so we hit sub_call's first argument next iteration\n+    }\n+\n+    DCHECK(std::all_of(exprs.begin(), exprs.end(), [](const Expression& expr) {\n+      return CallNotNull(expr)->options == nullptr;\n+    }));\n+  }\n+};\n+\n+inline Result<std::shared_ptr<compute::Function>> GetFunction(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (call.function_name != \"cast\") {\n+    return exec_context->func_registry()->GetFunction(call.function_name);\n+  }\n+  // XXX this special case is strange; why not make \"cast\" a ScalarFunction?\n+  const auto& to_type = checked_cast<const compute::CastOptions&>(*call.options).to_type;\n+  return compute::GetCastFunction(to_type);\n+}\n+\n+template <typename PreVisit, typename PostVisitCall>\n+Result<Expression> Modify(Expression expr, const PreVisit& pre,\n\nReview comment:\n       Add a comment/docstring?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n\nReview comment:\n       Why are you not passing `expr` directly here?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n\nReview comment:\n       Why is this useful?\r\n   Also note that \"immutable state\" is kind of self-contradictory. We probably need to stuff precomputed data elsewhere than in the kernel state... See ARROW-10556, but the solution may be something else than a caching layer.\n\n##########\nFile path: cpp/src/arrow/compute/cast.cc\n##########\n@@ -118,8 +118,86 @@ class CastMetaFunction : public MetaFunction {\n \n }  // namespace\n \n+const FunctionDoc struct_doc{\"Wrap Arrays into a StructArray\",\n+                             (\"Names of the StructArray's fields are\\n\"\n+                              \"specified through StructOptions.\"),\n+                             {},\n+                             \"StructOptions\"};\n+\n+Result<ValueDescr> StructResolve(KernelContext* ctx,\n+                                 const std::vector<ValueDescr>& descrs) {\n+  const auto& names = OptionsWrapper<StructOptions>::Get(ctx).field_names;\n+  if (names.size() != descrs.size()) {\n+    return Status::Invalid(\"Struct() was passed \", names.size(), \" field \", \"names but \",\n+                           descrs.size(), \" arguments\");\n+  }\n+\n+  size_t i = 0;\n+  FieldVector fields(descrs.size());\n+\n+  ValueDescr::Shape shape = ValueDescr::SCALAR;\n+  for (const ValueDescr& descr : descrs) {\n+    if (descr.shape != ValueDescr::SCALAR) {\n+      shape = ValueDescr::ARRAY;\n+    } else {\n+      switch (descr.type->id()) {\n+        case Type::EXTENSION:\n\nReview comment:\n       Hmm... shouldn't broadcasting an extension scalar be as simple as broadcasting the underlying storage scalar?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_cast_internal.cc\n##########\n@@ -160,16 +172,15 @@ void UnpackDictionary(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n     return;\n   }\n \n-  Result<Datum> result = Take(Datum(dict_arr.dictionary()), Datum(dict_arr.indices()),\n-                              /*options=*/TakeOptions::Defaults(), ctx->exec_context());\n-  if (!result.ok()) {\n-    ctx->SetStatus(result.status());\n-    return;\n-  }\n-  *out = *result;\n+  return Finish(Take(Datum(dict_arr.dictionary()), Datum(dict_arr.indices()),\n\nReview comment:\n       `KERNEL_ASSIGN_OR_RAISE` as well?\n\n##########\nFile path: cpp/src/arrow/compute/cast.cc\n##########\n@@ -135,7 +213,7 @@ CastFunction::CastFunction(std::string name, Type::type out_type)\n   impl_->out_type = out_type;\n }\n \n-CastFunction::~CastFunction() {}\n+CastFunction::~CastFunction() = default;\n\nReview comment:\n       Is there a particular reason for preferring one over the other, btw?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n+    return Expression{Parameter{*ref, std::move(descr)}};\n+  }\n+\n+  auto bound_call = *CallNotNull(*this);\n+\n+  ARROW_ASSIGN_OR_RAISE(bound_call.function, GetFunction(bound_call, exec_context));\n+\n+  for (auto&& argument : bound_call.arguments) {\n+    ARROW_ASSIGN_OR_RAISE(argument, argument.Bind(in, exec_context));\n+  }\n+  RETURN_NOT_OK(InsertImplicitCasts(&bound_call));\n+\n+  auto descrs = GetDescriptors(bound_call.arguments);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel, bound_call.function->DispatchExact(descrs));\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel_state,\n+                        InitKernelState(bound_call, exec_context));\n+  kernel_context.SetState(bound_call.kernel_state.get());\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      bound_call.descr,\n+      bound_call.kernel->signature->out_type().Resolve(&kernel_context, descrs));\n+\n+  return Expression(std::move(bound_call));\n+}\n+\n+Result<Expression> Expression::Bind(const Schema& in_schema,\n+                                    compute::ExecContext* exec_context) const {\n+  return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n+}\n+\n+Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+                                      compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return ExecuteScalarExpression(expr, input, &exec_context);\n+  }\n+\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\"Cannot Execute unbound expression.\");\n+  }\n+\n+  if (!expr.IsScalarExpression()) {\n+    return Status::Invalid(\n+        \"ExecuteScalarExpression cannot Execute non-scalar expression \", expr.ToString());\n+  }\n+\n+  if (auto lit = expr.literal()) return *lit;\n+\n+  if (auto ref = expr.field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum field, GetDatumField(*ref, input));\n+\n+    if (field.descr() != expr.descr()) {\n+      // Refernced field was present but didn't have the expected type.\n+      // Should we just error here? For now, pay dispatch cost and just cast.\n+      ARROW_ASSIGN_OR_RAISE(\n+          field, compute::Cast(field, expr.descr().type, compute::CastOptions::Safe(),\n+                               exec_context));\n+    }\n+\n+    return field;\n+  }\n+\n+  auto call = CallNotNull(expr);\n+\n+  std::vector<Datum> arguments(call->arguments.size());\n+  for (size_t i = 0; i < arguments.size(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(\n+        arguments[i], ExecuteScalarExpression(call->arguments[i], input, exec_context));\n+  }\n+\n+  auto executor = compute::detail::KernelExecutor::MakeScalar();\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  kernel_context.SetState(call->kernel_state.get());\n+\n+  auto kernel = call->kernel;\n+  auto descrs = GetDescriptors(arguments);\n+  auto options = call->options.get();\n+  RETURN_NOT_OK(executor->Init(&kernel_context, {kernel, descrs, options}));\n+\n+  auto listener = std::make_shared<compute::detail::DatumAccumulator>();\n+  RETURN_NOT_OK(executor->Execute(arguments, listener.get()));\n+  return executor->WrapResults(arguments, listener->values());\n+}\n+\n+std::array<std::pair<const Expression&, const Expression&>, 2>\n+ArgumentsAndFlippedArguments(const Expression::Call& call) {\n+  DCHECK_EQ(call.arguments.size(), 2);\n+  return {std::pair<const Expression&, const Expression&>{call.arguments[0],\n+                                                          call.arguments[1]},\n+          std::pair<const Expression&, const Expression&>{call.arguments[1],\n+                                                          call.arguments[0]}};\n+}\n+\n+template <typename BinOp, typename It,\n+          typename Out = typename std::iterator_traits<It>::value_type>\n+util::optional<Out> FoldLeft(It begin, It end, const BinOp& bin_op) {\n+  if (begin == end) return util::nullopt;\n+\n+  Out folded = std::move(*begin++);\n+  while (begin != end) {\n+    folded = bin_op(std::move(folded), std::move(*begin++));\n+  }\n+  return folded;\n+}\n+\n+util::optional<compute::NullHandling::type> GetNullHandling(\n+    const Expression::Call& call) {\n+  if (call.function && call.function->kind() == compute::Function::SCALAR) {\n+    return static_cast<const compute::ScalarKernel*>(call.kernel)->null_handling;\n+  }\n+  return util::nullopt;\n+}\n+\n+bool DefinitelyNotNull(const Expression& expr) {\n+  DCHECK(expr.IsBound());\n+\n+  if (expr.literal()) {\n+    return !expr.IsNullLiteral();\n+  }\n+\n+  if (expr.field_ref()) return false;\n+\n+  auto call = CallNotNull(expr);\n+  if (auto null_handling = GetNullHandling(*call)) {\n+    if (null_handling == compute::NullHandling::OUTPUT_NOT_NULL) {\n+      return true;\n+    }\n+    if (null_handling == compute::NullHandling::INTERSECTION) {\n+      return std::all_of(call->arguments.begin(), call->arguments.end(),\n+                         DefinitelyNotNull);\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+std::vector<FieldRef> FieldsInExpression(const Expression& expr) {\n+  if (auto lit = expr.literal()) return {};\n+\n+  if (auto ref = expr.field_ref()) {\n+    return {*ref};\n+  }\n+\n+  std::vector<FieldRef> fields;\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    auto argument_fields = FieldsInExpression(arg);\n+    std::move(argument_fields.begin(), argument_fields.end(), std::back_inserter(fields));\n+  }\n+  return fields;\n+}\n+\n+Result<Expression> FoldConstants(Expression expr) {\n+  return Modify(\n+      std::move(expr), [](Expression expr) { return expr; },\n+      [](Expression expr, ...) -> Result<Expression> {\n+        auto call = CallNotNull(expr);\n+        if (std::all_of(call->arguments.begin(), call->arguments.end(),\n+                        [](const Expression& argument) { return argument.literal(); })) {\n+          // all arguments are literal; we can evaluate this subexpression *now*\n+          static const Datum ignored_input;\n+          ARROW_ASSIGN_OR_RAISE(Datum constant,\n+                                ExecuteScalarExpression(expr, ignored_input));\n+\n+          return literal(std::move(constant));\n+        }\n+\n+        // XXX the following should probably be in a registry of passes instead\n+        // of inline\n+\n+        if (GetNullHandling(*call) == compute::NullHandling::INTERSECTION) {\n+          // kernels which always produce intersected validity can be resolved\n+          // to null *now* if any of their inputs is a null literal\n+          for (const auto& argument : call->arguments) {\n+            if (argument.IsNullLiteral()) {\n+              return argument;\n+            }\n+          }\n+        }\n+\n+        if (call->function_name == \"and_kleene\") {\n+          for (auto args : ArgumentsAndFlippedArguments(*call)) {\n+            // true and x == x\n+            if (args.first == literal(true)) return args.second;\n+\n+            // false and x == false\n+            if (args.first == literal(false)) return args.first;\n+\n+            // x and x == x\n+            if (args.first == args.second) return args.first;\n+          }\n+          return expr;\n+        }\n+\n+        if (call->function_name == \"or_kleene\") {\n+          for (auto args : ArgumentsAndFlippedArguments(*call)) {\n+            // false or x == x\n+            if (args.first == literal(false)) return args.second;\n+\n+            // true or x == true\n+            if (args.first == literal(true)) return args.first;\n+\n+            // x or x == x\n+            if (args.first == args.second) return args.first;\n+          }\n+          return expr;\n+        }\n+\n+        return expr;\n+      });\n+}\n+\n+inline std::vector<Expression> GuaranteeConjunctionMembers(\n+    const Expression& guaranteed_true_predicate) {\n+  auto guarantee = guaranteed_true_predicate.call();\n+  if (!guarantee || guarantee->function_name != \"and_kleene\") {\n+    return {guaranteed_true_predicate};\n+  }\n+  return FlattenedAssociativeChain(guaranteed_true_predicate).fringe;\n+}\n+\n+// Conjunction members which are represented in known_values are erased from\n+// conjunction_members\n+Status ExtractKnownFieldValuesImpl(\n+    std::vector<Expression>* conjunction_members,\n+    std::unordered_map<FieldRef, Datum, FieldRef::Hash>* known_values) {\n+  auto unconsumed_end =\n+      std::partition(conjunction_members->begin(), conjunction_members->end(),\n+                     [](const Expression& expr) {\n+                       // search for an equality conditions between a field and a literal\n+                       auto call = expr.call();\n+                       if (!call) return true;\n+\n+                       if (call->function_name == \"equal\") {\n+                         auto ref = call->arguments[0].field_ref();\n+                         auto lit = call->arguments[1].literal();\n+                         return !(ref && lit);\n\nReview comment:\n       I suppose the caller should be careful about argument order :-)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_cast_temporal.cc\n##########\n@@ -256,14 +251,45 @@ struct CastFunctor<Date64Type, Date32Type> {\n template <>\n struct CastFunctor<Date32Type, Date64Type> {\n   static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n-    // TODO: Make this work on scalar inputs\n     DCHECK_EQ(batch[0].kind(), Datum::ARRAY);\n \n     ShiftTime<int64_t, int32_t>(ctx, util::DIVIDE, kMillisecondsInDay, *batch[0].array(),\n                                 out->mutable_array());\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// date32, date64 to timestamp\n+\n+template <>\n+struct CastFunctor<TimestampType, Date32Type> {\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    DCHECK_EQ(batch[0].kind(), Datum::ARRAY);\n+\n+    const auto& out_type = checked_cast<const TimestampType&>(*out->type());\n+    // get conversion SECOND -> unit\n+    auto conversion = util::GetTimestampConversion(TimeUnit::SECOND, out_type.unit());\n+    DCHECK_EQ(conversion.first, util::MULTIPLY);\n+\n+    // multiply to achieve days -> unit\n+    conversion.second *= kMillisecondsInDay / 1000;\n+    ShiftTime<int32_t, int64_t>(ctx, util::MULTIPLY, conversion.second, *batch[0].array(),\n+                                out->mutable_array());\n+  }\n+};\n+\n+template <>\n+struct CastFunctor<TimestampType, Date64Type> {\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    DCHECK_EQ(batch[0].kind(), Datum::ARRAY);\n+\n+    const auto& out_type = checked_cast<const TimestampType&>(*out->type());\n+    auto conversion = util::GetTimestampConversion(TimeUnit::MILLI, out_type.unit());\n+    ShiftTime<int64_t, int64_t>(ctx, util::MULTIPLY, conversion.second, *batch[0].array(),\n\nReview comment:\n       Add a check on `conversion.first` as above?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n+    return Expression{Parameter{*ref, std::move(descr)}};\n+  }\n+\n+  auto bound_call = *CallNotNull(*this);\n+\n+  ARROW_ASSIGN_OR_RAISE(bound_call.function, GetFunction(bound_call, exec_context));\n+\n+  for (auto&& argument : bound_call.arguments) {\n+    ARROW_ASSIGN_OR_RAISE(argument, argument.Bind(in, exec_context));\n+  }\n+  RETURN_NOT_OK(InsertImplicitCasts(&bound_call));\n+\n+  auto descrs = GetDescriptors(bound_call.arguments);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel, bound_call.function->DispatchExact(descrs));\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel_state,\n+                        InitKernelState(bound_call, exec_context));\n+  kernel_context.SetState(bound_call.kernel_state.get());\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      bound_call.descr,\n+      bound_call.kernel->signature->out_type().Resolve(&kernel_context, descrs));\n+\n+  return Expression(std::move(bound_call));\n+}\n+\n+Result<Expression> Expression::Bind(const Schema& in_schema,\n+                                    compute::ExecContext* exec_context) const {\n+  return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n+}\n+\n+Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+                                      compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return ExecuteScalarExpression(expr, input, &exec_context);\n+  }\n+\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\"Cannot Execute unbound expression.\");\n+  }\n+\n+  if (!expr.IsScalarExpression()) {\n+    return Status::Invalid(\n+        \"ExecuteScalarExpression cannot Execute non-scalar expression \", expr.ToString());\n+  }\n+\n+  if (auto lit = expr.literal()) return *lit;\n+\n+  if (auto ref = expr.field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum field, GetDatumField(*ref, input));\n+\n+    if (field.descr() != expr.descr()) {\n+      // Refernced field was present but didn't have the expected type.\n+      // Should we just error here? For now, pay dispatch cost and just cast.\n+      ARROW_ASSIGN_OR_RAISE(\n+          field, compute::Cast(field, expr.descr().type, compute::CastOptions::Safe(),\n+                               exec_context));\n+    }\n+\n+    return field;\n+  }\n+\n+  auto call = CallNotNull(expr);\n+\n+  std::vector<Datum> arguments(call->arguments.size());\n+  for (size_t i = 0; i < arguments.size(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(\n+        arguments[i], ExecuteScalarExpression(call->arguments[i], input, exec_context));\n+  }\n+\n+  auto executor = compute::detail::KernelExecutor::MakeScalar();\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  kernel_context.SetState(call->kernel_state.get());\n+\n+  auto kernel = call->kernel;\n+  auto descrs = GetDescriptors(arguments);\n+  auto options = call->options.get();\n+  RETURN_NOT_OK(executor->Init(&kernel_context, {kernel, descrs, options}));\n+\n+  auto listener = std::make_shared<compute::detail::DatumAccumulator>();\n+  RETURN_NOT_OK(executor->Execute(arguments, listener.get()));\n+  return executor->WrapResults(arguments, listener->values());\n+}\n+\n+std::array<std::pair<const Expression&, const Expression&>, 2>\n+ArgumentsAndFlippedArguments(const Expression::Call& call) {\n+  DCHECK_EQ(call.arguments.size(), 2);\n+  return {std::pair<const Expression&, const Expression&>{call.arguments[0],\n+                                                          call.arguments[1]},\n+          std::pair<const Expression&, const Expression&>{call.arguments[1],\n+                                                          call.arguments[0]}};\n+}\n+\n+template <typename BinOp, typename It,\n+          typename Out = typename std::iterator_traits<It>::value_type>\n+util::optional<Out> FoldLeft(It begin, It end, const BinOp& bin_op) {\n+  if (begin == end) return util::nullopt;\n+\n+  Out folded = std::move(*begin++);\n+  while (begin != end) {\n+    folded = bin_op(std::move(folded), std::move(*begin++));\n+  }\n+  return folded;\n+}\n+\n+util::optional<compute::NullHandling::type> GetNullHandling(\n+    const Expression::Call& call) {\n+  if (call.function && call.function->kind() == compute::Function::SCALAR) {\n+    return static_cast<const compute::ScalarKernel*>(call.kernel)->null_handling;\n+  }\n+  return util::nullopt;\n+}\n+\n+bool DefinitelyNotNull(const Expression& expr) {\n+  DCHECK(expr.IsBound());\n+\n+  if (expr.literal()) {\n+    return !expr.IsNullLiteral();\n+  }\n+\n+  if (expr.field_ref()) return false;\n+\n+  auto call = CallNotNull(expr);\n+  if (auto null_handling = GetNullHandling(*call)) {\n+    if (null_handling == compute::NullHandling::OUTPUT_NOT_NULL) {\n+      return true;\n+    }\n+    if (null_handling == compute::NullHandling::INTERSECTION) {\n+      return std::all_of(call->arguments.begin(), call->arguments.end(),\n+                         DefinitelyNotNull);\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+std::vector<FieldRef> FieldsInExpression(const Expression& expr) {\n+  if (auto lit = expr.literal()) return {};\n+\n+  if (auto ref = expr.field_ref()) {\n+    return {*ref};\n+  }\n+\n+  std::vector<FieldRef> fields;\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    auto argument_fields = FieldsInExpression(arg);\n+    std::move(argument_fields.begin(), argument_fields.end(), std::back_inserter(fields));\n+  }\n+  return fields;\n+}\n+\n+Result<Expression> FoldConstants(Expression expr) {\n+  return Modify(\n+      std::move(expr), [](Expression expr) { return expr; },\n+      [](Expression expr, ...) -> Result<Expression> {\n+        auto call = CallNotNull(expr);\n+        if (std::all_of(call->arguments.begin(), call->arguments.end(),\n+                        [](const Expression& argument) { return argument.literal(); })) {\n+          // all arguments are literal; we can evaluate this subexpression *now*\n+          static const Datum ignored_input;\n+          ARROW_ASSIGN_OR_RAISE(Datum constant,\n+                                ExecuteScalarExpression(expr, ignored_input));\n+\n+          return literal(std::move(constant));\n+        }\n+\n+        // XXX the following should probably be in a registry of passes instead\n+        // of inline\n+\n+        if (GetNullHandling(*call) == compute::NullHandling::INTERSECTION) {\n+          // kernels which always produce intersected validity can be resolved\n+          // to null *now* if any of their inputs is a null literal\n+          for (const auto& argument : call->arguments) {\n+            if (argument.IsNullLiteral()) {\n+              return argument;\n+            }\n+          }\n+        }\n+\n+        if (call->function_name == \"and_kleene\") {\n+          for (auto args : ArgumentsAndFlippedArguments(*call)) {\n+            // true and x == x\n+            if (args.first == literal(true)) return args.second;\n+\n+            // false and x == false\n+            if (args.first == literal(false)) return args.first;\n+\n+            // x and x == x\n+            if (args.first == args.second) return args.first;\n+          }\n+          return expr;\n+        }\n+\n+        if (call->function_name == \"or_kleene\") {\n+          for (auto args : ArgumentsAndFlippedArguments(*call)) {\n+            // false or x == x\n+            if (args.first == literal(false)) return args.second;\n+\n+            // true or x == true\n+            if (args.first == literal(true)) return args.first;\n+\n+            // x or x == x\n+            if (args.first == args.second) return args.first;\n+          }\n+          return expr;\n+        }\n+\n+        return expr;\n+      });\n+}\n+\n+inline std::vector<Expression> GuaranteeConjunctionMembers(\n+    const Expression& guaranteed_true_predicate) {\n+  auto guarantee = guaranteed_true_predicate.call();\n+  if (!guarantee || guarantee->function_name != \"and_kleene\") {\n+    return {guaranteed_true_predicate};\n+  }\n+  return FlattenedAssociativeChain(guaranteed_true_predicate).fringe;\n+}\n+\n+// Conjunction members which are represented in known_values are erased from\n+// conjunction_members\n+Status ExtractKnownFieldValuesImpl(\n+    std::vector<Expression>* conjunction_members,\n+    std::unordered_map<FieldRef, Datum, FieldRef::Hash>* known_values) {\n+  auto unconsumed_end =\n+      std::partition(conjunction_members->begin(), conjunction_members->end(),\n+                     [](const Expression& expr) {\n+                       // search for an equality conditions between a field and a literal\n+                       auto call = expr.call();\n+                       if (!call) return true;\n+\n+                       if (call->function_name == \"equal\") {\n+                         auto ref = call->arguments[0].field_ref();\n+                         auto lit = call->arguments[1].literal();\n+                         return !(ref && lit);\n+                       }\n+\n+                       return true;\n+                     });\n+\n+  for (auto it = unconsumed_end; it != conjunction_members->end(); ++it) {\n+    auto call = CallNotNull(*it);\n+\n+    auto ref = call->arguments[0].field_ref();\n+    auto lit = call->arguments[1].literal();\n+\n+    auto it_success = known_values->emplace(*ref, *lit);\n+    if (it_success.second) continue;\n+\n+    // A value was already known for ref; check it\n+    auto ref_lit = it_success.first;\n+    if (*lit != ref_lit->second) {\n+      return Status::Invalid(\"Conflicting guarantees: (\", ref->ToString(),\n+                             \" == \", lit->ToString(), \") vs (\", ref->ToString(),\n+                             \" == \", ref_lit->second.ToString());\n+    }\n+  }\n+\n+  conjunction_members->erase(unconsumed_end, conjunction_members->end());\n+\n+  return Status::OK();\n+}\n+\n+Result<std::unordered_map<FieldRef, Datum, FieldRef::Hash>> ExtractKnownFieldValues(\n+    const Expression& guaranteed_true_predicate) {\n+  auto conjunction_members = GuaranteeConjunctionMembers(guaranteed_true_predicate);\n+  std::unordered_map<FieldRef, Datum, FieldRef::Hash> known_values;\n+  RETURN_NOT_OK(ExtractKnownFieldValuesImpl(&conjunction_members, &known_values));\n+  return known_values;\n+}\n+\n+Result<Expression> ReplaceFieldsWithKnownValues(\n+    const std::unordered_map<FieldRef, Datum, FieldRef::Hash>& known_values,\n+    Expression expr) {\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\n+        \"ReplaceFieldsWithKnownValues called on an unbound Expression\");\n+  }\n+\n+  return Modify(\n+      std::move(expr),\n+      [&known_values](Expression expr) -> Result<Expression> {\n+        if (auto ref = expr.field_ref()) {\n+          auto it = known_values.find(*ref);\n+          if (it != known_values.end()) {\n+            ARROW_ASSIGN_OR_RAISE(Datum lit,\n+                                  compute::Cast(it->second, expr.descr().type));\n+            return literal(std::move(lit));\n+          }\n+        }\n+        return expr;\n+      },\n+      [](Expression expr, ...) { return expr; });\n+}\n+\n+inline bool IsBinaryAssociativeCommutative(const Expression::Call& call) {\n+  static std::unordered_set<std::string> binary_associative_commutative{\n+      \"and\",      \"or\",  \"and_kleene\",       \"or_kleene\",  \"xor\",\n+      \"multiply\", \"add\", \"multiply_checked\", \"add_checked\"};\n+\n+  auto it = binary_associative_commutative.find(call.function_name);\n+  return it != binary_associative_commutative.end();\n+}\n+\n+Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Canonicalize(std::move(expr), &exec_context);\n+  }\n+\n+  // If potentially reconstructing more deeply than a call's immediate arguments\n+  // (for example, when reorganizing an associative chain), add expressions to this set to\n+  // avoid unnecessary work\n+  struct {\n+    std::unordered_set<Expression, Expression::Hash> set_;\n+\n+    bool operator()(const Expression& expr) const {\n+      return set_.find(expr) != set_.end();\n+    }\n+\n+    void Add(std::vector<Expression> exprs) {\n+      std::move(exprs.begin(), exprs.end(), std::inserter(set_, set_.end()));\n+    }\n+  } AlreadyCanonicalized;\n+\n+  return Modify(\n+      std::move(expr),\n+      [&AlreadyCanonicalized, exec_context](Expression expr) -> Result<Expression> {\n+        auto call = expr.call();\n+        if (!call) return expr;\n+\n+        if (AlreadyCanonicalized(expr)) return expr;\n+\n+        if (IsBinaryAssociativeCommutative(*call)) {\n+          struct {\n+            int Priority(const Expression& operand) const {\n+              // order literals first, starting with nulls\n\nReview comment:\n       Perhaps this is not important, but note the reverse convention is used for comparisons...\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_cast_internal.cc\n##########\n@@ -149,6 +149,18 @@ void CastNumberToNumberUnsafe(Type::type in_type, Type::type out_type, const Dat\n // ----------------------------------------------------------------------\n \n void UnpackDictionary(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  auto Finish = [&](Result<Datum> result) {\n+    if (!result.ok()) {\n+      ctx->SetStatus(result.status());\n+      return;\n+    }\n+    *out = *result;\n+  };\n+\n+  if (out->is_scalar()) {\n+    return Finish(batch[0].scalar_as<DictionaryScalar>().GetEncodedValue());\n\nReview comment:\n       `KERNEL_ASSIGN_OR_RAISE(*out, ctx, batch[0].scalar_as<DictionaryScalar>().GetEncodedValue())` should work\n\n##########\nFile path: cpp/src/arrow/compute/kernels/util_internal.cc\n##########\n@@ -57,6 +57,29 @@ PrimitiveArg GetPrimitiveArg(const ArrayData& arr) {\n   return arg;\n }\n \n+ArrayKernelExec TrivialScalarUnaryAsArraysExec(ArrayKernelExec exec) {\n+  return [exec](KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    if (out->is_array()) {\n+      return exec(ctx, batch, out);\n+    }\n+\n+    if (!batch[0].scalar()->is_valid) {\n+      out->scalar()->is_valid = false;\n+      return;\n+    }\n+\n+    Datum array_in, array_out;\n+    KERNEL_RETURN_IF_ERROR(\n\nReview comment:\n       `KERNEL_ASSIGN_OR_RAISE(array_in, ctx, ...)`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/util_internal.cc\n##########\n@@ -57,6 +57,29 @@ PrimitiveArg GetPrimitiveArg(const ArrayData& arr) {\n   return arg;\n }\n \n+ArrayKernelExec TrivialScalarUnaryAsArraysExec(ArrayKernelExec exec) {\n+  return [exec](KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    if (out->is_array()) {\n+      return exec(ctx, batch, out);\n+    }\n+\n+    if (!batch[0].scalar()->is_valid) {\n+      out->scalar()->is_valid = false;\n+      return;\n+    }\n+\n+    Datum array_in, array_out;\n+    KERNEL_RETURN_IF_ERROR(\n+        ctx, MakeArrayFromScalar(*batch[0].scalar(), 1).As<Datum>().Value(&array_in));\n+    KERNEL_RETURN_IF_ERROR(\n+        ctx, MakeArrayFromScalar(*out->scalar(), 1).As<Datum>().Value(&array_out));\n\nReview comment:\n       This is just like `MakeArrayOfNull`, right?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n+    return Expression{Parameter{*ref, std::move(descr)}};\n+  }\n+\n+  auto bound_call = *CallNotNull(*this);\n+\n+  ARROW_ASSIGN_OR_RAISE(bound_call.function, GetFunction(bound_call, exec_context));\n+\n+  for (auto&& argument : bound_call.arguments) {\n+    ARROW_ASSIGN_OR_RAISE(argument, argument.Bind(in, exec_context));\n+  }\n+  RETURN_NOT_OK(InsertImplicitCasts(&bound_call));\n+\n+  auto descrs = GetDescriptors(bound_call.arguments);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel, bound_call.function->DispatchExact(descrs));\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel_state,\n+                        InitKernelState(bound_call, exec_context));\n+  kernel_context.SetState(bound_call.kernel_state.get());\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      bound_call.descr,\n+      bound_call.kernel->signature->out_type().Resolve(&kernel_context, descrs));\n+\n+  return Expression(std::move(bound_call));\n+}\n+\n+Result<Expression> Expression::Bind(const Schema& in_schema,\n+                                    compute::ExecContext* exec_context) const {\n+  return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n+}\n+\n+Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+                                      compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return ExecuteScalarExpression(expr, input, &exec_context);\n+  }\n+\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\"Cannot Execute unbound expression.\");\n+  }\n+\n+  if (!expr.IsScalarExpression()) {\n+    return Status::Invalid(\n+        \"ExecuteScalarExpression cannot Execute non-scalar expression \", expr.ToString());\n+  }\n+\n+  if (auto lit = expr.literal()) return *lit;\n+\n+  if (auto ref = expr.field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum field, GetDatumField(*ref, input));\n+\n+    if (field.descr() != expr.descr()) {\n+      // Refernced field was present but didn't have the expected type.\n+      // Should we just error here? For now, pay dispatch cost and just cast.\n+      ARROW_ASSIGN_OR_RAISE(\n+          field, compute::Cast(field, expr.descr().type, compute::CastOptions::Safe(),\n+                               exec_context));\n+    }\n+\n+    return field;\n+  }\n+\n+  auto call = CallNotNull(expr);\n+\n+  std::vector<Datum> arguments(call->arguments.size());\n+  for (size_t i = 0; i < arguments.size(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(\n+        arguments[i], ExecuteScalarExpression(call->arguments[i], input, exec_context));\n+  }\n+\n+  auto executor = compute::detail::KernelExecutor::MakeScalar();\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  kernel_context.SetState(call->kernel_state.get());\n+\n+  auto kernel = call->kernel;\n+  auto descrs = GetDescriptors(arguments);\n+  auto options = call->options.get();\n+  RETURN_NOT_OK(executor->Init(&kernel_context, {kernel, descrs, options}));\n+\n+  auto listener = std::make_shared<compute::detail::DatumAccumulator>();\n+  RETURN_NOT_OK(executor->Execute(arguments, listener.get()));\n+  return executor->WrapResults(arguments, listener->values());\n+}\n+\n+std::array<std::pair<const Expression&, const Expression&>, 2>\n+ArgumentsAndFlippedArguments(const Expression::Call& call) {\n+  DCHECK_EQ(call.arguments.size(), 2);\n+  return {std::pair<const Expression&, const Expression&>{call.arguments[0],\n+                                                          call.arguments[1]},\n+          std::pair<const Expression&, const Expression&>{call.arguments[1],\n+                                                          call.arguments[0]}};\n+}\n+\n+template <typename BinOp, typename It,\n+          typename Out = typename std::iterator_traits<It>::value_type>\n+util::optional<Out> FoldLeft(It begin, It end, const BinOp& bin_op) {\n+  if (begin == end) return util::nullopt;\n+\n+  Out folded = std::move(*begin++);\n+  while (begin != end) {\n+    folded = bin_op(std::move(folded), std::move(*begin++));\n+  }\n+  return folded;\n+}\n+\n+util::optional<compute::NullHandling::type> GetNullHandling(\n+    const Expression::Call& call) {\n+  if (call.function && call.function->kind() == compute::Function::SCALAR) {\n+    return static_cast<const compute::ScalarKernel*>(call.kernel)->null_handling;\n+  }\n+  return util::nullopt;\n+}\n+\n+bool DefinitelyNotNull(const Expression& expr) {\n+  DCHECK(expr.IsBound());\n+\n+  if (expr.literal()) {\n+    return !expr.IsNullLiteral();\n+  }\n+\n+  if (expr.field_ref()) return false;\n+\n+  auto call = CallNotNull(expr);\n+  if (auto null_handling = GetNullHandling(*call)) {\n+    if (null_handling == compute::NullHandling::OUTPUT_NOT_NULL) {\n+      return true;\n+    }\n+    if (null_handling == compute::NullHandling::INTERSECTION) {\n+      return std::all_of(call->arguments.begin(), call->arguments.end(),\n+                         DefinitelyNotNull);\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+std::vector<FieldRef> FieldsInExpression(const Expression& expr) {\n+  if (auto lit = expr.literal()) return {};\n+\n+  if (auto ref = expr.field_ref()) {\n+    return {*ref};\n+  }\n+\n+  std::vector<FieldRef> fields;\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    auto argument_fields = FieldsInExpression(arg);\n+    std::move(argument_fields.begin(), argument_fields.end(), std::back_inserter(fields));\n+  }\n+  return fields;\n+}\n+\n+Result<Expression> FoldConstants(Expression expr) {\n+  return Modify(\n+      std::move(expr), [](Expression expr) { return expr; },\n+      [](Expression expr, ...) -> Result<Expression> {\n+        auto call = CallNotNull(expr);\n+        if (std::all_of(call->arguments.begin(), call->arguments.end(),\n+                        [](const Expression& argument) { return argument.literal(); })) {\n+          // all arguments are literal; we can evaluate this subexpression *now*\n+          static const Datum ignored_input;\n+          ARROW_ASSIGN_OR_RAISE(Datum constant,\n+                                ExecuteScalarExpression(expr, ignored_input));\n+\n+          return literal(std::move(constant));\n+        }\n+\n+        // XXX the following should probably be in a registry of passes instead\n+        // of inline\n+\n+        if (GetNullHandling(*call) == compute::NullHandling::INTERSECTION) {\n+          // kernels which always produce intersected validity can be resolved\n+          // to null *now* if any of their inputs is a null literal\n+          for (const auto& argument : call->arguments) {\n+            if (argument.IsNullLiteral()) {\n+              return argument;\n+            }\n+          }\n+        }\n+\n+        if (call->function_name == \"and_kleene\") {\n+          for (auto args : ArgumentsAndFlippedArguments(*call)) {\n+            // true and x == x\n+            if (args.first == literal(true)) return args.second;\n+\n+            // false and x == false\n+            if (args.first == literal(false)) return args.first;\n+\n+            // x and x == x\n+            if (args.first == args.second) return args.first;\n+          }\n+          return expr;\n+        }\n+\n+        if (call->function_name == \"or_kleene\") {\n+          for (auto args : ArgumentsAndFlippedArguments(*call)) {\n+            // false or x == x\n+            if (args.first == literal(false)) return args.second;\n+\n+            // true or x == true\n+            if (args.first == literal(true)) return args.first;\n+\n+            // x or x == x\n+            if (args.first == args.second) return args.first;\n+          }\n+          return expr;\n+        }\n+\n+        return expr;\n+      });\n+}\n+\n+inline std::vector<Expression> GuaranteeConjunctionMembers(\n+    const Expression& guaranteed_true_predicate) {\n+  auto guarantee = guaranteed_true_predicate.call();\n+  if (!guarantee || guarantee->function_name != \"and_kleene\") {\n+    return {guaranteed_true_predicate};\n+  }\n+  return FlattenedAssociativeChain(guaranteed_true_predicate).fringe;\n+}\n+\n+// Conjunction members which are represented in known_values are erased from\n+// conjunction_members\n+Status ExtractKnownFieldValuesImpl(\n+    std::vector<Expression>* conjunction_members,\n+    std::unordered_map<FieldRef, Datum, FieldRef::Hash>* known_values) {\n+  auto unconsumed_end =\n+      std::partition(conjunction_members->begin(), conjunction_members->end(),\n+                     [](const Expression& expr) {\n+                       // search for an equality conditions between a field and a literal\n+                       auto call = expr.call();\n+                       if (!call) return true;\n+\n+                       if (call->function_name == \"equal\") {\n+                         auto ref = call->arguments[0].field_ref();\n+                         auto lit = call->arguments[1].literal();\n+                         return !(ref && lit);\n+                       }\n+\n+                       return true;\n+                     });\n+\n+  for (auto it = unconsumed_end; it != conjunction_members->end(); ++it) {\n+    auto call = CallNotNull(*it);\n+\n+    auto ref = call->arguments[0].field_ref();\n+    auto lit = call->arguments[1].literal();\n+\n+    auto it_success = known_values->emplace(*ref, *lit);\n+    if (it_success.second) continue;\n+\n+    // A value was already known for ref; check it\n+    auto ref_lit = it_success.first;\n+    if (*lit != ref_lit->second) {\n+      return Status::Invalid(\"Conflicting guarantees: (\", ref->ToString(),\n+                             \" == \", lit->ToString(), \") vs (\", ref->ToString(),\n+                             \" == \", ref_lit->second.ToString());\n+    }\n+  }\n+\n+  conjunction_members->erase(unconsumed_end, conjunction_members->end());\n+\n+  return Status::OK();\n+}\n+\n+Result<std::unordered_map<FieldRef, Datum, FieldRef::Hash>> ExtractKnownFieldValues(\n+    const Expression& guaranteed_true_predicate) {\n+  auto conjunction_members = GuaranteeConjunctionMembers(guaranteed_true_predicate);\n+  std::unordered_map<FieldRef, Datum, FieldRef::Hash> known_values;\n+  RETURN_NOT_OK(ExtractKnownFieldValuesImpl(&conjunction_members, &known_values));\n+  return known_values;\n+}\n+\n+Result<Expression> ReplaceFieldsWithKnownValues(\n+    const std::unordered_map<FieldRef, Datum, FieldRef::Hash>& known_values,\n+    Expression expr) {\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\n+        \"ReplaceFieldsWithKnownValues called on an unbound Expression\");\n+  }\n+\n+  return Modify(\n+      std::move(expr),\n+      [&known_values](Expression expr) -> Result<Expression> {\n+        if (auto ref = expr.field_ref()) {\n+          auto it = known_values.find(*ref);\n+          if (it != known_values.end()) {\n+            ARROW_ASSIGN_OR_RAISE(Datum lit,\n+                                  compute::Cast(it->second, expr.descr().type));\n+            return literal(std::move(lit));\n+          }\n+        }\n+        return expr;\n+      },\n+      [](Expression expr, ...) { return expr; });\n+}\n+\n+inline bool IsBinaryAssociativeCommutative(const Expression::Call& call) {\n+  static std::unordered_set<std::string> binary_associative_commutative{\n+      \"and\",      \"or\",  \"and_kleene\",       \"or_kleene\",  \"xor\",\n+      \"multiply\", \"add\", \"multiply_checked\", \"add_checked\"};\n+\n+  auto it = binary_associative_commutative.find(call.function_name);\n+  return it != binary_associative_commutative.end();\n+}\n+\n+Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Canonicalize(std::move(expr), &exec_context);\n+  }\n+\n+  // If potentially reconstructing more deeply than a call's immediate arguments\n+  // (for example, when reorganizing an associative chain), add expressions to this set to\n+  // avoid unnecessary work\n+  struct {\n+    std::unordered_set<Expression, Expression::Hash> set_;\n+\n+    bool operator()(const Expression& expr) const {\n+      return set_.find(expr) != set_.end();\n+    }\n+\n+    void Add(std::vector<Expression> exprs) {\n+      std::move(exprs.begin(), exprs.end(), std::inserter(set_, set_.end()));\n+    }\n+  } AlreadyCanonicalized;\n+\n+  return Modify(\n+      std::move(expr),\n+      [&AlreadyCanonicalized, exec_context](Expression expr) -> Result<Expression> {\n+        auto call = expr.call();\n+        if (!call) return expr;\n+\n+        if (AlreadyCanonicalized(expr)) return expr;\n+\n+        if (IsBinaryAssociativeCommutative(*call)) {\n+          struct {\n+            int Priority(const Expression& operand) const {\n+              // order literals first, starting with nulls\n+              if (operand.IsNullLiteral()) return 0;\n+              if (operand.literal()) return 1;\n+              return 2;\n+            }\n+            bool operator()(const Expression& l, const Expression& r) const {\n+              return Priority(l) < Priority(r);\n+            }\n+          } CanonicalOrdering;\n+\n+          FlattenedAssociativeChain chain(expr);\n+          if (chain.was_left_folded &&\n+              std::is_sorted(chain.fringe.begin(), chain.fringe.end(),\n+                             CanonicalOrdering)) {\n+            AlreadyCanonicalized.Add(std::move(chain.exprs));\n+            return expr;\n+          }\n+\n+          std::stable_sort(chain.fringe.begin(), chain.fringe.end(), CanonicalOrdering);\n+\n+          // fold the chain back up\n+          auto folded =\n+              FoldLeft(chain.fringe.begin(), chain.fringe.end(),\n+                       [call, &AlreadyCanonicalized](Expression l, Expression r) {\n+                         auto canonicalized_call = *call;\n+                         canonicalized_call.arguments = {std::move(l), std::move(r)};\n+                         Expression expr(std::move(canonicalized_call));\n+                         AlreadyCanonicalized.Add({expr});\n+                         return expr;\n+                       });\n+          return std::move(*folded);\n+        }\n+\n+        if (auto cmp = Comparison::Get(call->function_name)) {\n+          if (call->arguments[0].literal() && !call->arguments[1].literal()) {\n+            // ensure that literals are on comparisons' RHS\n+            auto flipped_call = *call;\n+            flipped_call.function_name =\n+                Comparison::GetName(Comparison::GetFlipped(*cmp));\n+            // look up the flipped kernel\n+            // TODO extract a helper for use here and in Bind\n+            ARROW_ASSIGN_OR_RAISE(\n+                auto function,\n+                exec_context->func_registry()->GetFunction(flipped_call.function_name));\n+\n+            auto descrs = GetDescriptors(flipped_call.arguments);\n+            ARROW_ASSIGN_OR_RAISE(flipped_call.kernel, function->DispatchExact(descrs));\n+\n+            std::swap(flipped_call.arguments[0], flipped_call.arguments[1]);\n+            return Expression(std::move(flipped_call));\n+          }\n+        }\n+\n+        return expr;\n+      },\n+      [](Expression expr, ...) { return expr; });\n+}\n+\n+Result<Expression> DirectComparisonSimplification(Expression expr,\n+                                                  const Expression::Call& guarantee) {\n+  return Modify(\n+      std::move(expr), [](Expression expr) { return expr; },\n+      [&guarantee](Expression expr, ...) -> Result<Expression> {\n+        auto call = expr.call();\n+        if (!call) return expr;\n+\n+        // Ensure both calls are comparisons with equal LHS and scalar RHS\n+        auto cmp = Comparison::Get(expr);\n+        auto cmp_guarantee = Comparison::Get(guarantee.function_name);\n+        if (!cmp || !cmp_guarantee) return expr;\n+\n+        if (call->arguments[0] != guarantee.arguments[0]) return expr;\n+\n+        auto rhs = call->arguments[1].literal();\n+        auto guarantee_rhs = guarantee.arguments[1].literal();\n+        if (!rhs || !guarantee_rhs) return expr;\n+\n+        if (!rhs->is_scalar() || !guarantee_rhs->is_scalar()) {\n+          return expr;\n+        }\n+\n+        ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_guarantee_rhs,\n+                              Comparison::Execute(*rhs, *guarantee_rhs));\n+        DCHECK_NE(cmp_rhs_guarantee_rhs, Comparison::NA);\n+\n+        if (cmp_rhs_guarantee_rhs == Comparison::EQUAL) {\n+          // RHS of filter is equal to RHS of guarantee\n+\n+          if ((*cmp_guarantee & *cmp) == *cmp_guarantee) {\n+            // guarantee is a subset of filter, so all data will be included\n+            return literal(true);\n+          }\n+\n+          if ((*cmp_guarantee & *cmp) == 0) {\n+            // guarantee disjoint with filter, so all data will be excluded\n+            return literal(false);\n+          }\n+\n+          return expr;\n+        }\n+\n+        if (*cmp_guarantee & cmp_rhs_guarantee_rhs) {\n+          // unusable guarantee\n+          return expr;\n+        }\n+\n+        if (*cmp & Comparison::GetFlipped(cmp_rhs_guarantee_rhs)) {\n+          // x > 1, x >= 1, x != 1 guaranteed by x >= 3\n+          return literal(true);\n+        } else {\n+          // x < 1, x <= 1, x == 1 unsatisfiable if x >= 3\n+          return literal(false);\n+        }\n+      });\n+}\n+\n+Result<Expression> SimplifyWithGuarantee(Expression expr,\n+                                         const Expression& guaranteed_true_predicate) {\n+  auto conjunction_members = GuaranteeConjunctionMembers(guaranteed_true_predicate);\n+\n+  std::unordered_map<FieldRef, Datum, FieldRef::Hash> known_values;\n+  RETURN_NOT_OK(ExtractKnownFieldValuesImpl(&conjunction_members, &known_values));\n+\n+  ARROW_ASSIGN_OR_RAISE(expr,\n+                        ReplaceFieldsWithKnownValues(known_values, std::move(expr)));\n+\n+  auto CanonicalizeAndFoldConstants = [&expr] {\n+    ARROW_ASSIGN_OR_RAISE(expr, Canonicalize(std::move(expr)));\n+    ARROW_ASSIGN_OR_RAISE(expr, FoldConstants(std::move(expr)));\n+    return Status::OK();\n+  };\n+  RETURN_NOT_OK(CanonicalizeAndFoldConstants());\n+\n+  for (const auto& guarantee : conjunction_members) {\n\nReview comment:\n       Instead of looping on conjunction members, have you tried to match all members at once in the post-visit callback in `DirectComparisonSimplification`?\n\n##########\nFile path: cpp/src/arrow/dataset/partition.h\n##########\n@@ -294,5 +285,22 @@ class ARROW_DS_EXPORT PartitioningOrFactory {\n   std::shared_ptr<Partitioning> partitioning_;\n };\n \n+/// \\brief Assemble lists of indices of identical rows.\n+///\n+/// \\param[in] by A StructArray whose columns will be used as grouping criteria.\n+/// \\return A StructArray mapping unique rows (in field \"values\", represented as a\n+///         StructArray with the same fields as `by`) to lists of indices where\n+///         that row appears (in field \"groupings\").\n\nReview comment:\n       So the return type is `struct{values: <by.type>, groupings: list[int64]}`?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n\nReview comment:\n       Of course, this may be deferred to a later JIRA. But should add a TODO and open the JIRA at least.\n\n##########\nFile path: cpp/src/arrow/dataset/partition.h\n##########\n@@ -63,13 +63,13 @@ class ARROW_DS_EXPORT Partitioning {\n   /// produce sub-batches which satisfy mutually exclusive Expressions.\n   struct PartitionedBatches {\n     RecordBatchVector batches;\n-    ExpressionVector expressions;\n+    std::vector<Expression> expressions;\n\nReview comment:\n       We could keep `ExpressionVector`...\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -62,10 +63,7 @@ class ARROW_DS_EXPORT ScanOptions {\n   std::shared_ptr<ScanOptions> ReplaceSchema(std::shared_ptr<Schema> schema) const;\n \n   // Filter\n-  std::shared_ptr<Expression> filter = scalar(true);\n-\n-  // Evaluator for Filter\n-  std::shared_ptr<ExpressionEvaluator> evaluator;\n+  Expression filter2 = literal(true);\n\nReview comment:\n       Why `filter2`? Is it just to help with refactoring? (will it be renamed back to `filter`?)\n\n##########\nFile path: cpp/src/arrow/dataset/partition_test.cc\n##########\n@@ -21,52 +21,51 @@\n #include <gtest/gtest.h>\n \n #include <cstdint>\n-#include <map>\n #include <memory>\n #include <regex>\n #include <string>\n #include <vector>\n \n-#include \"arrow/dataset/file_base.h\"\n #include \"arrow/dataset/scanner_internal.h\"\n #include \"arrow/dataset/test_util.h\"\n-#include \"arrow/filesystem/localfs.h\"\n #include \"arrow/filesystem/path_util.h\"\n #include \"arrow/status.h\"\n #include \"arrow/testing/gtest_util.h\"\n-#include \"arrow/util/io_util.h\"\n \n namespace arrow {\n using internal::checked_pointer_cast;\n \n namespace dataset {\n \n-using E = TestExpression;\n-\n class TestPartitioning : public ::testing::Test {\n  public:\n   void AssertParseError(const std::string& path) {\n     ASSERT_RAISES(Invalid, partitioning_->Parse(path));\n   }\n \n-  void AssertParse(const std::string& path, E expected) {\n+  void AssertParse(const std::string& path, Expression expected) {\n     ASSERT_OK_AND_ASSIGN(auto parsed, partitioning_->Parse(path));\n-    ASSERT_EQ(E{parsed}, expected);\n+    ASSERT_EQ(parsed, expected);\n   }\n \n   template <StatusCode code = StatusCode::Invalid>\n-  void AssertFormatError(E expr) {\n-    ASSERT_EQ(partitioning_->Format(*expr.expression).status().code(), code);\n+  void AssertFormatError(Expression expr) {\n+    ASSERT_EQ(partitioning_->Format(expr).status().code(), code);\n   }\n \n-  void AssertFormat(E expr, const std::string& expected) {\n-    ASSERT_OK_AND_ASSIGN(auto formatted, partitioning_->Format(*expr.expression));\n+  void AssertFormat(Expression expr, const std::string& expected) {\n+    // formatted partition expressions are bound to the schema of the dataset being\n+    // written\n+    ASSERT_OK_AND_ASSIGN(auto formatted, partitioning_->Format(expr));\n     ASSERT_EQ(formatted, expected);\n \n     // ensure the formatted path round trips the relevant components of the partition\n     // expression: roundtripped should be a subset of expr\n-    ASSERT_OK_AND_ASSIGN(auto roundtripped, partitioning_->Parse(formatted));\n-    ASSERT_EQ(E{roundtripped->Assume(*expr.expression)}, E{scalar(true)});\n+    ASSERT_OK_AND_ASSIGN(Expression roundtripped, partitioning_->Parse(formatted));\n+\n+    ASSERT_OK_AND_ASSIGN(roundtripped, roundtripped.Bind(*written_schema_));\n\nReview comment:\n       If we format `roundtripped` again, it should produce the same string, right?\n\n##########\nFile path: cpp/src/arrow/dataset/partition.cc\n##########\n@@ -573,5 +530,192 @@ Result<std::shared_ptr<Schema>> PartitioningOrFactory::GetOrInferSchema(\n   return factory()->Inspect(paths);\n }\n \n+// Transform an array of counts to offsets which will divide a ListArray\n+// into an equal number of slices with corresponding lengths.\n+inline Result<std::shared_ptr<Array>> CountsToOffsets(\n+    std::shared_ptr<Int64Array> counts) {\n+  Int32Builder offset_builder;\n\nReview comment:\n       Not sure this is performance-critical, but if it is, note that `Int32Builder` will pointlessly build up a null bitmap bit by bit.\n\n##########\nFile path: cpp/src/arrow/dataset/expression.h\n##########\n@@ -0,0 +1,234 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/dataset/type_fwd.h\"\n+#include \"arrow/dataset/visibility.h\"\n+#include \"arrow/datum.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/scalar.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace dataset {\n+\n+/// An unbound expression which maps a single Datum to another Datum.\n+/// An expression is one of\n+/// - A literal Datum.\n+/// - A reference to a single (potentially nested) field of the input Datum.\n+/// - A call to a compute function, with arguments specified by other Expressions.\n+class ARROW_DS_EXPORT Expression {\n+ public:\n+  struct Call {\n+    std::string function_name;\n+    std::vector<Expression> arguments;\n+    std::shared_ptr<compute::FunctionOptions> options;\n+\n+    // post-Bind properties:\n+    const compute::Kernel* kernel = NULLPTR;\n+    std::shared_ptr<compute::Function> function;\n+    std::shared_ptr<compute::KernelState> kernel_state;\n+    ValueDescr descr;\n+  };\n+\n+  std::string ToString() const;\n+  bool Equals(const Expression& other) const;\n+  size_t hash() const;\n+  struct Hash {\n+    size_t operator()(const Expression& expr) const { return expr.hash(); }\n+  };\n+\n+  /// Bind this expression to the given input type, looking up Kernels and field types.\n+  /// Some expression simplification may be performed and implicit casts will be inserted.\n+  /// Any state necessary for execution will be initialized and returned.\n+  Result<Expression> Bind(ValueDescr in, compute::ExecContext* = NULLPTR) const;\n+  Result<Expression> Bind(const Schema& in_schema, compute::ExecContext* = NULLPTR) const;\n+\n+  // XXX someday\n+  // Clone all KernelState in this bound expression. If any function referenced by this\n+  // expression has mutable KernelState, it is not safe to execute or apply simplification\n+  // passes to it (or copies of it!) from multiple threads. Cloning state produces new\n+  // KernelStates where necessary to ensure that Expressions may be manipulated safely\n+  // on multiple threads.\n+  // Result<ExpressionState> CloneState() const;\n+  // Status SetState(ExpressionState);\n+\n+  /// Return true if all an expression's field references have explicit ValueDescr and all\n+  /// of its functions' kernels are looked up.\n+  bool IsBound() const;\n+\n+  /// Return true if this expression is composed only of Scalar literals, field\n+  /// references, and calls to ScalarFunctions.\n+  bool IsScalarExpression() const;\n+\n+  /// Return true if this expression is literal and entirely null.\n+  bool IsNullLiteral() const;\n+\n+  /// Return true if this expression could evaluate to true.\n+  bool IsSatisfiable() const;\n+\n+  // XXX someday\n+  // Result<PipelineGraph> GetPipelines();\n+\n+  const Call* call() const;\n+  const Datum* literal() const;\n+  const FieldRef* field_ref() const;\n+\n+  ValueDescr descr() const;\n+  // XXX someday\n+  // NullGeneralization::type nullable() const;\n+\n+  struct Parameter {\n+    FieldRef ref;\n+    ValueDescr descr;\n+  };\n+\n+  Expression() = default;\n+  explicit Expression(Call call);\n+  explicit Expression(Datum literal);\n+  explicit Expression(Parameter parameter);\n+\n+ private:\n+  using Impl = util::Variant<Datum, Parameter, Call>;\n+  std::shared_ptr<Impl> impl_;\n+\n+  ARROW_EXPORT friend bool Identical(const Expression& l, const Expression& r);\n+\n+  ARROW_EXPORT friend void PrintTo(const Expression&, std::ostream*);\n+};\n+\n+inline bool operator==(const Expression& l, const Expression& r) { return l.Equals(r); }\n+inline bool operator!=(const Expression& l, const Expression& r) { return !l.Equals(r); }\n+\n+// Factories\n+\n+ARROW_DS_EXPORT\n+Expression literal(Datum lit);\n+\n+template <typename Arg>\n+Expression literal(Arg&& arg) {\n+  return literal(Datum(std::forward<Arg>(arg)));\n+}\n+\n+ARROW_DS_EXPORT\n+Expression field_ref(FieldRef ref);\n+\n+ARROW_DS_EXPORT\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options = NULLPTR);\n+\n+template <typename Options, typename = typename std::enable_if<std::is_base_of<\n+                                compute::FunctionOptions, Options>::value>::type>\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                Options options) {\n+  return call(std::move(function), std::move(arguments),\n+              std::make_shared<Options>(std::move(options)));\n+}\n+\n+ARROW_DS_EXPORT\n+std::vector<FieldRef> FieldsInExpression(const Expression&);\n+\n+ARROW_DS_EXPORT\n+Result<std::unordered_map<FieldRef, Datum, FieldRef::Hash>> ExtractKnownFieldValues(\n+    const Expression& guaranteed_true_predicate);\n+\n+/// \\defgroup expression-passes Functions for modification of Expressions\n+///\n+/// @{\n+///\n+/// These operate on bound expressions.\n+\n+/// Weak canonicalization which establishes guarantees for subsequent passes. Even\n+/// equivalent Expressions may result in different canonicalized expressions.\n+/// TODO this could be a strong canonicalization\n+ARROW_DS_EXPORT\n+Result<Expression> Canonicalize(Expression, compute::ExecContext* = NULLPTR);\n+\n+/// Simplify Expressions based on literal arguments (for example, add(null, x) will always\n+/// be null so replace the call with a null literal). Includes early evaluation of all\n+/// calls whose arguments are entirely literal.\n+ARROW_DS_EXPORT\n+Result<Expression> FoldConstants(Expression);\n+\n+ARROW_DS_EXPORT\n+Result<Expression> ReplaceFieldsWithKnownValues(\n+    const std::unordered_map<FieldRef, Datum, FieldRef::Hash>& known_values, Expression);\n+\n+/// Simplify an expression by replacing subexpressions based on a guarantee:\n+/// a boolean expression which is guaranteed to evaluate to `true`. For example, this is\n+/// used to remove redundant function calls from a filter expression or to replace a\n+/// reference to a constant-value field with a literal.\n+ARROW_DS_EXPORT\n+Result<Expression> SimplifyWithGuarantee(Expression,\n+                                         const Expression& guaranteed_true_predicate);\n+\n+/// @}\n+\n+// Execution\n+\n+/// Execute a scalar expression against the provided state and input Datum. This\n\nReview comment:\n       Hmm... I assume the input Datum should be a record batch or table, so that field refs can be looked up?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.h\n##########\n@@ -0,0 +1,234 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/dataset/type_fwd.h\"\n+#include \"arrow/dataset/visibility.h\"\n+#include \"arrow/datum.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/scalar.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace dataset {\n+\n+/// An unbound expression which maps a single Datum to another Datum.\n+/// An expression is one of\n+/// - A literal Datum.\n+/// - A reference to a single (potentially nested) field of the input Datum.\n+/// - A call to a compute function, with arguments specified by other Expressions.\n+class ARROW_DS_EXPORT Expression {\n+ public:\n+  struct Call {\n+    std::string function_name;\n+    std::vector<Expression> arguments;\n+    std::shared_ptr<compute::FunctionOptions> options;\n+\n+    // post-Bind properties:\n+    const compute::Kernel* kernel = NULLPTR;\n+    std::shared_ptr<compute::Function> function;\n+    std::shared_ptr<compute::KernelState> kernel_state;\n+    ValueDescr descr;\n+  };\n+\n+  std::string ToString() const;\n+  bool Equals(const Expression& other) const;\n+  size_t hash() const;\n+  struct Hash {\n+    size_t operator()(const Expression& expr) const { return expr.hash(); }\n+  };\n+\n+  /// Bind this expression to the given input type, looking up Kernels and field types.\n+  /// Some expression simplification may be performed and implicit casts will be inserted.\n+  /// Any state necessary for execution will be initialized and returned.\n+  Result<Expression> Bind(ValueDescr in, compute::ExecContext* = NULLPTR) const;\n+  Result<Expression> Bind(const Schema& in_schema, compute::ExecContext* = NULLPTR) const;\n+\n+  // XXX someday\n+  // Clone all KernelState in this bound expression. If any function referenced by this\n+  // expression has mutable KernelState, it is not safe to execute or apply simplification\n+  // passes to it (or copies of it!) from multiple threads. Cloning state produces new\n+  // KernelStates where necessary to ensure that Expressions may be manipulated safely\n+  // on multiple threads.\n+  // Result<ExpressionState> CloneState() const;\n+  // Status SetState(ExpressionState);\n+\n+  /// Return true if all an expression's field references have explicit ValueDescr and all\n+  /// of its functions' kernels are looked up.\n+  bool IsBound() const;\n+\n+  /// Return true if this expression is composed only of Scalar literals, field\n+  /// references, and calls to ScalarFunctions.\n+  bool IsScalarExpression() const;\n+\n+  /// Return true if this expression is literal and entirely null.\n+  bool IsNullLiteral() const;\n+\n+  /// Return true if this expression could evaluate to true.\n+  bool IsSatisfiable() const;\n+\n+  // XXX someday\n+  // Result<PipelineGraph> GetPipelines();\n+\n+  const Call* call() const;\n+  const Datum* literal() const;\n+  const FieldRef* field_ref() const;\n+\n+  ValueDescr descr() const;\n+  // XXX someday\n+  // NullGeneralization::type nullable() const;\n+\n+  struct Parameter {\n+    FieldRef ref;\n+    ValueDescr descr;\n+  };\n+\n+  Expression() = default;\n+  explicit Expression(Call call);\n+  explicit Expression(Datum literal);\n+  explicit Expression(Parameter parameter);\n+\n+ private:\n+  using Impl = util::Variant<Datum, Parameter, Call>;\n+  std::shared_ptr<Impl> impl_;\n+\n+  ARROW_EXPORT friend bool Identical(const Expression& l, const Expression& r);\n+\n+  ARROW_EXPORT friend void PrintTo(const Expression&, std::ostream*);\n+};\n+\n+inline bool operator==(const Expression& l, const Expression& r) { return l.Equals(r); }\n+inline bool operator!=(const Expression& l, const Expression& r) { return !l.Equals(r); }\n+\n+// Factories\n+\n+ARROW_DS_EXPORT\n+Expression literal(Datum lit);\n+\n+template <typename Arg>\n+Expression literal(Arg&& arg) {\n+  return literal(Datum(std::forward<Arg>(arg)));\n+}\n+\n+ARROW_DS_EXPORT\n+Expression field_ref(FieldRef ref);\n+\n+ARROW_DS_EXPORT\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options = NULLPTR);\n+\n+template <typename Options, typename = typename std::enable_if<std::is_base_of<\n+                                compute::FunctionOptions, Options>::value>::type>\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                Options options) {\n+  return call(std::move(function), std::move(arguments),\n+              std::make_shared<Options>(std::move(options)));\n+}\n+\n+ARROW_DS_EXPORT\n+std::vector<FieldRef> FieldsInExpression(const Expression&);\n+\n+ARROW_DS_EXPORT\n+Result<std::unordered_map<FieldRef, Datum, FieldRef::Hash>> ExtractKnownFieldValues(\n+    const Expression& guaranteed_true_predicate);\n+\n+/// \\defgroup expression-passes Functions for modification of Expressions\n+///\n+/// @{\n+///\n+/// These operate on bound expressions.\n+\n+/// Weak canonicalization which establishes guarantees for subsequent passes. Even\n+/// equivalent Expressions may result in different canonicalized expressions.\n+/// TODO this could be a strong canonicalization\n+ARROW_DS_EXPORT\n+Result<Expression> Canonicalize(Expression, compute::ExecContext* = NULLPTR);\n+\n+/// Simplify Expressions based on literal arguments (for example, add(null, x) will always\n+/// be null so replace the call with a null literal). Includes early evaluation of all\n+/// calls whose arguments are entirely literal.\n\nReview comment:\n       At some point we'll want to be able to flag compute functions as \"impure\", for example a now() or random() function.\n\n##########\nFile path: cpp/src/arrow/dataset/scanner_test.cc\n##########\n@@ -184,14 +183,26 @@ TEST_F(TestScannerBuilder, TestProject) {\n TEST_F(TestScannerBuilder, TestFilter) {\n   ScannerBuilder builder(dataset_, ctx_);\n \n-  ASSERT_OK(builder.Filter(scalar(true)));\n-  ASSERT_OK(builder.Filter(\"i64\"_ == int64_t(10)));\n-  ASSERT_OK(builder.Filter(\"i64\"_ == int64_t(10) || \"b\"_ == true));\n-\n-  ASSERT_RAISES(TypeError, builder.Filter(\"i64\"_ == int32_t(10)));\n-  ASSERT_RAISES(Invalid, builder.Filter(\"not_a_column\"_ == true));\n-  ASSERT_RAISES(Invalid,\n-                builder.Filter(\"i64\"_ == int64_t(10) || \"not_a_column\"_ == true));\n+  ASSERT_OK(builder.Filter(literal(true)));\n+  ASSERT_OK(builder.Filter(call(\"equal\", {field_ref(\"i64\"), literal<int64_t>(10)})));\n+  ASSERT_OK(builder.Filter(\n+      call(\"or_kleene\", {\n\nReview comment:\n       Is `call(\"or_kleene\", {Expression, Expression})` the same as `or_(Expression, Expression)`?\n\n##########\nFile path: cpp/src/arrow/dataset/partition.cc\n##########\n@@ -573,5 +530,192 @@ Result<std::shared_ptr<Schema>> PartitioningOrFactory::GetOrInferSchema(\n   return factory()->Inspect(paths);\n }\n \n+// Transform an array of counts to offsets which will divide a ListArray\n+// into an equal number of slices with corresponding lengths.\n+inline Result<std::shared_ptr<Array>> CountsToOffsets(\n+    std::shared_ptr<Int64Array> counts) {\n+  Int32Builder offset_builder;\n+  RETURN_NOT_OK(offset_builder.Resize(counts->length() + 1));\n+  offset_builder.UnsafeAppend(0);\n+\n+  for (int64_t i = 0; i < counts->length(); ++i) {\n+    DCHECK_NE(counts->Value(i), 0);\n+    auto next_offset = static_cast<int32_t>(offset_builder[i] + counts->Value(i));\n+    offset_builder.UnsafeAppend(next_offset);\n+  }\n+\n+  std::shared_ptr<Array> offsets;\n+  RETURN_NOT_OK(offset_builder.Finish(&offsets));\n+  return offsets;\n+}\n+\n+// Helper for simultaneous dictionary encoding of multiple arrays.\n+//\n+// The fused dictionary is the Cartesian product of the individual dictionaries.\n+// For example given two arrays A, B where A has unique values [\"ex\", \"why\"]\n+// and B has unique values [0, 1] the fused dictionary is the set of tuples\n+// [[\"ex\", 0], [\"ex\", 1], [\"why\", 0], [\"ex\", 1]].\n+//\n+// TODO(bkietz) this capability belongs in an Action of the hash kernels, where\n+// it can be used to group aggregates without materializing a grouped batch.\n+// For the purposes of writing we need the materialized grouped batch anyway\n+// since no Writers accept a selection vector.\n+class StructDictionary {\n+ public:\n+  struct Encoded {\n+    std::shared_ptr<Int32Array> indices;\n+    std::shared_ptr<StructDictionary> dictionary;\n+  };\n+\n+  static Result<Encoded> Encode(const ArrayVector& columns) {\n+    Encoded out{nullptr, std::make_shared<StructDictionary>()};\n+\n+    for (const auto& column : columns) {\n+      if (column->null_count() != 0) {\n+        return Status::NotImplemented(\"Grouping on a field with nulls\");\n+      }\n+\n+      RETURN_NOT_OK(out.dictionary->AddOne(column, &out.indices));\n+    }\n+\n+    return out;\n+  }\n+\n+  Result<std::shared_ptr<StructArray>> Decode(std::shared_ptr<Int32Array> fused_indices,\n+                                              FieldVector fields) {\n+    std::vector<Int32Builder> builders(dictionaries_.size());\n+    for (Int32Builder& b : builders) {\n+      RETURN_NOT_OK(b.Resize(fused_indices->length()));\n+    }\n+\n+    std::vector<int32_t> codes(dictionaries_.size());\n+    for (int64_t i = 0; i < fused_indices->length(); ++i) {\n+      Expand(fused_indices->Value(i), codes.data());\n+\n+      auto builder_it = builders.begin();\n+      for (int32_t index : codes) {\n+        builder_it++->UnsafeAppend(index);\n+      }\n+    }\n+\n+    ArrayVector columns(dictionaries_.size());\n+    for (size_t i = 0; i < dictionaries_.size(); ++i) {\n+      std::shared_ptr<ArrayData> indices;\n+      RETURN_NOT_OK(builders[i].FinishInternal(&indices));\n+\n+      ARROW_ASSIGN_OR_RAISE(Datum column, compute::Take(dictionaries_[i], indices));\n+      columns[i] = column.make_array();\n+    }\n+\n+    return StructArray::Make(std::move(columns), std::move(fields));\n+  }\n+\n+ private:\n+  Status AddOne(Datum column, std::shared_ptr<Int32Array>* fused_indices) {\n+    ArrayData* encoded;\n+    if (column.type()->id() != Type::DICTIONARY) {\n+      ARROW_ASSIGN_OR_RAISE(column, compute::DictionaryEncode(column));\n+    }\n+    encoded = column.mutable_array();\n+\n+    auto indices =\n+        std::make_shared<Int32Array>(encoded->length, std::move(encoded->buffers[1]));\n\nReview comment:\n       Be careful, you might have got a dictionary array with a non-int32 index type.\n\n##########\nFile path: cpp/src/arrow/dataset/expression_internal.h\n##########\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace dataset {\n+\n+bool Identical(const Expression& l, const Expression& r) { return l.impl_ == r.impl_; }\n+\n+const Expression::Call* CallNotNull(const Expression& expr) {\n+  auto call = expr.call();\n+  DCHECK_NE(call, nullptr);\n+  return call;\n+}\n+\n+inline void GetAllFieldRefs(const Expression& expr,\n+                            std::unordered_set<FieldRef, FieldRef::Hash>* refs) {\n+  if (auto lit = expr.literal()) return;\n+\n+  if (auto ref = expr.field_ref()) {\n+    refs->emplace(*ref);\n+    return;\n+  }\n+\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    GetAllFieldRefs(arg, refs);\n+  }\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Expression>& exprs) {\n+  std::vector<ValueDescr> descrs(exprs.size());\n+  for (size_t i = 0; i < exprs.size(); ++i) {\n+    DCHECK(exprs[i].IsBound());\n+    descrs[i] = exprs[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Datum>& values) {\n+  std::vector<ValueDescr> descrs(values.size());\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    descrs[i] = values[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+struct FieldPathGetDatumImpl {\n+  template <typename T, typename = decltype(FieldPath{}.Get(std::declval<const T&>()))>\n+  Result<Datum> operator()(const std::shared_ptr<T>& ptr) {\n+    return path_.Get(*ptr).template As<Datum>();\n+  }\n+\n+  template <typename T>\n+  Result<Datum> operator()(const T&) {\n+    return Status::NotImplemented(\"FieldPath::Get() into Datum \", datum_.ToString());\n+  }\n+\n+  const Datum& datum_;\n+  const FieldPath& path_;\n+};\n+\n+inline Result<Datum> GetDatumField(const FieldRef& ref, const Datum& input) {\n+  Datum field;\n+\n+  FieldPath path;\n+  if (auto type = input.type()) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.type()));\n+  } else if (input.kind() == Datum::RECORD_BATCH) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.record_batch()->schema()));\n+  } else if (input.kind() == Datum::TABLE) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.table()->schema()));\n+  }\n+\n+  if (path) {\n+    ARROW_ASSIGN_OR_RAISE(field,\n+                          util::visit(FieldPathGetDatumImpl{input, path}, input.value));\n+  }\n+\n+  if (field == Datum{}) {\n+    field = Datum(std::make_shared<NullScalar>());\n+  }\n+\n+  return field;\n+}\n+\n+struct Comparison {\n+  enum type {\n+    NA = 0,\n+    EQUAL = 1,\n+    LESS = 2,\n+    GREATER = 4,\n+    NOT_EQUAL = LESS | GREATER,\n+    LESS_EQUAL = LESS | EQUAL,\n+    GREATER_EQUAL = GREATER | EQUAL,\n+  };\n+\n+  static const type* Get(const std::string& function) {\n+    static std::unordered_map<std::string, type> flipped_comparisons{\n+        {\"equal\", EQUAL},     {\"not_equal\", NOT_EQUAL},\n+        {\"less\", LESS},       {\"less_equal\", LESS_EQUAL},\n+        {\"greater\", GREATER}, {\"greater_equal\", GREATER_EQUAL},\n+    };\n+\n+    auto it = flipped_comparisons.find(function);\n+    return it != flipped_comparisons.end() ? &it->second : nullptr;\n+  }\n+\n+  static const type* Get(const Expression& expr) {\n+    if (auto call = expr.call()) {\n+      return Comparison::Get(call->function_name);\n+    }\n+    return nullptr;\n+  }\n+\n+  // Execute a simple Comparison between scalars, casting the RHS if types disagree\n+  static Result<type> Execute(Datum l, Datum r) {\n+    if (!l.is_scalar() || !r.is_scalar()) {\n+      return Status::Invalid(\"Cannot Execute Comparison on non-scalars\");\n+    }\n+\n+    if (!l.type()->Equals(r.type())) {\n+      ARROW_ASSIGN_OR_RAISE(r, compute::Cast(r, l.type()));\n\nReview comment:\n       This may cast to the narrowest type if e.g. `l` is int8 and `r` is int16. Then, due to truncation, the comparison can produce an incorrect result.\n\n##########\nFile path: cpp/src/arrow/dataset/partition_test.cc\n##########\n@@ -99,38 +98,57 @@ class TestPartitioning : public ::testing::Test {\n \n   std::shared_ptr<Partitioning> partitioning_;\n   std::shared_ptr<PartitioningFactory> factory_;\n+  std::shared_ptr<Schema> written_schema_;\n };\n \n TEST_F(TestPartitioning, DirectoryPartitioning) {\n   partitioning_ = std::make_shared<DirectoryPartitioning>(\n       schema({field(\"alpha\", int32()), field(\"beta\", utf8())}));\n \n-  AssertParse(\"/0/hello\", \"alpha\"_ == int32_t(0) and \"beta\"_ == \"hello\");\n-  AssertParse(\"/3\", \"alpha\"_ == int32_t(3));\n-  AssertParseError(\"/world/0\");   // reversed order\n-  AssertParseError(\"/0.0/foo\");   // invalid alpha\n-  AssertParseError(\"/3.25\");      // invalid alpha with missing beta\n-  AssertParse(\"\", scalar(true));  // no segments to parse\n+  AssertParse(\"/0/hello\", and_(equal(field_ref(\"alpha\"), literal(0)),\n+                               equal(field_ref(\"beta\"), literal(\"hello\"))));\n+  AssertParse(\"/3\", equal(field_ref(\"alpha\"), literal(3)));\n+  AssertParseError(\"/world/0\");    // reversed order\n+  AssertParseError(\"/0.0/foo\");    // invalid alpha\n+  AssertParseError(\"/3.25\");       // invalid alpha with missing beta\n+  AssertParse(\"\", literal(true));  // no segments to parse\n \n   // gotcha someday:\n-  AssertParse(\"/0/dat.parquet\", \"alpha\"_ == int32_t(0) and \"beta\"_ == \"dat.parquet\");\n+  AssertParse(\"/0/dat.parquet\", and_(equal(field_ref(\"alpha\"), literal(0)),\n+                                     equal(field_ref(\"beta\"), literal(\"dat.parquet\"))));\n \n-  AssertParse(\"/0/foo/ignored=2341\", \"alpha\"_ == int32_t(0) and \"beta\"_ == \"foo\");\n+  AssertParse(\"/0/foo/ignored=2341\", and_(equal(field_ref(\"alpha\"), literal(0)),\n+                                          equal(field_ref(\"beta\"), literal(\"foo\"))));\n }\n \n TEST_F(TestPartitioning, DirectoryPartitioningFormat) {\n   partitioning_ = std::make_shared<DirectoryPartitioning>(\n       schema({field(\"alpha\", int32()), field(\"beta\", utf8())}));\n \n-  AssertFormat(\"alpha\"_ == int32_t(0) and \"beta\"_ == \"hello\", \"0/hello\");\n-  AssertFormat(\"beta\"_ == \"hello\" and \"alpha\"_ == int32_t(0), \"0/hello\");\n-  AssertFormat(\"alpha\"_ == int32_t(0), \"0\");\n-  AssertFormatError(\"beta\"_ == \"hello\");\n-  AssertFormat(scalar(true), \"\");\n+  written_schema_ = partitioning_->schema();\n \n-  AssertFormatError<StatusCode::TypeError>(\"alpha\"_ == 0.0 and \"beta\"_ == \"hello\");\n-  AssertFormat(\"gamma\"_ == \"yo\" and \"alpha\"_ == int32_t(0) and \"beta\"_ == \"hello\",\n+  AssertFormat(and_(equal(field_ref(\"alpha\"), literal(0)),\n+                    equal(field_ref(\"beta\"), literal(\"hello\"))),\n+               \"0/hello\");\n+  AssertFormat(and_(equal(field_ref(\"beta\"), literal(\"hello\")),\n+                    equal(field_ref(\"alpha\"), literal(0))),\n+               \"0/hello\");\n+  AssertFormat(equal(field_ref(\"alpha\"), literal(0)), \"0\");\n+  AssertFormatError(equal(field_ref(\"beta\"), literal(\"hello\")));\n+  AssertFormat(literal(true), \"\");\n+\n+  ASSERT_OK_AND_ASSIGN(written_schema_,\n+                       written_schema_->AddField(0, field(\"gamma\", utf8())));\n+  AssertFormat(and_({equal(field_ref(\"gamma\"), literal(\"yo\")),\n+                     equal(field_ref(\"alpha\"), literal(0)),\n+                     equal(field_ref(\"beta\"), literal(\"hello\"))}),\n                \"0/hello\");\n+\n+  // written_schema_ is incompatible with partitioning_'s schema\n\nReview comment:\n       I'm not sure I understand this test. What does `written_schema_` correspond to? The concrete schema of a file (e.g. Parquet) present in the dataset?\n\n##########\nFile path: cpp/src/arrow/result.h\n##########\n@@ -401,6 +401,28 @@ class ARROW_MUST_USE_TYPE Result : public util::EqualityComparable<Result<T>> {\n     return std::forward<M>(m)(ValueUnsafe());\n   }\n \n+  /// Cast the internally stored value to produce a new result or propagate the stored\n+  /// error.\n+  template <typename U, typename E = typename std::enable_if<\n+                            std::is_constructible<U, T>::value>::type>\n+  Result<U> As() && {\n\nReview comment:\n       +1\n\n##########\nFile path: cpp/src/arrow/type.h\n##########\n@@ -1423,10 +1426,14 @@ class ARROW_EXPORT FieldPath {\n   Result<std::shared_ptr<Array>> Get(const RecordBatch& batch) const;\n   Result<std::shared_ptr<ChunkedArray>> Get(const Table& table) const;\n \n-  /// \\brief Retrieve the referenced child Array from an Array or ChunkedArray\n+  /// \\brief Retrieve the referenced child from an Array, ArrayData, or ChunkedArray\n   Result<std::shared_ptr<Array>> Get(const Array& array) const;\n+  Result<std::shared_ptr<ArrayData>> Get(const ArrayData& data) const;\n   Result<std::shared_ptr<ChunkedArray>> Get(const ChunkedArray& array) const;\n \n+  /// \\brief Retrieve the reference child from a Datum\n\nReview comment:\n       \"referenced\"?\n\n##########\nFile path: cpp/src/arrow/type.h\n##########\n@@ -1423,10 +1426,14 @@ class ARROW_EXPORT FieldPath {\n   Result<std::shared_ptr<Array>> Get(const RecordBatch& batch) const;\n   Result<std::shared_ptr<ChunkedArray>> Get(const Table& table) const;\n \n-  /// \\brief Retrieve the referenced child Array from an Array or ChunkedArray\n+  /// \\brief Retrieve the referenced child from an Array, ArrayData, or ChunkedArray\n   Result<std::shared_ptr<Array>> Get(const Array& array) const;\n+  Result<std::shared_ptr<ArrayData>> Get(const ArrayData& data) const;\n   Result<std::shared_ptr<ChunkedArray>> Get(const ChunkedArray& array) const;\n \n+  /// \\brief Retrieve the reference child from a Datum\n+  Result<Datum> Get(const Datum& datum) const;\n\nReview comment:\n       I haven't seen the implementation for this overload. Did I overlook something?\n\n##########\nFile path: cpp/src/arrow/dataset/expression_internal.h\n##########\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace dataset {\n+\n+bool Identical(const Expression& l, const Expression& r) { return l.impl_ == r.impl_; }\n+\n+const Expression::Call* CallNotNull(const Expression& expr) {\n+  auto call = expr.call();\n+  DCHECK_NE(call, nullptr);\n+  return call;\n+}\n+\n+inline void GetAllFieldRefs(const Expression& expr,\n+                            std::unordered_set<FieldRef, FieldRef::Hash>* refs) {\n+  if (auto lit = expr.literal()) return;\n+\n+  if (auto ref = expr.field_ref()) {\n+    refs->emplace(*ref);\n+    return;\n+  }\n+\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    GetAllFieldRefs(arg, refs);\n+  }\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Expression>& exprs) {\n+  std::vector<ValueDescr> descrs(exprs.size());\n+  for (size_t i = 0; i < exprs.size(); ++i) {\n+    DCHECK(exprs[i].IsBound());\n+    descrs[i] = exprs[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Datum>& values) {\n+  std::vector<ValueDescr> descrs(values.size());\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    descrs[i] = values[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+struct FieldPathGetDatumImpl {\n+  template <typename T, typename = decltype(FieldPath{}.Get(std::declval<const T&>()))>\n+  Result<Datum> operator()(const std::shared_ptr<T>& ptr) {\n+    return path_.Get(*ptr).template As<Datum>();\n+  }\n+\n+  template <typename T>\n+  Result<Datum> operator()(const T&) {\n+    return Status::NotImplemented(\"FieldPath::Get() into Datum \", datum_.ToString());\n+  }\n+\n+  const Datum& datum_;\n+  const FieldPath& path_;\n+};\n+\n+inline Result<Datum> GetDatumField(const FieldRef& ref, const Datum& input) {\n+  Datum field;\n+\n+  FieldPath path;\n+  if (auto type = input.type()) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.type()));\n+  } else if (input.kind() == Datum::RECORD_BATCH) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.record_batch()->schema()));\n+  } else if (input.kind() == Datum::TABLE) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.table()->schema()));\n+  }\n+\n+  if (path) {\n+    ARROW_ASSIGN_OR_RAISE(field,\n+                          util::visit(FieldPathGetDatumImpl{input, path}, input.value));\n+  }\n+\n+  if (field == Datum{}) {\n+    field = Datum(std::make_shared<NullScalar>());\n+  }\n+\n+  return field;\n+}\n+\n+struct Comparison {\n+  enum type {\n+    NA = 0,\n+    EQUAL = 1,\n+    LESS = 2,\n+    GREATER = 4,\n+    NOT_EQUAL = LESS | GREATER,\n+    LESS_EQUAL = LESS | EQUAL,\n+    GREATER_EQUAL = GREATER | EQUAL,\n+  };\n+\n+  static const type* Get(const std::string& function) {\n+    static std::unordered_map<std::string, type> flipped_comparisons{\n\nReview comment:\n       Nit, but these don't look \"flipped\" to me?\n\n##########\nFile path: cpp/src/arrow/dataset/expression_internal.h\n##########\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace dataset {\n+\n+bool Identical(const Expression& l, const Expression& r) { return l.impl_ == r.impl_; }\n+\n+const Expression::Call* CallNotNull(const Expression& expr) {\n+  auto call = expr.call();\n+  DCHECK_NE(call, nullptr);\n+  return call;\n+}\n+\n+inline void GetAllFieldRefs(const Expression& expr,\n+                            std::unordered_set<FieldRef, FieldRef::Hash>* refs) {\n+  if (auto lit = expr.literal()) return;\n+\n+  if (auto ref = expr.field_ref()) {\n+    refs->emplace(*ref);\n+    return;\n+  }\n+\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    GetAllFieldRefs(arg, refs);\n+  }\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Expression>& exprs) {\n+  std::vector<ValueDescr> descrs(exprs.size());\n+  for (size_t i = 0; i < exprs.size(); ++i) {\n+    DCHECK(exprs[i].IsBound());\n+    descrs[i] = exprs[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Datum>& values) {\n+  std::vector<ValueDescr> descrs(values.size());\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    descrs[i] = values[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+struct FieldPathGetDatumImpl {\n+  template <typename T, typename = decltype(FieldPath{}.Get(std::declval<const T&>()))>\n+  Result<Datum> operator()(const std::shared_ptr<T>& ptr) {\n+    return path_.Get(*ptr).template As<Datum>();\n+  }\n+\n+  template <typename T>\n+  Result<Datum> operator()(const T&) {\n+    return Status::NotImplemented(\"FieldPath::Get() into Datum \", datum_.ToString());\n+  }\n+\n+  const Datum& datum_;\n+  const FieldPath& path_;\n+};\n+\n+inline Result<Datum> GetDatumField(const FieldRef& ref, const Datum& input) {\n+  Datum field;\n+\n+  FieldPath path;\n+  if (auto type = input.type()) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.type()));\n+  } else if (input.kind() == Datum::RECORD_BATCH) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.record_batch()->schema()));\n+  } else if (input.kind() == Datum::TABLE) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.table()->schema()));\n\nReview comment:\n       Should we add `std::shared_ptr<Schema> Datum::schema() const`?\n\n##########\nFile path: cpp/src/arrow/dataset/expression_internal.h\n##########\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace dataset {\n+\n+bool Identical(const Expression& l, const Expression& r) { return l.impl_ == r.impl_; }\n+\n+const Expression::Call* CallNotNull(const Expression& expr) {\n+  auto call = expr.call();\n+  DCHECK_NE(call, nullptr);\n+  return call;\n+}\n+\n+inline void GetAllFieldRefs(const Expression& expr,\n+                            std::unordered_set<FieldRef, FieldRef::Hash>* refs) {\n+  if (auto lit = expr.literal()) return;\n+\n+  if (auto ref = expr.field_ref()) {\n+    refs->emplace(*ref);\n+    return;\n+  }\n+\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    GetAllFieldRefs(arg, refs);\n+  }\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Expression>& exprs) {\n+  std::vector<ValueDescr> descrs(exprs.size());\n+  for (size_t i = 0; i < exprs.size(); ++i) {\n+    DCHECK(exprs[i].IsBound());\n+    descrs[i] = exprs[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Datum>& values) {\n+  std::vector<ValueDescr> descrs(values.size());\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    descrs[i] = values[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+struct FieldPathGetDatumImpl {\n+  template <typename T, typename = decltype(FieldPath{}.Get(std::declval<const T&>()))>\n+  Result<Datum> operator()(const std::shared_ptr<T>& ptr) {\n+    return path_.Get(*ptr).template As<Datum>();\n+  }\n+\n+  template <typename T>\n+  Result<Datum> operator()(const T&) {\n+    return Status::NotImplemented(\"FieldPath::Get() into Datum \", datum_.ToString());\n+  }\n+\n+  const Datum& datum_;\n+  const FieldPath& path_;\n+};\n+\n+inline Result<Datum> GetDatumField(const FieldRef& ref, const Datum& input) {\n+  Datum field;\n+\n+  FieldPath path;\n+  if (auto type = input.type()) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.type()));\n+  } else if (input.kind() == Datum::RECORD_BATCH) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.record_batch()->schema()));\n+  } else if (input.kind() == Datum::TABLE) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.table()->schema()));\n+  }\n+\n+  if (path) {\n+    ARROW_ASSIGN_OR_RAISE(field,\n+                          util::visit(FieldPathGetDatumImpl{input, path}, input.value));\n+  }\n+\n+  if (field == Datum{}) {\n+    field = Datum(std::make_shared<NullScalar>());\n+  }\n+\n+  return field;\n+}\n+\n+struct Comparison {\n+  enum type {\n+    NA = 0,\n+    EQUAL = 1,\n+    LESS = 2,\n+    GREATER = 4,\n+    NOT_EQUAL = LESS | GREATER,\n+    LESS_EQUAL = LESS | EQUAL,\n+    GREATER_EQUAL = GREATER | EQUAL,\n+  };\n+\n+  static const type* Get(const std::string& function) {\n+    static std::unordered_map<std::string, type> flipped_comparisons{\n+        {\"equal\", EQUAL},     {\"not_equal\", NOT_EQUAL},\n+        {\"less\", LESS},       {\"less_equal\", LESS_EQUAL},\n+        {\"greater\", GREATER}, {\"greater_equal\", GREATER_EQUAL},\n+    };\n+\n+    auto it = flipped_comparisons.find(function);\n+    return it != flipped_comparisons.end() ? &it->second : nullptr;\n+  }\n+\n+  static const type* Get(const Expression& expr) {\n+    if (auto call = expr.call()) {\n+      return Comparison::Get(call->function_name);\n+    }\n+    return nullptr;\n+  }\n+\n+  // Execute a simple Comparison between scalars, casting the RHS if types disagree\n\nReview comment:\n       FTR, what does this return if both inputs are null?\n\n##########\nFile path: cpp/src/arrow/dataset/scanner_test.cc\n##########\n@@ -184,14 +183,26 @@ TEST_F(TestScannerBuilder, TestProject) {\n TEST_F(TestScannerBuilder, TestFilter) {\n   ScannerBuilder builder(dataset_, ctx_);\n \n-  ASSERT_OK(builder.Filter(scalar(true)));\n-  ASSERT_OK(builder.Filter(\"i64\"_ == int64_t(10)));\n-  ASSERT_OK(builder.Filter(\"i64\"_ == int64_t(10) || \"b\"_ == true));\n-\n-  ASSERT_RAISES(TypeError, builder.Filter(\"i64\"_ == int32_t(10)));\n-  ASSERT_RAISES(Invalid, builder.Filter(\"not_a_column\"_ == true));\n-  ASSERT_RAISES(Invalid,\n-                builder.Filter(\"i64\"_ == int64_t(10) || \"not_a_column\"_ == true));\n+  ASSERT_OK(builder.Filter(literal(true)));\n+  ASSERT_OK(builder.Filter(call(\"equal\", {field_ref(\"i64\"), literal<int64_t>(10)})));\n\nReview comment:\n       Is `call(\"equal\", {Expression, Expression})` the same as `equal(Expression, Expression)`?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.h\n##########\n@@ -0,0 +1,234 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// This API is EXPERIMENTAL.\n+\n+#pragma once\n+\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/api_scalar.h\"\n+#include \"arrow/compute/cast.h\"\n+#include \"arrow/dataset/type_fwd.h\"\n+#include \"arrow/dataset/visibility.h\"\n+#include \"arrow/datum.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/scalar.h\"\n+#include \"arrow/type_fwd.h\"\n+#include \"arrow/util/variant.h\"\n+\n+namespace arrow {\n+namespace dataset {\n+\n+/// An unbound expression which maps a single Datum to another Datum.\n+/// An expression is one of\n+/// - A literal Datum.\n+/// - A reference to a single (potentially nested) field of the input Datum.\n+/// - A call to a compute function, with arguments specified by other Expressions.\n+class ARROW_DS_EXPORT Expression {\n+ public:\n+  struct Call {\n+    std::string function_name;\n+    std::vector<Expression> arguments;\n+    std::shared_ptr<compute::FunctionOptions> options;\n+\n+    // post-Bind properties:\n+    const compute::Kernel* kernel = NULLPTR;\n+    std::shared_ptr<compute::Function> function;\n+    std::shared_ptr<compute::KernelState> kernel_state;\n+    ValueDescr descr;\n+  };\n+\n+  std::string ToString() const;\n+  bool Equals(const Expression& other) const;\n+  size_t hash() const;\n+  struct Hash {\n+    size_t operator()(const Expression& expr) const { return expr.hash(); }\n+  };\n+\n+  /// Bind this expression to the given input type, looking up Kernels and field types.\n+  /// Some expression simplification may be performed and implicit casts will be inserted.\n+  /// Any state necessary for execution will be initialized and returned.\n+  Result<Expression> Bind(ValueDescr in, compute::ExecContext* = NULLPTR) const;\n+  Result<Expression> Bind(const Schema& in_schema, compute::ExecContext* = NULLPTR) const;\n+\n+  // XXX someday\n+  // Clone all KernelState in this bound expression. If any function referenced by this\n+  // expression has mutable KernelState, it is not safe to execute or apply simplification\n+  // passes to it (or copies of it!) from multiple threads. Cloning state produces new\n+  // KernelStates where necessary to ensure that Expressions may be manipulated safely\n+  // on multiple threads.\n+  // Result<ExpressionState> CloneState() const;\n+  // Status SetState(ExpressionState);\n+\n+  /// Return true if all an expression's field references have explicit ValueDescr and all\n+  /// of its functions' kernels are looked up.\n+  bool IsBound() const;\n+\n+  /// Return true if this expression is composed only of Scalar literals, field\n+  /// references, and calls to ScalarFunctions.\n+  bool IsScalarExpression() const;\n+\n+  /// Return true if this expression is literal and entirely null.\n+  bool IsNullLiteral() const;\n+\n+  /// Return true if this expression could evaluate to true.\n+  bool IsSatisfiable() const;\n+\n+  // XXX someday\n+  // Result<PipelineGraph> GetPipelines();\n+\n+  const Call* call() const;\n+  const Datum* literal() const;\n+  const FieldRef* field_ref() const;\n+\n+  ValueDescr descr() const;\n+  // XXX someday\n+  // NullGeneralization::type nullable() const;\n+\n+  struct Parameter {\n+    FieldRef ref;\n+    ValueDescr descr;\n+  };\n+\n+  Expression() = default;\n+  explicit Expression(Call call);\n+  explicit Expression(Datum literal);\n+  explicit Expression(Parameter parameter);\n+\n+ private:\n+  using Impl = util::Variant<Datum, Parameter, Call>;\n+  std::shared_ptr<Impl> impl_;\n+\n+  ARROW_EXPORT friend bool Identical(const Expression& l, const Expression& r);\n+\n+  ARROW_EXPORT friend void PrintTo(const Expression&, std::ostream*);\n+};\n+\n+inline bool operator==(const Expression& l, const Expression& r) { return l.Equals(r); }\n+inline bool operator!=(const Expression& l, const Expression& r) { return !l.Equals(r); }\n+\n+// Factories\n+\n+ARROW_DS_EXPORT\n+Expression literal(Datum lit);\n+\n+template <typename Arg>\n+Expression literal(Arg&& arg) {\n+  return literal(Datum(std::forward<Arg>(arg)));\n+}\n+\n+ARROW_DS_EXPORT\n+Expression field_ref(FieldRef ref);\n+\n+ARROW_DS_EXPORT\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options = NULLPTR);\n+\n+template <typename Options, typename = typename std::enable_if<std::is_base_of<\n+                                compute::FunctionOptions, Options>::value>::type>\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                Options options) {\n+  return call(std::move(function), std::move(arguments),\n+              std::make_shared<Options>(std::move(options)));\n+}\n+\n+ARROW_DS_EXPORT\n+std::vector<FieldRef> FieldsInExpression(const Expression&);\n\nReview comment:\n       Add a docstring? Especially, is this deep or shallow?\n\n##########\nFile path: cpp/src/arrow/dataset/expression_internal.h\n##########\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace dataset {\n+\n+bool Identical(const Expression& l, const Expression& r) { return l.impl_ == r.impl_; }\n+\n+const Expression::Call* CallNotNull(const Expression& expr) {\n+  auto call = expr.call();\n+  DCHECK_NE(call, nullptr);\n+  return call;\n+}\n+\n+inline void GetAllFieldRefs(const Expression& expr,\n+                            std::unordered_set<FieldRef, FieldRef::Hash>* refs) {\n+  if (auto lit = expr.literal()) return;\n+\n+  if (auto ref = expr.field_ref()) {\n+    refs->emplace(*ref);\n+    return;\n+  }\n+\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    GetAllFieldRefs(arg, refs);\n+  }\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Expression>& exprs) {\n+  std::vector<ValueDescr> descrs(exprs.size());\n+  for (size_t i = 0; i < exprs.size(); ++i) {\n+    DCHECK(exprs[i].IsBound());\n+    descrs[i] = exprs[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Datum>& values) {\n+  std::vector<ValueDescr> descrs(values.size());\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    descrs[i] = values[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+struct FieldPathGetDatumImpl {\n+  template <typename T, typename = decltype(FieldPath{}.Get(std::declval<const T&>()))>\n+  Result<Datum> operator()(const std::shared_ptr<T>& ptr) {\n+    return path_.Get(*ptr).template As<Datum>();\n+  }\n+\n+  template <typename T>\n+  Result<Datum> operator()(const T&) {\n+    return Status::NotImplemented(\"FieldPath::Get() into Datum \", datum_.ToString());\n+  }\n+\n+  const Datum& datum_;\n+  const FieldPath& path_;\n+};\n+\n+inline Result<Datum> GetDatumField(const FieldRef& ref, const Datum& input) {\n+  Datum field;\n+\n+  FieldPath path;\n+  if (auto type = input.type()) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.type()));\n+  } else if (input.kind() == Datum::RECORD_BATCH) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.record_batch()->schema()));\n+  } else if (input.kind() == Datum::TABLE) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.table()->schema()));\n+  }\n+\n+  if (path) {\n+    ARROW_ASSIGN_OR_RAISE(field,\n+                          util::visit(FieldPathGetDatumImpl{input, path}, input.value));\n+  }\n+\n+  if (field == Datum{}) {\n+    field = Datum(std::make_shared<NullScalar>());\n+  }\n+\n+  return field;\n+}\n+\n+struct Comparison {\n+  enum type {\n+    NA = 0,\n+    EQUAL = 1,\n+    LESS = 2,\n+    GREATER = 4,\n+    NOT_EQUAL = LESS | GREATER,\n+    LESS_EQUAL = LESS | EQUAL,\n+    GREATER_EQUAL = GREATER | EQUAL,\n+  };\n+\n+  static const type* Get(const std::string& function) {\n+    static std::unordered_map<std::string, type> flipped_comparisons{\n+        {\"equal\", EQUAL},     {\"not_equal\", NOT_EQUAL},\n+        {\"less\", LESS},       {\"less_equal\", LESS_EQUAL},\n+        {\"greater\", GREATER}, {\"greater_equal\", GREATER_EQUAL},\n+    };\n+\n+    auto it = flipped_comparisons.find(function);\n+    return it != flipped_comparisons.end() ? &it->second : nullptr;\n+  }\n+\n+  static const type* Get(const Expression& expr) {\n+    if (auto call = expr.call()) {\n+      return Comparison::Get(call->function_name);\n+    }\n+    return nullptr;\n+  }\n+\n+  // Execute a simple Comparison between scalars, casting the RHS if types disagree\n+  static Result<type> Execute(Datum l, Datum r) {\n+    if (!l.is_scalar() || !r.is_scalar()) {\n+      return Status::Invalid(\"Cannot Execute Comparison on non-scalars\");\n+    }\n+\n+    if (!l.type()->Equals(r.type())) {\n+      ARROW_ASSIGN_OR_RAISE(r, compute::Cast(r, l.type()));\n+    }\n+\n+    std::vector<Datum> arguments{std::move(l), std::move(r)};\n+\n+    ARROW_ASSIGN_OR_RAISE(auto equal, compute::CallFunction(\"equal\", arguments));\n+\n+    if (!equal.scalar()->is_valid) return NA;\n+    if (equal.scalar_as<BooleanScalar>().value) return EQUAL;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto less, compute::CallFunction(\"less\", arguments));\n+\n+    if (!less.scalar()->is_valid) return NA;\n+    return less.scalar_as<BooleanScalar>().value ? LESS : GREATER;\n+  }\n+\n+  static type GetFlipped(type op) {\n+    switch (op) {\n+      case NA:\n+        return NA;\n+      case EQUAL:\n+        return EQUAL;\n+      case LESS:\n+        return GREATER;\n+      case GREATER:\n+        return LESS;\n+      case NOT_EQUAL:\n+        return NOT_EQUAL;\n+      case LESS_EQUAL:\n+        return GREATER_EQUAL;\n+      case GREATER_EQUAL:\n+        return LESS_EQUAL;\n+    }\n+    DCHECK(false);\n+    return NA;\n+  }\n+\n+  static std::string GetName(type op) {\n+    switch (op) {\n+      case NA:\n+        DCHECK(false) << \"unreachable\";\n+        break;\n+      case EQUAL:\n+        return \"equal\";\n+      case LESS:\n+        return \"less\";\n+      case GREATER:\n+        return \"greater\";\n+      case NOT_EQUAL:\n+        return \"not_equal\";\n+      case LESS_EQUAL:\n+        return \"less_equal\";\n+      case GREATER_EQUAL:\n+        return \"greater_equal\";\n+    }\n+    DCHECK(false);\n+    return \"na\";\n+  }\n+\n+  static std::string GetOp(type op) {\n+    switch (op) {\n+      case NA:\n+        DCHECK(false) << \"unreachable\";\n+        break;\n+      case EQUAL:\n+        return \"==\";\n+      case LESS:\n+        return \"<\";\n+      case GREATER:\n+        return \">\";\n+      case NOT_EQUAL:\n+        return \"!=\";\n+      case LESS_EQUAL:\n+        return \"<=\";\n+      case GREATER_EQUAL:\n+        return \">=\";\n+    }\n+    DCHECK(false);\n+    return \"\";\n+  }\n+};\n+\n+inline const compute::CastOptions* GetCastOptions(const Expression::Call& call) {\n+  if (call.function_name != \"cast\") return nullptr;\n+  return checked_cast<const compute::CastOptions*>(call.options.get());\n+}\n+\n+inline bool IsSetLookup(const std::string& function) {\n+  return function == \"is_in\" || function == \"index_in\";\n+}\n+\n+inline bool IsSameTypesBinary(const std::string& function) {\n+  if (Comparison::Get(function)) return true;\n+\n+  static std::unordered_set<std::string> set{\"add\", \"subtract\", \"multiply\", \"divide\"};\n+\n+  return set.find(function) != set.end();\n+}\n+\n+inline const compute::SetLookupOptions* GetSetLookupOptions(\n+    const Expression::Call& call) {\n+  if (!IsSetLookup(call.function_name)) return nullptr;\n+  return checked_cast<const compute::SetLookupOptions*>(call.options.get());\n+}\n+\n+inline const compute::StructOptions* GetStructOptions(const Expression::Call& call) {\n+  if (call.function_name != \"struct\") return nullptr;\n+  return checked_cast<const compute::StructOptions*>(call.options.get());\n+}\n+\n+inline const compute::StrptimeOptions* GetStrptimeOptions(const Expression::Call& call) {\n+  if (call.function_name != \"strptime\") return nullptr;\n+  return checked_cast<const compute::StrptimeOptions*>(call.options.get());\n+}\n+\n+inline const std::shared_ptr<DataType>& GetDictionaryValueType(\n+    const std::shared_ptr<DataType>& type) {\n+  if (type && type->id() == Type::DICTIONARY) {\n+    return checked_cast<const DictionaryType&>(*type).value_type();\n+  }\n+  static std::shared_ptr<DataType> null;\n+  return null;\n+}\n+\n+inline Status EnsureNotDictionary(ValueDescr* descr) {\n+  if (auto value_type = GetDictionaryValueType(descr->type)) {\n+    descr->type = std::move(value_type);\n+  }\n+  return Status::OK();\n+}\n+\n+inline Status EnsureNotDictionary(Datum* datum) {\n+  if (datum->type()->id() == Type::DICTIONARY) {\n+    const auto& type = checked_cast<const DictionaryType&>(*datum->type()).value_type();\n+    ARROW_ASSIGN_OR_RAISE(*datum, compute::Cast(*datum, type));\n+  }\n+  return Status::OK();\n+}\n+\n+inline Status EnsureNotDictionary(Expression::Call* call) {\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto new_options = *options;\n+    RETURN_NOT_OK(EnsureNotDictionary(&new_options.value_set));\n+    call->options.reset(new compute::SetLookupOptions(std::move(new_options)));\n+  }\n+  return Status::OK();\n+}\n+\n+inline Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const Expression::Call& call) {\n+  if (call.options == nullptr) {\n+    return nullptr;\n+  }\n+\n+  auto Finish = [](ScalarVector values, std::vector<std::string> names) {\n+    FieldVector fields(names.size());\n+    for (size_t i = 0; i < fields.size(); ++i) {\n+      fields[i] = field(std::move(names[i]), values[i]->type);\n+    }\n+    return std::make_shared<StructScalar>(std::move(values), struct_(std::move(fields)));\n+  };\n+\n+  if (auto options = GetSetLookupOptions(call)) {\n+    if (!options->value_set.is_array()) {\n+      return Status::NotImplemented(\"chunked value_set\");\n+    }\n+    return Finish(\n+        {\n+            std::make_shared<ListScalar>(options->value_set.make_array()),\n+            MakeScalar(options->skip_nulls),\n+        },\n+        {\"value_set\", \"skip_nulls\"});\n+  }\n+\n+  if (call.function_name == \"cast\") {\n+    auto options = checked_cast<const compute::CastOptions*>(call.options.get());\n+    return Finish(\n+        {\n+            MakeNullScalar(options->to_type),\n+            MakeScalar(options->allow_int_overflow),\n+            MakeScalar(options->allow_time_truncate),\n+            MakeScalar(options->allow_time_overflow),\n+            MakeScalar(options->allow_decimal_truncate),\n+            MakeScalar(options->allow_float_truncate),\n+            MakeScalar(options->allow_invalid_utf8),\n+        },\n+        {\n+            \"to_type_holder\",\n+            \"allow_int_overflow\",\n+            \"allow_time_truncate\",\n+            \"allow_time_overflow\",\n+            \"allow_decimal_truncate\",\n+            \"allow_float_truncate\",\n+            \"allow_invalid_utf8\",\n+        });\n+  }\n+\n+  return Status::NotImplemented(\"conversion of options for \", call.function_name);\n+}\n+\n+inline Status FunctionOptionsFromStructScalar(const StructScalar* repr,\n+                                              Expression::Call* call) {\n+  if (repr == nullptr) {\n+    call->options = nullptr;\n+    return Status::OK();\n+  }\n+\n+  if (IsSetLookup(call->function_name)) {\n+    ARROW_ASSIGN_OR_RAISE(auto value_set, repr->field(\"value_set\"));\n+    ARROW_ASSIGN_OR_RAISE(auto skip_nulls, repr->field(\"skip_nulls\"));\n+    call->options = std::make_shared<compute::SetLookupOptions>(\n+        checked_cast<const ListScalar&>(*value_set).value,\n+        checked_cast<const BooleanScalar&>(*skip_nulls).value);\n+    return Status::OK();\n+  }\n+\n+  if (call->function_name == \"cast\") {\n+    auto options = std::make_shared<compute::CastOptions>();\n+    ARROW_ASSIGN_OR_RAISE(auto to_type_holder, repr->field(\"to_type_holder\"));\n+    options->to_type = to_type_holder->type;\n+\n+    int i = 1;\n+    for (bool* opt : {\n+             &options->allow_int_overflow,\n+             &options->allow_time_truncate,\n+             &options->allow_time_overflow,\n+             &options->allow_decimal_truncate,\n+             &options->allow_float_truncate,\n+             &options->allow_invalid_utf8,\n+         }) {\n+      *opt = checked_cast<const BooleanScalar&>(*repr->value[i++]).value;\n+    }\n+\n+    call->options = std::move(options);\n+    return Status::OK();\n+  }\n\nReview comment:\n       For clarity and ease of extension, perhaps this should be hiddened behind parametered helper classes, e.g.:\r\n   ```c++\r\n   if (IsSetLookup(call->function_name)) {\r\n     return OptionsConverter<compute::SetLookupOptions>::ToFunctionOptions(*repr, &call->options));\r\n   }\r\n   if (call->function_name == \"cast\") {\r\n     return OptionsConverter<compute::CastOptions>::ToFunctionOptions(*repr, &call->options));\r\n   }\r\n   ```\r\n   \r\n   And reciprocally in `FunctionOptionsToStructScalar`.\n\n##########\nFile path: cpp/src/arrow/dataset/expression_internal.h\n##########\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace dataset {\n+\n+bool Identical(const Expression& l, const Expression& r) { return l.impl_ == r.impl_; }\n+\n+const Expression::Call* CallNotNull(const Expression& expr) {\n+  auto call = expr.call();\n+  DCHECK_NE(call, nullptr);\n+  return call;\n+}\n+\n+inline void GetAllFieldRefs(const Expression& expr,\n+                            std::unordered_set<FieldRef, FieldRef::Hash>* refs) {\n+  if (auto lit = expr.literal()) return;\n+\n+  if (auto ref = expr.field_ref()) {\n+    refs->emplace(*ref);\n+    return;\n+  }\n+\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    GetAllFieldRefs(arg, refs);\n+  }\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Expression>& exprs) {\n+  std::vector<ValueDescr> descrs(exprs.size());\n+  for (size_t i = 0; i < exprs.size(); ++i) {\n+    DCHECK(exprs[i].IsBound());\n+    descrs[i] = exprs[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Datum>& values) {\n+  std::vector<ValueDescr> descrs(values.size());\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    descrs[i] = values[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+struct FieldPathGetDatumImpl {\n+  template <typename T, typename = decltype(FieldPath{}.Get(std::declval<const T&>()))>\n+  Result<Datum> operator()(const std::shared_ptr<T>& ptr) {\n+    return path_.Get(*ptr).template As<Datum>();\n+  }\n+\n+  template <typename T>\n+  Result<Datum> operator()(const T&) {\n+    return Status::NotImplemented(\"FieldPath::Get() into Datum \", datum_.ToString());\n+  }\n+\n+  const Datum& datum_;\n+  const FieldPath& path_;\n+};\n+\n+inline Result<Datum> GetDatumField(const FieldRef& ref, const Datum& input) {\n+  Datum field;\n+\n+  FieldPath path;\n+  if (auto type = input.type()) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.type()));\n+  } else if (input.kind() == Datum::RECORD_BATCH) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.record_batch()->schema()));\n+  } else if (input.kind() == Datum::TABLE) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.table()->schema()));\n+  }\n+\n+  if (path) {\n+    ARROW_ASSIGN_OR_RAISE(field,\n+                          util::visit(FieldPathGetDatumImpl{input, path}, input.value));\n+  }\n+\n+  if (field == Datum{}) {\n+    field = Datum(std::make_shared<NullScalar>());\n+  }\n+\n+  return field;\n+}\n+\n+struct Comparison {\n+  enum type {\n+    NA = 0,\n+    EQUAL = 1,\n+    LESS = 2,\n+    GREATER = 4,\n+    NOT_EQUAL = LESS | GREATER,\n+    LESS_EQUAL = LESS | EQUAL,\n+    GREATER_EQUAL = GREATER | EQUAL,\n+  };\n+\n+  static const type* Get(const std::string& function) {\n+    static std::unordered_map<std::string, type> flipped_comparisons{\n+        {\"equal\", EQUAL},     {\"not_equal\", NOT_EQUAL},\n+        {\"less\", LESS},       {\"less_equal\", LESS_EQUAL},\n+        {\"greater\", GREATER}, {\"greater_equal\", GREATER_EQUAL},\n+    };\n+\n+    auto it = flipped_comparisons.find(function);\n+    return it != flipped_comparisons.end() ? &it->second : nullptr;\n+  }\n+\n+  static const type* Get(const Expression& expr) {\n+    if (auto call = expr.call()) {\n+      return Comparison::Get(call->function_name);\n+    }\n+    return nullptr;\n+  }\n+\n+  // Execute a simple Comparison between scalars, casting the RHS if types disagree\n+  static Result<type> Execute(Datum l, Datum r) {\n+    if (!l.is_scalar() || !r.is_scalar()) {\n+      return Status::Invalid(\"Cannot Execute Comparison on non-scalars\");\n+    }\n+\n+    if (!l.type()->Equals(r.type())) {\n+      ARROW_ASSIGN_OR_RAISE(r, compute::Cast(r, l.type()));\n+    }\n+\n+    std::vector<Datum> arguments{std::move(l), std::move(r)};\n+\n+    ARROW_ASSIGN_OR_RAISE(auto equal, compute::CallFunction(\"equal\", arguments));\n+\n+    if (!equal.scalar()->is_valid) return NA;\n+    if (equal.scalar_as<BooleanScalar>().value) return EQUAL;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto less, compute::CallFunction(\"less\", arguments));\n+\n+    if (!less.scalar()->is_valid) return NA;\n+    return less.scalar_as<BooleanScalar>().value ? LESS : GREATER;\n+  }\n+\n+  static type GetFlipped(type op) {\n+    switch (op) {\n+      case NA:\n+        return NA;\n+      case EQUAL:\n+        return EQUAL;\n+      case LESS:\n+        return GREATER;\n+      case GREATER:\n+        return LESS;\n+      case NOT_EQUAL:\n+        return NOT_EQUAL;\n+      case LESS_EQUAL:\n+        return GREATER_EQUAL;\n+      case GREATER_EQUAL:\n+        return LESS_EQUAL;\n+    }\n+    DCHECK(false);\n+    return NA;\n+  }\n+\n+  static std::string GetName(type op) {\n+    switch (op) {\n+      case NA:\n+        DCHECK(false) << \"unreachable\";\n+        break;\n+      case EQUAL:\n+        return \"equal\";\n+      case LESS:\n+        return \"less\";\n+      case GREATER:\n+        return \"greater\";\n+      case NOT_EQUAL:\n+        return \"not_equal\";\n+      case LESS_EQUAL:\n+        return \"less_equal\";\n+      case GREATER_EQUAL:\n+        return \"greater_equal\";\n+    }\n+    DCHECK(false);\n+    return \"na\";\n+  }\n+\n+  static std::string GetOp(type op) {\n+    switch (op) {\n+      case NA:\n+        DCHECK(false) << \"unreachable\";\n+        break;\n+      case EQUAL:\n+        return \"==\";\n+      case LESS:\n+        return \"<\";\n+      case GREATER:\n+        return \">\";\n+      case NOT_EQUAL:\n+        return \"!=\";\n+      case LESS_EQUAL:\n+        return \"<=\";\n+      case GREATER_EQUAL:\n+        return \">=\";\n+    }\n+    DCHECK(false);\n+    return \"\";\n+  }\n+};\n+\n+inline const compute::CastOptions* GetCastOptions(const Expression::Call& call) {\n+  if (call.function_name != \"cast\") return nullptr;\n+  return checked_cast<const compute::CastOptions*>(call.options.get());\n+}\n+\n+inline bool IsSetLookup(const std::string& function) {\n+  return function == \"is_in\" || function == \"index_in\";\n+}\n+\n+inline bool IsSameTypesBinary(const std::string& function) {\n+  if (Comparison::Get(function)) return true;\n+\n+  static std::unordered_set<std::string> set{\"add\", \"subtract\", \"multiply\", \"divide\"};\n+\n+  return set.find(function) != set.end();\n+}\n+\n+inline const compute::SetLookupOptions* GetSetLookupOptions(\n+    const Expression::Call& call) {\n+  if (!IsSetLookup(call.function_name)) return nullptr;\n+  return checked_cast<const compute::SetLookupOptions*>(call.options.get());\n+}\n+\n+inline const compute::StructOptions* GetStructOptions(const Expression::Call& call) {\n+  if (call.function_name != \"struct\") return nullptr;\n+  return checked_cast<const compute::StructOptions*>(call.options.get());\n+}\n+\n+inline const compute::StrptimeOptions* GetStrptimeOptions(const Expression::Call& call) {\n+  if (call.function_name != \"strptime\") return nullptr;\n+  return checked_cast<const compute::StrptimeOptions*>(call.options.get());\n+}\n+\n+inline const std::shared_ptr<DataType>& GetDictionaryValueType(\n+    const std::shared_ptr<DataType>& type) {\n+  if (type && type->id() == Type::DICTIONARY) {\n+    return checked_cast<const DictionaryType&>(*type).value_type();\n+  }\n+  static std::shared_ptr<DataType> null;\n+  return null;\n+}\n+\n+inline Status EnsureNotDictionary(ValueDescr* descr) {\n+  if (auto value_type = GetDictionaryValueType(descr->type)) {\n+    descr->type = std::move(value_type);\n+  }\n+  return Status::OK();\n+}\n+\n+inline Status EnsureNotDictionary(Datum* datum) {\n+  if (datum->type()->id() == Type::DICTIONARY) {\n+    const auto& type = checked_cast<const DictionaryType&>(*datum->type()).value_type();\n+    ARROW_ASSIGN_OR_RAISE(*datum, compute::Cast(*datum, type));\n+  }\n+  return Status::OK();\n+}\n+\n+inline Status EnsureNotDictionary(Expression::Call* call) {\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto new_options = *options;\n+    RETURN_NOT_OK(EnsureNotDictionary(&new_options.value_set));\n+    call->options.reset(new compute::SetLookupOptions(std::move(new_options)));\n+  }\n+  return Status::OK();\n+}\n+\n+inline Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const Expression::Call& call) {\n+  if (call.options == nullptr) {\n+    return nullptr;\n+  }\n+\n+  auto Finish = [](ScalarVector values, std::vector<std::string> names) {\n\nReview comment:\n       This looks generally useful. Make this could be an alternate constructor or static factory of `StructScalar`?\n\n##########\nFile path: cpp/src/arrow/dataset/expression_internal.h\n##########\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace dataset {\n+\n+bool Identical(const Expression& l, const Expression& r) { return l.impl_ == r.impl_; }\n+\n+const Expression::Call* CallNotNull(const Expression& expr) {\n+  auto call = expr.call();\n+  DCHECK_NE(call, nullptr);\n+  return call;\n+}\n+\n+inline void GetAllFieldRefs(const Expression& expr,\n+                            std::unordered_set<FieldRef, FieldRef::Hash>* refs) {\n+  if (auto lit = expr.literal()) return;\n+\n+  if (auto ref = expr.field_ref()) {\n+    refs->emplace(*ref);\n+    return;\n+  }\n+\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    GetAllFieldRefs(arg, refs);\n+  }\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Expression>& exprs) {\n+  std::vector<ValueDescr> descrs(exprs.size());\n+  for (size_t i = 0; i < exprs.size(); ++i) {\n+    DCHECK(exprs[i].IsBound());\n+    descrs[i] = exprs[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Datum>& values) {\n+  std::vector<ValueDescr> descrs(values.size());\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    descrs[i] = values[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+struct FieldPathGetDatumImpl {\n+  template <typename T, typename = decltype(FieldPath{}.Get(std::declval<const T&>()))>\n+  Result<Datum> operator()(const std::shared_ptr<T>& ptr) {\n+    return path_.Get(*ptr).template As<Datum>();\n+  }\n+\n+  template <typename T>\n+  Result<Datum> operator()(const T&) {\n+    return Status::NotImplemented(\"FieldPath::Get() into Datum \", datum_.ToString());\n+  }\n+\n+  const Datum& datum_;\n+  const FieldPath& path_;\n+};\n+\n+inline Result<Datum> GetDatumField(const FieldRef& ref, const Datum& input) {\n+  Datum field;\n+\n+  FieldPath path;\n+  if (auto type = input.type()) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.type()));\n+  } else if (input.kind() == Datum::RECORD_BATCH) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.record_batch()->schema()));\n+  } else if (input.kind() == Datum::TABLE) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.table()->schema()));\n+  }\n+\n+  if (path) {\n+    ARROW_ASSIGN_OR_RAISE(field,\n+                          util::visit(FieldPathGetDatumImpl{input, path}, input.value));\n+  }\n+\n+  if (field == Datum{}) {\n+    field = Datum(std::make_shared<NullScalar>());\n+  }\n+\n+  return field;\n+}\n+\n+struct Comparison {\n+  enum type {\n+    NA = 0,\n+    EQUAL = 1,\n+    LESS = 2,\n+    GREATER = 4,\n+    NOT_EQUAL = LESS | GREATER,\n+    LESS_EQUAL = LESS | EQUAL,\n+    GREATER_EQUAL = GREATER | EQUAL,\n+  };\n+\n+  static const type* Get(const std::string& function) {\n+    static std::unordered_map<std::string, type> flipped_comparisons{\n+        {\"equal\", EQUAL},     {\"not_equal\", NOT_EQUAL},\n+        {\"less\", LESS},       {\"less_equal\", LESS_EQUAL},\n+        {\"greater\", GREATER}, {\"greater_equal\", GREATER_EQUAL},\n+    };\n+\n+    auto it = flipped_comparisons.find(function);\n+    return it != flipped_comparisons.end() ? &it->second : nullptr;\n+  }\n+\n+  static const type* Get(const Expression& expr) {\n+    if (auto call = expr.call()) {\n+      return Comparison::Get(call->function_name);\n+    }\n+    return nullptr;\n+  }\n+\n+  // Execute a simple Comparison between scalars, casting the RHS if types disagree\n+  static Result<type> Execute(Datum l, Datum r) {\n+    if (!l.is_scalar() || !r.is_scalar()) {\n+      return Status::Invalid(\"Cannot Execute Comparison on non-scalars\");\n+    }\n+\n+    if (!l.type()->Equals(r.type())) {\n+      ARROW_ASSIGN_OR_RAISE(r, compute::Cast(r, l.type()));\n+    }\n+\n+    std::vector<Datum> arguments{std::move(l), std::move(r)};\n+\n+    ARROW_ASSIGN_OR_RAISE(auto equal, compute::CallFunction(\"equal\", arguments));\n+\n+    if (!equal.scalar()->is_valid) return NA;\n+    if (equal.scalar_as<BooleanScalar>().value) return EQUAL;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto less, compute::CallFunction(\"less\", arguments));\n+\n+    if (!less.scalar()->is_valid) return NA;\n+    return less.scalar_as<BooleanScalar>().value ? LESS : GREATER;\n+  }\n+\n+  static type GetFlipped(type op) {\n+    switch (op) {\n+      case NA:\n+        return NA;\n+      case EQUAL:\n+        return EQUAL;\n+      case LESS:\n+        return GREATER;\n+      case GREATER:\n+        return LESS;\n+      case NOT_EQUAL:\n+        return NOT_EQUAL;\n+      case LESS_EQUAL:\n+        return GREATER_EQUAL;\n+      case GREATER_EQUAL:\n+        return LESS_EQUAL;\n+    }\n+    DCHECK(false);\n+    return NA;\n+  }\n+\n+  static std::string GetName(type op) {\n+    switch (op) {\n+      case NA:\n+        DCHECK(false) << \"unreachable\";\n+        break;\n+      case EQUAL:\n+        return \"equal\";\n+      case LESS:\n+        return \"less\";\n+      case GREATER:\n+        return \"greater\";\n+      case NOT_EQUAL:\n+        return \"not_equal\";\n+      case LESS_EQUAL:\n+        return \"less_equal\";\n+      case GREATER_EQUAL:\n+        return \"greater_equal\";\n+    }\n+    DCHECK(false);\n+    return \"na\";\n+  }\n+\n+  static std::string GetOp(type op) {\n+    switch (op) {\n+      case NA:\n+        DCHECK(false) << \"unreachable\";\n+        break;\n+      case EQUAL:\n+        return \"==\";\n+      case LESS:\n+        return \"<\";\n+      case GREATER:\n+        return \">\";\n+      case NOT_EQUAL:\n+        return \"!=\";\n+      case LESS_EQUAL:\n+        return \"<=\";\n+      case GREATER_EQUAL:\n+        return \">=\";\n+    }\n+    DCHECK(false);\n+    return \"\";\n+  }\n+};\n+\n+inline const compute::CastOptions* GetCastOptions(const Expression::Call& call) {\n+  if (call.function_name != \"cast\") return nullptr;\n+  return checked_cast<const compute::CastOptions*>(call.options.get());\n+}\n+\n+inline bool IsSetLookup(const std::string& function) {\n+  return function == \"is_in\" || function == \"index_in\";\n+}\n+\n+inline bool IsSameTypesBinary(const std::string& function) {\n+  if (Comparison::Get(function)) return true;\n+\n+  static std::unordered_set<std::string> set{\"add\", \"subtract\", \"multiply\", \"divide\"};\n+\n+  return set.find(function) != set.end();\n+}\n+\n+inline const compute::SetLookupOptions* GetSetLookupOptions(\n+    const Expression::Call& call) {\n+  if (!IsSetLookup(call.function_name)) return nullptr;\n+  return checked_cast<const compute::SetLookupOptions*>(call.options.get());\n+}\n+\n+inline const compute::StructOptions* GetStructOptions(const Expression::Call& call) {\n+  if (call.function_name != \"struct\") return nullptr;\n+  return checked_cast<const compute::StructOptions*>(call.options.get());\n+}\n+\n+inline const compute::StrptimeOptions* GetStrptimeOptions(const Expression::Call& call) {\n+  if (call.function_name != \"strptime\") return nullptr;\n+  return checked_cast<const compute::StrptimeOptions*>(call.options.get());\n+}\n+\n+inline const std::shared_ptr<DataType>& GetDictionaryValueType(\n+    const std::shared_ptr<DataType>& type) {\n+  if (type && type->id() == Type::DICTIONARY) {\n+    return checked_cast<const DictionaryType&>(*type).value_type();\n+  }\n+  static std::shared_ptr<DataType> null;\n+  return null;\n+}\n+\n+inline Status EnsureNotDictionary(ValueDescr* descr) {\n+  if (auto value_type = GetDictionaryValueType(descr->type)) {\n+    descr->type = std::move(value_type);\n+  }\n+  return Status::OK();\n+}\n+\n+inline Status EnsureNotDictionary(Datum* datum) {\n+  if (datum->type()->id() == Type::DICTIONARY) {\n+    const auto& type = checked_cast<const DictionaryType&>(*datum->type()).value_type();\n+    ARROW_ASSIGN_OR_RAISE(*datum, compute::Cast(*datum, type));\n+  }\n+  return Status::OK();\n+}\n+\n+inline Status EnsureNotDictionary(Expression::Call* call) {\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto new_options = *options;\n+    RETURN_NOT_OK(EnsureNotDictionary(&new_options.value_set));\n+    call->options.reset(new compute::SetLookupOptions(std::move(new_options)));\n+  }\n+  return Status::OK();\n+}\n+\n+inline Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const Expression::Call& call) {\n+  if (call.options == nullptr) {\n+    return nullptr;\n+  }\n+\n+  auto Finish = [](ScalarVector values, std::vector<std::string> names) {\n+    FieldVector fields(names.size());\n+    for (size_t i = 0; i < fields.size(); ++i) {\n+      fields[i] = field(std::move(names[i]), values[i]->type);\n+    }\n+    return std::make_shared<StructScalar>(std::move(values), struct_(std::move(fields)));\n+  };\n+\n+  if (auto options = GetSetLookupOptions(call)) {\n+    if (!options->value_set.is_array()) {\n+      return Status::NotImplemented(\"chunked value_set\");\n+    }\n+    return Finish(\n+        {\n+            std::make_shared<ListScalar>(options->value_set.make_array()),\n+            MakeScalar(options->skip_nulls),\n+        },\n+        {\"value_set\", \"skip_nulls\"});\n+  }\n+\n+  if (call.function_name == \"cast\") {\n+    auto options = checked_cast<const compute::CastOptions*>(call.options.get());\n+    return Finish(\n+        {\n+            MakeNullScalar(options->to_type),\n+            MakeScalar(options->allow_int_overflow),\n+            MakeScalar(options->allow_time_truncate),\n+            MakeScalar(options->allow_time_overflow),\n+            MakeScalar(options->allow_decimal_truncate),\n+            MakeScalar(options->allow_float_truncate),\n+            MakeScalar(options->allow_invalid_utf8),\n+        },\n+        {\n+            \"to_type_holder\",\n+            \"allow_int_overflow\",\n+            \"allow_time_truncate\",\n+            \"allow_time_overflow\",\n+            \"allow_decimal_truncate\",\n+            \"allow_float_truncate\",\n+            \"allow_invalid_utf8\",\n+        });\n+  }\n+\n+  return Status::NotImplemented(\"conversion of options for \", call.function_name);\n+}\n+\n+inline Status FunctionOptionsFromStructScalar(const StructScalar* repr,\n+                                              Expression::Call* call) {\n+  if (repr == nullptr) {\n+    call->options = nullptr;\n+    return Status::OK();\n+  }\n+\n+  if (IsSetLookup(call->function_name)) {\n+    ARROW_ASSIGN_OR_RAISE(auto value_set, repr->field(\"value_set\"));\n+    ARROW_ASSIGN_OR_RAISE(auto skip_nulls, repr->field(\"skip_nulls\"));\n+    call->options = std::make_shared<compute::SetLookupOptions>(\n+        checked_cast<const ListScalar&>(*value_set).value,\n+        checked_cast<const BooleanScalar&>(*skip_nulls).value);\n+    return Status::OK();\n+  }\n+\n+  if (call->function_name == \"cast\") {\n+    auto options = std::make_shared<compute::CastOptions>();\n+    ARROW_ASSIGN_OR_RAISE(auto to_type_holder, repr->field(\"to_type_holder\"));\n+    options->to_type = to_type_holder->type;\n+\n+    int i = 1;\n+    for (bool* opt : {\n+             &options->allow_int_overflow,\n+             &options->allow_time_truncate,\n+             &options->allow_time_overflow,\n+             &options->allow_decimal_truncate,\n+             &options->allow_float_truncate,\n+             &options->allow_invalid_utf8,\n+         }) {\n+      *opt = checked_cast<const BooleanScalar&>(*repr->value[i++]).value;\n+    }\n+\n+    call->options = std::move(options);\n+    return Status::OK();\n+  }\n+\n+  return Status::NotImplemented(\"conversion of options for \", call->function_name);\n+}\n+\n+struct FlattenedAssociativeChain {\n+  bool was_left_folded = true;\n+  std::vector<Expression> exprs, fringe;\n+\n+  explicit FlattenedAssociativeChain(Expression expr) : exprs{std::move(expr)} {\n\nReview comment:\n       What does this do? Add a comment?\n\n##########\nFile path: cpp/src/arrow/dataset/expression_internal.h\n##########\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace dataset {\n+\n+bool Identical(const Expression& l, const Expression& r) { return l.impl_ == r.impl_; }\n+\n+const Expression::Call* CallNotNull(const Expression& expr) {\n+  auto call = expr.call();\n+  DCHECK_NE(call, nullptr);\n+  return call;\n+}\n+\n+inline void GetAllFieldRefs(const Expression& expr,\n+                            std::unordered_set<FieldRef, FieldRef::Hash>* refs) {\n+  if (auto lit = expr.literal()) return;\n+\n+  if (auto ref = expr.field_ref()) {\n+    refs->emplace(*ref);\n+    return;\n+  }\n+\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    GetAllFieldRefs(arg, refs);\n+  }\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Expression>& exprs) {\n+  std::vector<ValueDescr> descrs(exprs.size());\n+  for (size_t i = 0; i < exprs.size(); ++i) {\n+    DCHECK(exprs[i].IsBound());\n+    descrs[i] = exprs[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Datum>& values) {\n+  std::vector<ValueDescr> descrs(values.size());\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    descrs[i] = values[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+struct FieldPathGetDatumImpl {\n+  template <typename T, typename = decltype(FieldPath{}.Get(std::declval<const T&>()))>\n+  Result<Datum> operator()(const std::shared_ptr<T>& ptr) {\n+    return path_.Get(*ptr).template As<Datum>();\n+  }\n+\n+  template <typename T>\n+  Result<Datum> operator()(const T&) {\n+    return Status::NotImplemented(\"FieldPath::Get() into Datum \", datum_.ToString());\n+  }\n+\n+  const Datum& datum_;\n+  const FieldPath& path_;\n+};\n+\n+inline Result<Datum> GetDatumField(const FieldRef& ref, const Datum& input) {\n+  Datum field;\n+\n+  FieldPath path;\n+  if (auto type = input.type()) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.type()));\n+  } else if (input.kind() == Datum::RECORD_BATCH) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.record_batch()->schema()));\n+  } else if (input.kind() == Datum::TABLE) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.table()->schema()));\n+  }\n+\n+  if (path) {\n+    ARROW_ASSIGN_OR_RAISE(field,\n+                          util::visit(FieldPathGetDatumImpl{input, path}, input.value));\n+  }\n+\n+  if (field == Datum{}) {\n+    field = Datum(std::make_shared<NullScalar>());\n+  }\n+\n+  return field;\n+}\n+\n+struct Comparison {\n+  enum type {\n+    NA = 0,\n+    EQUAL = 1,\n+    LESS = 2,\n+    GREATER = 4,\n+    NOT_EQUAL = LESS | GREATER,\n+    LESS_EQUAL = LESS | EQUAL,\n+    GREATER_EQUAL = GREATER | EQUAL,\n+  };\n+\n+  static const type* Get(const std::string& function) {\n+    static std::unordered_map<std::string, type> flipped_comparisons{\n+        {\"equal\", EQUAL},     {\"not_equal\", NOT_EQUAL},\n+        {\"less\", LESS},       {\"less_equal\", LESS_EQUAL},\n+        {\"greater\", GREATER}, {\"greater_equal\", GREATER_EQUAL},\n+    };\n+\n+    auto it = flipped_comparisons.find(function);\n+    return it != flipped_comparisons.end() ? &it->second : nullptr;\n+  }\n+\n+  static const type* Get(const Expression& expr) {\n+    if (auto call = expr.call()) {\n+      return Comparison::Get(call->function_name);\n+    }\n+    return nullptr;\n+  }\n+\n+  // Execute a simple Comparison between scalars, casting the RHS if types disagree\n+  static Result<type> Execute(Datum l, Datum r) {\n+    if (!l.is_scalar() || !r.is_scalar()) {\n+      return Status::Invalid(\"Cannot Execute Comparison on non-scalars\");\n+    }\n+\n+    if (!l.type()->Equals(r.type())) {\n+      ARROW_ASSIGN_OR_RAISE(r, compute::Cast(r, l.type()));\n+    }\n+\n+    std::vector<Datum> arguments{std::move(l), std::move(r)};\n+\n+    ARROW_ASSIGN_OR_RAISE(auto equal, compute::CallFunction(\"equal\", arguments));\n+\n+    if (!equal.scalar()->is_valid) return NA;\n+    if (equal.scalar_as<BooleanScalar>().value) return EQUAL;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto less, compute::CallFunction(\"less\", arguments));\n+\n+    if (!less.scalar()->is_valid) return NA;\n+    return less.scalar_as<BooleanScalar>().value ? LESS : GREATER;\n+  }\n+\n+  static type GetFlipped(type op) {\n+    switch (op) {\n+      case NA:\n+        return NA;\n+      case EQUAL:\n+        return EQUAL;\n+      case LESS:\n+        return GREATER;\n+      case GREATER:\n+        return LESS;\n+      case NOT_EQUAL:\n+        return NOT_EQUAL;\n+      case LESS_EQUAL:\n+        return GREATER_EQUAL;\n+      case GREATER_EQUAL:\n+        return LESS_EQUAL;\n+    }\n+    DCHECK(false);\n+    return NA;\n+  }\n+\n+  static std::string GetName(type op) {\n+    switch (op) {\n+      case NA:\n+        DCHECK(false) << \"unreachable\";\n+        break;\n+      case EQUAL:\n+        return \"equal\";\n+      case LESS:\n+        return \"less\";\n+      case GREATER:\n+        return \"greater\";\n+      case NOT_EQUAL:\n+        return \"not_equal\";\n+      case LESS_EQUAL:\n+        return \"less_equal\";\n+      case GREATER_EQUAL:\n+        return \"greater_equal\";\n+    }\n+    DCHECK(false);\n+    return \"na\";\n+  }\n+\n+  static std::string GetOp(type op) {\n+    switch (op) {\n+      case NA:\n+        DCHECK(false) << \"unreachable\";\n+        break;\n+      case EQUAL:\n+        return \"==\";\n+      case LESS:\n+        return \"<\";\n+      case GREATER:\n+        return \">\";\n+      case NOT_EQUAL:\n+        return \"!=\";\n+      case LESS_EQUAL:\n+        return \"<=\";\n+      case GREATER_EQUAL:\n+        return \">=\";\n+    }\n+    DCHECK(false);\n+    return \"\";\n+  }\n+};\n+\n+inline const compute::CastOptions* GetCastOptions(const Expression::Call& call) {\n+  if (call.function_name != \"cast\") return nullptr;\n+  return checked_cast<const compute::CastOptions*>(call.options.get());\n+}\n+\n+inline bool IsSetLookup(const std::string& function) {\n+  return function == \"is_in\" || function == \"index_in\";\n+}\n+\n+inline bool IsSameTypesBinary(const std::string& function) {\n+  if (Comparison::Get(function)) return true;\n+\n+  static std::unordered_set<std::string> set{\"add\", \"subtract\", \"multiply\", \"divide\"};\n+\n+  return set.find(function) != set.end();\n+}\n+\n+inline const compute::SetLookupOptions* GetSetLookupOptions(\n+    const Expression::Call& call) {\n+  if (!IsSetLookup(call.function_name)) return nullptr;\n+  return checked_cast<const compute::SetLookupOptions*>(call.options.get());\n+}\n+\n+inline const compute::StructOptions* GetStructOptions(const Expression::Call& call) {\n+  if (call.function_name != \"struct\") return nullptr;\n+  return checked_cast<const compute::StructOptions*>(call.options.get());\n+}\n+\n+inline const compute::StrptimeOptions* GetStrptimeOptions(const Expression::Call& call) {\n+  if (call.function_name != \"strptime\") return nullptr;\n+  return checked_cast<const compute::StrptimeOptions*>(call.options.get());\n+}\n+\n+inline const std::shared_ptr<DataType>& GetDictionaryValueType(\n+    const std::shared_ptr<DataType>& type) {\n+  if (type && type->id() == Type::DICTIONARY) {\n+    return checked_cast<const DictionaryType&>(*type).value_type();\n+  }\n+  static std::shared_ptr<DataType> null;\n+  return null;\n+}\n+\n+inline Status EnsureNotDictionary(ValueDescr* descr) {\n+  if (auto value_type = GetDictionaryValueType(descr->type)) {\n+    descr->type = std::move(value_type);\n+  }\n+  return Status::OK();\n+}\n+\n+inline Status EnsureNotDictionary(Datum* datum) {\n+  if (datum->type()->id() == Type::DICTIONARY) {\n+    const auto& type = checked_cast<const DictionaryType&>(*datum->type()).value_type();\n+    ARROW_ASSIGN_OR_RAISE(*datum, compute::Cast(*datum, type));\n+  }\n+  return Status::OK();\n+}\n+\n+inline Status EnsureNotDictionary(Expression::Call* call) {\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto new_options = *options;\n+    RETURN_NOT_OK(EnsureNotDictionary(&new_options.value_set));\n+    call->options.reset(new compute::SetLookupOptions(std::move(new_options)));\n+  }\n+  return Status::OK();\n+}\n+\n+inline Result<std::shared_ptr<StructScalar>> FunctionOptionsToStructScalar(\n+    const Expression::Call& call) {\n+  if (call.options == nullptr) {\n+    return nullptr;\n+  }\n+\n+  auto Finish = [](ScalarVector values, std::vector<std::string> names) {\n+    FieldVector fields(names.size());\n+    for (size_t i = 0; i < fields.size(); ++i) {\n+      fields[i] = field(std::move(names[i]), values[i]->type);\n+    }\n+    return std::make_shared<StructScalar>(std::move(values), struct_(std::move(fields)));\n+  };\n+\n+  if (auto options = GetSetLookupOptions(call)) {\n+    if (!options->value_set.is_array()) {\n+      return Status::NotImplemented(\"chunked value_set\");\n+    }\n+    return Finish(\n+        {\n+            std::make_shared<ListScalar>(options->value_set.make_array()),\n+            MakeScalar(options->skip_nulls),\n+        },\n+        {\"value_set\", \"skip_nulls\"});\n+  }\n+\n+  if (call.function_name == \"cast\") {\n+    auto options = checked_cast<const compute::CastOptions*>(call.options.get());\n+    return Finish(\n+        {\n+            MakeNullScalar(options->to_type),\n+            MakeScalar(options->allow_int_overflow),\n+            MakeScalar(options->allow_time_truncate),\n+            MakeScalar(options->allow_time_overflow),\n+            MakeScalar(options->allow_decimal_truncate),\n+            MakeScalar(options->allow_float_truncate),\n+            MakeScalar(options->allow_invalid_utf8),\n+        },\n+        {\n+            \"to_type_holder\",\n+            \"allow_int_overflow\",\n+            \"allow_time_truncate\",\n+            \"allow_time_overflow\",\n+            \"allow_decimal_truncate\",\n+            \"allow_float_truncate\",\n+            \"allow_invalid_utf8\",\n+        });\n+  }\n+\n+  return Status::NotImplemented(\"conversion of options for \", call.function_name);\n+}\n+\n+inline Status FunctionOptionsFromStructScalar(const StructScalar* repr,\n+                                              Expression::Call* call) {\n+  if (repr == nullptr) {\n+    call->options = nullptr;\n+    return Status::OK();\n+  }\n+\n+  if (IsSetLookup(call->function_name)) {\n+    ARROW_ASSIGN_OR_RAISE(auto value_set, repr->field(\"value_set\"));\n+    ARROW_ASSIGN_OR_RAISE(auto skip_nulls, repr->field(\"skip_nulls\"));\n+    call->options = std::make_shared<compute::SetLookupOptions>(\n+        checked_cast<const ListScalar&>(*value_set).value,\n+        checked_cast<const BooleanScalar&>(*skip_nulls).value);\n+    return Status::OK();\n+  }\n+\n+  if (call->function_name == \"cast\") {\n+    auto options = std::make_shared<compute::CastOptions>();\n+    ARROW_ASSIGN_OR_RAISE(auto to_type_holder, repr->field(\"to_type_holder\"));\n+    options->to_type = to_type_holder->type;\n+\n+    int i = 1;\n+    for (bool* opt : {\n+             &options->allow_int_overflow,\n+             &options->allow_time_truncate,\n+             &options->allow_time_overflow,\n+             &options->allow_decimal_truncate,\n+             &options->allow_float_truncate,\n+             &options->allow_invalid_utf8,\n+         }) {\n+      *opt = checked_cast<const BooleanScalar&>(*repr->value[i++]).value;\n+    }\n+\n+    call->options = std::move(options);\n+    return Status::OK();\n+  }\n+\n+  return Status::NotImplemented(\"conversion of options for \", call->function_name);\n+}\n+\n+struct FlattenedAssociativeChain {\n+  bool was_left_folded = true;\n+  std::vector<Expression> exprs, fringe;\n+\n+  explicit FlattenedAssociativeChain(Expression expr) : exprs{std::move(expr)} {\n+    auto call = CallNotNull(exprs.back());\n+    fringe = call->arguments;\n+\n+    auto it = fringe.begin();\n+\n+    while (it != fringe.end()) {\n+      auto sub_call = it->call();\n+      if (!sub_call || sub_call->function_name != call->function_name) {\n+        ++it;\n+        continue;\n+      }\n+\n+      if (it != fringe.begin()) {\n+        was_left_folded = false;\n+      }\n+\n+      exprs.push_back(std::move(*it));\n+      it = fringe.erase(it);\n+      it = fringe.insert(it, sub_call->arguments.begin(), sub_call->arguments.end());\n+      // NB: no increment so we hit sub_call's first argument next iteration\n+    }\n+\n+    DCHECK(std::all_of(exprs.begin(), exprs.end(), [](const Expression& expr) {\n+      return CallNotNull(expr)->options == nullptr;\n+    }));\n+  }\n+};\n+\n+inline Result<std::shared_ptr<compute::Function>> GetFunction(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (call.function_name != \"cast\") {\n+    return exec_context->func_registry()->GetFunction(call.function_name);\n+  }\n+  // XXX this special case is strange; why not make \"cast\" a ScalarFunction?\n\nReview comment:\n       Because its output type depends on the options, not only the input types, I presume?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n\nReview comment:\n       Why does it need fixing?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n\nReview comment:\n       Ideally we would have `FunctionOptions::Equals`...\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n\nReview comment:\n       Well, the problem is that you may be casting a large type to a narrower type. We would need some type unification logic.\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n\nReview comment:\n       Hmm... why does it change anything to \"bind\" with an empty descr?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n+    return Expression{Parameter{*ref, std::move(descr)}};\n+  }\n+\n+  auto bound_call = *CallNotNull(*this);\n+\n+  ARROW_ASSIGN_OR_RAISE(bound_call.function, GetFunction(bound_call, exec_context));\n+\n+  for (auto&& argument : bound_call.arguments) {\n+    ARROW_ASSIGN_OR_RAISE(argument, argument.Bind(in, exec_context));\n+  }\n+  RETURN_NOT_OK(InsertImplicitCasts(&bound_call));\n+\n+  auto descrs = GetDescriptors(bound_call.arguments);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel, bound_call.function->DispatchExact(descrs));\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel_state,\n+                        InitKernelState(bound_call, exec_context));\n\nReview comment:\n       `InitKernelState` recreates a new kernel context. Should it keep the same one?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n\nReview comment:\n       Perhaps it should? It would also be far faster in practice (only do the set lookup on the dictionary and take from the results...).\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n+    return Expression{Parameter{*ref, std::move(descr)}};\n+  }\n+\n+  auto bound_call = *CallNotNull(*this);\n+\n+  ARROW_ASSIGN_OR_RAISE(bound_call.function, GetFunction(bound_call, exec_context));\n+\n+  for (auto&& argument : bound_call.arguments) {\n+    ARROW_ASSIGN_OR_RAISE(argument, argument.Bind(in, exec_context));\n+  }\n+  RETURN_NOT_OK(InsertImplicitCasts(&bound_call));\n+\n+  auto descrs = GetDescriptors(bound_call.arguments);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel, bound_call.function->DispatchExact(descrs));\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel_state,\n+                        InitKernelState(bound_call, exec_context));\n+  kernel_context.SetState(bound_call.kernel_state.get());\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      bound_call.descr,\n+      bound_call.kernel->signature->out_type().Resolve(&kernel_context, descrs));\n+\n+  return Expression(std::move(bound_call));\n+}\n+\n+Result<Expression> Expression::Bind(const Schema& in_schema,\n+                                    compute::ExecContext* exec_context) const {\n+  return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n+}\n+\n+Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+                                      compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return ExecuteScalarExpression(expr, input, &exec_context);\n+  }\n+\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\"Cannot Execute unbound expression.\");\n+  }\n+\n+  if (!expr.IsScalarExpression()) {\n\nReview comment:\n       This calls `IsScalarExpression` at each level of the expression tree, and `IsScalarExpression` itself is recursive, so will result in O(N^2) expression node visits.\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n\nReview comment:\n       But why would anyone pass a dictionary as a value set? Especially as a value set, by definition, doesn't care about duplicates.\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n\nReview comment:\n       Hmm, so referring a non-existing field is ok? That seems a bit fragile in the presence of e.g. typos.\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n\nReview comment:\n       Is this required for any actual use case?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n+    return Expression{Parameter{*ref, std::move(descr)}};\n+  }\n+\n+  auto bound_call = *CallNotNull(*this);\n+\n+  ARROW_ASSIGN_OR_RAISE(bound_call.function, GetFunction(bound_call, exec_context));\n+\n+  for (auto&& argument : bound_call.arguments) {\n+    ARROW_ASSIGN_OR_RAISE(argument, argument.Bind(in, exec_context));\n+  }\n+  RETURN_NOT_OK(InsertImplicitCasts(&bound_call));\n+\n+  auto descrs = GetDescriptors(bound_call.arguments);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel, bound_call.function->DispatchExact(descrs));\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel_state,\n+                        InitKernelState(bound_call, exec_context));\n+  kernel_context.SetState(bound_call.kernel_state.get());\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      bound_call.descr,\n+      bound_call.kernel->signature->out_type().Resolve(&kernel_context, descrs));\n+\n+  return Expression(std::move(bound_call));\n+}\n+\n+Result<Expression> Expression::Bind(const Schema& in_schema,\n+                                    compute::ExecContext* exec_context) const {\n+  return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n+}\n+\n+Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+                                      compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return ExecuteScalarExpression(expr, input, &exec_context);\n+  }\n+\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\"Cannot Execute unbound expression.\");\n+  }\n+\n+  if (!expr.IsScalarExpression()) {\n+    return Status::Invalid(\n+        \"ExecuteScalarExpression cannot Execute non-scalar expression \", expr.ToString());\n+  }\n+\n+  if (auto lit = expr.literal()) return *lit;\n+\n+  if (auto ref = expr.field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum field, GetDatumField(*ref, input));\n+\n+    if (field.descr() != expr.descr()) {\n+      // Refernced field was present but didn't have the expected type.\n+      // Should we just error here? For now, pay dispatch cost and just cast.\n+      ARROW_ASSIGN_OR_RAISE(\n+          field, compute::Cast(field, expr.descr().type, compute::CastOptions::Safe(),\n+                               exec_context));\n+    }\n+\n+    return field;\n+  }\n+\n+  auto call = CallNotNull(expr);\n+\n+  std::vector<Datum> arguments(call->arguments.size());\n+  for (size_t i = 0; i < arguments.size(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(\n+        arguments[i], ExecuteScalarExpression(call->arguments[i], input, exec_context));\n+  }\n+\n+  auto executor = compute::detail::KernelExecutor::MakeScalar();\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  kernel_context.SetState(call->kernel_state.get());\n+\n+  auto kernel = call->kernel;\n+  auto descrs = GetDescriptors(arguments);\n+  auto options = call->options.get();\n+  RETURN_NOT_OK(executor->Init(&kernel_context, {kernel, descrs, options}));\n+\n+  auto listener = std::make_shared<compute::detail::DatumAccumulator>();\n\nReview comment:\n       Hopefully we can have a compute API that avoids going through this...\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n+    return Expression{Parameter{*ref, std::move(descr)}};\n+  }\n+\n+  auto bound_call = *CallNotNull(*this);\n+\n+  ARROW_ASSIGN_OR_RAISE(bound_call.function, GetFunction(bound_call, exec_context));\n+\n+  for (auto&& argument : bound_call.arguments) {\n+    ARROW_ASSIGN_OR_RAISE(argument, argument.Bind(in, exec_context));\n+  }\n+  RETURN_NOT_OK(InsertImplicitCasts(&bound_call));\n+\n+  auto descrs = GetDescriptors(bound_call.arguments);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel, bound_call.function->DispatchExact(descrs));\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel_state,\n+                        InitKernelState(bound_call, exec_context));\n+  kernel_context.SetState(bound_call.kernel_state.get());\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      bound_call.descr,\n+      bound_call.kernel->signature->out_type().Resolve(&kernel_context, descrs));\n+\n+  return Expression(std::move(bound_call));\n+}\n+\n+Result<Expression> Expression::Bind(const Schema& in_schema,\n+                                    compute::ExecContext* exec_context) const {\n+  return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n+}\n+\n+Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+                                      compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return ExecuteScalarExpression(expr, input, &exec_context);\n+  }\n+\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\"Cannot Execute unbound expression.\");\n+  }\n+\n+  if (!expr.IsScalarExpression()) {\n+    return Status::Invalid(\n+        \"ExecuteScalarExpression cannot Execute non-scalar expression \", expr.ToString());\n+  }\n+\n+  if (auto lit = expr.literal()) return *lit;\n+\n+  if (auto ref = expr.field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum field, GetDatumField(*ref, input));\n+\n+    if (field.descr() != expr.descr()) {\n+      // Refernced field was present but didn't have the expected type.\n+      // Should we just error here? For now, pay dispatch cost and just cast.\n+      ARROW_ASSIGN_OR_RAISE(\n+          field, compute::Cast(field, expr.descr().type, compute::CastOptions::Safe(),\n+                               exec_context));\n+    }\n+\n+    return field;\n+  }\n+\n+  auto call = CallNotNull(expr);\n+\n+  std::vector<Datum> arguments(call->arguments.size());\n+  for (size_t i = 0; i < arguments.size(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(\n+        arguments[i], ExecuteScalarExpression(call->arguments[i], input, exec_context));\n+  }\n+\n+  auto executor = compute::detail::KernelExecutor::MakeScalar();\n\nReview comment:\n       We really need a compute API that allow to executor a `Kernel` over a vector of `Datum` inputs together with some `FunctionOptions`. Perhaps open a JIRA for that?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n\nReview comment:\n       It seems that we may want a `virtual Result<std::unique_ptr<FunctionOptions>> FunctionOptions::CastFor(const std::shared_ptr<DataType>& input_type)`?\r\n   \r\n   (returning nullptr by default, meaning unchanged)\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n+    return Expression{Parameter{*ref, std::move(descr)}};\n+  }\n+\n+  auto bound_call = *CallNotNull(*this);\n+\n+  ARROW_ASSIGN_OR_RAISE(bound_call.function, GetFunction(bound_call, exec_context));\n+\n+  for (auto&& argument : bound_call.arguments) {\n+    ARROW_ASSIGN_OR_RAISE(argument, argument.Bind(in, exec_context));\n+  }\n+  RETURN_NOT_OK(InsertImplicitCasts(&bound_call));\n+\n+  auto descrs = GetDescriptors(bound_call.arguments);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel, bound_call.function->DispatchExact(descrs));\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel_state,\n+                        InitKernelState(bound_call, exec_context));\n+  kernel_context.SetState(bound_call.kernel_state.get());\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      bound_call.descr,\n+      bound_call.kernel->signature->out_type().Resolve(&kernel_context, descrs));\n+\n+  return Expression(std::move(bound_call));\n+}\n+\n+Result<Expression> Expression::Bind(const Schema& in_schema,\n+                                    compute::ExecContext* exec_context) const {\n+  return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n+}\n+\n+Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n\nReview comment:\n       At some point, put all private stuff in the anonymous namespace.\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n\nReview comment:\n       Unless expressions are only meant to support a small frozen subset of compute functions?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n+    return Expression{Parameter{*ref, std::move(descr)}};\n+  }\n+\n+  auto bound_call = *CallNotNull(*this);\n+\n+  ARROW_ASSIGN_OR_RAISE(bound_call.function, GetFunction(bound_call, exec_context));\n+\n+  for (auto&& argument : bound_call.arguments) {\n+    ARROW_ASSIGN_OR_RAISE(argument, argument.Bind(in, exec_context));\n+  }\n+  RETURN_NOT_OK(InsertImplicitCasts(&bound_call));\n+\n+  auto descrs = GetDescriptors(bound_call.arguments);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel, bound_call.function->DispatchExact(descrs));\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel_state,\n+                        InitKernelState(bound_call, exec_context));\n+  kernel_context.SetState(bound_call.kernel_state.get());\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      bound_call.descr,\n+      bound_call.kernel->signature->out_type().Resolve(&kernel_context, descrs));\n+\n+  return Expression(std::move(bound_call));\n+}\n+\n+Result<Expression> Expression::Bind(const Schema& in_schema,\n+                                    compute::ExecContext* exec_context) const {\n+  return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n+}\n+\n+Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+                                      compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return ExecuteScalarExpression(expr, input, &exec_context);\n+  }\n+\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\"Cannot Execute unbound expression.\");\n+  }\n+\n+  if (!expr.IsScalarExpression()) {\n+    return Status::Invalid(\n+        \"ExecuteScalarExpression cannot Execute non-scalar expression \", expr.ToString());\n+  }\n+\n+  if (auto lit = expr.literal()) return *lit;\n+\n+  if (auto ref = expr.field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum field, GetDatumField(*ref, input));\n+\n+    if (field.descr() != expr.descr()) {\n+      // Refernced field was present but didn't have the expected type.\n+      // Should we just error here? For now, pay dispatch cost and just cast.\n+      ARROW_ASSIGN_OR_RAISE(\n+          field, compute::Cast(field, expr.descr().type, compute::CastOptions::Safe(),\n+                               exec_context));\n+    }\n+\n+    return field;\n+  }\n+\n+  auto call = CallNotNull(expr);\n+\n+  std::vector<Datum> arguments(call->arguments.size());\n+  for (size_t i = 0; i < arguments.size(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(\n+        arguments[i], ExecuteScalarExpression(call->arguments[i], input, exec_context));\n+  }\n+\n+  auto executor = compute::detail::KernelExecutor::MakeScalar();\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  kernel_context.SetState(call->kernel_state.get());\n+\n+  auto kernel = call->kernel;\n+  auto descrs = GetDescriptors(arguments);\n+  auto options = call->options.get();\n+  RETURN_NOT_OK(executor->Init(&kernel_context, {kernel, descrs, options}));\n+\n+  auto listener = std::make_shared<compute::detail::DatumAccumulator>();\n+  RETURN_NOT_OK(executor->Execute(arguments, listener.get()));\n+  return executor->WrapResults(arguments, listener->values());\n+}\n+\n+std::array<std::pair<const Expression&, const Expression&>, 2>\n+ArgumentsAndFlippedArguments(const Expression::Call& call) {\n+  DCHECK_EQ(call.arguments.size(), 2);\n+  return {std::pair<const Expression&, const Expression&>{call.arguments[0],\n+                                                          call.arguments[1]},\n+          std::pair<const Expression&, const Expression&>{call.arguments[1],\n+                                                          call.arguments[0]}};\n+}\n+\n+template <typename BinOp, typename It,\n+          typename Out = typename std::iterator_traits<It>::value_type>\n+util::optional<Out> FoldLeft(It begin, It end, const BinOp& bin_op) {\n+  if (begin == end) return util::nullopt;\n+\n+  Out folded = std::move(*begin++);\n+  while (begin != end) {\n+    folded = bin_op(std::move(folded), std::move(*begin++));\n+  }\n+  return folded;\n+}\n+\n+util::optional<compute::NullHandling::type> GetNullHandling(\n+    const Expression::Call& call) {\n+  if (call.function && call.function->kind() == compute::Function::SCALAR) {\n+    return static_cast<const compute::ScalarKernel*>(call.kernel)->null_handling;\n+  }\n+  return util::nullopt;\n+}\n+\n+bool DefinitelyNotNull(const Expression& expr) {\n+  DCHECK(expr.IsBound());\n+\n+  if (expr.literal()) {\n+    return !expr.IsNullLiteral();\n+  }\n+\n+  if (expr.field_ref()) return false;\n+\n+  auto call = CallNotNull(expr);\n+  if (auto null_handling = GetNullHandling(*call)) {\n+    if (null_handling == compute::NullHandling::OUTPUT_NOT_NULL) {\n+      return true;\n+    }\n+    if (null_handling == compute::NullHandling::INTERSECTION) {\n+      return std::all_of(call->arguments.begin(), call->arguments.end(),\n+                         DefinitelyNotNull);\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+std::vector<FieldRef> FieldsInExpression(const Expression& expr) {\n+  if (auto lit = expr.literal()) return {};\n+\n+  if (auto ref = expr.field_ref()) {\n+    return {*ref};\n+  }\n+\n+  std::vector<FieldRef> fields;\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    auto argument_fields = FieldsInExpression(arg);\n+    std::move(argument_fields.begin(), argument_fields.end(), std::back_inserter(fields));\n+  }\n+  return fields;\n+}\n+\n+Result<Expression> FoldConstants(Expression expr) {\n+  return Modify(\n+      std::move(expr), [](Expression expr) { return expr; },\n+      [](Expression expr, ...) -> Result<Expression> {\n+        auto call = CallNotNull(expr);\n+        if (std::all_of(call->arguments.begin(), call->arguments.end(),\n+                        [](const Expression& argument) { return argument.literal(); })) {\n+          // all arguments are literal; we can evaluate this subexpression *now*\n+          static const Datum ignored_input;\n+          ARROW_ASSIGN_OR_RAISE(Datum constant,\n+                                ExecuteScalarExpression(expr, ignored_input));\n+\n+          return literal(std::move(constant));\n+        }\n+\n+        // XXX the following should probably be in a registry of passes instead\n+        // of inline\n+\n+        if (GetNullHandling(*call) == compute::NullHandling::INTERSECTION) {\n+          // kernels which always produce intersected validity can be resolved\n+          // to null *now* if any of their inputs is a null literal\n+          for (const auto& argument : call->arguments) {\n+            if (argument.IsNullLiteral()) {\n+              return argument;\n+            }\n+          }\n+        }\n+\n+        if (call->function_name == \"and_kleene\") {\n+          for (auto args : ArgumentsAndFlippedArguments(*call)) {\n+            // true and x == x\n+            if (args.first == literal(true)) return args.second;\n+\n+            // false and x == false\n+            if (args.first == literal(false)) return args.first;\n+\n+            // x and x == x\n+            if (args.first == args.second) return args.first;\n+          }\n+          return expr;\n+        }\n+\n+        if (call->function_name == \"or_kleene\") {\n+          for (auto args : ArgumentsAndFlippedArguments(*call)) {\n+            // false or x == x\n+            if (args.first == literal(false)) return args.second;\n+\n+            // true or x == true\n+            if (args.first == literal(true)) return args.first;\n+\n+            // x or x == x\n+            if (args.first == args.second) return args.first;\n+          }\n+          return expr;\n+        }\n+\n+        return expr;\n+      });\n+}\n+\n+inline std::vector<Expression> GuaranteeConjunctionMembers(\n+    const Expression& guaranteed_true_predicate) {\n+  auto guarantee = guaranteed_true_predicate.call();\n+  if (!guarantee || guarantee->function_name != \"and_kleene\") {\n+    return {guaranteed_true_predicate};\n+  }\n+  return FlattenedAssociativeChain(guaranteed_true_predicate).fringe;\n+}\n+\n+// Conjunction members which are represented in known_values are erased from\n+// conjunction_members\n+Status ExtractKnownFieldValuesImpl(\n+    std::vector<Expression>* conjunction_members,\n+    std::unordered_map<FieldRef, Datum, FieldRef::Hash>* known_values) {\n+  auto unconsumed_end =\n+      std::partition(conjunction_members->begin(), conjunction_members->end(),\n+                     [](const Expression& expr) {\n+                       // search for an equality conditions between a field and a literal\n+                       auto call = expr.call();\n+                       if (!call) return true;\n+\n+                       if (call->function_name == \"equal\") {\n+                         auto ref = call->arguments[0].field_ref();\n+                         auto lit = call->arguments[1].literal();\n+                         return !(ref && lit);\n+                       }\n+\n+                       return true;\n+                     });\n+\n+  for (auto it = unconsumed_end; it != conjunction_members->end(); ++it) {\n+    auto call = CallNotNull(*it);\n+\n+    auto ref = call->arguments[0].field_ref();\n+    auto lit = call->arguments[1].literal();\n+\n+    auto it_success = known_values->emplace(*ref, *lit);\n+    if (it_success.second) continue;\n+\n+    // A value was already known for ref; check it\n+    auto ref_lit = it_success.first;\n+    if (*lit != ref_lit->second) {\n+      return Status::Invalid(\"Conflicting guarantees: (\", ref->ToString(),\n+                             \" == \", lit->ToString(), \") vs (\", ref->ToString(),\n+                             \" == \", ref_lit->second.ToString());\n+    }\n+  }\n+\n+  conjunction_members->erase(unconsumed_end, conjunction_members->end());\n+\n+  return Status::OK();\n+}\n+\n+Result<std::unordered_map<FieldRef, Datum, FieldRef::Hash>> ExtractKnownFieldValues(\n+    const Expression& guaranteed_true_predicate) {\n+  auto conjunction_members = GuaranteeConjunctionMembers(guaranteed_true_predicate);\n+  std::unordered_map<FieldRef, Datum, FieldRef::Hash> known_values;\n+  RETURN_NOT_OK(ExtractKnownFieldValuesImpl(&conjunction_members, &known_values));\n+  return known_values;\n+}\n+\n+Result<Expression> ReplaceFieldsWithKnownValues(\n+    const std::unordered_map<FieldRef, Datum, FieldRef::Hash>& known_values,\n+    Expression expr) {\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\n+        \"ReplaceFieldsWithKnownValues called on an unbound Expression\");\n+  }\n+\n+  return Modify(\n+      std::move(expr),\n+      [&known_values](Expression expr) -> Result<Expression> {\n+        if (auto ref = expr.field_ref()) {\n+          auto it = known_values.find(*ref);\n+          if (it != known_values.end()) {\n+            ARROW_ASSIGN_OR_RAISE(Datum lit,\n+                                  compute::Cast(it->second, expr.descr().type));\n+            return literal(std::move(lit));\n+          }\n+        }\n+        return expr;\n+      },\n+      [](Expression expr, ...) { return expr; });\n+}\n+\n+inline bool IsBinaryAssociativeCommutative(const Expression::Call& call) {\n+  static std::unordered_set<std::string> binary_associative_commutative{\n+      \"and\",      \"or\",  \"and_kleene\",       \"or_kleene\",  \"xor\",\n+      \"multiply\", \"add\", \"multiply_checked\", \"add_checked\"};\n+\n+  auto it = binary_associative_commutative.find(call.function_name);\n+  return it != binary_associative_commutative.end();\n+}\n+\n+Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Canonicalize(std::move(expr), &exec_context);\n+  }\n+\n+  // If potentially reconstructing more deeply than a call's immediate arguments\n+  // (for example, when reorganizing an associative chain), add expressions to this set to\n+  // avoid unnecessary work\n+  struct {\n+    std::unordered_set<Expression, Expression::Hash> set_;\n+\n+    bool operator()(const Expression& expr) const {\n+      return set_.find(expr) != set_.end();\n+    }\n+\n+    void Add(std::vector<Expression> exprs) {\n+      std::move(exprs.begin(), exprs.end(), std::inserter(set_, set_.end()));\n+    }\n+  } AlreadyCanonicalized;\n+\n+  return Modify(\n+      std::move(expr),\n+      [&AlreadyCanonicalized, exec_context](Expression expr) -> Result<Expression> {\n+        auto call = expr.call();\n+        if (!call) return expr;\n+\n+        if (AlreadyCanonicalized(expr)) return expr;\n\nReview comment:\n       Note that Expression hash function is O(nodes) and you're calling it at each level... I think memoizing the hash value inside the Expression may be a good idea.\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n+    return Expression{Parameter{*ref, std::move(descr)}};\n+  }\n+\n+  auto bound_call = *CallNotNull(*this);\n+\n+  ARROW_ASSIGN_OR_RAISE(bound_call.function, GetFunction(bound_call, exec_context));\n+\n+  for (auto&& argument : bound_call.arguments) {\n+    ARROW_ASSIGN_OR_RAISE(argument, argument.Bind(in, exec_context));\n+  }\n+  RETURN_NOT_OK(InsertImplicitCasts(&bound_call));\n+\n+  auto descrs = GetDescriptors(bound_call.arguments);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel, bound_call.function->DispatchExact(descrs));\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel_state,\n+                        InitKernelState(bound_call, exec_context));\n+  kernel_context.SetState(bound_call.kernel_state.get());\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      bound_call.descr,\n+      bound_call.kernel->signature->out_type().Resolve(&kernel_context, descrs));\n+\n+  return Expression(std::move(bound_call));\n+}\n+\n+Result<Expression> Expression::Bind(const Schema& in_schema,\n+                                    compute::ExecContext* exec_context) const {\n+  return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n+}\n+\n+Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+                                      compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return ExecuteScalarExpression(expr, input, &exec_context);\n+  }\n+\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\"Cannot Execute unbound expression.\");\n+  }\n+\n+  if (!expr.IsScalarExpression()) {\n+    return Status::Invalid(\n+        \"ExecuteScalarExpression cannot Execute non-scalar expression \", expr.ToString());\n+  }\n+\n+  if (auto lit = expr.literal()) return *lit;\n+\n+  if (auto ref = expr.field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum field, GetDatumField(*ref, input));\n+\n+    if (field.descr() != expr.descr()) {\n+      // Refernced field was present but didn't have the expected type.\n+      // Should we just error here? For now, pay dispatch cost and just cast.\n+      ARROW_ASSIGN_OR_RAISE(\n+          field, compute::Cast(field, expr.descr().type, compute::CastOptions::Safe(),\n+                               exec_context));\n+    }\n+\n+    return field;\n+  }\n+\n+  auto call = CallNotNull(expr);\n+\n+  std::vector<Datum> arguments(call->arguments.size());\n+  for (size_t i = 0; i < arguments.size(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(\n+        arguments[i], ExecuteScalarExpression(call->arguments[i], input, exec_context));\n+  }\n+\n+  auto executor = compute::detail::KernelExecutor::MakeScalar();\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  kernel_context.SetState(call->kernel_state.get());\n+\n+  auto kernel = call->kernel;\n+  auto descrs = GetDescriptors(arguments);\n+  auto options = call->options.get();\n+  RETURN_NOT_OK(executor->Init(&kernel_context, {kernel, descrs, options}));\n+\n+  auto listener = std::make_shared<compute::detail::DatumAccumulator>();\n+  RETURN_NOT_OK(executor->Execute(arguments, listener.get()));\n+  return executor->WrapResults(arguments, listener->values());\n+}\n+\n+std::array<std::pair<const Expression&, const Expression&>, 2>\n+ArgumentsAndFlippedArguments(const Expression::Call& call) {\n+  DCHECK_EQ(call.arguments.size(), 2);\n+  return {std::pair<const Expression&, const Expression&>{call.arguments[0],\n+                                                          call.arguments[1]},\n+          std::pair<const Expression&, const Expression&>{call.arguments[1],\n+                                                          call.arguments[0]}};\n+}\n+\n+template <typename BinOp, typename It,\n+          typename Out = typename std::iterator_traits<It>::value_type>\n+util::optional<Out> FoldLeft(It begin, It end, const BinOp& bin_op) {\n+  if (begin == end) return util::nullopt;\n+\n+  Out folded = std::move(*begin++);\n+  while (begin != end) {\n+    folded = bin_op(std::move(folded), std::move(*begin++));\n+  }\n+  return folded;\n+}\n+\n+util::optional<compute::NullHandling::type> GetNullHandling(\n+    const Expression::Call& call) {\n+  if (call.function && call.function->kind() == compute::Function::SCALAR) {\n+    return static_cast<const compute::ScalarKernel*>(call.kernel)->null_handling;\n+  }\n+  return util::nullopt;\n+}\n+\n+bool DefinitelyNotNull(const Expression& expr) {\n+  DCHECK(expr.IsBound());\n+\n+  if (expr.literal()) {\n+    return !expr.IsNullLiteral();\n+  }\n+\n+  if (expr.field_ref()) return false;\n+\n+  auto call = CallNotNull(expr);\n+  if (auto null_handling = GetNullHandling(*call)) {\n+    if (null_handling == compute::NullHandling::OUTPUT_NOT_NULL) {\n+      return true;\n+    }\n+    if (null_handling == compute::NullHandling::INTERSECTION) {\n+      return std::all_of(call->arguments.begin(), call->arguments.end(),\n+                         DefinitelyNotNull);\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+std::vector<FieldRef> FieldsInExpression(const Expression& expr) {\n+  if (auto lit = expr.literal()) return {};\n+\n+  if (auto ref = expr.field_ref()) {\n+    return {*ref};\n+  }\n+\n+  std::vector<FieldRef> fields;\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    auto argument_fields = FieldsInExpression(arg);\n+    std::move(argument_fields.begin(), argument_fields.end(), std::back_inserter(fields));\n+  }\n+  return fields;\n+}\n+\n+Result<Expression> FoldConstants(Expression expr) {\n+  return Modify(\n+      std::move(expr), [](Expression expr) { return expr; },\n+      [](Expression expr, ...) -> Result<Expression> {\n+        auto call = CallNotNull(expr);\n+        if (std::all_of(call->arguments.begin(), call->arguments.end(),\n+                        [](const Expression& argument) { return argument.literal(); })) {\n+          // all arguments are literal; we can evaluate this subexpression *now*\n+          static const Datum ignored_input;\n+          ARROW_ASSIGN_OR_RAISE(Datum constant,\n+                                ExecuteScalarExpression(expr, ignored_input));\n+\n+          return literal(std::move(constant));\n+        }\n+\n+        // XXX the following should probably be in a registry of passes instead\n+        // of inline\n+\n+        if (GetNullHandling(*call) == compute::NullHandling::INTERSECTION) {\n+          // kernels which always produce intersected validity can be resolved\n+          // to null *now* if any of their inputs is a null literal\n+          for (const auto& argument : call->arguments) {\n+            if (argument.IsNullLiteral()) {\n+              return argument;\n+            }\n+          }\n+        }\n+\n+        if (call->function_name == \"and_kleene\") {\n+          for (auto args : ArgumentsAndFlippedArguments(*call)) {\n+            // true and x == x\n+            if (args.first == literal(true)) return args.second;\n+\n+            // false and x == false\n+            if (args.first == literal(false)) return args.first;\n+\n+            // x and x == x\n+            if (args.first == args.second) return args.first;\n+          }\n+          return expr;\n+        }\n+\n+        if (call->function_name == \"or_kleene\") {\n+          for (auto args : ArgumentsAndFlippedArguments(*call)) {\n+            // false or x == x\n+            if (args.first == literal(false)) return args.second;\n+\n+            // true or x == true\n+            if (args.first == literal(true)) return args.first;\n+\n+            // x or x == x\n+            if (args.first == args.second) return args.first;\n+          }\n+          return expr;\n+        }\n+\n+        return expr;\n+      });\n+}\n+\n+inline std::vector<Expression> GuaranteeConjunctionMembers(\n+    const Expression& guaranteed_true_predicate) {\n+  auto guarantee = guaranteed_true_predicate.call();\n+  if (!guarantee || guarantee->function_name != \"and_kleene\") {\n+    return {guaranteed_true_predicate};\n+  }\n+  return FlattenedAssociativeChain(guaranteed_true_predicate).fringe;\n+}\n+\n+// Conjunction members which are represented in known_values are erased from\n+// conjunction_members\n+Status ExtractKnownFieldValuesImpl(\n+    std::vector<Expression>* conjunction_members,\n+    std::unordered_map<FieldRef, Datum, FieldRef::Hash>* known_values) {\n+  auto unconsumed_end =\n+      std::partition(conjunction_members->begin(), conjunction_members->end(),\n+                     [](const Expression& expr) {\n+                       // search for an equality conditions between a field and a literal\n+                       auto call = expr.call();\n+                       if (!call) return true;\n+\n+                       if (call->function_name == \"equal\") {\n+                         auto ref = call->arguments[0].field_ref();\n+                         auto lit = call->arguments[1].literal();\n+                         return !(ref && lit);\n+                       }\n+\n+                       return true;\n+                     });\n+\n+  for (auto it = unconsumed_end; it != conjunction_members->end(); ++it) {\n+    auto call = CallNotNull(*it);\n+\n+    auto ref = call->arguments[0].field_ref();\n+    auto lit = call->arguments[1].literal();\n+\n+    auto it_success = known_values->emplace(*ref, *lit);\n+    if (it_success.second) continue;\n+\n+    // A value was already known for ref; check it\n+    auto ref_lit = it_success.first;\n+    if (*lit != ref_lit->second) {\n+      return Status::Invalid(\"Conflicting guarantees: (\", ref->ToString(),\n+                             \" == \", lit->ToString(), \") vs (\", ref->ToString(),\n+                             \" == \", ref_lit->second.ToString());\n+    }\n+  }\n+\n+  conjunction_members->erase(unconsumed_end, conjunction_members->end());\n+\n+  return Status::OK();\n+}\n+\n+Result<std::unordered_map<FieldRef, Datum, FieldRef::Hash>> ExtractKnownFieldValues(\n+    const Expression& guaranteed_true_predicate) {\n+  auto conjunction_members = GuaranteeConjunctionMembers(guaranteed_true_predicate);\n+  std::unordered_map<FieldRef, Datum, FieldRef::Hash> known_values;\n+  RETURN_NOT_OK(ExtractKnownFieldValuesImpl(&conjunction_members, &known_values));\n+  return known_values;\n+}\n+\n+Result<Expression> ReplaceFieldsWithKnownValues(\n+    const std::unordered_map<FieldRef, Datum, FieldRef::Hash>& known_values,\n+    Expression expr) {\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\n+        \"ReplaceFieldsWithKnownValues called on an unbound Expression\");\n+  }\n+\n+  return Modify(\n+      std::move(expr),\n+      [&known_values](Expression expr) -> Result<Expression> {\n+        if (auto ref = expr.field_ref()) {\n+          auto it = known_values.find(*ref);\n+          if (it != known_values.end()) {\n+            ARROW_ASSIGN_OR_RAISE(Datum lit,\n+                                  compute::Cast(it->second, expr.descr().type));\n+            return literal(std::move(lit));\n+          }\n+        }\n+        return expr;\n+      },\n+      [](Expression expr, ...) { return expr; });\n+}\n+\n+inline bool IsBinaryAssociativeCommutative(const Expression::Call& call) {\n+  static std::unordered_set<std::string> binary_associative_commutative{\n+      \"and\",      \"or\",  \"and_kleene\",       \"or_kleene\",  \"xor\",\n+      \"multiply\", \"add\", \"multiply_checked\", \"add_checked\"};\n+\n+  auto it = binary_associative_commutative.find(call.function_name);\n+  return it != binary_associative_commutative.end();\n+}\n+\n+Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Canonicalize(std::move(expr), &exec_context);\n+  }\n+\n+  // If potentially reconstructing more deeply than a call's immediate arguments\n+  // (for example, when reorganizing an associative chain), add expressions to this set to\n+  // avoid unnecessary work\n+  struct {\n+    std::unordered_set<Expression, Expression::Hash> set_;\n+\n+    bool operator()(const Expression& expr) const {\n+      return set_.find(expr) != set_.end();\n+    }\n+\n+    void Add(std::vector<Expression> exprs) {\n+      std::move(exprs.begin(), exprs.end(), std::inserter(set_, set_.end()));\n+    }\n+  } AlreadyCanonicalized;\n+\n+  return Modify(\n+      std::move(expr),\n+      [&AlreadyCanonicalized, exec_context](Expression expr) -> Result<Expression> {\n+        auto call = expr.call();\n+        if (!call) return expr;\n+\n+        if (AlreadyCanonicalized(expr)) return expr;\n+\n+        if (IsBinaryAssociativeCommutative(*call)) {\n+          struct {\n+            int Priority(const Expression& operand) const {\n+              // order literals first, starting with nulls\n+              if (operand.IsNullLiteral()) return 0;\n+              if (operand.literal()) return 1;\n+              return 2;\n+            }\n+            bool operator()(const Expression& l, const Expression& r) const {\n+              return Priority(l) < Priority(r);\n+            }\n+          } CanonicalOrdering;\n+\n+          FlattenedAssociativeChain chain(expr);\n+          if (chain.was_left_folded &&\n+              std::is_sorted(chain.fringe.begin(), chain.fringe.end(),\n+                             CanonicalOrdering)) {\n+            AlreadyCanonicalized.Add(std::move(chain.exprs));\n+            return expr;\n+          }\n+\n+          std::stable_sort(chain.fringe.begin(), chain.fringe.end(), CanonicalOrdering);\n+\n+          // fold the chain back up\n+          auto folded =\n+              FoldLeft(chain.fringe.begin(), chain.fringe.end(),\n+                       [call, &AlreadyCanonicalized](Expression l, Expression r) {\n+                         auto canonicalized_call = *call;\n+                         canonicalized_call.arguments = {std::move(l), std::move(r)};\n+                         Expression expr(std::move(canonicalized_call));\n+                         AlreadyCanonicalized.Add({expr});\n+                         return expr;\n+                       });\n+          return std::move(*folded);\n+        }\n+\n+        if (auto cmp = Comparison::Get(call->function_name)) {\n+          if (call->arguments[0].literal() && !call->arguments[1].literal()) {\n+            // ensure that literals are on comparisons' RHS\n+            auto flipped_call = *call;\n+            flipped_call.function_name =\n+                Comparison::GetName(Comparison::GetFlipped(*cmp));\n+            // look up the flipped kernel\n+            // TODO extract a helper for use here and in Bind\n+            ARROW_ASSIGN_OR_RAISE(\n+                auto function,\n+                exec_context->func_registry()->GetFunction(flipped_call.function_name));\n+\n+            auto descrs = GetDescriptors(flipped_call.arguments);\n+            ARROW_ASSIGN_OR_RAISE(flipped_call.kernel, function->DispatchExact(descrs));\n+\n+            std::swap(flipped_call.arguments[0], flipped_call.arguments[1]);\n+            return Expression(std::move(flipped_call));\n+          }\n+        }\n+\n+        return expr;\n+      },\n+      [](Expression expr, ...) { return expr; });\n+}\n+\n+Result<Expression> DirectComparisonSimplification(Expression expr,\n+                                                  const Expression::Call& guarantee) {\n+  return Modify(\n+      std::move(expr), [](Expression expr) { return expr; },\n+      [&guarantee](Expression expr, ...) -> Result<Expression> {\n+        auto call = expr.call();\n+        if (!call) return expr;\n+\n+        // Ensure both calls are comparisons with equal LHS and scalar RHS\n+        auto cmp = Comparison::Get(expr);\n+        auto cmp_guarantee = Comparison::Get(guarantee.function_name);\n+        if (!cmp || !cmp_guarantee) return expr;\n+\n+        if (call->arguments[0] != guarantee.arguments[0]) return expr;\n+\n+        auto rhs = call->arguments[1].literal();\n+        auto guarantee_rhs = guarantee.arguments[1].literal();\n+        if (!rhs || !guarantee_rhs) return expr;\n+\n+        if (!rhs->is_scalar() || !guarantee_rhs->is_scalar()) {\n+          return expr;\n+        }\n+\n+        ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_guarantee_rhs,\n+                              Comparison::Execute(*rhs, *guarantee_rhs));\n+        DCHECK_NE(cmp_rhs_guarantee_rhs, Comparison::NA);\n+\n+        if (cmp_rhs_guarantee_rhs == Comparison::EQUAL) {\n+          // RHS of filter is equal to RHS of guarantee\n+\n+          if ((*cmp_guarantee & *cmp) == *cmp_guarantee) {\n+            // guarantee is a subset of filter, so all data will be included\n+            return literal(true);\n+          }\n+\n+          if ((*cmp_guarantee & *cmp) == 0) {\n+            // guarantee disjoint with filter, so all data will be excluded\n+            return literal(false);\n+          }\n+\n+          return expr;\n+        }\n+\n+        if (*cmp_guarantee & cmp_rhs_guarantee_rhs) {\n+          // unusable guarantee\n\nReview comment:\n       Give an example?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n+    return Expression{Parameter{*ref, std::move(descr)}};\n+  }\n+\n+  auto bound_call = *CallNotNull(*this);\n+\n+  ARROW_ASSIGN_OR_RAISE(bound_call.function, GetFunction(bound_call, exec_context));\n+\n+  for (auto&& argument : bound_call.arguments) {\n+    ARROW_ASSIGN_OR_RAISE(argument, argument.Bind(in, exec_context));\n+  }\n+  RETURN_NOT_OK(InsertImplicitCasts(&bound_call));\n+\n+  auto descrs = GetDescriptors(bound_call.arguments);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel, bound_call.function->DispatchExact(descrs));\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel_state,\n+                        InitKernelState(bound_call, exec_context));\n+  kernel_context.SetState(bound_call.kernel_state.get());\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      bound_call.descr,\n+      bound_call.kernel->signature->out_type().Resolve(&kernel_context, descrs));\n+\n+  return Expression(std::move(bound_call));\n+}\n+\n+Result<Expression> Expression::Bind(const Schema& in_schema,\n+                                    compute::ExecContext* exec_context) const {\n+  return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n+}\n+\n+Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+                                      compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return ExecuteScalarExpression(expr, input, &exec_context);\n+  }\n+\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\"Cannot Execute unbound expression.\");\n+  }\n+\n+  if (!expr.IsScalarExpression()) {\n+    return Status::Invalid(\n+        \"ExecuteScalarExpression cannot Execute non-scalar expression \", expr.ToString());\n+  }\n+\n+  if (auto lit = expr.literal()) return *lit;\n+\n+  if (auto ref = expr.field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum field, GetDatumField(*ref, input));\n+\n+    if (field.descr() != expr.descr()) {\n+      // Refernced field was present but didn't have the expected type.\n+      // Should we just error here? For now, pay dispatch cost and just cast.\n+      ARROW_ASSIGN_OR_RAISE(\n+          field, compute::Cast(field, expr.descr().type, compute::CastOptions::Safe(),\n+                               exec_context));\n+    }\n+\n+    return field;\n+  }\n+\n+  auto call = CallNotNull(expr);\n+\n+  std::vector<Datum> arguments(call->arguments.size());\n+  for (size_t i = 0; i < arguments.size(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(\n+        arguments[i], ExecuteScalarExpression(call->arguments[i], input, exec_context));\n+  }\n+\n+  auto executor = compute::detail::KernelExecutor::MakeScalar();\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  kernel_context.SetState(call->kernel_state.get());\n+\n+  auto kernel = call->kernel;\n+  auto descrs = GetDescriptors(arguments);\n+  auto options = call->options.get();\n+  RETURN_NOT_OK(executor->Init(&kernel_context, {kernel, descrs, options}));\n+\n+  auto listener = std::make_shared<compute::detail::DatumAccumulator>();\n+  RETURN_NOT_OK(executor->Execute(arguments, listener.get()));\n+  return executor->WrapResults(arguments, listener->values());\n+}\n+\n+std::array<std::pair<const Expression&, const Expression&>, 2>\n+ArgumentsAndFlippedArguments(const Expression::Call& call) {\n+  DCHECK_EQ(call.arguments.size(), 2);\n+  return {std::pair<const Expression&, const Expression&>{call.arguments[0],\n+                                                          call.arguments[1]},\n+          std::pair<const Expression&, const Expression&>{call.arguments[1],\n+                                                          call.arguments[0]}};\n+}\n+\n+template <typename BinOp, typename It,\n+          typename Out = typename std::iterator_traits<It>::value_type>\n+util::optional<Out> FoldLeft(It begin, It end, const BinOp& bin_op) {\n+  if (begin == end) return util::nullopt;\n+\n+  Out folded = std::move(*begin++);\n+  while (begin != end) {\n+    folded = bin_op(std::move(folded), std::move(*begin++));\n+  }\n+  return folded;\n+}\n+\n+util::optional<compute::NullHandling::type> GetNullHandling(\n+    const Expression::Call& call) {\n+  if (call.function && call.function->kind() == compute::Function::SCALAR) {\n+    return static_cast<const compute::ScalarKernel*>(call.kernel)->null_handling;\n+  }\n+  return util::nullopt;\n+}\n+\n+bool DefinitelyNotNull(const Expression& expr) {\n+  DCHECK(expr.IsBound());\n+\n+  if (expr.literal()) {\n+    return !expr.IsNullLiteral();\n+  }\n+\n+  if (expr.field_ref()) return false;\n+\n+  auto call = CallNotNull(expr);\n+  if (auto null_handling = GetNullHandling(*call)) {\n+    if (null_handling == compute::NullHandling::OUTPUT_NOT_NULL) {\n+      return true;\n+    }\n+    if (null_handling == compute::NullHandling::INTERSECTION) {\n+      return std::all_of(call->arguments.begin(), call->arguments.end(),\n+                         DefinitelyNotNull);\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+std::vector<FieldRef> FieldsInExpression(const Expression& expr) {\n+  if (auto lit = expr.literal()) return {};\n+\n+  if (auto ref = expr.field_ref()) {\n+    return {*ref};\n+  }\n+\n+  std::vector<FieldRef> fields;\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    auto argument_fields = FieldsInExpression(arg);\n+    std::move(argument_fields.begin(), argument_fields.end(), std::back_inserter(fields));\n+  }\n+  return fields;\n+}\n+\n+Result<Expression> FoldConstants(Expression expr) {\n+  return Modify(\n+      std::move(expr), [](Expression expr) { return expr; },\n+      [](Expression expr, ...) -> Result<Expression> {\n+        auto call = CallNotNull(expr);\n+        if (std::all_of(call->arguments.begin(), call->arguments.end(),\n+                        [](const Expression& argument) { return argument.literal(); })) {\n+          // all arguments are literal; we can evaluate this subexpression *now*\n+          static const Datum ignored_input;\n+          ARROW_ASSIGN_OR_RAISE(Datum constant,\n+                                ExecuteScalarExpression(expr, ignored_input));\n+\n+          return literal(std::move(constant));\n+        }\n+\n+        // XXX the following should probably be in a registry of passes instead\n+        // of inline\n+\n+        if (GetNullHandling(*call) == compute::NullHandling::INTERSECTION) {\n+          // kernels which always produce intersected validity can be resolved\n+          // to null *now* if any of their inputs is a null literal\n+          for (const auto& argument : call->arguments) {\n+            if (argument.IsNullLiteral()) {\n+              return argument;\n+            }\n+          }\n+        }\n+\n+        if (call->function_name == \"and_kleene\") {\n+          for (auto args : ArgumentsAndFlippedArguments(*call)) {\n+            // true and x == x\n+            if (args.first == literal(true)) return args.second;\n+\n+            // false and x == false\n+            if (args.first == literal(false)) return args.first;\n+\n+            // x and x == x\n+            if (args.first == args.second) return args.first;\n+          }\n+          return expr;\n+        }\n+\n+        if (call->function_name == \"or_kleene\") {\n+          for (auto args : ArgumentsAndFlippedArguments(*call)) {\n+            // false or x == x\n+            if (args.first == literal(false)) return args.second;\n+\n+            // true or x == true\n+            if (args.first == literal(true)) return args.first;\n+\n+            // x or x == x\n+            if (args.first == args.second) return args.first;\n+          }\n+          return expr;\n+        }\n+\n+        return expr;\n+      });\n+}\n+\n+inline std::vector<Expression> GuaranteeConjunctionMembers(\n+    const Expression& guaranteed_true_predicate) {\n+  auto guarantee = guaranteed_true_predicate.call();\n+  if (!guarantee || guarantee->function_name != \"and_kleene\") {\n+    return {guaranteed_true_predicate};\n+  }\n+  return FlattenedAssociativeChain(guaranteed_true_predicate).fringe;\n+}\n+\n+// Conjunction members which are represented in known_values are erased from\n+// conjunction_members\n+Status ExtractKnownFieldValuesImpl(\n+    std::vector<Expression>* conjunction_members,\n+    std::unordered_map<FieldRef, Datum, FieldRef::Hash>* known_values) {\n+  auto unconsumed_end =\n+      std::partition(conjunction_members->begin(), conjunction_members->end(),\n+                     [](const Expression& expr) {\n+                       // search for an equality conditions between a field and a literal\n+                       auto call = expr.call();\n+                       if (!call) return true;\n+\n+                       if (call->function_name == \"equal\") {\n+                         auto ref = call->arguments[0].field_ref();\n+                         auto lit = call->arguments[1].literal();\n+                         return !(ref && lit);\n+                       }\n+\n+                       return true;\n+                     });\n+\n+  for (auto it = unconsumed_end; it != conjunction_members->end(); ++it) {\n+    auto call = CallNotNull(*it);\n+\n+    auto ref = call->arguments[0].field_ref();\n+    auto lit = call->arguments[1].literal();\n+\n+    auto it_success = known_values->emplace(*ref, *lit);\n+    if (it_success.second) continue;\n+\n+    // A value was already known for ref; check it\n+    auto ref_lit = it_success.first;\n+    if (*lit != ref_lit->second) {\n+      return Status::Invalid(\"Conflicting guarantees: (\", ref->ToString(),\n+                             \" == \", lit->ToString(), \") vs (\", ref->ToString(),\n+                             \" == \", ref_lit->second.ToString());\n+    }\n+  }\n+\n+  conjunction_members->erase(unconsumed_end, conjunction_members->end());\n+\n+  return Status::OK();\n+}\n+\n+Result<std::unordered_map<FieldRef, Datum, FieldRef::Hash>> ExtractKnownFieldValues(\n+    const Expression& guaranteed_true_predicate) {\n+  auto conjunction_members = GuaranteeConjunctionMembers(guaranteed_true_predicate);\n+  std::unordered_map<FieldRef, Datum, FieldRef::Hash> known_values;\n+  RETURN_NOT_OK(ExtractKnownFieldValuesImpl(&conjunction_members, &known_values));\n+  return known_values;\n+}\n+\n+Result<Expression> ReplaceFieldsWithKnownValues(\n+    const std::unordered_map<FieldRef, Datum, FieldRef::Hash>& known_values,\n+    Expression expr) {\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\n+        \"ReplaceFieldsWithKnownValues called on an unbound Expression\");\n+  }\n+\n+  return Modify(\n+      std::move(expr),\n+      [&known_values](Expression expr) -> Result<Expression> {\n+        if (auto ref = expr.field_ref()) {\n+          auto it = known_values.find(*ref);\n+          if (it != known_values.end()) {\n+            ARROW_ASSIGN_OR_RAISE(Datum lit,\n+                                  compute::Cast(it->second, expr.descr().type));\n+            return literal(std::move(lit));\n+          }\n+        }\n+        return expr;\n+      },\n+      [](Expression expr, ...) { return expr; });\n+}\n+\n+inline bool IsBinaryAssociativeCommutative(const Expression::Call& call) {\n+  static std::unordered_set<std::string> binary_associative_commutative{\n+      \"and\",      \"or\",  \"and_kleene\",       \"or_kleene\",  \"xor\",\n+      \"multiply\", \"add\", \"multiply_checked\", \"add_checked\"};\n+\n+  auto it = binary_associative_commutative.find(call.function_name);\n+  return it != binary_associative_commutative.end();\n+}\n+\n+Result<Expression> Canonicalize(Expression expr, compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Canonicalize(std::move(expr), &exec_context);\n+  }\n+\n+  // If potentially reconstructing more deeply than a call's immediate arguments\n+  // (for example, when reorganizing an associative chain), add expressions to this set to\n+  // avoid unnecessary work\n+  struct {\n+    std::unordered_set<Expression, Expression::Hash> set_;\n+\n+    bool operator()(const Expression& expr) const {\n+      return set_.find(expr) != set_.end();\n+    }\n+\n+    void Add(std::vector<Expression> exprs) {\n+      std::move(exprs.begin(), exprs.end(), std::inserter(set_, set_.end()));\n+    }\n+  } AlreadyCanonicalized;\n+\n+  return Modify(\n+      std::move(expr),\n+      [&AlreadyCanonicalized, exec_context](Expression expr) -> Result<Expression> {\n+        auto call = expr.call();\n+        if (!call) return expr;\n+\n+        if (AlreadyCanonicalized(expr)) return expr;\n+\n+        if (IsBinaryAssociativeCommutative(*call)) {\n+          struct {\n+            int Priority(const Expression& operand) const {\n+              // order literals first, starting with nulls\n+              if (operand.IsNullLiteral()) return 0;\n+              if (operand.literal()) return 1;\n+              return 2;\n+            }\n+            bool operator()(const Expression& l, const Expression& r) const {\n+              return Priority(l) < Priority(r);\n+            }\n+          } CanonicalOrdering;\n+\n+          FlattenedAssociativeChain chain(expr);\n+          if (chain.was_left_folded &&\n+              std::is_sorted(chain.fringe.begin(), chain.fringe.end(),\n+                             CanonicalOrdering)) {\n+            AlreadyCanonicalized.Add(std::move(chain.exprs));\n+            return expr;\n+          }\n+\n+          std::stable_sort(chain.fringe.begin(), chain.fringe.end(), CanonicalOrdering);\n+\n+          // fold the chain back up\n+          auto folded =\n+              FoldLeft(chain.fringe.begin(), chain.fringe.end(),\n+                       [call, &AlreadyCanonicalized](Expression l, Expression r) {\n+                         auto canonicalized_call = *call;\n+                         canonicalized_call.arguments = {std::move(l), std::move(r)};\n+                         Expression expr(std::move(canonicalized_call));\n+                         AlreadyCanonicalized.Add({expr});\n+                         return expr;\n+                       });\n+          return std::move(*folded);\n+        }\n+\n+        if (auto cmp = Comparison::Get(call->function_name)) {\n+          if (call->arguments[0].literal() && !call->arguments[1].literal()) {\n+            // ensure that literals are on comparisons' RHS\n+            auto flipped_call = *call;\n+            flipped_call.function_name =\n+                Comparison::GetName(Comparison::GetFlipped(*cmp));\n+            // look up the flipped kernel\n+            // TODO extract a helper for use here and in Bind\n+            ARROW_ASSIGN_OR_RAISE(\n+                auto function,\n+                exec_context->func_registry()->GetFunction(flipped_call.function_name));\n+\n+            auto descrs = GetDescriptors(flipped_call.arguments);\n+            ARROW_ASSIGN_OR_RAISE(flipped_call.kernel, function->DispatchExact(descrs));\n+\n+            std::swap(flipped_call.arguments[0], flipped_call.arguments[1]);\n+            return Expression(std::move(flipped_call));\n+          }\n+        }\n+\n+        return expr;\n+      },\n+      [](Expression expr, ...) { return expr; });\n+}\n+\n+Result<Expression> DirectComparisonSimplification(Expression expr,\n+                                                  const Expression::Call& guarantee) {\n+  return Modify(\n+      std::move(expr), [](Expression expr) { return expr; },\n+      [&guarantee](Expression expr, ...) -> Result<Expression> {\n+        auto call = expr.call();\n+        if (!call) return expr;\n+\n+        // Ensure both calls are comparisons with equal LHS and scalar RHS\n+        auto cmp = Comparison::Get(expr);\n+        auto cmp_guarantee = Comparison::Get(guarantee.function_name);\n+        if (!cmp || !cmp_guarantee) return expr;\n+\n+        if (call->arguments[0] != guarantee.arguments[0]) return expr;\n+\n+        auto rhs = call->arguments[1].literal();\n+        auto guarantee_rhs = guarantee.arguments[1].literal();\n+        if (!rhs || !guarantee_rhs) return expr;\n+\n+        if (!rhs->is_scalar() || !guarantee_rhs->is_scalar()) {\n+          return expr;\n+        }\n+\n+        ARROW_ASSIGN_OR_RAISE(auto cmp_rhs_guarantee_rhs,\n+                              Comparison::Execute(*rhs, *guarantee_rhs));\n+        DCHECK_NE(cmp_rhs_guarantee_rhs, Comparison::NA);\n+\n+        if (cmp_rhs_guarantee_rhs == Comparison::EQUAL) {\n+          // RHS of filter is equal to RHS of guarantee\n+\n+          if ((*cmp_guarantee & *cmp) == *cmp_guarantee) {\n+            // guarantee is a subset of filter, so all data will be included\n+            return literal(true);\n+          }\n+\n+          if ((*cmp_guarantee & *cmp) == 0) {\n+            // guarantee disjoint with filter, so all data will be excluded\n+            return literal(false);\n+          }\n+\n+          return expr;\n+        }\n+\n+        if (*cmp_guarantee & cmp_rhs_guarantee_rhs) {\n+          // unusable guarantee\n+          return expr;\n+        }\n+\n+        if (*cmp & Comparison::GetFlipped(cmp_rhs_guarantee_rhs)) {\n+          // x > 1, x >= 1, x != 1 guaranteed by x >= 3\n+          return literal(true);\n+        } else {\n+          // x < 1, x <= 1, x == 1 unsatisfiable if x >= 3\n+          return literal(false);\n+        }\n+      });\n+}\n+\n+Result<Expression> SimplifyWithGuarantee(Expression expr,\n+                                         const Expression& guaranteed_true_predicate) {\n+  auto conjunction_members = GuaranteeConjunctionMembers(guaranteed_true_predicate);\n+\n+  std::unordered_map<FieldRef, Datum, FieldRef::Hash> known_values;\n+  RETURN_NOT_OK(ExtractKnownFieldValuesImpl(&conjunction_members, &known_values));\n+\n+  ARROW_ASSIGN_OR_RAISE(expr,\n+                        ReplaceFieldsWithKnownValues(known_values, std::move(expr)));\n\nReview comment:\n       Is this useful, given that `DirectComparisonSimplification` should catch these cases as well?\n\n##########\nFile path: cpp/src/arrow/dataset/expression.cc\n##########\n@@ -0,0 +1,1177 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+\n+#include \"arrow/chunked_array.h\"\n+#include \"arrow/compute/exec_internal.h\"\n+#include \"arrow/dataset/expression_internal.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/ipc/writer.h\"\n+#include \"arrow/util/key_value_metadata.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/optional.h\"\n+#include \"arrow/util/string.h\"\n+#include \"arrow/util/value_parsing.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+namespace dataset {\n+\n+Expression::Expression(Call call) : impl_(std::make_shared<Impl>(std::move(call))) {}\n+\n+Expression::Expression(Datum literal)\n+    : impl_(std::make_shared<Impl>(std::move(literal))) {}\n+\n+Expression::Expression(Parameter parameter)\n+    : impl_(std::make_shared<Impl>(std::move(parameter))) {}\n+\n+Expression literal(Datum lit) { return Expression(std::move(lit)); }\n+\n+Expression field_ref(FieldRef ref) {\n+  return Expression(Expression::Parameter{std::move(ref), {}});\n+}\n+\n+Expression call(std::string function, std::vector<Expression> arguments,\n+                std::shared_ptr<compute::FunctionOptions> options) {\n+  Expression::Call call;\n+  call.function_name = std::move(function);\n+  call.arguments = std::move(arguments);\n+  call.options = std::move(options);\n+  return Expression(std::move(call));\n+}\n+\n+const Datum* Expression::literal() const { return util::get_if<Datum>(impl_.get()); }\n+\n+const FieldRef* Expression::field_ref() const {\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return &parameter->ref;\n+  }\n+  return nullptr;\n+}\n+\n+const Expression::Call* Expression::call() const {\n+  return util::get_if<Call>(impl_.get());\n+}\n+\n+ValueDescr Expression::descr() const {\n+  if (impl_ == nullptr) return {};\n+\n+  if (auto lit = literal()) {\n+    return lit->descr();\n+  }\n+\n+  if (auto parameter = util::get_if<Parameter>(impl_.get())) {\n+    return parameter->descr;\n+  }\n+\n+  return CallNotNull(*this)->descr;\n+}\n+\n+std::string Expression::ToString() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      switch (lit->type()->id()) {\n+        case Type::STRING:\n+        case Type::LARGE_STRING:\n+          return '\"' +\n+                 Escape(util::string_view(*lit->scalar_as<BaseBinaryScalar>().value)) +\n+                 '\"';\n+\n+        case Type::BINARY:\n+        case Type::FIXED_SIZE_BINARY:\n+        case Type::LARGE_BINARY:\n+          return '\"' + lit->scalar_as<BaseBinaryScalar>().value->ToHexString() + '\"';\n+\n+        default:\n+          break;\n+      }\n+      return lit->scalar()->ToString();\n+    }\n+    return lit->ToString();\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    if (auto name = ref->name()) {\n+      return *name;\n+    }\n+    if (auto path = ref->field_path()) {\n+      return path->ToString();\n+    }\n+    return ref->ToString();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto binary = [&](std::string op) {\n+    return \"(\" + call->arguments[0].ToString() + \" \" + op + \" \" +\n+           call->arguments[1].ToString() + \")\";\n+  };\n+\n+  if (auto cmp = Comparison::Get(call->function_name)) {\n+    return binary(Comparison::GetOp(*cmp));\n+  }\n+\n+  constexpr util::string_view kleene = \"_kleene\";\n+  if (util::string_view{call->function_name}.ends_with(kleene)) {\n+    auto op = call->function_name.substr(0, call->function_name.size() - kleene.size());\n+    return binary(std::move(op));\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    std::string out = \"{\";\n+    auto argument = call->arguments.begin();\n+    for (const auto& field_name : options->field_names) {\n+      out += field_name + \"=\" + argument++->ToString() + \", \";\n+    }\n+    out.resize(out.size() - 1);\n+    out.back() = '}';\n+    return out;\n+  }\n+\n+  std::string out = call->function_name + \"(\";\n+  for (const auto& arg : call->arguments) {\n+    out += arg.ToString() + \", \";\n+  }\n+\n+  if (call->options == nullptr) {\n+    out.resize(out.size() - 1);\n+    out.back() = ')';\n+    return out;\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    DCHECK_EQ(options->value_set.kind(), Datum::ARRAY);\n+    out += \"value_set=\" + options->value_set.make_array()->ToString();\n+    if (options->skip_nulls) {\n+      out += \", skip_nulls\";\n+    }\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    if (options->to_type == nullptr) {\n+      return out + \"to_type=<INVALID NOT PROVIDED>)\";\n+    }\n+    out += \"to_type=\" + options->to_type->ToString();\n+    if (options->allow_int_overflow) out += \", allow_int_overflow\";\n+    if (options->allow_time_truncate) out += \", allow_time_truncate\";\n+    if (options->allow_time_overflow) out += \", allow_time_overflow\";\n+    if (options->allow_decimal_truncate) out += \", allow_decimal_truncate\";\n+    if (options->allow_float_truncate) out += \", allow_float_truncate\";\n+    if (options->allow_invalid_utf8) out += \", allow_invalid_utf8\";\n+    return out + \")\";\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    return out + \"format=\" + options->format +\n+           \", unit=\" + internal::ToString(options->unit) + \")\";\n+  }\n+\n+  return out + \"{NON-REPRESENTABLE OPTIONS})\";\n+}\n+\n+void PrintTo(const Expression& expr, std::ostream* os) {\n+  *os << expr.ToString();\n+  if (expr.IsBound()) {\n+    *os << \"[bound]\";\n+  }\n+}\n+\n+bool Expression::Equals(const Expression& other) const {\n+  if (Identical(*this, other)) return true;\n+\n+  if (impl_->index() != other.impl_->index()) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    return lit->Equals(*other.literal());\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->Equals(*other.field_ref());\n+  }\n+\n+  auto call = CallNotNull(*this);\n+  auto other_call = CallNotNull(other);\n+\n+  if (call->function_name != other_call->function_name ||\n+      call->kernel != other_call->kernel) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < call->arguments.size(); ++i) {\n+    if (!call->arguments[i].Equals(other_call->arguments[i])) {\n+      return false;\n+    }\n+  }\n+\n+  if (call->options == other_call->options) return true;\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    auto other_options = GetSetLookupOptions(*other_call);\n+    return options->value_set == other_options->value_set &&\n+           options->skip_nulls == other_options->skip_nulls;\n+  }\n+\n+  if (auto options = GetCastOptions(*call)) {\n+    auto other_options = GetCastOptions(*other_call);\n+    for (auto safety_opt : {\n+             &compute::CastOptions::allow_int_overflow,\n+             &compute::CastOptions::allow_time_truncate,\n+             &compute::CastOptions::allow_time_overflow,\n+             &compute::CastOptions::allow_decimal_truncate,\n+             &compute::CastOptions::allow_float_truncate,\n+             &compute::CastOptions::allow_invalid_utf8,\n+         }) {\n+      if (options->*safety_opt != other_options->*safety_opt) return false;\n+    }\n+    return options->to_type->Equals(other_options->to_type);\n+  }\n+\n+  if (auto options = GetStructOptions(*call)) {\n+    auto other_options = GetStructOptions(*other_call);\n+    return options->field_names == other_options->field_names;\n+  }\n+\n+  if (auto options = GetStrptimeOptions(*call)) {\n+    auto other_options = GetStrptimeOptions(*other_call);\n+    return options->format == other_options->format &&\n+           options->unit == other_options->unit;\n+  }\n+\n+  ARROW_LOG(WARNING) << \"comparing unknown FunctionOptions for function \"\n+                     << call->function_name;\n+  return false;\n+}\n+\n+size_t Expression::hash() const {\n+  if (auto lit = literal()) {\n+    if (lit->is_scalar()) {\n+      return Scalar::Hash::hash(*lit->scalar());\n+    }\n+    return 0;\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return ref->hash();\n+  }\n+\n+  auto call = CallNotNull(*this);\n+\n+  size_t out = std::hash<std::string>{}(call->function_name);\n+  for (const auto& arg : call->arguments) {\n+    out ^= arg.hash();\n+  }\n+  return out;\n+}\n+\n+bool Expression::IsBound() const {\n+  if (descr().type == nullptr) return false;\n+\n+  if (auto lit = literal()) return true;\n+\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsBound()) return false;\n+  }\n+\n+  return call->kernel != nullptr;\n+}\n+\n+bool Expression::IsScalarExpression() const {\n+  if (auto lit = literal()) {\n+    return lit->is_scalar();\n+  }\n+\n+  // FIXME handle case where a list's item field is referenced\n+  if (auto ref = field_ref()) return true;\n+\n+  auto call = CallNotNull(*this);\n+\n+  for (const Expression& arg : call->arguments) {\n+    if (!arg.IsScalarExpression()) return false;\n+  }\n+\n+  if (call->function) {\n+    return call->function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // this expression is not bound; make a best guess based on\n+  // the default function registry\n+  if (auto function = compute::GetFunctionRegistry()\n+                          ->GetFunction(call->function_name)\n+                          .ValueOr(nullptr)) {\n+    return function->kind() == compute::Function::SCALAR;\n+  }\n+\n+  // unknown function or other error; conservatively return false\n+  return false;\n+}\n+\n+bool Expression::IsNullLiteral() const {\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool Expression::IsSatisfiable() const {\n+  if (descr().type && descr().type->id() == Type::NA) {\n+    return false;\n+  }\n+\n+  if (auto lit = literal()) {\n+    if (lit->null_count() == lit->length()) {\n+      return false;\n+    }\n+\n+    if (lit->is_scalar() && lit->type()->id() == Type::BOOL) {\n+      return lit->scalar_as<BooleanScalar>().value;\n+    }\n+  }\n+\n+  if (auto ref = field_ref()) {\n+    return true;\n+  }\n+\n+  return true;\n+}\n+\n+inline bool KernelStateIsImmutable(const std::string& function) {\n+  // XXX maybe just add Kernel::state_is_immutable or so?\n+\n+  // known functions with non-null but nevertheless immutable KernelState\n+  static std::unordered_set<std::string> names = {\n+      \"is_in\", \"index_in\", \"cast\", \"struct\", \"strptime\",\n+  };\n+\n+  return names.find(function) != names.end();\n+}\n+\n+Result<std::unique_ptr<compute::KernelState>> InitKernelState(\n+    const Expression::Call& call, compute::ExecContext* exec_context) {\n+  if (!call.kernel->init) return nullptr;\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  auto kernel_state = call.kernel->init(\n+      &kernel_context, {call.kernel, GetDescriptors(call.arguments), call.options.get()});\n+\n+  RETURN_NOT_OK(kernel_context.status());\n+  return std::move(kernel_state);\n+}\n+\n+Status MaybeInsertCast(std::shared_ptr<DataType> to_type, Expression* expr) {\n+  if (expr->descr().type->Equals(to_type)) {\n+    return Status::OK();\n+  }\n+\n+  if (auto lit = expr->literal()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum new_lit, compute::Cast(*lit, to_type));\n+    *expr = literal(std::move(new_lit));\n+    return Status::OK();\n+  }\n+\n+  // FIXME the resulting cast Call must be bound but this is a hack\n+  auto with_cast = call(\"cast\", {literal(MakeNullScalar(expr->descr().type))},\n+                        compute::CastOptions::Safe(to_type));\n+\n+  static ValueDescr ignored_descr;\n+  ARROW_ASSIGN_OR_RAISE(with_cast, with_cast.Bind(ignored_descr));\n+\n+  auto call_with_cast = *CallNotNull(with_cast);\n+  call_with_cast.arguments[0] = std::move(*expr);\n+  call_with_cast.descr = ValueDescr{std::move(to_type), expr->descr().shape};\n+\n+  *expr = Expression(std::move(call_with_cast));\n+  return Status::OK();\n+}\n+\n+Status InsertImplicitCasts(Expression::Call* call) {\n+  DCHECK(std::all_of(call->arguments.begin(), call->arguments.end(),\n+                     [](const Expression& argument) { return argument.IsBound(); }));\n+\n+  if (IsSameTypesBinary(call->function_name)) {\n+    for (auto&& argument : call->arguments) {\n+      if (auto value_type = GetDictionaryValueType(argument.descr().type)) {\n+        RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &argument));\n+      }\n+    }\n+\n+    if (call->arguments[0].descr().shape == ValueDescr::SCALAR) {\n+      // argument 0 is scalar so casting is cheap\n+      return MaybeInsertCast(call->arguments[1].descr().type, &call->arguments[0]);\n+    }\n+\n+    // cast argument 1 unconditionally\n+    return MaybeInsertCast(call->arguments[0].descr().type, &call->arguments[1]);\n+  }\n+\n+  if (auto options = GetSetLookupOptions(*call)) {\n+    if (auto value_type = GetDictionaryValueType(call->arguments[0].descr().type)) {\n+      // DICTIONARY input is not supported; decode it.\n+      RETURN_NOT_OK(MaybeInsertCast(std::move(value_type), &call->arguments[0]));\n+    }\n+\n+    if (options->value_set.type()->id() == Type::DICTIONARY) {\n+      // DICTIONARY value_set is not supported; decode it.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      RETURN_NOT_OK(EnsureNotDictionary(&new_options->value_set));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    if (!options->value_set.type()->Equals(call->arguments[0].descr().type)) {\n+      // The value_set is assumed smaller than inputs, casting it should be cheaper.\n+      auto new_options = std::make_shared<compute::SetLookupOptions>(*options);\n+      ARROW_ASSIGN_OR_RAISE(new_options->value_set,\n+                            compute::Cast(std::move(new_options->value_set),\n+                                          call->arguments[0].descr().type));\n+      options = new_options.get();\n+      call->options = std::move(new_options);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Result<Expression> Expression::Bind(ValueDescr in,\n+                                    compute::ExecContext* exec_context) const {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return Bind(std::move(in), &exec_context);\n+  }\n+\n+  if (literal()) return *this;\n+\n+  if (auto ref = field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(auto field, ref->GetOneOrNone(*in.type));\n+    auto descr = field ? ValueDescr{field->type(), in.shape} : ValueDescr::Scalar(null());\n+    return Expression{Parameter{*ref, std::move(descr)}};\n+  }\n+\n+  auto bound_call = *CallNotNull(*this);\n+\n+  ARROW_ASSIGN_OR_RAISE(bound_call.function, GetFunction(bound_call, exec_context));\n+\n+  for (auto&& argument : bound_call.arguments) {\n+    ARROW_ASSIGN_OR_RAISE(argument, argument.Bind(in, exec_context));\n+  }\n+  RETURN_NOT_OK(InsertImplicitCasts(&bound_call));\n+\n+  auto descrs = GetDescriptors(bound_call.arguments);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel, bound_call.function->DispatchExact(descrs));\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  ARROW_ASSIGN_OR_RAISE(bound_call.kernel_state,\n+                        InitKernelState(bound_call, exec_context));\n+  kernel_context.SetState(bound_call.kernel_state.get());\n+\n+  ARROW_ASSIGN_OR_RAISE(\n+      bound_call.descr,\n+      bound_call.kernel->signature->out_type().Resolve(&kernel_context, descrs));\n+\n+  return Expression(std::move(bound_call));\n+}\n+\n+Result<Expression> Expression::Bind(const Schema& in_schema,\n+                                    compute::ExecContext* exec_context) const {\n+  return Bind(ValueDescr::Array(struct_(in_schema.fields())), exec_context);\n+}\n+\n+Result<Datum> ExecuteScalarExpression(const Expression& expr, const Datum& input,\n+                                      compute::ExecContext* exec_context) {\n+  if (exec_context == nullptr) {\n+    compute::ExecContext exec_context;\n+    return ExecuteScalarExpression(expr, input, &exec_context);\n+  }\n+\n+  if (!expr.IsBound()) {\n+    return Status::Invalid(\"Cannot Execute unbound expression.\");\n+  }\n+\n+  if (!expr.IsScalarExpression()) {\n+    return Status::Invalid(\n+        \"ExecuteScalarExpression cannot Execute non-scalar expression \", expr.ToString());\n+  }\n+\n+  if (auto lit = expr.literal()) return *lit;\n+\n+  if (auto ref = expr.field_ref()) {\n+    ARROW_ASSIGN_OR_RAISE(Datum field, GetDatumField(*ref, input));\n+\n+    if (field.descr() != expr.descr()) {\n+      // Refernced field was present but didn't have the expected type.\n+      // Should we just error here? For now, pay dispatch cost and just cast.\n+      ARROW_ASSIGN_OR_RAISE(\n+          field, compute::Cast(field, expr.descr().type, compute::CastOptions::Safe(),\n+                               exec_context));\n+    }\n+\n+    return field;\n+  }\n+\n+  auto call = CallNotNull(expr);\n+\n+  std::vector<Datum> arguments(call->arguments.size());\n+  for (size_t i = 0; i < arguments.size(); ++i) {\n+    ARROW_ASSIGN_OR_RAISE(\n+        arguments[i], ExecuteScalarExpression(call->arguments[i], input, exec_context));\n+  }\n+\n+  auto executor = compute::detail::KernelExecutor::MakeScalar();\n+\n+  compute::KernelContext kernel_context(exec_context);\n+  kernel_context.SetState(call->kernel_state.get());\n+\n+  auto kernel = call->kernel;\n+  auto descrs = GetDescriptors(arguments);\n+  auto options = call->options.get();\n+  RETURN_NOT_OK(executor->Init(&kernel_context, {kernel, descrs, options}));\n+\n+  auto listener = std::make_shared<compute::detail::DatumAccumulator>();\n+  RETURN_NOT_OK(executor->Execute(arguments, listener.get()));\n+  return executor->WrapResults(arguments, listener->values());\n+}\n+\n+std::array<std::pair<const Expression&, const Expression&>, 2>\n+ArgumentsAndFlippedArguments(const Expression::Call& call) {\n+  DCHECK_EQ(call.arguments.size(), 2);\n+  return {std::pair<const Expression&, const Expression&>{call.arguments[0],\n+                                                          call.arguments[1]},\n+          std::pair<const Expression&, const Expression&>{call.arguments[1],\n+                                                          call.arguments[0]}};\n+}\n+\n+template <typename BinOp, typename It,\n+          typename Out = typename std::iterator_traits<It>::value_type>\n+util::optional<Out> FoldLeft(It begin, It end, const BinOp& bin_op) {\n+  if (begin == end) return util::nullopt;\n+\n+  Out folded = std::move(*begin++);\n+  while (begin != end) {\n+    folded = bin_op(std::move(folded), std::move(*begin++));\n+  }\n+  return folded;\n+}\n+\n+util::optional<compute::NullHandling::type> GetNullHandling(\n+    const Expression::Call& call) {\n+  if (call.function && call.function->kind() == compute::Function::SCALAR) {\n+    return static_cast<const compute::ScalarKernel*>(call.kernel)->null_handling;\n+  }\n+  return util::nullopt;\n+}\n+\n+bool DefinitelyNotNull(const Expression& expr) {\n+  DCHECK(expr.IsBound());\n+\n+  if (expr.literal()) {\n+    return !expr.IsNullLiteral();\n+  }\n+\n+  if (expr.field_ref()) return false;\n\nReview comment:\n       Hmm... what if the referenced field has `nullable == false`?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T19:38:13.154+0000",
                    "updated": "2020-12-17T19:38:13.154+0000",
                    "started": "2020-12-17T19:38:13.154+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525689",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525710",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545375274\n\n\n\n##########\nFile path: cpp/examples/arrow/dataset-parquet-scan-example.cc\n##########\n@@ -62,7 +60,8 @@ struct Configuration {\n \n   // Indicates the filter by which rows will be filtered. This optimization can\n   // make use of partition information and/or file metadata if possible.\n-  std::shared_ptr<ds::Expression> filter = (\"total_amount\"_ > 1000.0f).Copy();\n+  ds::Expression filter =\n+      ds::greater(ds::field_ref(\"total_amount\"), ds::literal(1000.0f));\n\nReview comment:\n       I don't plan to bring them back.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T20:15:03.550+0000",
                    "updated": "2020-12-17T20:15:03.550+0000",
                    "started": "2020-12-17T20:15:03.549+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525710",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525712",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545376296\n\n\n\n##########\nFile path: cpp/src/arrow/compute/cast.cc\n##########\n@@ -118,8 +118,86 @@ class CastMetaFunction : public MetaFunction {\n \n }  // namespace\n \n+const FunctionDoc struct_doc{\"Wrap Arrays into a StructArray\",\n+                             (\"Names of the StructArray's fields are\\n\"\n+                              \"specified through StructOptions.\"),\n+                             {},\n+                             \"StructOptions\"};\n+\n+Result<ValueDescr> StructResolve(KernelContext* ctx,\n+                                 const std::vector<ValueDescr>& descrs) {\n+  const auto& names = OptionsWrapper<StructOptions>::Get(ctx).field_names;\n+  if (names.size() != descrs.size()) {\n+    return Status::Invalid(\"Struct() was passed \", names.size(), \" field \", \"names but \",\n+                           descrs.size(), \" arguments\");\n+  }\n+\n+  size_t i = 0;\n+  FieldVector fields(descrs.size());\n+\n+  ValueDescr::Shape shape = ValueDescr::SCALAR;\n+  for (const ValueDescr& descr : descrs) {\n+    if (descr.shape != ValueDescr::SCALAR) {\n+      shape = ValueDescr::ARRAY;\n+    } else {\n+      switch (descr.type->id()) {\n+        case Type::EXTENSION:\n+        case Type::DENSE_UNION:\n+        case Type::SPARSE_UNION:\n+          return Status::NotImplemented(\"Broadcasting scalars of type \", *descr.type);\n+        default:\n+          break;\n+      }\n+    }\n+\n+    fields[i] = field(names[i], descr.type);\n+    ++i;\n+  }\n+\n+  return ValueDescr{struct_(std::move(fields)), shape};\n+}\n+\n+void StructExec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+  KERNEL_ASSIGN_OR_RAISE(auto descr, ctx, StructResolve(ctx, batch.GetDescriptors()));\n+\n+  if (descr.shape == ValueDescr::SCALAR) {\n+    ScalarVector scalars(batch.num_values());\n+    for (int i = 0; i < batch.num_values(); ++i) {\n+      scalars[i] = batch[i].scalar();\n+    }\n+\n+    *out =\n+        Datum(std::make_shared<StructScalar>(std::move(scalars), std::move(descr.type)));\n+    return;\n+  }\n+\n+  ArrayVector arrays(batch.num_values());\n+  for (int i = 0; i < batch.num_values(); ++i) {\n+    if (batch[i].is_array()) {\n+      arrays[i] = batch[i].make_array();\n+      continue;\n+    }\n+\n+    KERNEL_ASSIGN_OR_RAISE(\n+        arrays[i], ctx,\n+        MakeArrayFromScalar(*batch[i].scalar(), batch.length, ctx->memory_pool()));\n+  }\n+\n+  *out = std::make_shared<StructArray>(descr.type, batch.length, std::move(arrays));\n+}\n+\n void RegisterScalarCast(FunctionRegistry* registry) {\n   DCHECK_OK(registry->AddFunction(std::make_shared<CastMetaFunction>()));\n+\n+  auto struct_function =\n+      std::make_shared<ScalarFunction>(\"struct\", Arity::VarArgs(), &struct_doc);\n\nReview comment:\n       I'll rename to \"make_struct\"\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T20:16:41.626+0000",
                    "updated": "2020-12-17T20:16:41.626+0000",
                    "started": "2020-12-17T20:16:41.626+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525712",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525714",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545376880\n\n\n\n##########\nFile path: cpp/src/arrow/compute/cast.cc\n##########\n@@ -135,7 +213,7 @@ CastFunction::CastFunction(std::string name, Type::type out_type)\n   impl_->out_type = out_type;\n }\n \n-CastFunction::~CastFunction() {}\n+CastFunction::~CastFunction() = default;\n\nReview comment:\n       They're equivalent, though the clang-tidy modernize pass prefers `= default`.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T20:17:37.255+0000",
                    "updated": "2020-12-17T20:17:37.255+0000",
                    "started": "2020-12-17T20:17:37.255+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525714",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525715",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545377183\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_cast_temporal.cc\n##########\n@@ -256,14 +251,45 @@ struct CastFunctor<Date64Type, Date32Type> {\n template <>\n struct CastFunctor<Date32Type, Date64Type> {\n   static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n-    // TODO: Make this work on scalar inputs\n     DCHECK_EQ(batch[0].kind(), Datum::ARRAY);\n \n     ShiftTime<int64_t, int32_t>(ctx, util::DIVIDE, kMillisecondsInDay, *batch[0].array(),\n                                 out->mutable_array());\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// date32, date64 to timestamp\n+\n+template <>\n+struct CastFunctor<TimestampType, Date32Type> {\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    DCHECK_EQ(batch[0].kind(), Datum::ARRAY);\n+\n+    const auto& out_type = checked_cast<const TimestampType&>(*out->type());\n+    // get conversion SECOND -> unit\n+    auto conversion = util::GetTimestampConversion(TimeUnit::SECOND, out_type.unit());\n+    DCHECK_EQ(conversion.first, util::MULTIPLY);\n+\n+    // multiply to achieve days -> unit\n+    conversion.second *= kMillisecondsInDay / 1000;\n+    ShiftTime<int32_t, int64_t>(ctx, util::MULTIPLY, conversion.second, *batch[0].array(),\n+                                out->mutable_array());\n+  }\n+};\n+\n+template <>\n+struct CastFunctor<TimestampType, Date64Type> {\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    DCHECK_EQ(batch[0].kind(), Datum::ARRAY);\n+\n+    const auto& out_type = checked_cast<const TimestampType&>(*out->type());\n+    auto conversion = util::GetTimestampConversion(TimeUnit::MILLI, out_type.unit());\n+    ShiftTime<int64_t, int64_t>(ctx, util::MULTIPLY, conversion.second, *batch[0].array(),\n\nReview comment:\n       will do\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T20:18:20.866+0000",
                    "updated": "2020-12-17T20:18:20.866+0000",
                    "started": "2020-12-17T20:18:20.866+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525715",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525716",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545377183\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_cast_temporal.cc\n##########\n@@ -256,14 +251,45 @@ struct CastFunctor<Date64Type, Date32Type> {\n template <>\n struct CastFunctor<Date32Type, Date64Type> {\n   static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n-    // TODO: Make this work on scalar inputs\n     DCHECK_EQ(batch[0].kind(), Datum::ARRAY);\n \n     ShiftTime<int64_t, int32_t>(ctx, util::DIVIDE, kMillisecondsInDay, *batch[0].array(),\n                                 out->mutable_array());\n   }\n };\n \n+// ----------------------------------------------------------------------\n+// date32, date64 to timestamp\n+\n+template <>\n+struct CastFunctor<TimestampType, Date32Type> {\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    DCHECK_EQ(batch[0].kind(), Datum::ARRAY);\n+\n+    const auto& out_type = checked_cast<const TimestampType&>(*out->type());\n+    // get conversion SECOND -> unit\n+    auto conversion = util::GetTimestampConversion(TimeUnit::SECOND, out_type.unit());\n+    DCHECK_EQ(conversion.first, util::MULTIPLY);\n+\n+    // multiply to achieve days -> unit\n+    conversion.second *= kMillisecondsInDay / 1000;\n+    ShiftTime<int32_t, int64_t>(ctx, util::MULTIPLY, conversion.second, *batch[0].array(),\n+                                out->mutable_array());\n+  }\n+};\n+\n+template <>\n+struct CastFunctor<TimestampType, Date64Type> {\n+  static void Exec(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n+    DCHECK_EQ(batch[0].kind(), Datum::ARRAY);\n+\n+    const auto& out_type = checked_cast<const TimestampType&>(*out->type());\n+    auto conversion = util::GetTimestampConversion(TimeUnit::MILLI, out_type.unit());\n+    ShiftTime<int64_t, int64_t>(ctx, util::MULTIPLY, conversion.second, *batch[0].array(),\n\nReview comment:\n       actually, this one might not be multiply, so it should be using conversion.first\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T20:18:55.560+0000",
                    "updated": "2020-12-17T20:18:55.560+0000",
                    "started": "2020-12-17T20:18:55.560+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525716",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525720",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545379841\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/partition.h\n##########\n@@ -63,13 +63,13 @@ class ARROW_DS_EXPORT Partitioning {\n   /// produce sub-batches which satisfy mutually exclusive Expressions.\n   struct PartitionedBatches {\n     RecordBatchVector batches;\n-    ExpressionVector expressions;\n+    std::vector<Expression> expressions;\n\nReview comment:\n       The other `$XVector` typedefs indicate a `vector<shared_ptr<$X>>` whereas ExpressionVector would be `vector<$X>` I'm fine with putting it back but it seemed against the unwritten convention\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T20:23:10.203+0000",
                    "updated": "2020-12-17T20:23:10.203+0000",
                    "started": "2020-12-17T20:23:10.202+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525720",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525721",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545380280\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/partition.h\n##########\n@@ -294,5 +285,22 @@ class ARROW_DS_EXPORT PartitioningOrFactory {\n   std::shared_ptr<Partitioning> partitioning_;\n };\n \n+/// \\brief Assemble lists of indices of identical rows.\n+///\n+/// \\param[in] by A StructArray whose columns will be used as grouping criteria.\n+/// \\return A StructArray mapping unique rows (in field \"values\", represented as a\n+///         StructArray with the same fields as `by`) to lists of indices where\n+///         that row appears (in field \"groupings\").\n\nReview comment:\n       correct\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T20:23:43.545+0000",
                    "updated": "2020-12-17T20:23:43.545+0000",
                    "started": "2020-12-17T20:23:43.545+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525721",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525723",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545381777\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/partition_test.cc\n##########\n@@ -21,52 +21,51 @@\n #include <gtest/gtest.h>\n \n #include <cstdint>\n-#include <map>\n #include <memory>\n #include <regex>\n #include <string>\n #include <vector>\n \n-#include \"arrow/dataset/file_base.h\"\n #include \"arrow/dataset/scanner_internal.h\"\n #include \"arrow/dataset/test_util.h\"\n-#include \"arrow/filesystem/localfs.h\"\n #include \"arrow/filesystem/path_util.h\"\n #include \"arrow/status.h\"\n #include \"arrow/testing/gtest_util.h\"\n-#include \"arrow/util/io_util.h\"\n \n namespace arrow {\n using internal::checked_pointer_cast;\n \n namespace dataset {\n \n-using E = TestExpression;\n-\n class TestPartitioning : public ::testing::Test {\n  public:\n   void AssertParseError(const std::string& path) {\n     ASSERT_RAISES(Invalid, partitioning_->Parse(path));\n   }\n \n-  void AssertParse(const std::string& path, E expected) {\n+  void AssertParse(const std::string& path, Expression expected) {\n     ASSERT_OK_AND_ASSIGN(auto parsed, partitioning_->Parse(path));\n-    ASSERT_EQ(E{parsed}, expected);\n+    ASSERT_EQ(parsed, expected);\n   }\n \n   template <StatusCode code = StatusCode::Invalid>\n-  void AssertFormatError(E expr) {\n-    ASSERT_EQ(partitioning_->Format(*expr.expression).status().code(), code);\n+  void AssertFormatError(Expression expr) {\n+    ASSERT_EQ(partitioning_->Format(expr).status().code(), code);\n   }\n \n-  void AssertFormat(E expr, const std::string& expected) {\n-    ASSERT_OK_AND_ASSIGN(auto formatted, partitioning_->Format(*expr.expression));\n+  void AssertFormat(Expression expr, const std::string& expected) {\n+    // formatted partition expressions are bound to the schema of the dataset being\n+    // written\n+    ASSERT_OK_AND_ASSIGN(auto formatted, partitioning_->Format(expr));\n     ASSERT_EQ(formatted, expected);\n \n     // ensure the formatted path round trips the relevant components of the partition\n     // expression: roundtripped should be a subset of expr\n-    ASSERT_OK_AND_ASSIGN(auto roundtripped, partitioning_->Parse(formatted));\n-    ASSERT_EQ(E{roundtripped->Assume(*expr.expression)}, E{scalar(true)});\n+    ASSERT_OK_AND_ASSIGN(Expression roundtripped, partitioning_->Parse(formatted));\n+\n+    ASSERT_OK_AND_ASSIGN(roundtripped, roundtripped.Bind(*written_schema_));\n\nReview comment:\n       Yes, I'll add an assert for that\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T20:26:20.138+0000",
                    "updated": "2020-12-17T20:26:20.138+0000",
                    "started": "2020-12-17T20:26:20.138+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525723",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525724",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545382248\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner.h\n##########\n@@ -62,10 +63,7 @@ class ARROW_DS_EXPORT ScanOptions {\n   std::shared_ptr<ScanOptions> ReplaceSchema(std::shared_ptr<Schema> schema) const;\n \n   // Filter\n-  std::shared_ptr<Expression> filter = scalar(true);\n-\n-  // Evaluator for Filter\n-  std::shared_ptr<ExpressionEvaluator> evaluator;\n+  Expression filter2 = literal(true);\n\nReview comment:\n       Yes, while refactoring I had both `filter` and `filter2`. I will rename it back to `filter`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T20:26:55.564+0000",
                    "updated": "2020-12-17T20:26:55.564+0000",
                    "started": "2020-12-17T20:26:55.563+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525724",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525726",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545382579\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/scanner_test.cc\n##########\n@@ -184,14 +183,26 @@ TEST_F(TestScannerBuilder, TestProject) {\n TEST_F(TestScannerBuilder, TestFilter) {\n   ScannerBuilder builder(dataset_, ctx_);\n \n-  ASSERT_OK(builder.Filter(scalar(true)));\n-  ASSERT_OK(builder.Filter(\"i64\"_ == int64_t(10)));\n-  ASSERT_OK(builder.Filter(\"i64\"_ == int64_t(10) || \"b\"_ == true));\n-\n-  ASSERT_RAISES(TypeError, builder.Filter(\"i64\"_ == int32_t(10)));\n-  ASSERT_RAISES(Invalid, builder.Filter(\"not_a_column\"_ == true));\n-  ASSERT_RAISES(Invalid,\n-                builder.Filter(\"i64\"_ == int64_t(10) || \"not_a_column\"_ == true));\n+  ASSERT_OK(builder.Filter(literal(true)));\n+  ASSERT_OK(builder.Filter(call(\"equal\", {field_ref(\"i64\"), literal<int64_t>(10)})));\n\nReview comment:\n       yes, I'll replace with a call to `equal`\n\n##########\nFile path: cpp/src/arrow/dataset/scanner_test.cc\n##########\n@@ -184,14 +183,26 @@ TEST_F(TestScannerBuilder, TestProject) {\n TEST_F(TestScannerBuilder, TestFilter) {\n   ScannerBuilder builder(dataset_, ctx_);\n \n-  ASSERT_OK(builder.Filter(scalar(true)));\n-  ASSERT_OK(builder.Filter(\"i64\"_ == int64_t(10)));\n-  ASSERT_OK(builder.Filter(\"i64\"_ == int64_t(10) || \"b\"_ == true));\n-\n-  ASSERT_RAISES(TypeError, builder.Filter(\"i64\"_ == int32_t(10)));\n-  ASSERT_RAISES(Invalid, builder.Filter(\"not_a_column\"_ == true));\n-  ASSERT_RAISES(Invalid,\n-                builder.Filter(\"i64\"_ == int64_t(10) || \"not_a_column\"_ == true));\n+  ASSERT_OK(builder.Filter(literal(true)));\n+  ASSERT_OK(builder.Filter(call(\"equal\", {field_ref(\"i64\"), literal<int64_t>(10)})));\n+  ASSERT_OK(builder.Filter(\n+      call(\"or_kleene\", {\n\nReview comment:\n       same\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T20:27:42.891+0000",
                    "updated": "2020-12-17T20:27:42.891+0000",
                    "started": "2020-12-17T20:27:42.891+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525726",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525728",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545383431\n\n\n\n##########\nFile path: cpp/src/arrow/type.cc\n##########\n@@ -1039,13 +1042,31 @@ Result<std::shared_ptr<Field>> FieldPath::Get(const FieldVector& fields) const {\n \n Result<std::shared_ptr<Array>> FieldPath::Get(const RecordBatch& batch) const {\n   ARROW_ASSIGN_OR_RAISE(auto data, FieldPathGetImpl::Get(this, batch.column_data()));\n-  return MakeArray(data);\n+  return MakeArray(std::move(data));\n }\n \n Result<std::shared_ptr<ChunkedArray>> FieldPath::Get(const Table& table) const {\n   return FieldPathGetImpl::Get(this, table.columns());\n }\n \n+Result<std::shared_ptr<Array>> FieldPath::Get(const Array& array) const {\n+  ARROW_ASSIGN_OR_RAISE(auto data, Get(*array.data()));\n+  return MakeArray(std::move(data));\n+}\n+\n+Result<std::shared_ptr<ArrayData>> FieldPath::Get(const ArrayData& data) const {\n+  return FieldPathGetImpl::Get(this, data.child_data);\n+}\n+\n+Result<std::shared_ptr<ChunkedArray>> FieldPath::Get(const ChunkedArray& array) const {\n+  FieldPath prefixed_with_0 = *this;\n+  prefixed_with_0.indices_.insert(prefixed_with_0.indices_.begin(), 0);\n+\n+  ChunkedArrayVector vec;\n+  vec.emplace_back(const_cast<ChunkedArray*>(&array), [](...) {});\n\nReview comment:\n       I'll probably just remove this. Retrieving fields from tables and chunked arrays is not currently used anywhere\n\n##########\nFile path: cpp/src/arrow/type.h\n##########\n@@ -1423,10 +1426,14 @@ class ARROW_EXPORT FieldPath {\n   Result<std::shared_ptr<Array>> Get(const RecordBatch& batch) const;\n   Result<std::shared_ptr<ChunkedArray>> Get(const Table& table) const;\n \n-  /// \\brief Retrieve the referenced child Array from an Array or ChunkedArray\n+  /// \\brief Retrieve the referenced child from an Array, ArrayData, or ChunkedArray\n   Result<std::shared_ptr<Array>> Get(const Array& array) const;\n+  Result<std::shared_ptr<ArrayData>> Get(const ArrayData& data) const;\n   Result<std::shared_ptr<ChunkedArray>> Get(const ChunkedArray& array) const;\n \n+  /// \\brief Retrieve the reference child from a Datum\n+  Result<Datum> Get(const Datum& datum) const;\n\nReview comment:\n       I moved that to `expression_internal.h`, I'll remove this decl\n\n##########\nFile path: cpp/src/arrow/type.h\n##########\n@@ -1423,10 +1426,14 @@ class ARROW_EXPORT FieldPath {\n   Result<std::shared_ptr<Array>> Get(const RecordBatch& batch) const;\n   Result<std::shared_ptr<ChunkedArray>> Get(const Table& table) const;\n \n-  /// \\brief Retrieve the referenced child Array from an Array or ChunkedArray\n+  /// \\brief Retrieve the referenced child from an Array, ArrayData, or ChunkedArray\n   Result<std::shared_ptr<Array>> Get(const Array& array) const;\n+  Result<std::shared_ptr<ArrayData>> Get(const ArrayData& data) const;\n   Result<std::shared_ptr<ChunkedArray>> Get(const ChunkedArray& array) const;\n \n+  /// \\brief Retrieve the reference child from a Datum\n\nReview comment:\n       yes, will fix\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T20:29:31.306+0000",
                    "updated": "2020-12-17T20:29:31.306+0000",
                    "started": "2020-12-17T20:29:31.306+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525728",
                    "issueId": "13335691"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/worklog/525729",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8894:\nURL: https://github.com/apache/arrow/pull/8894#discussion_r545384018\n\n\n\n##########\nFile path: cpp/src/arrow/dataset/expression_internal.h\n##########\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/dataset/expression.h\"\n+\n+#include <unordered_map>\n+#include <unordered_set>\n+#include <vector>\n+\n+#include \"arrow/compute/api_vector.h\"\n+#include \"arrow/compute/registry.h\"\n+#include \"arrow/record_batch.h\"\n+#include \"arrow/table.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace dataset {\n+\n+bool Identical(const Expression& l, const Expression& r) { return l.impl_ == r.impl_; }\n+\n+const Expression::Call* CallNotNull(const Expression& expr) {\n+  auto call = expr.call();\n+  DCHECK_NE(call, nullptr);\n+  return call;\n+}\n+\n+inline void GetAllFieldRefs(const Expression& expr,\n+                            std::unordered_set<FieldRef, FieldRef::Hash>* refs) {\n+  if (auto lit = expr.literal()) return;\n+\n+  if (auto ref = expr.field_ref()) {\n+    refs->emplace(*ref);\n+    return;\n+  }\n+\n+  for (const Expression& arg : CallNotNull(expr)->arguments) {\n+    GetAllFieldRefs(arg, refs);\n+  }\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Expression>& exprs) {\n+  std::vector<ValueDescr> descrs(exprs.size());\n+  for (size_t i = 0; i < exprs.size(); ++i) {\n+    DCHECK(exprs[i].IsBound());\n+    descrs[i] = exprs[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+inline std::vector<ValueDescr> GetDescriptors(const std::vector<Datum>& values) {\n+  std::vector<ValueDescr> descrs(values.size());\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    descrs[i] = values[i].descr();\n+  }\n+  return descrs;\n+}\n+\n+struct FieldPathGetDatumImpl {\n+  template <typename T, typename = decltype(FieldPath{}.Get(std::declval<const T&>()))>\n+  Result<Datum> operator()(const std::shared_ptr<T>& ptr) {\n+    return path_.Get(*ptr).template As<Datum>();\n+  }\n+\n+  template <typename T>\n+  Result<Datum> operator()(const T&) {\n+    return Status::NotImplemented(\"FieldPath::Get() into Datum \", datum_.ToString());\n+  }\n+\n+  const Datum& datum_;\n+  const FieldPath& path_;\n+};\n+\n+inline Result<Datum> GetDatumField(const FieldRef& ref, const Datum& input) {\n+  Datum field;\n+\n+  FieldPath path;\n+  if (auto type = input.type()) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.type()));\n+  } else if (input.kind() == Datum::RECORD_BATCH) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.record_batch()->schema()));\n+  } else if (input.kind() == Datum::TABLE) {\n+    ARROW_ASSIGN_OR_RAISE(path, ref.FindOneOrNone(*input.table()->schema()));\n+  }\n+\n+  if (path) {\n+    ARROW_ASSIGN_OR_RAISE(field,\n+                          util::visit(FieldPathGetDatumImpl{input, path}, input.value));\n+  }\n+\n+  if (field == Datum{}) {\n+    field = Datum(std::make_shared<NullScalar>());\n+  }\n+\n+  return field;\n+}\n+\n+struct Comparison {\n+  enum type {\n+    NA = 0,\n+    EQUAL = 1,\n+    LESS = 2,\n+    GREATER = 4,\n+    NOT_EQUAL = LESS | GREATER,\n+    LESS_EQUAL = LESS | EQUAL,\n+    GREATER_EQUAL = GREATER | EQUAL,\n+  };\n+\n+  static const type* Get(const std::string& function) {\n+    static std::unordered_map<std::string, type> flipped_comparisons{\n\nReview comment:\n       will rename\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T20:30:05.431+0000",
                    "updated": "2020-12-17T20:30:05.431+0000",
                    "started": "2020-12-17T20:30:05.430+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525729",
                    "issueId": "13335691"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 64800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@7db0d836[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3901a774[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5c1a13f9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@68942509[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@56952b7e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@715075cf[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7d5925c7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@34aceb08[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4b1de838[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@39110299[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@d526f61[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@5e753168[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 64800,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Jan 06 22:32:18 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-01-06T22:32:18.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10322/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-10-16T00:59:45.000+0000",
        "updated": "2021-01-07T16:40:50.000+0000",
        "timeoriginalestimate": null,
        "description": "The Expression class hierarchy was originally intended to provide generic, structured representations of compute functionality. On the former point they have been superseded by compute::\r\n\r\n{Function, Kernel, ...}\r\n\r\nwhich encapsulates validation and execution. In light of this Expression can be drastically simplified and improved by composition with these classes. Each responsibility which can be deferred implies less boilerplate when exposing a new compute function for use in datasets. Ideally any compute function will be immediately available to use in a filter or projection.\r\n{code:java}\r\nstruct Expression {\r\n  using Literal = std::shared_ptr<Scalar>;\r\n\r\n  struct Call {\r\n    std::shared_ptr<ScalarFunction> function;\r\n    std::shared_ptr<FunctionOptions> options;\r\n    std::vector<Expression> arguments;\r\n  };\r\n\r\n  util::variant<Literal, FieldRef, Call> value;\r\n};\r\n{code}\r\nA simple discriminated union as above should be sufficient to represent arbitrary filters and projections: any expression which results in type {{bool}} is a valid filter, and any expression which is a {{Projection}} may be used to map one record batch to another.\r\n\r\nExpression simplification (currently implemented in {{Expression::Assume}}) is an optimization used for example in predicate pushdown, and therefore need not exhaustively cover the full space of available compute functions.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "18h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 64800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Dataset] Minimize Expression to a wrapper around compute::Function",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13335691/comment/17260084",
                    "id": "17260084",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 8894\n[https://github.com/apache/arrow/pull/8894]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-01-06T22:32:18.738+0000",
                    "updated": "2021-01-06T22:32:18.738+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0jquw:",
        "customfield_12314139": null
    }
}