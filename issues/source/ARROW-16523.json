{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13444282",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282",
    "key": "ARROW-16523",
    "fields": {
        "parent": {
            "id": "13444280",
            "key": "ARROW-16522",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13444280",
            "fields": {
                "summary": "[C++] Evolution of exec plan",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                    "description": "The issue is open and ready for the assignee to start work on it.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                    "name": "Open",
                    "id": "1",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                        "id": 2,
                        "key": "new",
                        "colorName": "blue-gray",
                        "name": "To Do"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                    "id": "4",
                    "description": "An improvement or enhancement to an existing feature or task.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                    "name": "Improvement",
                    "subtask": false,
                    "avatarId": 21140
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351550",
                "id": "12351550",
                "name": "9.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-08-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available",
            "query-engine"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=sakras",
            "name": "sakras",
            "key": "sakras",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Sasha Krassovsky",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 14400,
            "total": 14400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 14400,
            "total": 14400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16523/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 24,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/770000",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#issuecomment-1125598737\n\n   https://issues.apache.org/jira/browse/ARROW-16523\n\n\n",
                    "created": "2022-05-13T02:34:45.859+0000",
                    "updated": "2022-05-13T02:34:45.859+0000",
                    "started": "2022-05-13T02:34:45.859+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "770000",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/770001",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#issuecomment-1125598746\n\n   :warning: Ticket **has not been started in JIRA**, please click 'Start Progress'.\n\n\n",
                    "created": "2022-05-13T02:34:47.807+0000",
                    "updated": "2022-05-13T02:34:47.807+0000",
                    "started": "2022-05-13T02:34:47.807+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "770001",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/774864",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r882219732\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,18 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  size_t GetThreadIndex();\n\nReview Comment:\n   ```suggestion\r\n     size_t GetThreadIndex();\r\n   ```\r\n   Minor nit: `size_t` feels like overkill for a thread index.  Maybe `int` or `uint32_t`?\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -157,6 +169,8 @@ class ARROW_EXPORT ExecNode {\n   /// knows when it has received all input, regardless of order.\n   virtual void InputFinished(ExecNode* input, int total_batches) = 0;\n \n+  virtual Status Init() { return Status::OK(); }\n\nReview Comment:\n   ```suggestion\r\n     /// \\brief Validate configuration and prepare any initial state\r\n     ///\r\n     /// This will be called after the plan has been fully created and before any\r\n     /// node starts producing.  At this point a node can use its inputs and outputs\r\n     /// (and input schemas) to validate its configuration.\r\n     virtual Status Init() { return Status::OK(); }\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/aggregate_node.cc:\n##########\n@@ -508,47 +519,24 @@ class GroupByNode : public ExecNode {\n     std::move(out_keys.values.begin(), out_keys.values.end(),\n               out_data.values.begin() + agg_kernels_.size());\n     state->grouper.reset();\n-\n-    if (output_counter_.SetTotal(\n-            static_cast<int>(bit_util::CeilDiv(out_data.length, output_batch_size())))) {\n-      // this will be hit if out_data.length == 0\n-      finished_.MarkFinished();\n-    }\n     return out_data;\n   }\n \n-  void OutputNthBatch(int n) {\n+  void OutputNthBatch(int64_t n) {\n     // bail if StopProducing was called\n     if (finished_.is_finished()) return;\n \n     int64_t batch_size = output_batch_size();\n     outputs_[0]->InputReceived(this, out_data_.Slice(batch_size * n, batch_size));\n-\n-    if (output_counter_.Increment()) {\n-      finished_.MarkFinished();\n-    }\n   }\n \n   Status OutputResult() {\n     RETURN_NOT_OK(Merge());\n     ARROW_ASSIGN_OR_RAISE(out_data_, Finalize());\n \n-    int num_output_batches = *output_counter_.total();\n-    outputs_[0]->InputFinished(this, num_output_batches);\n-\n-    auto executor = ctx_->executor();\n-    for (int i = 0; i < num_output_batches; ++i) {\n-      if (executor) {\n-        // bail if StopProducing was called\n-        if (finished_.is_finished()) break;\n-\n-        auto plan = this->plan()->shared_from_this();\n-        RETURN_NOT_OK(executor->Spawn([plan, this, i] { OutputNthBatch(i); }));\n-      } else {\n-        OutputNthBatch(i);\n-      }\n-    }\n-\n+    int64_t num_output_batches = bit_util::CeilDiv(out_data_.length, output_batch_size());\n+    outputs_[0]->InputFinished(this, static_cast<int>(num_output_batches));\n\nReview Comment:\n   This feels a little weird that we are calling `InputFinished` before we call any kind of `InputReceived` but I think it's correct.\n\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -96,64 +96,51 @@ struct SourceNode : ExecNode {\n       options.executor = executor;\n       options.should_schedule = ShouldSchedule::IfDifferentExecutor;\n     }\n-    finished_ = Loop([this, executor, options] {\n-                  std::unique_lock<std::mutex> lock(mutex_);\n-                  int total_batches = batch_count_++;\n-                  if (stop_requested_) {\n-                    return Future<ControlFlow<int>>::MakeFinished(Break(total_batches));\n-                  }\n-                  lock.unlock();\n-\n-                  return generator_().Then(\n-                      [=](const util::optional<ExecBatch>& maybe_batch)\n-                          -> Future<ControlFlow<int>> {\n-                        std::unique_lock<std::mutex> lock(mutex_);\n-                        if (IsIterationEnd(maybe_batch) || stop_requested_) {\n-                          stop_requested_ = true;\n-                          return Break(total_batches);\n-                        }\n-                        lock.unlock();\n-                        ExecBatch batch = std::move(*maybe_batch);\n-\n-                        if (executor) {\n-                          auto status = task_group_.AddTask(\n-                              [this, executor, batch]() -> Result<Future<>> {\n-                                return executor->Submit([=]() {\n-                                  outputs_[0]->InputReceived(this, std::move(batch));\n-                                  return Status::OK();\n-                                });\n-                              });\n-                          if (!status.ok()) {\n-                            outputs_[0]->ErrorReceived(this, std::move(status));\n-                            return Break(total_batches);\n-                          }\n-                        } else {\n-                          outputs_[0]->InputReceived(this, std::move(batch));\n-                        }\n-                        lock.lock();\n-                        if (!backpressure_future_.is_finished()) {\n-                          EVENT(span_, \"Source paused due to backpressure\");\n-                          return backpressure_future_.Then(\n-                              []() -> ControlFlow<int> { return Continue(); });\n-                        }\n-                        return Future<ControlFlow<int>>::MakeFinished(Continue());\n-                      },\n-                      [=](const Status& error) -> ControlFlow<int> {\n-                        // NB: ErrorReceived is independent of InputFinished, but\n-                        // ErrorReceived will usually prompt StopProducing which will\n-                        // prompt InputFinished. ErrorReceived may still be called from a\n-                        // node which was requested to stop (indeed, the request to stop\n-                        // may prompt an error).\n-                        std::unique_lock<std::mutex> lock(mutex_);\n-                        stop_requested_ = true;\n-                        lock.unlock();\n-                        outputs_[0]->ErrorReceived(this, error);\n-                        return Break(total_batches);\n-                      },\n-                      options);\n-                }).Then([&](int total_batches) {\n-      outputs_[0]->InputFinished(this, total_batches);\n-      return task_group_.End();\n+    Loop([this, options] {\n+      std::unique_lock<std::mutex> lock(mutex_);\n+      int total_batches = batch_count_++;\n+      if (stop_requested_) {\n+        return Future<ControlFlow<int>>::MakeFinished(Break(total_batches));\n+      }\n+      lock.unlock();\n+\n+      return generator_().Then(\n+          [=](const util::optional<ExecBatch>& maybe_batch) -> Future<ControlFlow<int>> {\n+            std::unique_lock<std::mutex> lock(mutex_);\n+            if (IsIterationEnd(maybe_batch) || stop_requested_) {\n+              stop_requested_ = true;\n+              return Break(total_batches);\n+            }\n+            lock.unlock();\n+            ExecBatch batch = std::move(*maybe_batch);\n+            RETURN_NOT_OK(plan_->ScheduleTask([=]() {\n+              outputs_[0]->InputReceived(this, std::move(batch));\n+              return Status::OK();\n+            }));\n+            lock.lock();\n+            if (!backpressure_future_.is_finished()) {\n+              EVENT(span_, \"Source paused due to backpressure\");\n+              return backpressure_future_.Then(\n+                  []() -> ControlFlow<int> { return Continue(); });\n+            }\n+            return Future<ControlFlow<int>>::MakeFinished(Continue());\n+          },\n+          [=](const Status& error) -> ControlFlow<int> {\n+            // NB: ErrorReceived is independent of InputFinished, but\n+            // ErrorReceived will usually prompt StopProducing which will\n+            // prompt InputFinished. ErrorReceived may still be called from a\n+            // node which was requested to stop (indeed, the request to stop\n+            // may prompt an error).\n\nReview Comment:\n   I'm not sure how much this comment makes sense anymore (not really related to your change).  Since an error prompts us to return `Break(total_batches)` we will immediately be calling `outputs_[0]->InputFinished` in the callback.  So I don't think we are relying on `StopProducing` here (`StopProducing`, at this point, is just a signal that the user has requested an abort of the plan, and not something nodes send to each other  `StopProducing` would never trigger a call to `InputFinished`).\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -279,7 +293,7 @@ class ARROW_EXPORT ExecNode {\n   NodeVector outputs_;\n \n   // Future to sync finished\n-  Future<> finished_ = Future<>::MakeFinished();\n+  Future<> finished_ = Future<>::Make();\n\nReview Comment:\n   Ideally this goes away at some point right?  If all work is being done by a plan scheduler then it seems a node shouldn't really need a concept of \"finished\"\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,18 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  size_t GetThreadIndex();\n+  size_t thread_capacity() const;\n\nReview Comment:\n   ```suggestion\r\n     size_t max_concurrency() const;\r\n   ```\r\n   The old name is probably fine too if you favor it.  When I see `thread_capacity` my brain thinks \"the capacity of a thread\".  Either way we should add a brief doc comment here explaining what this is (e.g. does it include I/O threads?  Is it safe to make an array of thread locals based on this?  Is this the max value that could be returned by `GetThreadIndex`?)\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -237,14 +290,18 @@ struct ExecPlanImpl : public ExecPlan {\n     return ss.str();\n   }\n \n-  Future<> finished_ = Future<>::MakeFinished();\n+  Future<> finished_ = Future<>::Make();\n\nReview Comment:\n   ```suggestion\r\n     Future<> finished_;\r\n   ```\r\n   \r\n   Minor nit, this will save on the initialization at the expense of calls to `plan->finished()` failing if the plan hasn't been started (actually, we might want calls like this to fail to avoid the possibility of someone calling `plan->finished()`, abandoning the plan, and then being stuck with a future that never finishes.)\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,18 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  size_t GetThreadIndex();\n+  size_t thread_capacity() const;\n+\n+  Status AddFuture(Future<> fut);\n+  Status ScheduleTask(std::function<Status()> fn);\n+  Status ScheduleTask(std::function<Status(size_t)> fn);\n+  // The need to register a task group before use will be removed after we rewrite the\n+  // scheduler.\n+  int RegisterTaskGroup(std::function<Status(size_t, int64_t)> task,\n+                        std::function<Status(size_t)> on_finished);\n+  Status StartTaskGroup(int task_group_id, int64_t num_tasks);\n+\n\nReview Comment:\n   We should document these methods and also provide some guidelines on when they should be used, even if some of this is eventually headed to the scheduler in a new rework.  As a user writing an ExecNode I would have various questions:\r\n   \r\n   When should I schedule a task vs just doing the work?\r\n    - Right now this is basically for pipeline breakers right?\r\n   When should I use ScheduleTask vs. RegisterTaskGroup/StartTaskGroup?\r\n    - I'm not sure the guidance here.  I think task group is for when you have enough work that it makes sense to break up the work across many different threads.\r\n   When should I use AddFuture?\r\n    - Only if you have to because you are interfacing with something that generates futures, e.g. I/O.  Not preferred for new work.\r\n    \r\n    Make sure to document that `RegisterTaskGroup` must be called during `Init`.\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -237,14 +290,18 @@ struct ExecPlanImpl : public ExecPlan {\n     return ss.str();\n   }\n \n-  Future<> finished_ = Future<>::MakeFinished();\n+  Future<> finished_ = Future<>::Make();\n   bool started_ = false, stopped_ = false;\n   std::vector<std::unique_ptr<ExecNode>> nodes_;\n   NodeVector sources_, sinks_;\n   NodeVector sorted_nodes_;\n   uint32_t auto_label_counter_ = 0;\n   util::tracing::Span span_;\n   std::shared_ptr<const KeyValueMetadata> metadata_;\n+\n+  ThreadIndexer thread_indexer_;\n+  util::AsyncTaskGroup task_group_;\n+  std::unique_ptr<TaskScheduler> task_scheduler_;\n\nReview Comment:\n   ```suggestion\r\n     std::unique_ptr<TaskScheduler> task_scheduler_ = TaskScheduler::Make();\r\n   ```\r\n   Let's initialize this here for consistency with other fields (e.g. `auto_label_counter_`, `finished_`, `started_`, ...)\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -883,6 +875,8 @@ class HashJoinBasicImpl : public HashJoinImpl {\n   //\n   OutputBatchCallback output_batch_callback_;\n   FinishedCallback finished_callback_;\n+  RegisterTaskGroupCallback register_task_group_callback_;\n\nReview Comment:\n   This feels a little ping-pongy.  Did you mention the other day that the task groups might be moving into the node itself?  I don't think this needs to change, just calling it out as food for thought.\r\n   \r\n   If these tasks aren't moving out then maybe we can define some basic pure virtual class above `ExecNode` like `PlanContext` which has the scheduler, thread id accessor, etc. that we can allow types like this to depend on?\n\n\n\n",
                    "created": "2022-05-26T01:09:19.244+0000",
                    "updated": "2022-05-26T01:09:19.244+0000",
                    "started": "2022-05-26T01:09:19.244+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "774864",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/775162",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r882904638\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,18 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  size_t GetThreadIndex();\n\nReview Comment:\n   I'd be fine with `uint32_t`. I just chose `size_t` because that's what `ThreadIndexer` currently returns. \n\n\n\n",
                    "created": "2022-05-26T17:23:36.452+0000",
                    "updated": "2022-05-26T17:23:36.452+0000",
                    "started": "2022-05-26T17:23:36.451+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775162",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/775164",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r882909683\n\n\n##########\ncpp/src/arrow/compute/exec/aggregate_node.cc:\n##########\n@@ -508,47 +519,24 @@ class GroupByNode : public ExecNode {\n     std::move(out_keys.values.begin(), out_keys.values.end(),\n               out_data.values.begin() + agg_kernels_.size());\n     state->grouper.reset();\n-\n-    if (output_counter_.SetTotal(\n-            static_cast<int>(bit_util::CeilDiv(out_data.length, output_batch_size())))) {\n-      // this will be hit if out_data.length == 0\n-      finished_.MarkFinished();\n-    }\n     return out_data;\n   }\n \n-  void OutputNthBatch(int n) {\n+  void OutputNthBatch(int64_t n) {\n     // bail if StopProducing was called\n     if (finished_.is_finished()) return;\n \n     int64_t batch_size = output_batch_size();\n     outputs_[0]->InputReceived(this, out_data_.Slice(batch_size * n, batch_size));\n-\n-    if (output_counter_.Increment()) {\n-      finished_.MarkFinished();\n-    }\n   }\n \n   Status OutputResult() {\n     RETURN_NOT_OK(Merge());\n     ARROW_ASSIGN_OR_RAISE(out_data_, Finalize());\n \n-    int num_output_batches = *output_counter_.total();\n-    outputs_[0]->InputFinished(this, num_output_batches);\n-\n-    auto executor = ctx_->executor();\n-    for (int i = 0; i < num_output_batches; ++i) {\n-      if (executor) {\n-        // bail if StopProducing was called\n-        if (finished_.is_finished()) break;\n-\n-        auto plan = this->plan()->shared_from_this();\n-        RETURN_NOT_OK(executor->Spawn([plan, this, i] { OutputNthBatch(i); }));\n-      } else {\n-        OutputNthBatch(i);\n-      }\n-    }\n-\n+    int64_t num_output_batches = bit_util::CeilDiv(out_data_.length, output_batch_size());\n+    outputs_[0]->InputFinished(this, static_cast<int>(num_output_batches));\n\nReview Comment:\n   Yes, it's why we have that `AtomicCounter` thingy that's supposed to only run any cleanup if its number of received batches is equal to the number of batches specified in `InputFinished`. I guess the role of `InputFinished` is really to just say how many batches there will be total, not to have any sort of guarantees of \"thou shalt not receive batches after `InputFinsihed` is called\"\n\n\n\n",
                    "created": "2022-05-26T17:29:01.585+0000",
                    "updated": "2022-05-26T17:29:01.585+0000",
                    "started": "2022-05-26T17:29:01.584+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775164",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/775168",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r882912625\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join.cc:\n##########\n@@ -883,6 +875,8 @@ class HashJoinBasicImpl : public HashJoinImpl {\n   //\n   OutputBatchCallback output_batch_callback_;\n   FinishedCallback finished_callback_;\n+  RegisterTaskGroupCallback register_task_group_callback_;\n\nReview Comment:\n   Yeah, I've actually decided I want to keep the task groups inside the node because I think it's a bit cleaner with the accumulation. This `Register` thing will go away with the scheduler revamp too, so it'll be enough to just say \"Run this lambda 100 times for me\". \n\n\n\n",
                    "created": "2022-05-26T17:32:46.959+0000",
                    "updated": "2022-05-26T17:32:46.959+0000",
                    "started": "2022-05-26T17:32:46.959+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775168",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/775169",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r882914624\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -96,64 +96,51 @@ struct SourceNode : ExecNode {\n       options.executor = executor;\n       options.should_schedule = ShouldSchedule::IfDifferentExecutor;\n     }\n-    finished_ = Loop([this, executor, options] {\n-                  std::unique_lock<std::mutex> lock(mutex_);\n-                  int total_batches = batch_count_++;\n-                  if (stop_requested_) {\n-                    return Future<ControlFlow<int>>::MakeFinished(Break(total_batches));\n-                  }\n-                  lock.unlock();\n-\n-                  return generator_().Then(\n-                      [=](const util::optional<ExecBatch>& maybe_batch)\n-                          -> Future<ControlFlow<int>> {\n-                        std::unique_lock<std::mutex> lock(mutex_);\n-                        if (IsIterationEnd(maybe_batch) || stop_requested_) {\n-                          stop_requested_ = true;\n-                          return Break(total_batches);\n-                        }\n-                        lock.unlock();\n-                        ExecBatch batch = std::move(*maybe_batch);\n-\n-                        if (executor) {\n-                          auto status = task_group_.AddTask(\n-                              [this, executor, batch]() -> Result<Future<>> {\n-                                return executor->Submit([=]() {\n-                                  outputs_[0]->InputReceived(this, std::move(batch));\n-                                  return Status::OK();\n-                                });\n-                              });\n-                          if (!status.ok()) {\n-                            outputs_[0]->ErrorReceived(this, std::move(status));\n-                            return Break(total_batches);\n-                          }\n-                        } else {\n-                          outputs_[0]->InputReceived(this, std::move(batch));\n-                        }\n-                        lock.lock();\n-                        if (!backpressure_future_.is_finished()) {\n-                          EVENT(span_, \"Source paused due to backpressure\");\n-                          return backpressure_future_.Then(\n-                              []() -> ControlFlow<int> { return Continue(); });\n-                        }\n-                        return Future<ControlFlow<int>>::MakeFinished(Continue());\n-                      },\n-                      [=](const Status& error) -> ControlFlow<int> {\n-                        // NB: ErrorReceived is independent of InputFinished, but\n-                        // ErrorReceived will usually prompt StopProducing which will\n-                        // prompt InputFinished. ErrorReceived may still be called from a\n-                        // node which was requested to stop (indeed, the request to stop\n-                        // may prompt an error).\n-                        std::unique_lock<std::mutex> lock(mutex_);\n-                        stop_requested_ = true;\n-                        lock.unlock();\n-                        outputs_[0]->ErrorReceived(this, error);\n-                        return Break(total_batches);\n-                      },\n-                      options);\n-                }).Then([&](int total_batches) {\n-      outputs_[0]->InputFinished(this, total_batches);\n-      return task_group_.End();\n+    Loop([this, options] {\n+      std::unique_lock<std::mutex> lock(mutex_);\n+      int total_batches = batch_count_++;\n+      if (stop_requested_) {\n+        return Future<ControlFlow<int>>::MakeFinished(Break(total_batches));\n+      }\n+      lock.unlock();\n+\n+      return generator_().Then(\n+          [=](const util::optional<ExecBatch>& maybe_batch) -> Future<ControlFlow<int>> {\n+            std::unique_lock<std::mutex> lock(mutex_);\n+            if (IsIterationEnd(maybe_batch) || stop_requested_) {\n+              stop_requested_ = true;\n+              return Break(total_batches);\n+            }\n+            lock.unlock();\n+            ExecBatch batch = std::move(*maybe_batch);\n+            RETURN_NOT_OK(plan_->ScheduleTask([=]() {\n+              outputs_[0]->InputReceived(this, std::move(batch));\n+              return Status::OK();\n+            }));\n+            lock.lock();\n+            if (!backpressure_future_.is_finished()) {\n+              EVENT(span_, \"Source paused due to backpressure\");\n+              return backpressure_future_.Then(\n+                  []() -> ControlFlow<int> { return Continue(); });\n+            }\n+            return Future<ControlFlow<int>>::MakeFinished(Continue());\n+          },\n+          [=](const Status& error) -> ControlFlow<int> {\n+            // NB: ErrorReceived is independent of InputFinished, but\n+            // ErrorReceived will usually prompt StopProducing which will\n+            // prompt InputFinished. ErrorReceived may still be called from a\n+            // node which was requested to stop (indeed, the request to stop\n+            // may prompt an error).\n\nReview Comment:\n   Good point, I didn't understand this comment anyway \ud83d\ude1b \r\n   This whole node gets rewritten in Part 2 anyway, but yes I'll delete the comment here. \n\n\n\n",
                    "created": "2022-05-26T17:35:12.271+0000",
                    "updated": "2022-05-26T17:35:12.271+0000",
                    "started": "2022-05-26T17:35:12.271+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775169",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/775170",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r882918417\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -279,7 +293,7 @@ class ARROW_EXPORT ExecNode {\n   NodeVector outputs_;\n \n   // Future to sync finished\n-  Future<> finished_ = Future<>::MakeFinished();\n+  Future<> finished_ = Future<>::Make();\n\nReview Comment:\n   Yes, except we probably want a distinction between \"everything that we wanted to output has been outputted\" and \"we haven't finished outputting but we didn't schedule enough tasks so we're stuck\" (the second one being a bug). \r\n   \r\n   So far the idea I have is to have `finished_` only on sink nodes, but that also doesn't necessarily seem as clean. \n\n\n\n",
                    "created": "2022-05-26T17:40:02.848+0000",
                    "updated": "2022-05-26T17:40:02.848+0000",
                    "started": "2022-05-26T17:40:02.848+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775170",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/775231",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r883038721\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,18 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  size_t GetThreadIndex();\n+  size_t thread_capacity() const;\n\nReview Comment:\n   I like `max_concurrency`. I added a comment.\n\n\n\n",
                    "created": "2022-05-26T20:14:59.657+0000",
                    "updated": "2022-05-26T20:14:59.657+0000",
                    "started": "2022-05-26T20:14:59.657+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775231",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/775232",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r883039628\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -157,6 +169,8 @@ class ARROW_EXPORT ExecNode {\n   /// knows when it has received all input, regardless of order.\n   virtual void InputFinished(ExecNode* input, int total_batches) = 0;\n \n+  virtual Status Init() { return Status::OK(); }\n\nReview Comment:\n   Actually this is just the new name of `PrepareToProduce` that was put in in the Bloom filter pushdown PR, so I'll just take that comment. \n\n\n\n",
                    "created": "2022-05-26T20:16:19.798+0000",
                    "updated": "2022-05-26T20:16:19.798+0000",
                    "started": "2022-05-26T20:16:19.797+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775232",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/775233",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r882909683\n\n\n##########\ncpp/src/arrow/compute/exec/aggregate_node.cc:\n##########\n@@ -508,47 +519,24 @@ class GroupByNode : public ExecNode {\n     std::move(out_keys.values.begin(), out_keys.values.end(),\n               out_data.values.begin() + agg_kernels_.size());\n     state->grouper.reset();\n-\n-    if (output_counter_.SetTotal(\n-            static_cast<int>(bit_util::CeilDiv(out_data.length, output_batch_size())))) {\n-      // this will be hit if out_data.length == 0\n-      finished_.MarkFinished();\n-    }\n     return out_data;\n   }\n \n-  void OutputNthBatch(int n) {\n+  void OutputNthBatch(int64_t n) {\n     // bail if StopProducing was called\n     if (finished_.is_finished()) return;\n \n     int64_t batch_size = output_batch_size();\n     outputs_[0]->InputReceived(this, out_data_.Slice(batch_size * n, batch_size));\n-\n-    if (output_counter_.Increment()) {\n-      finished_.MarkFinished();\n-    }\n   }\n \n   Status OutputResult() {\n     RETURN_NOT_OK(Merge());\n     ARROW_ASSIGN_OR_RAISE(out_data_, Finalize());\n \n-    int num_output_batches = *output_counter_.total();\n-    outputs_[0]->InputFinished(this, num_output_batches);\n-\n-    auto executor = ctx_->executor();\n-    for (int i = 0; i < num_output_batches; ++i) {\n-      if (executor) {\n-        // bail if StopProducing was called\n-        if (finished_.is_finished()) break;\n-\n-        auto plan = this->plan()->shared_from_this();\n-        RETURN_NOT_OK(executor->Spawn([plan, this, i] { OutputNthBatch(i); }));\n-      } else {\n-        OutputNthBatch(i);\n-      }\n-    }\n-\n+    int64_t num_output_batches = bit_util::CeilDiv(out_data_.length, output_batch_size());\n+    outputs_[0]->InputFinished(this, static_cast<int>(num_output_batches));\n\nReview Comment:\n   Yes, it's why we have that `AtomicCounter` thingy that's supposed to only run any cleanup if its number of received batches is equal to the number of batches specified in `InputFinished`. I guess the role of `InputFinished` is really to just say how many batches there will be total, not to have any sort of guarantees of \"thou shalt not receive batches after `InputFinished` is called\"\n\n\n\n",
                    "created": "2022-05-26T20:17:34.780+0000",
                    "updated": "2022-05-26T20:17:34.780+0000",
                    "started": "2022-05-26T20:17:34.779+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "775233",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/779707",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r892950355\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,18 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  size_t GetThreadIndex();\n+  size_t thread_capacity() const;\n+\n+  Status AddFuture(Future<> fut);\n+  Status ScheduleTask(std::function<Status()> fn);\n+  Status ScheduleTask(std::function<Status(size_t)> fn);\n+  // The need to register a task group before use will be removed after we rewrite the\n+  // scheduler.\n+  int RegisterTaskGroup(std::function<Status(size_t, int64_t)> task,\n+                        std::function<Status(size_t)> on_finished);\n+  Status StartTaskGroup(int task_group_id, int64_t num_tasks);\n+\n\nReview Comment:\n   Added some comments.\n\n\n\n",
                    "created": "2022-06-08T23:40:44.394+0000",
                    "updated": "2022-06-08T23:40:44.394+0000",
                    "started": "2022-06-08T23:40:44.393+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "779707",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/779718",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r892967468\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.cc:\n##########\n@@ -237,14 +290,18 @@ struct ExecPlanImpl : public ExecPlan {\n     return ss.str();\n   }\n \n-  Future<> finished_ = Future<>::MakeFinished();\n+  Future<> finished_ = Future<>::Make();\n\nReview Comment:\n   Actually this seems to segfault when I do this, so I left it as is for now.\n\n\n\n",
                    "created": "2022-06-09T00:16:48.572+0000",
                    "updated": "2022-06-09T00:16:48.572+0000",
                    "started": "2022-06-09T00:16:48.572+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "779718",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/789731",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r918299723\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,63 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  /// \\brief Returns the index of the current thread.\n+  size_t GetThreadIndex();\n+  /// \\brief Returns the maximum number of threads that the plan could use.\n+  ///\n+  /// GetThreadIndex will always return something less than this, so it is safe to\n+  /// e.g. make an array of thread-locals off this.\n+  size_t max_concurrency() const;\n+\n+  // The below API interfaces with the scheduler to add tasks to the task group. Tasks\n+  // should be added sparingly! Prefer just doing the work immediately rather than adding\n+  // a task for it. Tasks are used in pipeline breakers that may output many more rows\n+  // than they received (such as a full outer join).\n+  //\n+  //\n+  /// \\brief Adds a future to the plan's task group.\n+  ///\n+  /// \\param fut The future to add\n+  ///\n+  /// Use this when interfacing with anything that returns a future (such as IO), but\n+  /// prefer ScheduleTask/StartTaskGroup inside of\n+  /// ExecNodes.\n+  Status AddFuture(Future<> fut);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes no arguments and returns a Status.\n+  Status ScheduleTask(std::function<Status()> fn);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n\nReview Comment:\n   ```suggestion\r\n     /// \\brief Add a single function as a task to the plan's task group.\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,63 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  /// \\brief Returns the index of the current thread.\n+  size_t GetThreadIndex();\n+  /// \\brief Returns the maximum number of threads that the plan could use.\n+  ///\n+  /// GetThreadIndex will always return something less than this, so it is safe to\n+  /// e.g. make an array of thread-locals off this.\n+  size_t max_concurrency() const;\n+\n+  // The below API interfaces with the scheduler to add tasks to the task group. Tasks\n+  // should be added sparingly! Prefer just doing the work immediately rather than adding\n+  // a task for it. Tasks are used in pipeline breakers that may output many more rows\n+  // than they received (such as a full outer join).\n+  //\n+  //\n+  /// \\brief Adds a future to the plan's task group.\n+  ///\n+  /// \\param fut The future to add\n+  ///\n+  /// Use this when interfacing with anything that returns a future (such as IO), but\n+  /// prefer ScheduleTask/StartTaskGroup inside of\n+  /// ExecNodes.\n+  Status AddFuture(Future<> fut);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n\nReview Comment:\n   ```suggestion\r\n     /// \\brief Add a single function as a task to the plan's task group.\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,63 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  /// \\brief Returns the index of the current thread.\n+  size_t GetThreadIndex();\n+  /// \\brief Returns the maximum number of threads that the plan could use.\n+  ///\n+  /// GetThreadIndex will always return something less than this, so it is safe to\n+  /// e.g. make an array of thread-locals off this.\n+  size_t max_concurrency() const;\n+\n+  // The below API interfaces with the scheduler to add tasks to the task group. Tasks\n\nReview Comment:\n   Can you add this as part of the `///` comment block?  Just put it after `ExecNodes.`\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,63 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  /// \\brief Returns the index of the current thread.\n+  size_t GetThreadIndex();\n+  /// \\brief Returns the maximum number of threads that the plan could use.\n+  ///\n+  /// GetThreadIndex will always return something less than this, so it is safe to\n+  /// e.g. make an array of thread-locals off this.\n+  size_t max_concurrency() const;\n+\n+  // The below API interfaces with the scheduler to add tasks to the task group. Tasks\n+  // should be added sparingly! Prefer just doing the work immediately rather than adding\n+  // a task for it. Tasks are used in pipeline breakers that may output many more rows\n+  // than they received (such as a full outer join).\n+  //\n+  //\n+  /// \\brief Adds a future to the plan's task group.\n+  ///\n+  /// \\param fut The future to add\n+  ///\n+  /// Use this when interfacing with anything that returns a future (such as IO), but\n+  /// prefer ScheduleTask/StartTaskGroup inside of\n+  /// ExecNodes.\n+  Status AddFuture(Future<> fut);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes no arguments and returns a Status.\n+  Status ScheduleTask(std::function<Status()> fn);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes the thread index and returns a Status.\n+  Status ScheduleTask(std::function<Status(size_t)> fn);\n+  // Register/Start TaskGroup is a way of performing a \"Parallel For\" pattern:\n+  // - The task function takes the thread index and the index of the task\n+  // - The on_finished function takes the thread index\n+  // Returns an integer ID that will be used to reference the task group in\n+  // StartTaskGroup. At runtime, call StartTaskGroup with the ID and the number of times\n+  // you'd like the task to be executed. The need to register a task group before use will\n+  // be removed after we rewrite the scheduler.\n+  /// \\brief Registers a \"parallel for\" task group with the scheduler\n\nReview Comment:\n   ```suggestion\r\n     /// \\brief Register a \"parallel for\" task group with the scheduler\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -196,17 +186,16 @@ struct SourceNode : ExecNode {\n   void StopProducing() override {\n     std::unique_lock<std::mutex> lock(mutex_);\n     stop_requested_ = true;\n+    if (!started_) finished_.MarkFinished();\n\nReview Comment:\n   If `started_` is false wouldn't that have to mean that someone called `StopProducing` before they called `StartProducing`?  What kind of situation are you trying to guard against here?\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,63 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  /// \\brief Returns the index of the current thread.\n+  size_t GetThreadIndex();\n+  /// \\brief Returns the maximum number of threads that the plan could use.\n+  ///\n+  /// GetThreadIndex will always return something less than this, so it is safe to\n+  /// e.g. make an array of thread-locals off this.\n+  size_t max_concurrency() const;\n+\n+  // The below API interfaces with the scheduler to add tasks to the task group. Tasks\n+  // should be added sparingly! Prefer just doing the work immediately rather than adding\n+  // a task for it. Tasks are used in pipeline breakers that may output many more rows\n+  // than they received (such as a full outer join).\n+  //\n+  //\n+  /// \\brief Adds a future to the plan's task group.\n+  ///\n+  /// \\param fut The future to add\n+  ///\n+  /// Use this when interfacing with anything that returns a future (such as IO), but\n+  /// prefer ScheduleTask/StartTaskGroup inside of\n+  /// ExecNodes.\n+  Status AddFuture(Future<> fut);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes no arguments and returns a Status.\n+  Status ScheduleTask(std::function<Status()> fn);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes the thread index and returns a Status.\n+  Status ScheduleTask(std::function<Status(size_t)> fn);\n\nReview Comment:\n   Do these have the same caveats as the future-task adding overload (e.g. use sparingly, use for connecting with asynchronous code)?  If so, we probably shouldn't repeat ourselves but maybe should reference the primary overload.\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,63 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  /// \\brief Returns the index of the current thread.\n+  size_t GetThreadIndex();\n+  /// \\brief Returns the maximum number of threads that the plan could use.\n+  ///\n+  /// GetThreadIndex will always return something less than this, so it is safe to\n+  /// e.g. make an array of thread-locals off this.\n+  size_t max_concurrency() const;\n+\n+  // The below API interfaces with the scheduler to add tasks to the task group. Tasks\n+  // should be added sparingly! Prefer just doing the work immediately rather than adding\n+  // a task for it. Tasks are used in pipeline breakers that may output many more rows\n+  // than they received (such as a full outer join).\n+  //\n+  //\n+  /// \\brief Adds a future to the plan's task group.\n\nReview Comment:\n   ```suggestion\r\n     /// \\brief Add a future to the plan's task group.\r\n   ```\r\n   \n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,63 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  /// \\brief Returns the index of the current thread.\n+  size_t GetThreadIndex();\n+  /// \\brief Returns the maximum number of threads that the plan could use.\n+  ///\n+  /// GetThreadIndex will always return something less than this, so it is safe to\n+  /// e.g. make an array of thread-locals off this.\n+  size_t max_concurrency() const;\n+\n+  // The below API interfaces with the scheduler to add tasks to the task group. Tasks\n+  // should be added sparingly! Prefer just doing the work immediately rather than adding\n+  // a task for it. Tasks are used in pipeline breakers that may output many more rows\n+  // than they received (such as a full outer join).\n+  //\n+  //\n+  /// \\brief Adds a future to the plan's task group.\n+  ///\n+  /// \\param fut The future to add\n+  ///\n+  /// Use this when interfacing with anything that returns a future (such as IO), but\n+  /// prefer ScheduleTask/StartTaskGroup inside of\n+  /// ExecNodes.\n+  Status AddFuture(Future<> fut);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes no arguments and returns a Status.\n+  Status ScheduleTask(std::function<Status()> fn);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes the thread index and returns a Status.\n+  Status ScheduleTask(std::function<Status(size_t)> fn);\n+  // Register/Start TaskGroup is a way of performing a \"Parallel For\" pattern:\n+  // - The task function takes the thread index and the index of the task\n+  // - The on_finished function takes the thread index\n+  // Returns an integer ID that will be used to reference the task group in\n+  // StartTaskGroup. At runtime, call StartTaskGroup with the ID and the number of times\n+  // you'd like the task to be executed. The need to register a task group before use will\n+  // be removed after we rewrite the scheduler.\n+  /// \\brief Registers a \"parallel for\" task group with the scheduler\n+  ///\n+  /// \\param task The function implementing the task. Takes the thread_index and\n+  ///             the task index.\n+  /// \\param on_finished The function that gets run once all tasks have been completed.\n+  /// Takes\n+  ///                    the thread_index.\n+  ///\n+  /// Must be called inside of ExecNode::Init.\n+  int RegisterTaskGroup(std::function<Status(size_t, int64_t)> task,\n+                        std::function<Status(size_t)> on_finished);\n+\n+  /// \\brief Starts the task group with the specified ID\n\nReview Comment:\n   ```suggestion\r\n     /// \\brief Start the task group with the specified ID\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,63 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  /// \\brief Returns the index of the current thread.\n+  size_t GetThreadIndex();\n+  /// \\brief Returns the maximum number of threads that the plan could use.\n+  ///\n+  /// GetThreadIndex will always return something less than this, so it is safe to\n+  /// e.g. make an array of thread-locals off this.\n+  size_t max_concurrency() const;\n+\n+  // The below API interfaces with the scheduler to add tasks to the task group. Tasks\n+  // should be added sparingly! Prefer just doing the work immediately rather than adding\n+  // a task for it. Tasks are used in pipeline breakers that may output many more rows\n+  // than they received (such as a full outer join).\n+  //\n+  //\n+  /// \\brief Adds a future to the plan's task group.\n+  ///\n+  /// \\param fut The future to add\n+  ///\n+  /// Use this when interfacing with anything that returns a future (such as IO), but\n+  /// prefer ScheduleTask/StartTaskGroup inside of\n+  /// ExecNodes.\n+  Status AddFuture(Future<> fut);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes no arguments and returns a Status.\n+  Status ScheduleTask(std::function<Status()> fn);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes the thread index and returns a Status.\n+  Status ScheduleTask(std::function<Status(size_t)> fn);\n+  // Register/Start TaskGroup is a way of performing a \"Parallel For\" pattern:\n+  // - The task function takes the thread index and the index of the task\n+  // - The on_finished function takes the thread index\n+  // Returns an integer ID that will be used to reference the task group in\n+  // StartTaskGroup. At runtime, call StartTaskGroup with the ID and the number of times\n+  // you'd like the task to be executed. The need to register a task group before use will\n+  // be removed after we rewrite the scheduler.\n+  /// \\brief Registers a \"parallel for\" task group with the scheduler\n+  ///\n+  /// \\param task The function implementing the task. Takes the thread_index and\n+  ///             the task index.\n+  /// \\param on_finished The function that gets run once all tasks have been completed.\n+  /// Takes\n+  ///                    the thread_index.\n+  ///\n+  /// Must be called inside of ExecNode::Init.\n\nReview Comment:\n   Can you fix the formatting here?\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,63 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  /// \\brief Returns the index of the current thread.\n+  size_t GetThreadIndex();\n+  /// \\brief Returns the maximum number of threads that the plan could use.\n+  ///\n+  /// GetThreadIndex will always return something less than this, so it is safe to\n+  /// e.g. make an array of thread-locals off this.\n+  size_t max_concurrency() const;\n+\n+  // The below API interfaces with the scheduler to add tasks to the task group. Tasks\n+  // should be added sparingly! Prefer just doing the work immediately rather than adding\n+  // a task for it. Tasks are used in pipeline breakers that may output many more rows\n+  // than they received (such as a full outer join).\n+  //\n+  //\n+  /// \\brief Adds a future to the plan's task group.\n+  ///\n+  /// \\param fut The future to add\n+  ///\n+  /// Use this when interfacing with anything that returns a future (such as IO), but\n+  /// prefer ScheduleTask/StartTaskGroup inside of\n+  /// ExecNodes.\n\nReview Comment:\n   ```suggestion\r\n     /// prefer ScheduleTask/StartTaskGroup inside of ExecNodes.\r\n   ```\n\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,63 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  /// \\brief Returns the index of the current thread.\n+  size_t GetThreadIndex();\n+  /// \\brief Returns the maximum number of threads that the plan could use.\n+  ///\n+  /// GetThreadIndex will always return something less than this, so it is safe to\n+  /// e.g. make an array of thread-locals off this.\n+  size_t max_concurrency() const;\n+\n+  // The below API interfaces with the scheduler to add tasks to the task group. Tasks\n+  // should be added sparingly! Prefer just doing the work immediately rather than adding\n+  // a task for it. Tasks are used in pipeline breakers that may output many more rows\n+  // than they received (such as a full outer join).\n+  //\n+  //\n+  /// \\brief Adds a future to the plan's task group.\n+  ///\n+  /// \\param fut The future to add\n+  ///\n+  /// Use this when interfacing with anything that returns a future (such as IO), but\n+  /// prefer ScheduleTask/StartTaskGroup inside of\n+  /// ExecNodes.\n+  Status AddFuture(Future<> fut);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes no arguments and returns a Status.\n+  Status ScheduleTask(std::function<Status()> fn);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes the thread index and returns a Status.\n+  Status ScheduleTask(std::function<Status(size_t)> fn);\n+  // Register/Start TaskGroup is a way of performing a \"Parallel For\" pattern:\n+  // - The task function takes the thread index and the index of the task\n+  // - The on_finished function takes the thread index\n+  // Returns an integer ID that will be used to reference the task group in\n+  // StartTaskGroup. At runtime, call StartTaskGroup with the ID and the number of times\n+  // you'd like the task to be executed. The need to register a task group before use will\n+  // be removed after we rewrite the scheduler.\n+  /// \\brief Registers a \"parallel for\" task group with the scheduler\n+  ///\n+  /// \\param task The function implementing the task. Takes the thread_index and\n+  ///             the task index.\n+  /// \\param on_finished The function that gets run once all tasks have been completed.\n+  /// Takes\n+  ///                    the thread_index.\n+  ///\n+  /// Must be called inside of ExecNode::Init.\n+  int RegisterTaskGroup(std::function<Status(size_t, int64_t)> task,\n+                        std::function<Status(size_t)> on_finished);\n+\n+  /// \\brief Starts the task group with the specified ID\n+  ///\n+  /// \\param task_group_id The ID  of the task group to run\n+  /// \\param num_tasks The number of times to run the task\n+  Status StartTaskGroup(int task_group_id, int64_t num_tasks);\n\nReview Comment:\n   Can this be called more than once per registered task group (I wouldn't think so but it might not hurt to mention this explicitly)\n\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_node.cc:\n##########\n@@ -894,25 +898,42 @@ class HashJoinNode : public ExecNode {\n     }\n   }\n \n-  Status PrepareToProduce() override {\n+  Status Init() override {\n+    RETURN_NOT_OK(ExecNode::Init());\n     bool use_sync_execution = !(plan_->exec_context()->executor());\n     // TODO(ARROW-15732)\n     // Each side of join might have an IO thread being called from. Once this is fixed\n     // we will change it back to just the CPU's thread pool capacity.\n     size_t num_threads = (GetCpuThreadPoolCapacity() + io::GetIOThreadPoolCapacity() + 1);\n\nReview Comment:\n   Should this be a call to max_concurrency?\n\n\n\n",
                    "created": "2022-07-11T20:25:06.911+0000",
                    "updated": "2022-07-11T20:25:06.911+0000",
                    "started": "2022-07-11T20:25:06.911+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789731",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/789737",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r918343203\n\n\n##########\ncpp/src/arrow/compute/exec/hash_join_node.cc:\n##########\n@@ -894,25 +898,42 @@ class HashJoinNode : public ExecNode {\n     }\n   }\n \n-  Status PrepareToProduce() override {\n+  Status Init() override {\n+    RETURN_NOT_OK(ExecNode::Init());\n     bool use_sync_execution = !(plan_->exec_context()->executor());\n     // TODO(ARROW-15732)\n     // Each side of join might have an IO thread being called from. Once this is fixed\n     // we will change it back to just the CPU's thread pool capacity.\n     size_t num_threads = (GetCpuThreadPoolCapacity() + io::GetIOThreadPoolCapacity() + 1);\n\nReview Comment:\n   Eventually, it will be `max_concurrency` when ARROW-15732 is fixed (since `max_concurrency` only returns GetCpuThreadPoolCapacity). \n\n\n\n",
                    "created": "2022-07-11T20:56:20.273+0000",
                    "updated": "2022-07-11T20:56:20.273+0000",
                    "started": "2022-07-11T20:56:20.273+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789737",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/789738",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r918344951\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,63 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  /// \\brief Returns the index of the current thread.\n+  size_t GetThreadIndex();\n+  /// \\brief Returns the maximum number of threads that the plan could use.\n+  ///\n+  /// GetThreadIndex will always return something less than this, so it is safe to\n+  /// e.g. make an array of thread-locals off this.\n+  size_t max_concurrency() const;\n+\n+  // The below API interfaces with the scheduler to add tasks to the task group. Tasks\n+  // should be added sparingly! Prefer just doing the work immediately rather than adding\n+  // a task for it. Tasks are used in pipeline breakers that may output many more rows\n+  // than they received (such as a full outer join).\n+  //\n+  //\n+  /// \\brief Adds a future to the plan's task group.\n+  ///\n+  /// \\param fut The future to add\n+  ///\n+  /// Use this when interfacing with anything that returns a future (such as IO), but\n+  /// prefer ScheduleTask/StartTaskGroup inside of\n+  /// ExecNodes.\n+  Status AddFuture(Future<> fut);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes no arguments and returns a Status.\n+  Status ScheduleTask(std::function<Status()> fn);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes the thread index and returns a Status.\n+  Status ScheduleTask(std::function<Status(size_t)> fn);\n\nReview Comment:\n   Nope, these are just used for spawning general tasks within the plan. \n\n\n\n",
                    "created": "2022-07-11T20:58:45.594+0000",
                    "updated": "2022-07-11T20:58:45.594+0000",
                    "started": "2022-07-11T20:58:45.594+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789738",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/789739",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r918346131\n\n\n##########\ncpp/src/arrow/compute/exec/exec_plan.h:\n##########\n@@ -61,6 +61,63 @@ class ARROW_EXPORT ExecPlan : public std::enable_shared_from_this<ExecPlan> {\n     return out;\n   }\n \n+  /// \\brief Returns the index of the current thread.\n+  size_t GetThreadIndex();\n+  /// \\brief Returns the maximum number of threads that the plan could use.\n+  ///\n+  /// GetThreadIndex will always return something less than this, so it is safe to\n+  /// e.g. make an array of thread-locals off this.\n+  size_t max_concurrency() const;\n+\n+  // The below API interfaces with the scheduler to add tasks to the task group. Tasks\n+  // should be added sparingly! Prefer just doing the work immediately rather than adding\n+  // a task for it. Tasks are used in pipeline breakers that may output many more rows\n+  // than they received (such as a full outer join).\n+  //\n+  //\n+  /// \\brief Adds a future to the plan's task group.\n+  ///\n+  /// \\param fut The future to add\n+  ///\n+  /// Use this when interfacing with anything that returns a future (such as IO), but\n+  /// prefer ScheduleTask/StartTaskGroup inside of\n+  /// ExecNodes.\n+  Status AddFuture(Future<> fut);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes no arguments and returns a Status.\n+  Status ScheduleTask(std::function<Status()> fn);\n+\n+  /// \\brief Adds a single function as a task to the plan's task group.\n+  ///\n+  /// \\param fn The task to run. Takes the thread index and returns a Status.\n+  Status ScheduleTask(std::function<Status(size_t)> fn);\n\nReview Comment:\n   Oh I see what you mean, yes they should be used sparingly. The guidance is still warranted (i.e. try to do one task per pipeline, only break the pipeline by adding a task if you have to). \n\n\n\n",
                    "created": "2022-07-11T21:00:30.778+0000",
                    "updated": "2022-07-11T21:00:30.778+0000",
                    "started": "2022-07-11T21:00:30.777+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789739",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/789740",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on code in PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#discussion_r918350576\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -196,17 +186,16 @@ struct SourceNode : ExecNode {\n   void StopProducing() override {\n     std::unique_lock<std::mutex> lock(mutex_);\n     stop_requested_ = true;\n+    if (!started_) finished_.MarkFinished();\n\nReview Comment:\n   Yes, that's what I'm guarding against. Part 2 of the refactor will fix this weirdness, but essentially if we encounter an error during `StartProducing`, we call `StopProducing` of every node that has been started. These nodes then call `StopProducing` on their inputs, which ends up propagating down to the `SourceNode`. \r\n   \r\n   Part2 will get rid of this `StopProducing` spam by having each node have an `Abort` method which will be called once by the plan. Nodes will not be calling `Abort` on each other. \n\n\n\n",
                    "created": "2022-07-11T21:07:01.636+0000",
                    "updated": "2022-07-11T21:07:01.636+0000",
                    "started": "2022-07-11T21:07:01.636+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "789740",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/791109",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "save-buffer commented on PR #13143:\nURL: https://github.com/apache/arrow/pull/13143#issuecomment-1184828207\n\n   Looks like the only failure was this, so this is probably green. \r\n   ```\r\n   Issue another request to this URL:\r\n   [2068](https://github.com/apache/arrow/runs/7330179393?check_suite_focus=true#step:8:2069)\r\n     'https://codeload.github.com/abseil/abseil-cpp/tar.gz/refs/tags/20211102.0'\r\n   [2069](https://github.com/apache/arrow/runs/7330179393?check_suite_focus=true#step:8:2070)\r\n   [2070](https://github.com/apache/arrow/runs/7330179393?check_suite_focus=true#step:8:2071)\r\n   [2071](https://github.com/apache/arrow/runs/7330179393?check_suite_focus=true#step:8:2072)\r\n     timeout on name lookup is not supported\r\n   [2072](https://github.com/apache/arrow/runs/7330179393?check_suite_focus=true#step:8:2073)\r\n   ```\n\n\n",
                    "created": "2022-07-14T19:40:11.264+0000",
                    "updated": "2022-07-14T19:40:11.264+0000",
                    "started": "2022-07-14T19:40:11.264+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "791109",
                    "issueId": "13444282"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/worklog/791180",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace merged PR #13143:\nURL: https://github.com/apache/arrow/pull/13143\n\n\n",
                    "created": "2022-07-14T23:11:48.673+0000",
                    "updated": "2022-07-14T23:11:48.673+0000",
                    "started": "2022-07-14T23:11:48.672+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "791180",
                    "issueId": "13444282"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 14400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1d3bba3f[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1f313a47[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@574e8a08[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@413b71a4[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3ac01586[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@c968aaf[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2f2b4fff[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3507adef[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@fd1f2ec[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@372ac24b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@420b27e6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4aeb929d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 14400,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Jul 14 23:11:49 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-07-14T23:11:49.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-16523/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2022-05-11T02:10:06.000+0000",
        "updated": "2022-07-15T14:30:31.000+0000",
        "timeoriginalestimate": null,
        "description": "Source nodes and pipeline breakers need to schedule new thread tasks.  These tasks run entire fused pipelines (e.g. the thread task could be thought of as analogous to a \"driver\" in some other models).\r\n\r\nAt the moment every node that needs to schedule tasks (scan node, hash-join node, aggregate node, etc.) handles this independently.  The result is a lot of similar looking code and bugs like ARROW-15221 where one node takes care of cleanup but another doesn't.\r\n\r\nWe can centralize this by moving this scheduling into the ExecPlan itself and giving nodes an ability to schedule tasks via the ExecPlan.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 14400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Move ExecPlan scheduling into the plan",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13444282/comment/17567027",
                    "id": "17567027",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 13143\n[https://github.com/apache/arrow/pull/13143]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-07-14T23:11:49.774+0000",
                    "updated": "2022-07-14T23:11:49.774+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z128y0:",
        "customfield_12314139": null
    }
}