{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13296475",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475",
    "key": "ARROW-8344",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12347769",
                "id": "12347769",
                "description": "",
                "name": "1.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-07-24"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12340948",
                "id": "12340948",
                "description": "",
                "name": "0.16.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-02-07"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": null,
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334712",
                "id": "12334712",
                "name": "C#"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=mr_smidge",
            "name": "mr_smidge",
            "key": "mr_smidge",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=mr_smidge&avatarId=42832",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=mr_smidge&avatarId=42832",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=mr_smidge&avatarId=42832",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=mr_smidge&avatarId=42832"
            },
            "displayName": "Adam Szmigin",
            "active": true,
            "timeZone": "Europe/London"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=mr_smidge",
            "name": "mr_smidge",
            "key": "mr_smidge",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=mr_smidge&avatarId=42832",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=mr_smidge&avatarId=42832",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=mr_smidge&avatarId=42832",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=mr_smidge&avatarId=42832"
            },
            "displayName": "Adam Szmigin",
            "active": true,
            "timeZone": "Europe/London"
        },
        "aggregateprogress": {
            "progress": 9000,
            "total": 9000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 9000,
            "total": 9000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8344/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 15,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/455776",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mr-smidge opened a new pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671\n\n\n   This PR fixes a few bugs in `BinaryArray.Builder()`:\r\n   * Fixes the `Clear()` method, which previously would break all subsequently-appended values (see JIRA ticket for examples).\r\n   * Makes the `Build()` method idempotent, by making sure the builder's internal arrays are not modified when it is called.\r\n   \r\n   And makes a few other improvements:\r\n   * Comprehensive test coverage of the builder's key methods (this was written in proper TDD-style, so these tests would fail if run on `master`).\r\n   * XML docstrings for all methods affected.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-08T00:21:18.761+0000",
                    "updated": "2020-07-08T00:21:18.761+0000",
                    "started": "2020-07-08T00:21:18.761+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "455776",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/455777",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mr-smidge commented on a change in pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#discussion_r451214556\n\n\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -66,87 +66,158 @@ protected BuilderBase(IArrowType dataType)\n                 ValueOffsets = new ArrowBuffer.Builder<int>();\n                 ValueBuffer = new ArrowBuffer.Builder<byte>();\n                 ValidityBuffer = new ArrowBuffer.BitmapBuilder();\n+\n+                // From the docs:\n+                //\n+                // The offsets buffer contains length + 1 signed integers (either 32-bit or 64-bit, depending on the\n+                // logical type), which encode the start position of each slot in the data buffer. The length of the\n+                // value in each slot is computed using the difference between the offset at that slot\u2019s index and the\n+                // subsequent offset.\n+                //\n+                // In this builder, we choose to append the first offset (zero) upon construction, and each trailing\n+                // offset is then added after each individual item has been appended.\n+                ValueOffsets.Append(this.Offset);\n\nReview comment:\n       For an array with N items, there need to be N+1 offset values written.\r\n   \r\n   Previously, an offset was written with each `Append*()` call, with the extra one written when calling `Build()`.  This PR flips this around to add the extra offset upon construction (or calling `Clear()`), with the others written post-hoc during `Append*()` calls.  As such, `Build()` is now idempotent.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-08T00:23:24.335+0000",
                    "updated": "2020-07-08T00:23:24.335+0000",
                    "started": "2020-07-08T00:23:24.335+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "455777",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/455779",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mr-smidge commented on a change in pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#discussion_r451215414\n\n\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -66,87 +66,158 @@ protected BuilderBase(IArrowType dataType)\n                 ValueOffsets = new ArrowBuffer.Builder<int>();\n                 ValueBuffer = new ArrowBuffer.Builder<byte>();\n                 ValidityBuffer = new ArrowBuffer.BitmapBuilder();\n+\n+                // From the docs:\n+                //\n+                // The offsets buffer contains length + 1 signed integers (either 32-bit or 64-bit, depending on the\n+                // logical type), which encode the start position of each slot in the data buffer. The length of the\n+                // value in each slot is computed using the difference between the offset at that slot\u2019s index and the\n+                // subsequent offset.\n+                //\n+                // In this builder, we choose to append the first offset (zero) upon construction, and each trailing\n+                // offset is then added after each individual item has been appended.\n+                ValueOffsets.Append(this.Offset);\n             }\n \n             protected abstract TArray Build(ArrayData data);\n \n-            public int Length => ValueOffsets.Length;\n+            /// <summary>\n+            /// Gets the length of the array built so far.\n+            /// </summary>\n+            public int Length => ValueOffsets.Length - 1;\n \n+            /// <summary>\n+            /// Build an Arrow array from the appended contents so far.\n+            /// </summary>\n+            /// <param name=\"allocator\">Optional memory allocator.</param>\n+            /// <returns>Returns an array of type <typeparamref name=\"TArray\"/>.</returns>\n             public TArray Build(MemoryAllocator allocator = default)\n             {\n-                ValueOffsets.Append(Offset);\n-\n-                ArrowBuffer validityBuffer = NullCount > 0\n-                                        ? ValidityBuffer.Build(allocator)\n-                                        : ArrowBuffer.Empty;\n-\n-                var data = new ArrayData(DataType, ValueOffsets.Length - 1, NullCount, 0,\n-                    new[] { validityBuffer, ValueOffsets.Build(allocator), ValueBuffer.Build(allocator) });\n+                var bufs = new[]\n+                {\n+                    NullCount > 0 ? ValidityBuffer.Build(allocator) : ArrowBuffer.Empty,\n+                    ValueOffsets.Build(allocator),\n+                    ValueBuffer.Build(allocator),\n+                };\n+                var data = new ArrayData(\n+                    DataType,\n+                    length: ValueOffsets.Length - 1,\n+                    NullCount,\n+                    offset: 0,\n+                    bufs);\n \n                 return Build(data);\n             }\n \n+            /// <summary>\n+            /// Append a single null value to the array.\n+            /// </summary>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendNull()\n             {\n-                ValueOffsets.Append(Offset);\n+                // Do not add to the value buffer in the case of a null.\n+                // Note that we do not need to increment the offset as a result.\n                 ValidityBuffer.Append(false);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Appends a value, consisting of a single byte, to the array.\n+            /// </summary>\n+            /// <param name=\"value\">Byte value to append.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(byte value)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(value);\n-                Offset++;\n                 ValidityBuffer.Append(true);\n+                Offset++;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append a value, consisting of a span of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that a single value is added, which consists of arbitrarily many bytes.  If multiple values are\n+            /// to be added, use the <see cref=\"AppendRange\"/> method.\n+            /// </remarks>\n+            /// <param name=\"span\">Span of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(ReadOnlySpan<byte> span)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(span);\n                 ValidityBuffer.Append(true);\n                 Offset += span.Length;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n-            public TBuilder AppendRange(IEnumerable<byte[]> values)\n+            /// <summary>\n+            /// Append a value, consisting of an enumerable collection of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends a single value, which may consist of arbitrarily many bytes.  If multiple\n+            /// values are to be added, use the <see cref=\"AppendRange(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"value\">Enumerable collection of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n+            public TBuilder Append(IEnumerable<byte> value)\n             {\n-                foreach (byte[] arr in values)\n+                if (value == null)\n                 {\n-                    if (arr == null)\n-                    {\n-                        AppendNull();\n-                        continue;\n-                    }\n-                    int len = ValueBuffer.Length;\n-                    ValueOffsets.Append(Offset);\n-                    ValueBuffer.Append(arr);\n-                    ValidityBuffer.Append(true);\n-                    Offset += ValueBuffer.Length - len;\n+                    return AppendNull();\n                 }\n \n+                // Note: by looking at the length of the value buffer before and after, we avoid having to iterate\n+                // through the enumerable multiple times to get both length and contents.\n+                int priorLength = ValueBuffer.Length;\n+                ValueBuffer.AppendRange(value);\n+                int valueLength = ValueBuffer.Length - priorLength;\n+                Offset += valueLength;\n+                ValidityBuffer.Append(true);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append an enumerable collection of single-byte values to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends multiple values, each of which is a single byte.  If a single value is\n+            /// to be added, use the <see cref=\"Append(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"values\">Single-byte values to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendRange(IEnumerable<byte> values)\n\nReview comment:\n       This `AppendRange(IEnumerable<byte>)` method previously did the \"wrong thing\": it was called `AppendRange()`, but it didn't add a range of values.  Instead, it added a single value.\r\n   \r\n   This method now does what one would expect when calling `AppendRange()`, and adds a range of values (each of which is a single byte).  The original method behaviour is now available via `Append(IEnumerable<byte>)` instead.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-08T00:26:53.045+0000",
                    "updated": "2020-07-08T00:26:53.045+0000",
                    "started": "2020-07-08T00:26:53.045+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "455779",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/455780",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mr-smidge commented on a change in pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#discussion_r451215646\n\n\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -173,11 +245,19 @@ public TBuilder Set(int index, byte value)\n                 throw new NotImplementedException();\n             }\n \n+            /// <summary>\n+            /// Clear all contents appended so far.\n+            /// </summary>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Clear()\n             {\n                 ValueOffsets.Clear();\n                 ValueBuffer.Clear();\n                 ValidityBuffer.Clear();\n+\n+                // Always write the first offset before anything has been written.\n+                Offset = 0;\n\nReview comment:\n       Not resetting the `Offset` member variable was the root cause of the string-clearing bug referenced in ARROW-8344.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-08T00:27:37.936+0000",
                    "updated": "2020-07-08T00:27:37.936+0000",
                    "started": "2020-07-08T00:27:37.936+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "455780",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/455782",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mr-smidge commented on a change in pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#discussion_r451216615\n\n\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -237,7 +329,9 @@ public ReadOnlySpan<byte> GetBytes(int index)\n \n             if (IsNull(index))\n             {\n-                return null;\n+                // Note that `return null;` is valid syntax, but would be misleading as `null` in the context of a span\n+                // is actually returned as an empty span.\n+                return ReadOnlySpan<byte>.Empty;\n\nReview comment:\n       This clause previously said `return null;`, which was misleading as it suggested that the method could be used to identify null values in the array.  However, `null` in the context of a `ReadOnlySpan<T>` is the same as the empty span, and so the method can't distinguish null values from empty ones:\r\n   \r\n   ```csharp\r\n   Assert.True(ReadOnlySpan<byte>.Empty == null)\r\n   ```\r\n   \r\n   The new code is clearer in intent.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-08T00:31:41.083+0000",
                    "updated": "2020-07-08T00:31:41.083+0000",
                    "started": "2020-07-08T00:31:41.082+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "455782",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/455785",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#issuecomment-655212330\n\n\n   https://issues.apache.org/jira/browse/ARROW-8344\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-08T00:39:44.943+0000",
                    "updated": "2020-07-08T00:39:44.943+0000",
                    "started": "2020-07-08T00:39:44.942+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "455785",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/457321",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "eerhardt commented on a change in pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#discussion_r453038089\n\n\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -66,87 +66,158 @@ protected BuilderBase(IArrowType dataType)\n                 ValueOffsets = new ArrowBuffer.Builder<int>();\n                 ValueBuffer = new ArrowBuffer.Builder<byte>();\n                 ValidityBuffer = new ArrowBuffer.BitmapBuilder();\n+\n+                // From the docs:\n+                //\n+                // The offsets buffer contains length + 1 signed integers (either 32-bit or 64-bit, depending on the\n+                // logical type), which encode the start position of each slot in the data buffer. The length of the\n+                // value in each slot is computed using the difference between the offset at that slot\u2019s index and the\n+                // subsequent offset.\n+                //\n+                // In this builder, we choose to append the first offset (zero) upon construction, and each trailing\n+                // offset is then added after each individual item has been appended.\n+                ValueOffsets.Append(this.Offset);\n\nReview comment:\n       Nice fix.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-10T19:27:29.491+0000",
                    "updated": "2020-07-10T19:27:29.491+0000",
                    "started": "2020-07-10T19:27:29.491+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "457321",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/457324",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "eerhardt commented on a change in pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#discussion_r453042194\n\n\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -237,7 +329,9 @@ public ReadOnlySpan<byte> GetBytes(int index)\n \n             if (IsNull(index))\n             {\n-                return null;\n+                // Note that `return null;` is valid syntax, but would be misleading as `null` in the context of a span\n+                // is actually returned as an empty span.\n+                return ReadOnlySpan<byte>.Empty;\n\nReview comment:\n       I've been confused and bit by this a few times in different projects. All the following ways produce an \"equivalent\" span:\r\n   \r\n   * `return null`  (this uses the implicit operator from an array)\r\n   * `return default`\r\n   * `return ReadOnlySpan<T>.Empty`  (this just says `return default` underneath the covers)\r\n   \r\n   I agree that `ReadOnlySpan<T>.Empty` is the most clear thing to return here. Next would be `return default`. `return null` is the worst of the three options IMO.\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -66,87 +66,158 @@ protected BuilderBase(IArrowType dataType)\n                 ValueOffsets = new ArrowBuffer.Builder<int>();\n                 ValueBuffer = new ArrowBuffer.Builder<byte>();\n                 ValidityBuffer = new ArrowBuffer.BitmapBuilder();\n+\n+                // From the docs:\n+                //\n+                // The offsets buffer contains length + 1 signed integers (either 32-bit or 64-bit, depending on the\n+                // logical type), which encode the start position of each slot in the data buffer. The length of the\n+                // value in each slot is computed using the difference between the offset at that slot\u2019s index and the\n+                // subsequent offset.\n+                //\n+                // In this builder, we choose to append the first offset (zero) upon construction, and each trailing\n+                // offset is then added after each individual item has been appended.\n+                ValueOffsets.Append(this.Offset);\n             }\n \n             protected abstract TArray Build(ArrayData data);\n \n-            public int Length => ValueOffsets.Length;\n+            /// <summary>\n+            /// Gets the length of the array built so far.\n+            /// </summary>\n+            public int Length => ValueOffsets.Length - 1;\n \n+            /// <summary>\n+            /// Build an Arrow array from the appended contents so far.\n+            /// </summary>\n+            /// <param name=\"allocator\">Optional memory allocator.</param>\n+            /// <returns>Returns an array of type <typeparamref name=\"TArray\"/>.</returns>\n             public TArray Build(MemoryAllocator allocator = default)\n             {\n-                ValueOffsets.Append(Offset);\n-\n-                ArrowBuffer validityBuffer = NullCount > 0\n-                                        ? ValidityBuffer.Build(allocator)\n-                                        : ArrowBuffer.Empty;\n-\n-                var data = new ArrayData(DataType, ValueOffsets.Length - 1, NullCount, 0,\n-                    new[] { validityBuffer, ValueOffsets.Build(allocator), ValueBuffer.Build(allocator) });\n+                var bufs = new[]\n+                {\n+                    NullCount > 0 ? ValidityBuffer.Build(allocator) : ArrowBuffer.Empty,\n+                    ValueOffsets.Build(allocator),\n+                    ValueBuffer.Build(allocator),\n+                };\n+                var data = new ArrayData(\n+                    DataType,\n+                    length: ValueOffsets.Length - 1,\n\nReview comment:\n       Can this line just be `Length` ?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-10T19:37:30.135+0000",
                    "updated": "2020-07-10T19:37:30.135+0000",
                    "started": "2020-07-10T19:37:30.134+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "457324",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/457332",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "eerhardt commented on a change in pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#discussion_r453045241\n\n\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -66,87 +66,158 @@ protected BuilderBase(IArrowType dataType)\n                 ValueOffsets = new ArrowBuffer.Builder<int>();\n                 ValueBuffer = new ArrowBuffer.Builder<byte>();\n                 ValidityBuffer = new ArrowBuffer.BitmapBuilder();\n+\n+                // From the docs:\n+                //\n+                // The offsets buffer contains length + 1 signed integers (either 32-bit or 64-bit, depending on the\n+                // logical type), which encode the start position of each slot in the data buffer. The length of the\n+                // value in each slot is computed using the difference between the offset at that slot\u2019s index and the\n+                // subsequent offset.\n+                //\n+                // In this builder, we choose to append the first offset (zero) upon construction, and each trailing\n+                // offset is then added after each individual item has been appended.\n+                ValueOffsets.Append(this.Offset);\n             }\n \n             protected abstract TArray Build(ArrayData data);\n \n-            public int Length => ValueOffsets.Length;\n+            /// <summary>\n+            /// Gets the length of the array built so far.\n+            /// </summary>\n+            public int Length => ValueOffsets.Length - 1;\n \n+            /// <summary>\n+            /// Build an Arrow array from the appended contents so far.\n+            /// </summary>\n+            /// <param name=\"allocator\">Optional memory allocator.</param>\n+            /// <returns>Returns an array of type <typeparamref name=\"TArray\"/>.</returns>\n             public TArray Build(MemoryAllocator allocator = default)\n             {\n-                ValueOffsets.Append(Offset);\n-\n-                ArrowBuffer validityBuffer = NullCount > 0\n-                                        ? ValidityBuffer.Build(allocator)\n-                                        : ArrowBuffer.Empty;\n-\n-                var data = new ArrayData(DataType, ValueOffsets.Length - 1, NullCount, 0,\n-                    new[] { validityBuffer, ValueOffsets.Build(allocator), ValueBuffer.Build(allocator) });\n+                var bufs = new[]\n+                {\n+                    NullCount > 0 ? ValidityBuffer.Build(allocator) : ArrowBuffer.Empty,\n+                    ValueOffsets.Build(allocator),\n+                    ValueBuffer.Build(allocator),\n+                };\n+                var data = new ArrayData(\n+                    DataType,\n+                    length: ValueOffsets.Length - 1,\n+                    NullCount,\n+                    offset: 0,\n+                    bufs);\n \n                 return Build(data);\n             }\n \n+            /// <summary>\n+            /// Append a single null value to the array.\n+            /// </summary>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendNull()\n             {\n-                ValueOffsets.Append(Offset);\n+                // Do not add to the value buffer in the case of a null.\n+                // Note that we do not need to increment the offset as a result.\n                 ValidityBuffer.Append(false);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Appends a value, consisting of a single byte, to the array.\n+            /// </summary>\n+            /// <param name=\"value\">Byte value to append.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(byte value)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(value);\n-                Offset++;\n                 ValidityBuffer.Append(true);\n+                Offset++;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append a value, consisting of a span of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that a single value is added, which consists of arbitrarily many bytes.  If multiple values are\n+            /// to be added, use the <see cref=\"AppendRange\"/> method.\n+            /// </remarks>\n+            /// <param name=\"span\">Span of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(ReadOnlySpan<byte> span)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(span);\n                 ValidityBuffer.Append(true);\n                 Offset += span.Length;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n-            public TBuilder AppendRange(IEnumerable<byte[]> values)\n+            /// <summary>\n+            /// Append a value, consisting of an enumerable collection of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends a single value, which may consist of arbitrarily many bytes.  If multiple\n+            /// values are to be added, use the <see cref=\"AppendRange(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"value\">Enumerable collection of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n+            public TBuilder Append(IEnumerable<byte> value)\n             {\n-                foreach (byte[] arr in values)\n+                if (value == null)\n                 {\n-                    if (arr == null)\n-                    {\n-                        AppendNull();\n-                        continue;\n-                    }\n-                    int len = ValueBuffer.Length;\n-                    ValueOffsets.Append(Offset);\n-                    ValueBuffer.Append(arr);\n-                    ValidityBuffer.Append(true);\n-                    Offset += ValueBuffer.Length - len;\n+                    return AppendNull();\n                 }\n \n+                // Note: by looking at the length of the value buffer before and after, we avoid having to iterate\n+                // through the enumerable multiple times to get both length and contents.\n+                int priorLength = ValueBuffer.Length;\n+                ValueBuffer.AppendRange(value);\n+                int valueLength = ValueBuffer.Length - priorLength;\n+                Offset += valueLength;\n+                ValidityBuffer.Append(true);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append an enumerable collection of single-byte values to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends multiple values, each of which is a single byte.  If a single value is\n+            /// to be added, use the <see cref=\"Append(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"values\">Single-byte values to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendRange(IEnumerable<byte> values)\n             {\n-                if (values == null)\n+                foreach (byte b in values)\n                 {\n-                    return AppendNull();\n+                    Append(b);\n                 }\n-                int len = ValueBuffer.Length;\n-                ValueBuffer.AppendRange(values);\n-                int valOffset = ValueBuffer.Length - len;\n-                ValueOffsets.Append(Offset);\n-                Offset += valOffset;\n-                ValidityBuffer.Append(true);\n+\n+                return Instance;\n+            }\n+\n+            /// <summary>\n+            /// Append an enumerable collection of values to the array.\n+            /// </summary>\n+            /// <param name=\"values\">Values to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n+            public TBuilder AppendRange(IEnumerable<byte[]> values)\n+            {\n+                foreach (byte[] arr in values)\n\nReview comment:\n       This will throw a `NullReferenceException` if `values` is `null`.\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -66,87 +66,158 @@ protected BuilderBase(IArrowType dataType)\n                 ValueOffsets = new ArrowBuffer.Builder<int>();\n                 ValueBuffer = new ArrowBuffer.Builder<byte>();\n                 ValidityBuffer = new ArrowBuffer.BitmapBuilder();\n+\n+                // From the docs:\n+                //\n+                // The offsets buffer contains length + 1 signed integers (either 32-bit or 64-bit, depending on the\n+                // logical type), which encode the start position of each slot in the data buffer. The length of the\n+                // value in each slot is computed using the difference between the offset at that slot\u2019s index and the\n+                // subsequent offset.\n+                //\n+                // In this builder, we choose to append the first offset (zero) upon construction, and each trailing\n+                // offset is then added after each individual item has been appended.\n+                ValueOffsets.Append(this.Offset);\n             }\n \n             protected abstract TArray Build(ArrayData data);\n \n-            public int Length => ValueOffsets.Length;\n+            /// <summary>\n+            /// Gets the length of the array built so far.\n+            /// </summary>\n+            public int Length => ValueOffsets.Length - 1;\n \n+            /// <summary>\n+            /// Build an Arrow array from the appended contents so far.\n+            /// </summary>\n+            /// <param name=\"allocator\">Optional memory allocator.</param>\n+            /// <returns>Returns an array of type <typeparamref name=\"TArray\"/>.</returns>\n             public TArray Build(MemoryAllocator allocator = default)\n             {\n-                ValueOffsets.Append(Offset);\n-\n-                ArrowBuffer validityBuffer = NullCount > 0\n-                                        ? ValidityBuffer.Build(allocator)\n-                                        : ArrowBuffer.Empty;\n-\n-                var data = new ArrayData(DataType, ValueOffsets.Length - 1, NullCount, 0,\n-                    new[] { validityBuffer, ValueOffsets.Build(allocator), ValueBuffer.Build(allocator) });\n+                var bufs = new[]\n+                {\n+                    NullCount > 0 ? ValidityBuffer.Build(allocator) : ArrowBuffer.Empty,\n+                    ValueOffsets.Build(allocator),\n+                    ValueBuffer.Build(allocator),\n+                };\n+                var data = new ArrayData(\n+                    DataType,\n+                    length: ValueOffsets.Length - 1,\n+                    NullCount,\n+                    offset: 0,\n+                    bufs);\n \n                 return Build(data);\n             }\n \n+            /// <summary>\n+            /// Append a single null value to the array.\n+            /// </summary>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendNull()\n             {\n-                ValueOffsets.Append(Offset);\n+                // Do not add to the value buffer in the case of a null.\n+                // Note that we do not need to increment the offset as a result.\n                 ValidityBuffer.Append(false);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Appends a value, consisting of a single byte, to the array.\n+            /// </summary>\n+            /// <param name=\"value\">Byte value to append.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(byte value)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(value);\n-                Offset++;\n                 ValidityBuffer.Append(true);\n+                Offset++;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append a value, consisting of a span of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that a single value is added, which consists of arbitrarily many bytes.  If multiple values are\n+            /// to be added, use the <see cref=\"AppendRange\"/> method.\n+            /// </remarks>\n+            /// <param name=\"span\">Span of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(ReadOnlySpan<byte> span)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(span);\n                 ValidityBuffer.Append(true);\n                 Offset += span.Length;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n-            public TBuilder AppendRange(IEnumerable<byte[]> values)\n+            /// <summary>\n+            /// Append a value, consisting of an enumerable collection of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends a single value, which may consist of arbitrarily many bytes.  If multiple\n+            /// values are to be added, use the <see cref=\"AppendRange(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"value\">Enumerable collection of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n+            public TBuilder Append(IEnumerable<byte> value)\n             {\n-                foreach (byte[] arr in values)\n+                if (value == null)\n                 {\n-                    if (arr == null)\n-                    {\n-                        AppendNull();\n-                        continue;\n-                    }\n-                    int len = ValueBuffer.Length;\n-                    ValueOffsets.Append(Offset);\n-                    ValueBuffer.Append(arr);\n-                    ValidityBuffer.Append(true);\n-                    Offset += ValueBuffer.Length - len;\n+                    return AppendNull();\n                 }\n \n+                // Note: by looking at the length of the value buffer before and after, we avoid having to iterate\n+                // through the enumerable multiple times to get both length and contents.\n+                int priorLength = ValueBuffer.Length;\n+                ValueBuffer.AppendRange(value);\n+                int valueLength = ValueBuffer.Length - priorLength;\n+                Offset += valueLength;\n+                ValidityBuffer.Append(true);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append an enumerable collection of single-byte values to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends multiple values, each of which is a single byte.  If a single value is\n+            /// to be added, use the <see cref=\"Append(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"values\">Single-byte values to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendRange(IEnumerable<byte> values)\n             {\n-                if (values == null)\n+                foreach (byte b in values)\n\nReview comment:\n       This will throw a `NullReferenceException` if `values` is `null`.\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -66,87 +66,158 @@ protected BuilderBase(IArrowType dataType)\n                 ValueOffsets = new ArrowBuffer.Builder<int>();\n                 ValueBuffer = new ArrowBuffer.Builder<byte>();\n                 ValidityBuffer = new ArrowBuffer.BitmapBuilder();\n+\n+                // From the docs:\n+                //\n+                // The offsets buffer contains length + 1 signed integers (either 32-bit or 64-bit, depending on the\n+                // logical type), which encode the start position of each slot in the data buffer. The length of the\n+                // value in each slot is computed using the difference between the offset at that slot\u2019s index and the\n+                // subsequent offset.\n+                //\n+                // In this builder, we choose to append the first offset (zero) upon construction, and each trailing\n+                // offset is then added after each individual item has been appended.\n+                ValueOffsets.Append(this.Offset);\n             }\n \n             protected abstract TArray Build(ArrayData data);\n \n-            public int Length => ValueOffsets.Length;\n+            /// <summary>\n+            /// Gets the length of the array built so far.\n+            /// </summary>\n+            public int Length => ValueOffsets.Length - 1;\n \n+            /// <summary>\n+            /// Build an Arrow array from the appended contents so far.\n+            /// </summary>\n+            /// <param name=\"allocator\">Optional memory allocator.</param>\n+            /// <returns>Returns an array of type <typeparamref name=\"TArray\"/>.</returns>\n             public TArray Build(MemoryAllocator allocator = default)\n             {\n-                ValueOffsets.Append(Offset);\n-\n-                ArrowBuffer validityBuffer = NullCount > 0\n-                                        ? ValidityBuffer.Build(allocator)\n-                                        : ArrowBuffer.Empty;\n-\n-                var data = new ArrayData(DataType, ValueOffsets.Length - 1, NullCount, 0,\n-                    new[] { validityBuffer, ValueOffsets.Build(allocator), ValueBuffer.Build(allocator) });\n+                var bufs = new[]\n+                {\n+                    NullCount > 0 ? ValidityBuffer.Build(allocator) : ArrowBuffer.Empty,\n+                    ValueOffsets.Build(allocator),\n+                    ValueBuffer.Build(allocator),\n+                };\n+                var data = new ArrayData(\n+                    DataType,\n+                    length: ValueOffsets.Length - 1,\n+                    NullCount,\n+                    offset: 0,\n+                    bufs);\n \n                 return Build(data);\n             }\n \n+            /// <summary>\n+            /// Append a single null value to the array.\n+            /// </summary>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendNull()\n             {\n-                ValueOffsets.Append(Offset);\n+                // Do not add to the value buffer in the case of a null.\n+                // Note that we do not need to increment the offset as a result.\n                 ValidityBuffer.Append(false);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Appends a value, consisting of a single byte, to the array.\n+            /// </summary>\n+            /// <param name=\"value\">Byte value to append.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(byte value)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(value);\n-                Offset++;\n                 ValidityBuffer.Append(true);\n+                Offset++;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append a value, consisting of a span of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that a single value is added, which consists of arbitrarily many bytes.  If multiple values are\n+            /// to be added, use the <see cref=\"AppendRange\"/> method.\n+            /// </remarks>\n+            /// <param name=\"span\">Span of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(ReadOnlySpan<byte> span)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(span);\n                 ValidityBuffer.Append(true);\n                 Offset += span.Length;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n-            public TBuilder AppendRange(IEnumerable<byte[]> values)\n+            /// <summary>\n+            /// Append a value, consisting of an enumerable collection of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends a single value, which may consist of arbitrarily many bytes.  If multiple\n+            /// values are to be added, use the <see cref=\"AppendRange(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"value\">Enumerable collection of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n+            public TBuilder Append(IEnumerable<byte> value)\n             {\n-                foreach (byte[] arr in values)\n+                if (value == null)\n                 {\n-                    if (arr == null)\n-                    {\n-                        AppendNull();\n-                        continue;\n-                    }\n-                    int len = ValueBuffer.Length;\n-                    ValueOffsets.Append(Offset);\n-                    ValueBuffer.Append(arr);\n-                    ValidityBuffer.Append(true);\n-                    Offset += ValueBuffer.Length - len;\n+                    return AppendNull();\n                 }\n \n+                // Note: by looking at the length of the value buffer before and after, we avoid having to iterate\n+                // through the enumerable multiple times to get both length and contents.\n+                int priorLength = ValueBuffer.Length;\n+                ValueBuffer.AppendRange(value);\n+                int valueLength = ValueBuffer.Length - priorLength;\n+                Offset += valueLength;\n+                ValidityBuffer.Append(true);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append an enumerable collection of single-byte values to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends multiple values, each of which is a single byte.  If a single value is\n+            /// to be added, use the <see cref=\"Append(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"values\">Single-byte values to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendRange(IEnumerable<byte> values)\n             {\n-                if (values == null)\n+                foreach (byte b in values)\n                 {\n-                    return AppendNull();\n+                    Append(b);\n                 }\n-                int len = ValueBuffer.Length;\n-                ValueBuffer.AppendRange(values);\n-                int valOffset = ValueBuffer.Length - len;\n-                ValueOffsets.Append(Offset);\n-                Offset += valOffset;\n-                ValidityBuffer.Append(true);\n+\n+                return Instance;\n+            }\n+\n+            /// <summary>\n+            /// Append an enumerable collection of values to the array.\n+            /// </summary>\n+            /// <param name=\"values\">Values to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n+            public TBuilder AppendRange(IEnumerable<byte[]> values)\n+            {\n+                foreach (byte[] arr in values)\n+                {\n+                    Append((IEnumerable<byte>)arr);\n\nReview comment:\n       This should call `Append(ReadOnlySpan<byte> span)` instead. It is faster. You can easily check for `null` and call `AppendNull()` if `arr` is null.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-10T19:51:28.683+0000",
                    "updated": "2020-07-10T19:51:28.683+0000",
                    "started": "2020-07-10T19:51:28.683+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "457332",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/458083",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mr-smidge commented on a change in pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#discussion_r453690533\n\n\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -66,87 +66,158 @@ protected BuilderBase(IArrowType dataType)\n                 ValueOffsets = new ArrowBuffer.Builder<int>();\n                 ValueBuffer = new ArrowBuffer.Builder<byte>();\n                 ValidityBuffer = new ArrowBuffer.BitmapBuilder();\n+\n+                // From the docs:\n+                //\n+                // The offsets buffer contains length + 1 signed integers (either 32-bit or 64-bit, depending on the\n+                // logical type), which encode the start position of each slot in the data buffer. The length of the\n+                // value in each slot is computed using the difference between the offset at that slot\u2019s index and the\n+                // subsequent offset.\n+                //\n+                // In this builder, we choose to append the first offset (zero) upon construction, and each trailing\n+                // offset is then added after each individual item has been appended.\n+                ValueOffsets.Append(this.Offset);\n             }\n \n             protected abstract TArray Build(ArrayData data);\n \n-            public int Length => ValueOffsets.Length;\n+            /// <summary>\n+            /// Gets the length of the array built so far.\n+            /// </summary>\n+            public int Length => ValueOffsets.Length - 1;\n \n+            /// <summary>\n+            /// Build an Arrow array from the appended contents so far.\n+            /// </summary>\n+            /// <param name=\"allocator\">Optional memory allocator.</param>\n+            /// <returns>Returns an array of type <typeparamref name=\"TArray\"/>.</returns>\n             public TArray Build(MemoryAllocator allocator = default)\n             {\n-                ValueOffsets.Append(Offset);\n-\n-                ArrowBuffer validityBuffer = NullCount > 0\n-                                        ? ValidityBuffer.Build(allocator)\n-                                        : ArrowBuffer.Empty;\n-\n-                var data = new ArrayData(DataType, ValueOffsets.Length - 1, NullCount, 0,\n-                    new[] { validityBuffer, ValueOffsets.Build(allocator), ValueBuffer.Build(allocator) });\n+                var bufs = new[]\n+                {\n+                    NullCount > 0 ? ValidityBuffer.Build(allocator) : ArrowBuffer.Empty,\n+                    ValueOffsets.Build(allocator),\n+                    ValueBuffer.Build(allocator),\n+                };\n+                var data = new ArrayData(\n+                    DataType,\n+                    length: ValueOffsets.Length - 1,\n+                    NullCount,\n+                    offset: 0,\n+                    bufs);\n \n                 return Build(data);\n             }\n \n+            /// <summary>\n+            /// Append a single null value to the array.\n+            /// </summary>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendNull()\n             {\n-                ValueOffsets.Append(Offset);\n+                // Do not add to the value buffer in the case of a null.\n+                // Note that we do not need to increment the offset as a result.\n                 ValidityBuffer.Append(false);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Appends a value, consisting of a single byte, to the array.\n+            /// </summary>\n+            /// <param name=\"value\">Byte value to append.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(byte value)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(value);\n-                Offset++;\n                 ValidityBuffer.Append(true);\n+                Offset++;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append a value, consisting of a span of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that a single value is added, which consists of arbitrarily many bytes.  If multiple values are\n+            /// to be added, use the <see cref=\"AppendRange\"/> method.\n+            /// </remarks>\n+            /// <param name=\"span\">Span of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(ReadOnlySpan<byte> span)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(span);\n                 ValidityBuffer.Append(true);\n                 Offset += span.Length;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n-            public TBuilder AppendRange(IEnumerable<byte[]> values)\n+            /// <summary>\n+            /// Append a value, consisting of an enumerable collection of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends a single value, which may consist of arbitrarily many bytes.  If multiple\n+            /// values are to be added, use the <see cref=\"AppendRange(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"value\">Enumerable collection of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n+            public TBuilder Append(IEnumerable<byte> value)\n             {\n-                foreach (byte[] arr in values)\n+                if (value == null)\n                 {\n-                    if (arr == null)\n-                    {\n-                        AppendNull();\n-                        continue;\n-                    }\n-                    int len = ValueBuffer.Length;\n-                    ValueOffsets.Append(Offset);\n-                    ValueBuffer.Append(arr);\n-                    ValidityBuffer.Append(true);\n-                    Offset += ValueBuffer.Length - len;\n+                    return AppendNull();\n                 }\n \n+                // Note: by looking at the length of the value buffer before and after, we avoid having to iterate\n+                // through the enumerable multiple times to get both length and contents.\n+                int priorLength = ValueBuffer.Length;\n+                ValueBuffer.AppendRange(value);\n+                int valueLength = ValueBuffer.Length - priorLength;\n+                Offset += valueLength;\n+                ValidityBuffer.Append(true);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append an enumerable collection of single-byte values to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends multiple values, each of which is a single byte.  If a single value is\n+            /// to be added, use the <see cref=\"Append(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"values\">Single-byte values to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendRange(IEnumerable<byte> values)\n             {\n-                if (values == null)\n+                foreach (byte b in values)\n                 {\n-                    return AppendNull();\n+                    Append(b);\n                 }\n-                int len = ValueBuffer.Length;\n-                ValueBuffer.AppendRange(values);\n-                int valOffset = ValueBuffer.Length - len;\n-                ValueOffsets.Append(Offset);\n-                Offset += valOffset;\n-                ValidityBuffer.Append(true);\n+\n+                return Instance;\n+            }\n+\n+            /// <summary>\n+            /// Append an enumerable collection of values to the array.\n+            /// </summary>\n+            /// <param name=\"values\">Values to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n+            public TBuilder AppendRange(IEnumerable<byte[]> values)\n+            {\n+                foreach (byte[] arr in values)\n\nReview comment:\n       Fixed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-13T14:28:36.072+0000",
                    "updated": "2020-07-13T14:28:36.072+0000",
                    "started": "2020-07-13T14:28:36.071+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "458083",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/458085",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mr-smidge commented on a change in pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#discussion_r453690625\n\n\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -66,87 +66,158 @@ protected BuilderBase(IArrowType dataType)\n                 ValueOffsets = new ArrowBuffer.Builder<int>();\n                 ValueBuffer = new ArrowBuffer.Builder<byte>();\n                 ValidityBuffer = new ArrowBuffer.BitmapBuilder();\n+\n+                // From the docs:\n+                //\n+                // The offsets buffer contains length + 1 signed integers (either 32-bit or 64-bit, depending on the\n+                // logical type), which encode the start position of each slot in the data buffer. The length of the\n+                // value in each slot is computed using the difference between the offset at that slot\u2019s index and the\n+                // subsequent offset.\n+                //\n+                // In this builder, we choose to append the first offset (zero) upon construction, and each trailing\n+                // offset is then added after each individual item has been appended.\n+                ValueOffsets.Append(this.Offset);\n             }\n \n             protected abstract TArray Build(ArrayData data);\n \n-            public int Length => ValueOffsets.Length;\n+            /// <summary>\n+            /// Gets the length of the array built so far.\n+            /// </summary>\n+            public int Length => ValueOffsets.Length - 1;\n \n+            /// <summary>\n+            /// Build an Arrow array from the appended contents so far.\n+            /// </summary>\n+            /// <param name=\"allocator\">Optional memory allocator.</param>\n+            /// <returns>Returns an array of type <typeparamref name=\"TArray\"/>.</returns>\n             public TArray Build(MemoryAllocator allocator = default)\n             {\n-                ValueOffsets.Append(Offset);\n-\n-                ArrowBuffer validityBuffer = NullCount > 0\n-                                        ? ValidityBuffer.Build(allocator)\n-                                        : ArrowBuffer.Empty;\n-\n-                var data = new ArrayData(DataType, ValueOffsets.Length - 1, NullCount, 0,\n-                    new[] { validityBuffer, ValueOffsets.Build(allocator), ValueBuffer.Build(allocator) });\n+                var bufs = new[]\n+                {\n+                    NullCount > 0 ? ValidityBuffer.Build(allocator) : ArrowBuffer.Empty,\n+                    ValueOffsets.Build(allocator),\n+                    ValueBuffer.Build(allocator),\n+                };\n+                var data = new ArrayData(\n+                    DataType,\n+                    length: ValueOffsets.Length - 1,\n+                    NullCount,\n+                    offset: 0,\n+                    bufs);\n \n                 return Build(data);\n             }\n \n+            /// <summary>\n+            /// Append a single null value to the array.\n+            /// </summary>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendNull()\n             {\n-                ValueOffsets.Append(Offset);\n+                // Do not add to the value buffer in the case of a null.\n+                // Note that we do not need to increment the offset as a result.\n                 ValidityBuffer.Append(false);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Appends a value, consisting of a single byte, to the array.\n+            /// </summary>\n+            /// <param name=\"value\">Byte value to append.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(byte value)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(value);\n-                Offset++;\n                 ValidityBuffer.Append(true);\n+                Offset++;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append a value, consisting of a span of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that a single value is added, which consists of arbitrarily many bytes.  If multiple values are\n+            /// to be added, use the <see cref=\"AppendRange\"/> method.\n+            /// </remarks>\n+            /// <param name=\"span\">Span of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(ReadOnlySpan<byte> span)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(span);\n                 ValidityBuffer.Append(true);\n                 Offset += span.Length;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n-            public TBuilder AppendRange(IEnumerable<byte[]> values)\n+            /// <summary>\n+            /// Append a value, consisting of an enumerable collection of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends a single value, which may consist of arbitrarily many bytes.  If multiple\n+            /// values are to be added, use the <see cref=\"AppendRange(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"value\">Enumerable collection of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n+            public TBuilder Append(IEnumerable<byte> value)\n             {\n-                foreach (byte[] arr in values)\n+                if (value == null)\n                 {\n-                    if (arr == null)\n-                    {\n-                        AppendNull();\n-                        continue;\n-                    }\n-                    int len = ValueBuffer.Length;\n-                    ValueOffsets.Append(Offset);\n-                    ValueBuffer.Append(arr);\n-                    ValidityBuffer.Append(true);\n-                    Offset += ValueBuffer.Length - len;\n+                    return AppendNull();\n                 }\n \n+                // Note: by looking at the length of the value buffer before and after, we avoid having to iterate\n+                // through the enumerable multiple times to get both length and contents.\n+                int priorLength = ValueBuffer.Length;\n+                ValueBuffer.AppendRange(value);\n+                int valueLength = ValueBuffer.Length - priorLength;\n+                Offset += valueLength;\n+                ValidityBuffer.Append(true);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append an enumerable collection of single-byte values to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends multiple values, each of which is a single byte.  If a single value is\n+            /// to be added, use the <see cref=\"Append(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"values\">Single-byte values to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendRange(IEnumerable<byte> values)\n             {\n-                if (values == null)\n+                foreach (byte b in values)\n\nReview comment:\n       Fixed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-13T14:28:54.614+0000",
                    "updated": "2020-07-13T14:28:54.614+0000",
                    "started": "2020-07-13T14:28:54.614+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "458085",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/458086",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mr-smidge commented on a change in pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#discussion_r453690865\n\n\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -66,87 +66,158 @@ protected BuilderBase(IArrowType dataType)\n                 ValueOffsets = new ArrowBuffer.Builder<int>();\n                 ValueBuffer = new ArrowBuffer.Builder<byte>();\n                 ValidityBuffer = new ArrowBuffer.BitmapBuilder();\n+\n+                // From the docs:\n+                //\n+                // The offsets buffer contains length + 1 signed integers (either 32-bit or 64-bit, depending on the\n+                // logical type), which encode the start position of each slot in the data buffer. The length of the\n+                // value in each slot is computed using the difference between the offset at that slot\u2019s index and the\n+                // subsequent offset.\n+                //\n+                // In this builder, we choose to append the first offset (zero) upon construction, and each trailing\n+                // offset is then added after each individual item has been appended.\n+                ValueOffsets.Append(this.Offset);\n             }\n \n             protected abstract TArray Build(ArrayData data);\n \n-            public int Length => ValueOffsets.Length;\n+            /// <summary>\n+            /// Gets the length of the array built so far.\n+            /// </summary>\n+            public int Length => ValueOffsets.Length - 1;\n \n+            /// <summary>\n+            /// Build an Arrow array from the appended contents so far.\n+            /// </summary>\n+            /// <param name=\"allocator\">Optional memory allocator.</param>\n+            /// <returns>Returns an array of type <typeparamref name=\"TArray\"/>.</returns>\n             public TArray Build(MemoryAllocator allocator = default)\n             {\n-                ValueOffsets.Append(Offset);\n-\n-                ArrowBuffer validityBuffer = NullCount > 0\n-                                        ? ValidityBuffer.Build(allocator)\n-                                        : ArrowBuffer.Empty;\n-\n-                var data = new ArrayData(DataType, ValueOffsets.Length - 1, NullCount, 0,\n-                    new[] { validityBuffer, ValueOffsets.Build(allocator), ValueBuffer.Build(allocator) });\n+                var bufs = new[]\n+                {\n+                    NullCount > 0 ? ValidityBuffer.Build(allocator) : ArrowBuffer.Empty,\n+                    ValueOffsets.Build(allocator),\n+                    ValueBuffer.Build(allocator),\n+                };\n+                var data = new ArrayData(\n+                    DataType,\n+                    length: ValueOffsets.Length - 1,\n+                    NullCount,\n+                    offset: 0,\n+                    bufs);\n \n                 return Build(data);\n             }\n \n+            /// <summary>\n+            /// Append a single null value to the array.\n+            /// </summary>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendNull()\n             {\n-                ValueOffsets.Append(Offset);\n+                // Do not add to the value buffer in the case of a null.\n+                // Note that we do not need to increment the offset as a result.\n                 ValidityBuffer.Append(false);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Appends a value, consisting of a single byte, to the array.\n+            /// </summary>\n+            /// <param name=\"value\">Byte value to append.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(byte value)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(value);\n-                Offset++;\n                 ValidityBuffer.Append(true);\n+                Offset++;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append a value, consisting of a span of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that a single value is added, which consists of arbitrarily many bytes.  If multiple values are\n+            /// to be added, use the <see cref=\"AppendRange\"/> method.\n+            /// </remarks>\n+            /// <param name=\"span\">Span of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder Append(ReadOnlySpan<byte> span)\n             {\n-                ValueOffsets.Append(Offset);\n                 ValueBuffer.Append(span);\n                 ValidityBuffer.Append(true);\n                 Offset += span.Length;\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n-            public TBuilder AppendRange(IEnumerable<byte[]> values)\n+            /// <summary>\n+            /// Append a value, consisting of an enumerable collection of bytes, to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends a single value, which may consist of arbitrarily many bytes.  If multiple\n+            /// values are to be added, use the <see cref=\"AppendRange(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"value\">Enumerable collection of bytes to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n+            public TBuilder Append(IEnumerable<byte> value)\n             {\n-                foreach (byte[] arr in values)\n+                if (value == null)\n                 {\n-                    if (arr == null)\n-                    {\n-                        AppendNull();\n-                        continue;\n-                    }\n-                    int len = ValueBuffer.Length;\n-                    ValueOffsets.Append(Offset);\n-                    ValueBuffer.Append(arr);\n-                    ValidityBuffer.Append(true);\n-                    Offset += ValueBuffer.Length - len;\n+                    return AppendNull();\n                 }\n \n+                // Note: by looking at the length of the value buffer before and after, we avoid having to iterate\n+                // through the enumerable multiple times to get both length and contents.\n+                int priorLength = ValueBuffer.Length;\n+                ValueBuffer.AppendRange(value);\n+                int valueLength = ValueBuffer.Length - priorLength;\n+                Offset += valueLength;\n+                ValidityBuffer.Append(true);\n+                ValueOffsets.Append(Offset);\n                 return Instance;\n             }\n \n+            /// <summary>\n+            /// Append an enumerable collection of single-byte values to the array.\n+            /// </summary>\n+            /// <remarks>\n+            /// Note that this method appends multiple values, each of which is a single byte.  If a single value is\n+            /// to be added, use the <see cref=\"Append(IEnumerable{byte})\"/> method instead.\n+            /// </remarks>\n+            /// <param name=\"values\">Single-byte values to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n             public TBuilder AppendRange(IEnumerable<byte> values)\n             {\n-                if (values == null)\n+                foreach (byte b in values)\n                 {\n-                    return AppendNull();\n+                    Append(b);\n                 }\n-                int len = ValueBuffer.Length;\n-                ValueBuffer.AppendRange(values);\n-                int valOffset = ValueBuffer.Length - len;\n-                ValueOffsets.Append(Offset);\n-                Offset += valOffset;\n-                ValidityBuffer.Append(true);\n+\n+                return Instance;\n+            }\n+\n+            /// <summary>\n+            /// Append an enumerable collection of values to the array.\n+            /// </summary>\n+            /// <param name=\"values\">Values to add.</param>\n+            /// <returns>Returns the builder (for fluent-style composition).</returns>\n+            public TBuilder AppendRange(IEnumerable<byte[]> values)\n+            {\n+                foreach (byte[] arr in values)\n+                {\n+                    Append((IEnumerable<byte>)arr);\n\nReview comment:\n       Thanks - changed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-13T14:29:09.475+0000",
                    "updated": "2020-07-13T14:29:09.475+0000",
                    "started": "2020-07-13T14:29:09.475+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "458086",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/458088",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mr-smidge commented on a change in pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#discussion_r453692211\n\n\n\n##########\nFile path: csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n##########\n@@ -66,87 +66,158 @@ protected BuilderBase(IArrowType dataType)\n                 ValueOffsets = new ArrowBuffer.Builder<int>();\n                 ValueBuffer = new ArrowBuffer.Builder<byte>();\n                 ValidityBuffer = new ArrowBuffer.BitmapBuilder();\n+\n+                // From the docs:\n+                //\n+                // The offsets buffer contains length + 1 signed integers (either 32-bit or 64-bit, depending on the\n+                // logical type), which encode the start position of each slot in the data buffer. The length of the\n+                // value in each slot is computed using the difference between the offset at that slot\u2019s index and the\n+                // subsequent offset.\n+                //\n+                // In this builder, we choose to append the first offset (zero) upon construction, and each trailing\n+                // offset is then added after each individual item has been appended.\n+                ValueOffsets.Append(this.Offset);\n             }\n \n             protected abstract TArray Build(ArrayData data);\n \n-            public int Length => ValueOffsets.Length;\n+            /// <summary>\n+            /// Gets the length of the array built so far.\n+            /// </summary>\n+            public int Length => ValueOffsets.Length - 1;\n \n+            /// <summary>\n+            /// Build an Arrow array from the appended contents so far.\n+            /// </summary>\n+            /// <param name=\"allocator\">Optional memory allocator.</param>\n+            /// <returns>Returns an array of type <typeparamref name=\"TArray\"/>.</returns>\n             public TArray Build(MemoryAllocator allocator = default)\n             {\n-                ValueOffsets.Append(Offset);\n-\n-                ArrowBuffer validityBuffer = NullCount > 0\n-                                        ? ValidityBuffer.Build(allocator)\n-                                        : ArrowBuffer.Empty;\n-\n-                var data = new ArrayData(DataType, ValueOffsets.Length - 1, NullCount, 0,\n-                    new[] { validityBuffer, ValueOffsets.Build(allocator), ValueBuffer.Build(allocator) });\n+                var bufs = new[]\n+                {\n+                    NullCount > 0 ? ValidityBuffer.Build(allocator) : ArrowBuffer.Empty,\n+                    ValueOffsets.Build(allocator),\n+                    ValueBuffer.Build(allocator),\n+                };\n+                var data = new ArrayData(\n+                    DataType,\n+                    length: ValueOffsets.Length - 1,\n\nReview comment:\n       Yes it can - changed.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-13T14:30:49.550+0000",
                    "updated": "2020-07-13T14:30:49.550+0000",
                    "started": "2020-07-13T14:30:49.550+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "458088",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/458089",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "mr-smidge commented on pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671#issuecomment-657595775\n\n\n   > This is looking really good. I just have a few comments, and then it should be ready to merge.\r\n   \r\n   All comments should be addressed now :smile:.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-13T14:31:42.615+0000",
                    "updated": "2020-07-13T14:31:42.615+0000",
                    "started": "2020-07-13T14:31:42.615+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "458089",
                    "issueId": "13296475"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/worklog/458633",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "eerhardt closed pull request #7671:\nURL: https://github.com/apache/arrow/pull/7671\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-07-14T14:08:09.837+0000",
                    "updated": "2020-07-14T14:08:09.837+0000",
                    "started": "2020-07-14T14:08:09.837+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "458633",
                    "issueId": "13296475"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
            "id": "1",
            "description": "A problem which impairs or prevents the functions of the product.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
            "name": "Bug",
            "subtask": false,
            "avatarId": 21133
        },
        "timespent": 9000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@6e64349b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@21f96111[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@364a4097[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@5c515ea6[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@52ccbe56[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@45cc74[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@646f7a13[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@329dbc56[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5948a5d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2b9cc0f7[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@343c9875[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6b9ceda8[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 9000,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Jul 14 14:08:03 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-07-14T14:08:03.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-8344/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-04-06T09:29:48.000+0000",
        "updated": "2020-07-14T14:08:10.000+0000",
        "timeoriginalestimate": null,
        "description": "h1. Summary\r\n\r\nUsing the\u00a0{{Clear()}} method on a {{StringArray.Builder}} class causes all subsequently-built arrays to contain corrupted strings, either consisting solely of whitespace or the empty string: the outcome appears OS-specific.\u00a0 The below minimal example illustrates:\r\n{code:java}\r\nnamespace ArrowStringArrayBuilderBug\r\n{\r\n    using Apache.Arrow;\r\n    using Apache.Arrow.Memory;\r\n\r\n    public class Program\r\n    {\r\n        private static readonly NativeMemoryAllocator Allocator\r\n            = new NativeMemoryAllocator();\r\n\r\n        public static void Main()\r\n        {\r\n            var builder = new StringArray.Builder();\r\n            AppendBuildPrint(builder, \"Hello\", \"World\");\r\n            builder.Clear();\r\n            AppendBuildPrint(builder, \"Foo\", \"Bar\");\r\n        }\r\n\r\n        private static void AppendBuildPrint(\r\n            StringArray.Builder builder, params string[] strings)\r\n        {\r\n            foreach (var elem in strings)\r\n                builder.Append(elem);\r\n\r\n            var arr = builder.Build(Allocator);\r\n            System.Console.Write(\"Array contents: [\");\r\n            for (var i = 0; i < arr.Length; i++)\r\n            {\r\n                if (i > 0) System.Console.Write(\", \");\r\n                System.Console.Write($\"'{arr.GetString(i)}'\");\r\n            }\r\n            System.Console.WriteLine(\"]\");\r\n        }\r\n    }\r\n{code}\r\nh2. Expected Output\r\n{noformat}\r\nArray contents: ['Hello', 'World']\r\nArray contents: ['Foo', 'Bar']\r\n{noformat}\r\nh2. Actual Output (Windows 10 x64)\r\n{noformat}\r\nArray contents: ['Hello', 'World']\r\nArray contents: ['   ', '   ']{noformat}\r\nh2. Actual Output (Ubuntu 18.04 LTS x64)\r\n{noformat}\r\nArray contents: ['Hello', 'World']\r\nArray contents: ['', '']{noformat}\r\nh1. Workaround\r\n\r\nThe bug can be trivially worked around by constructing a new {{StringArray.Builder}} instead of calling {{Clear()}}.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 9000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C#] StringArray.Builder.Clear() corrupts subsequently-built array contents",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": "Windows 10 x64\r\nUbuntu Linux 18.04 LTS x64",
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13296475/comment/17157408",
                    "id": "17157408",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=eerhardt",
                        "name": "eerhardt",
                        "key": "eerhardt",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=eerhardt&avatarId=37925",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=eerhardt&avatarId=37925",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=eerhardt&avatarId=37925",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=eerhardt&avatarId=37925"
                        },
                        "displayName": "Eric Erhardt",
                        "active": true,
                        "timeZone": "America/North_Dakota/New_Salem"
                    },
                    "body": "Issue resolved by pull request 7671\n[https://github.com/apache/arrow/pull/7671]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=eerhardt",
                        "name": "eerhardt",
                        "key": "eerhardt",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=eerhardt&avatarId=37925",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=eerhardt&avatarId=37925",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=eerhardt&avatarId=37925",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=eerhardt&avatarId=37925"
                        },
                        "displayName": "Eric Erhardt",
                        "active": true,
                        "timeZone": "America/North_Dakota/New_Salem"
                    },
                    "created": "2020-07-14T14:08:03.179+0000",
                    "updated": "2020-07-14T14:08:03.179+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0dba8:",
        "customfield_12314139": null
    }
}