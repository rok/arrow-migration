{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13136681",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681",
    "key": "ARROW-2104",
    "fields": {
        "parent": {
            "id": "13061965",
            "key": "ARROW-772",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13061965",
            "fields": {
                "summary": "[C++] Implement take kernel functions",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                    "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                    "name": "Resolved",
                    "id": "5",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12344925",
                "id": "12344925",
                "description": "",
                "name": "0.14.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-07-04"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12526422",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12526422",
                "type": {
                    "id": "10020",
                    "name": "Cloners",
                    "inward": "is cloned by",
                    "outward": "is a clone of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10020"
                },
                "outwardIssue": {
                    "id": "13136679",
                    "key": "ARROW-2103",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136679",
                    "fields": {
                        "summary": "[C++] Implement take kernel functions - string/binary value type",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                            "id": "7",
                            "description": "The sub-task of the issue",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                            "name": "Sub-task",
                            "subtask": true,
                            "avatarId": 21146
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alphalfalfa",
            "name": "alphalfalfa",
            "key": "alphalfalfa",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Jingyuan Wang",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=alphalfalfa",
            "name": "alphalfalfa",
            "key": "alphalfalfa",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Jingyuan Wang",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 43800,
            "total": 43800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 43800,
            "total": 43800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2104/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 77,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/258871",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531\n \n \n   Take now supports gathering from List, FixedSizeList, Map, and Struct arrays. Union is not yet supported\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-12T16:32:44.749+0000",
                    "updated": "2019-06-12T16:32:44.749+0000",
                    "started": "2019-06-12T16:32:44.748+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "258871",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266622",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297158826\n \n \n\n ##########\n File path: python/pyarrow/tests/test_compute.py\n ##########\n @@ -51,7 +51,10 @@ def test_sum(arrow_type):\n     ('double', np.arange(0, 0.5, 0.1)),\n     ('string', ['a', 'b', None, 'ddd', 'ee']),\n     ('binary', [b'a', b'b', b'c', b'ddd', b'ee']),\n-    (pa.binary(3), [b'abc', b'bcd', b'cde', b'def', b'efg'])\n+    (pa.binary(3), [b'abc', b'bcd', b'cde', b'def', b'efg']),\n+    (pa.list_(pa.int8()), [[1, 2], [3, 4], [5, 6], None, [9, 16]]),\n+    (pa.struct([('a', pa.int8()), ('b', pa.int8())]), [\n+     {'a': 1, 'b': 2}, None, {'a': 3, 'b': 4}, None, {'a': 5, 'b': 6}]),\n ])\n def test_take(ty, values):\n \n Review comment:\n   Can you call `.validate()` on the result arrays below?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:08:18.466+0000",
                    "updated": "2019-06-25T13:08:18.466+0000",
                    "started": "2019-06-25T13:08:18.464+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266622",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266623",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297160457\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-internal.h\n ##########\n @@ -0,0 +1,573 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <limits>\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/stl.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename Builder, typename Scalar>\n+static Status UnsafeAppend(Builder* builder, Scalar&& value) {\n+  builder->UnsafeAppend(std::forward<Scalar>(value));\n+  return Status::OK();\n+}\n+\n+static Status UnsafeAppend(BinaryBuilder* builder, util::string_view value) {\n+  RETURN_NOT_OK(builder->ReserveData(static_cast<int64_t>(value.size())));\n \n Review comment:\n   Hmm... it would probably be more efficient to do it in two passes:\r\n   - first pass to compute the overall data length\r\n   - second pass to do the actual builder appends after having reserved the right data size at once\r\n   \r\n   What do you think? Is it easily doable to switch to such a scheme?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:08:18.589+0000",
                    "updated": "2019-06-25T13:08:18.589+0000",
                    "started": "2019-06-25T13:08:18.584+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266623",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266624",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297173834\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-test.cc\n ##########\n @@ -29,31 +29,36 @@\n namespace arrow {\n namespace compute {\n \n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n using util::string_view;\n \n+constexpr auto kSeed = 0x0ff1ce;\n+\n template <typename ArrowType>\n class TestTakeKernel : public ComputeFixture, public TestBase {\n  protected:\n   void AssertTakeArrays(const std::shared_ptr<Array>& values,\n-                        const std::shared_ptr<Array>& indices, TakeOptions options,\n+                        const std::shared_ptr<Array>& indices,\n                         const std::shared_ptr<Array>& expected) {\n     std::shared_ptr<Array> actual;\n+    TakeOptions options;\n     ASSERT_OK(arrow::compute::Take(&this->ctx_, *values, *indices, options, &actual));\n \n Review comment:\n   Would be nice to call `ValidateArray` on `actual`.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:08:18.735+0000",
                    "updated": "2019-06-25T13:08:18.735+0000",
                    "started": "2019-06-25T13:08:18.734+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266624",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266625",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297174149\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-test.cc\n ##########\n @@ -29,31 +29,36 @@\n namespace arrow {\n namespace compute {\n \n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n using util::string_view;\n \n+constexpr auto kSeed = 0x0ff1ce;\n+\n template <typename ArrowType>\n class TestTakeKernel : public ComputeFixture, public TestBase {\n  protected:\n   void AssertTakeArrays(const std::shared_ptr<Array>& values,\n-                        const std::shared_ptr<Array>& indices, TakeOptions options,\n+                        const std::shared_ptr<Array>& indices,\n                         const std::shared_ptr<Array>& expected) {\n     std::shared_ptr<Array> actual;\n+    TakeOptions options;\n     ASSERT_OK(arrow::compute::Take(&this->ctx_, *values, *indices, options, &actual));\n     AssertArraysEqual(*expected, *actual);\n   }\n   void AssertTake(const std::shared_ptr<DataType>& type, const std::string& values,\n-                  const std::string& indices, TakeOptions options,\n-                  const std::string& expected) {\n+                  const std::string& indices, const std::string& expected) {\n     std::shared_ptr<Array> actual;\n \n     for (auto index_type : {int8(), uint32()}) {\n-      ASSERT_OK(this->Take(type, values, index_type, indices, options, &actual));\n+      ASSERT_OK(this->Take(type, values, index_type, indices, &actual));\n \n Review comment:\n   Would be nice to call `ValidateArray` on `actual` here as well.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:08:18.880+0000",
                    "updated": "2019-06-25T13:08:18.880+0000",
                    "started": "2019-06-25T13:08:18.879+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266625",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266626",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297175322\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-test.cc\n ##########\n @@ -62,82 +67,111 @@ class TestTakeKernel : public ComputeFixture, public TestBase {\n class TestTakeKernelWithNull : public TestTakeKernel<NullType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, options, expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, expected);\n   }\n };\n \n TEST_F(TestTakeKernelWithNull, TakeNull) {\n-  TakeOptions options;\n-  this->AssertTake(\"[null, null, null]\", \"[0, 1, 0]\", options, \"[null, null, null]\");\n+  this->AssertTake(\"[null, null, null]\", \"[0, 1, 0]\", \"[null, null, null]\");\n \n   std::shared_ptr<Array> arr;\n-  ASSERT_RAISES(IndexError, this->Take(null(), \"[null, null, null]\", int8(), \"[0, 9, 0]\",\n-                                       options, &arr));\n+  ASSERT_RAISES(IndexError,\n+                this->Take(null(), \"[null, null, null]\", int8(), \"[0, 9, 0]\", &arr));\n }\n \n TEST_F(TestTakeKernelWithNull, InvalidIndexType) {\n-  TakeOptions options;\n   std::shared_ptr<Array> arr;\n   ASSERT_RAISES(TypeError, this->Take(null(), \"[null, null, null]\", float32(),\n-                                      \"[0.0, 1.0, 0.1]\", options, &arr));\n+                                      \"[0.0, 1.0, 0.1]\", &arr));\n }\n \n class TestTakeKernelWithBoolean : public TestTakeKernel<BooleanType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<BooleanType>::AssertTake(boolean(), values, indices, options,\n-                                            expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<BooleanType>::AssertTake(boolean(), values, indices, expected);\n   }\n };\n \n TEST_F(TestTakeKernelWithBoolean, TakeBoolean) {\n-  TakeOptions options;\n-  this->AssertTake(\"[true, false, true]\", \"[0, 1, 0]\", options, \"[true, false, true]\");\n-  this->AssertTake(\"[null, false, true]\", \"[0, 1, 0]\", options, \"[null, false, null]\");\n-  this->AssertTake(\"[true, false, true]\", \"[null, 1, 0]\", options, \"[null, false, true]\");\n+  this->AssertTake(\"[true, false, true]\", \"[0, 1, 0]\", \"[true, false, true]\");\n+  this->AssertTake(\"[null, false, true]\", \"[0, 1, 0]\", \"[null, false, null]\");\n+  this->AssertTake(\"[true, false, true]\", \"[null, 1, 0]\", \"[null, false, true]\");\n \n   std::shared_ptr<Array> arr;\n-  ASSERT_RAISES(IndexError, this->Take(boolean(), \"[true, false, true]\", int8(),\n-                                       \"[0, 9, 0]\", options, &arr));\n+  ASSERT_RAISES(IndexError,\n+                this->Take(boolean(), \"[true, false, true]\", int8(), \"[0, 9, 0]\", &arr));\n }\n \n template <typename ArrowType>\n class TestTakeKernelWithNumeric : public TestTakeKernel<ArrowType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<ArrowType>::AssertTake(type_singleton(), values, indices, options,\n-                                          expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<ArrowType>::AssertTake(type_singleton(), values, indices, expected);\n   }\n   std::shared_ptr<DataType> type_singleton() {\n     return TypeTraits<ArrowType>::type_singleton();\n   }\n+  void ValidateTake(const std::shared_ptr<Array>& values,\n+                    const std::shared_ptr<Array>& indices_boxed) {\n+    std::shared_ptr<Array> taken;\n+    TakeOptions options;\n+    ASSERT_OK(\n+        arrow::compute::Take(&this->ctx_, *values, *indices_boxed, options, &taken));\n+    ASSERT_EQ(indices_boxed->length(), taken->length());\n+\n+    ASSERT_EQ(indices_boxed->type_id(), Type::INT32);\n+    auto indices = checked_pointer_cast<Int32Array>(indices_boxed);\n+    for (int64_t i = 0; i < indices->length(); ++i) {\n+      if (indices->IsNull(i)) {\n+        ASSERT_TRUE(taken->IsNull(i));\n+        continue;\n+      }\n+      int32_t taken_index = indices->Value(i);\n+      ASSERT_TRUE(values->RangeEquals(taken_index, taken_index + 1, i, taken));\n+    }\n+  }\n };\n \n TYPED_TEST_CASE(TestTakeKernelWithNumeric, NumericArrowTypes);\n TYPED_TEST(TestTakeKernelWithNumeric, TakeNumeric) {\n-  TakeOptions options;\n-  this->AssertTake(\"[7, 8, 9]\", \"[0, 1, 0]\", options, \"[7, 8, 7]\");\n-  this->AssertTake(\"[null, 8, 9]\", \"[0, 1, 0]\", options, \"[null, 8, null]\");\n-  this->AssertTake(\"[7, 8, 9]\", \"[null, 1, 0]\", options, \"[null, 8, 7]\");\n-  this->AssertTake(\"[null, 8, 9]\", \"[]\", options, \"[]\");\n+  this->AssertTake(\"[7, 8, 9]\", \"[0, 1, 0]\", \"[7, 8, 7]\");\n+  this->AssertTake(\"[null, 8, 9]\", \"[0, 1, 0]\", \"[null, 8, null]\");\n+  this->AssertTake(\"[7, 8, 9]\", \"[null, 1, 0]\", \"[null, 8, 7]\");\n+  this->AssertTake(\"[null, 8, 9]\", \"[]\", \"[]\");\n \n   std::shared_ptr<Array> arr;\n   ASSERT_RAISES(IndexError, this->Take(this->type_singleton(), \"[7, 8, 9]\", int8(),\n-                                       \"[0, 9, 0]\", options, &arr));\n+                                       \"[0, 9, 0]\", &arr));\n+}\n+\n+TYPED_TEST(TestTakeKernelWithNumeric, TakeRandomNumeric) {\n+  auto rand = random::RandomArrayGenerator(kSeed);\n+  for (size_t i = 3; i < 8; i++) {\n+    const int64_t length = static_cast<int64_t>(1ULL << i);\n+    for (size_t j = 0; j < 13; j++) {\n+      const int64_t indices_length = static_cast<int64_t>(1ULL << j);\n \n Review comment:\n   Are there any tests with a 0-length indices array?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:08:18.924+0000",
                    "updated": "2019-06-25T13:08:18.924+0000",
                    "started": "2019-06-25T13:08:18.923+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266626",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266627",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297176516\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-test.cc\n ##########\n @@ -147,28 +181,129 @@ class TestTakeKernelWithString : public TestTakeKernel<StringType> {\n     ASSERT_OK(DictionaryArray::FromArrays(type, ArrayFromJSON(int8(), expected_indices),\n                                           dict, &expected));\n     auto take_indices = ArrayFromJSON(int8(), indices);\n-    this->AssertTakeArrays(values, take_indices, options, expected);\n+    this->AssertTakeArrays(values, take_indices, expected);\n   }\n };\n \n TEST_F(TestTakeKernelWithString, TakeString) {\n-  TakeOptions options;\n-  this->AssertTake(R\"([\"a\", \"b\", \"c\"])\", \"[0, 1, 0]\", options, R\"([\"a\", \"b\", \"a\"])\");\n-  this->AssertTake(R\"([null, \"b\", \"c\"])\", \"[0, 1, 0]\", options, \"[null, \\\"b\\\", null]\");\n-  this->AssertTake(R\"([\"a\", \"b\", \"c\"])\", \"[null, 1, 0]\", options, R\"([null, \"b\", \"a\"])\");\n+  this->AssertTake(R\"([\"a\", \"b\", \"c\"])\", \"[0, 1, 0]\", R\"([\"a\", \"b\", \"a\"])\");\n+  this->AssertTake(R\"([null, \"b\", \"c\"])\", \"[0, 1, 0]\", \"[null, \\\"b\\\", null]\");\n+  this->AssertTake(R\"([\"a\", \"b\", \"c\"])\", \"[null, 1, 0]\", R\"([null, \"b\", \"a\"])\");\n \n   std::shared_ptr<Array> arr;\n-  ASSERT_RAISES(IndexError, this->Take(utf8(), R\"([\"a\", \"b\", \"c\"])\", int8(), \"[0, 9, 0]\",\n-                                       options, &arr));\n+  ASSERT_RAISES(IndexError,\n+                this->Take(utf8(), R\"([\"a\", \"b\", \"c\"])\", int8(), \"[0, 9, 0]\", &arr));\n+  ASSERT_RAISES(IndexError, this->Take(utf8(), R\"([\"a\", \"b\", null, \"ddd\", \"ee\"])\",\n+                                       int64(), \"[2, 5]\", &arr));\n \n Review comment:\n   Do you sometimes test that a negative index raises `IndexError`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:08:18.925+0000",
                    "updated": "2019-06-25T13:08:18.925+0000",
                    "started": "2019-06-25T13:08:18.924+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266627",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266628",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297173489\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-test.cc\n ##########\n @@ -62,82 +67,111 @@ class TestTakeKernel : public ComputeFixture, public TestBase {\n class TestTakeKernelWithNull : public TestTakeKernel<NullType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, options, expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, expected);\n \n Review comment:\n   Hmm... why `utf8()`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:08:18.936+0000",
                    "updated": "2019-06-25T13:08:18.936+0000",
                    "started": "2019-06-25T13:08:18.914+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266628",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266629",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297176203\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-test.cc\n ##########\n @@ -62,82 +67,111 @@ class TestTakeKernel : public ComputeFixture, public TestBase {\n class TestTakeKernelWithNull : public TestTakeKernel<NullType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, options, expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, expected);\n   }\n };\n \n TEST_F(TestTakeKernelWithNull, TakeNull) {\n-  TakeOptions options;\n-  this->AssertTake(\"[null, null, null]\", \"[0, 1, 0]\", options, \"[null, null, null]\");\n+  this->AssertTake(\"[null, null, null]\", \"[0, 1, 0]\", \"[null, null, null]\");\n \n   std::shared_ptr<Array> arr;\n-  ASSERT_RAISES(IndexError, this->Take(null(), \"[null, null, null]\", int8(), \"[0, 9, 0]\",\n-                                       options, &arr));\n+  ASSERT_RAISES(IndexError,\n+                this->Take(null(), \"[null, null, null]\", int8(), \"[0, 9, 0]\", &arr));\n }\n \n TEST_F(TestTakeKernelWithNull, InvalidIndexType) {\n-  TakeOptions options;\n   std::shared_ptr<Array> arr;\n   ASSERT_RAISES(TypeError, this->Take(null(), \"[null, null, null]\", float32(),\n-                                      \"[0.0, 1.0, 0.1]\", options, &arr));\n+                                      \"[0.0, 1.0, 0.1]\", &arr));\n }\n \n class TestTakeKernelWithBoolean : public TestTakeKernel<BooleanType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<BooleanType>::AssertTake(boolean(), values, indices, options,\n-                                            expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<BooleanType>::AssertTake(boolean(), values, indices, expected);\n   }\n };\n \n TEST_F(TestTakeKernelWithBoolean, TakeBoolean) {\n-  TakeOptions options;\n-  this->AssertTake(\"[true, false, true]\", \"[0, 1, 0]\", options, \"[true, false, true]\");\n-  this->AssertTake(\"[null, false, true]\", \"[0, 1, 0]\", options, \"[null, false, null]\");\n-  this->AssertTake(\"[true, false, true]\", \"[null, 1, 0]\", options, \"[null, false, true]\");\n+  this->AssertTake(\"[true, false, true]\", \"[0, 1, 0]\", \"[true, false, true]\");\n+  this->AssertTake(\"[null, false, true]\", \"[0, 1, 0]\", \"[null, false, null]\");\n+  this->AssertTake(\"[true, false, true]\", \"[null, 1, 0]\", \"[null, false, true]\");\n \n   std::shared_ptr<Array> arr;\n-  ASSERT_RAISES(IndexError, this->Take(boolean(), \"[true, false, true]\", int8(),\n-                                       \"[0, 9, 0]\", options, &arr));\n+  ASSERT_RAISES(IndexError,\n+                this->Take(boolean(), \"[true, false, true]\", int8(), \"[0, 9, 0]\", &arr));\n }\n \n template <typename ArrowType>\n class TestTakeKernelWithNumeric : public TestTakeKernel<ArrowType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<ArrowType>::AssertTake(type_singleton(), values, indices, options,\n-                                          expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<ArrowType>::AssertTake(type_singleton(), values, indices, expected);\n   }\n   std::shared_ptr<DataType> type_singleton() {\n     return TypeTraits<ArrowType>::type_singleton();\n   }\n+  void ValidateTake(const std::shared_ptr<Array>& values,\n+                    const std::shared_ptr<Array>& indices_boxed) {\n+    std::shared_ptr<Array> taken;\n+    TakeOptions options;\n+    ASSERT_OK(\n+        arrow::compute::Take(&this->ctx_, *values, *indices_boxed, options, &taken));\n+    ASSERT_EQ(indices_boxed->length(), taken->length());\n+\n+    ASSERT_EQ(indices_boxed->type_id(), Type::INT32);\n+    auto indices = checked_pointer_cast<Int32Array>(indices_boxed);\n+    for (int64_t i = 0; i < indices->length(); ++i) {\n+      if (indices->IsNull(i)) {\n+        ASSERT_TRUE(taken->IsNull(i));\n+        continue;\n+      }\n+      int32_t taken_index = indices->Value(i);\n+      ASSERT_TRUE(values->RangeEquals(taken_index, taken_index + 1, i, taken));\n+    }\n+  }\n };\n \n TYPED_TEST_CASE(TestTakeKernelWithNumeric, NumericArrowTypes);\n TYPED_TEST(TestTakeKernelWithNumeric, TakeNumeric) {\n-  TakeOptions options;\n-  this->AssertTake(\"[7, 8, 9]\", \"[0, 1, 0]\", options, \"[7, 8, 7]\");\n-  this->AssertTake(\"[null, 8, 9]\", \"[0, 1, 0]\", options, \"[null, 8, null]\");\n-  this->AssertTake(\"[7, 8, 9]\", \"[null, 1, 0]\", options, \"[null, 8, 7]\");\n-  this->AssertTake(\"[null, 8, 9]\", \"[]\", options, \"[]\");\n+  this->AssertTake(\"[7, 8, 9]\", \"[0, 1, 0]\", \"[7, 8, 7]\");\n+  this->AssertTake(\"[null, 8, 9]\", \"[0, 1, 0]\", \"[null, 8, null]\");\n+  this->AssertTake(\"[7, 8, 9]\", \"[null, 1, 0]\", \"[null, 8, 7]\");\n+  this->AssertTake(\"[null, 8, 9]\", \"[]\", \"[]\");\n \n   std::shared_ptr<Array> arr;\n   ASSERT_RAISES(IndexError, this->Take(this->type_singleton(), \"[7, 8, 9]\", int8(),\n-                                       \"[0, 9, 0]\", options, &arr));\n+                                       \"[0, 9, 0]\", &arr));\n+}\n+\n+TYPED_TEST(TestTakeKernelWithNumeric, TakeRandomNumeric) {\n+  auto rand = random::RandomArrayGenerator(kSeed);\n+  for (size_t i = 3; i < 8; i++) {\n+    const int64_t length = static_cast<int64_t>(1ULL << i);\n+    for (size_t j = 0; j < 13; j++) {\n+      const int64_t indices_length = static_cast<int64_t>(1ULL << j);\n+      for (auto null_probability : {0.0, 0.01, 0.1, 0.25, 0.5, 1.0}) {\n \n Review comment:\n   Don't think it's useful to test so many probabilities...\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:08:18.952+0000",
                    "updated": "2019-06-25T13:08:18.952+0000",
                    "started": "2019-06-25T13:08:18.951+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266629",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266630",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297170587\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-internal.h\n ##########\n @@ -0,0 +1,573 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <limits>\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/stl.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename Builder, typename Scalar>\n+static Status UnsafeAppend(Builder* builder, Scalar&& value) {\n+  builder->UnsafeAppend(std::forward<Scalar>(value));\n+  return Status::OK();\n+}\n+\n+static Status UnsafeAppend(BinaryBuilder* builder, util::string_view value) {\n+  RETURN_NOT_OK(builder->ReserveData(static_cast<int64_t>(value.size())));\n+  builder->UnsafeAppend(value);\n+  return Status::OK();\n+}\n+\n+static Status UnsafeAppend(StringBuilder* builder, util::string_view value) {\n+  RETURN_NOT_OK(builder->ReserveData(static_cast<int64_t>(value.size())));\n+  builder->UnsafeAppend(value);\n+  return Status::OK();\n+}\n+\n+template <typename IndexSequence>\n+class Taker {\n+ public:\n+  explicit Taker(const std::shared_ptr<DataType>& type) : type_(type) {}\n+\n+  virtual ~Taker() = default;\n+\n+  virtual Status MakeChildren() { return Status::OK(); }\n+\n+  virtual Status Init(MemoryPool* pool) = 0;\n+\n+  virtual Status Take(const Array& values, IndexSequence indices) = 0;\n+\n+  virtual Status Finish(std::shared_ptr<Array>*) = 0;\n+\n+  static Status Make(const std::shared_ptr<DataType>& type, std::unique_ptr<Taker>* out);\n+\n+  static_assert(std::is_copy_constructible<IndexSequence>::value,\n+                \"Index sequences must be copy constructible\");\n+\n+  static_assert(\n+      IndexSequence::take_null_index == std::numeric_limits<int64_t>::min(),\n+      \"Index sequences must declare a taken element as null with index == LONG_MIN\");\n+\n+  static_assert(\n+      std::is_same<decltype(IndexSequence::never_out_of_bounds), const bool>::value,\n+      \"Index sequences must declare whether bounds checking is necessary\");\n+\n+  static_assert(\n+      std::is_same<decltype(std::declval<IndexSequence>().Next()), int64_t>::value,\n+      \"An index sequence must yield indices of type int64_t.\");\n+\n+  static_assert(std::is_same<decltype(std::declval<const IndexSequence>().length()),\n+                             int64_t>::value,\n+                \"An index sequence must provide its length.\");\n+\n+  static_assert(std::is_same<decltype(std::declval<const IndexSequence>().null_count()),\n+                             int64_t>::value,\n+                \"An index sequence must provide the number of nulls it will take.\");\n+\n+ protected:\n+  Status OutOfBounds() { return Status::IndexError(\"take index out of bounds\"); }\n+\n+  Status BoundsCheck(const Array& values, int64_t index) {\n+    if (IndexSequence::never_out_of_bounds) {\n+      return Status::OK();\n+    }\n+    if (index == IndexSequence::take_null_index) {\n+      return Status::OK();\n+    }\n+    if (index < 0 || index >= values.length()) {\n+      return OutOfBounds();\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status BoundsCheckedNext(const Array& values, IndexSequence* indices, int64_t* index) {\n+    *index = indices->Next();\n+    return BoundsCheck(values, *index);\n+  }\n+\n+  template <typename Builder>\n+  Status MakeBuilder(MemoryPool* pool, std::unique_ptr<Builder>* out) {\n+    std::unique_ptr<ArrayBuilder> builder;\n+    RETURN_NOT_OK(arrow::MakeBuilder(pool, type_, &builder));\n+    out->reset(checked_cast<Builder*>(builder.release()));\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<DataType> type_;\n+};\n+\n+class RangeIndexSequence {\n+ public:\n+  static constexpr int64_t take_null_index = std::numeric_limits<int64_t>::min();\n+  static constexpr bool never_out_of_bounds = true;\n+\n+  RangeIndexSequence(int64_t offset, int64_t length) : index_(offset), length_(length) {}\n+\n+  int64_t Next() { return index_++; }\n+\n+  int64_t length() const { return length_; }\n+\n+  int64_t null_count() const { return 0; }\n+\n+ private:\n+  int64_t index_ = 0, length_ = -1;\n+};\n+\n+class RangeOrNullIndexSequence {\n+ public:\n+  static constexpr int64_t take_null_index = std::numeric_limits<int64_t>::min();\n+  static constexpr bool never_out_of_bounds = true;\n+\n+  RangeOrNullIndexSequence(int64_t offset_or_null, int64_t length)\n+      : index_(offset_or_null), length_(length) {}\n+\n+  int64_t Next() {\n+    if (index_ == take_null_index) {\n+      return take_null_index;\n+    }\n+    return index_++;\n+  }\n+\n+  int64_t length() const { return length_; }\n+\n+  int64_t null_count() const { return index_ == take_null_index ? length_ : 0; }\n+\n+ private:\n+  int64_t index_ = 0, length_ = -1;\n+};\n+\n+template <typename IndexSequence, typename T>\n+class TakerImpl;\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, NullType> : public Taker<IndexSequence> {\n+ public:\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status Init(MemoryPool*) override { return Status::OK(); }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+\n+    if (!IndexSequence::never_out_of_bounds) {\n+      for (int64_t index, i = 0; i < indices.length(); ++i) {\n+        RETURN_NOT_OK(this->BoundsCheckedNext(values, &indices, &index));\n+      }\n+    }\n+\n+    length_ += indices.length();\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    out->reset(new NullArray(length_));\n+    return Status::OK();\n+  }\n+\n+ private:\n+  int64_t length_ = 0;\n+};\n+\n+template <typename IndexSequence, typename T>\n+class TakerImpl : public Taker<IndexSequence> {\n+ public:\n+  using ArrayType = typename TypeTraits<T>::ArrayType;\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status Init(MemoryPool* pool) override { return this->MakeBuilder(pool, &builder_); }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+    RETURN_NOT_OK(builder_->Reserve(indices.length()));\n+\n+    if (indices.null_count() == 0) {\n+      if (values.null_count() == 0) {\n+        return Take<false, false>(values, indices);\n+      } else {\n+        return Take<false, true>(values, indices);\n+      }\n+    } else {\n+      if (values.null_count() == 0) {\n+        return Take<true, false>(values, indices);\n+      } else {\n+        return Take<true, true>(values, indices);\n+      }\n+    }\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override { return builder_->Finish(out); }\n+\n+ private:\n+  template <bool SomeIndicesNull, bool SomeValuesNull>\n+  Status Take(const Array& values, IndexSequence indices) {\n+    for (int64_t i = 0; i < indices.length(); ++i) {\n+      int64_t index = indices.Next();\n+\n+      if (SomeIndicesNull && index == IndexSequence::take_null_index) {\n+        builder_->UnsafeAppendNull();\n+        continue;\n+      }\n+\n+      RETURN_NOT_OK(this->BoundsCheck(values, index));\n+\n+      if (SomeValuesNull && values.IsNull(index)) {\n+        builder_->UnsafeAppendNull();\n+        continue;\n+      }\n+\n+      auto value = checked_cast<const ArrayType&>(values).GetView(index);\n+      RETURN_NOT_OK(UnsafeAppend(builder_.get(), value));\n+    }\n+    return Status::OK();\n+  }\n+\n+  std::unique_ptr<BuilderType> builder_;\n+};\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, ListType> : public Taker<IndexSequence> {\n+ public:\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status MakeChildren() override {\n+    const auto& list_type = checked_cast<const ListType&>(*this->type_);\n+    return Taker<RangeIndexSequence>::Make(list_type.value_type(), &value_taker_);\n+  }\n+\n+  Status Init(MemoryPool* pool) override {\n+    null_bitmap_builder_.reset(new TypedBufferBuilder<bool>(pool));\n+    offset_builder_.reset(new TypedBufferBuilder<int32_t>(pool));\n+    return value_taker_->Init(pool);\n+  }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+\n+    const auto& list_array = checked_cast<const ListArray&>(values);\n+\n+    RETURN_NOT_OK(null_bitmap_builder_->Reserve(indices.length()));\n+    RETURN_NOT_OK(offset_builder_->Reserve(indices.length() + 1));\n+    int32_t offset = 0;\n+    offset_builder_->UnsafeAppend(offset);\n+\n+    for (int64_t index, i = 0; i < indices.length(); ++i) {\n+      RETURN_NOT_OK(this->BoundsCheckedNext(values, &indices, &index));\n+\n+      bool is_valid = index != IndexSequence::take_null_index && values.IsValid(index);\n+      null_bitmap_builder_->UnsafeAppend(is_valid);\n+\n+      if (is_valid) {\n+        offset += list_array.value_length(index);\n+        RangeIndexSequence value_indices(list_array.value_offset(index),\n+                                         list_array.value_length(index));\n+        RETURN_NOT_OK(value_taker_->Take(*list_array.values(), value_indices));\n+      }\n+      offset_builder_->UnsafeAppend(offset);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override { return FinishAs<ListArray>(out); }\n+\n+ protected:\n+  template <typename T>\n+  Status FinishAs(std::shared_ptr<Array>* out) {\n+    auto null_count = null_bitmap_builder_->false_count();\n+    auto length = null_bitmap_builder_->length();\n+\n+    std::shared_ptr<Buffer> offsets, null_bitmap;\n+    RETURN_NOT_OK(null_bitmap_builder_->Finish(&null_bitmap));\n+    RETURN_NOT_OK(offset_builder_->Finish(&offsets));\n+\n+    std::shared_ptr<Array> taken_values;\n+    RETURN_NOT_OK(value_taker_->Finish(&taken_values));\n+\n+    out->reset(\n+        new T(this->type_, length, offsets, taken_values, null_bitmap, null_count));\n+    return Status::OK();\n+  }\n+\n+  std::unique_ptr<TypedBufferBuilder<bool>> null_bitmap_builder_;\n+  std::unique_ptr<TypedBufferBuilder<int32_t>> offset_builder_;\n+  std::unique_ptr<Taker<RangeIndexSequence>> value_taker_;\n+};\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, MapType> : public TakerImpl<IndexSequence, ListType> {\n+ public:\n+  using TakerImpl<IndexSequence, ListType>::TakerImpl;\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    return this->template FinishAs<MapArray>(out);\n+  }\n+};\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, FixedSizeListType> : public Taker<IndexSequence> {\n+ public:\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status MakeChildren() override {\n+    const auto& list_type = checked_cast<const FixedSizeListType&>(*this->type_);\n+    return Taker<RangeOrNullIndexSequence>::Make(list_type.value_type(), &value_taker_);\n+  }\n+\n+  Status Init(MemoryPool* pool) override {\n+    null_bitmap_builder_.reset(new TypedBufferBuilder<bool>(pool));\n+    return value_taker_->Init(pool);\n+  }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+\n+    const auto& list_array = checked_cast<const FixedSizeListArray&>(values);\n+    auto list_size = list_array.list_type()->list_size();\n+\n+    RETURN_NOT_OK(null_bitmap_builder_->Reserve(indices.length()));\n+\n+    for (int64_t index, i = 0; i < indices.length(); ++i) {\n+      RETURN_NOT_OK(this->BoundsCheckedNext(values, &indices, &index));\n+\n+      bool is_valid = index != IndexSequence::take_null_index && values.IsValid(index);\n+      null_bitmap_builder_->UnsafeAppend(is_valid);\n+\n+      RangeOrNullIndexSequence value_indices(\n+          is_valid ? list_array.value_offset(index) : IndexSequence::take_null_index,\n+          list_size);\n+      RETURN_NOT_OK(value_taker_->Take(*list_array.values(), value_indices));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    auto null_count = null_bitmap_builder_->false_count();\n+    auto length = null_bitmap_builder_->length();\n+\n+    std::shared_ptr<Buffer> null_bitmap;\n+    RETURN_NOT_OK(null_bitmap_builder_->Finish(&null_bitmap));\n+\n+    std::shared_ptr<Array> taken_values;\n+    RETURN_NOT_OK(value_taker_->Finish(&taken_values));\n+\n+    out->reset(new FixedSizeListArray(this->type_, length, taken_values, null_bitmap,\n+                                      null_count));\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  std::unique_ptr<TypedBufferBuilder<bool>> null_bitmap_builder_;\n+  std::unique_ptr<Taker<RangeOrNullIndexSequence>> value_taker_;\n+};\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, StructType> : public Taker<IndexSequence> {\n+ public:\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status MakeChildren() override {\n+    children_.resize(this->type_->num_children());\n+    for (int i = 0; i < this->type_->num_children(); ++i) {\n+      RETURN_NOT_OK(\n+          Taker<IndexSequence>::Make(this->type_->child(i)->type(), &children_[i]));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Init(MemoryPool* pool) override {\n+    null_bitmap_builder_.reset(new TypedBufferBuilder<bool>(pool));\n+    for (int i = 0; i < this->type_->num_children(); ++i) {\n+      RETURN_NOT_OK(children_[i]->Init(pool));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+\n+    const auto& struct_array = checked_cast<const StructArray&>(values);\n+    for (int i = 0; i < this->type_->num_children(); ++i) {\n+      RETURN_NOT_OK(children_[i]->Take(*struct_array.field(i), indices));\n+    }\n+    // TODO(bkietz) each child is doing bounds checking; this only needs to happen once\n+\n+    RETURN_NOT_OK(null_bitmap_builder_->Reserve(indices.length()));\n+    for (int64_t i = 0; i < indices.length(); ++i) {\n+      int64_t index = indices.Next();\n+      null_bitmap_builder_->UnsafeAppend(index != IndexSequence::take_null_index &&\n+                                         values.IsValid(index));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    auto null_count = null_bitmap_builder_->false_count();\n+    auto length = null_bitmap_builder_->length();\n+    std::shared_ptr<Buffer> null_bitmap;\n+    RETURN_NOT_OK(null_bitmap_builder_->Finish(&null_bitmap));\n+\n+    ArrayVector fields(this->type_->num_children());\n+    for (int i = 0; i < this->type_->num_children(); ++i) {\n+      RETURN_NOT_OK(children_[i]->Finish(&fields[i]));\n+    }\n+\n+    out->reset(\n+        new StructArray(this->type_, length, std::move(fields), null_bitmap, null_count));\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  std::unique_ptr<TypedBufferBuilder<bool>> null_bitmap_builder_;\n+  std::vector<std::unique_ptr<Taker<IndexSequence>>> children_;\n+};\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, DictionaryType> : public Taker<IndexSequence> {\n+ public:\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status MakeChildren() override {\n+    const auto& dict_type = checked_cast<const DictionaryType&>(*this->type_);\n+    return Taker<IndexSequence>::Make(dict_type.index_type(), &index_taker_);\n+  }\n+\n+  Status Init(MemoryPool* pool) override {\n+    dictionary_ = nullptr;\n+    return index_taker_->Init(pool);\n+  }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+    const auto& dict_array = checked_cast<const DictionaryArray&>(values);\n+\n+    if (dictionary_ != nullptr && dictionary_ != dict_array.dictionary()) {\n+      return Status::NotImplemented(\n+          \"taking from DictionaryArrays with different dictionaries\");\n+    } else {\n+      dictionary_ = dict_array.dictionary();\n+    }\n+    return index_taker_->Take(*dict_array.indices(), indices);\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    std::shared_ptr<Array> taken_indices;\n+    RETURN_NOT_OK(index_taker_->Finish(&taken_indices));\n+    out->reset(new DictionaryArray(this->type_, taken_indices, dictionary_));\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  std::shared_ptr<Array> dictionary_;\n+  std::unique_ptr<Taker<IndexSequence>> index_taker_;\n+};\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, ExtensionType> : public Taker<IndexSequence> {\n+ public:\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status MakeChildren() override {\n+    const auto& ext_type = checked_cast<const ExtensionType&>(*this->type_);\n+    return Taker<IndexSequence>::Make(ext_type.storage_type(), &storage_taker_);\n+  }\n+\n+  Status Init(MemoryPool* pool) override { return storage_taker_->Init(pool); }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+    const auto& ext_array = checked_cast<const ExtensionArray&>(values);\n+    return storage_taker_->Take(*ext_array.storage(), indices);\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    std::shared_ptr<Array> taken_storage;\n+    RETURN_NOT_OK(storage_taker_->Finish(&taken_storage));\n+    out->reset(new ExtensionArray(this->type_, taken_storage));\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  std::unique_ptr<Taker<IndexSequence>> storage_taker_;\n+};\n+\n+template <typename IndexSequence>\n+struct TakerMakeImpl {\n+  Status Visit(const NullType&) { return Make<NullType>(); }\n+\n+  template <typename Fixed>\n+  typename std::enable_if<std::is_base_of<FixedWidthType, Fixed>::value, Status>::type\n+  Visit(const Fixed&) {\n+    return Make<Fixed>();\n+  }\n+\n+  Status Visit(const BinaryType&) { return Make<BinaryType>(); }\n+\n+  Status Visit(const StringType&) { return Make<StringType>(); }\n+\n+  Status Visit(const ListType&) { return Make<ListType>(); }\n+\n+  Status Visit(const MapType&) { return Make<MapType>(); }\n+\n+  Status Visit(const FixedSizeListType&) { return Make<FixedSizeListType>(); }\n+\n+  Status Visit(const StructType& t) { return Make<StructType>(); }\n+\n+  Status Visit(const DictionaryType& t) { return Make<DictionaryType>(); }\n+\n+  Status Visit(const ExtensionType& t) { return Make<ExtensionType>(); }\n+\n+  Status Visit(const DataType& t) {\n+    return Status::NotImplemented(\"gathering values of type \", t);\n \n Review comment:\n   `t.ToString()`, no?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:08:18.956+0000",
                    "updated": "2019-06-25T13:08:18.956+0000",
                    "started": "2019-06-25T13:08:18.955+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266630",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266631",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297174669\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-test.cc\n ##########\n @@ -62,82 +67,111 @@ class TestTakeKernel : public ComputeFixture, public TestBase {\n class TestTakeKernelWithNull : public TestTakeKernel<NullType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, options, expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, expected);\n   }\n };\n \n TEST_F(TestTakeKernelWithNull, TakeNull) {\n-  TakeOptions options;\n-  this->AssertTake(\"[null, null, null]\", \"[0, 1, 0]\", options, \"[null, null, null]\");\n+  this->AssertTake(\"[null, null, null]\", \"[0, 1, 0]\", \"[null, null, null]\");\n \n   std::shared_ptr<Array> arr;\n-  ASSERT_RAISES(IndexError, this->Take(null(), \"[null, null, null]\", int8(), \"[0, 9, 0]\",\n-                                       options, &arr));\n+  ASSERT_RAISES(IndexError,\n+                this->Take(null(), \"[null, null, null]\", int8(), \"[0, 9, 0]\", &arr));\n }\n \n TEST_F(TestTakeKernelWithNull, InvalidIndexType) {\n-  TakeOptions options;\n   std::shared_ptr<Array> arr;\n   ASSERT_RAISES(TypeError, this->Take(null(), \"[null, null, null]\", float32(),\n-                                      \"[0.0, 1.0, 0.1]\", options, &arr));\n+                                      \"[0.0, 1.0, 0.1]\", &arr));\n }\n \n class TestTakeKernelWithBoolean : public TestTakeKernel<BooleanType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<BooleanType>::AssertTake(boolean(), values, indices, options,\n-                                            expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<BooleanType>::AssertTake(boolean(), values, indices, expected);\n   }\n };\n \n TEST_F(TestTakeKernelWithBoolean, TakeBoolean) {\n-  TakeOptions options;\n-  this->AssertTake(\"[true, false, true]\", \"[0, 1, 0]\", options, \"[true, false, true]\");\n-  this->AssertTake(\"[null, false, true]\", \"[0, 1, 0]\", options, \"[null, false, null]\");\n-  this->AssertTake(\"[true, false, true]\", \"[null, 1, 0]\", options, \"[null, false, true]\");\n+  this->AssertTake(\"[true, false, true]\", \"[0, 1, 0]\", \"[true, false, true]\");\n+  this->AssertTake(\"[null, false, true]\", \"[0, 1, 0]\", \"[null, false, null]\");\n+  this->AssertTake(\"[true, false, true]\", \"[null, 1, 0]\", \"[null, false, true]\");\n \n   std::shared_ptr<Array> arr;\n-  ASSERT_RAISES(IndexError, this->Take(boolean(), \"[true, false, true]\", int8(),\n-                                       \"[0, 9, 0]\", options, &arr));\n+  ASSERT_RAISES(IndexError,\n+                this->Take(boolean(), \"[true, false, true]\", int8(), \"[0, 9, 0]\", &arr));\n }\n \n template <typename ArrowType>\n class TestTakeKernelWithNumeric : public TestTakeKernel<ArrowType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<ArrowType>::AssertTake(type_singleton(), values, indices, options,\n-                                          expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<ArrowType>::AssertTake(type_singleton(), values, indices, expected);\n   }\n   std::shared_ptr<DataType> type_singleton() {\n     return TypeTraits<ArrowType>::type_singleton();\n   }\n+  void ValidateTake(const std::shared_ptr<Array>& values,\n+                    const std::shared_ptr<Array>& indices_boxed) {\n+    std::shared_ptr<Array> taken;\n+    TakeOptions options;\n+    ASSERT_OK(\n+        arrow::compute::Take(&this->ctx_, *values, *indices_boxed, options, &taken));\n \n Review comment:\n   Call `ValidateArray` on `taken`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:08:19.009+0000",
                    "updated": "2019-06-25T13:08:19.009+0000",
                    "started": "2019-06-25T13:08:19.008+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266631",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266632",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297176780\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-test.cc\n ##########\n @@ -147,28 +181,129 @@ class TestTakeKernelWithString : public TestTakeKernel<StringType> {\n     ASSERT_OK(DictionaryArray::FromArrays(type, ArrayFromJSON(int8(), expected_indices),\n                                           dict, &expected));\n     auto take_indices = ArrayFromJSON(int8(), indices);\n-    this->AssertTakeArrays(values, take_indices, options, expected);\n+    this->AssertTakeArrays(values, take_indices, expected);\n   }\n };\n \n TEST_F(TestTakeKernelWithString, TakeString) {\n-  TakeOptions options;\n-  this->AssertTake(R\"([\"a\", \"b\", \"c\"])\", \"[0, 1, 0]\", options, R\"([\"a\", \"b\", \"a\"])\");\n-  this->AssertTake(R\"([null, \"b\", \"c\"])\", \"[0, 1, 0]\", options, \"[null, \\\"b\\\", null]\");\n-  this->AssertTake(R\"([\"a\", \"b\", \"c\"])\", \"[null, 1, 0]\", options, R\"([null, \"b\", \"a\"])\");\n+  this->AssertTake(R\"([\"a\", \"b\", \"c\"])\", \"[0, 1, 0]\", R\"([\"a\", \"b\", \"a\"])\");\n+  this->AssertTake(R\"([null, \"b\", \"c\"])\", \"[0, 1, 0]\", \"[null, \\\"b\\\", null]\");\n+  this->AssertTake(R\"([\"a\", \"b\", \"c\"])\", \"[null, 1, 0]\", R\"([null, \"b\", \"a\"])\");\n \n   std::shared_ptr<Array> arr;\n-  ASSERT_RAISES(IndexError, this->Take(utf8(), R\"([\"a\", \"b\", \"c\"])\", int8(), \"[0, 9, 0]\",\n-                                       options, &arr));\n+  ASSERT_RAISES(IndexError,\n+                this->Take(utf8(), R\"([\"a\", \"b\", \"c\"])\", int8(), \"[0, 9, 0]\", &arr));\n+  ASSERT_RAISES(IndexError, this->Take(utf8(), R\"([\"a\", \"b\", null, \"ddd\", \"ee\"])\",\n+                                       int64(), \"[2, 5]\", &arr));\n }\n \n TEST_F(TestTakeKernelWithString, TakeDictionary) {\n-  TakeOptions options;\n   auto dict = R\"([\"a\", \"b\", \"c\", \"d\", \"e\"])\";\n-  this->AssertTakeDictionary(dict, \"[3, 4, 2]\", \"[0, 1, 0]\", options, \"[3, 4, 3]\");\n-  this->AssertTakeDictionary(dict, \"[null, 4, 2]\", \"[0, 1, 0]\", options,\n-                             \"[null, 4, null]\");\n-  this->AssertTakeDictionary(dict, \"[3, 4, 2]\", \"[null, 1, 0]\", options, \"[null, 4, 3]\");\n+  this->AssertTakeDictionary(dict, \"[3, 4, 2]\", \"[0, 1, 0]\", \"[3, 4, 3]\");\n+  this->AssertTakeDictionary(dict, \"[null, 4, 2]\", \"[0, 1, 0]\", \"[null, 4, null]\");\n+  this->AssertTakeDictionary(dict, \"[3, 4, 2]\", \"[null, 1, 0]\", \"[null, 4, 3]\");\n+}\n+\n+class TestTakeKernelWithList : public TestTakeKernel<ListType> {};\n+\n+TEST_F(TestTakeKernelWithList, TakeListInt32) {\n \n Review comment:\n   Add a test with a nested list?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:08:19.015+0000",
                    "updated": "2019-06-25T13:08:19.015+0000",
                    "started": "2019-06-25T13:08:19.013+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266632",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266636",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on issue #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#issuecomment-505439712\n \n \n   The benchmarks for Filter with this refactor show a slight improvement over [previous](https://github.com/apache/arrow/pull/4366#discussion_r293970853):\r\n   ```\r\n   ----------------------------------------------------------------------------------------------------------\r\n   Benchmark                                                   Time           CPU Iterations UserCounters...\r\n   ----------------------------------------------------------------------------------------------------------\r\n   FilterInt64/32768/0/min_time:1.000                      16321 ns      16321 ns      85904 null_percent=0 size=32.768k   1.86981GB/s\r\n   FilterInt64/32768/1/min_time:1.000                      16431 ns      16431 ns      84487 null_percent=1 size=32.768k   1.85729GB/s\r\n   FilterInt64/32768/10/min_time:1.000                     19935 ns      19935 ns      70396 null_percent=10 size=32.768k   1.53088GB/s\r\n   FilterInt64/32768/50/min_time:1.000                     39153 ns      39153 ns      35976 null_percent=50 size=32.768k   798.148MB/s\r\n   FilterInt64/1048576/1/min_time:1.000                   882180 ns     882176 ns       1590 null_percent=1 size=1048.58k   1.10699GB/s\r\n   FilterInt64/8388608/1/min_time:1.000                  7038037 ns    7038002 ns        200 null_percent=1 size=8.38861M   1.11005GB/s\r\n   FilterFixedSizeList1Int64/32768/0/min_time:1.000        44414 ns      44414 ns      31993 null_percent=0 size=32.768k   703.614MB/s\r\n   FilterFixedSizeList1Int64/32768/1/min_time:1.000        45416 ns      45416 ns      30649 null_percent=1 size=32.768k    688.08MB/s\r\n   FilterFixedSizeList1Int64/32768/10/min_time:1.000       57006 ns      57006 ns      24561 null_percent=10 size=32.768k   548.193MB/s\r\n   FilterFixedSizeList1Int64/32768/50/min_time:1.000      104088 ns     104088 ns      13318 null_percent=50 size=32.768k   300.227MB/s\r\n   FilterFixedSizeList1Int64/1048576/1/min_time:1.000    1590805 ns    1590798 ns        887 null_percent=1 size=1048.58k   628.615MB/s\r\n   FilterFixedSizeList1Int64/8388608/1/min_time:1.000   12718793 ns   12718723 ns        110 null_percent=1 size=8.38861M   628.994MB/s\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:16:09.883+0000",
                    "updated": "2019-06-25T13:16:09.883+0000",
                    "started": "2019-06-25T13:16:09.882+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266636",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266637",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297181706\n \n \n\n ##########\n File path: python/pyarrow/tests/test_compute.py\n ##########\n @@ -51,7 +51,10 @@ def test_sum(arrow_type):\n     ('double', np.arange(0, 0.5, 0.1)),\n     ('string', ['a', 'b', None, 'ddd', 'ee']),\n     ('binary', [b'a', b'b', b'c', b'ddd', b'ee']),\n-    (pa.binary(3), [b'abc', b'bcd', b'cde', b'def', b'efg'])\n+    (pa.binary(3), [b'abc', b'bcd', b'cde', b'def', b'efg']),\n+    (pa.list_(pa.int8()), [[1, 2], [3, 4], [5, 6], None, [9, 16]]),\n+    (pa.struct([('a', pa.int8()), ('b', pa.int8())]), [\n+     {'a': 1, 'b': 2}, None, {'a': 3, 'b': 4}, None, {'a': 5, 'b': 6}]),\n ])\n def test_take(ty, values):\n \n Review comment:\n   sure\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:16:41.225+0000",
                    "updated": "2019-06-25T13:16:41.225+0000",
                    "started": "2019-06-25T13:16:41.224+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266637",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266638",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297182184\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-internal.h\n ##########\n @@ -0,0 +1,573 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <limits>\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/stl.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename Builder, typename Scalar>\n+static Status UnsafeAppend(Builder* builder, Scalar&& value) {\n+  builder->UnsafeAppend(std::forward<Scalar>(value));\n+  return Status::OK();\n+}\n+\n+static Status UnsafeAppend(BinaryBuilder* builder, util::string_view value) {\n+  RETURN_NOT_OK(builder->ReserveData(static_cast<int64_t>(value.size())));\n \n Review comment:\n   That's not a problem. I'll write a benchmark so we can watch the difference.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:17:38.849+0000",
                    "updated": "2019-06-25T13:17:38.849+0000",
                    "started": "2019-06-25T13:17:38.848+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266638",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266641",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297182818\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-internal.h\n ##########\n @@ -0,0 +1,573 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <algorithm>\n+#include <limits>\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/builder.h\"\n+#include \"arrow/compute/context.h\"\n+#include \"arrow/util/bit-util.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/stl.h\"\n+#include \"arrow/visitor_inline.h\"\n+\n+namespace arrow {\n+namespace compute {\n+\n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+\n+template <typename Builder, typename Scalar>\n+static Status UnsafeAppend(Builder* builder, Scalar&& value) {\n+  builder->UnsafeAppend(std::forward<Scalar>(value));\n+  return Status::OK();\n+}\n+\n+static Status UnsafeAppend(BinaryBuilder* builder, util::string_view value) {\n+  RETURN_NOT_OK(builder->ReserveData(static_cast<int64_t>(value.size())));\n+  builder->UnsafeAppend(value);\n+  return Status::OK();\n+}\n+\n+static Status UnsafeAppend(StringBuilder* builder, util::string_view value) {\n+  RETURN_NOT_OK(builder->ReserveData(static_cast<int64_t>(value.size())));\n+  builder->UnsafeAppend(value);\n+  return Status::OK();\n+}\n+\n+template <typename IndexSequence>\n+class Taker {\n+ public:\n+  explicit Taker(const std::shared_ptr<DataType>& type) : type_(type) {}\n+\n+  virtual ~Taker() = default;\n+\n+  virtual Status MakeChildren() { return Status::OK(); }\n+\n+  virtual Status Init(MemoryPool* pool) = 0;\n+\n+  virtual Status Take(const Array& values, IndexSequence indices) = 0;\n+\n+  virtual Status Finish(std::shared_ptr<Array>*) = 0;\n+\n+  static Status Make(const std::shared_ptr<DataType>& type, std::unique_ptr<Taker>* out);\n+\n+  static_assert(std::is_copy_constructible<IndexSequence>::value,\n+                \"Index sequences must be copy constructible\");\n+\n+  static_assert(\n+      IndexSequence::take_null_index == std::numeric_limits<int64_t>::min(),\n+      \"Index sequences must declare a taken element as null with index == LONG_MIN\");\n+\n+  static_assert(\n+      std::is_same<decltype(IndexSequence::never_out_of_bounds), const bool>::value,\n+      \"Index sequences must declare whether bounds checking is necessary\");\n+\n+  static_assert(\n+      std::is_same<decltype(std::declval<IndexSequence>().Next()), int64_t>::value,\n+      \"An index sequence must yield indices of type int64_t.\");\n+\n+  static_assert(std::is_same<decltype(std::declval<const IndexSequence>().length()),\n+                             int64_t>::value,\n+                \"An index sequence must provide its length.\");\n+\n+  static_assert(std::is_same<decltype(std::declval<const IndexSequence>().null_count()),\n+                             int64_t>::value,\n+                \"An index sequence must provide the number of nulls it will take.\");\n+\n+ protected:\n+  Status OutOfBounds() { return Status::IndexError(\"take index out of bounds\"); }\n+\n+  Status BoundsCheck(const Array& values, int64_t index) {\n+    if (IndexSequence::never_out_of_bounds) {\n+      return Status::OK();\n+    }\n+    if (index == IndexSequence::take_null_index) {\n+      return Status::OK();\n+    }\n+    if (index < 0 || index >= values.length()) {\n+      return OutOfBounds();\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status BoundsCheckedNext(const Array& values, IndexSequence* indices, int64_t* index) {\n+    *index = indices->Next();\n+    return BoundsCheck(values, *index);\n+  }\n+\n+  template <typename Builder>\n+  Status MakeBuilder(MemoryPool* pool, std::unique_ptr<Builder>* out) {\n+    std::unique_ptr<ArrayBuilder> builder;\n+    RETURN_NOT_OK(arrow::MakeBuilder(pool, type_, &builder));\n+    out->reset(checked_cast<Builder*>(builder.release()));\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<DataType> type_;\n+};\n+\n+class RangeIndexSequence {\n+ public:\n+  static constexpr int64_t take_null_index = std::numeric_limits<int64_t>::min();\n+  static constexpr bool never_out_of_bounds = true;\n+\n+  RangeIndexSequence(int64_t offset, int64_t length) : index_(offset), length_(length) {}\n+\n+  int64_t Next() { return index_++; }\n+\n+  int64_t length() const { return length_; }\n+\n+  int64_t null_count() const { return 0; }\n+\n+ private:\n+  int64_t index_ = 0, length_ = -1;\n+};\n+\n+class RangeOrNullIndexSequence {\n+ public:\n+  static constexpr int64_t take_null_index = std::numeric_limits<int64_t>::min();\n+  static constexpr bool never_out_of_bounds = true;\n+\n+  RangeOrNullIndexSequence(int64_t offset_or_null, int64_t length)\n+      : index_(offset_or_null), length_(length) {}\n+\n+  int64_t Next() {\n+    if (index_ == take_null_index) {\n+      return take_null_index;\n+    }\n+    return index_++;\n+  }\n+\n+  int64_t length() const { return length_; }\n+\n+  int64_t null_count() const { return index_ == take_null_index ? length_ : 0; }\n+\n+ private:\n+  int64_t index_ = 0, length_ = -1;\n+};\n+\n+template <typename IndexSequence, typename T>\n+class TakerImpl;\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, NullType> : public Taker<IndexSequence> {\n+ public:\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status Init(MemoryPool*) override { return Status::OK(); }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+\n+    if (!IndexSequence::never_out_of_bounds) {\n+      for (int64_t index, i = 0; i < indices.length(); ++i) {\n+        RETURN_NOT_OK(this->BoundsCheckedNext(values, &indices, &index));\n+      }\n+    }\n+\n+    length_ += indices.length();\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    out->reset(new NullArray(length_));\n+    return Status::OK();\n+  }\n+\n+ private:\n+  int64_t length_ = 0;\n+};\n+\n+template <typename IndexSequence, typename T>\n+class TakerImpl : public Taker<IndexSequence> {\n+ public:\n+  using ArrayType = typename TypeTraits<T>::ArrayType;\n+  using BuilderType = typename TypeTraits<T>::BuilderType;\n+\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status Init(MemoryPool* pool) override { return this->MakeBuilder(pool, &builder_); }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+    RETURN_NOT_OK(builder_->Reserve(indices.length()));\n+\n+    if (indices.null_count() == 0) {\n+      if (values.null_count() == 0) {\n+        return Take<false, false>(values, indices);\n+      } else {\n+        return Take<false, true>(values, indices);\n+      }\n+    } else {\n+      if (values.null_count() == 0) {\n+        return Take<true, false>(values, indices);\n+      } else {\n+        return Take<true, true>(values, indices);\n+      }\n+    }\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override { return builder_->Finish(out); }\n+\n+ private:\n+  template <bool SomeIndicesNull, bool SomeValuesNull>\n+  Status Take(const Array& values, IndexSequence indices) {\n+    for (int64_t i = 0; i < indices.length(); ++i) {\n+      int64_t index = indices.Next();\n+\n+      if (SomeIndicesNull && index == IndexSequence::take_null_index) {\n+        builder_->UnsafeAppendNull();\n+        continue;\n+      }\n+\n+      RETURN_NOT_OK(this->BoundsCheck(values, index));\n+\n+      if (SomeValuesNull && values.IsNull(index)) {\n+        builder_->UnsafeAppendNull();\n+        continue;\n+      }\n+\n+      auto value = checked_cast<const ArrayType&>(values).GetView(index);\n+      RETURN_NOT_OK(UnsafeAppend(builder_.get(), value));\n+    }\n+    return Status::OK();\n+  }\n+\n+  std::unique_ptr<BuilderType> builder_;\n+};\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, ListType> : public Taker<IndexSequence> {\n+ public:\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status MakeChildren() override {\n+    const auto& list_type = checked_cast<const ListType&>(*this->type_);\n+    return Taker<RangeIndexSequence>::Make(list_type.value_type(), &value_taker_);\n+  }\n+\n+  Status Init(MemoryPool* pool) override {\n+    null_bitmap_builder_.reset(new TypedBufferBuilder<bool>(pool));\n+    offset_builder_.reset(new TypedBufferBuilder<int32_t>(pool));\n+    return value_taker_->Init(pool);\n+  }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+\n+    const auto& list_array = checked_cast<const ListArray&>(values);\n+\n+    RETURN_NOT_OK(null_bitmap_builder_->Reserve(indices.length()));\n+    RETURN_NOT_OK(offset_builder_->Reserve(indices.length() + 1));\n+    int32_t offset = 0;\n+    offset_builder_->UnsafeAppend(offset);\n+\n+    for (int64_t index, i = 0; i < indices.length(); ++i) {\n+      RETURN_NOT_OK(this->BoundsCheckedNext(values, &indices, &index));\n+\n+      bool is_valid = index != IndexSequence::take_null_index && values.IsValid(index);\n+      null_bitmap_builder_->UnsafeAppend(is_valid);\n+\n+      if (is_valid) {\n+        offset += list_array.value_length(index);\n+        RangeIndexSequence value_indices(list_array.value_offset(index),\n+                                         list_array.value_length(index));\n+        RETURN_NOT_OK(value_taker_->Take(*list_array.values(), value_indices));\n+      }\n+      offset_builder_->UnsafeAppend(offset);\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override { return FinishAs<ListArray>(out); }\n+\n+ protected:\n+  template <typename T>\n+  Status FinishAs(std::shared_ptr<Array>* out) {\n+    auto null_count = null_bitmap_builder_->false_count();\n+    auto length = null_bitmap_builder_->length();\n+\n+    std::shared_ptr<Buffer> offsets, null_bitmap;\n+    RETURN_NOT_OK(null_bitmap_builder_->Finish(&null_bitmap));\n+    RETURN_NOT_OK(offset_builder_->Finish(&offsets));\n+\n+    std::shared_ptr<Array> taken_values;\n+    RETURN_NOT_OK(value_taker_->Finish(&taken_values));\n+\n+    out->reset(\n+        new T(this->type_, length, offsets, taken_values, null_bitmap, null_count));\n+    return Status::OK();\n+  }\n+\n+  std::unique_ptr<TypedBufferBuilder<bool>> null_bitmap_builder_;\n+  std::unique_ptr<TypedBufferBuilder<int32_t>> offset_builder_;\n+  std::unique_ptr<Taker<RangeIndexSequence>> value_taker_;\n+};\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, MapType> : public TakerImpl<IndexSequence, ListType> {\n+ public:\n+  using TakerImpl<IndexSequence, ListType>::TakerImpl;\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    return this->template FinishAs<MapArray>(out);\n+  }\n+};\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, FixedSizeListType> : public Taker<IndexSequence> {\n+ public:\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status MakeChildren() override {\n+    const auto& list_type = checked_cast<const FixedSizeListType&>(*this->type_);\n+    return Taker<RangeOrNullIndexSequence>::Make(list_type.value_type(), &value_taker_);\n+  }\n+\n+  Status Init(MemoryPool* pool) override {\n+    null_bitmap_builder_.reset(new TypedBufferBuilder<bool>(pool));\n+    return value_taker_->Init(pool);\n+  }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+\n+    const auto& list_array = checked_cast<const FixedSizeListArray&>(values);\n+    auto list_size = list_array.list_type()->list_size();\n+\n+    RETURN_NOT_OK(null_bitmap_builder_->Reserve(indices.length()));\n+\n+    for (int64_t index, i = 0; i < indices.length(); ++i) {\n+      RETURN_NOT_OK(this->BoundsCheckedNext(values, &indices, &index));\n+\n+      bool is_valid = index != IndexSequence::take_null_index && values.IsValid(index);\n+      null_bitmap_builder_->UnsafeAppend(is_valid);\n+\n+      RangeOrNullIndexSequence value_indices(\n+          is_valid ? list_array.value_offset(index) : IndexSequence::take_null_index,\n+          list_size);\n+      RETURN_NOT_OK(value_taker_->Take(*list_array.values(), value_indices));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    auto null_count = null_bitmap_builder_->false_count();\n+    auto length = null_bitmap_builder_->length();\n+\n+    std::shared_ptr<Buffer> null_bitmap;\n+    RETURN_NOT_OK(null_bitmap_builder_->Finish(&null_bitmap));\n+\n+    std::shared_ptr<Array> taken_values;\n+    RETURN_NOT_OK(value_taker_->Finish(&taken_values));\n+\n+    out->reset(new FixedSizeListArray(this->type_, length, taken_values, null_bitmap,\n+                                      null_count));\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  std::unique_ptr<TypedBufferBuilder<bool>> null_bitmap_builder_;\n+  std::unique_ptr<Taker<RangeOrNullIndexSequence>> value_taker_;\n+};\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, StructType> : public Taker<IndexSequence> {\n+ public:\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status MakeChildren() override {\n+    children_.resize(this->type_->num_children());\n+    for (int i = 0; i < this->type_->num_children(); ++i) {\n+      RETURN_NOT_OK(\n+          Taker<IndexSequence>::Make(this->type_->child(i)->type(), &children_[i]));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Init(MemoryPool* pool) override {\n+    null_bitmap_builder_.reset(new TypedBufferBuilder<bool>(pool));\n+    for (int i = 0; i < this->type_->num_children(); ++i) {\n+      RETURN_NOT_OK(children_[i]->Init(pool));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+\n+    const auto& struct_array = checked_cast<const StructArray&>(values);\n+    for (int i = 0; i < this->type_->num_children(); ++i) {\n+      RETURN_NOT_OK(children_[i]->Take(*struct_array.field(i), indices));\n+    }\n+    // TODO(bkietz) each child is doing bounds checking; this only needs to happen once\n+\n+    RETURN_NOT_OK(null_bitmap_builder_->Reserve(indices.length()));\n+    for (int64_t i = 0; i < indices.length(); ++i) {\n+      int64_t index = indices.Next();\n+      null_bitmap_builder_->UnsafeAppend(index != IndexSequence::take_null_index &&\n+                                         values.IsValid(index));\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    auto null_count = null_bitmap_builder_->false_count();\n+    auto length = null_bitmap_builder_->length();\n+    std::shared_ptr<Buffer> null_bitmap;\n+    RETURN_NOT_OK(null_bitmap_builder_->Finish(&null_bitmap));\n+\n+    ArrayVector fields(this->type_->num_children());\n+    for (int i = 0; i < this->type_->num_children(); ++i) {\n+      RETURN_NOT_OK(children_[i]->Finish(&fields[i]));\n+    }\n+\n+    out->reset(\n+        new StructArray(this->type_, length, std::move(fields), null_bitmap, null_count));\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  std::unique_ptr<TypedBufferBuilder<bool>> null_bitmap_builder_;\n+  std::vector<std::unique_ptr<Taker<IndexSequence>>> children_;\n+};\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, DictionaryType> : public Taker<IndexSequence> {\n+ public:\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status MakeChildren() override {\n+    const auto& dict_type = checked_cast<const DictionaryType&>(*this->type_);\n+    return Taker<IndexSequence>::Make(dict_type.index_type(), &index_taker_);\n+  }\n+\n+  Status Init(MemoryPool* pool) override {\n+    dictionary_ = nullptr;\n+    return index_taker_->Init(pool);\n+  }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+    const auto& dict_array = checked_cast<const DictionaryArray&>(values);\n+\n+    if (dictionary_ != nullptr && dictionary_ != dict_array.dictionary()) {\n+      return Status::NotImplemented(\n+          \"taking from DictionaryArrays with different dictionaries\");\n+    } else {\n+      dictionary_ = dict_array.dictionary();\n+    }\n+    return index_taker_->Take(*dict_array.indices(), indices);\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    std::shared_ptr<Array> taken_indices;\n+    RETURN_NOT_OK(index_taker_->Finish(&taken_indices));\n+    out->reset(new DictionaryArray(this->type_, taken_indices, dictionary_));\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  std::shared_ptr<Array> dictionary_;\n+  std::unique_ptr<Taker<IndexSequence>> index_taker_;\n+};\n+\n+template <typename IndexSequence>\n+class TakerImpl<IndexSequence, ExtensionType> : public Taker<IndexSequence> {\n+ public:\n+  using Taker<IndexSequence>::Taker;\n+\n+  Status MakeChildren() override {\n+    const auto& ext_type = checked_cast<const ExtensionType&>(*this->type_);\n+    return Taker<IndexSequence>::Make(ext_type.storage_type(), &storage_taker_);\n+  }\n+\n+  Status Init(MemoryPool* pool) override { return storage_taker_->Init(pool); }\n+\n+  Status Take(const Array& values, IndexSequence indices) override {\n+    DCHECK(this->type_->Equals(values.type()));\n+    const auto& ext_array = checked_cast<const ExtensionArray&>(values);\n+    return storage_taker_->Take(*ext_array.storage(), indices);\n+  }\n+\n+  Status Finish(std::shared_ptr<Array>* out) override {\n+    std::shared_ptr<Array> taken_storage;\n+    RETURN_NOT_OK(storage_taker_->Finish(&taken_storage));\n+    out->reset(new ExtensionArray(this->type_, taken_storage));\n+    return Status::OK();\n+  }\n+\n+ protected:\n+  std::unique_ptr<Taker<IndexSequence>> storage_taker_;\n+};\n+\n+template <typename IndexSequence>\n+struct TakerMakeImpl {\n+  Status Visit(const NullType&) { return Make<NullType>(); }\n+\n+  template <typename Fixed>\n+  typename std::enable_if<std::is_base_of<FixedWidthType, Fixed>::value, Status>::type\n+  Visit(const Fixed&) {\n+    return Make<Fixed>();\n+  }\n+\n+  Status Visit(const BinaryType&) { return Make<BinaryType>(); }\n+\n+  Status Visit(const StringType&) { return Make<StringType>(); }\n+\n+  Status Visit(const ListType&) { return Make<ListType>(); }\n+\n+  Status Visit(const MapType&) { return Make<MapType>(); }\n+\n+  Status Visit(const FixedSizeListType&) { return Make<FixedSizeListType>(); }\n+\n+  Status Visit(const StructType& t) { return Make<StructType>(); }\n+\n+  Status Visit(const DictionaryType& t) { return Make<DictionaryType>(); }\n+\n+  Status Visit(const ExtensionType& t) { return Make<ExtensionType>(); }\n+\n+  Status Visit(const DataType& t) {\n+    return Status::NotImplemented(\"gathering values of type \", t);\n \n Review comment:\n   Not necessary: https://github.com/apache/arrow/blob/master/cpp/src/arrow/type.cc#L127-L131\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:18:58.406+0000",
                    "updated": "2019-06-25T13:18:58.406+0000",
                    "started": "2019-06-25T13:18:58.405+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266641",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266642",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297183021\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-test.cc\n ##########\n @@ -62,82 +67,111 @@ class TestTakeKernel : public ComputeFixture, public TestBase {\n class TestTakeKernelWithNull : public TestTakeKernel<NullType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, options, expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, expected);\n \n Review comment:\n   whoops\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:19:28.145+0000",
                    "updated": "2019-06-25T13:19:28.145+0000",
                    "started": "2019-06-25T13:19:28.144+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266642",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266643",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297183138\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-test.cc\n ##########\n @@ -29,31 +29,36 @@\n namespace arrow {\n namespace compute {\n \n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n using util::string_view;\n \n+constexpr auto kSeed = 0x0ff1ce;\n+\n template <typename ArrowType>\n class TestTakeKernel : public ComputeFixture, public TestBase {\n  protected:\n   void AssertTakeArrays(const std::shared_ptr<Array>& values,\n-                        const std::shared_ptr<Array>& indices, TakeOptions options,\n+                        const std::shared_ptr<Array>& indices,\n                         const std::shared_ptr<Array>& expected) {\n     std::shared_ptr<Array> actual;\n+    TakeOptions options;\n     ASSERT_OK(arrow::compute::Take(&this->ctx_, *values, *indices, options, &actual));\n \n Review comment:\n   Will do\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:19:37.024+0000",
                    "updated": "2019-06-25T13:19:37.024+0000",
                    "started": "2019-06-25T13:19:37.022+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266643",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266644",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297184224\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-test.cc\n ##########\n @@ -62,82 +67,111 @@ class TestTakeKernel : public ComputeFixture, public TestBase {\n class TestTakeKernelWithNull : public TestTakeKernel<NullType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, options, expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, expected);\n   }\n };\n \n TEST_F(TestTakeKernelWithNull, TakeNull) {\n-  TakeOptions options;\n-  this->AssertTake(\"[null, null, null]\", \"[0, 1, 0]\", options, \"[null, null, null]\");\n+  this->AssertTake(\"[null, null, null]\", \"[0, 1, 0]\", \"[null, null, null]\");\n \n   std::shared_ptr<Array> arr;\n-  ASSERT_RAISES(IndexError, this->Take(null(), \"[null, null, null]\", int8(), \"[0, 9, 0]\",\n-                                       options, &arr));\n+  ASSERT_RAISES(IndexError,\n+                this->Take(null(), \"[null, null, null]\", int8(), \"[0, 9, 0]\", &arr));\n }\n \n TEST_F(TestTakeKernelWithNull, InvalidIndexType) {\n-  TakeOptions options;\n   std::shared_ptr<Array> arr;\n   ASSERT_RAISES(TypeError, this->Take(null(), \"[null, null, null]\", float32(),\n-                                      \"[0.0, 1.0, 0.1]\", options, &arr));\n+                                      \"[0.0, 1.0, 0.1]\", &arr));\n }\n \n class TestTakeKernelWithBoolean : public TestTakeKernel<BooleanType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<BooleanType>::AssertTake(boolean(), values, indices, options,\n-                                            expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<BooleanType>::AssertTake(boolean(), values, indices, expected);\n   }\n };\n \n TEST_F(TestTakeKernelWithBoolean, TakeBoolean) {\n-  TakeOptions options;\n-  this->AssertTake(\"[true, false, true]\", \"[0, 1, 0]\", options, \"[true, false, true]\");\n-  this->AssertTake(\"[null, false, true]\", \"[0, 1, 0]\", options, \"[null, false, null]\");\n-  this->AssertTake(\"[true, false, true]\", \"[null, 1, 0]\", options, \"[null, false, true]\");\n+  this->AssertTake(\"[true, false, true]\", \"[0, 1, 0]\", \"[true, false, true]\");\n+  this->AssertTake(\"[null, false, true]\", \"[0, 1, 0]\", \"[null, false, null]\");\n+  this->AssertTake(\"[true, false, true]\", \"[null, 1, 0]\", \"[null, false, true]\");\n \n   std::shared_ptr<Array> arr;\n-  ASSERT_RAISES(IndexError, this->Take(boolean(), \"[true, false, true]\", int8(),\n-                                       \"[0, 9, 0]\", options, &arr));\n+  ASSERT_RAISES(IndexError,\n+                this->Take(boolean(), \"[true, false, true]\", int8(), \"[0, 9, 0]\", &arr));\n }\n \n template <typename ArrowType>\n class TestTakeKernelWithNumeric : public TestTakeKernel<ArrowType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<ArrowType>::AssertTake(type_singleton(), values, indices, options,\n-                                          expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<ArrowType>::AssertTake(type_singleton(), values, indices, expected);\n   }\n   std::shared_ptr<DataType> type_singleton() {\n     return TypeTraits<ArrowType>::type_singleton();\n   }\n+  void ValidateTake(const std::shared_ptr<Array>& values,\n+                    const std::shared_ptr<Array>& indices_boxed) {\n+    std::shared_ptr<Array> taken;\n+    TakeOptions options;\n+    ASSERT_OK(\n+        arrow::compute::Take(&this->ctx_, *values, *indices_boxed, options, &taken));\n+    ASSERT_EQ(indices_boxed->length(), taken->length());\n+\n+    ASSERT_EQ(indices_boxed->type_id(), Type::INT32);\n+    auto indices = checked_pointer_cast<Int32Array>(indices_boxed);\n+    for (int64_t i = 0; i < indices->length(); ++i) {\n+      if (indices->IsNull(i)) {\n+        ASSERT_TRUE(taken->IsNull(i));\n+        continue;\n+      }\n+      int32_t taken_index = indices->Value(i);\n+      ASSERT_TRUE(values->RangeEquals(taken_index, taken_index + 1, i, taken));\n+    }\n+  }\n };\n \n TYPED_TEST_CASE(TestTakeKernelWithNumeric, NumericArrowTypes);\n TYPED_TEST(TestTakeKernelWithNumeric, TakeNumeric) {\n-  TakeOptions options;\n-  this->AssertTake(\"[7, 8, 9]\", \"[0, 1, 0]\", options, \"[7, 8, 7]\");\n-  this->AssertTake(\"[null, 8, 9]\", \"[0, 1, 0]\", options, \"[null, 8, null]\");\n-  this->AssertTake(\"[7, 8, 9]\", \"[null, 1, 0]\", options, \"[null, 8, 7]\");\n-  this->AssertTake(\"[null, 8, 9]\", \"[]\", options, \"[]\");\n+  this->AssertTake(\"[7, 8, 9]\", \"[0, 1, 0]\", \"[7, 8, 7]\");\n+  this->AssertTake(\"[null, 8, 9]\", \"[0, 1, 0]\", \"[null, 8, null]\");\n+  this->AssertTake(\"[7, 8, 9]\", \"[null, 1, 0]\", \"[null, 8, 7]\");\n+  this->AssertTake(\"[null, 8, 9]\", \"[]\", \"[]\");\n \n   std::shared_ptr<Array> arr;\n   ASSERT_RAISES(IndexError, this->Take(this->type_singleton(), \"[7, 8, 9]\", int8(),\n-                                       \"[0, 9, 0]\", options, &arr));\n+                                       \"[0, 9, 0]\", &arr));\n+}\n+\n+TYPED_TEST(TestTakeKernelWithNumeric, TakeRandomNumeric) {\n+  auto rand = random::RandomArrayGenerator(kSeed);\n+  for (size_t i = 3; i < 8; i++) {\n+    const int64_t length = static_cast<int64_t>(1ULL << i);\n+    for (size_t j = 0; j < 13; j++) {\n+      const int64_t indices_length = static_cast<int64_t>(1ULL << j);\n \n Review comment:\n   There are [some](https://github.com/apache/arrow/pull/4531/files#diff-15701e61b85d2ae05898db82dfe9ce67R211) but I could add more\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:21:53.204+0000",
                    "updated": "2019-06-25T13:21:53.204+0000",
                    "started": "2019-06-25T13:21:53.204+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266644",
                    "issueId": "13136681"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/worklog/266645",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #4531: ARROW-2104: [C++] take kernel functions for nested types\nURL: https://github.com/apache/arrow/pull/4531#discussion_r297184371\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/take-test.cc\n ##########\n @@ -62,82 +67,111 @@ class TestTakeKernel : public ComputeFixture, public TestBase {\n class TestTakeKernelWithNull : public TestTakeKernel<NullType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, options, expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<NullType>::AssertTake(utf8(), values, indices, expected);\n   }\n };\n \n TEST_F(TestTakeKernelWithNull, TakeNull) {\n-  TakeOptions options;\n-  this->AssertTake(\"[null, null, null]\", \"[0, 1, 0]\", options, \"[null, null, null]\");\n+  this->AssertTake(\"[null, null, null]\", \"[0, 1, 0]\", \"[null, null, null]\");\n \n   std::shared_ptr<Array> arr;\n-  ASSERT_RAISES(IndexError, this->Take(null(), \"[null, null, null]\", int8(), \"[0, 9, 0]\",\n-                                       options, &arr));\n+  ASSERT_RAISES(IndexError,\n+                this->Take(null(), \"[null, null, null]\", int8(), \"[0, 9, 0]\", &arr));\n }\n \n TEST_F(TestTakeKernelWithNull, InvalidIndexType) {\n-  TakeOptions options;\n   std::shared_ptr<Array> arr;\n   ASSERT_RAISES(TypeError, this->Take(null(), \"[null, null, null]\", float32(),\n-                                      \"[0.0, 1.0, 0.1]\", options, &arr));\n+                                      \"[0.0, 1.0, 0.1]\", &arr));\n }\n \n class TestTakeKernelWithBoolean : public TestTakeKernel<BooleanType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<BooleanType>::AssertTake(boolean(), values, indices, options,\n-                                            expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<BooleanType>::AssertTake(boolean(), values, indices, expected);\n   }\n };\n \n TEST_F(TestTakeKernelWithBoolean, TakeBoolean) {\n-  TakeOptions options;\n-  this->AssertTake(\"[true, false, true]\", \"[0, 1, 0]\", options, \"[true, false, true]\");\n-  this->AssertTake(\"[null, false, true]\", \"[0, 1, 0]\", options, \"[null, false, null]\");\n-  this->AssertTake(\"[true, false, true]\", \"[null, 1, 0]\", options, \"[null, false, true]\");\n+  this->AssertTake(\"[true, false, true]\", \"[0, 1, 0]\", \"[true, false, true]\");\n+  this->AssertTake(\"[null, false, true]\", \"[0, 1, 0]\", \"[null, false, null]\");\n+  this->AssertTake(\"[true, false, true]\", \"[null, 1, 0]\", \"[null, false, true]\");\n \n   std::shared_ptr<Array> arr;\n-  ASSERT_RAISES(IndexError, this->Take(boolean(), \"[true, false, true]\", int8(),\n-                                       \"[0, 9, 0]\", options, &arr));\n+  ASSERT_RAISES(IndexError,\n+                this->Take(boolean(), \"[true, false, true]\", int8(), \"[0, 9, 0]\", &arr));\n }\n \n template <typename ArrowType>\n class TestTakeKernelWithNumeric : public TestTakeKernel<ArrowType> {\n  protected:\n   void AssertTake(const std::string& values, const std::string& indices,\n-                  TakeOptions options, const std::string& expected) {\n-    TestTakeKernel<ArrowType>::AssertTake(type_singleton(), values, indices, options,\n-                                          expected);\n+                  const std::string& expected) {\n+    TestTakeKernel<ArrowType>::AssertTake(type_singleton(), values, indices, expected);\n   }\n   std::shared_ptr<DataType> type_singleton() {\n     return TypeTraits<ArrowType>::type_singleton();\n   }\n+  void ValidateTake(const std::shared_ptr<Array>& values,\n+                    const std::shared_ptr<Array>& indices_boxed) {\n+    std::shared_ptr<Array> taken;\n+    TakeOptions options;\n+    ASSERT_OK(\n+        arrow::compute::Take(&this->ctx_, *values, *indices_boxed, options, &taken));\n+    ASSERT_EQ(indices_boxed->length(), taken->length());\n+\n+    ASSERT_EQ(indices_boxed->type_id(), Type::INT32);\n+    auto indices = checked_pointer_cast<Int32Array>(indices_boxed);\n+    for (int64_t i = 0; i < indices->length(); ++i) {\n+      if (indices->IsNull(i)) {\n+        ASSERT_TRUE(taken->IsNull(i));\n+        continue;\n+      }\n+      int32_t taken_index = indices->Value(i);\n+      ASSERT_TRUE(values->RangeEquals(taken_index, taken_index + 1, i, taken));\n+    }\n+  }\n };\n \n TYPED_TEST_CASE(TestTakeKernelWithNumeric, NumericArrowTypes);\n TYPED_TEST(TestTakeKernelWithNumeric, TakeNumeric) {\n-  TakeOptions options;\n-  this->AssertTake(\"[7, 8, 9]\", \"[0, 1, 0]\", options, \"[7, 8, 7]\");\n-  this->AssertTake(\"[null, 8, 9]\", \"[0, 1, 0]\", options, \"[null, 8, null]\");\n-  this->AssertTake(\"[7, 8, 9]\", \"[null, 1, 0]\", options, \"[null, 8, 7]\");\n-  this->AssertTake(\"[null, 8, 9]\", \"[]\", options, \"[]\");\n+  this->AssertTake(\"[7, 8, 9]\", \"[0, 1, 0]\", \"[7, 8, 7]\");\n+  this->AssertTake(\"[null, 8, 9]\", \"[0, 1, 0]\", \"[null, 8, null]\");\n+  this->AssertTake(\"[7, 8, 9]\", \"[null, 1, 0]\", \"[null, 8, 7]\");\n+  this->AssertTake(\"[null, 8, 9]\", \"[]\", \"[]\");\n \n   std::shared_ptr<Array> arr;\n   ASSERT_RAISES(IndexError, this->Take(this->type_singleton(), \"[7, 8, 9]\", int8(),\n-                                       \"[0, 9, 0]\", options, &arr));\n+                                       \"[0, 9, 0]\", &arr));\n+}\n+\n+TYPED_TEST(TestTakeKernelWithNumeric, TakeRandomNumeric) {\n+  auto rand = random::RandomArrayGenerator(kSeed);\n+  for (size_t i = 3; i < 8; i++) {\n+    const int64_t length = static_cast<int64_t>(1ULL << i);\n+    for (size_t j = 0; j < 13; j++) {\n+      const int64_t indices_length = static_cast<int64_t>(1ULL << j);\n+      for (auto null_probability : {0.0, 0.01, 0.1, 0.25, 0.5, 1.0}) {\n \n Review comment:\n   I can thin those out, then\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-06-25T13:22:13.986+0000",
                    "updated": "2019-06-25T13:22:13.986+0000",
                    "started": "2019-06-25T13:22:13.985+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "266645",
                    "issueId": "13136681"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 43800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@5a263b0a[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@394e5a42[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@27d8d8ca[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@6c8f1a39[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@21a8d83a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@762e4e9[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@661d7247[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@7257f26f[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@15599d17[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@50c76f9[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@80eb355[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4507ecb1[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 43800,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Jun 27 20:45:44 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-06-27T20:45:44.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2104/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2018-02-06T21:58:49.000+0000",
        "updated": "2019-06-27T20:45:48.000+0000",
        "timeoriginalestimate": null,
        "description": "Should support nested array value types.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "12h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 43800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement take kernel functions - nested array value type",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13136681/comment/16874498",
                    "id": "16874498",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 4531\n[https://github.com/apache/arrow/pull/4531]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-06-27T20:45:44.117+0000",
                    "updated": "2019-06-27T20:45:44.117+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|i3pvaf:",
        "customfield_12314139": null
    }
}