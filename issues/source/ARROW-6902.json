{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13262630",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630",
    "key": "ARROW-6902",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12340948",
                "id": "12340948",
                "description": "",
                "name": "0.16.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-02-07"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "analytic",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fsaintjacques",
            "name": "fsaintjacques",
            "key": "fsaintjacques",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=fsaintjacques&avatarId=37276",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fsaintjacques&avatarId=37276",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fsaintjacques&avatarId=37276",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fsaintjacques&avatarId=37276"
            },
            "displayName": "Francois Saint-Jacques",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fsaintjacques",
            "name": "fsaintjacques",
            "key": "fsaintjacques",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=fsaintjacques&avatarId=37276",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=fsaintjacques&avatarId=37276",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=fsaintjacques&avatarId=37276",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=fsaintjacques&avatarId=37276"
            },
            "displayName": "Francois Saint-Jacques",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 10800,
            "total": 10800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-6902/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 20,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/359649",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-13T20:59:33.695+0000",
                    "updated": "2019-12-13T20:59:33.695+0000",
                    "started": "2019-12-13T20:59:33.695+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "359649",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/359650",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on issue #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#issuecomment-565606954\n \n \n   https://issues.apache.org/jira/browse/ARROW-6902\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-13T21:00:50.558+0000",
                    "updated": "2019-12-13T21:00:50.558+0000",
                    "started": "2019-12-13T21:00:50.557+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "359650",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360450",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on issue #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#issuecomment-566211564\n \n \n   @ursabot benchmark --help\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-16T19:40:41.923+0000",
                    "updated": "2019-12-16T19:40:41.923+0000",
                    "started": "2019-12-16T19:40:41.923+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360450",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360451",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on issue #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#issuecomment-566211574\n \n \n   ```\n   Usage: @ursabot benchmark [OPTIONS] [<baseline>]\n   \n     Run the benchmark suite in comparison mode.\n   \n     This command will run the benchmark suite for tip of the branch commit\n     against `<baseline>` (or master if not provided).\n   \n     Examples:\n   \n     # Run the all the benchmarks\n     @ursabot benchmark\n   \n     # Compare only benchmarks where the name matches the /^Sum/ regex\n     @ursabot benchmark --benchmark-filter=^Sum\n   \n     # Compare only benchmarks where the suite matches the /compute-/ regex.\n     # A suite is the C++ binary.\n     @ursabot benchmark --suite-filter=compute-\n   \n     # Sometimes a new optimization requires the addition of new benchmarks to\n     # quantify the performance increase. When doing this be sure to add the\n     # benchmark in a separate commit before introducing the optimization.\n     #\n     # Note that specifying the baseline is the only way to compare using a new\n     # benchmark, since master does not contain the new benchmark and no\n     # comparison is possible.\n     #\n     # The following command compares the results of matching benchmarks,\n     # compiling against HEAD and the provided baseline commit, e.g. eaf8302.\n     # You can use this to quantify the performance improvement of new\n     # optimizations or to check for regressions.\n     @ursabot benchmark --benchmark-filter=MyBenchmark eaf8302\n   \n   Options:\n     --suite-filter <regex>      Regex filtering benchmark suites.\n     --benchmark-filter <regex>  Regex filtering benchmarks.\n     --help                      Show this message and exit.\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-16T19:40:43.445+0000",
                    "updated": "2019-12-16T19:40:43.445+0000",
                    "started": "2019-12-16T19:40:43.445+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360451",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360452",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on issue #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#issuecomment-566211574\n \n \n   ```\n   Usage: @ursabot benchmark [OPTIONS] [<baseline>]\n   \n     Run the benchmark suite in comparison mode.\n   \n     This command will run the benchmark suite for tip of the branch commit\n     against `<baseline>` (or master if not provided).\n   \n     Examples:\n   \n     # Run the all the benchmarks\n     @ursabot benchmark\n   \n     # Compare only benchmarks where the name matches the /^Sum/ regex\n     @ursabot benchmark --benchmark-filter=^Sum\n   \n     # Compare only benchmarks where the suite matches the /compute-/ regex.\n     # A suite is the C++ binary.\n     @ursabot benchmark --suite-filter=compute-\n   \n     # Sometimes a new optimization requires the addition of new benchmarks to\n     # quantify the performance increase. When doing this be sure to add the\n     # benchmark in a separate commit before introducing the optimization.\n     #\n     # Note that specifying the baseline is the only way to compare using a new\n     # benchmark, since master does not contain the new benchmark and no\n     # comparison is possible.\n     #\n     # The following command compares the results of matching benchmarks,\n     # compiling against HEAD and the provided baseline commit, e.g. eaf8302.\n     # You can use this to quantify the performance improvement of new\n     # optimizations or to check for regressions.\n     @ursabot benchmark --benchmark-filter=MyBenchmark eaf8302\n   \n   Options:\n     --suite-filter <regex>      Regex filtering benchmark suites.\n     --benchmark-filter <regex>  Regex filtering benchmarks.\n     --help                      Show this message and exit.\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-16T19:41:51.577+0000",
                    "updated": "2019-12-16T19:41:51.577+0000",
                    "started": "2019-12-16T19:41:51.577+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360452",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360453",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on issue #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#issuecomment-566211564\n \n \n   @ursabot benchmark --help\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-16T19:41:56.265+0000",
                    "updated": "2019-12-16T19:41:56.265+0000",
                    "started": "2019-12-16T19:41:56.264+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360453",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360454",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on issue #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#issuecomment-566212284\n \n \n   @ursabot benchmark --suite-filter=compute-compare\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-16T19:42:34.616+0000",
                    "updated": "2019-12-16T19:42:34.616+0000",
                    "started": "2019-12-16T19:42:34.616+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360454",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360467",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on issue #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#issuecomment-566215119\n \n \n   [AMD64 Ubuntu 18.04 C++ Benchmark (#83313)](https://ci.ursalabs.org/#builders/73/builds/61) builder failed with an exception.\n   \n   Revision: 1aff67bbdd2819231631f691863bf1be4ffcbf7f\n   \n   Archery: `'archery benchmark ...'` step's traceback:\n   ```pycon\n   Traceback (most recent call last):\n     File \"/home/ursabot/.conda/envs/ursabot/lib/python3.7/site-packages/twisted/internet/defer.py\", line 654, in _runCallbacks\n       current.result = callback(current.result, *args, **kw)\n     File \"/home/ursabot/.conda/envs/ursabot/lib/python3.7/site-packages/twisted/internet/defer.py\", line 1475, in gotResult\n       _inlineCallbacks(r, g, status)\n     File \"/home/ursabot/.conda/envs/ursabot/lib/python3.7/site-packages/twisted/internet/defer.py\", line 1416, in _inlineCallbacks\n       result = result.throwExceptionIntoGenerator(g)\n     File \"/home/ursabot/.conda/envs/ursabot/lib/python3.7/site-packages/twisted/python/failure.py\", line 512, in throwExceptionIntoGenerator\n       return g.throw(self.type, self.value, self.tb)\n   --- <exception caught here> ---\n     File \"/home/ursabot/.conda/envs/ursabot/lib/python3.7/site-packages/buildbot/process/buildstep.py\", line 566, in startStep\n       self.results = yield self.run()\n     File \"/home/ursabot/.conda/envs/ursabot/lib/python3.7/site-packages/twisted/internet/defer.py\", line 1418, in _inlineCallbacks\n       result = g.send(result)\n     File \"/home/ursabot/ursabot/ursabot/steps.py\", line 67, in run\n       await log.addContent(content)\n     File \"/home/ursabot/.conda/envs/ursabot/lib/python3.7/site-packages/buildbot/process/log.py\", line 130, in addContent\n       return self.lbf.append(text)\n     File \"/home/ursabot/.conda/envs/ursabot/lib/python3.7/site-packages/buildbot/util/lineboundaries.py\", line 62, in append\n       text = self.newline_re.sub('\\n', text)\n   builtins.TypeError: expected string or bytes-like object\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-16T19:50:01.744+0000",
                    "updated": "2019-12-16T19:50:01.744+0000",
                    "started": "2019-12-16T19:50:01.744+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360467",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360852",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#discussion_r358752286\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/compare.cc\n ##########\n @@ -17,250 +17,296 @@\n \n #include \"arrow/compute/kernels/compare.h\"\n \n+#include <utility>\n+\n+#include \"boost/range.hpp\"\n+\n #include \"arrow/compute/context.h\"\n #include \"arrow/compute/kernel.h\"\n #include \"arrow/compute/kernels/util_internal.h\"\n #include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n+#include \"arrow/util/string_view.h\"\n+#include \"arrow/visitor_inline.h\"\n \n namespace arrow {\n \n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+using util::string_view;\n+\n namespace compute {\n \n-std::shared_ptr<DataType> CompareBinaryKernel::out_type() const {\n-  return compare_function_->out_type();\n-}\n+template <typename T, CompareOperator Op>\n+struct Comparator;\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs == rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::NOT_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs != rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs > rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs >= rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs < rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs <= rhs; }\n+};\n+\n+template <typename Value>\n+struct RepeatedValue {\n+  Value operator()() { return value_; }\n+  Value value_;\n+};\n \n-Status CompareBinaryKernel::Call(FunctionContext* ctx, const Datum& left,\n-                                 const Datum& right, Datum* out) {\n-  DCHECK(left.type()->Equals(right.type()));\n-\n-  auto lk = left.kind();\n-  auto rk = right.kind();\n-  auto out_array = out->array();\n-\n-  if (lk == Datum::ARRAY && rk == Datum::SCALAR) {\n-    auto array = left.array();\n-    auto scalar = right.scalar();\n-    return compare_function_->Compare(*array, *scalar, &out_array);\n-  } else if (lk == Datum::SCALAR && rk == Datum::ARRAY) {\n-    auto scalar = left.scalar();\n-    auto array = right.array();\n-    auto out_array = out->array();\n-    return compare_function_->Compare(*scalar, *array, &out_array);\n-  } else if (lk == Datum::ARRAY && rk == Datum::ARRAY) {\n-    auto lhs = left.array();\n-    auto rhs = right.array();\n-    return compare_function_->Compare(*lhs, *rhs, &out_array);\n+struct RepeatedBufferAsStringView {\n+  explicit RepeatedBufferAsStringView(const Buffer& buffer) : value_(buffer) {}\n+  util::string_view operator()() { return value_; }\n+  util::string_view value_;\n+};\n+\n+struct ReadFromBitmap : internal::BitmapReader {\n+  using internal::BitmapReader::BitmapReader;\n+\n+  bool operator()() {\n+    bool out = IsSet();\n+    Next();\n+    return out;\n   }\n+};\n+\n+template <typename T>\n+struct DereferenceIncrementPointer {\n+  T operator()() { return *ptr_++; }\n+  const T* ptr_;\n+};\n+\n+template <typename ArrayType>\n+struct GetViewFromStringLikeArray {\n+  explicit GetViewFromStringLikeArray(const ArrayType* array) : array_(array) {}\n+\n+  string_view operator()() { return array_->GetView(i_++); }\n+\n+  const ArrayType* array_;\n+  int64_t i_ = 0;\n+};\n \n-  return Status::Invalid(\"Invalid datum signature for CompareBinaryKernel\");\n+template <typename T, typename RangeType = RepeatedValue<typename T::c_type>>\n+RangeType MakeRange(const TemporalScalar<T>& scalar) {\n+  return RangeType{scalar.value};\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename ScalarType = typename TypeTraits<ArrowType>::ScalarType,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareArrayScalar(const ArrayData& array, const ScalarType& scalar,\n-                                 uint8_t* output_bitmap) {\n-  const T* left = array.GetValues<T>(1);\n-  const T right = scalar.value;\n+template <typename T, typename RangeType = RepeatedValue<typename T::c_type>>\n+RangeType MakeRange(const internal::PrimitiveScalar<T>& scalar) {\n+  return RangeType{scalar.value};\n+}\n \n-  internal::GenerateBitsUnrolled(\n-      output_bitmap, 0, array.length,\n-      [&left, right]() -> bool { return Comparator<T, Op>::Compare(*left++, right); });\n+RepeatedBufferAsStringView MakeRange(const BaseBinaryScalar& scalar) {\n+  return RepeatedBufferAsStringView{*scalar.value};\n+}\n \n-  return Status::OK();\n+ReadFromBitmap MakeRange(const BooleanArray& array) {\n+  return ReadFromBitmap(array.data()->GetValues<uint8_t>(1), array.offset(),\n+                        array.length());\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename ScalarType = typename TypeTraits<ArrowType>::ScalarType,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareScalarArray(const ScalarType& scalar, const ArrayData& array,\n-                                 uint8_t* output_bitmap) {\n-  const T left = scalar.value;\n-  const T* right = array.GetValues<T>(1);\n+template <typename T,\n+          typename RangeType = DereferenceIncrementPointer<typename T::c_type>>\n+RangeType MakeRange(const NumericArray<T>& array) {\n+  return RangeType{array.raw_values()};\n+}\n \n-  internal::GenerateBitsUnrolled(\n-      output_bitmap, 0, array.length,\n-      [left, &right]() -> bool { return Comparator<T, Op>::Compare(left, *right++); });\n+template <typename T, typename RangeType = GetViewFromStringLikeArray<BaseBinaryArray<T>>>\n+RangeType MakeRange(const BaseBinaryArray<T>& array) {\n+  return RangeType{&array};\n+}\n \n-  return Status::OK();\n+inline Status AssignNulls(FunctionContext* ctx, const Scalar& scalar, const Array& array,\n+                          ArrayData* out) {\n+  return scalar.is_valid ? detail::PropagateNulls(ctx, *array.data(), out)\n+                         : detail::SetAllNulls(ctx, *array.data(), out);\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareArrayArray(const ArrayData& lhs, const ArrayData& rhs,\n-                                uint8_t* output_bitmap) {\n-  const T* left = lhs.GetValues<T>(1);\n-  const T* right = rhs.GetValues<T>(1);\n+inline Status AssignNulls(FunctionContext* ctx, const Array& left, const Array& right,\n+                          ArrayData* out) {\n+  return detail::AssignNullIntersection(ctx, *left.data(), *right.data(), out);\n+}\n \n-  internal::GenerateBitsUnrolled(output_bitmap, 0, lhs.length, [&left, &right]() -> bool {\n-    return Comparator<T, Op>::Compare(*left++, *right++);\n+template <CompareOperator Op, typename L, typename R>\n+Status Compare(L&& get_left, R&& get_right, ArrayData* out) {\n+  auto out_bitmap = out->buffers[1]->mutable_data();\n+  internal::GenerateBitsUnrolled(out_bitmap, 0, out->length, [&]() -> bool {\n+    return Comparator<decltype(get_left()), Op>::Compare(get_left(), get_right());\n   });\n-\n   return Status::OK();\n }\n \n template <typename ArrowType, CompareOperator Op>\n-class CompareFunctionImpl final : public CompareFunction {\n+class CompareKernel final : public BinaryKernel {\n+ public:\n   using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n   using ScalarType = typename TypeTraits<ArrowType>::ScalarType;\n \n- public:\n-  explicit CompareFunctionImpl(FunctionContext* ctx) : ctx_(ctx) {}\n-\n-  Status Compare(const ArrayData& array, const Scalar& scalar, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(array.type->Equals(scalar.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Output must be of same length\n-    DCHECK_EQ(output->length, array.length);\n-\n-    // Scalar is null, all comparisons are null.\n-    if (!scalar.is_valid) {\n-      return detail::SetAllNulls(ctx_, array, output);\n-    }\n+  std::shared_ptr<DataType> out_type() const override { return boolean(); }\n \n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::PropagateNulls(ctx_, array, output));\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out_datum) override {\n+    auto out = out_datum->array();\n \n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareArrayScalar<ArrowType, Op>(\n-        array, static_cast<const ScalarType&>(scalar), bitmap_result);\n-  }\n+    auto left_array = AsArray(left);\n+    auto left_scalar = AsScalar(left);\n+\n+    auto right_array = AsArray(right);\n+    auto right_scalar = AsScalar(right);\n \n-  Status Compare(const Scalar& scalar, const ArrayData& array, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(array.type->Equals(scalar.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Output must be of same length\n-    DCHECK_EQ(output->length, array.length);\n-\n-    // Scalar is null, all comparisons are null.\n-    if (!scalar.is_valid) {\n-      return detail::SetAllNulls(ctx_, array, output);\n+    if (left_array && right_array) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *left_array, *right_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_array), MakeRange(*right_array), out.get());\n     }\n \n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::PropagateNulls(ctx_, array, output));\n+    if (left_array && right_scalar) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *right_scalar, *left_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_array), MakeRange(*right_scalar), out.get());\n+    }\n \n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareScalarArray<ArrowType, Op>(static_cast<const ScalarType&>(scalar),\n-                                             array, bitmap_result);\n-  }\n+    if (left_scalar && right_array) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *left_scalar, *right_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_scalar), MakeRange(*right_array), out.get());\n+    }\n \n-  Status Compare(const ArrayData& lhs, const ArrayData& rhs, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(lhs.type->Equals(rhs.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Inputs must be of same length\n-    DCHECK_EQ(lhs.length, rhs.length);\n-    // Output must be of same length as inputs\n-    DCHECK_EQ(output->length, lhs.length);\n-\n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::AssignNullIntersection(ctx_, lhs, rhs, output));\n-\n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareArrayArray<ArrowType, Op>(lhs, rhs, bitmap_result);\n+    return Status::Invalid(\"Invalid datum signature for CompareBinaryKernel::Call\");\n   }\n \n  private:\n-  FunctionContext* ctx_;\n-};\n+  static std::shared_ptr<ArrayType> AsArray(const Datum& datum) {\n+    if (datum.kind() != Datum::ARRAY) return nullptr;\n+    return checked_pointer_cast<ArrayType>(datum.make_array());\n+  }\n \n-template <typename ArrowType, CompareOperator Op>\n-static inline std::shared_ptr<CompareFunction> MakeCompareFunctionTypeOp(\n-    FunctionContext* ctx) {\n-  return std::make_shared<CompareFunctionImpl<ArrowType, Op>>(ctx);\n-}\n+  static std::shared_ptr<ScalarType> AsScalar(const Datum& datum) {\n+    if (datum.kind() != Datum::SCALAR) return nullptr;\n+    return checked_pointer_cast<ScalarType>(datum.scalar());\n+  }\n+};\n \n template <typename ArrowType>\n-static inline std::shared_ptr<CompareFunction> MakeCompareFunctionType(\n-    FunctionContext* ctx, struct CompareOptions options) {\n-  switch (options.op) {\n+std::shared_ptr<BinaryKernel> UnpackOperator(CompareOperator op) {\n+  switch (op) {\n     case CompareOperator::EQUAL:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::EQUAL>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::EQUAL>>();\n+\n     case CompareOperator::NOT_EQUAL:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::NOT_EQUAL>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::NOT_EQUAL>>();\n+\n     case CompareOperator::GREATER:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::GREATER>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::GREATER>>();\n+\n     case CompareOperator::GREATER_EQUAL:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::GREATER_EQUAL>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::GREATER_EQUAL>>();\n+\n     case CompareOperator::LESS:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::LESS>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::LESS>>();\n+\n     case CompareOperator::LESS_EQUAL:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::LESS_EQUAL>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::LESS_EQUAL>>();\n   }\n \n   return nullptr;\n }\n \n-std::shared_ptr<CompareFunction> MakeCompareFunction(FunctionContext* ctx,\n-                                                     const DataType& type,\n-                                                     struct CompareOptions options) {\n-  switch (type.id()) {\n-    case UInt8Type::type_id:\n-      return MakeCompareFunctionType<UInt8Type>(ctx, options);\n-    case Int8Type::type_id:\n-      return MakeCompareFunctionType<Int8Type>(ctx, options);\n-    case UInt16Type::type_id:\n-      return MakeCompareFunctionType<UInt16Type>(ctx, options);\n-    case Int16Type::type_id:\n-      return MakeCompareFunctionType<Int16Type>(ctx, options);\n-    case UInt32Type::type_id:\n-      return MakeCompareFunctionType<UInt32Type>(ctx, options);\n-    case Int32Type::type_id:\n-      return MakeCompareFunctionType<Int32Type>(ctx, options);\n-    case UInt64Type::type_id:\n-      return MakeCompareFunctionType<UInt64Type>(ctx, options);\n-    case Int64Type::type_id:\n-      return MakeCompareFunctionType<Int64Type>(ctx, options);\n-    case FloatType::type_id:\n-      return MakeCompareFunctionType<FloatType>(ctx, options);\n-    case DoubleType::type_id:\n-      return MakeCompareFunctionType<DoubleType>(ctx, options);\n-    case Date32Type::type_id:\n-      return MakeCompareFunctionType<Date32Type>(ctx, options);\n-    case Date64Type::type_id:\n-      return MakeCompareFunctionType<Date64Type>(ctx, options);\n-    case TimestampType::type_id:\n-      return MakeCompareFunctionType<TimestampType>(ctx, options);\n-    case Time32Type::type_id:\n-      return MakeCompareFunctionType<Time32Type>(ctx, options);\n-    case Time64Type::type_id:\n-      return MakeCompareFunctionType<Time64Type>(ctx, options);\n-    default:\n-      return nullptr;\n+struct UnpackType {\n+  Status Visit(const NullType& unreachable) { return Status::OK(); }\n+\n+  Status Visit(const BooleanType& t) {\n+    *out_ = UnpackOperator<BooleanType>(options_.op);\n+    return Status::OK();\n   }\n+\n+  template <typename Numeric>\n+  enable_if_number<Numeric, Status> Visit(const Numeric& t) {\n+    *out_ = UnpackOperator<Numeric>(options_.op);\n+    return Status::OK();\n+  }\n+\n+  template <typename Temporal>\n+  enable_if_temporal<Temporal, Status> Visit(const Temporal& t) {\n+    *out_ = UnpackOperator<Temporal>(options_.op);\n+    return Status::OK();\n+  }\n+\n+  template <typename StringLike>\n+  enable_if_base_binary<StringLike, Status> Visit(const StringLike& t) {\n+    *out_ = UnpackOperator<StringLike>(options_.op);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DictionaryType& t) { return NotImplemented(t); }\n \n Review comment:\n   Why don't you simply define a fallback `Status Visit(const DataType& t)`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-17T12:13:33.489+0000",
                    "updated": "2019-12-17T12:13:33.489+0000",
                    "started": "2019-12-17T12:13:33.489+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360852",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360853",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#discussion_r358753702\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/compare.h\n ##########\n @@ -103,57 +40,16 @@ enum CompareOperator {\n   LESS_EQUAL,\n };\n \n-template <typename T, CompareOperator Op>\n-struct Comparator;\n-\n-template <typename T>\n-struct Comparator<T, CompareOperator::EQUAL> {\n-  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs == rhs; }\n-};\n-\n-template <typename T>\n-struct Comparator<T, CompareOperator::NOT_EQUAL> {\n-  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs != rhs; }\n-};\n-\n-template <typename T>\n-struct Comparator<T, CompareOperator::GREATER> {\n-  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs > rhs; }\n-};\n-\n-template <typename T>\n-struct Comparator<T, CompareOperator::GREATER_EQUAL> {\n-  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs >= rhs; }\n-};\n-\n-template <typename T>\n-struct Comparator<T, CompareOperator::LESS> {\n-  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs < rhs; }\n-};\n-\n-template <typename T>\n-struct Comparator<T, CompareOperator::LESS_EQUAL> {\n-  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs <= rhs; }\n-};\n-\n struct CompareOptions {\n   explicit CompareOptions(CompareOperator op) : op(op) {}\n \n   enum CompareOperator op;\n };\n \n-/// \\brief Return a Compare CompareFunction\n-///\n-/// \\param[in] context FunctionContext passing context information\n-/// \\param[in] type required to specialize the kernel\n-/// \\param[in] options required to specify the compare operator\n-///\n-/// \\since 0.14.0\n-/// \\note API not yet finalized\n+/// \\brief BinaryKernel bound implementing comparison\n ARROW_EXPORT\n-std::shared_ptr<CompareFunction> MakeCompareFunction(FunctionContext* context,\n-                                                     const DataType& type,\n-                                                     struct CompareOptions options);\n+Status MakeCompareKernel(const DataType& type, CompareOptions options,\n \n Review comment:\n   Return `Result<>` here?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-17T12:13:33.666+0000",
                    "updated": "2019-12-17T12:13:33.666+0000",
                    "started": "2019-12-17T12:13:33.666+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360853",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360854",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#discussion_r358755250\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/compare.cc\n ##########\n @@ -17,250 +17,296 @@\n \n #include \"arrow/compute/kernels/compare.h\"\n \n+#include <utility>\n+\n+#include \"boost/range.hpp\"\n+\n #include \"arrow/compute/context.h\"\n #include \"arrow/compute/kernel.h\"\n #include \"arrow/compute/kernels/util_internal.h\"\n #include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n+#include \"arrow/util/string_view.h\"\n+#include \"arrow/visitor_inline.h\"\n \n namespace arrow {\n \n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+using util::string_view;\n+\n namespace compute {\n \n-std::shared_ptr<DataType> CompareBinaryKernel::out_type() const {\n-  return compare_function_->out_type();\n-}\n+template <typename T, CompareOperator Op>\n+struct Comparator;\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs == rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::NOT_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs != rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs > rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs >= rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs < rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs <= rhs; }\n+};\n+\n+template <typename Value>\n+struct RepeatedValue {\n+  Value operator()() { return value_; }\n+  Value value_;\n+};\n \n-Status CompareBinaryKernel::Call(FunctionContext* ctx, const Datum& left,\n-                                 const Datum& right, Datum* out) {\n-  DCHECK(left.type()->Equals(right.type()));\n-\n-  auto lk = left.kind();\n-  auto rk = right.kind();\n-  auto out_array = out->array();\n-\n-  if (lk == Datum::ARRAY && rk == Datum::SCALAR) {\n-    auto array = left.array();\n-    auto scalar = right.scalar();\n-    return compare_function_->Compare(*array, *scalar, &out_array);\n-  } else if (lk == Datum::SCALAR && rk == Datum::ARRAY) {\n-    auto scalar = left.scalar();\n-    auto array = right.array();\n-    auto out_array = out->array();\n-    return compare_function_->Compare(*scalar, *array, &out_array);\n-  } else if (lk == Datum::ARRAY && rk == Datum::ARRAY) {\n-    auto lhs = left.array();\n-    auto rhs = right.array();\n-    return compare_function_->Compare(*lhs, *rhs, &out_array);\n+struct RepeatedBufferAsStringView {\n+  explicit RepeatedBufferAsStringView(const Buffer& buffer) : value_(buffer) {}\n+  util::string_view operator()() { return value_; }\n+  util::string_view value_;\n+};\n+\n+struct ReadFromBitmap : internal::BitmapReader {\n+  using internal::BitmapReader::BitmapReader;\n+\n+  bool operator()() {\n+    bool out = IsSet();\n+    Next();\n+    return out;\n   }\n+};\n+\n+template <typename T>\n+struct DereferenceIncrementPointer {\n+  T operator()() { return *ptr_++; }\n+  const T* ptr_;\n+};\n+\n+template <typename ArrayType>\n+struct GetViewFromStringLikeArray {\n+  explicit GetViewFromStringLikeArray(const ArrayType* array) : array_(array) {}\n+\n+  string_view operator()() { return array_->GetView(i_++); }\n+\n+  const ArrayType* array_;\n+  int64_t i_ = 0;\n+};\n \n-  return Status::Invalid(\"Invalid datum signature for CompareBinaryKernel\");\n+template <typename T, typename RangeType = RepeatedValue<typename T::c_type>>\n+RangeType MakeRange(const TemporalScalar<T>& scalar) {\n+  return RangeType{scalar.value};\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename ScalarType = typename TypeTraits<ArrowType>::ScalarType,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareArrayScalar(const ArrayData& array, const ScalarType& scalar,\n-                                 uint8_t* output_bitmap) {\n-  const T* left = array.GetValues<T>(1);\n-  const T right = scalar.value;\n+template <typename T, typename RangeType = RepeatedValue<typename T::c_type>>\n+RangeType MakeRange(const internal::PrimitiveScalar<T>& scalar) {\n+  return RangeType{scalar.value};\n+}\n \n-  internal::GenerateBitsUnrolled(\n-      output_bitmap, 0, array.length,\n-      [&left, right]() -> bool { return Comparator<T, Op>::Compare(*left++, right); });\n+RepeatedBufferAsStringView MakeRange(const BaseBinaryScalar& scalar) {\n+  return RepeatedBufferAsStringView{*scalar.value};\n+}\n \n-  return Status::OK();\n+ReadFromBitmap MakeRange(const BooleanArray& array) {\n+  return ReadFromBitmap(array.data()->GetValues<uint8_t>(1), array.offset(),\n+                        array.length());\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename ScalarType = typename TypeTraits<ArrowType>::ScalarType,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareScalarArray(const ScalarType& scalar, const ArrayData& array,\n-                                 uint8_t* output_bitmap) {\n-  const T left = scalar.value;\n-  const T* right = array.GetValues<T>(1);\n+template <typename T,\n+          typename RangeType = DereferenceIncrementPointer<typename T::c_type>>\n+RangeType MakeRange(const NumericArray<T>& array) {\n+  return RangeType{array.raw_values()};\n+}\n \n-  internal::GenerateBitsUnrolled(\n-      output_bitmap, 0, array.length,\n-      [left, &right]() -> bool { return Comparator<T, Op>::Compare(left, *right++); });\n+template <typename T, typename RangeType = GetViewFromStringLikeArray<BaseBinaryArray<T>>>\n+RangeType MakeRange(const BaseBinaryArray<T>& array) {\n+  return RangeType{&array};\n+}\n \n-  return Status::OK();\n+inline Status AssignNulls(FunctionContext* ctx, const Scalar& scalar, const Array& array,\n+                          ArrayData* out) {\n+  return scalar.is_valid ? detail::PropagateNulls(ctx, *array.data(), out)\n+                         : detail::SetAllNulls(ctx, *array.data(), out);\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareArrayArray(const ArrayData& lhs, const ArrayData& rhs,\n-                                uint8_t* output_bitmap) {\n-  const T* left = lhs.GetValues<T>(1);\n-  const T* right = rhs.GetValues<T>(1);\n+inline Status AssignNulls(FunctionContext* ctx, const Array& left, const Array& right,\n+                          ArrayData* out) {\n+  return detail::AssignNullIntersection(ctx, *left.data(), *right.data(), out);\n+}\n \n-  internal::GenerateBitsUnrolled(output_bitmap, 0, lhs.length, [&left, &right]() -> bool {\n-    return Comparator<T, Op>::Compare(*left++, *right++);\n+template <CompareOperator Op, typename L, typename R>\n+Status Compare(L&& get_left, R&& get_right, ArrayData* out) {\n+  auto out_bitmap = out->buffers[1]->mutable_data();\n+  internal::GenerateBitsUnrolled(out_bitmap, 0, out->length, [&]() -> bool {\n+    return Comparator<decltype(get_left()), Op>::Compare(get_left(), get_right());\n   });\n-\n   return Status::OK();\n }\n \n template <typename ArrowType, CompareOperator Op>\n-class CompareFunctionImpl final : public CompareFunction {\n+class CompareKernel final : public BinaryKernel {\n+ public:\n   using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n   using ScalarType = typename TypeTraits<ArrowType>::ScalarType;\n \n- public:\n-  explicit CompareFunctionImpl(FunctionContext* ctx) : ctx_(ctx) {}\n-\n-  Status Compare(const ArrayData& array, const Scalar& scalar, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(array.type->Equals(scalar.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Output must be of same length\n-    DCHECK_EQ(output->length, array.length);\n-\n-    // Scalar is null, all comparisons are null.\n-    if (!scalar.is_valid) {\n-      return detail::SetAllNulls(ctx_, array, output);\n-    }\n+  std::shared_ptr<DataType> out_type() const override { return boolean(); }\n \n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::PropagateNulls(ctx_, array, output));\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out_datum) override {\n+    auto out = out_datum->array();\n \n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareArrayScalar<ArrowType, Op>(\n-        array, static_cast<const ScalarType&>(scalar), bitmap_result);\n-  }\n+    auto left_array = AsArray(left);\n+    auto left_scalar = AsScalar(left);\n+\n+    auto right_array = AsArray(right);\n+    auto right_scalar = AsScalar(right);\n \n-  Status Compare(const Scalar& scalar, const ArrayData& array, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(array.type->Equals(scalar.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Output must be of same length\n-    DCHECK_EQ(output->length, array.length);\n-\n-    // Scalar is null, all comparisons are null.\n-    if (!scalar.is_valid) {\n-      return detail::SetAllNulls(ctx_, array, output);\n+    if (left_array && right_array) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *left_array, *right_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_array), MakeRange(*right_array), out.get());\n     }\n \n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::PropagateNulls(ctx_, array, output));\n+    if (left_array && right_scalar) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *right_scalar, *left_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_array), MakeRange(*right_scalar), out.get());\n+    }\n \n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareScalarArray<ArrowType, Op>(static_cast<const ScalarType&>(scalar),\n-                                             array, bitmap_result);\n-  }\n+    if (left_scalar && right_array) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *left_scalar, *right_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_scalar), MakeRange(*right_array), out.get());\n \n Review comment:\n   Will \"scalar CMP array\" generate separate code from \"array CMP scalar\"? Just wondering whether we can limit the number of different specializations.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-17T12:13:33.700+0000",
                    "updated": "2019-12-17T12:13:33.700+0000",
                    "started": "2019-12-17T12:13:33.699+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360854",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360855",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#discussion_r358756946\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/compare.cc\n ##########\n @@ -17,250 +17,296 @@\n \n #include \"arrow/compute/kernels/compare.h\"\n \n+#include <utility>\n+\n+#include \"boost/range.hpp\"\n+\n #include \"arrow/compute/context.h\"\n #include \"arrow/compute/kernel.h\"\n #include \"arrow/compute/kernels/util_internal.h\"\n #include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n+#include \"arrow/util/string_view.h\"\n+#include \"arrow/visitor_inline.h\"\n \n namespace arrow {\n \n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+using util::string_view;\n+\n namespace compute {\n \n-std::shared_ptr<DataType> CompareBinaryKernel::out_type() const {\n-  return compare_function_->out_type();\n-}\n+template <typename T, CompareOperator Op>\n+struct Comparator;\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs == rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::NOT_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs != rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs > rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs >= rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs < rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs <= rhs; }\n+};\n+\n+template <typename Value>\n \n Review comment:\n   I suppose those ranges will be useful for other kernels at some point?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-17T12:13:33.724+0000",
                    "updated": "2019-12-17T12:13:33.724+0000",
                    "started": "2019-12-17T12:13:33.724+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360855",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360856",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#discussion_r358757025\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/compare.cc\n ##########\n @@ -17,250 +17,296 @@\n \n #include \"arrow/compute/kernels/compare.h\"\n \n+#include <utility>\n+\n+#include \"boost/range.hpp\"\n \n Review comment:\n   This doesn't seem to be used, right?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-17T12:13:33.728+0000",
                    "updated": "2019-12-17T12:13:33.728+0000",
                    "started": "2019-12-17T12:13:33.727+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360856",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360935",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#discussion_r358846941\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/compare.cc\n ##########\n @@ -17,250 +17,296 @@\n \n #include \"arrow/compute/kernels/compare.h\"\n \n+#include <utility>\n+\n+#include \"boost/range.hpp\"\n+\n #include \"arrow/compute/context.h\"\n #include \"arrow/compute/kernel.h\"\n #include \"arrow/compute/kernels/util_internal.h\"\n #include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n+#include \"arrow/util/string_view.h\"\n+#include \"arrow/visitor_inline.h\"\n \n namespace arrow {\n \n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+using util::string_view;\n+\n namespace compute {\n \n-std::shared_ptr<DataType> CompareBinaryKernel::out_type() const {\n-  return compare_function_->out_type();\n-}\n+template <typename T, CompareOperator Op>\n+struct Comparator;\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs == rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::NOT_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs != rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs > rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs >= rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs < rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs <= rhs; }\n+};\n+\n+template <typename Value>\n+struct RepeatedValue {\n+  Value operator()() { return value_; }\n+  Value value_;\n+};\n \n-Status CompareBinaryKernel::Call(FunctionContext* ctx, const Datum& left,\n-                                 const Datum& right, Datum* out) {\n-  DCHECK(left.type()->Equals(right.type()));\n-\n-  auto lk = left.kind();\n-  auto rk = right.kind();\n-  auto out_array = out->array();\n-\n-  if (lk == Datum::ARRAY && rk == Datum::SCALAR) {\n-    auto array = left.array();\n-    auto scalar = right.scalar();\n-    return compare_function_->Compare(*array, *scalar, &out_array);\n-  } else if (lk == Datum::SCALAR && rk == Datum::ARRAY) {\n-    auto scalar = left.scalar();\n-    auto array = right.array();\n-    auto out_array = out->array();\n-    return compare_function_->Compare(*scalar, *array, &out_array);\n-  } else if (lk == Datum::ARRAY && rk == Datum::ARRAY) {\n-    auto lhs = left.array();\n-    auto rhs = right.array();\n-    return compare_function_->Compare(*lhs, *rhs, &out_array);\n+struct RepeatedBufferAsStringView {\n+  explicit RepeatedBufferAsStringView(const Buffer& buffer) : value_(buffer) {}\n+  util::string_view operator()() { return value_; }\n+  util::string_view value_;\n+};\n+\n+struct ReadFromBitmap : internal::BitmapReader {\n+  using internal::BitmapReader::BitmapReader;\n+\n+  bool operator()() {\n+    bool out = IsSet();\n+    Next();\n+    return out;\n   }\n+};\n+\n+template <typename T>\n+struct DereferenceIncrementPointer {\n+  T operator()() { return *ptr_++; }\n+  const T* ptr_;\n+};\n+\n+template <typename ArrayType>\n+struct GetViewFromStringLikeArray {\n+  explicit GetViewFromStringLikeArray(const ArrayType* array) : array_(array) {}\n+\n+  string_view operator()() { return array_->GetView(i_++); }\n+\n+  const ArrayType* array_;\n+  int64_t i_ = 0;\n+};\n \n-  return Status::Invalid(\"Invalid datum signature for CompareBinaryKernel\");\n+template <typename T, typename RangeType = RepeatedValue<typename T::c_type>>\n+RangeType MakeRange(const TemporalScalar<T>& scalar) {\n+  return RangeType{scalar.value};\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename ScalarType = typename TypeTraits<ArrowType>::ScalarType,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareArrayScalar(const ArrayData& array, const ScalarType& scalar,\n-                                 uint8_t* output_bitmap) {\n-  const T* left = array.GetValues<T>(1);\n-  const T right = scalar.value;\n+template <typename T, typename RangeType = RepeatedValue<typename T::c_type>>\n+RangeType MakeRange(const internal::PrimitiveScalar<T>& scalar) {\n+  return RangeType{scalar.value};\n+}\n \n-  internal::GenerateBitsUnrolled(\n-      output_bitmap, 0, array.length,\n-      [&left, right]() -> bool { return Comparator<T, Op>::Compare(*left++, right); });\n+RepeatedBufferAsStringView MakeRange(const BaseBinaryScalar& scalar) {\n+  return RepeatedBufferAsStringView{*scalar.value};\n+}\n \n-  return Status::OK();\n+ReadFromBitmap MakeRange(const BooleanArray& array) {\n+  return ReadFromBitmap(array.data()->GetValues<uint8_t>(1), array.offset(),\n+                        array.length());\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename ScalarType = typename TypeTraits<ArrowType>::ScalarType,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareScalarArray(const ScalarType& scalar, const ArrayData& array,\n-                                 uint8_t* output_bitmap) {\n-  const T left = scalar.value;\n-  const T* right = array.GetValues<T>(1);\n+template <typename T,\n+          typename RangeType = DereferenceIncrementPointer<typename T::c_type>>\n+RangeType MakeRange(const NumericArray<T>& array) {\n+  return RangeType{array.raw_values()};\n+}\n \n-  internal::GenerateBitsUnrolled(\n-      output_bitmap, 0, array.length,\n-      [left, &right]() -> bool { return Comparator<T, Op>::Compare(left, *right++); });\n+template <typename T, typename RangeType = GetViewFromStringLikeArray<BaseBinaryArray<T>>>\n+RangeType MakeRange(const BaseBinaryArray<T>& array) {\n+  return RangeType{&array};\n+}\n \n-  return Status::OK();\n+inline Status AssignNulls(FunctionContext* ctx, const Scalar& scalar, const Array& array,\n+                          ArrayData* out) {\n+  return scalar.is_valid ? detail::PropagateNulls(ctx, *array.data(), out)\n+                         : detail::SetAllNulls(ctx, *array.data(), out);\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareArrayArray(const ArrayData& lhs, const ArrayData& rhs,\n-                                uint8_t* output_bitmap) {\n-  const T* left = lhs.GetValues<T>(1);\n-  const T* right = rhs.GetValues<T>(1);\n+inline Status AssignNulls(FunctionContext* ctx, const Array& left, const Array& right,\n+                          ArrayData* out) {\n+  return detail::AssignNullIntersection(ctx, *left.data(), *right.data(), out);\n+}\n \n-  internal::GenerateBitsUnrolled(output_bitmap, 0, lhs.length, [&left, &right]() -> bool {\n-    return Comparator<T, Op>::Compare(*left++, *right++);\n+template <CompareOperator Op, typename L, typename R>\n+Status Compare(L&& get_left, R&& get_right, ArrayData* out) {\n+  auto out_bitmap = out->buffers[1]->mutable_data();\n+  internal::GenerateBitsUnrolled(out_bitmap, 0, out->length, [&]() -> bool {\n+    return Comparator<decltype(get_left()), Op>::Compare(get_left(), get_right());\n   });\n-\n   return Status::OK();\n }\n \n template <typename ArrowType, CompareOperator Op>\n-class CompareFunctionImpl final : public CompareFunction {\n+class CompareKernel final : public BinaryKernel {\n+ public:\n   using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n   using ScalarType = typename TypeTraits<ArrowType>::ScalarType;\n \n- public:\n-  explicit CompareFunctionImpl(FunctionContext* ctx) : ctx_(ctx) {}\n-\n-  Status Compare(const ArrayData& array, const Scalar& scalar, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(array.type->Equals(scalar.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Output must be of same length\n-    DCHECK_EQ(output->length, array.length);\n-\n-    // Scalar is null, all comparisons are null.\n-    if (!scalar.is_valid) {\n-      return detail::SetAllNulls(ctx_, array, output);\n-    }\n+  std::shared_ptr<DataType> out_type() const override { return boolean(); }\n \n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::PropagateNulls(ctx_, array, output));\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out_datum) override {\n+    auto out = out_datum->array();\n \n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareArrayScalar<ArrowType, Op>(\n-        array, static_cast<const ScalarType&>(scalar), bitmap_result);\n-  }\n+    auto left_array = AsArray(left);\n+    auto left_scalar = AsScalar(left);\n+\n+    auto right_array = AsArray(right);\n+    auto right_scalar = AsScalar(right);\n \n-  Status Compare(const Scalar& scalar, const ArrayData& array, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(array.type->Equals(scalar.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Output must be of same length\n-    DCHECK_EQ(output->length, array.length);\n-\n-    // Scalar is null, all comparisons are null.\n-    if (!scalar.is_valid) {\n-      return detail::SetAllNulls(ctx_, array, output);\n+    if (left_array && right_array) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *left_array, *right_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_array), MakeRange(*right_array), out.get());\n     }\n \n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::PropagateNulls(ctx_, array, output));\n+    if (left_array && right_scalar) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *right_scalar, *left_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_array), MakeRange(*right_scalar), out.get());\n+    }\n \n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareScalarArray<ArrowType, Op>(static_cast<const ScalarType&>(scalar),\n-                                             array, bitmap_result);\n-  }\n+    if (left_scalar && right_array) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *left_scalar, *right_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_scalar), MakeRange(*right_array), out.get());\n+    }\n \n-  Status Compare(const ArrayData& lhs, const ArrayData& rhs, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(lhs.type->Equals(rhs.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Inputs must be of same length\n-    DCHECK_EQ(lhs.length, rhs.length);\n-    // Output must be of same length as inputs\n-    DCHECK_EQ(output->length, lhs.length);\n-\n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::AssignNullIntersection(ctx_, lhs, rhs, output));\n-\n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareArrayArray<ArrowType, Op>(lhs, rhs, bitmap_result);\n+    return Status::Invalid(\"Invalid datum signature for CompareBinaryKernel::Call\");\n   }\n \n  private:\n-  FunctionContext* ctx_;\n-};\n+  static std::shared_ptr<ArrayType> AsArray(const Datum& datum) {\n+    if (datum.kind() != Datum::ARRAY) return nullptr;\n+    return checked_pointer_cast<ArrayType>(datum.make_array());\n+  }\n \n-template <typename ArrowType, CompareOperator Op>\n-static inline std::shared_ptr<CompareFunction> MakeCompareFunctionTypeOp(\n-    FunctionContext* ctx) {\n-  return std::make_shared<CompareFunctionImpl<ArrowType, Op>>(ctx);\n-}\n+  static std::shared_ptr<ScalarType> AsScalar(const Datum& datum) {\n+    if (datum.kind() != Datum::SCALAR) return nullptr;\n+    return checked_pointer_cast<ScalarType>(datum.scalar());\n+  }\n+};\n \n template <typename ArrowType>\n-static inline std::shared_ptr<CompareFunction> MakeCompareFunctionType(\n-    FunctionContext* ctx, struct CompareOptions options) {\n-  switch (options.op) {\n+std::shared_ptr<BinaryKernel> UnpackOperator(CompareOperator op) {\n+  switch (op) {\n     case CompareOperator::EQUAL:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::EQUAL>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::EQUAL>>();\n+\n     case CompareOperator::NOT_EQUAL:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::NOT_EQUAL>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::NOT_EQUAL>>();\n+\n     case CompareOperator::GREATER:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::GREATER>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::GREATER>>();\n+\n     case CompareOperator::GREATER_EQUAL:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::GREATER_EQUAL>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::GREATER_EQUAL>>();\n+\n     case CompareOperator::LESS:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::LESS>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::LESS>>();\n+\n     case CompareOperator::LESS_EQUAL:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::LESS_EQUAL>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::LESS_EQUAL>>();\n   }\n \n   return nullptr;\n }\n \n-std::shared_ptr<CompareFunction> MakeCompareFunction(FunctionContext* ctx,\n-                                                     const DataType& type,\n-                                                     struct CompareOptions options) {\n-  switch (type.id()) {\n-    case UInt8Type::type_id:\n-      return MakeCompareFunctionType<UInt8Type>(ctx, options);\n-    case Int8Type::type_id:\n-      return MakeCompareFunctionType<Int8Type>(ctx, options);\n-    case UInt16Type::type_id:\n-      return MakeCompareFunctionType<UInt16Type>(ctx, options);\n-    case Int16Type::type_id:\n-      return MakeCompareFunctionType<Int16Type>(ctx, options);\n-    case UInt32Type::type_id:\n-      return MakeCompareFunctionType<UInt32Type>(ctx, options);\n-    case Int32Type::type_id:\n-      return MakeCompareFunctionType<Int32Type>(ctx, options);\n-    case UInt64Type::type_id:\n-      return MakeCompareFunctionType<UInt64Type>(ctx, options);\n-    case Int64Type::type_id:\n-      return MakeCompareFunctionType<Int64Type>(ctx, options);\n-    case FloatType::type_id:\n-      return MakeCompareFunctionType<FloatType>(ctx, options);\n-    case DoubleType::type_id:\n-      return MakeCompareFunctionType<DoubleType>(ctx, options);\n-    case Date32Type::type_id:\n-      return MakeCompareFunctionType<Date32Type>(ctx, options);\n-    case Date64Type::type_id:\n-      return MakeCompareFunctionType<Date64Type>(ctx, options);\n-    case TimestampType::type_id:\n-      return MakeCompareFunctionType<TimestampType>(ctx, options);\n-    case Time32Type::type_id:\n-      return MakeCompareFunctionType<Time32Type>(ctx, options);\n-    case Time64Type::type_id:\n-      return MakeCompareFunctionType<Time64Type>(ctx, options);\n-    default:\n-      return nullptr;\n+struct UnpackType {\n+  Status Visit(const NullType& unreachable) { return Status::OK(); }\n+\n+  Status Visit(const BooleanType& t) {\n+    *out_ = UnpackOperator<BooleanType>(options_.op);\n+    return Status::OK();\n   }\n+\n+  template <typename Numeric>\n+  enable_if_number<Numeric, Status> Visit(const Numeric& t) {\n+    *out_ = UnpackOperator<Numeric>(options_.op);\n+    return Status::OK();\n+  }\n+\n+  template <typename Temporal>\n+  enable_if_temporal<Temporal, Status> Visit(const Temporal& t) {\n+    *out_ = UnpackOperator<Temporal>(options_.op);\n+    return Status::OK();\n+  }\n+\n+  template <typename StringLike>\n+  enable_if_base_binary<StringLike, Status> Visit(const StringLike& t) {\n+    *out_ = UnpackOperator<StringLike>(options_.op);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DictionaryType& t) { return NotImplemented(t); }\n \n Review comment:\n   I raised this issue while refactoring the type_traits. \r\n   \r\n   It's essentially equivalent to switch with a default case. If you add a new type (or pattern), you'll miss the visitor you need to implement (or ignore!) because it'll silently enter the catch-all pattern.\r\n   \r\n   Thus by being explicit, whenever you add a new pattern, you need to take a decision to ignore or implement the visitors.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-17T15:12:11.354+0000",
                    "updated": "2019-12-17T15:12:11.354+0000",
                    "started": "2019-12-17T15:12:11.353+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360935",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360938",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#discussion_r358850276\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/compare.h\n ##########\n @@ -103,57 +40,16 @@ enum CompareOperator {\n   LESS_EQUAL,\n };\n \n-template <typename T, CompareOperator Op>\n-struct Comparator;\n-\n-template <typename T>\n-struct Comparator<T, CompareOperator::EQUAL> {\n-  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs == rhs; }\n-};\n-\n-template <typename T>\n-struct Comparator<T, CompareOperator::NOT_EQUAL> {\n-  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs != rhs; }\n-};\n-\n-template <typename T>\n-struct Comparator<T, CompareOperator::GREATER> {\n-  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs > rhs; }\n-};\n-\n-template <typename T>\n-struct Comparator<T, CompareOperator::GREATER_EQUAL> {\n-  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs >= rhs; }\n-};\n-\n-template <typename T>\n-struct Comparator<T, CompareOperator::LESS> {\n-  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs < rhs; }\n-};\n-\n-template <typename T>\n-struct Comparator<T, CompareOperator::LESS_EQUAL> {\n-  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs <= rhs; }\n-};\n-\n struct CompareOptions {\n   explicit CompareOptions(CompareOperator op) : op(op) {}\n \n   enum CompareOperator op;\n };\n \n-/// \\brief Return a Compare CompareFunction\n-///\n-/// \\param[in] context FunctionContext passing context information\n-/// \\param[in] type required to specialize the kernel\n-/// \\param[in] options required to specify the compare operator\n-///\n-/// \\since 0.14.0\n-/// \\note API not yet finalized\n+/// \\brief BinaryKernel bound implementing comparison\n ARROW_EXPORT\n-std::shared_ptr<CompareFunction> MakeCompareFunction(FunctionContext* context,\n-                                                     const DataType& type,\n-                                                     struct CompareOptions options);\n+Status MakeCompareKernel(const DataType& type, CompareOptions options,\n \n Review comment:\n   alright\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-17T15:18:00.477+0000",
                    "updated": "2019-12-17T15:18:00.477+0000",
                    "started": "2019-12-17T15:18:00.477+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360938",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360939",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#discussion_r358852473\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/compare.cc\n ##########\n @@ -17,250 +17,296 @@\n \n #include \"arrow/compute/kernels/compare.h\"\n \n+#include <utility>\n+\n+#include \"boost/range.hpp\"\n+\n #include \"arrow/compute/context.h\"\n #include \"arrow/compute/kernel.h\"\n #include \"arrow/compute/kernels/util_internal.h\"\n #include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n+#include \"arrow/util/string_view.h\"\n+#include \"arrow/visitor_inline.h\"\n \n namespace arrow {\n \n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+using util::string_view;\n+\n namespace compute {\n \n-std::shared_ptr<DataType> CompareBinaryKernel::out_type() const {\n-  return compare_function_->out_type();\n-}\n+template <typename T, CompareOperator Op>\n+struct Comparator;\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs == rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::NOT_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs != rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs > rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs >= rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs < rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs <= rhs; }\n+};\n+\n+template <typename Value>\n+struct RepeatedValue {\n+  Value operator()() { return value_; }\n+  Value value_;\n+};\n \n-Status CompareBinaryKernel::Call(FunctionContext* ctx, const Datum& left,\n-                                 const Datum& right, Datum* out) {\n-  DCHECK(left.type()->Equals(right.type()));\n-\n-  auto lk = left.kind();\n-  auto rk = right.kind();\n-  auto out_array = out->array();\n-\n-  if (lk == Datum::ARRAY && rk == Datum::SCALAR) {\n-    auto array = left.array();\n-    auto scalar = right.scalar();\n-    return compare_function_->Compare(*array, *scalar, &out_array);\n-  } else if (lk == Datum::SCALAR && rk == Datum::ARRAY) {\n-    auto scalar = left.scalar();\n-    auto array = right.array();\n-    auto out_array = out->array();\n-    return compare_function_->Compare(*scalar, *array, &out_array);\n-  } else if (lk == Datum::ARRAY && rk == Datum::ARRAY) {\n-    auto lhs = left.array();\n-    auto rhs = right.array();\n-    return compare_function_->Compare(*lhs, *rhs, &out_array);\n+struct RepeatedBufferAsStringView {\n+  explicit RepeatedBufferAsStringView(const Buffer& buffer) : value_(buffer) {}\n+  util::string_view operator()() { return value_; }\n+  util::string_view value_;\n+};\n+\n+struct ReadFromBitmap : internal::BitmapReader {\n+  using internal::BitmapReader::BitmapReader;\n+\n+  bool operator()() {\n+    bool out = IsSet();\n+    Next();\n+    return out;\n   }\n+};\n+\n+template <typename T>\n+struct DereferenceIncrementPointer {\n+  T operator()() { return *ptr_++; }\n+  const T* ptr_;\n+};\n+\n+template <typename ArrayType>\n+struct GetViewFromStringLikeArray {\n+  explicit GetViewFromStringLikeArray(const ArrayType* array) : array_(array) {}\n+\n+  string_view operator()() { return array_->GetView(i_++); }\n+\n+  const ArrayType* array_;\n+  int64_t i_ = 0;\n+};\n \n-  return Status::Invalid(\"Invalid datum signature for CompareBinaryKernel\");\n+template <typename T, typename RangeType = RepeatedValue<typename T::c_type>>\n+RangeType MakeRange(const TemporalScalar<T>& scalar) {\n+  return RangeType{scalar.value};\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename ScalarType = typename TypeTraits<ArrowType>::ScalarType,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareArrayScalar(const ArrayData& array, const ScalarType& scalar,\n-                                 uint8_t* output_bitmap) {\n-  const T* left = array.GetValues<T>(1);\n-  const T right = scalar.value;\n+template <typename T, typename RangeType = RepeatedValue<typename T::c_type>>\n+RangeType MakeRange(const internal::PrimitiveScalar<T>& scalar) {\n+  return RangeType{scalar.value};\n+}\n \n-  internal::GenerateBitsUnrolled(\n-      output_bitmap, 0, array.length,\n-      [&left, right]() -> bool { return Comparator<T, Op>::Compare(*left++, right); });\n+RepeatedBufferAsStringView MakeRange(const BaseBinaryScalar& scalar) {\n+  return RepeatedBufferAsStringView{*scalar.value};\n+}\n \n-  return Status::OK();\n+ReadFromBitmap MakeRange(const BooleanArray& array) {\n+  return ReadFromBitmap(array.data()->GetValues<uint8_t>(1), array.offset(),\n+                        array.length());\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename ScalarType = typename TypeTraits<ArrowType>::ScalarType,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareScalarArray(const ScalarType& scalar, const ArrayData& array,\n-                                 uint8_t* output_bitmap) {\n-  const T left = scalar.value;\n-  const T* right = array.GetValues<T>(1);\n+template <typename T,\n+          typename RangeType = DereferenceIncrementPointer<typename T::c_type>>\n+RangeType MakeRange(const NumericArray<T>& array) {\n+  return RangeType{array.raw_values()};\n+}\n \n-  internal::GenerateBitsUnrolled(\n-      output_bitmap, 0, array.length,\n-      [left, &right]() -> bool { return Comparator<T, Op>::Compare(left, *right++); });\n+template <typename T, typename RangeType = GetViewFromStringLikeArray<BaseBinaryArray<T>>>\n+RangeType MakeRange(const BaseBinaryArray<T>& array) {\n+  return RangeType{&array};\n+}\n \n-  return Status::OK();\n+inline Status AssignNulls(FunctionContext* ctx, const Scalar& scalar, const Array& array,\n+                          ArrayData* out) {\n+  return scalar.is_valid ? detail::PropagateNulls(ctx, *array.data(), out)\n+                         : detail::SetAllNulls(ctx, *array.data(), out);\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareArrayArray(const ArrayData& lhs, const ArrayData& rhs,\n-                                uint8_t* output_bitmap) {\n-  const T* left = lhs.GetValues<T>(1);\n-  const T* right = rhs.GetValues<T>(1);\n+inline Status AssignNulls(FunctionContext* ctx, const Array& left, const Array& right,\n+                          ArrayData* out) {\n+  return detail::AssignNullIntersection(ctx, *left.data(), *right.data(), out);\n+}\n \n-  internal::GenerateBitsUnrolled(output_bitmap, 0, lhs.length, [&left, &right]() -> bool {\n-    return Comparator<T, Op>::Compare(*left++, *right++);\n+template <CompareOperator Op, typename L, typename R>\n+Status Compare(L&& get_left, R&& get_right, ArrayData* out) {\n+  auto out_bitmap = out->buffers[1]->mutable_data();\n+  internal::GenerateBitsUnrolled(out_bitmap, 0, out->length, [&]() -> bool {\n+    return Comparator<decltype(get_left()), Op>::Compare(get_left(), get_right());\n   });\n-\n   return Status::OK();\n }\n \n template <typename ArrowType, CompareOperator Op>\n-class CompareFunctionImpl final : public CompareFunction {\n+class CompareKernel final : public BinaryKernel {\n+ public:\n   using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n   using ScalarType = typename TypeTraits<ArrowType>::ScalarType;\n \n- public:\n-  explicit CompareFunctionImpl(FunctionContext* ctx) : ctx_(ctx) {}\n-\n-  Status Compare(const ArrayData& array, const Scalar& scalar, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(array.type->Equals(scalar.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Output must be of same length\n-    DCHECK_EQ(output->length, array.length);\n-\n-    // Scalar is null, all comparisons are null.\n-    if (!scalar.is_valid) {\n-      return detail::SetAllNulls(ctx_, array, output);\n-    }\n+  std::shared_ptr<DataType> out_type() const override { return boolean(); }\n \n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::PropagateNulls(ctx_, array, output));\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out_datum) override {\n+    auto out = out_datum->array();\n \n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareArrayScalar<ArrowType, Op>(\n-        array, static_cast<const ScalarType&>(scalar), bitmap_result);\n-  }\n+    auto left_array = AsArray(left);\n+    auto left_scalar = AsScalar(left);\n+\n+    auto right_array = AsArray(right);\n+    auto right_scalar = AsScalar(right);\n \n-  Status Compare(const Scalar& scalar, const ArrayData& array, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(array.type->Equals(scalar.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Output must be of same length\n-    DCHECK_EQ(output->length, array.length);\n-\n-    // Scalar is null, all comparisons are null.\n-    if (!scalar.is_valid) {\n-      return detail::SetAllNulls(ctx_, array, output);\n+    if (left_array && right_array) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *left_array, *right_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_array), MakeRange(*right_array), out.get());\n     }\n \n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::PropagateNulls(ctx_, array, output));\n+    if (left_array && right_scalar) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *right_scalar, *left_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_array), MakeRange(*right_scalar), out.get());\n+    }\n \n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareScalarArray<ArrowType, Op>(static_cast<const ScalarType&>(scalar),\n-                                             array, bitmap_result);\n-  }\n+    if (left_scalar && right_array) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *left_scalar, *right_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_scalar), MakeRange(*right_array), out.get());\n \n Review comment:\n   I think this could be accomplished generally by providing a mapping from op -> inverse op, so that `5 > [1, 4, 5, 6, 9]` could be replaced by `[1, 4, 5, 6, 9] < 5`. @fsaintjacques \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-17T15:21:31.860+0000",
                    "updated": "2019-12-17T15:21:31.860+0000",
                    "started": "2019-12-17T15:21:31.858+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360939",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360941",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#discussion_r358853668\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/compare.cc\n ##########\n @@ -17,250 +17,296 @@\n \n #include \"arrow/compute/kernels/compare.h\"\n \n+#include <utility>\n+\n+#include \"boost/range.hpp\"\n+\n #include \"arrow/compute/context.h\"\n #include \"arrow/compute/kernel.h\"\n #include \"arrow/compute/kernels/util_internal.h\"\n #include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n+#include \"arrow/util/string_view.h\"\n+#include \"arrow/visitor_inline.h\"\n \n namespace arrow {\n \n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+using util::string_view;\n+\n namespace compute {\n \n-std::shared_ptr<DataType> CompareBinaryKernel::out_type() const {\n-  return compare_function_->out_type();\n-}\n+template <typename T, CompareOperator Op>\n+struct Comparator;\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs == rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::NOT_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs != rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs > rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs >= rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs < rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs <= rhs; }\n+};\n+\n+template <typename Value>\n \n Review comment:\n   Definitely. As a (much) larger project I plan to eventually extract these and other range impls, consolidating into `arrow/util/range.h`.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-17T15:23:25.313+0000",
                    "updated": "2019-12-17T15:23:25.313+0000",
                    "started": "2019-12-17T15:23:25.313+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360941",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360942",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#discussion_r358853867\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/compare.cc\n ##########\n @@ -17,250 +17,296 @@\n \n #include \"arrow/compute/kernels/compare.h\"\n \n+#include <utility>\n+\n+#include \"boost/range.hpp\"\n \n Review comment:\n   Nope, cruft. I'll remove it\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-17T15:23:43.535+0000",
                    "updated": "2019-12-17T15:23:43.535+0000",
                    "started": "2019-12-17T15:23:43.535+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360942",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/360944",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034#discussion_r358854060\n \n \n\n ##########\n File path: cpp/src/arrow/compute/kernels/compare.cc\n ##########\n @@ -17,250 +17,296 @@\n \n #include \"arrow/compute/kernels/compare.h\"\n \n+#include <utility>\n+\n+#include \"boost/range.hpp\"\n+\n #include \"arrow/compute/context.h\"\n #include \"arrow/compute/kernel.h\"\n #include \"arrow/compute/kernels/util_internal.h\"\n #include \"arrow/util/bit_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n #include \"arrow/util/logging.h\"\n+#include \"arrow/util/string_view.h\"\n+#include \"arrow/visitor_inline.h\"\n \n namespace arrow {\n \n+using internal::checked_cast;\n+using internal::checked_pointer_cast;\n+using util::string_view;\n+\n namespace compute {\n \n-std::shared_ptr<DataType> CompareBinaryKernel::out_type() const {\n-  return compare_function_->out_type();\n-}\n+template <typename T, CompareOperator Op>\n+struct Comparator;\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs == rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::NOT_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs != rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs > rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::GREATER_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs >= rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs < rhs; }\n+};\n+\n+template <typename T>\n+struct Comparator<T, CompareOperator::LESS_EQUAL> {\n+  constexpr static bool Compare(const T& lhs, const T& rhs) { return lhs <= rhs; }\n+};\n+\n+template <typename Value>\n+struct RepeatedValue {\n+  Value operator()() { return value_; }\n+  Value value_;\n+};\n \n-Status CompareBinaryKernel::Call(FunctionContext* ctx, const Datum& left,\n-                                 const Datum& right, Datum* out) {\n-  DCHECK(left.type()->Equals(right.type()));\n-\n-  auto lk = left.kind();\n-  auto rk = right.kind();\n-  auto out_array = out->array();\n-\n-  if (lk == Datum::ARRAY && rk == Datum::SCALAR) {\n-    auto array = left.array();\n-    auto scalar = right.scalar();\n-    return compare_function_->Compare(*array, *scalar, &out_array);\n-  } else if (lk == Datum::SCALAR && rk == Datum::ARRAY) {\n-    auto scalar = left.scalar();\n-    auto array = right.array();\n-    auto out_array = out->array();\n-    return compare_function_->Compare(*scalar, *array, &out_array);\n-  } else if (lk == Datum::ARRAY && rk == Datum::ARRAY) {\n-    auto lhs = left.array();\n-    auto rhs = right.array();\n-    return compare_function_->Compare(*lhs, *rhs, &out_array);\n+struct RepeatedBufferAsStringView {\n+  explicit RepeatedBufferAsStringView(const Buffer& buffer) : value_(buffer) {}\n+  util::string_view operator()() { return value_; }\n+  util::string_view value_;\n+};\n+\n+struct ReadFromBitmap : internal::BitmapReader {\n+  using internal::BitmapReader::BitmapReader;\n+\n+  bool operator()() {\n+    bool out = IsSet();\n+    Next();\n+    return out;\n   }\n+};\n+\n+template <typename T>\n+struct DereferenceIncrementPointer {\n+  T operator()() { return *ptr_++; }\n+  const T* ptr_;\n+};\n+\n+template <typename ArrayType>\n+struct GetViewFromStringLikeArray {\n+  explicit GetViewFromStringLikeArray(const ArrayType* array) : array_(array) {}\n+\n+  string_view operator()() { return array_->GetView(i_++); }\n+\n+  const ArrayType* array_;\n+  int64_t i_ = 0;\n+};\n \n-  return Status::Invalid(\"Invalid datum signature for CompareBinaryKernel\");\n+template <typename T, typename RangeType = RepeatedValue<typename T::c_type>>\n+RangeType MakeRange(const TemporalScalar<T>& scalar) {\n+  return RangeType{scalar.value};\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename ScalarType = typename TypeTraits<ArrowType>::ScalarType,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareArrayScalar(const ArrayData& array, const ScalarType& scalar,\n-                                 uint8_t* output_bitmap) {\n-  const T* left = array.GetValues<T>(1);\n-  const T right = scalar.value;\n+template <typename T, typename RangeType = RepeatedValue<typename T::c_type>>\n+RangeType MakeRange(const internal::PrimitiveScalar<T>& scalar) {\n+  return RangeType{scalar.value};\n+}\n \n-  internal::GenerateBitsUnrolled(\n-      output_bitmap, 0, array.length,\n-      [&left, right]() -> bool { return Comparator<T, Op>::Compare(*left++, right); });\n+RepeatedBufferAsStringView MakeRange(const BaseBinaryScalar& scalar) {\n+  return RepeatedBufferAsStringView{*scalar.value};\n+}\n \n-  return Status::OK();\n+ReadFromBitmap MakeRange(const BooleanArray& array) {\n+  return ReadFromBitmap(array.data()->GetValues<uint8_t>(1), array.offset(),\n+                        array.length());\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename ScalarType = typename TypeTraits<ArrowType>::ScalarType,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareScalarArray(const ScalarType& scalar, const ArrayData& array,\n-                                 uint8_t* output_bitmap) {\n-  const T left = scalar.value;\n-  const T* right = array.GetValues<T>(1);\n+template <typename T,\n+          typename RangeType = DereferenceIncrementPointer<typename T::c_type>>\n+RangeType MakeRange(const NumericArray<T>& array) {\n+  return RangeType{array.raw_values()};\n+}\n \n-  internal::GenerateBitsUnrolled(\n-      output_bitmap, 0, array.length,\n-      [left, &right]() -> bool { return Comparator<T, Op>::Compare(left, *right++); });\n+template <typename T, typename RangeType = GetViewFromStringLikeArray<BaseBinaryArray<T>>>\n+RangeType MakeRange(const BaseBinaryArray<T>& array) {\n+  return RangeType{&array};\n+}\n \n-  return Status::OK();\n+inline Status AssignNulls(FunctionContext* ctx, const Scalar& scalar, const Array& array,\n+                          ArrayData* out) {\n+  return scalar.is_valid ? detail::PropagateNulls(ctx, *array.data(), out)\n+                         : detail::SetAllNulls(ctx, *array.data(), out);\n }\n \n-template <typename ArrowType, CompareOperator Op,\n-          typename T = typename TypeTraits<ArrowType>::CType>\n-static Status CompareArrayArray(const ArrayData& lhs, const ArrayData& rhs,\n-                                uint8_t* output_bitmap) {\n-  const T* left = lhs.GetValues<T>(1);\n-  const T* right = rhs.GetValues<T>(1);\n+inline Status AssignNulls(FunctionContext* ctx, const Array& left, const Array& right,\n+                          ArrayData* out) {\n+  return detail::AssignNullIntersection(ctx, *left.data(), *right.data(), out);\n+}\n \n-  internal::GenerateBitsUnrolled(output_bitmap, 0, lhs.length, [&left, &right]() -> bool {\n-    return Comparator<T, Op>::Compare(*left++, *right++);\n+template <CompareOperator Op, typename L, typename R>\n+Status Compare(L&& get_left, R&& get_right, ArrayData* out) {\n+  auto out_bitmap = out->buffers[1]->mutable_data();\n+  internal::GenerateBitsUnrolled(out_bitmap, 0, out->length, [&]() -> bool {\n+    return Comparator<decltype(get_left()), Op>::Compare(get_left(), get_right());\n   });\n-\n   return Status::OK();\n }\n \n template <typename ArrowType, CompareOperator Op>\n-class CompareFunctionImpl final : public CompareFunction {\n+class CompareKernel final : public BinaryKernel {\n+ public:\n   using ArrayType = typename TypeTraits<ArrowType>::ArrayType;\n   using ScalarType = typename TypeTraits<ArrowType>::ScalarType;\n \n- public:\n-  explicit CompareFunctionImpl(FunctionContext* ctx) : ctx_(ctx) {}\n-\n-  Status Compare(const ArrayData& array, const Scalar& scalar, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(array.type->Equals(scalar.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Output must be of same length\n-    DCHECK_EQ(output->length, array.length);\n-\n-    // Scalar is null, all comparisons are null.\n-    if (!scalar.is_valid) {\n-      return detail::SetAllNulls(ctx_, array, output);\n-    }\n+  std::shared_ptr<DataType> out_type() const override { return boolean(); }\n \n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::PropagateNulls(ctx_, array, output));\n+  Status Call(FunctionContext* ctx, const Datum& left, const Datum& right,\n+              Datum* out_datum) override {\n+    auto out = out_datum->array();\n \n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareArrayScalar<ArrowType, Op>(\n-        array, static_cast<const ScalarType&>(scalar), bitmap_result);\n-  }\n+    auto left_array = AsArray(left);\n+    auto left_scalar = AsScalar(left);\n+\n+    auto right_array = AsArray(right);\n+    auto right_scalar = AsScalar(right);\n \n-  Status Compare(const Scalar& scalar, const ArrayData& array, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(array.type->Equals(scalar.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Output must be of same length\n-    DCHECK_EQ(output->length, array.length);\n-\n-    // Scalar is null, all comparisons are null.\n-    if (!scalar.is_valid) {\n-      return detail::SetAllNulls(ctx_, array, output);\n+    if (left_array && right_array) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *left_array, *right_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_array), MakeRange(*right_array), out.get());\n     }\n \n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::PropagateNulls(ctx_, array, output));\n+    if (left_array && right_scalar) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *right_scalar, *left_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_array), MakeRange(*right_scalar), out.get());\n+    }\n \n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareScalarArray<ArrowType, Op>(static_cast<const ScalarType&>(scalar),\n-                                             array, bitmap_result);\n-  }\n+    if (left_scalar && right_array) {\n+      RETURN_NOT_OK(AssignNulls(ctx, *left_scalar, *right_array, out.get()));\n+      return Compare<Op>(MakeRange(*left_scalar), MakeRange(*right_array), out.get());\n+    }\n \n-  Status Compare(const ArrayData& lhs, const ArrayData& rhs, ArrayData* output) const {\n-    // Caller must cast\n-    DCHECK(lhs.type->Equals(rhs.type));\n-    // Output must be a boolean array\n-    DCHECK(output->type->Equals(boolean()));\n-    // Inputs must be of same length\n-    DCHECK_EQ(lhs.length, rhs.length);\n-    // Output must be of same length as inputs\n-    DCHECK_EQ(output->length, lhs.length);\n-\n-    // Copy null_bitmap\n-    RETURN_NOT_OK(detail::AssignNullIntersection(ctx_, lhs, rhs, output));\n-\n-    uint8_t* bitmap_result = output->buffers[1]->mutable_data();\n-    return CompareArrayArray<ArrowType, Op>(lhs, rhs, bitmap_result);\n+    return Status::Invalid(\"Invalid datum signature for CompareBinaryKernel::Call\");\n   }\n \n  private:\n-  FunctionContext* ctx_;\n-};\n+  static std::shared_ptr<ArrayType> AsArray(const Datum& datum) {\n+    if (datum.kind() != Datum::ARRAY) return nullptr;\n+    return checked_pointer_cast<ArrayType>(datum.make_array());\n+  }\n \n-template <typename ArrowType, CompareOperator Op>\n-static inline std::shared_ptr<CompareFunction> MakeCompareFunctionTypeOp(\n-    FunctionContext* ctx) {\n-  return std::make_shared<CompareFunctionImpl<ArrowType, Op>>(ctx);\n-}\n+  static std::shared_ptr<ScalarType> AsScalar(const Datum& datum) {\n+    if (datum.kind() != Datum::SCALAR) return nullptr;\n+    return checked_pointer_cast<ScalarType>(datum.scalar());\n+  }\n+};\n \n template <typename ArrowType>\n-static inline std::shared_ptr<CompareFunction> MakeCompareFunctionType(\n-    FunctionContext* ctx, struct CompareOptions options) {\n-  switch (options.op) {\n+std::shared_ptr<BinaryKernel> UnpackOperator(CompareOperator op) {\n+  switch (op) {\n     case CompareOperator::EQUAL:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::EQUAL>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::EQUAL>>();\n+\n     case CompareOperator::NOT_EQUAL:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::NOT_EQUAL>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::NOT_EQUAL>>();\n+\n     case CompareOperator::GREATER:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::GREATER>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::GREATER>>();\n+\n     case CompareOperator::GREATER_EQUAL:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::GREATER_EQUAL>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::GREATER_EQUAL>>();\n+\n     case CompareOperator::LESS:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::LESS>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::LESS>>();\n+\n     case CompareOperator::LESS_EQUAL:\n-      return MakeCompareFunctionTypeOp<ArrowType, CompareOperator::LESS_EQUAL>(ctx);\n+      return std::make_shared<CompareKernel<ArrowType, CompareOperator::LESS_EQUAL>>();\n   }\n \n   return nullptr;\n }\n \n-std::shared_ptr<CompareFunction> MakeCompareFunction(FunctionContext* ctx,\n-                                                     const DataType& type,\n-                                                     struct CompareOptions options) {\n-  switch (type.id()) {\n-    case UInt8Type::type_id:\n-      return MakeCompareFunctionType<UInt8Type>(ctx, options);\n-    case Int8Type::type_id:\n-      return MakeCompareFunctionType<Int8Type>(ctx, options);\n-    case UInt16Type::type_id:\n-      return MakeCompareFunctionType<UInt16Type>(ctx, options);\n-    case Int16Type::type_id:\n-      return MakeCompareFunctionType<Int16Type>(ctx, options);\n-    case UInt32Type::type_id:\n-      return MakeCompareFunctionType<UInt32Type>(ctx, options);\n-    case Int32Type::type_id:\n-      return MakeCompareFunctionType<Int32Type>(ctx, options);\n-    case UInt64Type::type_id:\n-      return MakeCompareFunctionType<UInt64Type>(ctx, options);\n-    case Int64Type::type_id:\n-      return MakeCompareFunctionType<Int64Type>(ctx, options);\n-    case FloatType::type_id:\n-      return MakeCompareFunctionType<FloatType>(ctx, options);\n-    case DoubleType::type_id:\n-      return MakeCompareFunctionType<DoubleType>(ctx, options);\n-    case Date32Type::type_id:\n-      return MakeCompareFunctionType<Date32Type>(ctx, options);\n-    case Date64Type::type_id:\n-      return MakeCompareFunctionType<Date64Type>(ctx, options);\n-    case TimestampType::type_id:\n-      return MakeCompareFunctionType<TimestampType>(ctx, options);\n-    case Time32Type::type_id:\n-      return MakeCompareFunctionType<Time32Type>(ctx, options);\n-    case Time64Type::type_id:\n-      return MakeCompareFunctionType<Time64Type>(ctx, options);\n-    default:\n-      return nullptr;\n+struct UnpackType {\n+  Status Visit(const NullType& unreachable) { return Status::OK(); }\n+\n+  Status Visit(const BooleanType& t) {\n+    *out_ = UnpackOperator<BooleanType>(options_.op);\n+    return Status::OK();\n   }\n+\n+  template <typename Numeric>\n+  enable_if_number<Numeric, Status> Visit(const Numeric& t) {\n+    *out_ = UnpackOperator<Numeric>(options_.op);\n+    return Status::OK();\n+  }\n+\n+  template <typename Temporal>\n+  enable_if_temporal<Temporal, Status> Visit(const Temporal& t) {\n+    *out_ = UnpackOperator<Temporal>(options_.op);\n+    return Status::OK();\n+  }\n+\n+  template <typename StringLike>\n+  enable_if_base_binary<StringLike, Status> Visit(const StringLike& t) {\n+    *out_ = UnpackOperator<StringLike>(options_.op);\n+    return Status::OK();\n+  }\n+\n+  Status Visit(const DictionaryType& t) { return NotImplemented(t); }\n \n Review comment:\n   To confirm: that was my intention as well\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-17T15:24:00.534+0000",
                    "updated": "2019-12-17T15:24:00.534+0000",
                    "started": "2019-12-17T15:24:00.533+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "360944",
                    "issueId": "13262630"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/worklog/361888",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nealrichardson commented on pull request #6034: ARROW-6902: [C++][Compute] Add String/Binary support to Compare kernel\nURL: https://github.com/apache/arrow/pull/6034\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-12-20T21:50:26.663+0000",
                    "updated": "2019-12-20T21:50:26.663+0000",
                    "started": "2019-12-20T21:50:26.663+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "361888",
                    "issueId": "13262630"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 10800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@4b089e2b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@765c6eaa[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7b036f96[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@6ebf7762[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@489c5869[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@164035e9[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@765f9768[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@634efaa6[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@493bb9b6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@5ec32205[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@54ad1a62[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4022519b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 10800,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Dec 20 21:50:31 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-12-20T21:50:31.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-6902/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2019-10-16T13:34:23.000+0000",
        "updated": "2019-12-20T21:50:31.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 10800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add String*/Binary* support for Compare kernels",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13262630/comment/17001225",
                    "id": "17001225",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "Issue resolved by pull request 6034\n[https://github.com/apache/arrow/pull/6034]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=npr",
                        "name": "npr",
                        "key": "npr",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Neal Richardson",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2019-12-20T21:50:31.096+0000",
                    "updated": "2019-12-20T21:50:31.096+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z07ng8:",
        "customfield_12314139": null
    }
}