{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13252908",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908",
    "key": "ARROW-6352",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12340948",
                "id": "12340948",
                "description": "",
                "name": "0.16.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-02-07"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=fan_li_ya",
            "name": "fan_li_ya",
            "key": "fan_li_ya",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Liya Fan",
            "active": true,
            "timeZone": "Asia/Shanghai"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
            "name": "emkornfield@gmail.com",
            "key": "emkornfield@gmail.com",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Micah Kornfield",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 25800,
            "total": 25800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 25800,
            "total": 25800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-6352/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 43,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/316600",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473\n \n \n   Today only Sparse unions are supported.  We should have a dense union implementation vector that conforms to the IPC protocol (the current sparse union vector doesn't do this and there are other JIRAs covering making it compatible).\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-23T10:56:48.241+0000",
                    "updated": "2019-09-23T10:56:48.241+0000",
                    "started": "2019-09-23T10:56:48.241+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "316600",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/317152",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r327420463\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionVector.java\n ##########\n @@ -0,0 +1,520 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.ReferenceManager;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.UnionMode;\n+import org.apache.arrow.vector.compare.RangeEqualsVisitor;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/DenseUnionVector.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+        import io.netty.buffer.ArrowBuf;\n+        import java.util.ArrayList;\n+        import java.util.Collections;\n+        import java.util.Iterator;\n+        import org.apache.arrow.vector.compare.VectorVisitor;\n+        import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+        import org.apache.arrow.vector.util.CallBack;\n+        import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+        import org.apache.arrow.memory.BaseAllocator;\n+        import org.apache.arrow.vector.BaseValueVector;\n+        import org.apache.arrow.vector.util.OversizedAllocationException;\n+        import org.apache.arrow.util.Preconditions;\n+\n+        import static org.apache.arrow.vector.types.UnionMode.Dense;\n+\n+\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+@SuppressWarnings(\"unused\")\n+\n+\n+/**\n+ * A vector which can hold values of different types. It does so by using a StructVector which contains a vector for each\n+ * primitive type that is stored. StructVector is used in order to take advantage of its serialization/deserialization methods,\n+ * as well as the addOrGet method.\n+ *\n+ * For performance reasons, DenseUnionVector stores a cached reference to each subtype vector, to avoid having to do the struct lookup\n+ * each time the vector is accessed.\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+public class DenseUnionVector extends UnionVector {\n \n Review comment:\n   I don't think this relationship should necessarily hold without a larger refactoring.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-24T04:16:59.832+0000",
                    "updated": "2019-09-24T04:16:59.832+0000",
                    "started": "2019-09-24T04:16:59.831+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "317152",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/317153",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r327420217\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionVector.java\n ##########\n @@ -0,0 +1,520 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.ReferenceManager;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.UnionMode;\n+import org.apache.arrow.vector.compare.RangeEqualsVisitor;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/DenseUnionVector.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+        import io.netty.buffer.ArrowBuf;\n+        import java.util.ArrayList;\n+        import java.util.Collections;\n+        import java.util.Iterator;\n+        import org.apache.arrow.vector.compare.VectorVisitor;\n+        import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+        import org.apache.arrow.vector.util.CallBack;\n+        import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+        import org.apache.arrow.memory.BaseAllocator;\n+        import org.apache.arrow.vector.BaseValueVector;\n+        import org.apache.arrow.vector.util.OversizedAllocationException;\n+        import org.apache.arrow.util.Preconditions;\n+\n+        import static org.apache.arrow.vector.types.UnionMode.Dense;\n+\n+\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+@SuppressWarnings(\"unused\")\n+\n+\n+/**\n+ * A vector which can hold values of different types. It does so by using a StructVector which contains a vector for each\n+ * primitive type that is stored. StructVector is used in order to take advantage of its serialization/deserialization methods,\n+ * as well as the addOrGet method.\n+ *\n+ * For performance reasons, DenseUnionVector stores a cached reference to each subtype vector, to avoid having to do the struct lookup\n+ * each time the vector is accessed.\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+public class DenseUnionVector extends UnionVector {\n+\n+  private static final byte OFFSET_WIDTH = 4;\n+\n+  private ArrowBuf offsetBuffer;\n+  private int offsetBufferAllocationSizeInBytes;\n+\n+  public static DenseUnionVector empty(String name, BufferAllocator allocator) {\n+    FieldType fieldType = FieldType.nullable(new ArrowType.Union(\n+            UnionMode.Dense, null));\n+    return new DenseUnionVector(name, allocator, fieldType, null);\n+  }\n+\n+  public DenseUnionVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(name, allocator, fieldType, callBack);\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.offsetBufferAllocationSizeInBytes = BaseValueVector.INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  }\n+\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf buffer = ownBuffers.get(0);\n+    typeBuffer.getReferenceManager().release();\n+    typeBuffer = buffer.getReferenceManager().retain(buffer, allocator);\n+    typeBufferAllocationSizeInBytes = typeBuffer.capacity();\n+\n+    buffer = ownBuffers.get(1);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = buffer.getReferenceManager().retain(buffer, allocator);\n+    offsetBufferAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    this.valueCount = fieldNode.getLength();\n+  }\n+\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+    setReaderAndWriterIndex();\n+    result.add(typeBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  protected void setReaderAndWriterIndex() {\n+    typeBuffer.readerIndex(0);\n+    typeBuffer.writerIndex(valueCount * TYPE_WIDTH);\n+\n+    offsetBuffer.readerIndex(0);\n+    offsetBuffer.writerIndex(valueCount * OFFSET_WIDTH);\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() { return offsetBuffer; }\n+\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    /* new allocation -- clear the current buffers */\n+    clear();\n+    internalStruct.allocateNew();\n+    try {\n+      allocateTypeBuffer();\n+      allocateOffsetBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public boolean allocateNewSafe() {\n+    /* new allocation -- clear the current buffers */\n+    clear();\n+    boolean safe = internalStruct.allocateNewSafe();\n+    if (!safe) { return false; }\n+    try {\n+      allocateTypeBuffer();\n+      allocateOffsetBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      return  false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private void allocateOffsetBuffer() {\n+    offsetBuffer = allocator.buffer(offsetBufferAllocationSizeInBytes);\n+    offsetBuffer.readerIndex(0);\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  @Override\n+  public void reAlloc() {\n+    internalStruct.reAlloc();\n+    reallocTypeBuffer();\n+    reallocOffsetBuffer();\n+  }\n+\n+  private void reallocOffsetBuffer() {\n+    final int currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize  = offsetBufferAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetBufferAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(Math.min(getTypeBufferValueCapacity(), getOffsetBufferValueCapacity()),\n+            internalStruct.getValueCapacity());\n+  }\n+\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    valueCount = 0;\n+    typeBuffer.getReferenceManager().release();\n+    typeBuffer = allocator.getEmpty();\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = allocator.getEmpty();\n+    internalStruct.clear();\n+  }\n+\n+  @Override\n+  public void reset() {\n+    valueCount = 0;\n+    typeBuffer.setZero(0, typeBuffer.capacity());\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    internalStruct.reset();\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    List<org.apache.arrow.vector.types.pojo.Field> childFields = new ArrayList<>();\n+    List<FieldVector> children = internalStruct.getChildren();\n+    int[] typeIds = new int[children.size()];\n+    for (ValueVector v : children) {\n+      typeIds[childFields.size()] = v.getMinorType().ordinal();\n+      childFields.add(v.getField());\n+    }\n+\n+    FieldType fieldType;\n+    if (this.fieldType == null) {\n+      fieldType = FieldType.nullable(new ArrowType.Union(Dense, typeIds));\n+    } else {\n+      final UnionMode mode = ((ArrowType.Union)this.fieldType.getType()).getMode();\n+      fieldType = new FieldType(this.fieldType.isNullable(), new ArrowType.Union(mode, typeIds),\n+              this.fieldType.getDictionary(), this.fieldType.getMetadata());\n+    }\n+\n+    return new Field(name, fieldType, childFields);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new org.apache.arrow.vector.complex.DenseUnionVector.TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((DenseUnionVector) target);\n+  }\n+\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    DenseUnionVector fromCast = (DenseUnionVector) from;\n+    int inOffset = fromCast.offsetBuffer.getInt(inIndex * OFFSET_WIDTH);\n+    fromCast.getReader().setPosition(inOffset);\n+    int outOffset = offsetBuffer.getInt(outIndex * OFFSET_WIDTH);\n+    getWriter().setPosition(outOffset);\n+    ComplexCopier.copy(fromCast.reader, writer);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    private final TransferPair[] internalTransferPairs = new TransferPair[Types.MinorType.values().length];\n+    private final DenseUnionVector to;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      to = new DenseUnionVector(name, allocator, null, callBack);\n+      internalStruct.makeTransferPair(to.internalStruct);\n+      createTransferPairs();\n+    }\n+\n+    public TransferImpl(DenseUnionVector to) {\n+      this.to = to;\n+      internalStruct.makeTransferPair(to.internalStruct);\n+      createTransferPairs();\n+    }\n+\n+    private void createTransferPairs() {\n+      for (int i = 0; i < internalStruct.getField().getChildren().size(); i++) {\n+        ValueVector srcVec = internalStruct.getVectorById(i);\n+        ValueVector dstVec = to.internalStruct.getVectorById(i);\n+        internalTransferPairs[srcVec.getMinorType().ordinal()] = srcVec.makeTransferPair(dstVec);\n+      }\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      final ReferenceManager refManager = typeBuffer.getReferenceManager();\n+      to.typeBuffer = refManager.transferOwnership(typeBuffer, to.allocator).getTransferredBuffer();\n+      to.offsetBuffer = refManager.transferOwnership(offsetBuffer, to.allocator).getTransferredBuffer();\n+      for (int i = 0; i < MinorType.values().length; i++) {\n+        if (internalTransferPairs[i] != null) {\n+          internalTransferPairs[i].transfer();\n+        }\n+      }\n+      to.valueCount = valueCount;\n+      clear();\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      to.clear();\n+      int startPoint = startIndex * TYPE_WIDTH;\n+      int sliceLength = length * TYPE_WIDTH;\n+      ArrowBuf slicedBuffer = typeBuffer.slice(startPoint, sliceLength);\n+      ReferenceManager refManager = slicedBuffer.getReferenceManager();\n+      to.typeBuffer = refManager.transferOwnership(slicedBuffer, to.allocator).getTransferredBuffer();\n+\n+      while (to.offsetBuffer.capacity() < length * OFFSET_WIDTH) {\n+        to.reallocOffsetBuffer();\n+      }\n+\n+      int [] typeCounts = new int[MinorType.values().length];\n+      int [] typeStarts = new int[Types.MinorType.values().length];\n+      for (int i = 0; i < typeCounts.length; i++) {\n+        typeCounts[i] = 0;\n+        typeStarts[i] = -1;\n+      }\n+\n+      for (int i = startIndex; i < startIndex + length; i++) {\n+        int ord = typeBuffer.getByte(i);\n+        to.offsetBuffer.setInt((i - startIndex) * OFFSET_WIDTH, typeCounts[ord]);\n+        typeCounts[ord] += 1;\n+        if (typeStarts[ord] == -1) {\n+          typeStarts[ord] = offsetBuffer.getInt(i * OFFSET_WIDTH);\n+        }\n+      }\n+      to.setValueCount(length);\n+\n+      // transfer vector values\n+      for (int i = 0; i < MinorType.values().length; i++) {\n+        if (typeCounts[i] > 0 && typeStarts[i] != -1) {\n+          internalTransferPairs[i].splitAndTransfer(typeStarts[i], typeCounts[i]);\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, DenseUnionVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public FieldReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  public FieldWriter getWriter() {\n+    if (writer == null) {\n+      writer = new UnionWriter(this);\n+    }\n+    return writer;\n+  }\n+\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) { return 0; }\n+\n+    return valueCount * TYPE_WIDTH + valueCount * OFFSET_WIDTH + internalStruct.getBufferSize();\n+  }\n+\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    long bufferSize = 0;\n+    for (final ValueVector v : (Iterable<ValueVector>) this) {\n+      bufferSize += v.getBufferSizeFor(valueCount);\n+    }\n+\n+    return (int) bufferSize + valueCount * TYPE_WIDTH + valueCount * OFFSET_WIDTH;\n+  }\n+\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    List<ArrowBuf> list = new java.util.ArrayList<>();\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() != 0) {\n+      list.add(typeBuffer);\n+      list.add(offsetBuffer);\n+      list.addAll(java.util.Arrays.asList(internalStruct.getBuffers(clear)));\n+    }\n+    if (clear) {\n \n Review comment:\n   can this call clear instead?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-24T04:16:59.912+0000",
                    "updated": "2019-09-24T04:16:59.912+0000",
                    "started": "2019-09-24T04:16:59.912+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "317153",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/317161",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on issue #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#issuecomment-534384066\n \n \n   > This change seems to propagate the fact that there can only be one Vector of a given minor type within the union. This isn't according to the spec, I would prefer to see something that might not be as efficient but implements the specification cleanly, instead of copying the same template pattern that SparseUnion uses.\r\n   \r\n   Thanks for your comments. You mean DenseUnionVector and SparseUnionVector should have separate minor type, and separate implementation right?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-24T04:32:35.918+0000",
                    "updated": "2019-09-24T04:32:35.918+0000",
                    "started": "2019-09-24T04:32:35.918+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "317161",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/317162",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on issue #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#issuecomment-534384066\n \n \n   > This change seems to propagate the fact that there can only be one Vector of a given minor type within the union. This isn't according to the spec, I would prefer to see something that might not be as efficient but implements the specification cleanly, instead of copying the same template pattern that SparseUnion uses.\r\n   \r\n   Thanks for your comments. You mean DenseUnionVector and SparseUnionVector should have separate minor type, and separate implementation, right?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-24T04:32:51.190+0000",
                    "updated": "2019-09-24T04:32:51.190+0000",
                    "started": "2019-09-24T04:32:51.190+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "317162",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/317165",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on issue #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#issuecomment-534384876\n \n \n   > Thanks for your comments. You mean DenseUnionVector and SparseUnionVector should have separate minor type, and separate implementation, right?\r\n   \r\n   Separate implemention yes.  Seperate minor type I'm not sure about I need to refresh myself on the implications of having two minor types corresponding to the same parameterized IPC specification type.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-24T04:36:48.338+0000",
                    "updated": "2019-09-24T04:36:48.338+0000",
                    "started": "2019-09-24T04:36:48.337+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "317165",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/318032",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on issue #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#issuecomment-534833142\n \n \n   > > Thanks for your comments. You mean DenseUnionVector and SparseUnionVector should have separate minor type, and separate implementation, right?\r\n   > \r\n   > Separate implemention yes. Seperate minor type I'm not sure about I need to refresh myself on the implications of having two minor types corresponding to the same parameterized IPC specification type.\r\n   \r\n   Thanks for your feedback. I have separated the implementations for UnionVector and DenseUnionVector. In addition, the implementations for reader/writer are also separate. However, implementations for list/struct reader/writer are shared. Please take a look.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-25T03:17:02.084+0000",
                    "updated": "2019-09-25T03:17:02.084+0000",
                    "started": "2019-09-25T03:17:02.084+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "318032",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/318046",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r327923539\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionVector.java\n ##########\n @@ -0,0 +1,520 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.ReferenceManager;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.UnionMode;\n+import org.apache.arrow.vector.compare.RangeEqualsVisitor;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/DenseUnionVector.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+        import io.netty.buffer.ArrowBuf;\n+        import java.util.ArrayList;\n+        import java.util.Collections;\n+        import java.util.Iterator;\n+        import org.apache.arrow.vector.compare.VectorVisitor;\n+        import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+        import org.apache.arrow.vector.util.CallBack;\n+        import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+        import org.apache.arrow.memory.BaseAllocator;\n+        import org.apache.arrow.vector.BaseValueVector;\n+        import org.apache.arrow.vector.util.OversizedAllocationException;\n+        import org.apache.arrow.util.Preconditions;\n+\n+        import static org.apache.arrow.vector.types.UnionMode.Dense;\n+\n+\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+@SuppressWarnings(\"unused\")\n+\n+\n+/**\n+ * A vector which can hold values of different types. It does so by using a StructVector which contains a vector for each\n+ * primitive type that is stored. StructVector is used in order to take advantage of its serialization/deserialization methods,\n+ * as well as the addOrGet method.\n+ *\n+ * For performance reasons, DenseUnionVector stores a cached reference to each subtype vector, to avoid having to do the struct lookup\n+ * each time the vector is accessed.\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+public class DenseUnionVector extends UnionVector {\n+\n+  private static final byte OFFSET_WIDTH = 4;\n+\n+  private ArrowBuf offsetBuffer;\n+  private int offsetBufferAllocationSizeInBytes;\n+\n+  public static DenseUnionVector empty(String name, BufferAllocator allocator) {\n+    FieldType fieldType = FieldType.nullable(new ArrowType.Union(\n+            UnionMode.Dense, null));\n+    return new DenseUnionVector(name, allocator, fieldType, null);\n+  }\n+\n+  public DenseUnionVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    super(name, allocator, fieldType, callBack);\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.offsetBufferAllocationSizeInBytes = BaseValueVector.INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  }\n+\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf buffer = ownBuffers.get(0);\n+    typeBuffer.getReferenceManager().release();\n+    typeBuffer = buffer.getReferenceManager().retain(buffer, allocator);\n+    typeBufferAllocationSizeInBytes = typeBuffer.capacity();\n+\n+    buffer = ownBuffers.get(1);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = buffer.getReferenceManager().retain(buffer, allocator);\n+    offsetBufferAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    this.valueCount = fieldNode.getLength();\n+  }\n+\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+    setReaderAndWriterIndex();\n+    result.add(typeBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  protected void setReaderAndWriterIndex() {\n+    typeBuffer.readerIndex(0);\n+    typeBuffer.writerIndex(valueCount * TYPE_WIDTH);\n+\n+    offsetBuffer.readerIndex(0);\n+    offsetBuffer.writerIndex(valueCount * OFFSET_WIDTH);\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() { return offsetBuffer; }\n+\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    /* new allocation -- clear the current buffers */\n+    clear();\n+    internalStruct.allocateNew();\n+    try {\n+      allocateTypeBuffer();\n+      allocateOffsetBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public boolean allocateNewSafe() {\n+    /* new allocation -- clear the current buffers */\n+    clear();\n+    boolean safe = internalStruct.allocateNewSafe();\n+    if (!safe) { return false; }\n+    try {\n+      allocateTypeBuffer();\n+      allocateOffsetBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      return  false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private void allocateOffsetBuffer() {\n+    offsetBuffer = allocator.buffer(offsetBufferAllocationSizeInBytes);\n+    offsetBuffer.readerIndex(0);\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  @Override\n+  public void reAlloc() {\n+    internalStruct.reAlloc();\n+    reallocTypeBuffer();\n+    reallocOffsetBuffer();\n+  }\n+\n+  private void reallocOffsetBuffer() {\n+    final int currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize  = offsetBufferAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetBufferAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(Math.min(getTypeBufferValueCapacity(), getOffsetBufferValueCapacity()),\n+            internalStruct.getValueCapacity());\n+  }\n+\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    valueCount = 0;\n+    typeBuffer.getReferenceManager().release();\n+    typeBuffer = allocator.getEmpty();\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = allocator.getEmpty();\n+    internalStruct.clear();\n+  }\n+\n+  @Override\n+  public void reset() {\n+    valueCount = 0;\n+    typeBuffer.setZero(0, typeBuffer.capacity());\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    internalStruct.reset();\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    List<org.apache.arrow.vector.types.pojo.Field> childFields = new ArrayList<>();\n+    List<FieldVector> children = internalStruct.getChildren();\n+    int[] typeIds = new int[children.size()];\n+    for (ValueVector v : children) {\n+      typeIds[childFields.size()] = v.getMinorType().ordinal();\n+      childFields.add(v.getField());\n+    }\n+\n+    FieldType fieldType;\n+    if (this.fieldType == null) {\n+      fieldType = FieldType.nullable(new ArrowType.Union(Dense, typeIds));\n+    } else {\n+      final UnionMode mode = ((ArrowType.Union)this.fieldType.getType()).getMode();\n+      fieldType = new FieldType(this.fieldType.isNullable(), new ArrowType.Union(mode, typeIds),\n+              this.fieldType.getDictionary(), this.fieldType.getMetadata());\n+    }\n+\n+    return new Field(name, fieldType, childFields);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new org.apache.arrow.vector.complex.DenseUnionVector.TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((DenseUnionVector) target);\n+  }\n+\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    DenseUnionVector fromCast = (DenseUnionVector) from;\n+    int inOffset = fromCast.offsetBuffer.getInt(inIndex * OFFSET_WIDTH);\n+    fromCast.getReader().setPosition(inOffset);\n+    int outOffset = offsetBuffer.getInt(outIndex * OFFSET_WIDTH);\n+    getWriter().setPosition(outOffset);\n+    ComplexCopier.copy(fromCast.reader, writer);\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    private final TransferPair[] internalTransferPairs = new TransferPair[Types.MinorType.values().length];\n+    private final DenseUnionVector to;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      to = new DenseUnionVector(name, allocator, null, callBack);\n+      internalStruct.makeTransferPair(to.internalStruct);\n+      createTransferPairs();\n+    }\n+\n+    public TransferImpl(DenseUnionVector to) {\n+      this.to = to;\n+      internalStruct.makeTransferPair(to.internalStruct);\n+      createTransferPairs();\n+    }\n+\n+    private void createTransferPairs() {\n+      for (int i = 0; i < internalStruct.getField().getChildren().size(); i++) {\n+        ValueVector srcVec = internalStruct.getVectorById(i);\n+        ValueVector dstVec = to.internalStruct.getVectorById(i);\n+        internalTransferPairs[srcVec.getMinorType().ordinal()] = srcVec.makeTransferPair(dstVec);\n+      }\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      final ReferenceManager refManager = typeBuffer.getReferenceManager();\n+      to.typeBuffer = refManager.transferOwnership(typeBuffer, to.allocator).getTransferredBuffer();\n+      to.offsetBuffer = refManager.transferOwnership(offsetBuffer, to.allocator).getTransferredBuffer();\n+      for (int i = 0; i < MinorType.values().length; i++) {\n+        if (internalTransferPairs[i] != null) {\n+          internalTransferPairs[i].transfer();\n+        }\n+      }\n+      to.valueCount = valueCount;\n+      clear();\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      to.clear();\n+      int startPoint = startIndex * TYPE_WIDTH;\n+      int sliceLength = length * TYPE_WIDTH;\n+      ArrowBuf slicedBuffer = typeBuffer.slice(startPoint, sliceLength);\n+      ReferenceManager refManager = slicedBuffer.getReferenceManager();\n+      to.typeBuffer = refManager.transferOwnership(slicedBuffer, to.allocator).getTransferredBuffer();\n+\n+      while (to.offsetBuffer.capacity() < length * OFFSET_WIDTH) {\n+        to.reallocOffsetBuffer();\n+      }\n+\n+      int [] typeCounts = new int[MinorType.values().length];\n+      int [] typeStarts = new int[Types.MinorType.values().length];\n+      for (int i = 0; i < typeCounts.length; i++) {\n+        typeCounts[i] = 0;\n+        typeStarts[i] = -1;\n+      }\n+\n+      for (int i = startIndex; i < startIndex + length; i++) {\n+        int ord = typeBuffer.getByte(i);\n+        to.offsetBuffer.setInt((i - startIndex) * OFFSET_WIDTH, typeCounts[ord]);\n+        typeCounts[ord] += 1;\n+        if (typeStarts[ord] == -1) {\n+          typeStarts[ord] = offsetBuffer.getInt(i * OFFSET_WIDTH);\n+        }\n+      }\n+      to.setValueCount(length);\n+\n+      // transfer vector values\n+      for (int i = 0; i < MinorType.values().length; i++) {\n+        if (typeCounts[i] > 0 && typeStarts[i] != -1) {\n+          internalTransferPairs[i].splitAndTransfer(typeStarts[i], typeCounts[i]);\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, DenseUnionVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public FieldReader getReader() {\n+    if (reader == null) {\n+      reader = new UnionReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  public FieldWriter getWriter() {\n+    if (writer == null) {\n+      writer = new UnionWriter(this);\n+    }\n+    return writer;\n+  }\n+\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) { return 0; }\n+\n+    return valueCount * TYPE_WIDTH + valueCount * OFFSET_WIDTH + internalStruct.getBufferSize();\n+  }\n+\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    long bufferSize = 0;\n+    for (final ValueVector v : (Iterable<ValueVector>) this) {\n+      bufferSize += v.getBufferSizeFor(valueCount);\n+    }\n+\n+    return (int) bufferSize + valueCount * TYPE_WIDTH + valueCount * OFFSET_WIDTH;\n+  }\n+\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    List<ArrowBuf> list = new java.util.ArrayList<>();\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() != 0) {\n+      list.add(typeBuffer);\n+      list.add(offsetBuffer);\n+      list.addAll(java.util.Arrays.asList(internalStruct.getBuffers(clear)));\n+    }\n+    if (clear) {\n \n Review comment:\n   yes, I think so. Calling clear/close is essentially the same as calling release, which decrements the refcount by 1.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-25T04:04:31.671+0000",
                    "updated": "2019-09-25T04:04:31.671+0000",
                    "started": "2019-09-25T04:04:31.671+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "318046",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/318047",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r327923568\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionVector.java\n ##########\n @@ -0,0 +1,520 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.ReferenceManager;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.UnionMode;\n+import org.apache.arrow.vector.compare.RangeEqualsVisitor;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/DenseUnionVector.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+        import io.netty.buffer.ArrowBuf;\n+        import java.util.ArrayList;\n+        import java.util.Collections;\n+        import java.util.Iterator;\n+        import org.apache.arrow.vector.compare.VectorVisitor;\n+        import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+        import org.apache.arrow.vector.util.CallBack;\n+        import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+        import org.apache.arrow.memory.BaseAllocator;\n+        import org.apache.arrow.vector.BaseValueVector;\n+        import org.apache.arrow.vector.util.OversizedAllocationException;\n+        import org.apache.arrow.util.Preconditions;\n+\n+        import static org.apache.arrow.vector.types.UnionMode.Dense;\n+\n+\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+@SuppressWarnings(\"unused\")\n+\n+\n+/**\n+ * A vector which can hold values of different types. It does so by using a StructVector which contains a vector for each\n+ * primitive type that is stored. StructVector is used in order to take advantage of its serialization/deserialization methods,\n+ * as well as the addOrGet method.\n+ *\n+ * For performance reasons, DenseUnionVector stores a cached reference to each subtype vector, to avoid having to do the struct lookup\n+ * each time the vector is accessed.\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+public class DenseUnionVector extends UnionVector {\n \n Review comment:\n   Sure. The implementations are separated now.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-09-25T04:04:52.204+0000",
                    "updated": "2019-09-25T04:04:52.204+0000",
                    "started": "2019-09-25T04:04:52.203+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "318047",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/323746",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r331695326\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionReader.java\n ##########\n @@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/DenseUnionReader.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex.impl;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+/**\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+@SuppressWarnings(\"unused\")\n+public class DenseUnionReader extends AbstractFieldReader {\n+\n+  private BaseReader[] readers = new BaseReader[43];\n \n Review comment:\n   This looks like it is propagating the incompatibity with the IPC specification.  Specifically a union should be able to have more then one vector for each minor type.  is this the case?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-10-04T21:38:29.253+0000",
                    "updated": "2019-10-04T21:38:29.253+0000",
                    "started": "2019-10-04T21:38:29.253+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "323746",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/323886",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r331736382\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionReader.java\n ##########\n @@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/DenseUnionReader.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex.impl;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+/**\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+@SuppressWarnings(\"unused\")\n+public class DenseUnionReader extends AbstractFieldReader {\n+\n+  private BaseReader[] readers = new BaseReader[43];\n \n Review comment:\n   Are you asking this question: UnionVector and DenseUnionVector are sharing the same minor type? If so, the answer is yes for now.\r\n   Do you think we should provide separate minor types for them?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-10-05T07:08:34.352+0000",
                    "updated": "2019-10-05T07:08:34.352+0000",
                    "started": "2019-10-05T07:08:34.352+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "323886",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/323994",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r331765018\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionReader.java\n ##########\n @@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/DenseUnionReader.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex.impl;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+/**\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+@SuppressWarnings(\"unused\")\n+public class DenseUnionReader extends AbstractFieldReader {\n+\n+  private BaseReader[] readers = new BaseReader[43];\n \n Review comment:\n   No I'm asking if there can be two different vectors of the same type in the union (e.g. two different struct vectors).\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-10-05T23:26:01.908+0000",
                    "updated": "2019-10-05T23:26:01.908+0000",
                    "started": "2019-10-05T23:26:01.907+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "323994",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/324934",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r332394676\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionReader.java\n ##########\n @@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/DenseUnionReader.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex.impl;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+/**\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+@SuppressWarnings(\"unused\")\n+public class DenseUnionReader extends AbstractFieldReader {\n+\n+  private BaseReader[] readers = new BaseReader[43];\n \n Review comment:\n   I see. Thanks for the clarification. \r\n   \r\n   You are right. This implementation does not support more than one vector for each minor type. \r\n   This is aligning with the current (Sparse) UnionVector. \r\n   \r\n   Should we resolve this problem?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-10-08T08:38:40.245+0000",
                    "updated": "2019-10-08T08:38:40.245+0000",
                    "started": "2019-10-08T08:38:40.244+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "324934",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/327207",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r334221347\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionReader.java\n ##########\n @@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/DenseUnionReader.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex.impl;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+/**\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+@SuppressWarnings(\"unused\")\n+public class DenseUnionReader extends AbstractFieldReader {\n+\n+  private BaseReader[] readers = new BaseReader[43];\n \n Review comment:\n   IMO densevector shouldn't propagate the same problems the existing UnionVector has with compatibility.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-10-12T05:15:45.362+0000",
                    "updated": "2019-10-12T05:15:45.362+0000",
                    "started": "2019-10-12T05:15:45.361+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "327207",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/327228",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r334223421\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionReader.java\n ##########\n @@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/DenseUnionReader.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex.impl;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+/**\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+@SuppressWarnings(\"unused\")\n+public class DenseUnionReader extends AbstractFieldReader {\n+\n+  private BaseReader[] readers = new BaseReader[43];\n \n Review comment:\n   Thanks a lot for your feedback. I will resolve it later.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-10-12T06:31:37.087+0000",
                    "updated": "2019-10-12T06:31:37.087+0000",
                    "started": "2019-10-12T06:31:37.087+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "327228",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/327729",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r334421476\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionReader.java\n ##########\n @@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+import org.apache.arrow.vector.types.Types.MinorType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/impl/DenseUnionReader.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex.impl;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+/**\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+@SuppressWarnings(\"unused\")\n+public class DenseUnionReader extends AbstractFieldReader {\n+\n+  private BaseReader[] readers = new BaseReader[43];\n \n Review comment:\n   @emkornfield I have updated the code to allow arbitrary relative types for the desne union vector. Please take a look.\r\n   \r\n   Brief change list:\r\n   1. For StructVector and ListVector, a custom type id is registered when they are added, if the same relative type has never occured. \r\n   2. the type id of the custom relative types start from MinorType.values().length, and the maximum value is 128.\r\n   3. some additional data structures are added to track the existing custom relative types, struct vector, and list vectors.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-10-14T10:43:13.063+0000",
                    "updated": "2019-10-14T10:43:13.063+0000",
                    "started": "2019-10-14T10:43:13.062+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "327729",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/369736",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r365134366\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionVector.java\n ##########\n @@ -0,0 +1,887 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.ReferenceManager;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.UnionMode;\n+import org.apache.arrow.vector.compare.RangeEqualsVisitor;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/DenseUnionVector.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+        import io.netty.buffer.ArrowBuf;\n+        import java.util.ArrayList;\n+        import java.util.Collections;\n+        import java.util.Iterator;\n+        import org.apache.arrow.vector.compare.VectorVisitor;\n+        import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+        import org.apache.arrow.vector.util.CallBack;\n+        import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+        import org.apache.arrow.memory.BaseAllocator;\n+        import org.apache.arrow.vector.BaseValueVector;\n+        import org.apache.arrow.vector.util.OversizedAllocationException;\n+        import org.apache.arrow.util.Preconditions;\n+\n+        import static org.apache.arrow.vector.types.UnionMode.Dense;\n+\n+\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+@SuppressWarnings(\"unused\")\n+\n+\n+/**\n+ * A vector which can hold values of different types. It does so by using a StructVector which contains a vector for each\n+ * primitive type that is stored. StructVector is used in order to take advantage of its serialization/deserialization methods,\n+ * as well as the addOrGet method.\n+ *\n+ * For performance reasons, DenseUnionVector stores a cached reference to each subtype vector, to avoid having to do the struct lookup\n+ * each time the vector is accessed.\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+public class DenseUnionVector implements FieldVector {\n+\n+  private String name;\n+  private BufferAllocator allocator;\n+  int valueCount;\n+\n+  NonNullableStructVector internalStruct;\n+  private ArrowBuf typeBuffer;\n+  private ArrowBuf offsetBuffer;\n+\n+  /**\n+   * The key is type Id, and the value is vector.\n+   */\n+  private java.util.Map<Integer, StructVector> structVectors = new java.util.HashMap<>();\n+  private java.util.Map<Integer, ListVector> listVectors = new java.util.HashMap<>();\n+\n+  /**\n+   * The index is the type id, and the value is the type field.\n+   */\n+  private Field[] typeFields = new Field[Byte.MAX_VALUE + 1];\n+\n+  /**\n+   * The next typd id to allocate.\n+   */\n+  private int nextTypeId = Types.MinorType.values().length;\n+\n+  private FieldReader reader;\n+\n+  private int singleType = 0;\n+  private ValueVector singleVector;\n+\n+  private final CallBack callBack;\n+  private int typeBufferAllocationSizeInBytes;\n+  private int offsetBufferAllocationSizeInBytes;\n+\n+  private final FieldType fieldType;\n+\n+  private static final byte TYPE_WIDTH = 1;\n+  public static final byte OFFSET_WIDTH = 4;\n+\n+  private static final FieldType INTERNAL_STRUCT_TYPE = new FieldType(false /*nullable*/,\n+          ArrowType.Struct.INSTANCE, null /*dictionary*/, null /*metadata*/);\n+\n+  public static DenseUnionVector empty(String name, BufferAllocator allocator) {\n+    FieldType fieldType = FieldType.nullable(new ArrowType.Union(\n+            UnionMode.Dense, null));\n+    return new DenseUnionVector(name, allocator, fieldType, null);\n+  }\n+\n+  public DenseUnionVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    this.name = name;\n+    this.allocator = allocator;\n+    this.fieldType = fieldType;\n+    this.internalStruct = new NonNullableStructVector(\"internal\", allocator, INTERNAL_STRUCT_TYPE,\n+            callBack);\n+    this.typeBuffer = allocator.getEmpty();\n+    this.callBack = callBack;\n+    this.typeBufferAllocationSizeInBytes = BaseValueVector.INITIAL_VALUE_ALLOCATION * TYPE_WIDTH;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.offsetBufferAllocationSizeInBytes = BaseValueVector.INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  }\n+\n+  public BufferAllocator getAllocator() {\n+    return allocator;\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.UNION;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    internalStruct.initializeChildrenFromFields(children);\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return internalStruct.getChildrenFromFields();\n+  }\n+\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf buffer = ownBuffers.get(0);\n+    typeBuffer.getReferenceManager().release();\n+    typeBuffer = buffer.getReferenceManager().retain(buffer, allocator);\n+    typeBufferAllocationSizeInBytes = typeBuffer.capacity();\n+\n+    buffer = ownBuffers.get(1);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = buffer.getReferenceManager().retain(buffer, allocator);\n+    offsetBufferAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    this.valueCount = fieldNode.getLength();\n+  }\n+\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+    setReaderAndWriterIndex();\n+    result.add(typeBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  private void setReaderAndWriterIndex() {\n+    typeBuffer.readerIndex(0);\n+    typeBuffer.writerIndex(valueCount * TYPE_WIDTH);\n+\n+    offsetBuffer.readerIndex(0);\n+    offsetBuffer.writerIndex(valueCount * OFFSET_WIDTH);\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use geFieldBuffers\");\n+  }\n+\n+  private String fieldName(MinorType type) {\n+    return type.name().toLowerCase();\n+  }\n+\n+  private String fieldName(int typeId, MinorType type) {\n+    return type.name().toLowerCase() + typeId;\n+  }\n+\n+  private FieldType fieldType(MinorType type) {\n+    return FieldType.nullable(type.getType());\n+  }\n+\n+  private synchronized int registerNewTypeId(Field field) {\n+    if (nextTypeId == typeFields.length) {\n+      throw new IllegalStateException(\"Dense union vector support at most \" +\n+              typeFields.length + \" relative types. Please use union of union instead\");\n+    }\n+    int typeId = nextTypeId;\n+    typeFields[typeId] = field;\n+    this.nextTypeId += 1;\n+    return typeId;\n+  }\n+\n+  /**\n+   * Try to get the type id of the given field.\n+   * If the field is not used before, a new type id will be allocated.\n+   * @param field the field for which to get type id.\n+   * @return the typd id for the field.\n+   */\n+  public int getOrAllocateTypeId(Field field) {\n+    ArrowType fieldType = field.getFieldType().getType();\n+    if (fieldType instanceof Struct || fieldType instanceof  List) {\n+      // TODO: make this process faster\n+\n+      // search for a matching registered type id\n+      for (int i = Types.MinorType.values().length; i < nextTypeId; i++) {\n+        if (typeFields[i].relativeTypeEquals(field)) {\n+          return i;\n+        }\n+      }\n+\n+      // not registered yet, allocate a new type id\n+      return registerNewTypeId(field);\n+    } else {\n+      // for built-in types\n+      return Types.getMinorTypeForArrowType(field.getFieldType().getType()).ordinal();\n+    }\n+  }\n+\n+  private <T extends FieldVector> T addOrGet(MinorType minorType, Class<T> c) {\n+    return internalStruct.addOrGet(fieldName(minorType), fieldType(minorType), c);\n+  }\n+\n+  private <T extends FieldVector> T addOrGet(int typeId, MinorType minorType, Class<T> c) {\n+    return internalStruct.addOrGet(fieldName(typeId, minorType), fieldType(minorType), c);\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return typeBuffer.memoryAddress();\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() { return typeBuffer; }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() { return offsetBuffer; }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() { throw new UnsupportedOperationException(); }\n+\n+  public StructVector getStruct(int typeId) {\n+    StructVector structVector = structVectors.get(typeId);\n+    if (structVector == null) {\n+      int vectorCount = internalStruct.size();\n+      structVector = addOrGet(typeId, MinorType.STRUCT, StructVector.class);\n+      if (internalStruct.size() > vectorCount) {\n+        structVector.allocateNew();\n+        structVectors.put(typeId, structVector);\n+        if (callBack != null) {\n+          callBack.doWork();\n+        }\n+      }\n+    }\n+    return structVector;\n+  }\n+\n+  <#list vv.types as type>\n+    <#list type.minor as minor>\n+      <#assign name = minor.class?cap_first />\n+      <#assign fields = minor.fields!type.fields />\n+      <#assign uncappedName = name?uncap_first/>\n+      <#assign lowerCaseName = name?lower_case/>\n+      <#if !minor.typeParams?? >\n+\n+  private ${name}Vector ${uncappedName}Vector;\n+\n+  public ${name}Vector get${name}Vector() {\n+    if (${uncappedName}Vector == null) {\n+      int vectorCount = internalStruct.size();\n+      ${uncappedName}Vector = addOrGet(MinorType.${name?upper_case}, ${name}Vector.class);\n+      if (internalStruct.size() > vectorCount) {\n+        ${uncappedName}Vector.allocateNew();\n+        if (callBack != null) {\n+          callBack.doWork();\n+        }\n+      }\n+    }\n+    return ${uncappedName}Vector;\n+  }\n+      </#if>\n+    </#list>\n+  </#list>\n+\n+  public ListVector getList(int typeId) {\n+    ListVector listVector = listVectors.get(typeId);\n+    if (listVector == null) {\n+      int vectorCount = internalStruct.size();\n+      listVector = addOrGet(typeId, MinorType.LIST, ListVector.class);\n+      if (internalStruct.size() > vectorCount) {\n+        listVector.allocateNew();\n+        listVectors.put(typeId, listVector);\n+        if (callBack != null) {\n+          callBack.doWork();\n+        }\n+      }\n+    }\n+    return listVector;\n+  }\n+\n+  public int getTypeValue(int index) {\n+    return typeBuffer.getByte(index * TYPE_WIDTH);\n+  }\n+\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    /* new allocation -- clear the current buffers */\n+    clear();\n+    internalStruct.allocateNew();\n+    try {\n+      allocateTypeBuffer();\n+      allocateOffsetBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public boolean allocateNewSafe() {\n+    /* new allocation -- clear the current buffers */\n+    clear();\n+    boolean safe = internalStruct.allocateNewSafe();\n+    if (!safe) { return false; }\n+    try {\n+      allocateTypeBuffer();\n+      allocateOffsetBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      return  false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private void allocateTypeBuffer() {\n+    typeBuffer = allocator.buffer(typeBufferAllocationSizeInBytes);\n+    typeBuffer.readerIndex(0);\n+    typeBuffer.setZero(0, typeBuffer.capacity());\n+  }\n+\n+  private void allocateOffsetBuffer() {\n+    offsetBuffer = allocator.buffer(offsetBufferAllocationSizeInBytes);\n+    offsetBuffer.readerIndex(0);\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  @Override\n+  public void reAlloc() {\n+    internalStruct.reAlloc();\n+    reallocTypeBuffer();\n+    reallocOffsetBuffer();\n+  }\n+\n+  private void reallocTypeBuffer() {\n+    final int currentBufferCapacity = typeBuffer.capacity();\n+    long baseSize  = typeBufferAllocationSizeInBytes;\n+\n+    if (baseSize < (long)currentBufferCapacity) {\n+      baseSize = (long)currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n+    newBuf.setBytes(0, typeBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    typeBuffer.getReferenceManager().release(1);\n+    typeBuffer = newBuf;\n+    typeBufferAllocationSizeInBytes = (int)newAllocationSize;\n+  }\n+\n+  private void reallocOffsetBuffer() {\n+    final int currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize  = offsetBufferAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetBufferAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) { }\n+\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(Math.min(getTypeBufferValueCapacity(), getOffsetBufferValueCapacity()),\n+            internalStruct.getValueCapacity());\n+  }\n+\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    valueCount = 0;\n+    typeBuffer.getReferenceManager().release();\n+    typeBuffer = allocator.getEmpty();\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = allocator.getEmpty();\n+    internalStruct.clear();\n+  }\n+\n+  @Override\n+  public void reset() {\n+    valueCount = 0;\n+    typeBuffer.setZero(0, typeBuffer.capacity());\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    internalStruct.reset();\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    List<org.apache.arrow.vector.types.pojo.Field> childFields = new ArrayList<>();\n+    List<FieldVector> children = internalStruct.getChildren();\n+    int[] typeIds = new int[children.size()];\n+    for (ValueVector v : children) {\n+      typeIds[childFields.size()] = v.getMinorType().ordinal();\n+      childFields.add(v.getField());\n+    }\n+\n+    FieldType fieldType;\n+    if (this.fieldType == null) {\n+      fieldType = FieldType.nullable(new ArrowType.Union(Dense, typeIds));\n+    } else {\n+      final UnionMode mode = ((ArrowType.Union)this.fieldType.getType()).getMode();\n+      fieldType = new FieldType(this.fieldType.isNullable(), new ArrowType.Union(mode, typeIds),\n+              this.fieldType.getDictionary(), this.fieldType.getMetadata());\n+    }\n+\n+    return new Field(name, fieldType, childFields);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(name, allocator);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new org.apache.arrow.vector.complex.DenseUnionVector.TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((DenseUnionVector) target);\n+  }\n+\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    DenseUnionVector fromCast = (DenseUnionVector) from;\n+    int inOffset = fromCast.offsetBuffer.getInt(inIndex * OFFSET_WIDTH);\n+    fromCast.getReader().setPosition(inOffset);\n+    int outOffset = offsetBuffer.getInt(outIndex * OFFSET_WIDTH);\n+    getWriter().setPosition(outOffset);\n+    ComplexCopier.copy(fromCast.reader, writer);\n+  }\n+\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  public FieldVector addVector(FieldVector v) {\n+    int typeId = getOrAllocateTypeId(v.getField());\n+    String name = typeId < Types.MinorType.values().length ? fieldName(v.getMinorType()) :\n+            fieldName(typeId, v.getMinorType());\n+    Preconditions.checkState(internalStruct.getChild(name) == null, String.format(\"%s vector already exists\", name));\n+    final FieldVector newVector = internalStruct.addOrGet(name, v.getField().getFieldType(), v.getClass());\n+    v.makeTransferPair(newVector).transfer();\n+    internalStruct.putChild(name, newVector);\n+    if (newVector instanceof StructVector) {\n+      structVectors.put(typeId, (StructVector) newVector);\n+    } else if (newVector instanceof ListVector) {\n+      listVectors.put(typeId, (ListVector) newVector);\n+    }\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return newVector;\n+  }\n+\n+  /**\n+   * Directly put a vector to internalStruct without creating a new one with same type.\n+   */\n+  public void directAddVector(FieldVector v) {\n+    String name = v.getMinorType().name().toLowerCase();\n+    Preconditions.checkState(internalStruct.getChild(name) == null, String.format(\"%s vector already exists\", name));\n+    internalStruct.putChild(name, v);\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    private final TransferPair[] internalTransferPairs = new TransferPair[Types.MinorType.values().length];\n+    private final DenseUnionVector to;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      to = new DenseUnionVector(name, allocator, null, callBack);\n+      internalStruct.makeTransferPair(to.internalStruct);\n+      createTransferPairs();\n+    }\n+\n+    public TransferImpl(DenseUnionVector to) {\n+      this.to = to;\n+      internalStruct.makeTransferPair(to.internalStruct);\n+      createTransferPairs();\n+    }\n+\n+    private void createTransferPairs() {\n+      for (int i = 0; i < internalStruct.getField().getChildren().size(); i++) {\n+        ValueVector srcVec = internalStruct.getVectorById(i);\n+        ValueVector dstVec = to.internalStruct.getVectorById(i);\n+        internalTransferPairs[srcVec.getMinorType().ordinal()] = srcVec.makeTransferPair(dstVec);\n+      }\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      final ReferenceManager refManager = typeBuffer.getReferenceManager();\n+      to.typeBuffer = refManager.transferOwnership(typeBuffer, to.allocator).getTransferredBuffer();\n+      to.offsetBuffer = refManager.transferOwnership(offsetBuffer, to.allocator).getTransferredBuffer();\n+      for (int i = 0; i < MinorType.values().length; i++) {\n+        if (internalTransferPairs[i] != null) {\n+          internalTransferPairs[i].transfer();\n+        }\n+      }\n+      to.valueCount = valueCount;\n+      clear();\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      to.clear();\n+      int startPoint = startIndex * TYPE_WIDTH;\n+      int sliceLength = length * TYPE_WIDTH;\n+      ArrowBuf slicedBuffer = typeBuffer.slice(startPoint, sliceLength);\n+      ReferenceManager refManager = slicedBuffer.getReferenceManager();\n+      to.typeBuffer = refManager.transferOwnership(slicedBuffer, to.allocator).getTransferredBuffer();\n+\n+      while (to.offsetBuffer.capacity() < length * OFFSET_WIDTH) {\n+        to.reallocOffsetBuffer();\n+      }\n+\n+      int [] typeCounts = new int[MinorType.values().length];\n+      int [] typeStarts = new int[Types.MinorType.values().length];\n+      for (int i = 0; i < typeCounts.length; i++) {\n+        typeCounts[i] = 0;\n+        typeStarts[i] = -1;\n+      }\n+\n+      for (int i = startIndex; i < startIndex + length; i++) {\n+        int ord = typeBuffer.getByte(i);\n+        to.offsetBuffer.setInt((i - startIndex) * OFFSET_WIDTH, typeCounts[ord]);\n+        typeCounts[ord] += 1;\n+        if (typeStarts[ord] == -1) {\n+          typeStarts[ord] = offsetBuffer.getInt(i * OFFSET_WIDTH);\n+        }\n+      }\n+      to.setValueCount(length);\n+\n+      // transfer vector values\n+      for (int i = 0; i < MinorType.values().length; i++) {\n+        if (typeCounts[i] > 0 && typeStarts[i] != -1) {\n+          internalTransferPairs[i].splitAndTransfer(typeStarts[i], typeCounts[i]);\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, DenseUnionVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public FieldReader getReader() {\n+    if (reader == null) {\n+      reader = new DenseUnionReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  public FieldWriter getWriter() {\n+    if (writer == null) {\n+      writer = new DenseUnionWriter(this);\n+    }\n+    return writer;\n+  }\n+\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) { return 0; }\n+\n+    return valueCount * TYPE_WIDTH + valueCount * OFFSET_WIDTH + internalStruct.getBufferSize();\n+  }\n+\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    long bufferSize = 0;\n+    for (final ValueVector v : (Iterable<ValueVector>) this) {\n+      bufferSize += v.getBufferSizeFor(valueCount);\n+    }\n+\n+    return (int) bufferSize + valueCount * TYPE_WIDTH + valueCount * OFFSET_WIDTH;\n+  }\n+\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    List<ArrowBuf> list = new java.util.ArrayList<>();\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() != 0) {\n+      list.add(typeBuffer);\n+      list.add(offsetBuffer);\n+      list.addAll(java.util.Arrays.asList(internalStruct.getBuffers(clear)));\n+    }\n+    if (clear) {\n+      valueCount = 0;\n+      typeBuffer.getReferenceManager().retain();\n+      typeBuffer.close();\n+      typeBuffer = allocator.getEmpty();\n+      offsetBuffer.getReferenceManager().retain();\n+      offsetBuffer.close();\n+      offsetBuffer = allocator.getEmpty();\n+    }\n+    return list.toArray(new ArrowBuf[list.size()]);\n+  }\n+\n+  @Override\n+  public Iterator<ValueVector> iterator() {\n+    List<ValueVector> vectors = org.apache.arrow.util.Collections2.toList(internalStruct.iterator());\n+    return vectors.iterator();\n+  }\n+\n+  private ValueVector getVector(int index) {\n+    int type = typeBuffer.getByte(index * TYPE_WIDTH);\n+    if (type < Types.MinorType.values().length) {\n+      switch (MinorType.values()[type]) {\n+        case NULL:\n+          return null;\n+      <#list vv.types as type>\n+        <#list type.minor as minor>\n+          <#assign name = minor.class?cap_first />\n+          <#assign fields = minor.fields !type.fields />\n+          <#assign uncappedName = name?uncap_first />\n+          <#if !minor.typeParams ??>\n+        case ${name?upper_case}:\n+        return get${name}Vector();\n+          </#if>\n+        </#list>\n+      </#list>\n+        default:\n+          throw new UnsupportedOperationException(\"Cannot support type: \" + MinorType.values()[type]);\n+      }\n+    } else {\n+      if (typeFields[type].getType() instanceof Struct) {\n+        return getStruct(type);\n+      } else if (typeFields[type].getType() instanceof List) {\n+        return getList(type);\n+      } else {\n+        throw new UnsupportedOperationException(\"Cannot support type: \" + type);\n+      }\n+    }\n+  }\n+\n+  public Object getObject(int index) {\n+    ValueVector vector = getVector(index);\n+    if (vector != null) {\n+      int offset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+      return vector.getObject(offset);\n+    }\n+    return null;\n+  }\n+\n+  public void get(int index, DenseUnionHolder holder) {\n+    FieldReader reader = new DenseUnionReader(DenseUnionVector.this);\n+    int offset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    reader.setPosition(offset);\n+    holder.reader = reader;\n+  }\n+\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  public boolean isNull(int index) {\n+    return (typeBuffer.getByte(index * TYPE_WIDTH) == 0);\n+  }\n+\n+  @Override\n+  public int getNullCount() {\n+    int nullCount = 0;\n+    for (int i = 0; i < getValueCount(); i++) {\n+      if (isNull(i)) {\n+        nullCount++;\n+      }\n+    }\n+    return nullCount;\n+  }\n+\n+  public int isSet(int index) {\n+    return isNull(index) ? 0 : 1;\n+  }\n+\n+  DenseUnionWriter writer;\n+\n+  public void setValueCount(int valueCount) {\n+    this.valueCount = valueCount;\n+    while (valueCount > getTypeBufferValueCapacity()) {\n+      reallocTypeBuffer();\n+      reallocOffsetBuffer();\n+    }\n+    internalStruct.setValueCount(valueCount);\n+  }\n+\n+  public void setSafe(int index, DenseUnionHolder holder) {\n+    FieldReader reader = holder.reader;\n+    if (writer == null) {\n+      writer = new DenseUnionWriter(DenseUnionVector.this);\n+    }\n+    int offset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    writer.setPosition(offset);\n+    MinorType type = reader.getMinorType();\n+    switch (type) {\n+      <#list vv.types as type>\n+        <#list type.minor as minor>\n+          <#assign name = minor.class?cap_first />\n+          <#assign fields = minor.fields!type.fields />\n+          <#assign uncappedName = name?uncap_first/>\n+          <#if !minor.typeParams?? >\n+      case ${name?upper_case}:\n+      Nullable${name}Holder ${uncappedName}Holder = new Nullable${name}Holder();\n+      reader.read(${uncappedName}Holder);\n+      setSafe(index, ${uncappedName}Holder);\n+      break;\n+          </#if>\n+        </#list>\n+      </#list>\n+      case STRUCT: {\n+        ComplexCopier.copy(reader, writer);\n+        break;\n+      }\n+      case LIST: {\n+        ComplexCopier.copy(reader, writer);\n+        break;\n+      }\n+      default:\n+        throw new UnsupportedOperationException();\n+    }\n+  }\n+    <#list vv.types as type>\n+      <#list type.minor as minor>\n+        <#assign name = minor.class?cap_first />\n+        <#assign fields = minor.fields!type.fields />\n+        <#assign uncappedName = name?uncap_first/>\n+        <#if !minor.typeParams?? >\n+  public void setSafe(int index, Nullable${name}Holder holder) {\n+    setType(index, MinorType.${name?upper_case});\n+    while (index >= getOffsetBufferValueCapacity()) {\n+      reallocOffsetBuffer();\n+    }\n+    ${name}Vector vector = get${name}Vector();\n+    int offset = vector.getValueCount();\n+    vector.setValueCount(offset + 1);\n+    vector.setSafe(offset, holder);\n+    offsetBuffer.setInt(index * OFFSET_WIDTH, offset);\n+  }\n+\n+        </#if>\n+      </#list>\n+    </#list>\n+\n+  public void setType(int index, int typeId) {\n \n Review comment:\n   typeIds should probably be \"byte\" everywhere.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-10T09:11:28.278+0000",
                    "updated": "2020-01-10T09:11:28.278+0000",
                    "started": "2020-01-10T09:11:28.277+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "369736",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/369738",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r365134970\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionVector.java\n ##########\n @@ -0,0 +1,887 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.ReferenceManager;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.UnionMode;\n+import org.apache.arrow.vector.compare.RangeEqualsVisitor;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/DenseUnionVector.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+        import io.netty.buffer.ArrowBuf;\n+        import java.util.ArrayList;\n+        import java.util.Collections;\n+        import java.util.Iterator;\n+        import org.apache.arrow.vector.compare.VectorVisitor;\n+        import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+        import org.apache.arrow.vector.util.CallBack;\n+        import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+        import org.apache.arrow.memory.BaseAllocator;\n+        import org.apache.arrow.vector.BaseValueVector;\n+        import org.apache.arrow.vector.util.OversizedAllocationException;\n+        import org.apache.arrow.util.Preconditions;\n+\n+        import static org.apache.arrow.vector.types.UnionMode.Dense;\n+\n+\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+@SuppressWarnings(\"unused\")\n+\n+\n+/**\n+ * A vector which can hold values of different types. It does so by using a StructVector which contains a vector for each\n+ * primitive type that is stored. StructVector is used in order to take advantage of its serialization/deserialization methods,\n+ * as well as the addOrGet method.\n+ *\n+ * For performance reasons, DenseUnionVector stores a cached reference to each subtype vector, to avoid having to do the struct lookup\n+ * each time the vector is accessed.\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+public class DenseUnionVector implements FieldVector {\n+\n+  private String name;\n+  private BufferAllocator allocator;\n+  int valueCount;\n+\n+  NonNullableStructVector internalStruct;\n+  private ArrowBuf typeBuffer;\n+  private ArrowBuf offsetBuffer;\n+\n+  /**\n+   * The key is type Id, and the value is vector.\n+   */\n+  private java.util.Map<Integer, StructVector> structVectors = new java.util.HashMap<>();\n+  private java.util.Map<Integer, ListVector> listVectors = new java.util.HashMap<>();\n+\n+  /**\n+   * The index is the type id, and the value is the type field.\n+   */\n+  private Field[] typeFields = new Field[Byte.MAX_VALUE + 1];\n+\n+  /**\n+   * The next typd id to allocate.\n+   */\n+  private int nextTypeId = Types.MinorType.values().length;\n+\n+  private FieldReader reader;\n+\n+  private int singleType = 0;\n+  private ValueVector singleVector;\n+\n+  private final CallBack callBack;\n+  private int typeBufferAllocationSizeInBytes;\n+  private int offsetBufferAllocationSizeInBytes;\n+\n+  private final FieldType fieldType;\n+\n+  private static final byte TYPE_WIDTH = 1;\n+  public static final byte OFFSET_WIDTH = 4;\n+\n+  private static final FieldType INTERNAL_STRUCT_TYPE = new FieldType(false /*nullable*/,\n+          ArrowType.Struct.INSTANCE, null /*dictionary*/, null /*metadata*/);\n+\n+  public static DenseUnionVector empty(String name, BufferAllocator allocator) {\n+    FieldType fieldType = FieldType.nullable(new ArrowType.Union(\n+            UnionMode.Dense, null));\n+    return new DenseUnionVector(name, allocator, fieldType, null);\n+  }\n+\n+  public DenseUnionVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    this.name = name;\n+    this.allocator = allocator;\n+    this.fieldType = fieldType;\n+    this.internalStruct = new NonNullableStructVector(\"internal\", allocator, INTERNAL_STRUCT_TYPE,\n+            callBack);\n+    this.typeBuffer = allocator.getEmpty();\n+    this.callBack = callBack;\n+    this.typeBufferAllocationSizeInBytes = BaseValueVector.INITIAL_VALUE_ALLOCATION * TYPE_WIDTH;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.offsetBufferAllocationSizeInBytes = BaseValueVector.INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  }\n+\n+  public BufferAllocator getAllocator() {\n+    return allocator;\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.UNION;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    internalStruct.initializeChildrenFromFields(children);\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return internalStruct.getChildrenFromFields();\n+  }\n+\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf buffer = ownBuffers.get(0);\n+    typeBuffer.getReferenceManager().release();\n+    typeBuffer = buffer.getReferenceManager().retain(buffer, allocator);\n+    typeBufferAllocationSizeInBytes = typeBuffer.capacity();\n+\n+    buffer = ownBuffers.get(1);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = buffer.getReferenceManager().retain(buffer, allocator);\n+    offsetBufferAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    this.valueCount = fieldNode.getLength();\n+  }\n+\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+    setReaderAndWriterIndex();\n+    result.add(typeBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  private void setReaderAndWriterIndex() {\n+    typeBuffer.readerIndex(0);\n+    typeBuffer.writerIndex(valueCount * TYPE_WIDTH);\n+\n+    offsetBuffer.readerIndex(0);\n+    offsetBuffer.writerIndex(valueCount * OFFSET_WIDTH);\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use geFieldBuffers\");\n+  }\n+\n+  private String fieldName(MinorType type) {\n+    return type.name().toLowerCase();\n+  }\n+\n+  private String fieldName(int typeId, MinorType type) {\n+    return type.name().toLowerCase() + typeId;\n+  }\n+\n+  private FieldType fieldType(MinorType type) {\n+    return FieldType.nullable(type.getType());\n+  }\n+\n+  private synchronized int registerNewTypeId(Field field) {\n+    if (nextTypeId == typeFields.length) {\n+      throw new IllegalStateException(\"Dense union vector support at most \" +\n+              typeFields.length + \" relative types. Please use union of union instead\");\n+    }\n+    int typeId = nextTypeId;\n+    typeFields[typeId] = field;\n+    this.nextTypeId += 1;\n+    return typeId;\n+  }\n+\n+  /**\n+   * Try to get the type id of the given field.\n+   * If the field is not used before, a new type id will be allocated.\n+   * @param field the field for which to get type id.\n+   * @return the typd id for the field.\n+   */\n+  public int getOrAllocateTypeId(Field field) {\n+    ArrowType fieldType = field.getFieldType().getType();\n+    if (fieldType instanceof Struct || fieldType instanceof  List) {\n+      // TODO: make this process faster\n+\n+      // search for a matching registered type id\n+      for (int i = Types.MinorType.values().length; i < nextTypeId; i++) {\n+        if (typeFields[i].relativeTypeEquals(field)) {\n+          return i;\n+        }\n+      }\n+\n+      // not registered yet, allocate a new type id\n+      return registerNewTypeId(field);\n+    } else {\n+      // for built-in types\n+      return Types.getMinorTypeForArrowType(field.getFieldType().getType()).ordinal();\n+    }\n+  }\n+\n+  private <T extends FieldVector> T addOrGet(MinorType minorType, Class<T> c) {\n+    return internalStruct.addOrGet(fieldName(minorType), fieldType(minorType), c);\n+  }\n+\n+  private <T extends FieldVector> T addOrGet(int typeId, MinorType minorType, Class<T> c) {\n+    return internalStruct.addOrGet(fieldName(typeId, minorType), fieldType(minorType), c);\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return typeBuffer.memoryAddress();\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() { return typeBuffer; }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() { return offsetBuffer; }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() { throw new UnsupportedOperationException(); }\n+\n+  public StructVector getStruct(int typeId) {\n+    StructVector structVector = structVectors.get(typeId);\n+    if (structVector == null) {\n+      int vectorCount = internalStruct.size();\n+      structVector = addOrGet(typeId, MinorType.STRUCT, StructVector.class);\n+      if (internalStruct.size() > vectorCount) {\n+        structVector.allocateNew();\n+        structVectors.put(typeId, structVector);\n+        if (callBack != null) {\n+          callBack.doWork();\n+        }\n+      }\n+    }\n+    return structVector;\n+  }\n+\n+  <#list vv.types as type>\n+    <#list type.minor as minor>\n+      <#assign name = minor.class?cap_first />\n+      <#assign fields = minor.fields!type.fields />\n+      <#assign uncappedName = name?uncap_first/>\n+      <#assign lowerCaseName = name?lower_case/>\n+      <#if !minor.typeParams?? >\n+\n+  private ${name}Vector ${uncappedName}Vector;\n+\n+  public ${name}Vector get${name}Vector() {\n+    if (${uncappedName}Vector == null) {\n+      int vectorCount = internalStruct.size();\n+      ${uncappedName}Vector = addOrGet(MinorType.${name?upper_case}, ${name}Vector.class);\n+      if (internalStruct.size() > vectorCount) {\n+        ${uncappedName}Vector.allocateNew();\n+        if (callBack != null) {\n+          callBack.doWork();\n+        }\n+      }\n+    }\n+    return ${uncappedName}Vector;\n+  }\n+      </#if>\n+    </#list>\n+  </#list>\n+\n+  public ListVector getList(int typeId) {\n+    ListVector listVector = listVectors.get(typeId);\n+    if (listVector == null) {\n+      int vectorCount = internalStruct.size();\n+      listVector = addOrGet(typeId, MinorType.LIST, ListVector.class);\n+      if (internalStruct.size() > vectorCount) {\n+        listVector.allocateNew();\n+        listVectors.put(typeId, listVector);\n+        if (callBack != null) {\n+          callBack.doWork();\n+        }\n+      }\n+    }\n+    return listVector;\n+  }\n+\n+  public int getTypeValue(int index) {\n+    return typeBuffer.getByte(index * TYPE_WIDTH);\n+  }\n+\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    /* new allocation -- clear the current buffers */\n+    clear();\n+    internalStruct.allocateNew();\n+    try {\n+      allocateTypeBuffer();\n+      allocateOffsetBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public boolean allocateNewSafe() {\n+    /* new allocation -- clear the current buffers */\n+    clear();\n+    boolean safe = internalStruct.allocateNewSafe();\n+    if (!safe) { return false; }\n+    try {\n+      allocateTypeBuffer();\n+      allocateOffsetBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      return  false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private void allocateTypeBuffer() {\n+    typeBuffer = allocator.buffer(typeBufferAllocationSizeInBytes);\n+    typeBuffer.readerIndex(0);\n+    typeBuffer.setZero(0, typeBuffer.capacity());\n+  }\n+\n+  private void allocateOffsetBuffer() {\n+    offsetBuffer = allocator.buffer(offsetBufferAllocationSizeInBytes);\n+    offsetBuffer.readerIndex(0);\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  @Override\n+  public void reAlloc() {\n+    internalStruct.reAlloc();\n+    reallocTypeBuffer();\n+    reallocOffsetBuffer();\n+  }\n+\n+  private void reallocTypeBuffer() {\n+    final int currentBufferCapacity = typeBuffer.capacity();\n+    long baseSize  = typeBufferAllocationSizeInBytes;\n+\n+    if (baseSize < (long)currentBufferCapacity) {\n+      baseSize = (long)currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n+    newBuf.setBytes(0, typeBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    typeBuffer.getReferenceManager().release(1);\n+    typeBuffer = newBuf;\n+    typeBufferAllocationSizeInBytes = (int)newAllocationSize;\n+  }\n+\n+  private void reallocOffsetBuffer() {\n+    final int currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize  = offsetBufferAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetBufferAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) { }\n+\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(Math.min(getTypeBufferValueCapacity(), getOffsetBufferValueCapacity()),\n+            internalStruct.getValueCapacity());\n+  }\n+\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    valueCount = 0;\n+    typeBuffer.getReferenceManager().release();\n+    typeBuffer = allocator.getEmpty();\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = allocator.getEmpty();\n+    internalStruct.clear();\n+  }\n+\n+  @Override\n+  public void reset() {\n+    valueCount = 0;\n+    typeBuffer.setZero(0, typeBuffer.capacity());\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    internalStruct.reset();\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    List<org.apache.arrow.vector.types.pojo.Field> childFields = new ArrayList<>();\n+    List<FieldVector> children = internalStruct.getChildren();\n+    int[] typeIds = new int[children.size()];\n+    for (ValueVector v : children) {\n+      typeIds[childFields.size()] = v.getMinorType().ordinal();\n+      childFields.add(v.getField());\n+    }\n+\n+    FieldType fieldType;\n+    if (this.fieldType == null) {\n+      fieldType = FieldType.nullable(new ArrowType.Union(Dense, typeIds));\n+    } else {\n+      final UnionMode mode = ((ArrowType.Union)this.fieldType.getType()).getMode();\n+      fieldType = new FieldType(this.fieldType.isNullable(), new ArrowType.Union(mode, typeIds),\n+              this.fieldType.getDictionary(), this.fieldType.getMetadata());\n+    }\n+\n+    return new Field(name, fieldType, childFields);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(name, allocator);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new org.apache.arrow.vector.complex.DenseUnionVector.TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((DenseUnionVector) target);\n+  }\n+\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    DenseUnionVector fromCast = (DenseUnionVector) from;\n+    int inOffset = fromCast.offsetBuffer.getInt(inIndex * OFFSET_WIDTH);\n+    fromCast.getReader().setPosition(inOffset);\n+    int outOffset = offsetBuffer.getInt(outIndex * OFFSET_WIDTH);\n+    getWriter().setPosition(outOffset);\n+    ComplexCopier.copy(fromCast.reader, writer);\n+  }\n+\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  public FieldVector addVector(FieldVector v) {\n+    int typeId = getOrAllocateTypeId(v.getField());\n+    String name = typeId < Types.MinorType.values().length ? fieldName(v.getMinorType()) :\n+            fieldName(typeId, v.getMinorType());\n+    Preconditions.checkState(internalStruct.getChild(name) == null, String.format(\"%s vector already exists\", name));\n+    final FieldVector newVector = internalStruct.addOrGet(name, v.getField().getFieldType(), v.getClass());\n+    v.makeTransferPair(newVector).transfer();\n+    internalStruct.putChild(name, newVector);\n+    if (newVector instanceof StructVector) {\n+      structVectors.put(typeId, (StructVector) newVector);\n+    } else if (newVector instanceof ListVector) {\n+      listVectors.put(typeId, (ListVector) newVector);\n+    }\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return newVector;\n+  }\n+\n+  /**\n+   * Directly put a vector to internalStruct without creating a new one with same type.\n+   */\n+  public void directAddVector(FieldVector v) {\n+    String name = v.getMinorType().name().toLowerCase();\n+    Preconditions.checkState(internalStruct.getChild(name) == null, String.format(\"%s vector already exists\", name));\n+    internalStruct.putChild(name, v);\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    private final TransferPair[] internalTransferPairs = new TransferPair[Types.MinorType.values().length];\n+    private final DenseUnionVector to;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      to = new DenseUnionVector(name, allocator, null, callBack);\n+      internalStruct.makeTransferPair(to.internalStruct);\n+      createTransferPairs();\n+    }\n+\n+    public TransferImpl(DenseUnionVector to) {\n+      this.to = to;\n+      internalStruct.makeTransferPair(to.internalStruct);\n+      createTransferPairs();\n+    }\n+\n+    private void createTransferPairs() {\n+      for (int i = 0; i < internalStruct.getField().getChildren().size(); i++) {\n+        ValueVector srcVec = internalStruct.getVectorById(i);\n+        ValueVector dstVec = to.internalStruct.getVectorById(i);\n+        internalTransferPairs[srcVec.getMinorType().ordinal()] = srcVec.makeTransferPair(dstVec);\n+      }\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      final ReferenceManager refManager = typeBuffer.getReferenceManager();\n+      to.typeBuffer = refManager.transferOwnership(typeBuffer, to.allocator).getTransferredBuffer();\n+      to.offsetBuffer = refManager.transferOwnership(offsetBuffer, to.allocator).getTransferredBuffer();\n+      for (int i = 0; i < MinorType.values().length; i++) {\n+        if (internalTransferPairs[i] != null) {\n+          internalTransferPairs[i].transfer();\n+        }\n+      }\n+      to.valueCount = valueCount;\n+      clear();\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      to.clear();\n+      int startPoint = startIndex * TYPE_WIDTH;\n+      int sliceLength = length * TYPE_WIDTH;\n+      ArrowBuf slicedBuffer = typeBuffer.slice(startPoint, sliceLength);\n+      ReferenceManager refManager = slicedBuffer.getReferenceManager();\n+      to.typeBuffer = refManager.transferOwnership(slicedBuffer, to.allocator).getTransferredBuffer();\n+\n+      while (to.offsetBuffer.capacity() < length * OFFSET_WIDTH) {\n+        to.reallocOffsetBuffer();\n+      }\n+\n+      int [] typeCounts = new int[MinorType.values().length];\n+      int [] typeStarts = new int[Types.MinorType.values().length];\n+      for (int i = 0; i < typeCounts.length; i++) {\n+        typeCounts[i] = 0;\n+        typeStarts[i] = -1;\n+      }\n+\n+      for (int i = startIndex; i < startIndex + length; i++) {\n+        int ord = typeBuffer.getByte(i);\n+        to.offsetBuffer.setInt((i - startIndex) * OFFSET_WIDTH, typeCounts[ord]);\n+        typeCounts[ord] += 1;\n+        if (typeStarts[ord] == -1) {\n+          typeStarts[ord] = offsetBuffer.getInt(i * OFFSET_WIDTH);\n+        }\n+      }\n+      to.setValueCount(length);\n+\n+      // transfer vector values\n+      for (int i = 0; i < MinorType.values().length; i++) {\n+        if (typeCounts[i] > 0 && typeStarts[i] != -1) {\n+          internalTransferPairs[i].splitAndTransfer(typeStarts[i], typeCounts[i]);\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, DenseUnionVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public FieldReader getReader() {\n+    if (reader == null) {\n+      reader = new DenseUnionReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  public FieldWriter getWriter() {\n+    if (writer == null) {\n+      writer = new DenseUnionWriter(this);\n+    }\n+    return writer;\n+  }\n+\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) { return 0; }\n+\n+    return valueCount * TYPE_WIDTH + valueCount * OFFSET_WIDTH + internalStruct.getBufferSize();\n+  }\n+\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    long bufferSize = 0;\n+    for (final ValueVector v : (Iterable<ValueVector>) this) {\n+      bufferSize += v.getBufferSizeFor(valueCount);\n+    }\n+\n+    return (int) bufferSize + valueCount * TYPE_WIDTH + valueCount * OFFSET_WIDTH;\n+  }\n+\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    List<ArrowBuf> list = new java.util.ArrayList<>();\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() != 0) {\n+      list.add(typeBuffer);\n+      list.add(offsetBuffer);\n+      list.addAll(java.util.Arrays.asList(internalStruct.getBuffers(clear)));\n+    }\n+    if (clear) {\n+      valueCount = 0;\n+      typeBuffer.getReferenceManager().retain();\n+      typeBuffer.close();\n+      typeBuffer = allocator.getEmpty();\n+      offsetBuffer.getReferenceManager().retain();\n+      offsetBuffer.close();\n+      offsetBuffer = allocator.getEmpty();\n+    }\n+    return list.toArray(new ArrowBuf[list.size()]);\n+  }\n+\n+  @Override\n+  public Iterator<ValueVector> iterator() {\n+    List<ValueVector> vectors = org.apache.arrow.util.Collections2.toList(internalStruct.iterator());\n+    return vectors.iterator();\n+  }\n+\n+  private ValueVector getVector(int index) {\n+    int type = typeBuffer.getByte(index * TYPE_WIDTH);\n+    if (type < Types.MinorType.values().length) {\n+      switch (MinorType.values()[type]) {\n+        case NULL:\n+          return null;\n+      <#list vv.types as type>\n+        <#list type.minor as minor>\n+          <#assign name = minor.class?cap_first />\n+          <#assign fields = minor.fields !type.fields />\n+          <#assign uncappedName = name?uncap_first />\n+          <#if !minor.typeParams ??>\n+        case ${name?upper_case}:\n+        return get${name}Vector();\n+          </#if>\n+        </#list>\n+      </#list>\n+        default:\n+          throw new UnsupportedOperationException(\"Cannot support type: \" + MinorType.values()[type]);\n+      }\n+    } else {\n+      if (typeFields[type].getType() instanceof Struct) {\n+        return getStruct(type);\n+      } else if (typeFields[type].getType() instanceof List) {\n+        return getList(type);\n+      } else {\n+        throw new UnsupportedOperationException(\"Cannot support type: \" + type);\n+      }\n+    }\n+  }\n+\n+  public Object getObject(int index) {\n+    ValueVector vector = getVector(index);\n+    if (vector != null) {\n+      int offset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+      return vector.getObject(offset);\n+    }\n+    return null;\n+  }\n+\n+  public void get(int index, DenseUnionHolder holder) {\n+    FieldReader reader = new DenseUnionReader(DenseUnionVector.this);\n+    int offset = offsetBuffer.getInt(index * OFFSET_WIDTH);\n+    reader.setPosition(offset);\n+    holder.reader = reader;\n+  }\n+\n+  public int getValueCount() {\n+    return valueCount;\n+  }\n+\n+  public boolean isNull(int index) {\n+    return (typeBuffer.getByte(index * TYPE_WIDTH) == 0);\n \n Review comment:\n   there should be a separate validity buffer or there needs to be a more discussion the mailing list.  As the spec is currently written this doesn't conform.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-10T09:13:05.857+0000",
                    "updated": "2020-01-10T09:13:05.857+0000",
                    "started": "2020-01-10T09:13:05.856+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "369738",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/369739",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on pull request #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#discussion_r365136234\n \n \n\n ##########\n File path: java/vector/src/main/codegen/templates/DenseUnionVector.java\n ##########\n @@ -0,0 +1,887 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import io.netty.buffer.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.memory.ReferenceManager;\n+import org.apache.arrow.util.Preconditions;\n+import org.apache.arrow.vector.BaseValueVector;\n+import org.apache.arrow.vector.FieldVector;\n+import org.apache.arrow.vector.ValueVector;\n+import org.apache.arrow.vector.complex.ListVector;\n+import org.apache.arrow.vector.complex.StructVector;\n+import org.apache.arrow.vector.compare.VectorVisitor;\n+import org.apache.arrow.vector.types.Types;\n+import org.apache.arrow.vector.types.UnionMode;\n+import org.apache.arrow.vector.compare.RangeEqualsVisitor;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.util.CallBack;\n+import org.apache.arrow.vector.util.TransferPair;\n+\n+<@pp.dropOutputFile />\n+<@pp.changeOutputFile name=\"/org/apache/arrow/vector/complex/DenseUnionVector.java\" />\n+\n+\n+<#include \"/@includes/license.ftl\" />\n+\n+        package org.apache.arrow.vector.complex;\n+\n+<#include \"/@includes/vv_imports.ftl\" />\n+        import io.netty.buffer.ArrowBuf;\n+        import java.util.ArrayList;\n+        import java.util.Collections;\n+        import java.util.Iterator;\n+        import org.apache.arrow.vector.compare.VectorVisitor;\n+        import org.apache.arrow.vector.complex.impl.ComplexCopier;\n+        import org.apache.arrow.vector.util.CallBack;\n+        import org.apache.arrow.vector.ipc.message.ArrowFieldNode;\n+        import org.apache.arrow.memory.BaseAllocator;\n+        import org.apache.arrow.vector.BaseValueVector;\n+        import org.apache.arrow.vector.util.OversizedAllocationException;\n+        import org.apache.arrow.util.Preconditions;\n+\n+        import static org.apache.arrow.vector.types.UnionMode.Dense;\n+\n+\n+\n+/*\n+ * This class is generated using freemarker and the ${.template_name} template.\n+ */\n+@SuppressWarnings(\"unused\")\n+\n+\n+/**\n+ * A vector which can hold values of different types. It does so by using a StructVector which contains a vector for each\n+ * primitive type that is stored. StructVector is used in order to take advantage of its serialization/deserialization methods,\n+ * as well as the addOrGet method.\n+ *\n+ * For performance reasons, DenseUnionVector stores a cached reference to each subtype vector, to avoid having to do the struct lookup\n+ * each time the vector is accessed.\n+ * Source code generated using FreeMarker template ${.template_name}\n+ */\n+public class DenseUnionVector implements FieldVector {\n+\n+  private String name;\n+  private BufferAllocator allocator;\n+  int valueCount;\n+\n+  NonNullableStructVector internalStruct;\n+  private ArrowBuf typeBuffer;\n+  private ArrowBuf offsetBuffer;\n+\n+  /**\n+   * The key is type Id, and the value is vector.\n+   */\n+  private java.util.Map<Integer, StructVector> structVectors = new java.util.HashMap<>();\n+  private java.util.Map<Integer, ListVector> listVectors = new java.util.HashMap<>();\n+\n+  /**\n+   * The index is the type id, and the value is the type field.\n+   */\n+  private Field[] typeFields = new Field[Byte.MAX_VALUE + 1];\n+\n+  /**\n+   * The next typd id to allocate.\n+   */\n+  private int nextTypeId = Types.MinorType.values().length;\n+\n+  private FieldReader reader;\n+\n+  private int singleType = 0;\n+  private ValueVector singleVector;\n+\n+  private final CallBack callBack;\n+  private int typeBufferAllocationSizeInBytes;\n+  private int offsetBufferAllocationSizeInBytes;\n+\n+  private final FieldType fieldType;\n+\n+  private static final byte TYPE_WIDTH = 1;\n+  public static final byte OFFSET_WIDTH = 4;\n+\n+  private static final FieldType INTERNAL_STRUCT_TYPE = new FieldType(false /*nullable*/,\n+          ArrowType.Struct.INSTANCE, null /*dictionary*/, null /*metadata*/);\n+\n+  public static DenseUnionVector empty(String name, BufferAllocator allocator) {\n+    FieldType fieldType = FieldType.nullable(new ArrowType.Union(\n+            UnionMode.Dense, null));\n+    return new DenseUnionVector(name, allocator, fieldType, null);\n+  }\n+\n+  public DenseUnionVector(String name, BufferAllocator allocator, FieldType fieldType, CallBack callBack) {\n+    this.name = name;\n+    this.allocator = allocator;\n+    this.fieldType = fieldType;\n+    this.internalStruct = new NonNullableStructVector(\"internal\", allocator, INTERNAL_STRUCT_TYPE,\n+            callBack);\n+    this.typeBuffer = allocator.getEmpty();\n+    this.callBack = callBack;\n+    this.typeBufferAllocationSizeInBytes = BaseValueVector.INITIAL_VALUE_ALLOCATION * TYPE_WIDTH;\n+    this.offsetBuffer = allocator.getEmpty();\n+    this.offsetBufferAllocationSizeInBytes = BaseValueVector.INITIAL_VALUE_ALLOCATION * OFFSET_WIDTH;\n+  }\n+\n+  public BufferAllocator getAllocator() {\n+    return allocator;\n+  }\n+\n+  @Override\n+  public MinorType getMinorType() {\n+    return MinorType.UNION;\n+  }\n+\n+  @Override\n+  public void initializeChildrenFromFields(List<Field> children) {\n+    internalStruct.initializeChildrenFromFields(children);\n+  }\n+\n+  @Override\n+  public List<FieldVector> getChildrenFromFields() {\n+    return internalStruct.getChildrenFromFields();\n+  }\n+\n+  @Override\n+  public void loadFieldBuffers(ArrowFieldNode fieldNode, List<ArrowBuf> ownBuffers) {\n+    if (ownBuffers.size() != 2) {\n+      throw new IllegalArgumentException(\"Illegal buffer count, expected \" + 2 + \", got: \" + ownBuffers.size());\n+    }\n+\n+    ArrowBuf buffer = ownBuffers.get(0);\n+    typeBuffer.getReferenceManager().release();\n+    typeBuffer = buffer.getReferenceManager().retain(buffer, allocator);\n+    typeBufferAllocationSizeInBytes = typeBuffer.capacity();\n+\n+    buffer = ownBuffers.get(1);\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = buffer.getReferenceManager().retain(buffer, allocator);\n+    offsetBufferAllocationSizeInBytes = offsetBuffer.capacity();\n+\n+    this.valueCount = fieldNode.getLength();\n+  }\n+\n+  @Override\n+  public List<ArrowBuf> getFieldBuffers() {\n+    List<ArrowBuf> result = new ArrayList<>(1);\n+    setReaderAndWriterIndex();\n+    result.add(typeBuffer);\n+    result.add(offsetBuffer);\n+\n+    return result;\n+  }\n+\n+  private void setReaderAndWriterIndex() {\n+    typeBuffer.readerIndex(0);\n+    typeBuffer.writerIndex(valueCount * TYPE_WIDTH);\n+\n+    offsetBuffer.readerIndex(0);\n+    offsetBuffer.writerIndex(valueCount * OFFSET_WIDTH);\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public List<BufferBacked> getFieldInnerVectors() {\n+    throw new UnsupportedOperationException(\"There are no inner vectors. Use geFieldBuffers\");\n+  }\n+\n+  private String fieldName(MinorType type) {\n+    return type.name().toLowerCase();\n+  }\n+\n+  private String fieldName(int typeId, MinorType type) {\n+    return type.name().toLowerCase() + typeId;\n+  }\n+\n+  private FieldType fieldType(MinorType type) {\n+    return FieldType.nullable(type.getType());\n+  }\n+\n+  private synchronized int registerNewTypeId(Field field) {\n+    if (nextTypeId == typeFields.length) {\n+      throw new IllegalStateException(\"Dense union vector support at most \" +\n+              typeFields.length + \" relative types. Please use union of union instead\");\n+    }\n+    int typeId = nextTypeId;\n+    typeFields[typeId] = field;\n+    this.nextTypeId += 1;\n+    return typeId;\n+  }\n+\n+  /**\n+   * Try to get the type id of the given field.\n+   * If the field is not used before, a new type id will be allocated.\n+   * @param field the field for which to get type id.\n+   * @return the typd id for the field.\n+   */\n+  public int getOrAllocateTypeId(Field field) {\n+    ArrowType fieldType = field.getFieldType().getType();\n+    if (fieldType instanceof Struct || fieldType instanceof  List) {\n+      // TODO: make this process faster\n+\n+      // search for a matching registered type id\n+      for (int i = Types.MinorType.values().length; i < nextTypeId; i++) {\n+        if (typeFields[i].relativeTypeEquals(field)) {\n+          return i;\n+        }\n+      }\n+\n+      // not registered yet, allocate a new type id\n+      return registerNewTypeId(field);\n+    } else {\n+      // for built-in types\n+      return Types.getMinorTypeForArrowType(field.getFieldType().getType()).ordinal();\n+    }\n+  }\n+\n+  private <T extends FieldVector> T addOrGet(MinorType minorType, Class<T> c) {\n+    return internalStruct.addOrGet(fieldName(minorType), fieldType(minorType), c);\n+  }\n+\n+  private <T extends FieldVector> T addOrGet(int typeId, MinorType minorType, Class<T> c) {\n+    return internalStruct.addOrGet(fieldName(typeId, minorType), fieldType(minorType), c);\n+  }\n+\n+  @Override\n+  public long getOffsetBufferAddress() {\n+    return offsetBuffer.memoryAddress();\n+  }\n+\n+  @Override\n+  public long getDataBufferAddress() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public long getValidityBufferAddress() {\n+    return typeBuffer.memoryAddress();\n+  }\n+\n+  @Override\n+  public ArrowBuf getValidityBuffer() { return typeBuffer; }\n+\n+  @Override\n+  public ArrowBuf getOffsetBuffer() { return offsetBuffer; }\n+\n+  @Override\n+  public ArrowBuf getDataBuffer() { throw new UnsupportedOperationException(); }\n+\n+  public StructVector getStruct(int typeId) {\n+    StructVector structVector = structVectors.get(typeId);\n+    if (structVector == null) {\n+      int vectorCount = internalStruct.size();\n+      structVector = addOrGet(typeId, MinorType.STRUCT, StructVector.class);\n+      if (internalStruct.size() > vectorCount) {\n+        structVector.allocateNew();\n+        structVectors.put(typeId, structVector);\n+        if (callBack != null) {\n+          callBack.doWork();\n+        }\n+      }\n+    }\n+    return structVector;\n+  }\n+\n+  <#list vv.types as type>\n+    <#list type.minor as minor>\n+      <#assign name = minor.class?cap_first />\n+      <#assign fields = minor.fields!type.fields />\n+      <#assign uncappedName = name?uncap_first/>\n+      <#assign lowerCaseName = name?lower_case/>\n+      <#if !minor.typeParams?? >\n+\n+  private ${name}Vector ${uncappedName}Vector;\n+\n+  public ${name}Vector get${name}Vector() {\n+    if (${uncappedName}Vector == null) {\n+      int vectorCount = internalStruct.size();\n+      ${uncappedName}Vector = addOrGet(MinorType.${name?upper_case}, ${name}Vector.class);\n+      if (internalStruct.size() > vectorCount) {\n+        ${uncappedName}Vector.allocateNew();\n+        if (callBack != null) {\n+          callBack.doWork();\n+        }\n+      }\n+    }\n+    return ${uncappedName}Vector;\n+  }\n+      </#if>\n+    </#list>\n+  </#list>\n+\n+  public ListVector getList(int typeId) {\n+    ListVector listVector = listVectors.get(typeId);\n+    if (listVector == null) {\n+      int vectorCount = internalStruct.size();\n+      listVector = addOrGet(typeId, MinorType.LIST, ListVector.class);\n+      if (internalStruct.size() > vectorCount) {\n+        listVector.allocateNew();\n+        listVectors.put(typeId, listVector);\n+        if (callBack != null) {\n+          callBack.doWork();\n+        }\n+      }\n+    }\n+    return listVector;\n+  }\n+\n+  public int getTypeValue(int index) {\n+    return typeBuffer.getByte(index * TYPE_WIDTH);\n+  }\n+\n+  @Override\n+  public void allocateNew() throws OutOfMemoryException {\n+    /* new allocation -- clear the current buffers */\n+    clear();\n+    internalStruct.allocateNew();\n+    try {\n+      allocateTypeBuffer();\n+      allocateOffsetBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public boolean allocateNewSafe() {\n+    /* new allocation -- clear the current buffers */\n+    clear();\n+    boolean safe = internalStruct.allocateNewSafe();\n+    if (!safe) { return false; }\n+    try {\n+      allocateTypeBuffer();\n+      allocateOffsetBuffer();\n+    } catch (Exception e) {\n+      clear();\n+      return  false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private void allocateTypeBuffer() {\n+    typeBuffer = allocator.buffer(typeBufferAllocationSizeInBytes);\n+    typeBuffer.readerIndex(0);\n+    typeBuffer.setZero(0, typeBuffer.capacity());\n+  }\n+\n+  private void allocateOffsetBuffer() {\n+    offsetBuffer = allocator.buffer(offsetBufferAllocationSizeInBytes);\n+    offsetBuffer.readerIndex(0);\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+  }\n+\n+  @Override\n+  public void reAlloc() {\n+    internalStruct.reAlloc();\n+    reallocTypeBuffer();\n+    reallocOffsetBuffer();\n+  }\n+\n+  private void reallocTypeBuffer() {\n+    final int currentBufferCapacity = typeBuffer.capacity();\n+    long baseSize  = typeBufferAllocationSizeInBytes;\n+\n+    if (baseSize < (long)currentBufferCapacity) {\n+      baseSize = (long)currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int)newAllocationSize);\n+    newBuf.setBytes(0, typeBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    typeBuffer.getReferenceManager().release(1);\n+    typeBuffer = newBuf;\n+    typeBufferAllocationSizeInBytes = (int)newAllocationSize;\n+  }\n+\n+  private void reallocOffsetBuffer() {\n+    final int currentBufferCapacity = offsetBuffer.capacity();\n+    long baseSize  = offsetBufferAllocationSizeInBytes;\n+\n+    if (baseSize < (long) currentBufferCapacity) {\n+      baseSize = (long) currentBufferCapacity;\n+    }\n+\n+    long newAllocationSize = baseSize * 2L;\n+    newAllocationSize = BaseAllocator.nextPowerOfTwo(newAllocationSize);\n+    assert newAllocationSize >= 1;\n+\n+    if (newAllocationSize > BaseValueVector.MAX_ALLOCATION_SIZE) {\n+      throw new OversizedAllocationException(\"Unable to expand the buffer\");\n+    }\n+\n+    final ArrowBuf newBuf = allocator.buffer((int) newAllocationSize);\n+    newBuf.setBytes(0, offsetBuffer, 0, currentBufferCapacity);\n+    newBuf.setZero(currentBufferCapacity, newBuf.capacity() - currentBufferCapacity);\n+    offsetBuffer.getReferenceManager().release(1);\n+    offsetBuffer = newBuf;\n+    offsetBufferAllocationSizeInBytes = (int) newAllocationSize;\n+  }\n+\n+  @Override\n+  public void setInitialCapacity(int numRecords) { }\n+\n+  @Override\n+  public int getValueCapacity() {\n+    return Math.min(Math.min(getTypeBufferValueCapacity(), getOffsetBufferValueCapacity()),\n+            internalStruct.getValueCapacity());\n+  }\n+\n+  @Override\n+  public void close() {\n+    clear();\n+  }\n+\n+  @Override\n+  public void clear() {\n+    valueCount = 0;\n+    typeBuffer.getReferenceManager().release();\n+    typeBuffer = allocator.getEmpty();\n+    offsetBuffer.getReferenceManager().release();\n+    offsetBuffer = allocator.getEmpty();\n+    internalStruct.clear();\n+  }\n+\n+  @Override\n+  public void reset() {\n+    valueCount = 0;\n+    typeBuffer.setZero(0, typeBuffer.capacity());\n+    offsetBuffer.setZero(0, offsetBuffer.capacity());\n+    internalStruct.reset();\n+  }\n+\n+  @Override\n+  public Field getField() {\n+    List<org.apache.arrow.vector.types.pojo.Field> childFields = new ArrayList<>();\n+    List<FieldVector> children = internalStruct.getChildren();\n+    int[] typeIds = new int[children.size()];\n+    for (ValueVector v : children) {\n+      typeIds[childFields.size()] = v.getMinorType().ordinal();\n+      childFields.add(v.getField());\n+    }\n+\n+    FieldType fieldType;\n+    if (this.fieldType == null) {\n+      fieldType = FieldType.nullable(new ArrowType.Union(Dense, typeIds));\n+    } else {\n+      final UnionMode mode = ((ArrowType.Union)this.fieldType.getType()).getMode();\n+      fieldType = new FieldType(this.fieldType.isNullable(), new ArrowType.Union(mode, typeIds),\n+              this.fieldType.getDictionary(), this.fieldType.getMetadata());\n+    }\n+\n+    return new Field(name, fieldType, childFields);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(BufferAllocator allocator) {\n+    return getTransferPair(name, allocator);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator) {\n+    return getTransferPair(ref, allocator, null);\n+  }\n+\n+  @Override\n+  public TransferPair getTransferPair(String ref, BufferAllocator allocator, CallBack callBack) {\n+    return new org.apache.arrow.vector.complex.DenseUnionVector.TransferImpl(ref, allocator, callBack);\n+  }\n+\n+  @Override\n+  public TransferPair makeTransferPair(ValueVector target) {\n+    return new TransferImpl((DenseUnionVector) target);\n+  }\n+\n+  @Override\n+  public void copyFrom(int inIndex, int outIndex, ValueVector from) {\n+    Preconditions.checkArgument(this.getMinorType() == from.getMinorType());\n+    DenseUnionVector fromCast = (DenseUnionVector) from;\n+    int inOffset = fromCast.offsetBuffer.getInt(inIndex * OFFSET_WIDTH);\n+    fromCast.getReader().setPosition(inOffset);\n+    int outOffset = offsetBuffer.getInt(outIndex * OFFSET_WIDTH);\n+    getWriter().setPosition(outOffset);\n+    ComplexCopier.copy(fromCast.reader, writer);\n+  }\n+\n+  @Override\n+  public void copyFromSafe(int inIndex, int outIndex, ValueVector from) {\n+    copyFrom(inIndex, outIndex, from);\n+  }\n+\n+  public FieldVector addVector(FieldVector v) {\n+    int typeId = getOrAllocateTypeId(v.getField());\n+    String name = typeId < Types.MinorType.values().length ? fieldName(v.getMinorType()) :\n+            fieldName(typeId, v.getMinorType());\n+    Preconditions.checkState(internalStruct.getChild(name) == null, String.format(\"%s vector already exists\", name));\n+    final FieldVector newVector = internalStruct.addOrGet(name, v.getField().getFieldType(), v.getClass());\n+    v.makeTransferPair(newVector).transfer();\n+    internalStruct.putChild(name, newVector);\n+    if (newVector instanceof StructVector) {\n+      structVectors.put(typeId, (StructVector) newVector);\n+    } else if (newVector instanceof ListVector) {\n+      listVectors.put(typeId, (ListVector) newVector);\n+    }\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+    return newVector;\n+  }\n+\n+  /**\n+   * Directly put a vector to internalStruct without creating a new one with same type.\n+   */\n+  public void directAddVector(FieldVector v) {\n+    String name = v.getMinorType().name().toLowerCase();\n+    Preconditions.checkState(internalStruct.getChild(name) == null, String.format(\"%s vector already exists\", name));\n+    internalStruct.putChild(name, v);\n+    if (callBack != null) {\n+      callBack.doWork();\n+    }\n+  }\n+\n+  private class TransferImpl implements TransferPair {\n+    private final TransferPair[] internalTransferPairs = new TransferPair[Types.MinorType.values().length];\n+    private final DenseUnionVector to;\n+\n+    public TransferImpl(String name, BufferAllocator allocator, CallBack callBack) {\n+      to = new DenseUnionVector(name, allocator, null, callBack);\n+      internalStruct.makeTransferPair(to.internalStruct);\n+      createTransferPairs();\n+    }\n+\n+    public TransferImpl(DenseUnionVector to) {\n+      this.to = to;\n+      internalStruct.makeTransferPair(to.internalStruct);\n+      createTransferPairs();\n+    }\n+\n+    private void createTransferPairs() {\n+      for (int i = 0; i < internalStruct.getField().getChildren().size(); i++) {\n+        ValueVector srcVec = internalStruct.getVectorById(i);\n+        ValueVector dstVec = to.internalStruct.getVectorById(i);\n+        internalTransferPairs[srcVec.getMinorType().ordinal()] = srcVec.makeTransferPair(dstVec);\n+      }\n+    }\n+\n+    @Override\n+    public void transfer() {\n+      to.clear();\n+      final ReferenceManager refManager = typeBuffer.getReferenceManager();\n+      to.typeBuffer = refManager.transferOwnership(typeBuffer, to.allocator).getTransferredBuffer();\n+      to.offsetBuffer = refManager.transferOwnership(offsetBuffer, to.allocator).getTransferredBuffer();\n+      for (int i = 0; i < MinorType.values().length; i++) {\n+        if (internalTransferPairs[i] != null) {\n+          internalTransferPairs[i].transfer();\n+        }\n+      }\n+      to.valueCount = valueCount;\n+      clear();\n+    }\n+\n+    @Override\n+    public void splitAndTransfer(int startIndex, int length) {\n+      to.clear();\n+      int startPoint = startIndex * TYPE_WIDTH;\n+      int sliceLength = length * TYPE_WIDTH;\n+      ArrowBuf slicedBuffer = typeBuffer.slice(startPoint, sliceLength);\n+      ReferenceManager refManager = slicedBuffer.getReferenceManager();\n+      to.typeBuffer = refManager.transferOwnership(slicedBuffer, to.allocator).getTransferredBuffer();\n+\n+      while (to.offsetBuffer.capacity() < length * OFFSET_WIDTH) {\n+        to.reallocOffsetBuffer();\n+      }\n+\n+      int [] typeCounts = new int[MinorType.values().length];\n+      int [] typeStarts = new int[Types.MinorType.values().length];\n+      for (int i = 0; i < typeCounts.length; i++) {\n+        typeCounts[i] = 0;\n+        typeStarts[i] = -1;\n+      }\n+\n+      for (int i = startIndex; i < startIndex + length; i++) {\n+        int ord = typeBuffer.getByte(i);\n+        to.offsetBuffer.setInt((i - startIndex) * OFFSET_WIDTH, typeCounts[ord]);\n+        typeCounts[ord] += 1;\n+        if (typeStarts[ord] == -1) {\n+          typeStarts[ord] = offsetBuffer.getInt(i * OFFSET_WIDTH);\n+        }\n+      }\n+      to.setValueCount(length);\n+\n+      // transfer vector values\n+      for (int i = 0; i < MinorType.values().length; i++) {\n+        if (typeCounts[i] > 0 && typeStarts[i] != -1) {\n+          internalTransferPairs[i].splitAndTransfer(typeStarts[i], typeCounts[i]);\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public ValueVector getTo() {\n+      return to;\n+    }\n+\n+    @Override\n+    public void copyValueSafe(int from, int to) {\n+      this.to.copyFrom(from, to, DenseUnionVector.this);\n+    }\n+  }\n+\n+  @Override\n+  public FieldReader getReader() {\n+    if (reader == null) {\n+      reader = new DenseUnionReader(this);\n+    }\n+    return reader;\n+  }\n+\n+  public FieldWriter getWriter() {\n+    if (writer == null) {\n+      writer = new DenseUnionWriter(this);\n+    }\n+    return writer;\n+  }\n+\n+  @Override\n+  public int getBufferSize() {\n+    if (valueCount == 0) { return 0; }\n+\n+    return valueCount * TYPE_WIDTH + valueCount * OFFSET_WIDTH + internalStruct.getBufferSize();\n+  }\n+\n+  @Override\n+  public int getBufferSizeFor(final int valueCount) {\n+    if (valueCount == 0) {\n+      return 0;\n+    }\n+\n+    long bufferSize = 0;\n+    for (final ValueVector v : (Iterable<ValueVector>) this) {\n+      bufferSize += v.getBufferSizeFor(valueCount);\n+    }\n+\n+    return (int) bufferSize + valueCount * TYPE_WIDTH + valueCount * OFFSET_WIDTH;\n+  }\n+\n+  @Override\n+  public ArrowBuf[] getBuffers(boolean clear) {\n+    List<ArrowBuf> list = new java.util.ArrayList<>();\n+    setReaderAndWriterIndex();\n+    if (getBufferSize() != 0) {\n+      list.add(typeBuffer);\n+      list.add(offsetBuffer);\n+      list.addAll(java.util.Arrays.asList(internalStruct.getBuffers(clear)));\n+    }\n+    if (clear) {\n+      valueCount = 0;\n+      typeBuffer.getReferenceManager().retain();\n+      typeBuffer.close();\n+      typeBuffer = allocator.getEmpty();\n+      offsetBuffer.getReferenceManager().retain();\n+      offsetBuffer.close();\n+      offsetBuffer = allocator.getEmpty();\n+    }\n+    return list.toArray(new ArrowBuf[list.size()]);\n+  }\n+\n+  @Override\n+  public Iterator<ValueVector> iterator() {\n+    List<ValueVector> vectors = org.apache.arrow.util.Collections2.toList(internalStruct.iterator());\n+    return vectors.iterator();\n+  }\n+\n+  private ValueVector getVector(int index) {\n+    int type = typeBuffer.getByte(index * TYPE_WIDTH);\n+    if (type < Types.MinorType.values().length) {\n \n Review comment:\n   this still doesn't conform to the spec as written.  There can pontentially be more then one vector of each primitive type (e.g. 2 IntVectors).  Again we should try to close on this on the mailing list, but I thought last time it was discussed we agreed to keep it general.  \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-10T09:16:11.972+0000",
                    "updated": "2020-01-10T09:16:11.972+0000",
                    "started": "2020-01-10T09:16:11.972+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "369739",
                    "issueId": "13252908"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/worklog/370699",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "liyafan82 commented on issue #5473: ARROW-6352: [Java] Add implementation of DenseUnionVector\nURL: https://github.com/apache/arrow/pull/5473#issuecomment-573598491\n \n \n   > I would like to see this refactored so we do base classes of the vector and reader as non-templated code and then the implementation adds the templated code (or vice versa). This is to minimize the use of java code in freemarker templates. We have tried to eliminate that in a bunch of places. We haven't refactored in the readers/writers but we should avoid introducing new debt on this front.\r\n   \r\n   Thanks for the suggestion. I will refactor the code towards that direction. \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-13T10:33:16.046+0000",
                    "updated": "2020-01-13T10:33:16.046+0000",
                    "started": "2020-01-13T10:33:16.045+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "370699",
                    "issueId": "13252908"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 25800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1587e75d[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5f431517[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6ec33713[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@296f7c71[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@10eae8de[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@70b0955d[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7bc4ff7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@55623785[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@128989ef[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@6667ec9e[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@341c452[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@47db05a0[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 25800,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Jan 24 06:01:58 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-01-24T06:01:58.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-6352/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2019-08-26T04:05:18.000+0000",
        "updated": "2020-01-24T06:01:58.000+0000",
        "timeoriginalestimate": null,
        "description": "Today only Sparse unions are supported.\u00a0 We should have a dense union implementation vector that conforms to the IPC protocol (the current sparse union vector doesn't do this and there are other JIRAs covering making it compatible).",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "7h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 25800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Java] Add implementation of DenseUnionVector.",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/comment/16915467",
                    "id": "16915467",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=fan_li_ya",
                        "name": "fan_li_ya",
                        "key": "fan_li_ya",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Liya Fan",
                        "active": true,
                        "timeZone": "Asia/Shanghai"
                    },
                    "body": "[~emkornfield@gmail.com]\u00a0This sounds interesting and useful.\r\n\r\nCan you please point out the \"other JIRAs covering\"?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=fan_li_ya",
                        "name": "fan_li_ya",
                        "key": "fan_li_ya",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Liya Fan",
                        "active": true,
                        "timeZone": "Asia/Shanghai"
                    },
                    "created": "2019-08-26T04:31:53.730+0000",
                    "updated": "2019-08-26T04:31:53.730+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/comment/16917545",
                    "id": "16917545",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "[~fan_li_ya]\u00a0https://issues.apache.org/jira/browse/ARROW-1692?filter=-1\u00a0is the one for sparse.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2019-08-28T08:23:31.995+0000",
                    "updated": "2019-08-28T08:23:31.995+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/comment/16917633",
                    "id": "16917633",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=fan_li_ya",
                        "name": "fan_li_ya",
                        "key": "fan_li_ya",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Liya Fan",
                        "active": true,
                        "timeZone": "Asia/Shanghai"
                    },
                    "body": "[~emkornfield@gmail.com]\u00a0Thanks for the information. Will take a closer look.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=fan_li_ya",
                        "name": "fan_li_ya",
                        "key": "fan_li_ya",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Liya Fan",
                        "active": true,
                        "timeZone": "Asia/Shanghai"
                    },
                    "created": "2019-08-28T10:18:40.009+0000",
                    "updated": "2019-08-28T10:18:40.009+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13252908/comment/17022711",
                    "id": "17022711",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 5473\n[https://github.com/apache/arrow/pull/5473]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=emkornfield%40gmail.com",
                        "name": "emkornfield@gmail.com",
                        "key": "emkornfield@gmail.com",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Micah Kornfield",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2020-01-24T06:01:58.602+0000",
                    "updated": "2020-01-24T06:01:58.602+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|z060qo:",
        "customfield_12314139": null
    }
}