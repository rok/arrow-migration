{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13377671",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671",
    "key": "ARROW-12724",
    "fields": {
        "fixVersions": [],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/2",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/critical.svg",
            "name": "Critical",
            "id": "2"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12644693",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12644693",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13472738",
                    "key": "ARROW-17168",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13472738",
                    "fields": {
                        "summary": "[C++][Docs] Expand C++ Cookbook",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
                            "id": "7",
                            "description": "The sub-task of the issue",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
                            "name": "Sub-task",
                            "subtask": true,
                            "avatarId": 21146
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=octalene",
            "name": "octalene",
            "key": "octalene",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=octalene&avatarId=51083",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=octalene&avatarId=51083",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=octalene&avatarId=51083",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=octalene&avatarId=51083"
            },
            "displayName": "Aldrin Montana",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/3",
            "description": "This issue is being actively worked on at the moment by the assignee.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
            "name": "In Progress",
            "id": "3",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                "id": 4,
                "key": "indeterminate",
                "colorName": "yellow",
                "name": "In Progress"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12332532",
                "id": "12332532",
                "name": "Documentation"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=edponce",
            "name": "edponce",
            "key": "edponce",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=edponce&avatarId=45496",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=edponce&avatarId=45496",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=edponce&avatarId=45496",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=edponce&avatarId=45496"
            },
            "displayName": "Eduardo Ponce",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=edponce",
            "name": "edponce",
            "key": "edponce",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=edponce&avatarId=45496",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=edponce&avatarId=45496",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=edponce&avatarId=45496",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=edponce&avatarId=45496"
            },
            "displayName": "Eduardo Ponce",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 47400,
            "total": 47400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 47400,
            "total": 47400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12724/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 79,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/594853",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#issuecomment-839230431\n\n\n   https://issues.apache.org/jira/browse/ARROW-12724\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-11T22:19:55.345+0000",
                    "updated": "2021-05-11T22:19:55.345+0000",
                    "started": "2021-05-11T22:19:55.344+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "594853",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/595118",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r630822980\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n\nReview comment:\n       Can you wrap long lines?\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n\nReview comment:\n       Also, it seems you're using Markdown syntax. These documents should be authored using [restructuredText](https://www.sphinx-doc.org/en/master/usage/restructuredtext/index.html).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-12T08:15:26.883+0000",
                    "updated": "2021-05-12T08:15:26.883+0000",
                    "started": "2021-05-12T08:15:26.883+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "595118",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/599407",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r633591259\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are defined as `structs` with the same name as the compute function's API. These `structs` contain static *Call* methods representing the unique implementation for each argument signature. Apache Arrow conforms to SFINAE and aliased-template conditionals to generalize kernel implementations for different argument types. Also, kernel implementations can have the *constexpr* specifier if applicable.\n\nReview comment:\n       The structures with static `Call` functions (such as `struct Add`) which are used to aid in efficient construction of some kernels are not identical to the kernels:\r\n   \r\n   ```suggestion\r\n   Kernels are simple ``structs`` containing only function pointers (the \"methods\" of the kernel) and attribute flags. Each function kind corresponds to a class of Kernel with methods representing each stage of the function's execution. For example, :struct:`ScalarKernel` includes (optionally) :member:`ScalarKernel::init` to initialize any state necessary for execution and :member:`ScalarKernel::exec` to perform the computation.\r\n   \r\n   Since many kernels are closely related in operation and differ only in their input types, it's frequently useful to leverage c++'s powerful template system to efficiently generate kernels' methods. For example, the \"add\" compute function accepts all numeric types and its kernels' methods are instantiations of the same function template.\r\n   ```\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are defined as `structs` with the same name as the compute function's API. These `structs` contain static *Call* methods representing the unique implementation for each argument signature. Apache Arrow conforms to SFINAE and aliased-template conditionals to generalize kernel implementations for different argument types. Also, kernel implementations can have the *constexpr* specifier if applicable.\n+\n+Function options\n+----------------\n+\n+[FunctionOptions](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE)\n+\n+\n+Function documentation\n+----------------------\n+\n+[FunctionDoc](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE)\n+\n+\n+Files and structures of the computer layer\n+==========================================\n+\n+This section describes the general structure of files/directory and principal code structures of the compute layer.\n+\n+* arrow/util/int_util_internal.h - defines utility functions\n+    * Function definitions suffixed with `WithOverflow` to support \"safe math\" for arithmetic kernels. Helper macros are included to create the definitions which invoke the corresponding operation in [`portable_snippets`](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h) library.\n+\n+* compute/api_scalar.h - contains\n+    * Subclasses of `FunctionOptions` for specific categories of compute functions\n+    * API/prototypes for all `Scalar` compute functions. Note that there is a single API version for each compute function.\n+* *compute/api_scalar.cc* - defines `Scalar` compute functions as wrappers over [\"CallFunction\"](https://arrow.apache.org/docs/cpp/api/compute.html?highlight=one%20shot#_CPPv412CallFunctionRKNSt6stringERKNSt6vectorI5DatumEEPK15FunctionOptionsP11ExecContext) (one-shot function). Arrow provides macros to easily define compute functions based on their `arity` and invocation mode.\n+    * Macros of the form `SCALAR_EAGER_*` invoke `CallFunction` directly and only require one function name.\n+    * Macros of the form `SCALAR_*` invoke `CallFunction` after checking for overflow and require two function names (default and `_checked` variant).\n+\n+* compute/kernels/scalar_arithmetic.cc - contains kernel definitions for \"Scalar Arithmetic\" compute functions. Kernel definitions are defined via a class with literal name of compute function and containing methods named `Call` that are parameterized for specific input types (signed/unsigned integer and floating-point).\n+    * For compute functions that may trigger overflow the \"checked\" variant is a class suffixed with `Checked` and makes use of assertions and overflow checks. If overflow occurs, kernel returns zero and sets that `Status*` error flag.\n+        * For compute functions that do not have a valid mathematical operation for specific datatypes (e.g., negate an unsigned integer), the kernel for those types is provided but should trigger an error with `DCHECK(false) << This is included only for the purposes of instantiability from the \"arithmetic kernel generator\"` and return zero.\n+\n+\n+Kernel dispatcher\n+-----------------\n+\n+* compute/exec.h\n+    * Defines variants of `CallFunction` which are the one-shot functions for invoking compute functions. A compute function should invoke `CallFunction` in its definition.\n+    * Defines `ExecContext` class\n+    * ScalarExecutor applies scalar function to batch\n+    * ExecBatchIterator::Make\n+\n+* `DispatchBest`\n+\n+* `FunctionRegistry` is the class representing a function registry. By default there is a single global registry where all kernels reside. `ExecContext` maintains a reference to the registry, if reference is NULL then the default registry is used.\n+\n+* aggregate_basic.cc, aggregate_basic_internal.h - example of passing options to kernel\n+    * scalaraggregator\n+\n+\n+Portable snippets for safe (integer) math\n+-----------------------------------------\n+\n+Arithmetic functions which can trigger integral overflow use the vendored library `portable_snippets` to perform \"safe math\" operations (e.g., arithmetic, logical shifts, casts).\n+Kernel implementations suffixed with `WithOverflow` need to be defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/util/int_util_internal.h for each primitive datatype supported. Use the helper macros of the form `*OPS_WITH_OVERFLOW` to automatically generate the definitions. This file also contains helper functions for performing safe integral arithmetic for the kernels' default variant.\n+\n+The short-hand name maps to the predefined operation names in https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h#L1028-L1033. For example, `OPS_WITH_OVERFLOW(AddWithOverflow, add)` uses short-hand name `add`.\n+\n+\n+Adding a new compute function\n+=============================\n+\n+This section describes the process for adding a new compute function and associated kernel implementations.\n+\n+First, you should identify the principal attributes of the new compute function.\n+The following series of steps help guide the design process.\n+\n+1. Decide on a unique name that fully represents the function's operation\n+\n+   Browse the [available compute functions](https://arrow.apache.org/docs/cpp/compute.html#available-functions) to prevent a name collision. Note that the long form of names is preferred, and multi-word names are allowed due to the fact that string versions use an underscore instead of whitespace and C++ function names use camel case convention.\n+     * What is a representative and unambiguous name for the operation performed by the compute function?\n+     * If a related or variant form of a compute function is to be added in the future, is the current name extensible or specific enough to allow room for clear differentiation? For example, `str_length` is not a good name because there are different types of strings, so in this case it is preferable to be specific with `ascii_length` and `utf8_length`.\n+\n+1. Identify the input/output types/shapes\n+    * What are the input types/shapes supported?\n+    * If multiple inputs are expected, are they the same type/shape?\n+\n+1. Identify the compute function \"kind\" based on its operation and #2.\n+    * Does the codebase of the \"kind\" provides full support for the new compute function?\n+        * If not, is it straightforward to add the missing parts or can the new compute function be supported by another \"kind\"?\n+\n+\n+Define compute function\n+-----------------------\n+\n+Add the compute function prototype and definition to the corresponding source files based on its \"kind\". For example the API of a \"Scalar\" function is found in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.h and its definition in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.cc.\n+\n+\n+\n+Define kernels of compute function\n+----------------------------------\n+\n+Define the kernel implementations in the corresponding source file based on the compute function's \"kind\" and category. For example, a \"Scalar\" arithmetic function has kernels defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernels/scalar_arithmetic.cc.\n+\n+Create compute function documentation (`FunctionDoc` object)\n+------------------------------------------------------------\n+\n+Each compute function has documentation which includes a summary, description, and argument types of its operation. A `FunctionDoc` object is instantiated and used in the registration step. Note that for compute functions that can overflow, another `FunctionDoc` is required for the `_checked` variant.\n+\n+Register kernels of compute function\n+------------------------------------\n+\n+1. Before registering the kernels, check that the available kernel generators support the `arity` and data types allowed for the new compute function. Kernel generators are not of the same form for all the kernel `kinds`. For example, in the \"Scalar Arithmetic\" kernels, registration functions have names of the form `MakeArithmeticFunction` and `MakeArithmeticFunctionNotNull`. If not available, you will need to define them for your particular case.\n+\n+1. Create the kernels by invoking the kernel generators.\n+\n+1. Register the kernels in the corresponding registry along with its `FunctionDoc`.\n+\n+\n+Testing\n+-------\n+\n+Arrow uses Google test framework. All kernels should have tests to ensure stability of the compute layer. Tests should at least cover ordinary inputs, corner cases, extreme values, nulls, different data types, and invalid tests. Moreover, there can be kernel-specific tests. For example, for arithmetic kernels, tests should include `NaN` and `Inf` inputs. The test files are located alongside the kernel source files and suffixed with `_test`. Tests are grouped by compute function `kind` and categories.\n+\n+`TYPED_TEST(test suite name, compute function)` - wrapper to define tests for the given compute function. The `test suite name` is associated with a set of data types that are used for the test suite (`TYPED_TEST_SUITE`). Tests from multiple compute functions can be placed in the same test suite. For example, `TYPED_TEST(TestBinaryArithmeticFloating, Sub)` and `TYPED_TEST(TestBinaryArithmeticFloating, Mul)`.\n+\n\nReview comment:\n       I think a simple (un-templated, non-suite) C++ test case is a necessary code snippet. For example,\r\n   \r\n   ```c++\r\n   // scalar_arithmetic_test.cc\r\n   TEST(AbsoluteValue, IntegralInputs) {\r\n     for (auto type : {int8(), int16(), int32(), int64()}) {\r\n       CheckScalarUnary(\"absolute_value\", int8(), \"[]\", int8(), \"[]\");\r\n   \r\n       CheckScalarUnary(\"absolute_value\", int8(), \"[0, -1, 1, 2, -2, 3, -3]\", int8(),\r\n                        \"[0, 1, 1, 2, 2, 3, 3]\");\r\n     }\r\n   }\r\n   ```\r\n   \r\n   Note that the above compiles and executes *before* adding the absolute_value function (IMHO it's a useful clarification of intended behavior to add a failing test like this as early as possible in the addition of a new function).\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are defined as `structs` with the same name as the compute function's API. These `structs` contain static *Call* methods representing the unique implementation for each argument signature. Apache Arrow conforms to SFINAE and aliased-template conditionals to generalize kernel implementations for different argument types. Also, kernel implementations can have the *constexpr* specifier if applicable.\n+\n+Function options\n+----------------\n+\n+[FunctionOptions](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE)\n+\n+\n+Function documentation\n+----------------------\n+\n\nReview comment:\n       Please describe this briefly, mentioning that it's used for interactive help in the bindings\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are defined as `structs` with the same name as the compute function's API. These `structs` contain static *Call* methods representing the unique implementation for each argument signature. Apache Arrow conforms to SFINAE and aliased-template conditionals to generalize kernel implementations for different argument types. Also, kernel implementations can have the *constexpr* specifier if applicable.\n+\n+Function options\n+----------------\n+\n\nReview comment:\n       Add an explanation and an example here please\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n\nReview comment:\n       ```suggestion\r\n   Hash aggregate\r\n   ~~~~~~~~~~~~~~\r\n   ```\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are defined as `structs` with the same name as the compute function's API. These `structs` contain static *Call* methods representing the unique implementation for each argument signature. Apache Arrow conforms to SFINAE and aliased-template conditionals to generalize kernel implementations for different argument types. Also, kernel implementations can have the *constexpr* specifier if applicable.\n+\n+Function options\n+----------------\n+\n+[FunctionOptions](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE)\n+\n+\n+Function documentation\n+----------------------\n+\n+[FunctionDoc](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE)\n+\n+\n+Files and structures of the computer layer\n+==========================================\n+\n+This section describes the general structure of files/directory and principal code structures of the compute layer.\n+\n+* arrow/util/int_util_internal.h - defines utility functions\n+    * Function definitions suffixed with `WithOverflow` to support \"safe math\" for arithmetic kernels. Helper macros are included to create the definitions which invoke the corresponding operation in [`portable_snippets`](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h) library.\n+\n+* compute/api_scalar.h - contains\n+    * Subclasses of `FunctionOptions` for specific categories of compute functions\n+    * API/prototypes for all `Scalar` compute functions. Note that there is a single API version for each compute function.\n+* *compute/api_scalar.cc* - defines `Scalar` compute functions as wrappers over [\"CallFunction\"](https://arrow.apache.org/docs/cpp/api/compute.html?highlight=one%20shot#_CPPv412CallFunctionRKNSt6stringERKNSt6vectorI5DatumEEPK15FunctionOptionsP11ExecContext) (one-shot function). Arrow provides macros to easily define compute functions based on their `arity` and invocation mode.\n+    * Macros of the form `SCALAR_EAGER_*` invoke `CallFunction` directly and only require one function name.\n+    * Macros of the form `SCALAR_*` invoke `CallFunction` after checking for overflow and require two function names (default and `_checked` variant).\n+\n+* compute/kernels/scalar_arithmetic.cc - contains kernel definitions for \"Scalar Arithmetic\" compute functions. Kernel definitions are defined via a class with literal name of compute function and containing methods named `Call` that are parameterized for specific input types (signed/unsigned integer and floating-point).\n+    * For compute functions that may trigger overflow the \"checked\" variant is a class suffixed with `Checked` and makes use of assertions and overflow checks. If overflow occurs, kernel returns zero and sets that `Status*` error flag.\n+        * For compute functions that do not have a valid mathematical operation for specific datatypes (e.g., negate an unsigned integer), the kernel for those types is provided but should trigger an error with `DCHECK(false) << This is included only for the purposes of instantiability from the \"arithmetic kernel generator\"` and return zero.\n+\n+\n+Kernel dispatcher\n+-----------------\n+\n+* compute/exec.h\n+    * Defines variants of `CallFunction` which are the one-shot functions for invoking compute functions. A compute function should invoke `CallFunction` in its definition.\n+    * Defines `ExecContext` class\n+    * ScalarExecutor applies scalar function to batch\n+    * ExecBatchIterator::Make\n+\n+* `DispatchBest`\n+\n+* `FunctionRegistry` is the class representing a function registry. By default there is a single global registry where all kernels reside. `ExecContext` maintains a reference to the registry, if reference is NULL then the default registry is used.\n+\n+* aggregate_basic.cc, aggregate_basic_internal.h - example of passing options to kernel\n+    * scalaraggregator\n+\n+\n+Portable snippets for safe (integer) math\n+-----------------------------------------\n+\n+Arithmetic functions which can trigger integral overflow use the vendored library `portable_snippets` to perform \"safe math\" operations (e.g., arithmetic, logical shifts, casts).\n+Kernel implementations suffixed with `WithOverflow` need to be defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/util/int_util_internal.h for each primitive datatype supported. Use the helper macros of the form `*OPS_WITH_OVERFLOW` to automatically generate the definitions. This file also contains helper functions for performing safe integral arithmetic for the kernels' default variant.\n+\n+The short-hand name maps to the predefined operation names in https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h#L1028-L1033. For example, `OPS_WITH_OVERFLOW(AddWithOverflow, add)` uses short-hand name `add`.\n+\n+\n+Adding a new compute function\n+=============================\n+\n+This section describes the process for adding a new compute function and associated kernel implementations.\n+\n+First, you should identify the principal attributes of the new compute function.\n+The following series of steps help guide the design process.\n+\n+1. Decide on a unique name that fully represents the function's operation\n+\n+   Browse the [available compute functions](https://arrow.apache.org/docs/cpp/compute.html#available-functions) to prevent a name collision. Note that the long form of names is preferred, and multi-word names are allowed due to the fact that string versions use an underscore instead of whitespace and C++ function names use camel case convention.\n+     * What is a representative and unambiguous name for the operation performed by the compute function?\n+     * If a related or variant form of a compute function is to be added in the future, is the current name extensible or specific enough to allow room for clear differentiation? For example, `str_length` is not a good name because there are different types of strings, so in this case it is preferable to be specific with `ascii_length` and `utf8_length`.\n+\n+1. Identify the input/output types/shapes\n+    * What are the input types/shapes supported?\n+    * If multiple inputs are expected, are they the same type/shape?\n+\n+1. Identify the compute function \"kind\" based on its operation and #2.\n+    * Does the codebase of the \"kind\" provides full support for the new compute function?\n+        * If not, is it straightforward to add the missing parts or can the new compute function be supported by another \"kind\"?\n+\n+\n+Define compute function\n+-----------------------\n+\n+Add the compute function prototype and definition to the corresponding source files based on its \"kind\". For example the API of a \"Scalar\" function is found in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.h and its definition in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.cc.\n+\n+\n+\n+Define kernels of compute function\n+----------------------------------\n+\n+Define the kernel implementations in the corresponding source file based on the compute function's \"kind\" and category. For example, a \"Scalar\" arithmetic function has kernels defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernels/scalar_arithmetic.cc.\n+\n+Create compute function documentation (`FunctionDoc` object)\n+------------------------------------------------------------\n+\n+Each compute function has documentation which includes a summary, description, and argument types of its operation. A `FunctionDoc` object is instantiated and used in the registration step. Note that for compute functions that can overflow, another `FunctionDoc` is required for the `_checked` variant.\n+\n+Register kernels of compute function\n+------------------------------------\n+\n+1. Before registering the kernels, check that the available kernel generators support the `arity` and data types allowed for the new compute function. Kernel generators are not of the same form for all the kernel `kinds`. For example, in the \"Scalar Arithmetic\" kernels, registration functions have names of the form `MakeArithmeticFunction` and `MakeArithmeticFunctionNotNull`. If not available, you will need to define them for your particular case.\n+\n+1. Create the kernels by invoking the kernel generators.\n+\n+1. Register the kernels in the corresponding registry along with its `FunctionDoc`.\n+\n+\n+Testing\n+-------\n+\n+Arrow uses Google test framework. All kernels should have tests to ensure stability of the compute layer. Tests should at least cover ordinary inputs, corner cases, extreme values, nulls, different data types, and invalid tests. Moreover, there can be kernel-specific tests. For example, for arithmetic kernels, tests should include `NaN` and `Inf` inputs. The test files are located alongside the kernel source files and suffixed with `_test`. Tests are grouped by compute function `kind` and categories.\n+\n+`TYPED_TEST(test suite name, compute function)` - wrapper to define tests for the given compute function. The `test suite name` is associated with a set of data types that are used for the test suite (`TYPED_TEST_SUITE`). Tests from multiple compute functions can be placed in the same test suite. For example, `TYPED_TEST(TestBinaryArithmeticFloating, Sub)` and `TYPED_TEST(TestBinaryArithmeticFloating, Mul)`.\n+\n+Helpers\n+=======\n+\n+* `MakeArray` - convert a `Datum` to an ...\n+* `ArrayFromJSON(type_id, format string)` -  `ArrayFromJSON(float32, \"[1.3, 10.80, NaN, Inf, null]\")`\n+\n+\n+Benchmarking\n+------------\n+\n+\n+Example of Unary Arithmetic Function: Absolute Value\n+====================================================\n+\n+Identify the principal attributes.\n+\n+1. Name\n+    * String literal: \"absolute_value\"\n+    * C++ function names: `AbsoluteValue`\n+1. Input/output types: Numerical (signed and unsigned, integral and floating-point)\n+1. Input/output shapes: operate on scalars or element-wise for arrays\n+1. Kind: Scalar\n+    * Category: Arithmetic\n+1. Arity: Unary\n+\n+\n+Define compute function\n+-----------------------\n\nReview comment:\n       Try to avoid ambiguity between the instance of `compute::Function` which is being added to the registry and the convenience function which is being added to `api_scalar.h`. The former is the canonical definition. The latter is a wrapper for easy use from C++, and probably isn't necessary for most compute functions. In fact for simplicity it might be better to avoid modifying `api_scalar.h` in this tutorial\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are defined as `structs` with the same name as the compute function's API. These `structs` contain static *Call* methods representing the unique implementation for each argument signature. Apache Arrow conforms to SFINAE and aliased-template conditionals to generalize kernel implementations for different argument types. Also, kernel implementations can have the *constexpr* specifier if applicable.\n+\n+Function options\n+----------------\n+\n+[FunctionOptions](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE)\n+\n+\n+Function documentation\n+----------------------\n+\n+[FunctionDoc](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE)\n+\n+\n+Files and structures of the computer layer\n+==========================================\n+\n+This section describes the general structure of files/directory and principal code structures of the compute layer.\n+\n+* arrow/util/int_util_internal.h - defines utility functions\n+    * Function definitions suffixed with `WithOverflow` to support \"safe math\" for arithmetic kernels. Helper macros are included to create the definitions which invoke the corresponding operation in [`portable_snippets`](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h) library.\n+\n+* compute/api_scalar.h - contains\n+    * Subclasses of `FunctionOptions` for specific categories of compute functions\n+    * API/prototypes for all `Scalar` compute functions. Note that there is a single API version for each compute function.\n+* *compute/api_scalar.cc* - defines `Scalar` compute functions as wrappers over [\"CallFunction\"](https://arrow.apache.org/docs/cpp/api/compute.html?highlight=one%20shot#_CPPv412CallFunctionRKNSt6stringERKNSt6vectorI5DatumEEPK15FunctionOptionsP11ExecContext) (one-shot function). Arrow provides macros to easily define compute functions based on their `arity` and invocation mode.\n+    * Macros of the form `SCALAR_EAGER_*` invoke `CallFunction` directly and only require one function name.\n+    * Macros of the form `SCALAR_*` invoke `CallFunction` after checking for overflow and require two function names (default and `_checked` variant).\n+\n+* compute/kernels/scalar_arithmetic.cc - contains kernel definitions for \"Scalar Arithmetic\" compute functions. Kernel definitions are defined via a class with literal name of compute function and containing methods named `Call` that are parameterized for specific input types (signed/unsigned integer and floating-point).\n+    * For compute functions that may trigger overflow the \"checked\" variant is a class suffixed with `Checked` and makes use of assertions and overflow checks. If overflow occurs, kernel returns zero and sets that `Status*` error flag.\n+        * For compute functions that do not have a valid mathematical operation for specific datatypes (e.g., negate an unsigned integer), the kernel for those types is provided but should trigger an error with `DCHECK(false) << This is included only for the purposes of instantiability from the \"arithmetic kernel generator\"` and return zero.\n+\n+\n+Kernel dispatcher\n+-----------------\n+\n+* compute/exec.h\n+    * Defines variants of `CallFunction` which are the one-shot functions for invoking compute functions. A compute function should invoke `CallFunction` in its definition.\n+    * Defines `ExecContext` class\n+    * ScalarExecutor applies scalar function to batch\n+    * ExecBatchIterator::Make\n+\n+* `DispatchBest`\n+\n+* `FunctionRegistry` is the class representing a function registry. By default there is a single global registry where all kernels reside. `ExecContext` maintains a reference to the registry, if reference is NULL then the default registry is used.\n+\n+* aggregate_basic.cc, aggregate_basic_internal.h - example of passing options to kernel\n+    * scalaraggregator\n+\n+\n+Portable snippets for safe (integer) math\n+-----------------------------------------\n+\n+Arithmetic functions which can trigger integral overflow use the vendored library `portable_snippets` to perform \"safe math\" operations (e.g., arithmetic, logical shifts, casts).\n+Kernel implementations suffixed with `WithOverflow` need to be defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/util/int_util_internal.h for each primitive datatype supported. Use the helper macros of the form `*OPS_WITH_OVERFLOW` to automatically generate the definitions. This file also contains helper functions for performing safe integral arithmetic for the kernels' default variant.\n+\n+The short-hand name maps to the predefined operation names in https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h#L1028-L1033. For example, `OPS_WITH_OVERFLOW(AddWithOverflow, add)` uses short-hand name `add`.\n+\n+\n+Adding a new compute function\n+=============================\n+\n+This section describes the process for adding a new compute function and associated kernel implementations.\n+\n+First, you should identify the principal attributes of the new compute function.\n+The following series of steps help guide the design process.\n+\n+1. Decide on a unique name that fully represents the function's operation\n+\n+   Browse the [available compute functions](https://arrow.apache.org/docs/cpp/compute.html#available-functions) to prevent a name collision. Note that the long form of names is preferred, and multi-word names are allowed due to the fact that string versions use an underscore instead of whitespace and C++ function names use camel case convention.\n+     * What is a representative and unambiguous name for the operation performed by the compute function?\n+     * If a related or variant form of a compute function is to be added in the future, is the current name extensible or specific enough to allow room for clear differentiation? For example, `str_length` is not a good name because there are different types of strings, so in this case it is preferable to be specific with `ascii_length` and `utf8_length`.\n+\n+1. Identify the input/output types/shapes\n+    * What are the input types/shapes supported?\n+    * If multiple inputs are expected, are they the same type/shape?\n+\n+1. Identify the compute function \"kind\" based on its operation and #2.\n+    * Does the codebase of the \"kind\" provides full support for the new compute function?\n+        * If not, is it straightforward to add the missing parts or can the new compute function be supported by another \"kind\"?\n+\n+\n+Define compute function\n+-----------------------\n+\n+Add the compute function prototype and definition to the corresponding source files based on its \"kind\". For example the API of a \"Scalar\" function is found in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.h and its definition in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.cc.\n+\n+\n+\n+Define kernels of compute function\n+----------------------------------\n+\n+Define the kernel implementations in the corresponding source file based on the compute function's \"kind\" and category. For example, a \"Scalar\" arithmetic function has kernels defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernels/scalar_arithmetic.cc.\n+\n+Create compute function documentation (`FunctionDoc` object)\n+------------------------------------------------------------\n+\n+Each compute function has documentation which includes a summary, description, and argument types of its operation. A `FunctionDoc` object is instantiated and used in the registration step. Note that for compute functions that can overflow, another `FunctionDoc` is required for the `_checked` variant.\n+\n+Register kernels of compute function\n+------------------------------------\n+\n+1. Before registering the kernels, check that the available kernel generators support the `arity` and data types allowed for the new compute function. Kernel generators are not of the same form for all the kernel `kinds`. For example, in the \"Scalar Arithmetic\" kernels, registration functions have names of the form `MakeArithmeticFunction` and `MakeArithmeticFunctionNotNull`. If not available, you will need to define them for your particular case.\n+\n+1. Create the kernels by invoking the kernel generators.\n+\n+1. Register the kernels in the corresponding registry along with its `FunctionDoc`.\n+\n+\n+Testing\n+-------\n+\n+Arrow uses Google test framework. All kernels should have tests to ensure stability of the compute layer. Tests should at least cover ordinary inputs, corner cases, extreme values, nulls, different data types, and invalid tests. Moreover, there can be kernel-specific tests. For example, for arithmetic kernels, tests should include `NaN` and `Inf` inputs. The test files are located alongside the kernel source files and suffixed with `_test`. Tests are grouped by compute function `kind` and categories.\n+\n+`TYPED_TEST(test suite name, compute function)` - wrapper to define tests for the given compute function. The `test suite name` is associated with a set of data types that are used for the test suite (`TYPED_TEST_SUITE`). Tests from multiple compute functions can be placed in the same test suite. For example, `TYPED_TEST(TestBinaryArithmeticFloating, Sub)` and `TYPED_TEST(TestBinaryArithmeticFloating, Mul)`.\n+\n+Helpers\n+=======\n+\n+* `MakeArray` - convert a `Datum` to an ...\n+* `ArrayFromJSON(type_id, format string)` -  `ArrayFromJSON(float32, \"[1.3, 10.80, NaN, Inf, null]\")`\n+\n+\n+Benchmarking\n+------------\n+\n+\n+Example of Unary Arithmetic Function: Absolute Value\n+====================================================\n+\n+Identify the principal attributes.\n+\n+1. Name\n+    * String literal: \"absolute_value\"\n+    * C++ function names: `AbsoluteValue`\n+1. Input/output types: Numerical (signed and unsigned, integral and floating-point)\n+1. Input/output shapes: operate on scalars or element-wise for arrays\n+1. Kind: Scalar\n+    * Category: Arithmetic\n+1. Arity: Unary\n+\n+\n+Define compute function\n+-----------------------\n+\n+Add compute function's prototype to https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.h\n+\n+```C++\n+ARROW_EXPORT\n+Result<Datum> AbsoluteValue(const Datum& arg, ArithmeticOptions options = ArithmeticOptions(), ExecContext* ctx = NULLPTR);\n+```\n+\n+Add compute function's definition to https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.cc\n+Recall that \"Arithmetic\" functions create two kernel variants: default and overflow-checking. Therefore, we use the `SCALAR_ARITHMETIC_UNARY` macro which requires two function names (with and without \"_checked\" suffix).\n+\n+```C++\n+SCALAR_ARITHMETIC_UNARY(AbsoluteValue, \"absolute_value\", \"absolute_value_checked\")\n\nReview comment:\n       In general, please avoid use of macros like `SCALAR_ARITHMETIC_UNARY()` and other context specific helpers for this walk through, as they obscure the underlying C++ and require a user to look up the macro's definition to understand what they're writing.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-19T19:15:31.133+0000",
                    "updated": "2021-05-19T19:15:31.133+0000",
                    "started": "2021-05-19T19:15:31.133+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "599407",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/599411",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r635520473\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n\nReview comment:\n       In addition, please ensure that all your links are in the RST format. For example, to create a link to the doxygen doc for a specific class member, use:\r\n   ```rst\r\n    :member:`ScalarKernel::exec`\r\n   ```\r\n   \r\n   To create a link to a specific source file on the `master` branch, use:\r\n   ```rst\r\n   `The scalar API header <https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.h>`__\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-19T19:19:59.363+0000",
                    "updated": "2021-05-19T19:19:59.363+0000",
                    "started": "2021-05-19T19:19:59.363+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "599411",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/606202",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#issuecomment-854164867\n\n\n   This is a sort of confusion I had when I first started writing kernels. \r\n   _\"A 'scalar' is a single (non-array) element! But how come \"Scalar functions\" accept and produce arrays?\"_ \r\n   But now I understand, even though arrays are passed, the function is applied on each scalar in the array independently.\r\n   Do you this is something we'd want to explicitly discuss in the doc?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-03T20:42:39.206+0000",
                    "updated": "2021-06-03T20:42:39.206+0000",
                    "started": "2021-06-03T20:42:39.206+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "606202",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/606204",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera edited a comment on pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#issuecomment-854164867\n\n\n   This is a sort of confusion I had when I first started writing kernels. \r\n   _\"A 'scalar' is a single (non-array) element! But how come \"Scalar functions\" accept and produce arrays?\"_ \r\n   But now I understand, even though arrays are passed, the function is applied on each scalar in the array independently.\r\n   Do you this is something we'd want to explicitly discuss in the doc?\r\n   May be use an alternative jargon like, \"element-wise and vector functions\"?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-03T20:43:45.724+0000",
                    "updated": "2021-06-03T20:43:45.724+0000",
                    "started": "2021-06-03T20:43:45.723+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "606204",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/606243",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r645107090\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n\nReview comment:\n       Shall we add the comment by @pitrou in Zulip here. \r\n   ```\r\n   Simple questions for whether a function is a scalar function:\r\n   - Do all inputs have the same (broadcasted) length?\r\n   - Does the Nth element in the output only depend on the Nth element of each input?\r\n   ```\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are defined as `structs` with the same name as the compute function's API. These `structs` contain static *Call* methods representing the unique implementation for each argument signature. Apache Arrow conforms to SFINAE and aliased-template conditionals to generalize kernel implementations for different argument types. Also, kernel implementations can have the *constexpr* specifier if applicable.\n+\n+Function options\n+----------------\n+\n+[FunctionOptions](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE)\n+\n+\n+Function documentation\n+----------------------\n+\n+[FunctionDoc](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE)\n+\n+\n+Files and structures of the computer layer\n+==========================================\n+\n+This section describes the general structure of files/directory and principal code structures of the compute layer.\n+\n+* arrow/util/int_util_internal.h - defines utility functions\n+    * Function definitions suffixed with `WithOverflow` to support \"safe math\" for arithmetic kernels. Helper macros are included to create the definitions which invoke the corresponding operation in [`portable_snippets`](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h) library.\n+\n+* compute/api_scalar.h - contains\n+    * Subclasses of `FunctionOptions` for specific categories of compute functions\n+    * API/prototypes for all `Scalar` compute functions. Note that there is a single API version for each compute function.\n+* *compute/api_scalar.cc* - defines `Scalar` compute functions as wrappers over [\"CallFunction\"](https://arrow.apache.org/docs/cpp/api/compute.html?highlight=one%20shot#_CPPv412CallFunctionRKNSt6stringERKNSt6vectorI5DatumEEPK15FunctionOptionsP11ExecContext) (one-shot function). Arrow provides macros to easily define compute functions based on their `arity` and invocation mode.\n+    * Macros of the form `SCALAR_EAGER_*` invoke `CallFunction` directly and only require one function name.\n+    * Macros of the form `SCALAR_*` invoke `CallFunction` after checking for overflow and require two function names (default and `_checked` variant).\n+\n+* compute/kernels/scalar_arithmetic.cc - contains kernel definitions for \"Scalar Arithmetic\" compute functions. Kernel definitions are defined via a class with literal name of compute function and containing methods named `Call` that are parameterized for specific input types (signed/unsigned integer and floating-point).\n+    * For compute functions that may trigger overflow the \"checked\" variant is a class suffixed with `Checked` and makes use of assertions and overflow checks. If overflow occurs, kernel returns zero and sets that `Status*` error flag.\n+        * For compute functions that do not have a valid mathematical operation for specific datatypes (e.g., negate an unsigned integer), the kernel for those types is provided but should trigger an error with `DCHECK(false) << This is included only for the purposes of instantiability from the \"arithmetic kernel generator\"` and return zero.\n+\n+\n+Kernel dispatcher\n+-----------------\n+\n+* compute/exec.h\n+    * Defines variants of `CallFunction` which are the one-shot functions for invoking compute functions. A compute function should invoke `CallFunction` in its definition.\n+    * Defines `ExecContext` class\n+    * ScalarExecutor applies scalar function to batch\n+    * ExecBatchIterator::Make\n+\n+* `DispatchBest`\n+\n+* `FunctionRegistry` is the class representing a function registry. By default there is a single global registry where all kernels reside. `ExecContext` maintains a reference to the registry, if reference is NULL then the default registry is used.\n+\n+* aggregate_basic.cc, aggregate_basic_internal.h - example of passing options to kernel\n+    * scalaraggregator\n+\n+\n+Portable snippets for safe (integer) math\n+-----------------------------------------\n+\n+Arithmetic functions which can trigger integral overflow use the vendored library `portable_snippets` to perform \"safe math\" operations (e.g., arithmetic, logical shifts, casts).\n+Kernel implementations suffixed with `WithOverflow` need to be defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/util/int_util_internal.h for each primitive datatype supported. Use the helper macros of the form `*OPS_WITH_OVERFLOW` to automatically generate the definitions. This file also contains helper functions for performing safe integral arithmetic for the kernels' default variant.\n+\n+The short-hand name maps to the predefined operation names in https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h#L1028-L1033. For example, `OPS_WITH_OVERFLOW(AddWithOverflow, add)` uses short-hand name `add`.\n+\n+\n+Adding a new compute function\n+=============================\n+\n+This section describes the process for adding a new compute function and associated kernel implementations.\n+\n+First, you should identify the principal attributes of the new compute function.\n+The following series of steps help guide the design process.\n+\n+1. Decide on a unique name that fully represents the function's operation\n+\n+   Browse the [available compute functions](https://arrow.apache.org/docs/cpp/compute.html#available-functions) to prevent a name collision. Note that the long form of names is preferred, and multi-word names are allowed due to the fact that string versions use an underscore instead of whitespace and C++ function names use camel case convention.\n+     * What is a representative and unambiguous name for the operation performed by the compute function?\n+     * If a related or variant form of a compute function is to be added in the future, is the current name extensible or specific enough to allow room for clear differentiation? For example, `str_length` is not a good name because there are different types of strings, so in this case it is preferable to be specific with `ascii_length` and `utf8_length`.\n+\n+1. Identify the input/output types/shapes\n+    * What are the input types/shapes supported?\n+    * If multiple inputs are expected, are they the same type/shape?\n+\n+1. Identify the compute function \"kind\" based on its operation and #2.\n+    * Does the codebase of the \"kind\" provides full support for the new compute function?\n+        * If not, is it straightforward to add the missing parts or can the new compute function be supported by another \"kind\"?\n+\n+\n+Define compute function\n+-----------------------\n+\n+Add the compute function prototype and definition to the corresponding source files based on its \"kind\". For example the API of a \"Scalar\" function is found in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.h and its definition in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.cc.\n+\n+\n+\n+Define kernels of compute function\n+----------------------------------\n+\n+Define the kernel implementations in the corresponding source file based on the compute function's \"kind\" and category. For example, a \"Scalar\" arithmetic function has kernels defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernels/scalar_arithmetic.cc.\n+\n+Create compute function documentation (`FunctionDoc` object)\n+------------------------------------------------------------\n+\n+Each compute function has documentation which includes a summary, description, and argument types of its operation. A `FunctionDoc` object is instantiated and used in the registration step. Note that for compute functions that can overflow, another `FunctionDoc` is required for the `_checked` variant.\n+\n+Register kernels of compute function\n+------------------------------------\n+\n+1. Before registering the kernels, check that the available kernel generators support the `arity` and data types allowed for the new compute function. Kernel generators are not of the same form for all the kernel `kinds`. For example, in the \"Scalar Arithmetic\" kernels, registration functions have names of the form `MakeArithmeticFunction` and `MakeArithmeticFunctionNotNull`. If not available, you will need to define them for your particular case.\n+\n+1. Create the kernels by invoking the kernel generators.\n+\n+1. Register the kernels in the corresponding registry along with its `FunctionDoc`.\n+\n+\n+Testing\n+-------\n+\n+Arrow uses Google test framework. All kernels should have tests to ensure stability of the compute layer. Tests should at least cover ordinary inputs, corner cases, extreme values, nulls, different data types, and invalid tests. Moreover, there can be kernel-specific tests. For example, for arithmetic kernels, tests should include `NaN` and `Inf` inputs. The test files are located alongside the kernel source files and suffixed with `_test`. Tests are grouped by compute function `kind` and categories.\n+\n+`TYPED_TEST(test suite name, compute function)` - wrapper to define tests for the given compute function. The `test suite name` is associated with a set of data types that are used for the test suite (`TYPED_TEST_SUITE`). Tests from multiple compute functions can be placed in the same test suite. For example, `TYPED_TEST(TestBinaryArithmeticFloating, Sub)` and `TYPED_TEST(TestBinaryArithmeticFloating, Mul)`.\n+\n\nReview comment:\n       Shall we also add untyped test fixtures (`TEST_F`s)?\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are simple ``structs`` containing only function pointers (the \"methods\" of the kernel) and attribute flags. Each function kind corresponds to a class of Kernel with methods representing each stage of the function's execution. For example, :struct:`ScalarKernel` includes (optionally) :member:`ScalarKernel::init` to initialize any state necessary for execution and :member:`ScalarKernel::exec` to perform the computation.\n+\n+Since many kernels are closely related in operation and differ only in their input types, it's frequently useful to leverage c++'s powerful template system to efficiently generate kernels' methods. For example, the \"add\" compute function accepts all numeric types and its kernels' methods are instantiations of the same function template.\n+\n+Function options\n+----------------\n+\n+[FunctionOptions](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE)\n+\n+\n+Function documentation\n+----------------------\n+\n+[FunctionDoc](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE)\n+\n+\n+Files and structures of the computer layer\n+==========================================\n+\n+This section describes the general structure of files/directory and principal code structures of the compute layer.\n+\n+* arrow/util/int_util_internal.h - defines utility functions\n+    * Function definitions suffixed with `WithOverflow` to support \"safe math\" for arithmetic kernels. Helper macros are included to create the definitions which invoke the corresponding operation in [`portable_snippets`](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h) library.\n+\n+* compute/api_scalar.h - contains\n+    * Subclasses of `FunctionOptions` for specific categories of compute functions\n+    * API/prototypes for all `Scalar` compute functions. Note that there is a single API version for each compute function.\n+* *compute/api_scalar.cc* - defines `Scalar` compute functions as wrappers over [\"CallFunction\"](https://arrow.apache.org/docs/cpp/api/compute.html?highlight=one%20shot#_CPPv412CallFunctionRKNSt6stringERKNSt6vectorI5DatumEEPK15FunctionOptionsP11ExecContext) (one-shot function). Arrow provides macros to easily define compute functions based on their `arity` and invocation mode.\n+    * Macros of the form `SCALAR_EAGER_*` invoke `CallFunction` directly and only require one function name.\n+    * Macros of the form `SCALAR_*` invoke `CallFunction` after checking for overflow and require two function names (default and `_checked` variant).\n+\n+* compute/kernels/scalar_arithmetic.cc - contains kernel definitions for \"Scalar Arithmetic\" compute functions. Kernel definitions are defined via a class with literal name of compute function and containing methods named `Call` that are parameterized for specific input types (signed/unsigned integer and floating-point).\n+    * For compute functions that may trigger overflow the \"checked\" variant is a class suffixed with `Checked` and makes use of assertions and overflow checks. If overflow occurs, kernel returns zero and sets that `Status*` error flag.\n+        * For compute functions that do not have a valid mathematical operation for specific datatypes (e.g., negate an unsigned integer), the kernel for those types is provided but should trigger an error with `DCHECK(false) << This is included only for the purposes of instantiability from the \"arithmetic kernel generator\"` and return zero.\n+\n+\n+Kernel dispatcher\n+-----------------\n+\n+* compute/exec.h\n+    * Defines variants of `CallFunction` which are the one-shot functions for invoking compute functions. A compute function should invoke `CallFunction` in its definition.\n+    * Defines `ExecContext` class\n+    * ScalarExecutor applies scalar function to batch\n+    * ExecBatchIterator::Make\n+\n+* `DispatchBest`\n+\n+* `FunctionRegistry` is the class representing a function registry. By default there is a single global registry where all kernels reside. `ExecContext` maintains a reference to the registry, if reference is NULL then the default registry is used.\n+\n+* aggregate_basic.cc, aggregate_basic_internal.h - example of passing options to kernel\n+    * scalaraggregator\n+\n+\n+Portable snippets for safe (integer) math\n+-----------------------------------------\n+\n+Arithmetic functions which can trigger integral overflow use the vendored library `portable_snippets` to perform \"safe math\" operations (e.g., arithmetic, logical shifts, casts).\n+Kernel implementations suffixed with `WithOverflow` need to be defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/util/int_util_internal.h for each primitive datatype supported. Use the helper macros of the form `*OPS_WITH_OVERFLOW` to automatically generate the definitions. This file also contains helper functions for performing safe integral arithmetic for the kernels' default variant.\n+\n+The short-hand name maps to the predefined operation names in https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h#L1028-L1033. For example, `OPS_WITH_OVERFLOW(AddWithOverflow, add)` uses short-hand name `add`.\n+\n+\n+Adding a new compute function\n+=============================\n+\n+This section describes the process for adding a new compute function and associated kernel implementations.\n+\n+First, you should identify the principal attributes of the new compute function.\n+The following series of steps help guide the design process.\n+\n+1. Decide on a unique name that fully represents the function's operation\n+\n+   Browse the [available compute functions](https://arrow.apache.org/docs/cpp/compute.html#available-functions) to prevent a name collision. Note that the long form of names is preferred, and multi-word names are allowed due to the fact that string versions use an underscore instead of whitespace and C++ function names use camel case convention.\n+     * What is a representative and unambiguous name for the operation performed by the compute function?\n+     * If a related or variant form of a compute function is to be added in the future, is the current name extensible or specific enough to allow room for clear differentiation? For example, `str_length` is not a good name because there are different types of strings, so in this case it is preferable to be specific with `ascii_length` and `utf8_length`.\n+\n+1. Identify the input/output types/shapes\n+    * What are the input types/shapes supported?\n+    * If multiple inputs are expected, are they the same type/shape?\n+\n+1. Identify the compute function \"kind\" based on its operation and #2.\n+    * Does the codebase of the \"kind\" provides full support for the new compute function?\n+        * If not, is it straightforward to add the missing parts or can the new compute function be supported by another \"kind\"?\n+\n+\n+Define compute function\n+-----------------------\n+\n+Add the compute function prototype and definition to the corresponding source files based on its \"kind\". For example the API of a \"Scalar\" function is found in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.h and its definition in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.cc.\n+\n+\n+\n+Define kernels of compute function\n+----------------------------------\n+\n+Define the kernel implementations in the corresponding source file based on the compute function's \"kind\" and category. For example, a \"Scalar\" arithmetic function has kernels defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernels/scalar_arithmetic.cc.\n+\n+Create compute function documentation (`FunctionDoc` object)\n+------------------------------------------------------------\n+\n+Each compute function has documentation which includes a summary, description, and argument types of its operation. A `FunctionDoc` object is instantiated and used in the registration step. Note that for compute functions that can overflow, another `FunctionDoc` is required for the `_checked` variant.\n+\n+Register kernels of compute function\n+------------------------------------\n+\n+1. Before registering the kernels, check that the available kernel generators support the `arity` and data types allowed for the new compute function. Kernel generators are not of the same form for all the kernel `kinds`. For example, in the \"Scalar Arithmetic\" kernels, registration functions have names of the form `MakeArithmeticFunction` and `MakeArithmeticFunctionNotNull`. If not available, you will need to define them for your particular case.\n+\n+1. Create the kernels by invoking the kernel generators.\n+\n+1. Register the kernels in the corresponding registry along with its `FunctionDoc`.\n+\n+\n+Testing\n+-------\n+\n+Arrow uses Google test framework. All kernels should have tests to ensure stability of the compute layer. Tests should at least cover ordinary inputs, corner cases, extreme values, nulls, different data types, and invalid tests. Moreover, there can be kernel-specific tests. For example, for arithmetic kernels, tests should include `NaN` and `Inf` inputs. The test files are located alongside the kernel source files and suffixed with `_test`. Tests are grouped by compute function `kind` and categories.\n+\n+`TYPED_TEST(test suite name, compute function)` - wrapper to define tests for the given compute function. The `test suite name` is associated with a set of data types that are used for the test suite (`TYPED_TEST_SUITE`). Tests from multiple compute functions can be placed in the same test suite. For example, `TYPED_TEST(TestBinaryArithmeticFloating, Sub)` and `TYPED_TEST(TestBinaryArithmeticFloating, Mul)`.\n+\n+Helpers\n+=======\n\nReview comment:\n       I think it'd be nicer if we could discuss about some helper methods in `codegen_internal.h`.\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are simple ``structs`` containing only function pointers (the \"methods\" of the kernel) and attribute flags. Each function kind corresponds to a class of Kernel with methods representing each stage of the function's execution. For example, :struct:`ScalarKernel` includes (optionally) :member:`ScalarKernel::init` to initialize any state necessary for execution and :member:`ScalarKernel::exec` to perform the computation.\n+\n+Since many kernels are closely related in operation and differ only in their input types, it's frequently useful to leverage c++'s powerful template system to efficiently generate kernels' methods. For example, the \"add\" compute function accepts all numeric types and its kernels' methods are instantiations of the same function template.\n+\n+Function options\n+----------------\n+\n+[FunctionOptions](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE)\n+\n+\n+Function documentation\n+----------------------\n+\n+[FunctionDoc](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE)\n+\n+\n+Files and structures of the computer layer\n+==========================================\n+\n+This section describes the general structure of files/directory and principal code structures of the compute layer.\n+\n+* arrow/util/int_util_internal.h - defines utility functions\n+    * Function definitions suffixed with `WithOverflow` to support \"safe math\" for arithmetic kernels. Helper macros are included to create the definitions which invoke the corresponding operation in [`portable_snippets`](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h) library.\n+\n+* compute/api_scalar.h - contains\n+    * Subclasses of `FunctionOptions` for specific categories of compute functions\n+    * API/prototypes for all `Scalar` compute functions. Note that there is a single API version for each compute function.\n+* *compute/api_scalar.cc* - defines `Scalar` compute functions as wrappers over [\"CallFunction\"](https://arrow.apache.org/docs/cpp/api/compute.html?highlight=one%20shot#_CPPv412CallFunctionRKNSt6stringERKNSt6vectorI5DatumEEPK15FunctionOptionsP11ExecContext) (one-shot function). Arrow provides macros to easily define compute functions based on their `arity` and invocation mode.\n+    * Macros of the form `SCALAR_EAGER_*` invoke `CallFunction` directly and only require one function name.\n+    * Macros of the form `SCALAR_*` invoke `CallFunction` after checking for overflow and require two function names (default and `_checked` variant).\n+\n+* compute/kernels/scalar_arithmetic.cc - contains kernel definitions for \"Scalar Arithmetic\" compute functions. Kernel definitions are defined via a class with literal name of compute function and containing methods named `Call` that are parameterized for specific input types (signed/unsigned integer and floating-point).\n+    * For compute functions that may trigger overflow the \"checked\" variant is a class suffixed with `Checked` and makes use of assertions and overflow checks. If overflow occurs, kernel returns zero and sets that `Status*` error flag.\n+        * For compute functions that do not have a valid mathematical operation for specific datatypes (e.g., negate an unsigned integer), the kernel for those types is provided but should trigger an error with `DCHECK(false) << This is included only for the purposes of instantiability from the \"arithmetic kernel generator\"` and return zero.\n+\n\nReview comment:\n       I think we should discuss the guarantees provided by the `compute` infrastructure as well. \r\n   ex: for scalar functions, if multiple arrays are passed, the compute infrastructure checks for nullity, guarantees that they are of same size, etc\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-03T21:53:27.840+0000",
                    "updated": "2021-06-03T21:53:27.840+0000",
                    "started": "2021-06-03T21:53:27.840+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "606243",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/606485",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r645107090\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n\nReview comment:\n       Shall we add the comment by @pitrou in Zulip here. \r\n   ```\r\n   Simple questions for whether a function is a scalar function:\r\n   - Do all inputs have the same (broadcasted) length?\r\n   - Does the Nth element in the output only depend on the Nth element of each input?\r\n   ```\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are defined as `structs` with the same name as the compute function's API. These `structs` contain static *Call* methods representing the unique implementation for each argument signature. Apache Arrow conforms to SFINAE and aliased-template conditionals to generalize kernel implementations for different argument types. Also, kernel implementations can have the *constexpr* specifier if applicable.\n+\n+Function options\n+----------------\n+\n+[FunctionOptions](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE)\n+\n+\n+Function documentation\n+----------------------\n+\n+[FunctionDoc](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE)\n+\n+\n+Files and structures of the computer layer\n+==========================================\n+\n+This section describes the general structure of files/directory and principal code structures of the compute layer.\n+\n+* arrow/util/int_util_internal.h - defines utility functions\n+    * Function definitions suffixed with `WithOverflow` to support \"safe math\" for arithmetic kernels. Helper macros are included to create the definitions which invoke the corresponding operation in [`portable_snippets`](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h) library.\n+\n+* compute/api_scalar.h - contains\n+    * Subclasses of `FunctionOptions` for specific categories of compute functions\n+    * API/prototypes for all `Scalar` compute functions. Note that there is a single API version for each compute function.\n+* *compute/api_scalar.cc* - defines `Scalar` compute functions as wrappers over [\"CallFunction\"](https://arrow.apache.org/docs/cpp/api/compute.html?highlight=one%20shot#_CPPv412CallFunctionRKNSt6stringERKNSt6vectorI5DatumEEPK15FunctionOptionsP11ExecContext) (one-shot function). Arrow provides macros to easily define compute functions based on their `arity` and invocation mode.\n+    * Macros of the form `SCALAR_EAGER_*` invoke `CallFunction` directly and only require one function name.\n+    * Macros of the form `SCALAR_*` invoke `CallFunction` after checking for overflow and require two function names (default and `_checked` variant).\n+\n+* compute/kernels/scalar_arithmetic.cc - contains kernel definitions for \"Scalar Arithmetic\" compute functions. Kernel definitions are defined via a class with literal name of compute function and containing methods named `Call` that are parameterized for specific input types (signed/unsigned integer and floating-point).\n+    * For compute functions that may trigger overflow the \"checked\" variant is a class suffixed with `Checked` and makes use of assertions and overflow checks. If overflow occurs, kernel returns zero and sets that `Status*` error flag.\n+        * For compute functions that do not have a valid mathematical operation for specific datatypes (e.g., negate an unsigned integer), the kernel for those types is provided but should trigger an error with `DCHECK(false) << This is included only for the purposes of instantiability from the \"arithmetic kernel generator\"` and return zero.\n+\n+\n+Kernel dispatcher\n+-----------------\n+\n+* compute/exec.h\n+    * Defines variants of `CallFunction` which are the one-shot functions for invoking compute functions. A compute function should invoke `CallFunction` in its definition.\n+    * Defines `ExecContext` class\n+    * ScalarExecutor applies scalar function to batch\n+    * ExecBatchIterator::Make\n+\n+* `DispatchBest`\n+\n+* `FunctionRegistry` is the class representing a function registry. By default there is a single global registry where all kernels reside. `ExecContext` maintains a reference to the registry, if reference is NULL then the default registry is used.\n+\n+* aggregate_basic.cc, aggregate_basic_internal.h - example of passing options to kernel\n+    * scalaraggregator\n+\n+\n+Portable snippets for safe (integer) math\n+-----------------------------------------\n+\n+Arithmetic functions which can trigger integral overflow use the vendored library `portable_snippets` to perform \"safe math\" operations (e.g., arithmetic, logical shifts, casts).\n+Kernel implementations suffixed with `WithOverflow` need to be defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/util/int_util_internal.h for each primitive datatype supported. Use the helper macros of the form `*OPS_WITH_OVERFLOW` to automatically generate the definitions. This file also contains helper functions for performing safe integral arithmetic for the kernels' default variant.\n+\n+The short-hand name maps to the predefined operation names in https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h#L1028-L1033. For example, `OPS_WITH_OVERFLOW(AddWithOverflow, add)` uses short-hand name `add`.\n+\n+\n+Adding a new compute function\n+=============================\n+\n+This section describes the process for adding a new compute function and associated kernel implementations.\n+\n+First, you should identify the principal attributes of the new compute function.\n+The following series of steps help guide the design process.\n+\n+1. Decide on a unique name that fully represents the function's operation\n+\n+   Browse the [available compute functions](https://arrow.apache.org/docs/cpp/compute.html#available-functions) to prevent a name collision. Note that the long form of names is preferred, and multi-word names are allowed due to the fact that string versions use an underscore instead of whitespace and C++ function names use camel case convention.\n+     * What is a representative and unambiguous name for the operation performed by the compute function?\n+     * If a related or variant form of a compute function is to be added in the future, is the current name extensible or specific enough to allow room for clear differentiation? For example, `str_length` is not a good name because there are different types of strings, so in this case it is preferable to be specific with `ascii_length` and `utf8_length`.\n+\n+1. Identify the input/output types/shapes\n+    * What are the input types/shapes supported?\n+    * If multiple inputs are expected, are they the same type/shape?\n+\n+1. Identify the compute function \"kind\" based on its operation and #2.\n+    * Does the codebase of the \"kind\" provides full support for the new compute function?\n+        * If not, is it straightforward to add the missing parts or can the new compute function be supported by another \"kind\"?\n+\n+\n+Define compute function\n+-----------------------\n+\n+Add the compute function prototype and definition to the corresponding source files based on its \"kind\". For example the API of a \"Scalar\" function is found in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.h and its definition in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.cc.\n+\n+\n+\n+Define kernels of compute function\n+----------------------------------\n+\n+Define the kernel implementations in the corresponding source file based on the compute function's \"kind\" and category. For example, a \"Scalar\" arithmetic function has kernels defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernels/scalar_arithmetic.cc.\n+\n+Create compute function documentation (`FunctionDoc` object)\n+------------------------------------------------------------\n+\n+Each compute function has documentation which includes a summary, description, and argument types of its operation. A `FunctionDoc` object is instantiated and used in the registration step. Note that for compute functions that can overflow, another `FunctionDoc` is required for the `_checked` variant.\n+\n+Register kernels of compute function\n+------------------------------------\n+\n+1. Before registering the kernels, check that the available kernel generators support the `arity` and data types allowed for the new compute function. Kernel generators are not of the same form for all the kernel `kinds`. For example, in the \"Scalar Arithmetic\" kernels, registration functions have names of the form `MakeArithmeticFunction` and `MakeArithmeticFunctionNotNull`. If not available, you will need to define them for your particular case.\n+\n+1. Create the kernels by invoking the kernel generators.\n+\n+1. Register the kernels in the corresponding registry along with its `FunctionDoc`.\n+\n+\n+Testing\n+-------\n+\n+Arrow uses Google test framework. All kernels should have tests to ensure stability of the compute layer. Tests should at least cover ordinary inputs, corner cases, extreme values, nulls, different data types, and invalid tests. Moreover, there can be kernel-specific tests. For example, for arithmetic kernels, tests should include `NaN` and `Inf` inputs. The test files are located alongside the kernel source files and suffixed with `_test`. Tests are grouped by compute function `kind` and categories.\n+\n+`TYPED_TEST(test suite name, compute function)` - wrapper to define tests for the given compute function. The `test suite name` is associated with a set of data types that are used for the test suite (`TYPED_TEST_SUITE`). Tests from multiple compute functions can be placed in the same test suite. For example, `TYPED_TEST(TestBinaryArithmeticFloating, Sub)` and `TYPED_TEST(TestBinaryArithmeticFloating, Mul)`.\n+\n\nReview comment:\n       Shall we also add untyped test fixtures (`TEST_F`s)?\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are simple ``structs`` containing only function pointers (the \"methods\" of the kernel) and attribute flags. Each function kind corresponds to a class of Kernel with methods representing each stage of the function's execution. For example, :struct:`ScalarKernel` includes (optionally) :member:`ScalarKernel::init` to initialize any state necessary for execution and :member:`ScalarKernel::exec` to perform the computation.\n+\n+Since many kernels are closely related in operation and differ only in their input types, it's frequently useful to leverage c++'s powerful template system to efficiently generate kernels' methods. For example, the \"add\" compute function accepts all numeric types and its kernels' methods are instantiations of the same function template.\n+\n+Function options\n+----------------\n+\n+[FunctionOptions](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE)\n+\n+\n+Function documentation\n+----------------------\n+\n+[FunctionDoc](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE)\n+\n+\n+Files and structures of the computer layer\n+==========================================\n+\n+This section describes the general structure of files/directory and principal code structures of the compute layer.\n+\n+* arrow/util/int_util_internal.h - defines utility functions\n+    * Function definitions suffixed with `WithOverflow` to support \"safe math\" for arithmetic kernels. Helper macros are included to create the definitions which invoke the corresponding operation in [`portable_snippets`](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h) library.\n+\n+* compute/api_scalar.h - contains\n+    * Subclasses of `FunctionOptions` for specific categories of compute functions\n+    * API/prototypes for all `Scalar` compute functions. Note that there is a single API version for each compute function.\n+* *compute/api_scalar.cc* - defines `Scalar` compute functions as wrappers over [\"CallFunction\"](https://arrow.apache.org/docs/cpp/api/compute.html?highlight=one%20shot#_CPPv412CallFunctionRKNSt6stringERKNSt6vectorI5DatumEEPK15FunctionOptionsP11ExecContext) (one-shot function). Arrow provides macros to easily define compute functions based on their `arity` and invocation mode.\n+    * Macros of the form `SCALAR_EAGER_*` invoke `CallFunction` directly and only require one function name.\n+    * Macros of the form `SCALAR_*` invoke `CallFunction` after checking for overflow and require two function names (default and `_checked` variant).\n+\n+* compute/kernels/scalar_arithmetic.cc - contains kernel definitions for \"Scalar Arithmetic\" compute functions. Kernel definitions are defined via a class with literal name of compute function and containing methods named `Call` that are parameterized for specific input types (signed/unsigned integer and floating-point).\n+    * For compute functions that may trigger overflow the \"checked\" variant is a class suffixed with `Checked` and makes use of assertions and overflow checks. If overflow occurs, kernel returns zero and sets that `Status*` error flag.\n+        * For compute functions that do not have a valid mathematical operation for specific datatypes (e.g., negate an unsigned integer), the kernel for those types is provided but should trigger an error with `DCHECK(false) << This is included only for the purposes of instantiability from the \"arithmetic kernel generator\"` and return zero.\n+\n+\n+Kernel dispatcher\n+-----------------\n+\n+* compute/exec.h\n+    * Defines variants of `CallFunction` which are the one-shot functions for invoking compute functions. A compute function should invoke `CallFunction` in its definition.\n+    * Defines `ExecContext` class\n+    * ScalarExecutor applies scalar function to batch\n+    * ExecBatchIterator::Make\n+\n+* `DispatchBest`\n+\n+* `FunctionRegistry` is the class representing a function registry. By default there is a single global registry where all kernels reside. `ExecContext` maintains a reference to the registry, if reference is NULL then the default registry is used.\n+\n+* aggregate_basic.cc, aggregate_basic_internal.h - example of passing options to kernel\n+    * scalaraggregator\n+\n+\n+Portable snippets for safe (integer) math\n+-----------------------------------------\n+\n+Arithmetic functions which can trigger integral overflow use the vendored library `portable_snippets` to perform \"safe math\" operations (e.g., arithmetic, logical shifts, casts).\n+Kernel implementations suffixed with `WithOverflow` need to be defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/util/int_util_internal.h for each primitive datatype supported. Use the helper macros of the form `*OPS_WITH_OVERFLOW` to automatically generate the definitions. This file also contains helper functions for performing safe integral arithmetic for the kernels' default variant.\n+\n+The short-hand name maps to the predefined operation names in https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h#L1028-L1033. For example, `OPS_WITH_OVERFLOW(AddWithOverflow, add)` uses short-hand name `add`.\n+\n+\n+Adding a new compute function\n+=============================\n+\n+This section describes the process for adding a new compute function and associated kernel implementations.\n+\n+First, you should identify the principal attributes of the new compute function.\n+The following series of steps help guide the design process.\n+\n+1. Decide on a unique name that fully represents the function's operation\n+\n+   Browse the [available compute functions](https://arrow.apache.org/docs/cpp/compute.html#available-functions) to prevent a name collision. Note that the long form of names is preferred, and multi-word names are allowed due to the fact that string versions use an underscore instead of whitespace and C++ function names use camel case convention.\n+     * What is a representative and unambiguous name for the operation performed by the compute function?\n+     * If a related or variant form of a compute function is to be added in the future, is the current name extensible or specific enough to allow room for clear differentiation? For example, `str_length` is not a good name because there are different types of strings, so in this case it is preferable to be specific with `ascii_length` and `utf8_length`.\n+\n+1. Identify the input/output types/shapes\n+    * What are the input types/shapes supported?\n+    * If multiple inputs are expected, are they the same type/shape?\n+\n+1. Identify the compute function \"kind\" based on its operation and #2.\n+    * Does the codebase of the \"kind\" provides full support for the new compute function?\n+        * If not, is it straightforward to add the missing parts or can the new compute function be supported by another \"kind\"?\n+\n+\n+Define compute function\n+-----------------------\n+\n+Add the compute function prototype and definition to the corresponding source files based on its \"kind\". For example the API of a \"Scalar\" function is found in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.h and its definition in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.cc.\n+\n+\n+\n+Define kernels of compute function\n+----------------------------------\n+\n+Define the kernel implementations in the corresponding source file based on the compute function's \"kind\" and category. For example, a \"Scalar\" arithmetic function has kernels defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernels/scalar_arithmetic.cc.\n+\n+Create compute function documentation (`FunctionDoc` object)\n+------------------------------------------------------------\n+\n+Each compute function has documentation which includes a summary, description, and argument types of its operation. A `FunctionDoc` object is instantiated and used in the registration step. Note that for compute functions that can overflow, another `FunctionDoc` is required for the `_checked` variant.\n+\n+Register kernels of compute function\n+------------------------------------\n+\n+1. Before registering the kernels, check that the available kernel generators support the `arity` and data types allowed for the new compute function. Kernel generators are not of the same form for all the kernel `kinds`. For example, in the \"Scalar Arithmetic\" kernels, registration functions have names of the form `MakeArithmeticFunction` and `MakeArithmeticFunctionNotNull`. If not available, you will need to define them for your particular case.\n+\n+1. Create the kernels by invoking the kernel generators.\n+\n+1. Register the kernels in the corresponding registry along with its `FunctionDoc`.\n+\n+\n+Testing\n+-------\n+\n+Arrow uses Google test framework. All kernels should have tests to ensure stability of the compute layer. Tests should at least cover ordinary inputs, corner cases, extreme values, nulls, different data types, and invalid tests. Moreover, there can be kernel-specific tests. For example, for arithmetic kernels, tests should include `NaN` and `Inf` inputs. The test files are located alongside the kernel source files and suffixed with `_test`. Tests are grouped by compute function `kind` and categories.\n+\n+`TYPED_TEST(test suite name, compute function)` - wrapper to define tests for the given compute function. The `test suite name` is associated with a set of data types that are used for the test suite (`TYPED_TEST_SUITE`). Tests from multiple compute functions can be placed in the same test suite. For example, `TYPED_TEST(TestBinaryArithmeticFloating, Sub)` and `TYPED_TEST(TestBinaryArithmeticFloating, Mul)`.\n+\n+Helpers\n+=======\n\nReview comment:\n       I think it'd be nicer if we could discuss about some helper methods in `codegen_internal.h`.\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are simple ``structs`` containing only function pointers (the \"methods\" of the kernel) and attribute flags. Each function kind corresponds to a class of Kernel with methods representing each stage of the function's execution. For example, :struct:`ScalarKernel` includes (optionally) :member:`ScalarKernel::init` to initialize any state necessary for execution and :member:`ScalarKernel::exec` to perform the computation.\n+\n+Since many kernels are closely related in operation and differ only in their input types, it's frequently useful to leverage c++'s powerful template system to efficiently generate kernels' methods. For example, the \"add\" compute function accepts all numeric types and its kernels' methods are instantiations of the same function template.\n+\n+Function options\n+----------------\n+\n+[FunctionOptions](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE)\n+\n+\n+Function documentation\n+----------------------\n+\n+[FunctionDoc](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE)\n+\n+\n+Files and structures of the computer layer\n+==========================================\n+\n+This section describes the general structure of files/directory and principal code structures of the compute layer.\n+\n+* arrow/util/int_util_internal.h - defines utility functions\n+    * Function definitions suffixed with `WithOverflow` to support \"safe math\" for arithmetic kernels. Helper macros are included to create the definitions which invoke the corresponding operation in [`portable_snippets`](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h) library.\n+\n+* compute/api_scalar.h - contains\n+    * Subclasses of `FunctionOptions` for specific categories of compute functions\n+    * API/prototypes for all `Scalar` compute functions. Note that there is a single API version for each compute function.\n+* *compute/api_scalar.cc* - defines `Scalar` compute functions as wrappers over [\"CallFunction\"](https://arrow.apache.org/docs/cpp/api/compute.html?highlight=one%20shot#_CPPv412CallFunctionRKNSt6stringERKNSt6vectorI5DatumEEPK15FunctionOptionsP11ExecContext) (one-shot function). Arrow provides macros to easily define compute functions based on their `arity` and invocation mode.\n+    * Macros of the form `SCALAR_EAGER_*` invoke `CallFunction` directly and only require one function name.\n+    * Macros of the form `SCALAR_*` invoke `CallFunction` after checking for overflow and require two function names (default and `_checked` variant).\n+\n+* compute/kernels/scalar_arithmetic.cc - contains kernel definitions for \"Scalar Arithmetic\" compute functions. Kernel definitions are defined via a class with literal name of compute function and containing methods named `Call` that are parameterized for specific input types (signed/unsigned integer and floating-point).\n+    * For compute functions that may trigger overflow the \"checked\" variant is a class suffixed with `Checked` and makes use of assertions and overflow checks. If overflow occurs, kernel returns zero and sets that `Status*` error flag.\n+        * For compute functions that do not have a valid mathematical operation for specific datatypes (e.g., negate an unsigned integer), the kernel for those types is provided but should trigger an error with `DCHECK(false) << This is included only for the purposes of instantiability from the \"arithmetic kernel generator\"` and return zero.\n+\n\nReview comment:\n       I think we should discuss the guarantees provided by the `compute` infrastructure as well. \r\n   ex: for scalar functions, if multiple arrays are passed, the compute infrastructure checks for nullity, guarantees that they are of same size, etc\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-04T07:48:49.044+0000",
                    "updated": "2021-06-04T07:48:49.044+0000",
                    "started": "2021-06-04T07:48:49.044+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "606485",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/606588",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#issuecomment-854164867\n\n\n   This is a sort of confusion I had when I first started writing kernels. \r\n   _\"A 'scalar' is a single (non-array) element! But how come \"Scalar functions\" accept and produce arrays?\"_ \r\n   But now I understand, even though arrays are passed, the function is applied on each scalar in the array independently.\r\n   Do you this is something we'd want to explicitly discuss in the doc?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-04T08:01:14.984+0000",
                    "updated": "2021-06-04T08:01:14.984+0000",
                    "started": "2021-06-04T08:01:14.984+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "606588",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/606822",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera edited a comment on pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#issuecomment-854164867\n\n\n   This is a sort of confusion I had when I first started writing kernels. \r\n   _\"A 'scalar' is a single (non-array) element! But how come \"Scalar functions\" accept and produce arrays?\"_ \r\n   But now I understand, even though arrays are passed, the function is applied on each scalar in the array independently.\r\n   Do you this is something we'd want to explicitly discuss in the doc?\r\n   May be use an alternative jargon like, \"element-wise and vector functions\"?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-04T08:27:45.557+0000",
                    "updated": "2021-06-04T08:27:45.557+0000",
                    "started": "2021-06-04T08:27:45.557+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "606822",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/701748",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkmgit commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r776153562\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,421 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are defined as `structs` with the same name as the compute function's API. These `structs` contain static *Call* methods representing the unique implementation for each argument signature. Apache Arrow conforms to SFINAE and aliased-template conditionals to generalize kernel implementations for different argument types. Also, kernel implementations can have the *constexpr* specifier if applicable.\n+\n+Function options\n+----------------\n+\n+[FunctionOptions](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE)\n+\n+\n+Function documentation\n+----------------------\n+\n+[FunctionDoc](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE)\n+\n+\n+Files and structures of the computer layer\n+==========================================\n+\n+This section describes the general structure of files/directory and principal code structures of the compute layer.\n+\n+* arrow/util/int_util_internal.h - defines utility functions\n+    * Function definitions suffixed with `WithOverflow` to support \"safe math\" for arithmetic kernels. Helper macros are included to create the definitions which invoke the corresponding operation in [`portable_snippets`](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h) library.\n+\n+* compute/api_scalar.h - contains\n+    * Subclasses of `FunctionOptions` for specific categories of compute functions\n+    * API/prototypes for all `Scalar` compute functions. Note that there is a single API version for each compute function.\n+* *compute/api_scalar.cc* - defines `Scalar` compute functions as wrappers over [\"CallFunction\"](https://arrow.apache.org/docs/cpp/api/compute.html?highlight=one%20shot#_CPPv412CallFunctionRKNSt6stringERKNSt6vectorI5DatumEEPK15FunctionOptionsP11ExecContext) (one-shot function). Arrow provides macros to easily define compute functions based on their `arity` and invocation mode.\n+    * Macros of the form `SCALAR_EAGER_*` invoke `CallFunction` directly and only require one function name.\n+    * Macros of the form `SCALAR_*` invoke `CallFunction` after checking for overflow and require two function names (default and `_checked` variant).\n+\n+* compute/kernels/scalar_arithmetic.cc - contains kernel definitions for \"Scalar Arithmetic\" compute functions. Kernel definitions are defined via a class with literal name of compute function and containing methods named `Call` that are parameterized for specific input types (signed/unsigned integer and floating-point).\n+    * For compute functions that may trigger overflow the \"checked\" variant is a class suffixed with `Checked` and makes use of assertions and overflow checks. If overflow occurs, kernel returns zero and sets that `Status*` error flag.\n+        * For compute functions that do not have a valid mathematical operation for specific datatypes (e.g., negate an unsigned integer), the kernel for those types is provided but should trigger an error with `DCHECK(false) << This is included only for the purposes of instantiability from the \"arithmetic kernel generator\"` and return zero.\n+\n+\n+Kernel dispatcher\n+-----------------\n+\n+* compute/exec.h\n+    * Defines variants of `CallFunction` which are the one-shot functions for invoking compute functions. A compute function should invoke `CallFunction` in its definition.\n+    * Defines `ExecContext` class\n+    * ScalarExecutor applies scalar function to batch\n+    * ExecBatchIterator::Make\n+\n+* `DispatchBest`\n+\n+* `FunctionRegistry` is the class representing a function registry. By default there is a single global registry where all kernels reside. `ExecContext` maintains a reference to the registry, if reference is NULL then the default registry is used.\n+\n+* aggregate_basic.cc, aggregate_basic_internal.h - example of passing options to kernel\n+    * scalaraggregator\n+\n+\n+Portable snippets for safe (integer) math\n+-----------------------------------------\n+\n+Arithmetic functions which can trigger integral overflow use the vendored library `portable_snippets` to perform \"safe math\" operations (e.g., arithmetic, logical shifts, casts).\n+Kernel implementations suffixed with `WithOverflow` need to be defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/util/int_util_internal.h for each primitive datatype supported. Use the helper macros of the form `*OPS_WITH_OVERFLOW` to automatically generate the definitions. This file also contains helper functions for performing safe integral arithmetic for the kernels' default variant.\n+\n+The short-hand name maps to the predefined operation names in https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h#L1028-L1033. For example, `OPS_WITH_OVERFLOW(AddWithOverflow, add)` uses short-hand name `add`.\n+\n+\n+Adding a new compute function\n+=============================\n+\n+This section describes the process for adding a new compute function and associated kernel implementations.\n+\n+First, you should identify the principal attributes of the new compute function.\n+The following series of steps help guide the design process.\n+\n+1. Decide on a unique name that fully represents the function's operation\n+\n+   Browse the [available compute functions](https://arrow.apache.org/docs/cpp/compute.html#available-functions) to prevent a name collision. Note that the long form of names is preferred, and multi-word names are allowed due to the fact that string versions use an underscore instead of whitespace and C++ function names use camel case convention.\n+     * What is a representative and unambiguous name for the operation performed by the compute function?\n+     * If a related or variant form of a compute function is to be added in the future, is the current name extensible or specific enough to allow room for clear differentiation? For example, `str_length` is not a good name because there are different types of strings, so in this case it is preferable to be specific with `ascii_length` and `utf8_length`.\n+\n+1. Identify the input/output types/shapes\n+    * What are the input types/shapes supported?\n+    * If multiple inputs are expected, are they the same type/shape?\n+\n+1. Identify the compute function \"kind\" based on its operation and #2.\n+    * Does the codebase of the \"kind\" provides full support for the new compute function?\n+        * If not, is it straightforward to add the missing parts or can the new compute function be supported by another \"kind\"?\n+\n+\n+Define compute function\n+-----------------------\n+\n+Add the compute function prototype and definition to the corresponding source files based on its \"kind\". For example the API of a \"Scalar\" function is found in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.h and its definition in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/api_scalar.cc.\n+\n+\n+\n+Define kernels of compute function\n+----------------------------------\n+\n+Define the kernel implementations in the corresponding source file based on the compute function's \"kind\" and category. For example, a \"Scalar\" arithmetic function has kernels defined in https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/kernels/scalar_arithmetic.cc.\n+\n+Create compute function documentation (`FunctionDoc` object)\n+------------------------------------------------------------\n+\n+Each compute function has documentation which includes a summary, description, and argument types of its operation. A `FunctionDoc` object is instantiated and used in the registration step. Note that for compute functions that can overflow, another `FunctionDoc` is required for the `_checked` variant.\n+\n+Register kernels of compute function\n+------------------------------------\n+\n+1. Before registering the kernels, check that the available kernel generators support the `arity` and data types allowed for the new compute function. Kernel generators are not of the same form for all the kernel `kinds`. For example, in the \"Scalar Arithmetic\" kernels, registration functions have names of the form `MakeArithmeticFunction` and `MakeArithmeticFunctionNotNull`. If not available, you will need to define them for your particular case.\n+\n+1. Create the kernels by invoking the kernel generators.\n+\n+1. Register the kernels in the corresponding registry along with its `FunctionDoc`.\n+\n+\n+Testing\n+-------\n+\n+Arrow uses Google test framework. All kernels should have tests to ensure stability of the compute layer. Tests should at least cover ordinary inputs, corner cases, extreme values, nulls, different data types, and invalid tests. Moreover, there can be kernel-specific tests. For example, for arithmetic kernels, tests should include `NaN` and `Inf` inputs. The test files are located alongside the kernel source files and suffixed with `_test`. Tests are grouped by compute function `kind` and categories.\n+\n+`TYPED_TEST(test suite name, compute function)` - wrapper to define tests for the given compute function. The `test suite name` is associated with a set of data types that are used for the test suite (`TYPED_TEST_SUITE`). Tests from multiple compute functions can be placed in the same test suite. For example, `TYPED_TEST(TestBinaryArithmeticFloating, Sub)` and `TYPED_TEST(TestBinaryArithmeticFloating, Mul)`.\n+\n+Helpers\n+=======\n+\n+* `MakeArray` - convert a `Datum` to an ...\n+* `ArrayFromJSON(type_id, format string)` -  `ArrayFromJSON(float32, \"[1.3, 10.80, NaN, Inf, null]\")`\n+\n+\n+Benchmarking\n+------------\n+\n+\n+Example of Unary Arithmetic Function: Absolute Value\n+====================================================\n+\n+Identify the principal attributes.\n+\n+1. Name\n+    * String literal: \"absolute_value\"\n+    * C++ function names: `AbsoluteValue`\n+1. Input/output types: Numerical (signed and unsigned, integral and floating-point)\n+1. Input/output shapes: operate on scalars or element-wise for arrays\n+1. Kind: Scalar\n+    * Category: Arithmetic\n+1. Arity: Unary\n+\n+\n+Define compute function\n+-----------------------\n\nReview comment:\n       It may be helpful to say something about impacts on language bindings, assuming that most of these will use what is in the registry rather tan the C++ convenience function.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-29T05:00:01.888+0000",
                    "updated": "2021-12-29T05:00:01.888+0000",
                    "started": "2021-12-29T05:00:01.887+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701748",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/701749",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkmgit commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r776153789\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n+* An [\"arity\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute5ArityE) which states the number of required arguments\n+for its core operation. Functions are commonly nullary, unary, binary, or ternary, but can also be variadic.\n+* [\"Documentation\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE) describing the function's functionality and behavior\n+* [\"Options\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE) specifying configuration of the function's behavior.\n+\n+Compute functions are grouped in source files based on their \"kind\" in https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute.\n+Kernels of compute functions are grouped in source files based on their \"kind\" and category, see https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels.\n+\n+\n+Kinds of compute functions\n+--------------------------\n+\n+Arrow uses an enumerated type to identify the kind of a compute function, refer to\n+https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/function.h\n+\n+Scalar\n+~~~~~~\n+\n+A function that performs scalar data operations on whole arrays of\n+data. Can generally process Array or Scalar values. The size of the\n+output will be the same as the size (or broadcasted size, in the case\n+of mixing Array and Scalar inputs) of the input.\n+\n+https://arrow.apache.org/docs/cpp/compute.html#arithmetic-functions\n+\n+**Categories of Scalar functions**\n+\n+* Arithmetic\n+* Comparisons\n+* Logical\n+* String\n+    * predicates\n+    * transforms\n+    * trimming\n+    * splitting\n+    * extraction\n+* Containment tests\n+* Structural transforms\n+* Conversions\n+\n+\n+Vector\n+~~~~~~\n+\n+A function with array input and output whose behavior depends on the\n+values of the entire arrays passed, rather than the value of each scalar value.\n+\n+**Categories of Vector functions**\n+\n+* Associative transforms\n+* Selections\n+* Sorts and partitions\n+* Structural transforms\n+\n+\n+Scalar aggregate\n+~~~~~~~~~~~~~~~~\n+\n+A function that computes scalar summary statistics from array input.\n+\n+### Hash aggregate\n+\n+A function that computes grouped summary statistics from array input\n+and an array of group identifiers.\n+\n+Meta\n+~~~~\n+\n+A function that dispatches to other functions and does not contain its own kernels.\n+\n+\n+\n+Kernels\n+-------\n+\n+Kernels are simple ``structs`` containing only function pointers (the \"methods\" of the kernel) and attribute flags. Each function kind corresponds to a class of Kernel with methods representing each stage of the function's execution. For example, :struct:`ScalarKernel` includes (optionally) :member:`ScalarKernel::init` to initialize any state necessary for execution and :member:`ScalarKernel::exec` to perform the computation.\n+\n+Since many kernels are closely related in operation and differ only in their input types, it's frequently useful to leverage c++'s powerful template system to efficiently generate kernels' methods. For example, the \"add\" compute function accepts all numeric types and its kernels' methods are instantiations of the same function template.\n+\n+Function options\n+----------------\n+\n+[FunctionOptions](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute15FunctionOptionsE)\n+\n+\n+Function documentation\n+----------------------\n+\n+[FunctionDoc](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute11FunctionDocE)\n+\n+\n+Files and structures of the computer layer\n+==========================================\n+\n+This section describes the general structure of files/directory and principal code structures of the compute layer.\n+\n+* arrow/util/int_util_internal.h - defines utility functions\n+    * Function definitions suffixed with `WithOverflow` to support \"safe math\" for arithmetic kernels. Helper macros are included to create the definitions which invoke the corresponding operation in [`portable_snippets`](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h) library.\n+\n+* compute/api_scalar.h - contains\n+    * Subclasses of `FunctionOptions` for specific categories of compute functions\n+    * API/prototypes for all `Scalar` compute functions. Note that there is a single API version for each compute function.\n+* *compute/api_scalar.cc* - defines `Scalar` compute functions as wrappers over [\"CallFunction\"](https://arrow.apache.org/docs/cpp/api/compute.html?highlight=one%20shot#_CPPv412CallFunctionRKNSt6stringERKNSt6vectorI5DatumEEPK15FunctionOptionsP11ExecContext) (one-shot function). Arrow provides macros to easily define compute functions based on their `arity` and invocation mode.\n+    * Macros of the form `SCALAR_EAGER_*` invoke `CallFunction` directly and only require one function name.\n+    * Macros of the form `SCALAR_*` invoke `CallFunction` after checking for overflow and require two function names (default and `_checked` variant).\n+\n+* compute/kernels/scalar_arithmetic.cc - contains kernel definitions for \"Scalar Arithmetic\" compute functions. Kernel definitions are defined via a class with literal name of compute function and containing methods named `Call` that are parameterized for specific input types (signed/unsigned integer and floating-point).\n+    * For compute functions that may trigger overflow the \"checked\" variant is a class suffixed with `Checked` and makes use of assertions and overflow checks. If overflow occurs, kernel returns zero and sets that `Status*` error flag.\n+        * For compute functions that do not have a valid mathematical operation for specific datatypes (e.g., negate an unsigned integer), the kernel for those types is provided but should trigger an error with `DCHECK(false) << This is included only for the purposes of instantiability from the \"arithmetic kernel generator\"` and return zero.\n+\n\nReview comment:\n       This would be helpful.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-29T05:01:27.438+0000",
                    "updated": "2021-12-29T05:01:27.438+0000",
                    "started": "2021-12-29T05:01:27.437+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701749",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/701751",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkmgit commented on pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#issuecomment-1002398828\n\n\n   One further consideration is interface design. This seems like it is still being stabilized but guiding principles would be helpful.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-29T05:03:29.124+0000",
                    "updated": "2021-12-29T05:03:29.124+0000",
                    "started": "2021-12-29T05:03:29.123+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701751",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/701758",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkmgit commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r776171860\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n\nReview comment:\n       ```suggestion\r\n   Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time with output length the same as the input length. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\r\n   ```\r\n   Maybe this is clearer\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-29T06:33:39.320+0000",
                    "updated": "2021-12-29T06:33:39.320+0000",
                    "started": "2021-12-29T06:33:39.320+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701758",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/701759",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkmgit commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r776172015\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n\nReview comment:\n       ```suggestion\r\n   * The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of input data types or function behavior options.\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-29T06:34:22.171+0000",
                    "updated": "2021-12-29T06:34:22.171+0000",
                    "started": "2021-12-29T06:34:22.170+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701759",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/701761",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkmgit commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r776174122\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n\nReview comment:\n       ```suggestion\r\n   An introduction to compute functions is provided in `compute documentation <https://arrow.apache.org/docs/cpp/compute.html>`_ .\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-29T06:43:08.146+0000",
                    "updated": "2021-12-29T06:43:08.146+0000",
                    "started": "2021-12-29T06:43:08.146+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701761",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/701762",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkmgit commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r776174414\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n\nReview comment:\n       ```suggestion\r\n   The `compute submodule <https://https://github.com/apache/arrow/tree/master/cpp/src/arrow/compute>`_ contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-29T06:44:31.609+0000",
                    "updated": "2021-12-29T06:44:31.609+0000",
                    "started": "2021-12-29T06:44:31.608+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701762",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/701763",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkmgit commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r776174723\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n\nReview comment:\n       ```suggestion\r\n   `Compute functions <https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h>`_  have the following principal attributes:\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-29T06:45:44.957+0000",
                    "updated": "2021-12-29T06:45:44.957+0000",
                    "started": "2021-12-29T06:45:44.957+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701763",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/701765",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkmgit commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r776177694\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n\nReview comment:\n       ```suggestion\r\n   * A unique :doc:`name <.compute>`  used for function invocation and language bindings\r\n   ```\r\n   Adding a section heading to the approriate part of the compute documentation will give a better link. See [restructured text documentation](https://www.sphinx-doc.org/en/master/usage/restructuredtext/roles.html#cross-referencing-arbitrary-locations)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-29T06:57:22.702+0000",
                    "updated": "2021-12-29T06:57:22.702+0000",
                    "started": "2021-12-29T06:57:22.701+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701765",
                    "issueId": "13377671"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/worklog/701766",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkmgit commented on a change in pull request #10296:\nURL: https://github.com/apache/arrow/pull/10296#discussion_r776178425\n\n\n\n##########\nFile path: docs/source/cpp/authoring_compute_functions.rst\n##########\n@@ -0,0 +1,423 @@\n+.. Licensed to the Apache Software Foundation (ASF) under one\n+.. or more contributor license agreements.  See the NOTICE file\n+.. distributed with this work for additional information\n+.. regarding copyright ownership.  The ASF licenses this file\n+.. to you under the Apache License, Version 2.0 (the\n+.. \"License\"); you may not use this file except in compliance\n+.. with the License.  You may obtain a copy of the License at\n+\n+..   http://www.apache.org/licenses/LICENSE-2.0\n+\n+.. Unless required by applicable law or agreed to in writing,\n+.. software distributed under the License is distributed on an\n+.. \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+.. KIND, either express or implied.  See the License for the\n+.. specific language governing permissions and limitations\n+.. under the License.\n+\n+.. default-domain:: cpp\n+.. highlight:: cpp\n+.. cpp:namespace:: arrow::compute\n+\n+===========================\n+Authoring Compute Functions\n+===========================\n+\n+Compute Functions\n+=================\n+\n+An introduction to compute functions is provided in https://arrow.apache.org/docs/cpp/compute.html.\n+\n+The [compute submodule](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute) contains analytical functions that process primarily columnar data for either scalar or Arrow-based array inputs. These are intended for use inside query engines, data frame libraries, etc.\n+\n+Many functions have SQL-like semantics in that they perform element-wise or scalar operations on whole arrays at a time. Other functions are not SQL-like and compute results that may be a different length or whose results depend on the order of the values.\n+\n+Terminology:\n+* The term compute \"function\" refers to a particular general operation that may have many different implementations corresponding to different combinations of types or function behavior options.\n+* A specific implementation of a function is a \"kernel\". Selecting a viable kernel for executing a function is referred to as \"dispatching\". When executing a function on inputs, we must first select a suitable kernel corresponding to the value types of the inputs is selected.\n+* Functions along with their kernel implementations are collected in a \"function registry\". Given a function name and argument types, we can look up that function and dispatch to a compatible kernel.\n+\n+[Compute functions](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h) have the following principal attributes:\n+* A unique [\"name\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4NK5arrow7compute8Function4nameEv) used for function invocation and language bindings\n+* A [\"kind\"](https://arrow.apache.org/docs/cpp/api/compute.html#_CPPv4N5arrow7compute8Function4KindE)\n+  which indicates in what context it is valid for use\n+    * Input/output [types](https://arrow.apache.org/docs/cpp/compute.html#type-categories) and [shapes](https://arrow.apache.org/docs/cpp/compute.html#input-shapes)\n+    * Compute functions can also be further \"categorized\" based on the type of operation performed. For example, `Scalar Arithmetic` vs `Scalar String`.\n+* Compute functions (see [FunctionImpl and subclasses](https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h)) contain [\"kernels\"](https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels) which are implementations for specific argument signatures.\n\nReview comment:\n       ```suggestion\r\n   * Compute functions (see `FunctionImpl and subclasses <https://github.com/apache/arrow/blob/master/cpp/src/arrow/compute/function.h>`_) contain `\"kernels\" <https://github.com/edponce/arrow/tree/master/cpp/src/arrow/compute/kernels>`_ which are implementations for specific argument signatures.\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-29T07:00:16.771+0000",
                    "updated": "2021-12-29T07:00:16.771+0000",
                    "started": "2021-12-29T07:00:16.770+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "701766",
                    "issueId": "13377671"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 47400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@5217dbe[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2d62d1da[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5aa7e069[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@61f016e6[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3588f362[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@4cca450e[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@298b5056[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@482d34a7[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3a4cdd23[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@24301d51[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@574af061[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@76637e23[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 47400,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Jul 28 22:12:17 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12724/watchers",
            "watchCount": 6,
            "isWatching": false
        },
        "created": "2021-05-10T17:56:23.000+0000",
        "updated": "2022-10-20T05:00:32.000+0000",
        "timeoriginalestimate": null,
        "description": "To help incoming developer's to work in the compute layer, it would be good to have documentation on the process to follow for authoring a new compute kernel. This document can help demystify the inner workings of the functions and data structures in the compute layer.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "13h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 47400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Docs] Add documentation for authoring compute kernels",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/comment/17434994",
                    "id": "17434994",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=baksmj",
                        "name": "baksmj",
                        "key": "baksmj",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=baksmj&avatarId=46648",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=baksmj&avatarId=46648",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=baksmj&avatarId=46648",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=baksmj&avatarId=46648"
                        },
                        "displayName": "Benson Muite",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "This will be helpful.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=baksmj",
                        "name": "baksmj",
                        "key": "baksmj",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=baksmj&avatarId=46648",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=baksmj&avatarId=46648",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=baksmj&avatarId=46648",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=baksmj&avatarId=46648"
                        },
                        "displayName": "Benson Muite",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-10-27T17:59:23.156+0000",
                    "updated": "2021-10-27T17:59:23.156+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/comment/17435072",
                    "id": "17435072",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=edponce",
                        "name": "edponce",
                        "key": "edponce",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=edponce&avatarId=45496",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=edponce&avatarId=45496",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=edponce&avatarId=45496",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=edponce&avatarId=45496"
                        },
                        "displayName": "Eduardo Ponce",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "[~baksmj] Yes, I am organizing myself to complete this very soon.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=edponce",
                        "name": "edponce",
                        "key": "edponce",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=edponce&avatarId=45496",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=edponce&avatarId=45496",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=edponce&avatarId=45496",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=edponce&avatarId=45496"
                        },
                        "displayName": "Eduardo Ponce",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-10-27T21:48:00.669+0000",
                    "updated": "2021-10-27T21:48:00.669+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/comment/17476163",
                    "id": "17476163",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
                        "name": "kszucs",
                        "key": "kszucs",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Krisztian Szucs",
                        "active": true,
                        "timeZone": "Europe/Budapest"
                    },
                    "body": "Postponing to 8.0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
                        "name": "kszucs",
                        "key": "kszucs",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Krisztian Szucs",
                        "active": true,
                        "timeZone": "Europe/Budapest"
                    },
                    "created": "2022-01-14T14:14:14.837+0000",
                    "updated": "2022-01-14T14:14:14.837+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/comment/17562784",
                    "id": "17562784",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=amol-",
                        "name": "amol-",
                        "key": "amol-",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=amol-&avatarId=46461",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=amol-&avatarId=46461",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=amol-&avatarId=46461",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=amol-&avatarId=46461"
                        },
                        "displayName": "Alessandro Molina",
                        "active": true,
                        "timeZone": "Europe/Rome"
                    },
                    "body": "Given [https://github.com/apache/arrow/pull/12460#issuecomment-1057520554]\r\nWhat are we planning to do with this one? Has been around for a while.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=amol-",
                        "name": "amol-",
                        "key": "amol-",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=amol-&avatarId=46461",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=amol-&avatarId=46461",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=amol-&avatarId=46461",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=amol-&avatarId=46461"
                        },
                        "displayName": "Alessandro Molina",
                        "active": true,
                        "timeZone": "Europe/Rome"
                    },
                    "created": "2022-07-05T18:00:21.125+0000",
                    "updated": "2022-07-05T18:00:21.125+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/comment/17562962",
                    "id": "17562962",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=octalene",
                        "name": "octalene",
                        "key": "octalene",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=octalene&avatarId=51083",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=octalene&avatarId=51083",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=octalene&avatarId=51083",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=octalene&avatarId=51083"
                        },
                        "displayName": "Aldrin Montana",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "I discussed with Eduardo and I think we have loosely agreed that this is just about ready to be closed.\r\n\r\nI am planning on following up with some updates and going to try and accompany it with a cookbook recipe ([https://github.com/apache/arrow-cookbook/issues/174)]\r\n\r\nI would like to try and get these through this week",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=octalene",
                        "name": "octalene",
                        "key": "octalene",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=octalene&avatarId=51083",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=octalene&avatarId=51083",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=octalene&avatarId=51083",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=octalene&avatarId=51083"
                        },
                        "displayName": "Aldrin Montana",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-07-06T05:45:05.626+0000",
                    "updated": "2022-07-06T05:45:05.626+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13377671/comment/17572673",
                    "id": "17572673",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=octalene",
                        "name": "octalene",
                        "key": "octalene",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=octalene&avatarId=51083",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=octalene&avatarId=51083",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=octalene&avatarId=51083",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=octalene&avatarId=51083"
                        },
                        "displayName": "Aldrin Montana",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "going to pick this up and make it cohesive with a PR in progress for https://github.com/apache/arrow-cookbook/issues/174",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=octalene",
                        "name": "octalene",
                        "key": "octalene",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=octalene&avatarId=51083",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=octalene&avatarId=51083",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=octalene&avatarId=51083",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=octalene&avatarId=51083"
                        },
                        "displayName": "Aldrin Montana",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2022-07-28T22:12:17.567+0000",
                    "updated": "2022-07-28T22:12:17.567+0000"
                }
            ],
            "maxResults": 6,
            "total": 6,
            "startAt": 0
        },
        "customfield_12311820": "0|z0qwe8:",
        "customfield_12314139": null
    }
}