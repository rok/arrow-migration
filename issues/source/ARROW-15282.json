{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13421341",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341",
    "key": "ARROW-15282",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351051",
                "id": "12351051",
                "description": "",
                "name": "8.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-05-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12643125",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12643125",
                "type": {
                    "id": "12310000",
                    "name": "Duplicate",
                    "inward": "is duplicated by",
                    "outward": "duplicates",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310000"
                },
                "inwardIssue": {
                    "id": "13399256",
                    "key": "ARROW-13889",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13399256",
                    "fields": {
                        "summary": "[C++][FlightRPC] Decouple Arrow Flight RPC from GRPC",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12634921",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12634921",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13431765",
                    "key": "ARROW-15835",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13431765",
                    "fields": {
                        "summary": "[C++][FlightRPC] Refactor auth, middleware into the transport-agnostic layer",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12634923",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12634923",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13431766",
                    "key": "ARROW-15836",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13431766",
                    "fields": {
                        "summary": "[C++][FlightRPC] Refactor remaining methods into transport-agnostic handlers",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12634522",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12634522",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13430733",
                    "key": "ARROW-15788",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13430733",
                    "fields": {
                        "summary": "[C++][FlightRPC] Support alternative transports in the Flight benchmark",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12633771",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12633771",
                "type": {
                    "id": "12310051",
                    "name": "Supercedes",
                    "inward": "is superceded by",
                    "outward": "supercedes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"
                },
                "inwardIssue": {
                    "id": "13428920",
                    "key": "ARROW-15706",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13428920",
                    "fields": {
                        "summary": "[C++][FlightRPC] Implement a UCX transport",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334621",
                "id": "12334621",
                "name": "FlightRPC"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
            "name": "yibocai",
            "key": "yibo",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
            },
            "displayName": "Yibo Cai",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
            "name": "yibocai",
            "key": "yibo",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
            },
            "displayName": "Yibo Cai",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 63000,
            "total": 63000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 63000,
            "total": 63000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15282/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 105,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/711873",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 opened a new pull request #12196:\nURL: https://github.com/apache/arrow/pull/12196\n\n\n   This patch decouples flightrpc data plane from grpc so we can leverage\r\n   optimized data transfer libraries.\r\n   \r\n   The basic idea is to replace grpc stream with a data plane stream for\r\n   FlightData transmission in DoGet/DoPut/DoExchange. There's no big change\r\n   to current flight client and server implementations. Added a wrapper to\r\n   support both grpc stream and data plane stream. By default, grpc stream\r\n   is used, which goes the current grpc based code path. If a data plane is\r\n   enabled (currently through environment variable), flight payload will go\r\n   through the data plane stream instead. See client.cc and server.cc to\r\n   review the changes.\r\n   \r\n   **About data plane implementation**\r\n   \r\n   - data_plane/types.{h,cc}\r\n     Defines client/server data plane and data plane stream interfaces.\r\n     It's the only exported api to other component ({client,server}.cc).\r\n   - data_plane/serialize.{h,cc}\r\n     De-Serialize FlightData manually as we bypass grpc. Luckly, we already\r\n     implemented related functions to support payload zero-copy.\r\n   - shm.cc\r\n     A shared memory driver to verify the data plane approach. The code may\r\n     be a bit hard to read, it's better to focus on data plane interface\r\n     implementations at first before dive deep into details like shared\r\n     memory, ipc and buffer management related code.\r\n     Please note there are still many caveats in current code, see TODO and\r\n     XXX in shm.cc for details.\r\n   \r\n   **To evaluate this patch**\r\n   \r\n   I tested shared memory data plane on Linux (x86, Arm) and MacOS (Arm).\r\n   Build with `-DARROW_FLIGHT_DP_SHM=ON` to enable the shared memory data\r\n   plane. Set `FLIGHT_DATAPLANE=shm` environment variable to run unit tests\r\n   and benchmarks with the shared memory data plane enabled.\r\n   \r\n   ```\r\n   Build: cmake -DARROW_FLIGHT_DP_SHM=ON -DARROW_FLIGHT=ON ....\r\n   Test:  FLIGHT_DATAPLANE=shm release/arrow-flight-test\r\n   Bench: FLIGHT_DATAPLANE=shm release/arrow-flight-benchmark \\\r\n          -num_streams=1|2|4 -num_threads=1|2|4\r\n   ```\r\n   \r\n   Benchmark result (throughput, latency) on Xeon Gold 5218.\r\n   Test case: DoGet, batch size = 128KiB\r\n   \r\n   | streams | grpc over unix socket | shared memory data plane |\r\n   | ------- | --------------------- | ------------------------ |\r\n   | 1       |  3324 MB/s,  35 us    |  7045 MB/s,  16 us       |\r\n   | 2       |  6289 MB/s,  38 us    | 13311 MB/s,  17 us       |\r\n   | 4       | 10037 MB/s,  44 us    | 25012 MB/s,  17 us       |\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-20T05:58:07.810+0000",
                    "updated": "2022-01-20T05:58:07.810+0000",
                    "started": "2022-01-20T05:58:07.810+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "711873",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/711874",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #12196:\nURL: https://github.com/apache/arrow/pull/12196#issuecomment-1017145615\n\n\n   <!--\n     Licensed to the Apache Software Foundation (ASF) under one\n     or more contributor license agreements.  See the NOTICE file\n     distributed with this work for additional information\n     regarding copyright ownership.  The ASF licenses this file\n     to you under the Apache License, Version 2.0 (the\n     \"License\"); you may not use this file except in compliance\n     with the License.  You may obtain a copy of the License at\n   \n       http://www.apache.org/licenses/LICENSE-2.0\n   \n     Unless required by applicable law or agreed to in writing,\n     software distributed under the License is distributed on an\n     \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     KIND, either express or implied.  See the License for the\n     specific language governing permissions and limitations\n     under the License.\n   -->\n   \n   Thanks for opening a pull request!\n   \n   If this is not a [minor PR](https://github.com/apache/arrow/blob/master/CONTRIBUTING.md#Minor-Fixes). Could you open an issue for this pull request on JIRA? https://issues.apache.org/jira/browse/ARROW\n   \n   Opening JIRAs ahead of time contributes to the [Openness](http://theapacheway.com/open/#:~:text=Openness%20allows%20new%20users%20the,must%20happen%20in%20the%20open.) of the Apache Arrow project.\n   \n   Then could you also rename pull request title in the following format?\n   \n       ARROW-${JIRA_ID}: [${COMPONENT}] ${SUMMARY}\n   \n   or\n   \n       MINOR: [${COMPONENT}] ${SUMMARY}\n   \n   See also:\n   \n     * [Other pull requests](https://github.com/apache/arrow/pulls/)\n     * [Contribution Guidelines - How to contribute patches](https://arrow.apache.org/docs/developers/contributing.html#how-to-contribute-patches)\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-20T05:58:30.571+0000",
                    "updated": "2022-01-20T05:58:30.571+0000",
                    "started": "2022-01-20T05:58:30.571+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "711874",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/711879",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #12196:\nURL: https://github.com/apache/arrow/pull/12196#issuecomment-1017155532\n\n\n   **NOTE:** The main purpose of this PR is to collect responses and seek for best approaches to support optimized data transfer methods other than grpc.\r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-20T06:19:40.401+0000",
                    "updated": "2022-01-20T06:19:40.401+0000",
                    "started": "2022-01-20T06:19:40.400+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "711879",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/712113",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #12196:\nURL: https://github.com/apache/arrow/pull/12196#discussion_r788828887\n\n\n\n##########\nFile path: cpp/src/arrow/flight/data_plane/types.cc\n##########\n@@ -0,0 +1,127 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/data_plane/types.h\"\n+#include \"arrow/flight/data_plane/internal.h\"\n+#include \"arrow/util/io_util.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/make_unique.h\"\n+\n+#ifdef GRPCPP_PP_INCLUDE\n+#include <grpcpp/grpcpp.h>\n+#else\n+#include <grpc++/grpc++.h>\n+#endif\n+\n+namespace arrow {\n+namespace flight {\n+namespace internal {\n+\n+namespace {\n+\n+// data plane registry (name -> data plane maker)\n+struct Registry {\n+  std::map<const std::string, DataPlaneMaker> makers;\n+\n+  // register all data planes on creation of registry singleton\n+  Registry() {\n+#ifdef FLIGHT_DP_SHM\n+    Register(\"shm\", GetShmDataPlaneMaker());\n+#endif\n+  }\n+\n+  static const Registry& instance() {\n+    static const Registry registry;\n+    return registry;\n+  }\n+\n+  void Register(const std::string& name, const DataPlaneMaker& maker) {\n+    DCHECK_EQ(makers.find(name), makers.end());\n+    makers[name] = maker;\n+  }\n+\n+  arrow::Result<DataPlaneMaker> GetDataPlaneMaker(const std::string& uri) const {\n+    const std::string name = uri.substr(0, uri.find(':'));\n+    auto it = makers.find(name);\n+    if (it == makers.end()) {\n+      return Status::Invalid(\"unknown data plane: \", name);\n+    }\n+    return it->second;\n+  }\n+};\n+\n+std::string GetGrpcMetadata(const grpc::ServerContext& context, const std::string& key) {\n+  const auto client_metadata = context.client_metadata();\n+  const auto found = client_metadata.find(key);\n+  std::string token;\n+  if (found == client_metadata.end()) {\n+    DCHECK(false);\n+    token = \"\";\n+  } else {\n+    token = std::string(found->second.data(), found->second.length());\n+  }\n+  return token;\n+}\n+\n+// TODO(yibo): getting data plane uri from env var is bad, shall we extend\n+// location to support two uri (control, data)? or any better approach to\n\nReview comment:\n       `grpc+tcp://localhost:1337/?data=shm` or something? Or maybe something like `grpc+tcp+shm://...` not sure what is semantically correct.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-20T14:44:32.607+0000",
                    "updated": "2022-01-20T14:44:32.607+0000",
                    "started": "2022-01-20T14:44:32.607+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "712113",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/712114",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #12196:\nURL: https://github.com/apache/arrow/pull/12196#issuecomment-1017583501\n\n\n   I suppose the key thing is to consider the types of backends we want to support. If they look more like UCX or WebSockets and can entirely replace gRPC, that's one thing; if they look more like shared memory (or libfabrics? DPDK?) then this approach is probably easier.\r\n   \r\n   Or maybe there's an approach where we allow swapping gRPC out entirely, _but only for the data plane methods_. Since it doesn't really add value to reimplement GetFlightInfo in UCX. (That argument breaks down somewhat for WebSockets, where I think using gRPC at all requires proxying or some other deployment configuration.) \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-20T14:47:10.379+0000",
                    "updated": "2022-01-20T14:47:10.379+0000",
                    "started": "2022-01-20T14:47:10.379+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "712114",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/712726",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #12196:\nURL: https://github.com/apache/arrow/pull/12196#issuecomment-1018387095\n\n\n   Thanks @lidavidm !\r\n   \r\n   Now looks to me UCX transport is the better way.\r\n   \r\n   My main concern of the data plane approach is that we have to build by ourselves the data transmission over raw data plane libraries. A robust, high performance communication system is hard enough and we'd better adopt mature frameworks like gRPC or UCX. 80% code of this PR is the shared memory driver, and it's still far from production quality (we need to handle cache management, flow control, and many other tricky things like race conditions).\r\n   \r\n   I think we can leave this PR open to see if there are other comments.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-21T10:38:51.324+0000",
                    "updated": "2022-01-21T10:38:51.324+0000",
                    "started": "2022-01-21T10:38:51.324+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "712726",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/712798",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkmgit commented on pull request #12196:\nURL: https://github.com/apache/arrow/pull/12196#issuecomment-1018442427\n\n\n   How were the tests run? Assume the [flight benchmark](https://github.com/cyb70289/arrow/blob/flight-data-plane/cpp/src/arrow/flight/flight_benchmark.cc) as described at https://arrow.apache.org/blog/2019/10/13/introducing-arrow-flight/ was used.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-21T11:58:10.328+0000",
                    "updated": "2022-01-21T11:58:10.328+0000",
                    "started": "2022-01-21T11:58:10.328+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "712798",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/712863",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #12196:\nURL: https://github.com/apache/arrow/pull/12196#issuecomment-1018506973\n\n\n   > My main concern of the data plane approach is that we have to build by ourselves the data transmission over raw data plane libraries. A robust, high performance communication system is hard enough and we'd better adopt mature frameworks like gRPC or UCX.\r\n   \r\n   To be fair, even with UCX there is still a fair amount of work to get Flight working on top. But I see your point - there is a lot of code that can be reused in Flight, but something very low level like shared memory without a helper library still requires a lot of work.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-21T13:30:32.994+0000",
                    "updated": "2022-01-21T13:30:32.994+0000",
                    "started": "2022-01-21T13:30:32.993+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "712863",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/712884",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on pull request #12196:\nURL: https://github.com/apache/arrow/pull/12196#issuecomment-1018535080\n\n\n   > How were the tests run? Assume the [flight benchmark](https://github.com/cyb70289/arrow/blob/flight-data-plane/cpp/src/arrow/flight/flight_benchmark.cc) as described at https://arrow.apache.org/blog/2019/10/13/introducing-arrow-flight/ was used.\r\n   \r\n   Do you mean how to run flightrpc benchmark?\r\n   - To build it you have to enable -DARROW_FLIGHT=ON in cmake.\r\n   - To run client and server on same host: just run \"arrow-flight-benchmark -num_streams=1 -num_threads=1\" (change 1 to 2,4,... for more streams). It spawns server at the background automatically.\r\n   - To run across network, you run \"arrow-flight-perf-server\" on server and \"arrow-flight-benchmark\" on client, you will need to specify server ip, see the cmdline helps for more options.\r\n   - To verify this PR please see the commit message above.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-01-21T14:08:02.049+0000",
                    "updated": "2022-01-21T14:08:02.049+0000",
                    "started": "2022-01-21T14:08:02.049+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "712884",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/729812",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #12465:\nURL: https://github.com/apache/arrow/pull/12465#issuecomment-1045055709\n\n\n   TODOs\r\n   - [ ] Address new TODOs scattered in source\r\n   - [ ] Make client/server share code around writing IPC with app metadata\r\n   - [ ] Document the new interfaces\r\n   - [ ] Check that Flight benchmark did not regress\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-18T19:23:39.936+0000",
                    "updated": "2022-02-18T19:23:39.936+0000",
                    "started": "2022-02-18T19:23:39.935+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "729812",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/729814",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #12465:\nURL: https://github.com/apache/arrow/pull/12465#issuecomment-1045056037\n\n\n   https://issues.apache.org/jira/browse/ARROW-15282\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-18T19:24:04.883+0000",
                    "updated": "2022-02-18T19:24:04.883+0000",
                    "started": "2022-02-18T19:24:04.882+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "729814",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/731186",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm edited a comment on pull request #12465:\nURL: https://github.com/apache/arrow/pull/12465#issuecomment-1045055709\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-22T21:33:05.355+0000",
                    "updated": "2022-02-22T21:33:05.355+0000",
                    "started": "2022-02-22T21:33:05.355+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "731186",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/731190",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm edited a comment on pull request #12465:\nURL: https://github.com/apache/arrow/pull/12465#issuecomment-1045055709\n\n\n   TODOs\r\n   - [x] Address new TODOs scattered in source\r\n   - [x] Make client/server share code around writing IPC with app metadata\r\n   - [ ] Document the new interfaces\r\n   - [ ] Check that Flight benchmark did not regress\r\n   - [ ] Check that CUDA support did not regress\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-22T21:36:37.382+0000",
                    "updated": "2022-02-22T21:36:37.382+0000",
                    "started": "2022-02-22T21:36:37.381+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "731190",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/731191",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm edited a comment on pull request #12465:\nURL: https://github.com/apache/arrow/pull/12465#issuecomment-1045055709\n\n\n   TODOs\r\n   - [x] Address new TODOs scattered in source\r\n   - [x] Make client/server share code around writing IPC with app metadata\r\n   - [x] Document the new interfaces\r\n   - [ ] Check that Flight benchmark did not regress\r\n   - [ ] Check that CUDA support did not regress\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-22T21:37:41.950+0000",
                    "updated": "2022-02-22T21:37:41.950+0000",
                    "started": "2022-02-22T21:37:41.950+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "731191",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/731192",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm edited a comment on pull request #12465:\nURL: https://github.com/apache/arrow/pull/12465#issuecomment-1045055709\n\n\n   TODOs\r\n   - [x] Address new TODOs scattered in source\r\n   - [x] Make client/server share code around writing IPC with app metadata\r\n   - [x] Document the new interfaces\r\n   - [x] Check that Flight benchmark did not regress\r\n   - [ ] Check that CUDA support did not regress\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-22T21:44:17.531+0000",
                    "updated": "2022-02-22T21:44:17.531+0000",
                    "started": "2022-02-22T21:44:17.531+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "731192",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/731195",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm edited a comment on pull request #12465:\nURL: https://github.com/apache/arrow/pull/12465#issuecomment-1045055709\n\n\n   TODOs\r\n   - [x] Address new TODOs scattered in source\r\n   - [x] Make client/server share code around writing IPC with app metadata\r\n   - [x] Document the new interfaces\r\n   - [x] Check that Flight benchmark did not regress\r\n   - [x] Check that CUDA support did not regress\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-22T21:47:35.494+0000",
                    "updated": "2022-02-22T21:47:35.494+0000",
                    "started": "2022-02-22T21:47:35.494+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "731195",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/731744",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #12465:\nURL: https://github.com/apache/arrow/pull/12465#issuecomment-1049039711\n\n\n   CC @cyb70289 if you have a chance to take a look (no pressure - this is a pretty large PR)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-23T17:40:37.777+0000",
                    "updated": "2022-02-23T17:40:37.777+0000",
                    "started": "2022-02-23T17:40:37.777+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "731744",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/732141",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #12465:\nURL: https://github.com/apache/arrow/pull/12465#discussion_r813537446\n\n\n\n##########\nFile path: cpp/src/arrow/flight/test_util.h\n##########\n@@ -82,24 +82,43 @@ std::unique_ptr<FlightServerBase> ExampleTestServer();\n // Helper to initialize a server and matching client with callbacks to\n // populate options.\n template <typename T, typename... Args>\n-Status MakeServer(std::unique_ptr<FlightServerBase>* server,\n+Status MakeServer(const Location& location, std::unique_ptr<FlightServerBase>* server,\n                   std::unique_ptr<FlightClient>* client,\n                   std::function<Status(FlightServerOptions*)> make_server_options,\n                   std::function<Status(FlightClientOptions*)> make_client_options,\n                   Args&&... server_args) {\n-  Location location;\n-  RETURN_NOT_OK(Location::ForGrpcTcp(\"localhost\", 0, &location));\n   *server = arrow::internal::make_unique<T>(std::forward<Args>(server_args)...);\n   FlightServerOptions server_options(location);\n   RETURN_NOT_OK(make_server_options(&server_options));\n   RETURN_NOT_OK((*server)->Init(server_options));\n   Location real_location;\n-  RETURN_NOT_OK(Location::ForGrpcTcp(\"localhost\", (*server)->port(), &real_location));\n+  if ((*server)->port() > 0) {\n\nReview comment:\n       Add a comment to explain the difference of `server->port() == 0`?\n\n##########\nFile path: cpp/src/arrow/flight/transport_server_impl.cc\n##########\n@@ -0,0 +1,327 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/transport_impl.h\"\n+\n+#include <unordered_map>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/flight/serialization_internal.h\"\n+#include \"arrow/flight/server.h\"\n+#include \"arrow/flight/types.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+\n+namespace arrow {\n+namespace flight {\n+namespace internal {\n+\n+namespace {\n+class TransportIpcMessageReader : public ipc::MessageReader {\n+ public:\n+  explicit TransportIpcMessageReader(\n+      std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader,\n+      std::shared_ptr<MemoryManager> memory_manager,\n+      std::shared_ptr<Buffer>* app_metadata)\n+      : peekable_reader_(peekable_reader),\n+        memory_manager_(std::move(memory_manager)),\n+        app_metadata_(app_metadata) {}\n+\n+  ::arrow::Result<std::unique_ptr<ipc::Message>> ReadNextMessage() override {\n+    if (stream_finished_) {\n+      return nullptr;\n+    }\n+    internal::FlightData* data;\n+    peekable_reader_->Next(&data);\n+    if (!data) {\n+      stream_finished_ = true;\n+      if (first_message_) {\n+        return Status::Invalid(\n+            \"Client provided malformed message or did not provide message\");\n+      }\n+      return nullptr;\n+    }\n+    if (data->body &&\n+        ARROW_PREDICT_FALSE(!data->body->device()->Equals(*memory_manager_->device()))) {\n+      ARROW_ASSIGN_OR_RAISE(data->body, Buffer::ViewOrCopy(data->body, memory_manager_));\n+    }\n+    *app_metadata_ = std::move(data->app_metadata);\n+    return data->OpenMessage();\n+  }\n+\n+ protected:\n+  std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader_;\n+  std::shared_ptr<MemoryManager> memory_manager_;\n+  // A reference to TransportDataStream.app_metadata_. That class\n+  // can't access the app metadata because when it Peek()s the stream,\n+  // it may be looking at a dictionary batch, not the record\n+  // batch. Updating it here ensures the reader is always updated with\n+  // the last metadata message read.\n+  std::shared_ptr<Buffer>* app_metadata_;\n+  bool first_message_ = true;\n+  bool stream_finished_ = false;\n+};\n+\n+/// \\brief Adapt TransportDataStream to the FlightMessageReader\n+///   interface for DoPut.\n+class TransportMessageReader final : public FlightMessageReader {\n+ public:\n+  explicit TransportMessageReader(TransportDataStream* stream,\n+                                  std::shared_ptr<MemoryManager> memory_manager)\n+      : peekable_reader_(new internal::PeekableFlightDataReader(stream)),\n+        memory_manager_(std::move(memory_manager)) {}\n+\n+  Status Init() {\n+    // Peek the first message to get the descriptor.\n+    internal::FlightData* data;\n+    peekable_reader_->Peek(&data);\n+    if (!data) {\n+      return Status::IOError(\"Stream finished before first message sent\");\n+    }\n+    if (!data->descriptor) {\n+      return Status::IOError(\"Descriptor missing on first message\");\n+    }\n+    descriptor_ = *data->descriptor;\n+    // If there's a schema (=DoPut), also Open().\n+    if (data->metadata) {\n+      return EnsureDataStarted();\n+    }\n+    peekable_reader_->Next(&data);\n+    return Status::OK();\n+  }\n+\n+  const FlightDescriptor& descriptor() const override { return descriptor_; }\n+\n+  arrow::Result<std::shared_ptr<Schema>> GetSchema() override {\n+    RETURN_NOT_OK(EnsureDataStarted());\n+    return batch_reader_->schema();\n+  }\n+\n+  Status Next(FlightStreamChunk* out) override {\n+    internal::FlightData* data;\n+    peekable_reader_->Peek(&data);\n+    if (!data) {\n+      out->app_metadata = nullptr;\n+      out->data = nullptr;\n+      return Status::OK();\n+    }\n+\n+    if (!data->metadata) {\n+      // Metadata-only (data->metadata is the IPC header)\n+      out->app_metadata = data->app_metadata;\n+      out->data = nullptr;\n+      peekable_reader_->Next(&data);\n+      return Status::OK();\n+    }\n+\n+    if (!batch_reader_) {\n+      RETURN_NOT_OK(EnsureDataStarted());\n+      // re-peek here since EnsureDataStarted() advances the stream\n+      return Next(out);\n+    }\n+    RETURN_NOT_OK(batch_reader_->ReadNext(&out->data));\n+    out->app_metadata = std::move(app_metadata_);\n+    return Status::OK();\n+  }\n+\n+ private:\n+  /// Ensure we are set up to read data.\n+  Status EnsureDataStarted() {\n+    if (!batch_reader_) {\n+      // peek() until we find the first data message; discard metadata\n+      if (!peekable_reader_->SkipToData()) {\n+        return Status::IOError(\"Client never sent a data message\");\n+      }\n+      auto message_reader =\n+          std::unique_ptr<ipc::MessageReader>(new TransportIpcMessageReader(\n+              peekable_reader_, memory_manager_, &app_metadata_));\n+      ARROW_ASSIGN_OR_RAISE(\n+          batch_reader_, ipc::RecordBatchStreamReader::Open(std::move(message_reader)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  FlightDescriptor descriptor_;\n+  std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader_;\n+  std::shared_ptr<MemoryManager> memory_manager_;\n+  std::shared_ptr<RecordBatchReader> batch_reader_;\n+  std::shared_ptr<Buffer> app_metadata_;\n+};\n+\n+// TODO(ARROW-10787): this should use the same writer/ipc trick as client\n+class TransportMessageWriter final : public FlightMessageWriter {\n+ public:\n+  explicit TransportMessageWriter(TransportDataStream* stream)\n+      : stream_(stream), ipc_options_(::arrow::ipc::IpcWriteOptions::Defaults()) {}\n+\n+  Status Begin(const std::shared_ptr<Schema>& schema,\n+               const ipc::IpcWriteOptions& options) override {\n+    if (started_) {\n+      return Status::Invalid(\"This writer has already been started.\");\n+    }\n+    started_ = true;\n+    ipc_options_ = options;\n+\n+    RETURN_NOT_OK(mapper_.AddSchemaFields(*schema));\n+    FlightPayload schema_payload;\n+    RETURN_NOT_OK(ipc::GetSchemaPayload(*schema, ipc_options_, mapper_,\n+                                        &schema_payload.ipc_message));\n+    return WritePayload(schema_payload);\n+  }\n+\n+  Status WriteRecordBatch(const RecordBatch& batch) override {\n+    return WriteWithMetadata(batch, nullptr);\n+  }\n+\n+  Status WriteMetadata(std::shared_ptr<Buffer> app_metadata) override {\n+    FlightPayload payload{};\n+    payload.app_metadata = app_metadata;\n+    return WritePayload(payload);\n+  }\n+\n+  Status WriteWithMetadata(const RecordBatch& batch,\n+                           std::shared_ptr<Buffer> app_metadata) override {\n+    RETURN_NOT_OK(CheckStarted());\n+    RETURN_NOT_OK(EnsureDictionariesWritten(batch));\n+    FlightPayload payload{};\n+    if (app_metadata) {\n+      payload.app_metadata = app_metadata;\n+    }\n+    RETURN_NOT_OK(ipc::GetRecordBatchPayload(batch, ipc_options_, &payload.ipc_message));\n+    RETURN_NOT_OK(WritePayload(payload));\n+    ++stats_.num_record_batches;\n+    return Status::OK();\n+  }\n+\n+  Status Close() override {\n+    // It's fine to Close() without writing data\n+    return Status::OK();\n+  }\n+\n+  ipc::WriteStats stats() const override { return stats_; }\n+\n+ private:\n+  Status WritePayload(const FlightPayload& payload) {\n+    RETURN_NOT_OK(stream_->WriteData(payload));\n+    ++stats_.num_messages;\n+    return Status::OK();\n+  }\n+\n+  Status CheckStarted() {\n+    if (!started_) {\n+      return Status::Invalid(\"This writer is not started. Call Begin() with a schema\");\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status EnsureDictionariesWritten(const RecordBatch& batch) {\n+    if (dictionaries_written_) {\n+      return Status::OK();\n+    }\n+    dictionaries_written_ = true;\n+    ARROW_ASSIGN_OR_RAISE(const auto dictionaries,\n+                          ipc::CollectDictionaries(batch, mapper_));\n+    for (const auto& pair : dictionaries) {\n+      FlightPayload payload{};\n+      RETURN_NOT_OK(ipc::GetDictionaryPayload(pair.first, pair.second, ipc_options_,\n+                                              &payload.ipc_message));\n+      RETURN_NOT_OK(WritePayload(payload));\n+      ++stats_.num_dictionary_batches;\n+    }\n+    return Status::OK();\n+  }\n+\n+  TransportDataStream* stream_;\n+  ::arrow::ipc::IpcWriteOptions ipc_options_;\n+  ipc::DictionaryFieldMapper mapper_;\n+  ipc::WriteStats stats_;\n+  bool started_ = false;\n+  bool dictionaries_written_ = false;\n+};\n+\n+/// \\brief Adapt TransportDataStream to the FlightMetadataWriter\n+///   interface for DoPut.\n+class TransportMetadataWriter final : public FlightMetadataWriter {\n+ public:\n+  explicit TransportMetadataWriter(TransportDataStream* stream) : stream_(stream) {}\n+\n+  Status WriteMetadata(const Buffer& buffer) override {\n+    return stream_->WritePutMetadata(buffer);\n+  }\n+\n+ private:\n+  TransportDataStream* stream_;\n+};\n+}  // namespace\n+\n+Status FlightServiceImpl::DoGet(const ServerCallContext& context, const Ticket& ticket,\n+                                TransportDataStream* stream) {\n+  std::unique_ptr<FlightDataStream> data_stream;\n+  RETURN_NOT_OK(service_->DoGet(context, ticket, &data_stream));\n+\n+  if (!data_stream) return Status::KeyError(\"No data in this flight\");\n+\n+  // Write the schema as the first message in the stream\n+  FlightPayload schema_payload;\n+  RETURN_NOT_OK(data_stream->GetSchemaPayload(&schema_payload));\n+  auto status = stream->WriteData(schema_payload);\n+  // Connection terminated\n+  if (status.IsIOError()) return Status::OK();\n+  RETURN_NOT_OK(status);\n+\n+  // Consume data stream and write out payloads\n+  while (true) {\n+    FlightPayload payload;\n+    RETURN_NOT_OK(data_stream->Next(&payload));\n+    // End of stream\n+    if (payload.ipc_message.metadata == nullptr) break;\n+    auto status = stream->WriteData(payload);\n+    // Ignore IOError (used to signal that client disconnected; there's nothing\n+    // we can do - e.g. see WritePayload in serialization_internal.cc)\n+    if (status.IsIOError()) return Status::OK();\n+    RETURN_NOT_OK(status);\n+  }\n+  RETURN_NOT_OK(stream->WritesDone());\n+  return Status::OK();\n+}\n+\n+Status FlightServiceImpl::DoPut(const ServerCallContext& context,\n+                                TransportDataStream* stream) {\n+  std::unique_ptr<FlightMessageReader> reader(\n+      new TransportMessageReader(stream, memory_manager_));\n+  std::unique_ptr<FlightMetadataWriter> writer(new TransportMetadataWriter(stream));\n+  RETURN_NOT_OK(reinterpret_cast<TransportMessageReader*>(reader.get())->Init());\n\nReview comment:\n       This cast looks a bit strange. What about defining reader as ptr to TransportMessageReader (using make_unique) and calling reader->Init() here? Will it work?\n\n##########\nFile path: cpp/src/arrow/flight/transport_server_impl.cc\n##########\n@@ -0,0 +1,327 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/transport_impl.h\"\n+\n+#include <unordered_map>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/flight/serialization_internal.h\"\n+#include \"arrow/flight/server.h\"\n+#include \"arrow/flight/types.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+\n+namespace arrow {\n+namespace flight {\n+namespace internal {\n+\n+namespace {\n+class TransportIpcMessageReader : public ipc::MessageReader {\n+ public:\n+  explicit TransportIpcMessageReader(\n+      std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader,\n+      std::shared_ptr<MemoryManager> memory_manager,\n+      std::shared_ptr<Buffer>* app_metadata)\n+      : peekable_reader_(peekable_reader),\n+        memory_manager_(std::move(memory_manager)),\n+        app_metadata_(app_metadata) {}\n+\n+  ::arrow::Result<std::unique_ptr<ipc::Message>> ReadNextMessage() override {\n+    if (stream_finished_) {\n+      return nullptr;\n+    }\n+    internal::FlightData* data;\n+    peekable_reader_->Next(&data);\n+    if (!data) {\n+      stream_finished_ = true;\n+      if (first_message_) {\n\nReview comment:\n       Probably from legacy code, looks `first_message_` is always true? Or we should set it to false somewhere?\n\n##########\nFile path: cpp/src/arrow/flight/transport_server_impl.cc\n##########\n@@ -0,0 +1,327 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/transport_impl.h\"\n+\n+#include <unordered_map>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/flight/serialization_internal.h\"\n+#include \"arrow/flight/server.h\"\n+#include \"arrow/flight/types.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+\n+namespace arrow {\n+namespace flight {\n+namespace internal {\n+\n+namespace {\n+class TransportIpcMessageReader : public ipc::MessageReader {\n+ public:\n+  explicit TransportIpcMessageReader(\n+      std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader,\n+      std::shared_ptr<MemoryManager> memory_manager,\n+      std::shared_ptr<Buffer>* app_metadata)\n+      : peekable_reader_(peekable_reader),\n+        memory_manager_(std::move(memory_manager)),\n+        app_metadata_(app_metadata) {}\n+\n+  ::arrow::Result<std::unique_ptr<ipc::Message>> ReadNextMessage() override {\n+    if (stream_finished_) {\n+      return nullptr;\n+    }\n+    internal::FlightData* data;\n+    peekable_reader_->Next(&data);\n+    if (!data) {\n+      stream_finished_ = true;\n+      if (first_message_) {\n+        return Status::Invalid(\n+            \"Client provided malformed message or did not provide message\");\n+      }\n+      return nullptr;\n+    }\n+    if (data->body &&\n+        ARROW_PREDICT_FALSE(!data->body->device()->Equals(*memory_manager_->device()))) {\n+      ARROW_ASSIGN_OR_RAISE(data->body, Buffer::ViewOrCopy(data->body, memory_manager_));\n+    }\n+    *app_metadata_ = std::move(data->app_metadata);\n+    return data->OpenMessage();\n+  }\n+\n+ protected:\n+  std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader_;\n+  std::shared_ptr<MemoryManager> memory_manager_;\n+  // A reference to TransportDataStream.app_metadata_. That class\n+  // can't access the app metadata because when it Peek()s the stream,\n+  // it may be looking at a dictionary batch, not the record\n+  // batch. Updating it here ensures the reader is always updated with\n+  // the last metadata message read.\n+  std::shared_ptr<Buffer>* app_metadata_;\n+  bool first_message_ = true;\n+  bool stream_finished_ = false;\n+};\n+\n+/// \\brief Adapt TransportDataStream to the FlightMessageReader\n+///   interface for DoPut.\n+class TransportMessageReader final : public FlightMessageReader {\n+ public:\n+  explicit TransportMessageReader(TransportDataStream* stream,\n\nReview comment:\n       `explicit` can be removed\n\n##########\nFile path: cpp/src/arrow/flight/client.cc\n##########\n@@ -596,198 +427,257 @@ class GrpcStreamReader : public FlightStreamReader {\n     return ReadAll(table, stop_token_);\n   }\n   using FlightStreamReader::ReadAll;\n-  void Cancel() override { rpc_->context.TryCancel(); }\n+  void Cancel() override { stream_->TryCancel(); }\n \n  private:\n-  std::unique_lock<std::mutex> TakeGuard() {\n-    return read_mutex_ ? std::unique_lock<std::mutex>(*read_mutex_)\n-                       : std::unique_lock<std::mutex>();\n-  }\n-\n   Status OverrideWithServerError(Status&& st) {\n     if (st.ok()) {\n       return std::move(st);\n     }\n     return stream_->Finish(std::move(st));\n   }\n \n-  friend class GrpcIpcMessageReader<Reader>;\n-  std::shared_ptr<ClientRpc> rpc_;\n-  std::shared_ptr<MemoryManager> memory_manager_;\n-  // Guard reads with a lock to prevent Finish()/Close() from being\n-  // called on the writer while the reader has a pending\n-  // read. Nullable, as DoGet() doesn't need this.\n-  std::shared_ptr<std::mutex> read_mutex_;\n+  std::shared_ptr<internal::ClientDataStream> stream_;\n   ipc::IpcReadOptions options_;\n   StopToken stop_token_;\n-  std::shared_ptr<FinishableStream<Reader, internal::FlightData>> stream_;\n-  std::shared_ptr<internal::PeekableFlightDataReader<std::shared_ptr<Reader>>>\n-      peekable_reader_;\n+  std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader_;\n   std::shared_ptr<ipc::RecordBatchReader> batch_reader_;\n   std::shared_ptr<Buffer> app_metadata_;\n };\n \n-// The next two classes implement writing to a FlightData stream.\n-// Similarly to the read side, we want to reuse the implementation of\n-// RecordBatchWriter. As a result, these two classes are intertwined\n-// in order to pass application metadata \"through\" RecordBatchWriter.\n-// In order to get application-specific metadata to the\n-// IpcPayloadWriter, DoPutPayloadWriter takes a pointer to\n-// GrpcStreamWriter. GrpcStreamWriter updates a metadata field on\n-// write; DoPutPayloadWriter reads that metadata field to determine\n-// what to write.\n-\n-template <typename ProtoReadT, typename FlightReadT>\n-class DoPutPayloadWriter;\n-\n-template <typename ProtoReadT, typename FlightReadT>\n-class GrpcStreamWriter : public FlightStreamWriter {\n+FlightMetadataReader::~FlightMetadataReader() = default;\n+\n+/// \\brief The base of the ClientDataStream implementation for gRPC.\n+template <typename Stream, typename ReadPayload>\n+class FinishableDataStream : public internal::ClientDataStream {\n  public:\n-  ~GrpcStreamWriter() override = default;\n+  FinishableDataStream(std::shared_ptr<ClientRpc> rpc, std::shared_ptr<Stream> stream,\n+                       std::shared_ptr<MemoryManager> memory_manager)\n+      : rpc_(std::move(rpc)),\n+        stream_(std::move(stream)),\n+        memory_manager_(memory_manager ? std::move(memory_manager)\n+                                       : CPUDevice::Instance()->default_memory_manager()),\n+        finished_(false) {}\n \n-  using GrpcStream = grpc::ClientReaderWriter<pb::FlightData, ProtoReadT>;\n+  Status Finish() override {\n+    if (finished_) {\n+      return server_status_;\n+    }\n \n-  explicit GrpcStreamWriter(\n-      const FlightDescriptor& descriptor, std::shared_ptr<ClientRpc> rpc,\n-      int64_t write_size_limit_bytes, const ipc::IpcWriteOptions& options,\n-      std::shared_ptr<FinishableWritableStream<GrpcStream, FlightReadT>> writer)\n-      : app_metadata_(nullptr),\n-        batch_writer_(nullptr),\n-        writer_(std::move(writer)),\n-        rpc_(std::move(rpc)),\n-        write_size_limit_bytes_(write_size_limit_bytes),\n-        options_(options),\n-        descriptor_(descriptor),\n-        writer_closed_(false) {}\n+    // Drain the read side, as otherwise gRPC Finish() will hang. We\n+    // only call Finish() when the client closes the writer or the\n+    // reader finishes, so it's OK to assume the client no longer\n+    // wants to read and drain the read side. (If the client wants to\n+    // indicate that it is done writing, but not done reading, it\n+    // should use DoneWriting.\n+    ReadPayload message;\n+    while (internal::ReadPayload(stream_.get(), &message)) {\n+      // Drain the read side to avoid gRPC hanging in Finish()\n+    }\n \n-  static Status Open(\n-      const FlightDescriptor& descriptor, std::shared_ptr<Schema> schema,\n-      const ipc::IpcWriteOptions& options, std::shared_ptr<ClientRpc> rpc,\n-      int64_t write_size_limit_bytes,\n-      std::shared_ptr<FinishableWritableStream<GrpcStream, FlightReadT>> writer,\n-      std::unique_ptr<FlightStreamWriter>* out);\n+    server_status_ = internal::FromGrpcStatus(stream_->Finish(), &rpc_->context);\n+    if (!server_status_.ok()) {\n+      server_status_ = Status::FromDetailAndArgs(\n+          server_status_.code(), server_status_.detail(), server_status_.message(),\n+          \". gRPC client debug context: \", rpc_->context.debug_error_string());\n+    }\n+    finished_ = true;\n \n-  Status CheckStarted() {\n-    if (!batch_writer_) {\n-      return Status::Invalid(\"Writer not initialized. Call Begin() with a schema.\");\n+    return server_status_;\n+  }\n+  void TryCancel() override { rpc_->context.TryCancel(); }\n+\n+  std::shared_ptr<ClientRpc> rpc_;\n+  std::shared_ptr<Stream> stream_;\n+  std::shared_ptr<MemoryManager> memory_manager_;\n+  bool finished_;\n+  Status server_status_;\n+};\n+\n+/// \\brief A ClientDataStream implementation for gRPC that manages a\n+///   mutex to protect from concurrent reads/writes, and drains the\n+///   read side on finish.\n+template <typename Stream, typename ReadPayload>\n+class WritableDataStream : public FinishableDataStream<Stream, ReadPayload> {\n+ public:\n+  using Base = FinishableDataStream<Stream, ReadPayload>;\n+  WritableDataStream(std::shared_ptr<ClientRpc> rpc, std::shared_ptr<Stream> stream,\n+                     std::shared_ptr<MemoryManager> memory_manager)\n+      : Base(std::move(rpc), std::move(stream), std::move(memory_manager)),\n+        read_mutex_(),\n+        finish_mutex_(),\n+        done_writing_(false) {}\n+\n+  Status WritesDone() override {\n+    // This is only used by the writer side of a stream, so it need\n+    // not be protected with a lock.\n+    if (done_writing_) {\n+      return Status::OK();\n+    }\n+    done_writing_ = true;\n+    if (!stream_->WritesDone()) {\n+      // Error happened, try to close the stream to get more detailed info\n+      return internal::ClientDataStream::Finish(MakeFlightError(\n+          FlightStatusCode::Internal, \"Could not flush pending record batches\"));\n     }\n     return Status::OK();\n   }\n \n-  Status Begin(const std::shared_ptr<Schema>& schema,\n-               const ipc::IpcWriteOptions& options) override {\n-    if (batch_writer_) {\n-      return Status::Invalid(\"This writer has already been started.\");\n+  Status Finish() override {\n+    // This may be used concurrently by reader/writer side of a\n+    // stream, so it needs to be protected.\n+    std::lock_guard<std::mutex> guard(finish_mutex_);\n+\n+    // Now that we're shared between a reader and writer, we need to\n+    // protect ourselves from being called while there's an\n+    // outstanding read.\n+    std::unique_lock<std::mutex> read_guard(read_mutex_, std::try_to_lock);\n+    if (!read_guard.owns_lock()) {\n+      return MakeFlightError(FlightStatusCode::Internal,\n+                             \"Cannot close stream with pending read operation.\");\n     }\n-    std::unique_ptr<ipc::internal::IpcPayloadWriter> payload_writer(\n-        new DoPutPayloadWriter<ProtoReadT, FlightReadT>(\n-            descriptor_, std::move(rpc_), write_size_limit_bytes_, writer_, this));\n-    // XXX: this does not actually write the message to the stream.\n-    // See Close().\n-    ARROW_ASSIGN_OR_RAISE(batch_writer_, ipc::internal::OpenRecordBatchWriter(\n-                                             std::move(payload_writer), schema, options));\n-    return Status::OK();\n+\n+    // Try to flush pending writes. Don't use our WritesDone() to\n+    // avoid recursion.\n+    bool finished_writes = done_writing_ || stream_->WritesDone();\n+    done_writing_ = true;\n+\n+    Status st = Base::Finish();\n+    if (!finished_writes) {\n+      return Status::FromDetailAndArgs(\n+          st.code(), st.detail(), st.message(),\n+          \". Additionally, could not finish writing record batches before closing\");\n+    }\n+    return st;\n   }\n \n-  Status Begin(const std::shared_ptr<Schema>& schema) override {\n-    return Begin(schema, options_);\n+  using Base::stream_;\n+  std::mutex read_mutex_;\n+  std::mutex finish_mutex_;\n+  bool done_writing_;\n+};\n+\n+class GrpcClientGetStream\n+    : public FinishableDataStream<grpc::ClientReader<pb::FlightData>,\n+                                  internal::FlightData> {\n+ public:\n+  using FinishableDataStream::FinishableDataStream;\n+\n+  bool ReadData(internal::FlightData* data) override {\n+    bool success = internal::ReadPayload(stream_.get(), data);\n+    if (ARROW_PREDICT_FALSE(!success)) return false;\n+    if (data->body &&\n+        ARROW_PREDICT_FALSE(!data->body->device()->Equals(*memory_manager_->device()))) {\n+      auto status = Buffer::ViewOrCopy(data->body, memory_manager_).Value(&data->body);\n+      if (!status.ok()) {\n+        server_status_ = std::move(status);\n+        return false;\n+      }\n+    }\n+    return true;\n   }\n+  Status WritesDone() override { return Status::NotImplemented(\"NYI\"); }\n+};\n \n-  Status WriteRecordBatch(const RecordBatch& batch) override {\n-    RETURN_NOT_OK(CheckStarted());\n-    return WriteWithMetadata(batch, nullptr);\n+class GrpcClientPutStream\n+    : public WritableDataStream<grpc::ClientReaderWriter<pb::FlightData, pb::PutResult>,\n+                                pb::PutResult> {\n+ public:\n+  using Stream = grpc::ClientReaderWriter<pb::FlightData, pb::PutResult>;\n+  GrpcClientPutStream(std::shared_ptr<ClientRpc> rpc, std::shared_ptr<Stream> stream,\n+                      std::shared_ptr<MemoryManager> memory_manager)\n+      : WritableDataStream(std::move(rpc), std::move(stream), std::move(memory_manager)) {\n   }\n \n-  Status WriteMetadata(std::shared_ptr<Buffer> app_metadata) override {\n-    FlightPayload payload{};\n-    payload.app_metadata = app_metadata;\n-    auto status = internal::WritePayload(payload, writer_->stream().get());\n+  bool ReadPutMetadata(std::shared_ptr<Buffer>* out) override {\n+    std::lock_guard<std::mutex> guard(read_mutex_);\n+    pb::PutResult message;\n+    if (stream_->Read(&message)) {\n+      *out = Buffer::FromString(std::move(*message.mutable_app_metadata()));\n+    } else {\n+      // Stream finished\n+      *out = nullptr;\n+    }\n+    return true;\n+  }\n+  Status WriteData(const FlightPayload& payload) override {\n+    auto status = internal::WritePayload(payload, this->stream_.get());\n     if (status.IsIOError()) {\n-      return writer_->Finish(MakeFlightError(FlightStatusCode::Internal,\n-                                             \"Could not write metadata to stream\"));\n+      return internal::ClientDataStream::Finish(MakeFlightError(\n+          FlightStatusCode::Internal, \"Could not write record batch to stream\"));\n     }\n     return status;\n   }\n+};\n \n-  Status WriteWithMetadata(const RecordBatch& batch,\n-                           std::shared_ptr<Buffer> app_metadata) override {\n-    RETURN_NOT_OK(CheckStarted());\n-    app_metadata_ = app_metadata;\n-    return batch_writer_->WriteRecordBatch(batch);\n+class GrpcClientExchangeStream\n+    : public WritableDataStream<grpc::ClientReaderWriter<pb::FlightData, pb::FlightData>,\n+                                internal::FlightData> {\n+ public:\n+  using Stream = grpc::ClientReaderWriter<pb::FlightData, pb::FlightData>;\n+  GrpcClientExchangeStream(std::shared_ptr<ClientRpc> rpc, std::shared_ptr<Stream> stream,\n+                           std::shared_ptr<MemoryManager> memory_manager)\n+      : WritableDataStream(std::move(rpc), std::move(stream), std::move(memory_manager)) {\n   }\n \n-  Status DoneWriting() override {\n-    // Do not CheckStarted - DoneWriting applies to data and metadata\n-    if (batch_writer_) {\n-      // Close the writer if we have one; this will force it to flush any\n-      // remaining data, before we close the write side of the stream.\n-      writer_closed_ = true;\n-      Status st = batch_writer_->Close();\n-      if (!st.ok()) {\n-        return writer_->Finish(std::move(st));\n+  bool ReadData(internal::FlightData* data) override {\n+    std::lock_guard<std::mutex> guard(read_mutex_);\n+    bool success = internal::ReadPayload(stream_.get(), data);\n+    if (ARROW_PREDICT_FALSE(!success)) return false;\n+    if (data->body &&\n+        ARROW_PREDICT_FALSE(!data->body->device()->Equals(*memory_manager_->device()))) {\n+      auto status = Buffer::ViewOrCopy(data->body, memory_manager_).Value(&data->body);\n+      if (!status.ok()) {\n+        server_status_ = std::move(status);\n+        return false;\n       }\n     }\n-    return writer_->DoneWriting();\n+    return true;\n   }\n-\n-  Status Close() override {\n-    // Do not CheckStarted - Close applies to data and metadata\n-    if (batch_writer_ && !writer_closed_) {\n-      // This is important! Close() calls\n-      // IpcPayloadWriter::CheckStarted() which will force the initial\n-      // schema message to be written to the stream. This is required\n-      // to unstick the server, else the client and the server end up\n-      // waiting for each other. This happens if the client never\n-      // wrote anything before calling Close().\n-      writer_closed_ = true;\n-      return writer_->Finish(batch_writer_->Close());\n+  Status WriteData(const FlightPayload& payload) override {\n+    auto status = internal::WritePayload(payload, this->stream_.get());\n+    if (status.IsIOError()) {\n+      return internal::ClientDataStream::Finish(MakeFlightError(\n+          FlightStatusCode::Internal, \"Could not write record batch to stream\"));\n     }\n-    return writer_->Finish(Status::OK());\n+    return status;\n   }\n+};\n \n-  ipc::WriteStats stats() const override {\n-    ARROW_CHECK_NE(batch_writer_, nullptr);\n-    return batch_writer_->stats();\n+class ClientMetadataReader : public FlightMetadataReader {\n+ public:\n+  explicit ClientMetadataReader(std::shared_ptr<internal::ClientDataStream> stream)\n+      : stream_(std::move(stream)) {}\n+\n+  Status ReadMetadata(std::shared_ptr<Buffer>* out) override {\n+    if (!stream_->ReadPutMetadata(out)) {\n+      return stream_->Finish(Status::OK());\n+    }\n+    return Status::OK();\n   }\n \n  private:\n-  friend class DoPutPayloadWriter<ProtoReadT, FlightReadT>;\n-  std::shared_ptr<Buffer> app_metadata_;\n-  std::unique_ptr<ipc::RecordBatchWriter> batch_writer_;\n-  std::shared_ptr<FinishableWritableStream<GrpcStream, FlightReadT>> writer_;\n-\n-  // Fields used to lazy-initialize the IpcPayloadWriter. They're\n-  // invalid once Begin() is called.\n-  std::shared_ptr<ClientRpc> rpc_;\n-  int64_t write_size_limit_bytes_;\n-  ipc::IpcWriteOptions options_;\n-  FlightDescriptor descriptor_;\n-  bool writer_closed_;\n+  std::shared_ptr<internal::ClientDataStream> stream_;\n };\n \n-/// A IpcPayloadWriter implementation that writes to a gRPC stream of\n-/// FlightData messages.\n-template <typename ProtoReadT, typename FlightReadT>\n-class DoPutPayloadWriter : public ipc::internal::IpcPayloadWriter {\n+/// \\brief An IpcPayloadWriter for any ClientDataStream.\n+///\n+/// To support app_metadata and reuse the existing IPC infrastructure,\n+/// this takes a pointer to a buffer to be combined with the IPC\n+/// payload when writing a Flight payload.\n+class ClientPutPayloadWriter : public ipc::internal::IpcPayloadWriter {\n  public:\n-  using GrpcStream = grpc::ClientReaderWriter<pb::FlightData, ProtoReadT>;\n-\n-  DoPutPayloadWriter(\n-      const FlightDescriptor& descriptor, std::shared_ptr<ClientRpc> rpc,\n-      int64_t write_size_limit_bytes,\n-      std::shared_ptr<FinishableWritableStream<GrpcStream, FlightReadT>> writer,\n-      GrpcStreamWriter<ProtoReadT, FlightReadT>* stream_writer)\n-      : descriptor_(descriptor),\n-        rpc_(rpc),\n+  explicit ClientPutPayloadWriter(std::shared_ptr<internal::ClientDataStream> stream,\n\nReview comment:\n       `explicit` can be removed\n\n##########\nFile path: cpp/src/arrow/flight/client.cc\n##########\n@@ -477,15 +334,9 @@ class GrpcIpcMessageReader : public ipc::MessageReader {\n   }\n \n  private:\n-  // The RPC context lifetime must be coupled to the ClientReader\n-  std::shared_ptr<ClientRpc> rpc_;\n+  std::shared_ptr<internal::ClientDataStream> stream_;\n+  std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader_;\n   std::shared_ptr<MemoryManager> memory_manager_;\n-  // Guard reads with a mutex to prevent concurrent reads if the write\n-  // side calls Finish(). Nullable as DoGet doesn't need this.\n-  std::shared_ptr<std::mutex> read_mutex_;\n\nReview comment:\n       The lock is not necessary now?\n\n##########\nFile path: cpp/src/arrow/flight/transport_impl.h\n##########\n@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Internal (but not private) interface for implementing alternate\n+// transports in Flight.\n+//\n+// EXPERIMENTAL. Subject to change.\n+\n+#pragma once\n+\n+#include <chrono>\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/flight/type_fwd.h\"\n+#include \"arrow/flight/visibility.h\"\n+#include \"arrow/type_fwd.h\"\n+\n+namespace arrow {\n+namespace ipc {\n+class Message;\n+}\n+namespace flight {\n+namespace internal {\n+\n+/// Internal, not user-visible type used for memory-efficient reads from gRPC\n\nReview comment:\n       not only `gRPC`?\n\n##########\nFile path: cpp/src/arrow/flight/transport_impl.h\n##########\n@@ -0,0 +1,221 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Internal (but not private) interface for implementing alternate\n+// transports in Flight.\n+//\n+// EXPERIMENTAL. Subject to change.\n+\n+#pragma once\n+\n+#include <chrono>\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"arrow/flight/type_fwd.h\"\n+#include \"arrow/flight/visibility.h\"\n+#include \"arrow/type_fwd.h\"\n+\n+namespace arrow {\n+namespace ipc {\n+class Message;\n+}\n+namespace flight {\n+namespace internal {\n+\n+/// Internal, not user-visible type used for memory-efficient reads from gRPC\n+/// stream\n+struct FlightData {\n+  /// Used only for puts, may be null\n+  std::unique_ptr<FlightDescriptor> descriptor;\n+\n+  /// Non-length-prefixed Message header as described in format/Message.fbs\n+  std::shared_ptr<Buffer> metadata;\n+\n+  /// Application-defined metadata\n+  std::shared_ptr<Buffer> app_metadata;\n+\n+  /// Message body\n+  std::shared_ptr<Buffer> body;\n+\n+  /// Open IPC message from the metadata and body\n+  ::arrow::Result<std::unique_ptr<ipc::Message>> OpenMessage();\n+};\n+\n+/// \\brief An transport-specific interface for reading/writing Arrow data.\n+///\n+/// New transports will implement this to read/write IPC payloads to\n+/// the underlying stream.\n+class ARROW_FLIGHT_EXPORT TransportDataStream {\n+ public:\n+  virtual ~TransportDataStream() = default;\n+  /// \\brief Attemnpt to read the next FlightData message.\n+  ///\n+  /// \\return success true if data was populated, false if there was\n+  ///   an error. For clients, the error can be retrieved from Finish.\n+  virtual bool ReadData(FlightData* data);\n\nReview comment:\n       Can this also return `Status`?\r\n   Looks it's called by `PeekableFlightDataReader` and error message is not populated there, so `Status`is not necessary?\n\n##########\nFile path: cpp/src/arrow/flight/server.cc\n##########\n@@ -442,20 +196,69 @@ class GrpcAddCallHeaders : public AddCallHeaders {\n   grpc::ServerContext* context_;\n };\n \n+class GetDataStream : public internal::TransportDataStream {\n+ public:\n+  explicit GetDataStream(ServerWriter<pb::FlightData>* writer) : writer_(writer) {}\n+\n+  Status WriteData(const FlightPayload& payload) override {\n+    return internal::WritePayload(payload, writer_);\n+  }\n+\n+ private:\n+  ServerWriter<pb::FlightData>* writer_;\n+};\n+\n+class PutDataStream final : public internal::TransportDataStream {\n+ public:\n+  explicit PutDataStream(grpc::ServerReaderWriter<pb::PutResult, pb::FlightData>* stream)\n+      : stream_(stream) {}\n+\n+  bool ReadData(internal::FlightData* data) override {\n+    return internal::ReadPayload(&*stream_, data);\n+  }\n+  Status WritePutMetadata(const Buffer& metadata) override {\n+    pb::PutResult message{};\n+    message.set_app_metadata(metadata.data(), metadata.size());\n+    if (stream_->Write(message)) {\n+      return Status::OK();\n+    }\n+    return Status::IOError(\"Unknown error writing metadata.\");\n+  }\n+\n+ private:\n+  grpc::ServerReaderWriter<pb::PutResult, pb::FlightData>* stream_;\n+};\n+\n+class ExchangeDataStream final : public internal::TransportDataStream {\n+ public:\n+  explicit ExchangeDataStream(\n+      grpc::ServerReaderWriter<pb::FlightData, pb::FlightData>* stream)\n+      : stream_(stream) {}\n+\n+  bool ReadData(internal::FlightData* data) override {\n+    return internal::ReadPayload(&*stream_, data);\n+  }\n+  Status WriteData(const FlightPayload& payload) override {\n+    return internal::WritePayload(payload, stream_);\n+  }\n+\n+ private:\n+  grpc::ServerReaderWriter<pb::FlightData, pb::FlightData>* stream_;\n+};\n+\n // This class glues an implementation of FlightServerBase together with the\n // gRPC service definition, so the latter is not exposed in the public API\n-class FlightServiceImpl : public FlightService::Service {\n+class FlightGrpcServiceImpl : public FlightService::Service {\n  public:\n-  explicit FlightServiceImpl(\n+  explicit FlightGrpcServiceImpl(\n\nReview comment:\n       `explicit` can be removed\n\n##########\nFile path: cpp/src/arrow/flight/transport_server_impl.cc\n##########\n@@ -0,0 +1,327 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/transport_impl.h\"\n+\n+#include <unordered_map>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/flight/serialization_internal.h\"\n+#include \"arrow/flight/server.h\"\n+#include \"arrow/flight/types.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+\n+namespace arrow {\n+namespace flight {\n+namespace internal {\n+\n+namespace {\n+class TransportIpcMessageReader : public ipc::MessageReader {\n+ public:\n+  explicit TransportIpcMessageReader(\n\nReview comment:\n       `explicit` is not necessary\n\n##########\nFile path: cpp/src/arrow/flight/transport_impl.cc\n##########\n@@ -0,0 +1,163 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/transport_impl.h\"\n+\n+#include <unordered_map>\n+\n+#include \"arrow/flight/client_auth.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/make_unique.h\"\n+\n+namespace arrow {\n+namespace flight {\n+namespace internal {\n+\n+bool TransportDataStream::ReadData(internal::FlightData*) { return false; }\n+Status TransportDataStream::WriteData(const FlightPayload&) {\n+  return Status::NotImplemented(\"Writing data for this stream\");\n+}\n+Status TransportDataStream::WritePutMetadata(const Buffer&) {\n+  return Status::NotImplemented(\"Writing put metadata for this stream\");\n+}\n+Status TransportDataStream::WritesDone() { return Status::OK(); }\n+bool ClientDataStream::ReadPutMetadata(std::shared_ptr<Buffer>*) { return false; }\n+Status ClientDataStream::Finish(Status st) {\n+  auto server_status = Finish();\n+  if (server_status.ok()) return st;\n+\n+  return Status::FromDetailAndArgs(server_status.code(), server_status.detail(),\n+                                   server_status.message(),\n+                                   \". Client context: \", st.ToString());\n+}\n+\n+Status ClientTransportImpl::Authenticate(\n+    const FlightCallOptions& options, std::unique_ptr<ClientAuthHandler> auth_handler) {\n+  return Status::NotImplemented(\"Authenticate for this transport\");\n+}\n+arrow::Result<std::pair<std::string, std::string>>\n+ClientTransportImpl::AuthenticateBasicToken(const FlightCallOptions& options,\n+                                            const std::string& username,\n+                                            const std::string& password) {\n+  return Status::NotImplemented(\"AuthenticateBasicToken for this transport\");\n+}\n+Status ClientTransportImpl::DoAction(const FlightCallOptions& options,\n+                                     const Action& action,\n+                                     std::unique_ptr<ResultStream>* results) {\n+  return Status::NotImplemented(\"DoAction for this transport\");\n+}\n+Status ClientTransportImpl::ListActions(const FlightCallOptions& options,\n+                                        std::vector<ActionType>* actions) {\n+  return Status::NotImplemented(\"ListActions for this transport\");\n+}\n+Status ClientTransportImpl::GetFlightInfo(const FlightCallOptions& options,\n+                                          const FlightDescriptor& descriptor,\n+                                          std::unique_ptr<FlightInfo>* info) {\n+  return Status::NotImplemented(\"GetFlightInfo for this transport\");\n+}\n+Status ClientTransportImpl::GetSchema(const FlightCallOptions& options,\n+                                      const FlightDescriptor& descriptor,\n+                                      std::unique_ptr<SchemaResult>* schema_result) {\n+  return Status::NotImplemented(\"GetSchema for this transport\");\n+}\n+Status ClientTransportImpl::ListFlights(const FlightCallOptions& options,\n+                                        const Criteria& criteria,\n+                                        std::unique_ptr<FlightListing>* listing) {\n+  return Status::NotImplemented(\"ListFlights for this transport\");\n+}\n+Status ClientTransportImpl::DoGet(const FlightCallOptions& options, const Ticket& ticket,\n+                                  std::unique_ptr<ClientDataStream>* stream) {\n+  return Status::NotImplemented(\"DoGet for this transport\");\n+}\n+Status ClientTransportImpl::DoPut(const FlightCallOptions& options,\n+                                  std::unique_ptr<ClientDataStream>* stream) {\n+  return Status::NotImplemented(\"DoPut for this transport\");\n+}\n+Status ClientTransportImpl::DoExchange(const FlightCallOptions& options,\n+                                       std::unique_ptr<ClientDataStream>* stream) {\n+  return Status::NotImplemented(\"DoExchange for this transport\");\n+}\n+\n+class TransportImplRegistry::Impl {\n+ public:\n+  arrow::Result<std::unique_ptr<ClientTransportImpl>> MakeClientImpl(\n+      const std::string& scheme) {\n+    auto it = client_factories_.find(scheme);\n+    if (it == client_factories_.end()) {\n+      return Status::KeyError(\"No client transport implementation for \", scheme);\n+    }\n+    return it->second();\n+  }\n+  arrow::Result<std::unique_ptr<ServerTransportImpl>> MakeServerImpl(\n+      const std::string& scheme) {\n+    auto it = server_factories_.find(scheme);\n+    if (it == server_factories_.end()) {\n+      return Status::KeyError(\"No server transport implementation for \", scheme);\n+    }\n+    return it->second();\n+  }\n+  Status RegisterClient(const std::string& scheme, ClientFactory factory) {\n+    auto it = client_factories_.insert({scheme, std::move(factory)});\n+    if (!it.second) {\n+      return Status::Invalid(\"Client transport already registered for \", scheme);\n+    }\n+    return Status::OK();\n+  }\n+  Status RegisterServer(const std::string& scheme, ServerFactory factory) {\n+    auto it = server_factories_.insert({scheme, std::move(factory)});\n+    if (!it.second) {\n+      return Status::Invalid(\"Server transport already registered for \", scheme);\n+    }\n+    return Status::OK();\n+  }\n+\n+ private:\n+  std::unordered_map<std::string, TransportImplRegistry::ClientFactory> client_factories_;\n+  std::unordered_map<std::string, TransportImplRegistry::ServerFactory> server_factories_;\n+};\n+\n+TransportImplRegistry::TransportImplRegistry() {\n+  impl_ = arrow::internal::make_unique<Impl>();\n+}\n+TransportImplRegistry::~TransportImplRegistry() = default;\n+arrow::Result<std::unique_ptr<ClientTransportImpl>> TransportImplRegistry::MakeClientImpl(\n+    const std::string& scheme) {\n+  return impl_->MakeClientImpl(scheme);\n+}\n+arrow::Result<std::unique_ptr<ServerTransportImpl>> TransportImplRegistry::MakeServerImpl(\n+    const std::string& scheme) {\n+  return impl_->MakeServerImpl(scheme);\n+}\n+Status TransportImplRegistry::RegisterClient(const std::string& scheme,\n+                                             ClientFactory factory) {\n+  return impl_->RegisterClient(scheme, std::move(factory));\n+}\n+Status TransportImplRegistry::RegisterServer(const std::string& scheme,\n+                                             ServerFactory factory) {\n+  return impl_->RegisterServer(scheme, std::move(factory));\n+}\n+\n+TransportImplRegistry* GetDefaultTransportImplRegistry() {\n+  static std::unique_ptr<TransportImplRegistry> kRegistry =\n+      arrow::internal::make_unique<TransportImplRegistry>();\n+  return kRegistry.get();\n\nReview comment:\n       `unique_ptr` looks not necessary, return address of a static instance?\n\n##########\nFile path: cpp/src/arrow/flight/client.cc\n##########\n@@ -428,22 +298,18 @@ class GrpcClientAuthReader : public ClientAuthReader {\n       stream_;\n };\n \n-// An ipc::MessageReader that adapts any readable gRPC stream\n-// returning FlightData.\n-template <typename Reader>\n-class GrpcIpcMessageReader : public ipc::MessageReader {\n+/// \\brief An ipc::MessageReader adapting the Flight ClientDataStream interface.\n+///\n+/// In order to support app_metadata and reuse the existing IPC\n+/// infrastructure, this takes a pointer to a buffer (provided by the\n+/// FlightStreamReader implementation) and upon reading a message,\n+/// updates that buffer with the one read from the server.\n+class IpcMessageReader : public ipc::MessageReader {\n\nReview comment:\n       Is this file grpc only or some classes are general?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-24T06:43:09.611+0000",
                    "updated": "2022-02-24T06:43:09.611+0000",
                    "started": "2022-02-24T06:43:09.611+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "732141",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/732382",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #12465:\nURL: https://github.com/apache/arrow/pull/12465#discussion_r813965377\n\n\n\n##########\nFile path: cpp/src/arrow/flight/transport_server_impl.cc\n##########\n@@ -0,0 +1,327 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/transport_impl.h\"\n+\n+#include <unordered_map>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/flight/serialization_internal.h\"\n+#include \"arrow/flight/server.h\"\n+#include \"arrow/flight/types.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+\n+namespace arrow {\n+namespace flight {\n+namespace internal {\n+\n+namespace {\n+class TransportIpcMessageReader : public ipc::MessageReader {\n+ public:\n+  explicit TransportIpcMessageReader(\n+      std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader,\n+      std::shared_ptr<MemoryManager> memory_manager,\n+      std::shared_ptr<Buffer>* app_metadata)\n+      : peekable_reader_(peekable_reader),\n+        memory_manager_(std::move(memory_manager)),\n+        app_metadata_(app_metadata) {}\n+\n+  ::arrow::Result<std::unique_ptr<ipc::Message>> ReadNextMessage() override {\n+    if (stream_finished_) {\n+      return nullptr;\n+    }\n+    internal::FlightData* data;\n+    peekable_reader_->Next(&data);\n+    if (!data) {\n+      stream_finished_ = true;\n+      if (first_message_) {\n\nReview comment:\n       Hmm, I'll have to check why tests didn't catch this - thanks\n\n##########\nFile path: cpp/src/arrow/flight/transport_server_impl.cc\n##########\n@@ -0,0 +1,327 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/transport_impl.h\"\n+\n+#include <unordered_map>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/flight/serialization_internal.h\"\n+#include \"arrow/flight/server.h\"\n+#include \"arrow/flight/types.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+\n+namespace arrow {\n+namespace flight {\n+namespace internal {\n+\n+namespace {\n+class TransportIpcMessageReader : public ipc::MessageReader {\n+ public:\n+  explicit TransportIpcMessageReader(\n+      std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader,\n+      std::shared_ptr<MemoryManager> memory_manager,\n+      std::shared_ptr<Buffer>* app_metadata)\n+      : peekable_reader_(peekable_reader),\n+        memory_manager_(std::move(memory_manager)),\n+        app_metadata_(app_metadata) {}\n+\n+  ::arrow::Result<std::unique_ptr<ipc::Message>> ReadNextMessage() override {\n+    if (stream_finished_) {\n+      return nullptr;\n+    }\n+    internal::FlightData* data;\n+    peekable_reader_->Next(&data);\n+    if (!data) {\n+      stream_finished_ = true;\n+      if (first_message_) {\n+        return Status::Invalid(\n+            \"Client provided malformed message or did not provide message\");\n+      }\n+      return nullptr;\n+    }\n+    if (data->body &&\n+        ARROW_PREDICT_FALSE(!data->body->device()->Equals(*memory_manager_->device()))) {\n+      ARROW_ASSIGN_OR_RAISE(data->body, Buffer::ViewOrCopy(data->body, memory_manager_));\n+    }\n+    *app_metadata_ = std::move(data->app_metadata);\n+    return data->OpenMessage();\n+  }\n+\n+ protected:\n+  std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader_;\n+  std::shared_ptr<MemoryManager> memory_manager_;\n+  // A reference to TransportDataStream.app_metadata_. That class\n+  // can't access the app metadata because when it Peek()s the stream,\n+  // it may be looking at a dictionary batch, not the record\n+  // batch. Updating it here ensures the reader is always updated with\n+  // the last metadata message read.\n+  std::shared_ptr<Buffer>* app_metadata_;\n+  bool first_message_ = true;\n+  bool stream_finished_ = false;\n+};\n+\n+/// \\brief Adapt TransportDataStream to the FlightMessageReader\n+///   interface for DoPut.\n+class TransportMessageReader final : public FlightMessageReader {\n+ public:\n+  explicit TransportMessageReader(TransportDataStream* stream,\n+                                  std::shared_ptr<MemoryManager> memory_manager)\n+      : peekable_reader_(new internal::PeekableFlightDataReader(stream)),\n+        memory_manager_(std::move(memory_manager)) {}\n+\n+  Status Init() {\n+    // Peek the first message to get the descriptor.\n+    internal::FlightData* data;\n+    peekable_reader_->Peek(&data);\n+    if (!data) {\n+      return Status::IOError(\"Stream finished before first message sent\");\n+    }\n+    if (!data->descriptor) {\n+      return Status::IOError(\"Descriptor missing on first message\");\n+    }\n+    descriptor_ = *data->descriptor;\n+    // If there's a schema (=DoPut), also Open().\n+    if (data->metadata) {\n+      return EnsureDataStarted();\n+    }\n+    peekable_reader_->Next(&data);\n+    return Status::OK();\n+  }\n+\n+  const FlightDescriptor& descriptor() const override { return descriptor_; }\n+\n+  arrow::Result<std::shared_ptr<Schema>> GetSchema() override {\n+    RETURN_NOT_OK(EnsureDataStarted());\n+    return batch_reader_->schema();\n+  }\n+\n+  Status Next(FlightStreamChunk* out) override {\n+    internal::FlightData* data;\n+    peekable_reader_->Peek(&data);\n+    if (!data) {\n+      out->app_metadata = nullptr;\n+      out->data = nullptr;\n+      return Status::OK();\n+    }\n+\n+    if (!data->metadata) {\n+      // Metadata-only (data->metadata is the IPC header)\n+      out->app_metadata = data->app_metadata;\n+      out->data = nullptr;\n+      peekable_reader_->Next(&data);\n+      return Status::OK();\n+    }\n+\n+    if (!batch_reader_) {\n+      RETURN_NOT_OK(EnsureDataStarted());\n+      // re-peek here since EnsureDataStarted() advances the stream\n+      return Next(out);\n+    }\n+    RETURN_NOT_OK(batch_reader_->ReadNext(&out->data));\n+    out->app_metadata = std::move(app_metadata_);\n+    return Status::OK();\n+  }\n+\n+ private:\n+  /// Ensure we are set up to read data.\n+  Status EnsureDataStarted() {\n+    if (!batch_reader_) {\n+      // peek() until we find the first data message; discard metadata\n+      if (!peekable_reader_->SkipToData()) {\n+        return Status::IOError(\"Client never sent a data message\");\n+      }\n+      auto message_reader =\n+          std::unique_ptr<ipc::MessageReader>(new TransportIpcMessageReader(\n+              peekable_reader_, memory_manager_, &app_metadata_));\n+      ARROW_ASSIGN_OR_RAISE(\n+          batch_reader_, ipc::RecordBatchStreamReader::Open(std::move(message_reader)));\n+    }\n+    return Status::OK();\n+  }\n+\n+  FlightDescriptor descriptor_;\n+  std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader_;\n+  std::shared_ptr<MemoryManager> memory_manager_;\n+  std::shared_ptr<RecordBatchReader> batch_reader_;\n+  std::shared_ptr<Buffer> app_metadata_;\n+};\n+\n+// TODO(ARROW-10787): this should use the same writer/ipc trick as client\n+class TransportMessageWriter final : public FlightMessageWriter {\n+ public:\n+  explicit TransportMessageWriter(TransportDataStream* stream)\n+      : stream_(stream), ipc_options_(::arrow::ipc::IpcWriteOptions::Defaults()) {}\n+\n+  Status Begin(const std::shared_ptr<Schema>& schema,\n+               const ipc::IpcWriteOptions& options) override {\n+    if (started_) {\n+      return Status::Invalid(\"This writer has already been started.\");\n+    }\n+    started_ = true;\n+    ipc_options_ = options;\n+\n+    RETURN_NOT_OK(mapper_.AddSchemaFields(*schema));\n+    FlightPayload schema_payload;\n+    RETURN_NOT_OK(ipc::GetSchemaPayload(*schema, ipc_options_, mapper_,\n+                                        &schema_payload.ipc_message));\n+    return WritePayload(schema_payload);\n+  }\n+\n+  Status WriteRecordBatch(const RecordBatch& batch) override {\n+    return WriteWithMetadata(batch, nullptr);\n+  }\n+\n+  Status WriteMetadata(std::shared_ptr<Buffer> app_metadata) override {\n+    FlightPayload payload{};\n+    payload.app_metadata = app_metadata;\n+    return WritePayload(payload);\n+  }\n+\n+  Status WriteWithMetadata(const RecordBatch& batch,\n+                           std::shared_ptr<Buffer> app_metadata) override {\n+    RETURN_NOT_OK(CheckStarted());\n+    RETURN_NOT_OK(EnsureDictionariesWritten(batch));\n+    FlightPayload payload{};\n+    if (app_metadata) {\n+      payload.app_metadata = app_metadata;\n+    }\n+    RETURN_NOT_OK(ipc::GetRecordBatchPayload(batch, ipc_options_, &payload.ipc_message));\n+    RETURN_NOT_OK(WritePayload(payload));\n+    ++stats_.num_record_batches;\n+    return Status::OK();\n+  }\n+\n+  Status Close() override {\n+    // It's fine to Close() without writing data\n+    return Status::OK();\n+  }\n+\n+  ipc::WriteStats stats() const override { return stats_; }\n+\n+ private:\n+  Status WritePayload(const FlightPayload& payload) {\n+    RETURN_NOT_OK(stream_->WriteData(payload));\n+    ++stats_.num_messages;\n+    return Status::OK();\n+  }\n+\n+  Status CheckStarted() {\n+    if (!started_) {\n+      return Status::Invalid(\"This writer is not started. Call Begin() with a schema\");\n+    }\n+    return Status::OK();\n+  }\n+\n+  Status EnsureDictionariesWritten(const RecordBatch& batch) {\n+    if (dictionaries_written_) {\n+      return Status::OK();\n+    }\n+    dictionaries_written_ = true;\n+    ARROW_ASSIGN_OR_RAISE(const auto dictionaries,\n+                          ipc::CollectDictionaries(batch, mapper_));\n+    for (const auto& pair : dictionaries) {\n+      FlightPayload payload{};\n+      RETURN_NOT_OK(ipc::GetDictionaryPayload(pair.first, pair.second, ipc_options_,\n+                                              &payload.ipc_message));\n+      RETURN_NOT_OK(WritePayload(payload));\n+      ++stats_.num_dictionary_batches;\n+    }\n+    return Status::OK();\n+  }\n+\n+  TransportDataStream* stream_;\n+  ::arrow::ipc::IpcWriteOptions ipc_options_;\n+  ipc::DictionaryFieldMapper mapper_;\n+  ipc::WriteStats stats_;\n+  bool started_ = false;\n+  bool dictionaries_written_ = false;\n+};\n+\n+/// \\brief Adapt TransportDataStream to the FlightMetadataWriter\n+///   interface for DoPut.\n+class TransportMetadataWriter final : public FlightMetadataWriter {\n+ public:\n+  explicit TransportMetadataWriter(TransportDataStream* stream) : stream_(stream) {}\n+\n+  Status WriteMetadata(const Buffer& buffer) override {\n+    return stream_->WritePutMetadata(buffer);\n+  }\n+\n+ private:\n+  TransportDataStream* stream_;\n+};\n+}  // namespace\n+\n+Status FlightServiceImpl::DoGet(const ServerCallContext& context, const Ticket& ticket,\n+                                TransportDataStream* stream) {\n+  std::unique_ptr<FlightDataStream> data_stream;\n+  RETURN_NOT_OK(service_->DoGet(context, ticket, &data_stream));\n+\n+  if (!data_stream) return Status::KeyError(\"No data in this flight\");\n+\n+  // Write the schema as the first message in the stream\n+  FlightPayload schema_payload;\n+  RETURN_NOT_OK(data_stream->GetSchemaPayload(&schema_payload));\n+  auto status = stream->WriteData(schema_payload);\n+  // Connection terminated\n+  if (status.IsIOError()) return Status::OK();\n+  RETURN_NOT_OK(status);\n+\n+  // Consume data stream and write out payloads\n+  while (true) {\n+    FlightPayload payload;\n+    RETURN_NOT_OK(data_stream->Next(&payload));\n+    // End of stream\n+    if (payload.ipc_message.metadata == nullptr) break;\n+    auto status = stream->WriteData(payload);\n+    // Ignore IOError (used to signal that client disconnected; there's nothing\n+    // we can do - e.g. see WritePayload in serialization_internal.cc)\n+    if (status.IsIOError()) return Status::OK();\n+    RETURN_NOT_OK(status);\n+  }\n+  RETURN_NOT_OK(stream->WritesDone());\n+  return Status::OK();\n+}\n+\n+Status FlightServiceImpl::DoPut(const ServerCallContext& context,\n+                                TransportDataStream* stream) {\n+  std::unique_ptr<FlightMessageReader> reader(\n+      new TransportMessageReader(stream, memory_manager_));\n+  std::unique_ptr<FlightMetadataWriter> writer(new TransportMetadataWriter(stream));\n+  RETURN_NOT_OK(reinterpret_cast<TransportMessageReader*>(reader.get())->Init());\n\nReview comment:\n       Ah, yes, we can just declare the unique_ptr as the subclass and its type will be converted when we std::move it, thanks!\n\n##########\nFile path: cpp/src/arrow/flight/client.cc\n##########\n@@ -428,22 +298,18 @@ class GrpcClientAuthReader : public ClientAuthReader {\n       stream_;\n };\n \n-// An ipc::MessageReader that adapts any readable gRPC stream\n-// returning FlightData.\n-template <typename Reader>\n-class GrpcIpcMessageReader : public ipc::MessageReader {\n+/// \\brief An ipc::MessageReader adapting the Flight ClientDataStream interface.\n+///\n+/// In order to support app_metadata and reuse the existing IPC\n+/// infrastructure, this takes a pointer to a buffer (provided by the\n+/// FlightStreamReader implementation) and upon reading a message,\n+/// updates that buffer with the one read from the server.\n+class IpcMessageReader : public ipc::MessageReader {\n\nReview comment:\n       Some classes are general. I would like to split them up further in the future, e.g. move out all the gRPC stuff into `arrow/flight/transport/grpc` like how the UCX transport is structured.\n\n##########\nFile path: cpp/src/arrow/flight/test_util.h\n##########\n@@ -82,24 +82,43 @@ std::unique_ptr<FlightServerBase> ExampleTestServer();\n // Helper to initialize a server and matching client with callbacks to\n // populate options.\n template <typename T, typename... Args>\n-Status MakeServer(std::unique_ptr<FlightServerBase>* server,\n+Status MakeServer(const Location& location, std::unique_ptr<FlightServerBase>* server,\n                   std::unique_ptr<FlightClient>* client,\n                   std::function<Status(FlightServerOptions*)> make_server_options,\n                   std::function<Status(FlightClientOptions*)> make_client_options,\n                   Args&&... server_args) {\n-  Location location;\n-  RETURN_NOT_OK(Location::ForGrpcTcp(\"localhost\", 0, &location));\n   *server = arrow::internal::make_unique<T>(std::forward<Args>(server_args)...);\n   FlightServerOptions server_options(location);\n   RETURN_NOT_OK(make_server_options(&server_options));\n   RETURN_NOT_OK((*server)->Init(server_options));\n   Location real_location;\n-  RETURN_NOT_OK(Location::ForGrpcTcp(\"localhost\", (*server)->port(), &real_location));\n+  if ((*server)->port() > 0) {\n\nReview comment:\n       I'll have to double check if this is still necessary, this is from my initial exploration when I didn't use UCX's listener feature (and hence there was no concept of a 'port')\n\n##########\nFile path: cpp/src/arrow/flight/client.cc\n##########\n@@ -477,15 +334,9 @@ class GrpcIpcMessageReader : public ipc::MessageReader {\n   }\n \n  private:\n-  // The RPC context lifetime must be coupled to the ClientReader\n-  std::shared_ptr<ClientRpc> rpc_;\n+  std::shared_ptr<internal::ClientDataStream> stream_;\n+  std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader_;\n   std::shared_ptr<MemoryManager> memory_manager_;\n-  // Guard reads with a mutex to prevent concurrent reads if the write\n-  // side calls Finish(). Nullable as DoGet doesn't need this.\n-  std::shared_ptr<std::mutex> read_mutex_;\n\nReview comment:\n       The lock was pushed down into the WritableDataStream implementation below to limit how many classes have to manage it\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-24T15:03:51.888+0000",
                    "updated": "2022-02-24T15:03:51.888+0000",
                    "started": "2022-02-24T15:03:51.887+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "732382",
                    "issueId": "13421341"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/worklog/732385",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #12465:\nURL: https://github.com/apache/arrow/pull/12465#discussion_r813974385\n\n\n\n##########\nFile path: cpp/src/arrow/flight/transport_server_impl.cc\n##########\n@@ -0,0 +1,327 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/transport_impl.h\"\n+\n+#include <unordered_map>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/flight/serialization_internal.h\"\n+#include \"arrow/flight/server.h\"\n+#include \"arrow/flight/types.h\"\n+#include \"arrow/ipc/reader.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+\n+namespace arrow {\n+namespace flight {\n+namespace internal {\n+\n+namespace {\n+class TransportIpcMessageReader : public ipc::MessageReader {\n+ public:\n+  explicit TransportIpcMessageReader(\n+      std::shared_ptr<internal::PeekableFlightDataReader> peekable_reader,\n+      std::shared_ptr<MemoryManager> memory_manager,\n+      std::shared_ptr<Buffer>* app_metadata)\n+      : peekable_reader_(peekable_reader),\n+        memory_manager_(std::move(memory_manager)),\n+        app_metadata_(app_metadata) {}\n+\n+  ::arrow::Result<std::unique_ptr<ipc::Message>> ReadNextMessage() override {\n+    if (stream_finished_) {\n+      return nullptr;\n+    }\n+    internal::FlightData* data;\n+    peekable_reader_->Next(&data);\n+    if (!data) {\n+      stream_finished_ = true;\n+      if (first_message_) {\n\nReview comment:\n       Ah, basically, this can only happen on the first message on DoPut since in all other cases, we peek at the stream before sending it to the IPC message reader - so it will never not have data. So in general if we were called and we don't get any data here, then it's an error.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2022-02-24T15:09:42.079+0000",
                    "updated": "2022-02-24T15:09:42.079+0000",
                    "started": "2022-02-24T15:09:42.079+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "732385",
                    "issueId": "13421341"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 63000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@42ff0a61[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1ce13409[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5ec830ca[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4b1c0666[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5b9e7627[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@4b41b074[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@541087b6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@7f148464[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5713faef[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@11173269[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@416a2aca[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@1a06b127[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 63000,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Mar 11 02:54:56 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-03-11T02:54:56.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15282/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2022-01-07T13:58:42.000+0000",
        "updated": "2022-07-01T15:56:52.000+0000",
        "timeoriginalestimate": null,
        "description": "The goal is to decouple FlightData payload transmission from gRPC and provide a convenient framework to support other accelerated data planes (ucx, dpdk, xdp, etc.).\r\n\r\nAs a PoC, I implemented a shared memory data plane for local rpc, the performance is great compared with current best (grpc over unix socket).\r\n\r\nTested throughput and latency on xeon gold 5218, DoGet, batch size 128K.\r\n||streams||grpc over unix socket||shared memory data plane||\r\n|1|3324 MB/s,  35 us|7045 MB/s,   16 us|\r\n|2|6289 MB/s,  38 us|13311 MB/s,   17 us|\r\n|4|10037 MB/s,  44 us|25012 MB/s,  17 us|",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "17.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 63000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][FlightRPC] Support non-grpc data planes",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/comment/17493646",
                    "id": "17493646",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
                        "name": "yibocai",
                        "key": "yibo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
                        },
                        "displayName": "Yibo Cai",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "A better solution at ARROW-15706.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
                        "name": "yibocai",
                        "key": "yibo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
                        },
                        "displayName": "Yibo Cai",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-02-17T04:58:37.208+0000",
                    "updated": "2022-02-17T04:58:37.208+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/comment/17494790",
                    "id": "17494790",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "If you don't mind I'm going to recycle this JIRA since I'd like to split the gRPC refactoring in ARROW-15706 from the UCX implementation itself",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2022-02-18T19:16:55.037+0000",
                    "updated": "2022-02-18T19:16:55.037+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/comment/17494899",
                    "id": "17494899",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
                        "name": "yibocai",
                        "key": "yibo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
                        },
                        "displayName": "Yibo Cai",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Sure, no problem.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
                        "name": "yibocai",
                        "key": "yibo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
                        },
                        "displayName": "Yibo Cai",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-02-19T07:08:04.049+0000",
                    "updated": "2022-02-19T07:08:04.049+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13421341/comment/17504697",
                    "id": "17504697",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
                        "name": "yibocai",
                        "key": "yibo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
                        },
                        "displayName": "Yibo Cai",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 12465\n[https://github.com/apache/arrow/pull/12465]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=yibocai",
                        "name": "yibocai",
                        "key": "yibo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=yibo&avatarId=47542",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=yibo&avatarId=47542",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=yibo&avatarId=47542",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=yibo&avatarId=47542"
                        },
                        "displayName": "Yibo Cai",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2022-03-11T02:54:56.698+0000",
                    "updated": "2022-03-11T02:54:56.698+0000"
                }
            ],
            "maxResults": 4,
            "total": 4,
            "startAt": 0
        },
        "customfield_12311820": "0|z0ycxk:",
        "customfield_12314139": null
    }
}