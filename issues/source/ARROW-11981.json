{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13365513",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513",
    "key": "ARROW-11981",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350323",
                "id": "12350323",
                "description": "",
                "name": "6.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "dataset",
            "kernel",
            "pull-request-available",
            "query-engine"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12615166",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12615166",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13376404",
                    "key": "ARROW-12633",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13376404",
                    "fields": {
                        "summary": "[C++] Query engine umbrella issue",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12621354",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12621354",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "inwardIssue": {
                    "id": "13395871",
                    "key": "ARROW-13653",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13395871",
                    "fields": {
                        "summary": "[C++][Dataset] Remove UnionDataset in favor of UnionExecNode",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=aocsa",
            "name": "aocsa",
            "key": "aocsa",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=aocsa&avatarId=47387",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=aocsa&avatarId=47387",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=aocsa&avatarId=47387",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=aocsa&avatarId=47387"
            },
            "displayName": "Alexander Ocsa",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 19800,
            "total": 19800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 19800,
            "total": 19800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11981/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 33,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/637383",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa opened a new pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927\n\n\n   \r\n   UnionDataset allows Fragments of multiple schemas and differing file formats to be scanned together as a single Dataset. This is useful functionality but makes the Dataset interface somewhat difficult to reason about since it must be general enough to accommodate UnionDataset.\r\n   \r\n   After ARROW-11928 it will probably be more natural to support unioning of datasets through a subclass of ExecNode. Reconciliation of differing schemas can then be trivially handled by a full ProjectNode.\r\n   \r\n   Note this would obviate both ARROW-11001 and ARROW-11749. In addition, Dataset could be simplified to a concrete class containing a set of compatibly typed/formatted Fragments.\r\n   \r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-12T15:25:26.581+0000",
                    "updated": "2021-08-12T15:25:26.581+0000",
                    "started": "2021-08-12T15:25:26.580+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637383",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/637384",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#issuecomment-897733240\n\n\n   https://issues.apache.org/jira/browse/ARROW-11981\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-12T15:25:40.518+0000",
                    "updated": "2021-08-12T15:25:40.518+0000",
                    "started": "2021-08-12T15:25:40.518+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637384",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/637498",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r687986863\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecNode* lhs_input, ExecNode* rhs_input, ExecContext* ctx)\n\nReview comment:\n       Most other nodes take ExecPlan* plan as the first input now. \r\n   \r\n   Additionally, is there any reason why this couldn't be made a variadic node?\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecNode* lhs_input, ExecNode* rhs_input, ExecContext* ctx)\n+      : ExecNode(lhs_input->plan(), {lhs_input, rhs_input},\n+                 {\"left_input_union\", \"right_input_union\"},\n+                 /*output_schema=*/lhs_input->output_schema(),\n+                 /*num_outputs=*/1),\n+        ctx_(ctx) {}\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    {\n+      std::unique_lock<std::mutex> lock(mutex_);\n+      ++batch_count_;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+    {\n+      std::unique_lock<std::mutex> lk(mutex_);\n+      ++input_count_;\n+    }\n+    std::unique_lock<std::mutex> lk(mutex_);\n+    if (input_count_ == 2) {\n+      finished_.MarkFinished();\n+      outputs_[0]->InputFinished(this, batch_count_);\n\nReview comment:\n       InputFinished isn't guaranteed to be called after calls to InputReceived finish. Instead we should add `num_total` to a counter here, then when we've gotten InputFinished from all inputs, we can then call InputFinished on the output.\r\n   \r\n   We shouldn't MarkFinished until we get all the batches. \r\n   \r\n   You can see this pattern in aggregate_node.cc: https://github.com/apache/arrow/blob/5c5a0d63a42dc8d5ecab5996574c466f2e9c2ed5/cpp/src/arrow/compute/exec/aggregate_node.cc#L483-L492 and https://github.com/apache/arrow/blob/5c5a0d63a42dc8d5ecab5996574c466f2e9c2ed5/cpp/src/arrow/compute/exec/aggregate_node.cc#L464-L475\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecNode* lhs_input, ExecNode* rhs_input, ExecContext* ctx)\n+      : ExecNode(lhs_input->plan(), {lhs_input, rhs_input},\n+                 {\"left_input_union\", \"right_input_union\"},\n+                 /*output_schema=*/lhs_input->output_schema(),\n+                 /*num_outputs=*/1),\n+        ctx_(ctx) {}\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    {\n+      std::unique_lock<std::mutex> lock(mutex_);\n+      ++batch_count_;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+    {\n+      std::unique_lock<std::mutex> lk(mutex_);\n+      ++input_count_;\n+    }\n+    std::unique_lock<std::mutex> lk(mutex_);\n+    if (input_count_ == 2) {\n+      finished_.MarkFinished();\n+      outputs_[0]->InputFinished(this, batch_count_);\n\nReview comment:\n       So it would look something like (assuming we use AtomicCounter)\r\n   \r\n   ```cpp\r\n   input_count_.SetTotal(2); // or inputs.size() if we want to make this a variadic node\r\n   // ...\r\n   \r\n   // InputFinished\r\n   total_batches_ += num_total;\r\n   if (input_count_.Increment()) {\r\n     outputs_[0]->InputFinished(this, total_batches_);\r\n     if (batch_count.SetTotal(total_batches_)) {\r\n       finished_.MarkFinished();\r\n     }\r\n   }\r\n   \r\n   // InputReceived\r\n   outputs_[0]->InputReceived(this, seq, std::move(batch));\r\n   if (batch_count_.Increment()) {\r\n     finished_.MarkFinished();\r\n   }\r\n   \r\n   // StopProducing\r\n   if (batch_count_.Cancel()) finished_.MarkFinished();\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecNode* lhs_input, ExecNode* rhs_input, ExecContext* ctx)\n+      : ExecNode(lhs_input->plan(), {lhs_input, rhs_input},\n+                 {\"left_input_union\", \"right_input_union\"},\n+                 /*output_schema=*/lhs_input->output_schema(),\n+                 /*num_outputs=*/1),\n+        ctx_(ctx) {}\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    {\n+      std::unique_lock<std::mutex> lock(mutex_);\n+      ++batch_count_;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+    {\n+      std::unique_lock<std::mutex> lk(mutex_);\n+      ++input_count_;\n+    }\n+    std::unique_lock<std::mutex> lk(mutex_);\n+    if (input_count_ == 2) {\n+      finished_.MarkFinished();\n+      outputs_[0]->InputFinished(this, batch_count_);\n+    }\n+  }\n+\n+  Status StartProducing() override {\n+    finished_ = Future<>::Make();\n+    return Status::OK();\n+  }\n+\n+  void PauseProducing(ExecNode* output) override {}\n+\n+  void ResumeProducing(ExecNode* output) override {}\n+\n+  void StopProducing(ExecNode* output) override {\n+    DCHECK_EQ(output, outputs_[0]);\n+    finished_.MarkFinished();\n+\n+    for (auto&& input : inputs_) {\n+      input->StopProducing(this);\n+    }\n+  }\n+\n+  void StopProducing() override { inputs_[0]->StopProducing(this); }\n+\n+  Future<> finished() override { return finished_; }\n+\n+ private:\n+  ExecContext* ctx_;\n+  std::mutex mutex_;\n+  int batch_count_{0};\n+  int input_count_{0};\n\nReview comment:\n       There's a helper called AtomicCounter to manage this sort of thing without having to keep the mutex.\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node_test.cc\n##########\n@@ -0,0 +1,188 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gmock/gmock-matchers.h>\n+\n+#include <iostream>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/pretty_print.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/matchers.h\"\n+\n+using testing::UnorderedElementsAreArray;\n+\n+namespace arrow {\n+namespace compute {\n+\n+void GenerateBatchesFromString(const std::shared_ptr<Schema>& schema,\n+                               const std::vector<util::string_view>& json_strings,\n+                               BatchesWithSchema* out_batches, int multiplicity = 1) {\n+  std::vector<ValueDescr> descrs;\n+  for (auto&& field : schema->fields()) {\n+    descrs.emplace_back(field->type());\n+  }\n+\n+  for (auto&& s : json_strings) {\n+    out_batches->batches.push_back(ExecBatchFromJSON(descrs, s));\n+  }\n+\n+  size_t batch_count = out_batches->batches.size();\n+  for (int repeat = 1; repeat < multiplicity; ++repeat) {\n+    for (size_t i = 0; i < batch_count; ++i) {\n+      out_batches->batches.push_back(out_batches->batches[i]);\n+    }\n+  }\n+\n+  out_batches->schema = schema;\n+}\n+\n+void CheckRunOutput(const BatchesWithSchema& l_batches,\n+                    const BatchesWithSchema& r_batches,\n+                    const BatchesWithSchema& exp_batches, bool parallel = false) {\n+  SCOPED_TRACE(\"serial\");\n+\n+  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+\n+  ExecNodeOptions Union_options{};\n+  Declaration union_decl{\"union\", Union_options};\n\nReview comment:\n       ```suggestion\r\n     ExecNodeOptions union_options{};\r\n     Declaration union_decl{\"union\", union_options};\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node_test.cc\n##########\n@@ -0,0 +1,188 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gmock/gmock-matchers.h>\n+\n+#include <iostream>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/pretty_print.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/matchers.h\"\n+\n+using testing::UnorderedElementsAreArray;\n+\n+namespace arrow {\n+namespace compute {\n+\n+void GenerateBatchesFromString(const std::shared_ptr<Schema>& schema,\n+                               const std::vector<util::string_view>& json_strings,\n+                               BatchesWithSchema* out_batches, int multiplicity = 1) {\n+  std::vector<ValueDescr> descrs;\n+  for (auto&& field : schema->fields()) {\n+    descrs.emplace_back(field->type());\n+  }\n+\n+  for (auto&& s : json_strings) {\n+    out_batches->batches.push_back(ExecBatchFromJSON(descrs, s));\n+  }\n+\n+  size_t batch_count = out_batches->batches.size();\n+  for (int repeat = 1; repeat < multiplicity; ++repeat) {\n+    for (size_t i = 0; i < batch_count; ++i) {\n+      out_batches->batches.push_back(out_batches->batches[i]);\n+    }\n+  }\n+\n+  out_batches->schema = schema;\n+}\n+\n+void CheckRunOutput(const BatchesWithSchema& l_batches,\n+                    const BatchesWithSchema& r_batches,\n+                    const BatchesWithSchema& exp_batches, bool parallel = false) {\n+  SCOPED_TRACE(\"serial\");\n+\n+  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+\n+  ExecNodeOptions Union_options{};\n+  Declaration union_decl{\"union\", Union_options};\n+\n+  // add left source\n+  union_decl.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  // add right source\n+  union_decl.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+  ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                .AddToPlan(plan.get()));\n+\n+  Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n+\n+  auto expected_matcher =\n+      Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n+  ASSERT_THAT(actual, expected_matcher);\n+}\n+\n+void RunNonEmptyTest(bool parallel) {\n+  auto l_schema = schema({field(\"l_i32\", int32()), field(\"l_str\", utf8())});\n+  auto r_schema = schema({field(\"r_i32\", int32()), field(\"r_str\", utf8())});\n+  BatchesWithSchema l_batches, r_batches, exp_batches;\n+\n+  int multiplicity = parallel ? 100 : 1;\n+\n+  GenerateBatchesFromString(l_schema,\n+                            {\n+                                R\"([[0,\"d\"], [1,\"b\"]])\",\n+                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n+                            },\n+                            &l_batches, multiplicity);\n+\n+  GenerateBatchesFromString(r_schema,\n+                            {\n+                                R\"([[10,\"A\"]])\",\n+                            },\n+                            &r_batches, multiplicity);\n+\n+  GenerateBatchesFromString(l_schema,\n+                            {\n+                                R\"([[0,\"d\"], [1,\"b\"]])\",\n+                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n+\n+                                R\"([[10,\"A\"]])\",\n+                            },\n+                            &exp_batches, multiplicity);\n+  CheckRunOutput(l_batches, r_batches, exp_batches, parallel);\n+}\n+\n+void RunEmptyTest(bool parallel) {\n+  auto l_schema = schema({field(\"l_i32\", int32()), field(\"l_str\", utf8())});\n+  auto r_schema = schema({field(\"r_i32\", int32()), field(\"r_str\", utf8())});\n+\n+  int multiplicity = parallel ? 100 : 1;\n+\n+  BatchesWithSchema l_empty, r_empty, output_batches;\n+\n+  GenerateBatchesFromString(l_schema, {R\"([])\"}, &l_empty, multiplicity);\n+  GenerateBatchesFromString(r_schema, {R\"([])\"}, &r_empty, multiplicity);\n+\n+  GenerateBatchesFromString(l_schema, {R\"([])\", R\"([])\"}, &output_batches, multiplicity);\n+\n+  CheckRunOutput(l_empty, r_empty, output_batches);\n+}\n+\n+class UnionTest : public testing::TestWithParam<std::tuple<bool>> {};\n+\n+INSTANTIATE_TEST_SUITE_P(UnionTest, UnionTest,\n+                         ::testing::Combine(::testing::Values(false, true)));\n+\n+TEST_P(UnionTest, TestNonEmpty) { RunNonEmptyTest(std::get<0>(GetParam())); }\n+\n+TEST_P(UnionTest, TestEmpty) { RunEmptyTest(std::get<0>(GetParam())); }\n+\n+void TestUnionRandom(const std::shared_ptr<DataType>& data_type, bool parallel,\n+                     int num_batches, int batch_size) {\n+  auto l_schema = schema({field(\"l0\", data_type), field(\"l1\", data_type)});\n+  auto r_schema = schema({field(\"r0\", data_type), field(\"r1\", data_type)});\n+\n+  // generate data\n+  auto l_batches = MakeRandomBatches(l_schema, num_batches, batch_size);\n+  auto r_batches = MakeRandomBatches(r_schema, num_batches, batch_size);\n+\n+  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+\n+  Declaration Union{\"union\", ExecNodeOptions{}};\n+\n+  // add left source\n+  Union.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  // add right source\n+  Union.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+  ASSERT_OK(Declaration::Sequence({Union, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                .AddToPlan(plan.get()));\n+\n+  ASSERT_FINISHES_OK_AND_ASSIGN(auto res, StartAndCollect(plan.get(), sink_gen));\n+}\n\nReview comment:\n       You should be able to check the batches here too.\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node_test.cc\n##########\n@@ -0,0 +1,188 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gmock/gmock-matchers.h>\n+\n+#include <iostream>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/pretty_print.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/matchers.h\"\n+\n+using testing::UnorderedElementsAreArray;\n+\n+namespace arrow {\n+namespace compute {\n+\n+void GenerateBatchesFromString(const std::shared_ptr<Schema>& schema,\n+                               const std::vector<util::string_view>& json_strings,\n+                               BatchesWithSchema* out_batches, int multiplicity = 1) {\n+  std::vector<ValueDescr> descrs;\n+  for (auto&& field : schema->fields()) {\n+    descrs.emplace_back(field->type());\n+  }\n+\n+  for (auto&& s : json_strings) {\n+    out_batches->batches.push_back(ExecBatchFromJSON(descrs, s));\n+  }\n+\n+  size_t batch_count = out_batches->batches.size();\n+  for (int repeat = 1; repeat < multiplicity; ++repeat) {\n+    for (size_t i = 0; i < batch_count; ++i) {\n+      out_batches->batches.push_back(out_batches->batches[i]);\n+    }\n+  }\n+\n+  out_batches->schema = schema;\n+}\n+\n+void CheckRunOutput(const BatchesWithSchema& l_batches,\n+                    const BatchesWithSchema& r_batches,\n+                    const BatchesWithSchema& exp_batches, bool parallel = false) {\n+  SCOPED_TRACE(\"serial\");\n+\n+  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+\n+  ExecNodeOptions Union_options{};\n+  Declaration union_decl{\"union\", Union_options};\n\nReview comment:\n       (You should be able to get away with `Declaration union_decl{\"union\", {}}`?)\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecNode* lhs_input, ExecNode* rhs_input, ExecContext* ctx)\n+      : ExecNode(lhs_input->plan(), {lhs_input, rhs_input},\n+                 {\"left_input_union\", \"right_input_union\"},\n+                 /*output_schema=*/lhs_input->output_schema(),\n+                 /*num_outputs=*/1),\n+        ctx_(ctx) {}\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    {\n+      std::unique_lock<std::mutex> lock(mutex_);\n+      ++batch_count_;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+    {\n+      std::unique_lock<std::mutex> lk(mutex_);\n+      ++input_count_;\n+    }\n+    std::unique_lock<std::mutex> lk(mutex_);\n+    if (input_count_ == 2) {\n+      finished_.MarkFinished();\n+      outputs_[0]->InputFinished(this, batch_count_);\n\nReview comment:\n       I wonder if we could make some sort of testing node that purposely permuted the order of operations to try to catch this\u2026\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node_test.cc\n##########\n@@ -0,0 +1,188 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gmock/gmock-matchers.h>\n+\n+#include <iostream>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/pretty_print.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/matchers.h\"\n+\n+using testing::UnorderedElementsAreArray;\n+\n+namespace arrow {\n+namespace compute {\n+\n+void GenerateBatchesFromString(const std::shared_ptr<Schema>& schema,\n+                               const std::vector<util::string_view>& json_strings,\n+                               BatchesWithSchema* out_batches, int multiplicity = 1) {\n+  std::vector<ValueDescr> descrs;\n+  for (auto&& field : schema->fields()) {\n+    descrs.emplace_back(field->type());\n+  }\n+\n+  for (auto&& s : json_strings) {\n+    out_batches->batches.push_back(ExecBatchFromJSON(descrs, s));\n+  }\n+\n+  size_t batch_count = out_batches->batches.size();\n+  for (int repeat = 1; repeat < multiplicity; ++repeat) {\n+    for (size_t i = 0; i < batch_count; ++i) {\n+      out_batches->batches.push_back(out_batches->batches[i]);\n+    }\n+  }\n+\n+  out_batches->schema = schema;\n+}\n+\n+void CheckRunOutput(const BatchesWithSchema& l_batches,\n+                    const BatchesWithSchema& r_batches,\n+                    const BatchesWithSchema& exp_batches, bool parallel = false) {\n+  SCOPED_TRACE(\"serial\");\n+\n+  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+\n+  ExecNodeOptions Union_options{};\n+  Declaration union_decl{\"union\", Union_options};\n+\n+  // add left source\n+  union_decl.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  // add right source\n+  union_decl.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+  ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                .AddToPlan(plan.get()));\n+\n+  Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n+\n+  auto expected_matcher =\n+      Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n+  ASSERT_THAT(actual, expected_matcher);\n+}\n+\n+void RunNonEmptyTest(bool parallel) {\n+  auto l_schema = schema({field(\"l_i32\", int32()), field(\"l_str\", utf8())});\n+  auto r_schema = schema({field(\"r_i32\", int32()), field(\"r_str\", utf8())});\n+  BatchesWithSchema l_batches, r_batches, exp_batches;\n+\n+  int multiplicity = parallel ? 100 : 1;\n+\n+  GenerateBatchesFromString(l_schema,\n+                            {\n+                                R\"([[0,\"d\"], [1,\"b\"]])\",\n+                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n+                            },\n+                            &l_batches, multiplicity);\n+\n+  GenerateBatchesFromString(r_schema,\n+                            {\n+                                R\"([[10,\"A\"]])\",\n+                            },\n+                            &r_batches, multiplicity);\n+\n+  GenerateBatchesFromString(l_schema,\n+                            {\n+                                R\"([[0,\"d\"], [1,\"b\"]])\",\n+                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n+\n+                                R\"([[10,\"A\"]])\",\n+                            },\n+                            &exp_batches, multiplicity);\n+  CheckRunOutput(l_batches, r_batches, exp_batches, parallel);\n+}\n+\n+void RunEmptyTest(bool parallel) {\n+  auto l_schema = schema({field(\"l_i32\", int32()), field(\"l_str\", utf8())});\n+  auto r_schema = schema({field(\"r_i32\", int32()), field(\"r_str\", utf8())});\n+\n+  int multiplicity = parallel ? 100 : 1;\n+\n+  BatchesWithSchema l_empty, r_empty, output_batches;\n+\n+  GenerateBatchesFromString(l_schema, {R\"([])\"}, &l_empty, multiplicity);\n+  GenerateBatchesFromString(r_schema, {R\"([])\"}, &r_empty, multiplicity);\n+\n+  GenerateBatchesFromString(l_schema, {R\"([])\", R\"([])\"}, &output_batches, multiplicity);\n+\n+  CheckRunOutput(l_empty, r_empty, output_batches);\n+}\n+\n+class UnionTest : public testing::TestWithParam<std::tuple<bool>> {};\n+\n+INSTANTIATE_TEST_SUITE_P(UnionTest, UnionTest,\n+                         ::testing::Combine(::testing::Values(false, true)));\n+\n+TEST_P(UnionTest, TestNonEmpty) { RunNonEmptyTest(std::get<0>(GetParam())); }\n+\n+TEST_P(UnionTest, TestEmpty) { RunEmptyTest(std::get<0>(GetParam())); }\n\nReview comment:\n       Why not just inline these?\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node_test.cc\n##########\n@@ -0,0 +1,188 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gmock/gmock-matchers.h>\n+\n+#include <iostream>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/pretty_print.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/matchers.h\"\n+\n+using testing::UnorderedElementsAreArray;\n+\n+namespace arrow {\n+namespace compute {\n+\n+void GenerateBatchesFromString(const std::shared_ptr<Schema>& schema,\n+                               const std::vector<util::string_view>& json_strings,\n+                               BatchesWithSchema* out_batches, int multiplicity = 1) {\n+  std::vector<ValueDescr> descrs;\n+  for (auto&& field : schema->fields()) {\n+    descrs.emplace_back(field->type());\n+  }\n+\n+  for (auto&& s : json_strings) {\n+    out_batches->batches.push_back(ExecBatchFromJSON(descrs, s));\n+  }\n+\n+  size_t batch_count = out_batches->batches.size();\n+  for (int repeat = 1; repeat < multiplicity; ++repeat) {\n+    for (size_t i = 0; i < batch_count; ++i) {\n+      out_batches->batches.push_back(out_batches->batches[i]);\n+    }\n+  }\n+\n+  out_batches->schema = schema;\n+}\n+\n+void CheckRunOutput(const BatchesWithSchema& l_batches,\n+                    const BatchesWithSchema& r_batches,\n+                    const BatchesWithSchema& exp_batches, bool parallel = false) {\n+  SCOPED_TRACE(\"serial\");\n\nReview comment:\n       This should depend on `parallel`?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-12T18:44:12.860+0000",
                    "updated": "2021-08-12T18:44:12.860+0000",
                    "started": "2021-08-12T18:44:12.860+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637498",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/637644",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r688204512\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecNode* lhs_input, ExecNode* rhs_input, ExecContext* ctx)\n+      : ExecNode(lhs_input->plan(), {lhs_input, rhs_input},\n+                 {\"left_input_union\", \"right_input_union\"},\n+                 /*output_schema=*/lhs_input->output_schema(),\n+                 /*num_outputs=*/1),\n+        ctx_(ctx) {}\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    {\n+      std::unique_lock<std::mutex> lock(mutex_);\n\nReview comment:\n       I think it would be better to use AtomicCounter here \r\n   https://github.com/apache/arrow/blob/d943b8bf22149775c84b5afbda5c34cb9a19d93c/cpp/src/arrow/compute/exec/util.h#L194\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecNode* lhs_input, ExecNode* rhs_input, ExecContext* ctx)\n+      : ExecNode(lhs_input->plan(), {lhs_input, rhs_input},\n+                 {\"left_input_union\", \"right_input_union\"},\n+                 /*output_schema=*/lhs_input->output_schema(),\n+                 /*num_outputs=*/1),\n+        ctx_(ctx) {}\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    {\n+      std::unique_lock<std::mutex> lock(mutex_);\n+      ++batch_count_;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+    {\n+      std::unique_lock<std::mutex> lk(mutex_);\n+      ++input_count_;\n+    }\n+    std::unique_lock<std::mutex> lk(mutex_);\n+    if (input_count_ == 2) {\n+      finished_.MarkFinished();\n+      outputs_[0]->InputFinished(this, batch_count_);\n+    }\n+  }\n+\n+  Status StartProducing() override {\n+    finished_ = Future<>::Make();\n+    return Status::OK();\n+  }\n+\n+  void PauseProducing(ExecNode* output) override {}\n+\n+  void ResumeProducing(ExecNode* output) override {}\n+\n+  void StopProducing(ExecNode* output) override {\n+    DCHECK_EQ(output, outputs_[0]);\n+    finished_.MarkFinished();\n+\n+    for (auto&& input : inputs_) {\n+      input->StopProducing(this);\n+    }\n+  }\n+\n+  void StopProducing() override { inputs_[0]->StopProducing(this); }\n+\n+  Future<> finished() override { return finished_; }\n+\n+ private:\n+  ExecContext* ctx_;\n+  std::mutex mutex_;\n+  int batch_count_{0};\n+  int input_count_{0};\n+  Future<> finished_ = Future<>::MakeFinished();\n+};\n+\n+Result<ExecNode*> MakeUnionNode(ExecNode* lhs_input, ExecNode* rhs_input) {\n\nReview comment:\n       I think we need to validate the lhs and rhs schemas here. They should be the same.\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecNode* lhs_input, ExecNode* rhs_input, ExecContext* ctx)\n\nReview comment:\n       can we have variable number of inputs in the exec node registry ATM? :thinking: \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-13T02:49:18.849+0000",
                    "updated": "2021-08-13T02:49:18.849+0000",
                    "started": "2021-08-13T02:49:18.848+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637644",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/637781",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r688490721\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecNode* lhs_input, ExecNode* rhs_input, ExecContext* ctx)\n\nReview comment:\n       Everything takes vector<ExecNode*>: https://github.com/apache/arrow/blob/5c5a0d63a42dc8d5ecab5996574c466f2e9c2ed5/cpp/src/arrow/compute/exec/exec_plan.h#L239-L276\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-13T12:54:06.797+0000",
                    "updated": "2021-08-13T12:54:06.797+0000",
                    "started": "2021-08-13T12:54:06.796+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "637781",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638255",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r689668854\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node_test.cc\n##########\n@@ -0,0 +1,188 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gmock/gmock-matchers.h>\n+\n+#include <iostream>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/pretty_print.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/matchers.h\"\n+\n+using testing::UnorderedElementsAreArray;\n+\n+namespace arrow {\n+namespace compute {\n+\n+void GenerateBatchesFromString(const std::shared_ptr<Schema>& schema,\n+                               const std::vector<util::string_view>& json_strings,\n+                               BatchesWithSchema* out_batches, int multiplicity = 1) {\n+  std::vector<ValueDescr> descrs;\n+  for (auto&& field : schema->fields()) {\n+    descrs.emplace_back(field->type());\n+  }\n+\n+  for (auto&& s : json_strings) {\n+    out_batches->batches.push_back(ExecBatchFromJSON(descrs, s));\n+  }\n+\n+  size_t batch_count = out_batches->batches.size();\n+  for (int repeat = 1; repeat < multiplicity; ++repeat) {\n+    for (size_t i = 0; i < batch_count; ++i) {\n+      out_batches->batches.push_back(out_batches->batches[i]);\n+    }\n+  }\n+\n+  out_batches->schema = schema;\n+}\n+\n+void CheckRunOutput(const BatchesWithSchema& l_batches,\n+                    const BatchesWithSchema& r_batches,\n+                    const BatchesWithSchema& exp_batches, bool parallel = false) {\n+  SCOPED_TRACE(\"serial\");\n+\n+  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+\n+  ExecNodeOptions Union_options{};\n+  Declaration union_decl{\"union\", Union_options};\n+\n+  // add left source\n+  union_decl.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  // add right source\n+  union_decl.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+  ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                .AddToPlan(plan.get()));\n+\n+  Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n+\n+  auto expected_matcher =\n+      Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n+  ASSERT_THAT(actual, expected_matcher);\n+}\n+\n+void RunNonEmptyTest(bool parallel) {\n+  auto l_schema = schema({field(\"l_i32\", int32()), field(\"l_str\", utf8())});\n+  auto r_schema = schema({field(\"r_i32\", int32()), field(\"r_str\", utf8())});\n+  BatchesWithSchema l_batches, r_batches, exp_batches;\n+\n+  int multiplicity = parallel ? 100 : 1;\n+\n+  GenerateBatchesFromString(l_schema,\n+                            {\n+                                R\"([[0,\"d\"], [1,\"b\"]])\",\n+                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n+                            },\n+                            &l_batches, multiplicity);\n+\n+  GenerateBatchesFromString(r_schema,\n+                            {\n+                                R\"([[10,\"A\"]])\",\n+                            },\n+                            &r_batches, multiplicity);\n+\n+  GenerateBatchesFromString(l_schema,\n+                            {\n+                                R\"([[0,\"d\"], [1,\"b\"]])\",\n+                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n+\n+                                R\"([[10,\"A\"]])\",\n+                            },\n+                            &exp_batches, multiplicity);\n+  CheckRunOutput(l_batches, r_batches, exp_batches, parallel);\n+}\n+\n+void RunEmptyTest(bool parallel) {\n+  auto l_schema = schema({field(\"l_i32\", int32()), field(\"l_str\", utf8())});\n+  auto r_schema = schema({field(\"r_i32\", int32()), field(\"r_str\", utf8())});\n+\n+  int multiplicity = parallel ? 100 : 1;\n+\n+  BatchesWithSchema l_empty, r_empty, output_batches;\n+\n+  GenerateBatchesFromString(l_schema, {R\"([])\"}, &l_empty, multiplicity);\n+  GenerateBatchesFromString(r_schema, {R\"([])\"}, &r_empty, multiplicity);\n+\n+  GenerateBatchesFromString(l_schema, {R\"([])\", R\"([])\"}, &output_batches, multiplicity);\n+\n+  CheckRunOutput(l_empty, r_empty, output_batches);\n+}\n+\n+class UnionTest : public testing::TestWithParam<std::tuple<bool>> {};\n+\n+INSTANTIATE_TEST_SUITE_P(UnionTest, UnionTest,\n+                         ::testing::Combine(::testing::Values(false, true)));\n+\n+TEST_P(UnionTest, TestNonEmpty) { RunNonEmptyTest(std::get<0>(GetParam())); }\n+\n+TEST_P(UnionTest, TestEmpty) { RunEmptyTest(std::get<0>(GetParam())); }\n\nReview comment:\n       Sure\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-16T16:07:30.610+0000",
                    "updated": "2021-08-16T16:07:30.610+0000",
                    "started": "2021-08-16T16:07:30.610+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638255",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638299",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#issuecomment-899670386\n\n\n   Thanks for the review @lidavidm, @nirandaperera. \r\n   I update this PR with the following main changes: \r\n    \r\n   1. The use AtomicCounter\r\n   2. Handle variable number of inputs \r\n   3. Validate input schemas \r\n   \r\n   \r\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-16T17:05:03.233+0000",
                    "updated": "2021-08-16T17:05:03.233+0000",
                    "started": "2021-08-16T17:05:03.233+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638299",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638300",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r689710634\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,131 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecNode* lhs_input, ExecNode* rhs_input, ExecContext* ctx)\n+      : ExecNode(lhs_input->plan(), {lhs_input, rhs_input},\n+                 {\"left_input_union\", \"right_input_union\"},\n+                 /*output_schema=*/lhs_input->output_schema(),\n+                 /*num_outputs=*/1),\n+        ctx_(ctx) {}\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    {\n+      std::unique_lock<std::mutex> lock(mutex_);\n+      ++batch_count_;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(input == inputs_[0] || input == inputs_[1]);\n+    {\n+      std::unique_lock<std::mutex> lk(mutex_);\n+      ++input_count_;\n+    }\n+    std::unique_lock<std::mutex> lk(mutex_);\n+    if (input_count_ == 2) {\n+      finished_.MarkFinished();\n+      outputs_[0]->InputFinished(this, batch_count_);\n\nReview comment:\n       Thanks I followed your suggest to update this PR \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-16T17:06:20.937+0000",
                    "updated": "2021-08-16T17:06:20.937+0000",
                    "started": "2021-08-16T17:06:20.936+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638300",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638310",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r689712083\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(ExecNode::NodeVector inputs) {\n\nReview comment:\n       ```suggestion\r\n   std::vector<std::string> GetInputLabels(const ExecNode::NodeVector& inputs) {\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(ExecNode::NodeVector inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n+      finished_.MarkFinished();\n\nReview comment:\n       Hmm, this branch shouldn't be possible unless inputs == 0 which isn't allowed by Make.\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(ExecNode::NodeVector inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, inputs.size(), \"UnionNode\"));\n+    if (inputs.size() < 2) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 2\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"Constructing a `UnionNode` with inputs with different schemas\");\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n\nReview comment:\n       I wonder if it actually makes sense to forward seq like this. As I understand nodes can't really rely on this anyways so I don't think it harms things, but it seems odd to even have the parameter in that case. CC @bkietz for opinions. \r\n   \r\n   (We could modify `Increment` to also give the count, if we wanted to give a unique seq_num to each batch we emit here.)\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(ExecNode::NodeVector inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, inputs.size(), \"UnionNode\"));\n+    if (inputs.size() < 2) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 2\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"Constructing a `UnionNode` with inputs with different schemas\");\n\nReview comment:\n       Nit: it might be nice to provide the schemas to aid debugging, something like\r\n   \r\n   ```cpp\r\n   return Status::Invalid(\"UnionNode input schemas must all match, first schema was: \", *schema, \" got schema: \", *input->output_schema);\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(ExecNode::NodeVector inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, inputs.size(), \"UnionNode\"));\n+    if (inputs.size() < 2) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 2\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"Constructing a `UnionNode` with inputs with different schemas\");\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+    if (batch_count_.Increment()) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    total_batches_.fetch_add(num_total);\n+\n+    if (input_count_.Increment()) {\n+      outputs_[0]->InputFinished(this, total_batches_.load());\n+      if (batch_count_.SetTotal(total_batches_.load())) {\n+        finished_.MarkFinished();\n+      }\n+    }\n+  }\n+\n+  Status StartProducing() override {\n+    finished_ = Future<>::Make();\n+    return Status::OK();\n+  }\n+\n+  void PauseProducing(ExecNode* output) override {}\n+\n+  void ResumeProducing(ExecNode* output) override {}\n\nReview comment:\n       Or if not, we should make a followup JIRA.\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(ExecNode::NodeVector inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, inputs.size(), \"UnionNode\"));\n+    if (inputs.size() < 2) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 2\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"Constructing a `UnionNode` with inputs with different schemas\");\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n\nReview comment:\n       This looks unused now.\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node_test.cc\n##########\n@@ -0,0 +1,203 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gmock/gmock-matchers.h>\n+\n+#include <iostream>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/pretty_print.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/matchers.h\"\n+\n+using testing::UnorderedElementsAreArray;\n+\n+namespace arrow {\n+namespace compute {\n+\n+void GenerateBatchesFromString(const std::shared_ptr<Schema>& schema,\n+                               const std::vector<util::string_view>& json_strings,\n+                               BatchesWithSchema* out_batches, int multiplicity = 1) {\n+  std::vector<ValueDescr> descrs;\n+  for (auto&& field : schema->fields()) {\n+    descrs.emplace_back(field->type());\n+  }\n+\n+  for (auto&& s : json_strings) {\n+    out_batches->batches.push_back(ExecBatchFromJSON(descrs, s));\n+  }\n+\n+  size_t batch_count = out_batches->batches.size();\n+  for (int repeat = 1; repeat < multiplicity; ++repeat) {\n+    for (size_t i = 0; i < batch_count; ++i) {\n+      out_batches->batches.push_back(out_batches->batches[i]);\n+    }\n+  }\n+\n+  out_batches->schema = schema;\n+}\n+\n+void CheckRunOutput(const BatchesWithSchema& l_batches,\n+                    const BatchesWithSchema& r_batches,\n+                    const BatchesWithSchema& exp_batches, bool parallel = false) {\n+  SCOPED_TRACE(parallel ? \"parallel\" : \"single threaded\");\n+\n+  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+\n+  Declaration union_decl{\"union\", ExecNodeOptions{}};\n+\n+  // add left source\n+  union_decl.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  // add right source\n+  union_decl.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+  ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                .AddToPlan(plan.get()));\n+\n+  Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n+\n+  auto expected_matcher =\n+      Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n+  ASSERT_THAT(actual, expected_matcher);\n+}\n+\n+void RunNonEmptyTest(bool parallel) {\n+  auto l_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n+  auto r_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n+  BatchesWithSchema l_batches, r_batches, exp_batches;\n+\n+  int multiplicity = parallel ? 100 : 1;\n+\n+  GenerateBatchesFromString(l_schema,\n+                            {\n+                                R\"([[0,\"d\"], [1,\"b\"]])\",\n+                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n+                            },\n+                            &l_batches, multiplicity);\n+\n+  GenerateBatchesFromString(r_schema,\n+                            {\n+                                R\"([[10,\"A\"]])\",\n+                            },\n+                            &r_batches, multiplicity);\n+\n+  GenerateBatchesFromString(l_schema,\n+                            {\n+                                R\"([[0,\"d\"], [1,\"b\"]])\",\n+                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n+\n+                                R\"([[10,\"A\"]])\",\n+                            },\n+                            &exp_batches, multiplicity);\n+  CheckRunOutput(l_batches, r_batches, exp_batches, parallel);\n+}\n+\n+void RunEmptyTest(bool parallel) {\n+  auto l_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n+  auto r_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n+\n+  int multiplicity = parallel ? 100 : 1;\n+\n+  BatchesWithSchema l_empty, r_empty, output_batches;\n+\n+  GenerateBatchesFromString(l_schema, {R\"([])\"}, &l_empty, multiplicity);\n+  GenerateBatchesFromString(r_schema, {R\"([])\"}, &r_empty, multiplicity);\n+\n+  GenerateBatchesFromString(l_schema, {R\"([])\", R\"([])\"}, &output_batches, multiplicity);\n+\n+  CheckRunOutput(l_empty, r_empty, output_batches);\n+}\n+\n+TEST(UnionTest, TestNonEmpty) {\n+  for (bool parallel : {false, true}) {\n+    RunNonEmptyTest(parallel);\n+  }\n+}\n+\n+TEST(UnionTest, TestEmpty) {\n+  for (bool parallel : {false, true}) {\n+    RunEmptyTest(parallel);\n+  }\n+}\n+\n+void TestUnionRandom(const std::shared_ptr<DataType>& data_type, bool parallel,\n+                     int num_batches, int batch_size) {\n+  auto l_schema = schema({field(\"colum0\", data_type), field(\"colum1\", data_type)});\n+  auto r_schema = schema({field(\"colum0\", data_type), field(\"colum1\", data_type)});\n+\n+  // generate data\n+  auto l_batches = MakeRandomBatches(l_schema, num_batches, batch_size);\n+  auto r_batches = MakeRandomBatches(r_schema, num_batches, batch_size);\n+\n+  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+\n+  Declaration Union{\"union\", ExecNodeOptions{}};\n+\n+  // add left source\n+  Union.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  // add right source\n+  Union.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n\nReview comment:\n       Maybe we could make this test use three inputs? We could even just duplicate one of the existing inputs.\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(ExecNode::NodeVector inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, inputs.size(), \"UnionNode\"));\n+    if (inputs.size() < 2) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 2\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"Constructing a `UnionNode` with inputs with different schemas\");\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+    if (batch_count_.Increment()) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    total_batches_.fetch_add(num_total);\n+\n+    if (input_count_.Increment()) {\n+      outputs_[0]->InputFinished(this, total_batches_.load());\n+      if (batch_count_.SetTotal(total_batches_.load())) {\n+        finished_.MarkFinished();\n+      }\n+    }\n+  }\n+\n+  Status StartProducing() override {\n+    finished_ = Future<>::Make();\n+    return Status::OK();\n+  }\n+\n+  void PauseProducing(ExecNode* output) override {}\n+\n+  void ResumeProducing(ExecNode* output) override {}\n+\n+  void StopProducing(ExecNode* output) override {\n+    DCHECK_EQ(output, outputs_[0]);\n+    if (batch_count_.Cancel()) {\n+      finished_.MakeFinished();\n\nReview comment:\n       ```suggestion\r\n         finished_.MarkFinished();\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(ExecNode::NodeVector inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, inputs.size(), \"UnionNode\"));\n+    if (inputs.size() < 2) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 2\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"Constructing a `UnionNode` with inputs with different schemas\");\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+    if (batch_count_.Increment()) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    total_batches_.fetch_add(num_total);\n+\n+    if (input_count_.Increment()) {\n+      outputs_[0]->InputFinished(this, total_batches_.load());\n+      if (batch_count_.SetTotal(total_batches_.load())) {\n+        finished_.MarkFinished();\n+      }\n+    }\n+  }\n+\n+  Status StartProducing() override {\n+    finished_ = Future<>::Make();\n+    return Status::OK();\n+  }\n+\n+  void PauseProducing(ExecNode* output) override {}\n+\n+  void ResumeProducing(ExecNode* output) override {}\n\nReview comment:\n       I think we can trivially forward pause/resume to our inputs.\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(ExecNode::NodeVector inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, inputs.size(), \"UnionNode\"));\n+    if (inputs.size() < 2) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 2\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"Constructing a `UnionNode` with inputs with different schemas\");\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+    if (batch_count_.Increment()) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    total_batches_.fetch_add(num_total);\n+\n+    if (input_count_.Increment()) {\n+      outputs_[0]->InputFinished(this, total_batches_.load());\n+      if (batch_count_.SetTotal(total_batches_.load())) {\n+        finished_.MarkFinished();\n+      }\n+    }\n+  }\n+\n+  Status StartProducing() override {\n+    finished_ = Future<>::Make();\n+    return Status::OK();\n+  }\n+\n+  void PauseProducing(ExecNode* output) override {}\n+\n+  void ResumeProducing(ExecNode* output) override {}\n+\n+  void StopProducing(ExecNode* output) override {\n+    DCHECK_EQ(output, outputs_[0]);\n+    if (batch_count_.Cancel()) {\n+      finished_.MakeFinished();\n+    }\n+    for (auto&& input : inputs_) {\n+      input->StopProducing(this);\n+    }\n+  }\n+\n+  void StopProducing() override {\n+    if (batch_count_.Cancel()) {\n+      finished_.MakeFinished();\n+    }\n+    inputs_[0]->StopProducing(this);\n+  }\n\nReview comment:\n       This should call StopProducing on every input.\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(ExecNode::NodeVector inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, inputs.size(), \"UnionNode\"));\n+    if (inputs.size() < 2) {\n\nReview comment:\n       It's kinda pointless, but allowing one input would be a little more consistent. (It might make life a little easier to not have to special case the n = 1 case when generating exec plans.)\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node_test.cc\n##########\n@@ -0,0 +1,203 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <gmock/gmock-matchers.h>\n+\n+#include <iostream>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/test_util.h\"\n+#include \"arrow/pretty_print.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/testing/matchers.h\"\n+\n+using testing::UnorderedElementsAreArray;\n+\n+namespace arrow {\n+namespace compute {\n+\n+void GenerateBatchesFromString(const std::shared_ptr<Schema>& schema,\n+                               const std::vector<util::string_view>& json_strings,\n+                               BatchesWithSchema* out_batches, int multiplicity = 1) {\n+  std::vector<ValueDescr> descrs;\n+  for (auto&& field : schema->fields()) {\n+    descrs.emplace_back(field->type());\n+  }\n+\n+  for (auto&& s : json_strings) {\n+    out_batches->batches.push_back(ExecBatchFromJSON(descrs, s));\n+  }\n+\n+  size_t batch_count = out_batches->batches.size();\n+  for (int repeat = 1; repeat < multiplicity; ++repeat) {\n+    for (size_t i = 0; i < batch_count; ++i) {\n+      out_batches->batches.push_back(out_batches->batches[i]);\n+    }\n+  }\n+\n+  out_batches->schema = schema;\n+}\n+\n+void CheckRunOutput(const BatchesWithSchema& l_batches,\n+                    const BatchesWithSchema& r_batches,\n+                    const BatchesWithSchema& exp_batches, bool parallel = false) {\n+  SCOPED_TRACE(parallel ? \"parallel\" : \"single threaded\");\n+\n+  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+\n+  Declaration union_decl{\"union\", ExecNodeOptions{}};\n+\n+  // add left source\n+  union_decl.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  // add right source\n+  union_decl.inputs.emplace_back(Declaration{\n+      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n+                                                                  /*slow=*/false)}});\n+  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+  ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                .AddToPlan(plan.get()));\n+\n+  Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n+\n+  auto expected_matcher =\n+      Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n+  ASSERT_THAT(actual, expected_matcher);\n+}\n+\n+void RunNonEmptyTest(bool parallel) {\n+  auto l_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n+  auto r_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n+  BatchesWithSchema l_batches, r_batches, exp_batches;\n+\n+  int multiplicity = parallel ? 100 : 1;\n+\n+  GenerateBatchesFromString(l_schema,\n+                            {\n+                                R\"([[0,\"d\"], [1,\"b\"]])\",\n+                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n+                            },\n+                            &l_batches, multiplicity);\n+\n+  GenerateBatchesFromString(r_schema,\n+                            {\n+                                R\"([[10,\"A\"]])\",\n+                            },\n+                            &r_batches, multiplicity);\n+\n+  GenerateBatchesFromString(l_schema,\n+                            {\n+                                R\"([[0,\"d\"], [1,\"b\"]])\",\n+                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n+\n+                                R\"([[10,\"A\"]])\",\n+                            },\n+                            &exp_batches, multiplicity);\n+  CheckRunOutput(l_batches, r_batches, exp_batches, parallel);\n+}\n+\n+void RunEmptyTest(bool parallel) {\n+  auto l_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n+  auto r_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n+\n+  int multiplicity = parallel ? 100 : 1;\n+\n+  BatchesWithSchema l_empty, r_empty, output_batches;\n+\n+  GenerateBatchesFromString(l_schema, {R\"([])\"}, &l_empty, multiplicity);\n+  GenerateBatchesFromString(r_schema, {R\"([])\"}, &r_empty, multiplicity);\n+\n+  GenerateBatchesFromString(l_schema, {R\"([])\", R\"([])\"}, &output_batches, multiplicity);\n+\n+  CheckRunOutput(l_empty, r_empty, output_batches);\n+}\n+\n+TEST(UnionTest, TestNonEmpty) {\n+  for (bool parallel : {false, true}) {\n+    RunNonEmptyTest(parallel);\n+  }\n+}\n+\n+TEST(UnionTest, TestEmpty) {\n+  for (bool parallel : {false, true}) {\n+    RunEmptyTest(parallel);\n+  }\n+}\n\nReview comment:\n       I think it'd be good to add a test that tries to create a union node with 0 inputs, and with differing schemas, to ensure those cases are covered.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-16T17:26:39.207+0000",
                    "updated": "2021-08-16T17:26:39.207+0000",
                    "started": "2021-08-16T17:26:39.207+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638310",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638463",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r689948342\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(ExecNode::NodeVector inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, inputs.size(), \"UnionNode\"));\n+    if (inputs.size() < 2) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 2\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"Constructing a `UnionNode` with inputs with different schemas\");\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n\nReview comment:\n       I think `seq` should be ultimately removed. It's a confusing parameter which we don't provide guarantees on. I'll add a JIRA for this anon\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T00:36:52.061+0000",
                    "updated": "2021-08-17T00:36:52.061+0000",
                    "started": "2021-08-17T00:36:52.061+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638463",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638472",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#issuecomment-899925561\n\n\n   Thanks @lidavidm, I updated this PR addressing feedback and ensuring the following cases are covered.\r\n   - union node with variable number of inputs with different schemas \r\n   - union node with 0 inputs\r\n   - union node with inputs with empty batches\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T01:30:50.932+0000",
                    "updated": "2021-08-17T01:30:50.932+0000",
                    "started": "2021-08-17T01:30:50.932+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638472",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638635",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r690324959\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -48,31 +48,29 @@ struct UnionNode : ExecNode {\n       : ExecNode(plan, inputs, GetInputLabels(inputs),\n                  /*output_schema=*/inputs[0]->output_schema(),\n                  /*num_outputs=*/1) {\n-    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n-      finished_.MarkFinished();\n-    }\n+    ARROW_DCHECK(this->input_count_.SetTotal(static_cast<int>(inputs.size())) == false);\n\nReview comment:\n       This won't work - this will get compiled out in release mode.\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node_test.cc\n##########\n@@ -17,187 +17,126 @@\n \n #include <gmock/gmock-matchers.h>\n \n-#include <iostream>\n-\n #include \"arrow/api.h\"\n #include \"arrow/compute/exec/options.h\"\n #include \"arrow/compute/exec/test_util.h\"\n-#include \"arrow/pretty_print.h\"\n #include \"arrow/testing/gtest_util.h\"\n #include \"arrow/testing/matchers.h\"\n+#include \"arrow/testing/random.h\"\n \n using testing::UnorderedElementsAreArray;\n \n namespace arrow {\n namespace compute {\n \n-void GenerateBatchesFromString(const std::shared_ptr<Schema>& schema,\n-                               const std::vector<util::string_view>& json_strings,\n-                               BatchesWithSchema* out_batches, int multiplicity = 1) {\n-  std::vector<ValueDescr> descrs;\n-  for (auto&& field : schema->fields()) {\n-    descrs.emplace_back(field->type());\n-  }\n+struct TestUnionNode : public ::testing::Test {\n+  TestUnionNode() : rng_(seed_) {}\n \n-  for (auto&& s : json_strings) {\n-    out_batches->batches.push_back(ExecBatchFromJSON(descrs, s));\n-  }\n+  std::shared_ptr<Schema> GenerateRandomSchema(size_t num_inputs) {\n+    static std::vector<std::shared_ptr<DataType>> some_arrow_types = {\n+        arrow::null(),    arrow::boolean(), arrow::int8(),    arrow::int16(),\n+        arrow::int32(),   arrow::int64(),   arrow::float16(), arrow::float32(),\n+        arrow::float64(), arrow::utf8(),    arrow::binary(),  arrow::date32()};\n \n-  size_t batch_count = out_batches->batches.size();\n-  for (int repeat = 1; repeat < multiplicity; ++repeat) {\n-    for (size_t i = 0; i < batch_count; ++i) {\n-      out_batches->batches.push_back(out_batches->batches[i]);\n+    std::vector<std::shared_ptr<Field>> fields(num_inputs);\n+    for (size_t i = 0; i < num_inputs; i++) {\n+      auto col_type = some_arrow_types.at(rand() % some_arrow_types.size());\n+      fields[i] =\n+          field(\"column_\" + std::to_string(i) + \"_\" + col_type->ToString(), col_type);\n     }\n+    return schema(fields);\n   }\n \n-  out_batches->schema = schema;\n-}\n-\n-void CheckRunOutput(const BatchesWithSchema& l_batches,\n-                    const BatchesWithSchema& r_batches,\n-                    const BatchesWithSchema& exp_batches, bool parallel = false) {\n-  SCOPED_TRACE(parallel ? \"parallel\" : \"single threaded\");\n-\n-  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n-\n-  Declaration union_decl{\"union\", ExecNodeOptions{}};\n-\n-  // add left source\n-  union_decl.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  // add right source\n-  union_decl.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n-\n-  ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n-                .AddToPlan(plan.get()));\n-\n-  Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n-\n-  auto expected_matcher =\n-      Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n-  ASSERT_THAT(actual, expected_matcher);\n-}\n-\n-void RunNonEmptyTest(bool parallel) {\n-  auto l_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n-  auto r_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n-  BatchesWithSchema l_batches, r_batches, exp_batches;\n-\n-  int multiplicity = parallel ? 100 : 1;\n-\n-  GenerateBatchesFromString(l_schema,\n-                            {\n-                                R\"([[0,\"d\"], [1,\"b\"]])\",\n-                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n-                            },\n-                            &l_batches, multiplicity);\n-\n-  GenerateBatchesFromString(r_schema,\n-                            {\n-                                R\"([[10,\"A\"]])\",\n-                            },\n-                            &r_batches, multiplicity);\n-\n-  GenerateBatchesFromString(l_schema,\n-                            {\n-                                R\"([[0,\"d\"], [1,\"b\"]])\",\n-                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n-\n-                                R\"([[10,\"A\"]])\",\n-                            },\n-                            &exp_batches, multiplicity);\n-  CheckRunOutput(l_batches, r_batches, exp_batches, parallel);\n-}\n+  void GenerateBatchesFromSchema(const std::shared_ptr<Schema>& schema,\n+                                 size_t num_batches, BatchesWithSchema* out_batches,\n+                                 int multiplicity = 1, int64_t batch_size = 4) {\n+    if (num_batches == 0) {\n+      auto empty_record_batch = ExecBatch(*rng_.BatchOf(schema->fields(), 0));\n+      out_batches->batches.push_back(empty_record_batch);\n+    } else {\n+      for (size_t j = 0; j < num_batches; j++) {\n+        out_batches->batches.push_back(\n+            ExecBatch(*rng_.BatchOf(schema->fields(), batch_size)));\n+      }\n+    }\n \n-void RunEmptyTest(bool parallel) {\n-  auto l_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n-  auto r_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n+    size_t batch_count = out_batches->batches.size();\n+    for (int repeat = 1; repeat < multiplicity; ++repeat) {\n+      for (size_t i = 0; i < batch_count; ++i) {\n+        out_batches->batches.push_back(out_batches->batches[i]);\n+      }\n+    }\n+    out_batches->schema = schema;\n+  }\n \n-  int multiplicity = parallel ? 100 : 1;\n+  void CheckRunOutput(const std::vector<BatchesWithSchema>& batches,\n+                      const BatchesWithSchema& exp_batches, bool parallel = false) {\n+    SCOPED_TRACE(parallel ? \"parallel\" : \"single threaded\");\n \n-  BatchesWithSchema l_empty, r_empty, output_batches;\n+    ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n \n-  GenerateBatchesFromString(l_schema, {R\"([])\"}, &l_empty, multiplicity);\n-  GenerateBatchesFromString(r_schema, {R\"([])\"}, &r_empty, multiplicity);\n+    Declaration union_decl{\"union\", ExecNodeOptions{}};\n \n-  GenerateBatchesFromString(l_schema, {R\"([])\", R\"([])\"}, &output_batches, multiplicity);\n+    for (const auto& batch : batches) {\n+      union_decl.inputs.emplace_back(Declaration{\n+          \"source\", SourceNodeOptions{batch.schema, batch.gen(parallel,\n+                                                              /*slow=*/false)}});\n+    }\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    // Test UnionNode::Make with zero inputs\n+    if (batches.size() == 0) {\n+      ASSERT_RAISES(Invalid, Declaration::Sequence(\n+                                 {union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                                 .AddToPlan(plan.get()));\n+      return;\n+    } else {\n+      ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                    .AddToPlan(plan.get()));\n+    }\n \n-  CheckRunOutput(l_empty, r_empty, output_batches);\n-}\n+    Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n \n-TEST(UnionTest, TestNonEmpty) {\n-  for (bool parallel : {false, true}) {\n-    RunNonEmptyTest(parallel);\n+    auto expected_matcher =\n+        Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n+    ASSERT_THAT(actual, expected_matcher);\n   }\n-}\n \n-TEST(UnionTest, TestEmpty) {\n-  for (bool parallel : {false, true}) {\n-    RunEmptyTest(parallel);\n+  void CheckUnionExecNode(size_t num_input_nodes, size_t num_batches, bool parallel) {\n+    auto random_schema = GenerateRandomSchema(num_input_nodes);\n+\n+    int multiplicity = parallel ? 10 : 1;\n+    std::vector<std::shared_ptr<RecordBatch>> all_record_batches;\n+    std::vector<BatchesWithSchema> input_batches(num_input_nodes);\n+    BatchesWithSchema exp_batches;\n+    exp_batches.schema = random_schema;\n+    for (size_t i = 0; i < num_input_nodes; i++) {\n+      GenerateBatchesFromSchema(random_schema, num_batches, &input_batches[i],\n+                                multiplicity, kBatchSize);\n+      for (const auto& batch : input_batches[i].batches) {\n+        exp_batches.batches.push_back(batch);\n+      }\n+    }\n+    CheckRunOutput(input_batches, exp_batches, parallel);\n   }\n-}\n-\n-void TestUnionRandom(const std::shared_ptr<DataType>& data_type, bool parallel,\n-                     int num_batches, int batch_size) {\n-  auto l_schema = schema({field(\"colum0\", data_type), field(\"colum1\", data_type)});\n-  auto r_schema = schema({field(\"colum0\", data_type), field(\"colum1\", data_type)});\n-\n-  // generate data\n-  auto l_batches = MakeRandomBatches(l_schema, num_batches, batch_size);\n-  auto r_batches = MakeRandomBatches(r_schema, num_batches, batch_size);\n-\n-  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n-\n-  Declaration Union{\"union\", ExecNodeOptions{}};\n-\n-  // add left source\n-  Union.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  // add right source\n-  Union.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n \n-  ASSERT_OK(Declaration::Sequence({Union, {\"sink\", SinkNodeOptions{&sink_gen}}})\n-                .AddToPlan(plan.get()));\n+  ::arrow::random::SeedType seed_ = 0xdeadbeef;\n+  ::arrow::random::RandomArrayGenerator rng_;\n \n-  auto actual = StartAndCollect(plan.get(), sink_gen);\n+  static constexpr int kNumBatches = 10;\n\nReview comment:\n       nit: put constants towards the top. See https://google.github.io/styleguide/cppguide.html#Declaration_Order\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node_test.cc\n##########\n@@ -17,187 +17,126 @@\n \n #include <gmock/gmock-matchers.h>\n \n-#include <iostream>\n-\n #include \"arrow/api.h\"\n #include \"arrow/compute/exec/options.h\"\n #include \"arrow/compute/exec/test_util.h\"\n-#include \"arrow/pretty_print.h\"\n #include \"arrow/testing/gtest_util.h\"\n #include \"arrow/testing/matchers.h\"\n+#include \"arrow/testing/random.h\"\n \n using testing::UnorderedElementsAreArray;\n \n namespace arrow {\n namespace compute {\n \n-void GenerateBatchesFromString(const std::shared_ptr<Schema>& schema,\n-                               const std::vector<util::string_view>& json_strings,\n-                               BatchesWithSchema* out_batches, int multiplicity = 1) {\n-  std::vector<ValueDescr> descrs;\n-  for (auto&& field : schema->fields()) {\n-    descrs.emplace_back(field->type());\n-  }\n+struct TestUnionNode : public ::testing::Test {\n+  TestUnionNode() : rng_(seed_) {}\n \n-  for (auto&& s : json_strings) {\n-    out_batches->batches.push_back(ExecBatchFromJSON(descrs, s));\n-  }\n+  std::shared_ptr<Schema> GenerateRandomSchema(size_t num_inputs) {\n+    static std::vector<std::shared_ptr<DataType>> some_arrow_types = {\n+        arrow::null(),    arrow::boolean(), arrow::int8(),    arrow::int16(),\n+        arrow::int32(),   arrow::int64(),   arrow::float16(), arrow::float32(),\n+        arrow::float64(), arrow::utf8(),    arrow::binary(),  arrow::date32()};\n \n-  size_t batch_count = out_batches->batches.size();\n-  for (int repeat = 1; repeat < multiplicity; ++repeat) {\n-    for (size_t i = 0; i < batch_count; ++i) {\n-      out_batches->batches.push_back(out_batches->batches[i]);\n+    std::vector<std::shared_ptr<Field>> fields(num_inputs);\n+    for (size_t i = 0; i < num_inputs; i++) {\n+      auto col_type = some_arrow_types.at(rand() % some_arrow_types.size());\n+      fields[i] =\n+          field(\"column_\" + std::to_string(i) + \"_\" + col_type->ToString(), col_type);\n     }\n+    return schema(fields);\n   }\n \n-  out_batches->schema = schema;\n-}\n-\n-void CheckRunOutput(const BatchesWithSchema& l_batches,\n-                    const BatchesWithSchema& r_batches,\n-                    const BatchesWithSchema& exp_batches, bool parallel = false) {\n-  SCOPED_TRACE(parallel ? \"parallel\" : \"single threaded\");\n-\n-  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n-\n-  Declaration union_decl{\"union\", ExecNodeOptions{}};\n-\n-  // add left source\n-  union_decl.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  // add right source\n-  union_decl.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n-\n-  ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n-                .AddToPlan(plan.get()));\n-\n-  Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n-\n-  auto expected_matcher =\n-      Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n-  ASSERT_THAT(actual, expected_matcher);\n-}\n-\n-void RunNonEmptyTest(bool parallel) {\n-  auto l_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n-  auto r_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n-  BatchesWithSchema l_batches, r_batches, exp_batches;\n-\n-  int multiplicity = parallel ? 100 : 1;\n-\n-  GenerateBatchesFromString(l_schema,\n-                            {\n-                                R\"([[0,\"d\"], [1,\"b\"]])\",\n-                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n-                            },\n-                            &l_batches, multiplicity);\n-\n-  GenerateBatchesFromString(r_schema,\n-                            {\n-                                R\"([[10,\"A\"]])\",\n-                            },\n-                            &r_batches, multiplicity);\n-\n-  GenerateBatchesFromString(l_schema,\n-                            {\n-                                R\"([[0,\"d\"], [1,\"b\"]])\",\n-                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n-\n-                                R\"([[10,\"A\"]])\",\n-                            },\n-                            &exp_batches, multiplicity);\n-  CheckRunOutput(l_batches, r_batches, exp_batches, parallel);\n-}\n+  void GenerateBatchesFromSchema(const std::shared_ptr<Schema>& schema,\n+                                 size_t num_batches, BatchesWithSchema* out_batches,\n+                                 int multiplicity = 1, int64_t batch_size = 4) {\n+    if (num_batches == 0) {\n+      auto empty_record_batch = ExecBatch(*rng_.BatchOf(schema->fields(), 0));\n+      out_batches->batches.push_back(empty_record_batch);\n+    } else {\n+      for (size_t j = 0; j < num_batches; j++) {\n+        out_batches->batches.push_back(\n+            ExecBatch(*rng_.BatchOf(schema->fields(), batch_size)));\n+      }\n+    }\n \n-void RunEmptyTest(bool parallel) {\n-  auto l_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n-  auto r_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n+    size_t batch_count = out_batches->batches.size();\n+    for (int repeat = 1; repeat < multiplicity; ++repeat) {\n+      for (size_t i = 0; i < batch_count; ++i) {\n+        out_batches->batches.push_back(out_batches->batches[i]);\n+      }\n+    }\n+    out_batches->schema = schema;\n+  }\n \n-  int multiplicity = parallel ? 100 : 1;\n+  void CheckRunOutput(const std::vector<BatchesWithSchema>& batches,\n+                      const BatchesWithSchema& exp_batches, bool parallel = false) {\n+    SCOPED_TRACE(parallel ? \"parallel\" : \"single threaded\");\n \n-  BatchesWithSchema l_empty, r_empty, output_batches;\n+    ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n \n-  GenerateBatchesFromString(l_schema, {R\"([])\"}, &l_empty, multiplicity);\n-  GenerateBatchesFromString(r_schema, {R\"([])\"}, &r_empty, multiplicity);\n+    Declaration union_decl{\"union\", ExecNodeOptions{}};\n \n-  GenerateBatchesFromString(l_schema, {R\"([])\", R\"([])\"}, &output_batches, multiplicity);\n+    for (const auto& batch : batches) {\n+      union_decl.inputs.emplace_back(Declaration{\n+          \"source\", SourceNodeOptions{batch.schema, batch.gen(parallel,\n+                                                              /*slow=*/false)}});\n+    }\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    // Test UnionNode::Make with zero inputs\n+    if (batches.size() == 0) {\n+      ASSERT_RAISES(Invalid, Declaration::Sequence(\n+                                 {union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                                 .AddToPlan(plan.get()));\n+      return;\n+    } else {\n+      ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                    .AddToPlan(plan.get()));\n+    }\n \n-  CheckRunOutput(l_empty, r_empty, output_batches);\n-}\n+    Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n \n-TEST(UnionTest, TestNonEmpty) {\n-  for (bool parallel : {false, true}) {\n-    RunNonEmptyTest(parallel);\n+    auto expected_matcher =\n+        Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n+    ASSERT_THAT(actual, expected_matcher);\n   }\n-}\n \n-TEST(UnionTest, TestEmpty) {\n-  for (bool parallel : {false, true}) {\n-    RunEmptyTest(parallel);\n+  void CheckUnionExecNode(size_t num_input_nodes, size_t num_batches, bool parallel) {\n+    auto random_schema = GenerateRandomSchema(num_input_nodes);\n+\n+    int multiplicity = parallel ? 10 : 1;\n+    std::vector<std::shared_ptr<RecordBatch>> all_record_batches;\n+    std::vector<BatchesWithSchema> input_batches(num_input_nodes);\n+    BatchesWithSchema exp_batches;\n+    exp_batches.schema = random_schema;\n+    for (size_t i = 0; i < num_input_nodes; i++) {\n+      GenerateBatchesFromSchema(random_schema, num_batches, &input_batches[i],\n+                                multiplicity, kBatchSize);\n+      for (const auto& batch : input_batches[i].batches) {\n+        exp_batches.batches.push_back(batch);\n+      }\n+    }\n+    CheckRunOutput(input_batches, exp_batches, parallel);\n   }\n-}\n-\n-void TestUnionRandom(const std::shared_ptr<DataType>& data_type, bool parallel,\n-                     int num_batches, int batch_size) {\n-  auto l_schema = schema({field(\"colum0\", data_type), field(\"colum1\", data_type)});\n-  auto r_schema = schema({field(\"colum0\", data_type), field(\"colum1\", data_type)});\n-\n-  // generate data\n-  auto l_batches = MakeRandomBatches(l_schema, num_batches, batch_size);\n-  auto r_batches = MakeRandomBatches(r_schema, num_batches, batch_size);\n-\n-  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n-\n-  Declaration Union{\"union\", ExecNodeOptions{}};\n-\n-  // add left source\n-  Union.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  // add right source\n-  Union.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n \n-  ASSERT_OK(Declaration::Sequence({Union, {\"sink\", SinkNodeOptions{&sink_gen}}})\n-                .AddToPlan(plan.get()));\n+  ::arrow::random::SeedType seed_ = 0xdeadbeef;\n+  ::arrow::random::RandomArrayGenerator rng_;\n \n-  auto actual = StartAndCollect(plan.get(), sink_gen);\n+  static constexpr int kNumBatches = 10;\n+  static constexpr int kBatchSize = 10;\n+};\n \n-  BatchesWithSchema exp_batches;\n-  exp_batches.schema = l_schema;\n-  exp_batches.batches.reserve(l_batches.batches.size() + r_batches.batches.size());\n-\n-  std::copy(l_batches.batches.begin(), l_batches.batches.end(),\n-            std::back_inserter(exp_batches.batches));\n-  std::copy(r_batches.batches.begin(), r_batches.batches.end(),\n-            std::back_inserter(exp_batches.batches));\n-\n-  auto expected_matcher =\n-      Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n-  ASSERT_THAT(actual, expected_matcher);\n+TEST_F(TestUnionNode, TestNonEmpty) {\n+  for (bool parallel : {false, true}) {\n+    for (int64_t num_input_nodes : {1, 2, 4, 8}) {\n+      this->CheckUnionExecNode(num_input_nodes, /*num_batches=*/kNumBatches, parallel);\n+    }\n+  }\n }\n+TEST_F(TestUnionNode, TestWithAnEmptyBatch) { this->CheckUnionExecNode(2, 0, false); }\n \n-class UnionTestRand\n-    : public testing::TestWithParam<std::tuple<std::shared_ptr<DataType>, bool>> {};\n-\n-static constexpr int kNumBatches = 100;\n-static constexpr int kBatchSize = 10;\n-\n-INSTANTIATE_TEST_SUITE_P(UnionTestRand, UnionTestRand,\n-                         ::testing::Combine(::testing::Values(int8(), int32(), int64(),\n-                                                              float32(), float64()),\n-                                            ::testing::Values(false, true)));\n-\n-TEST_P(UnionTestRand, TestingTypes) {\n-  TestUnionRandom(std::get<0>(GetParam()), std::get<1>(GetParam()), kNumBatches,\n-                  kBatchSize);\n-}\n+TEST_F(TestUnionNode, TestEmpty) { this->CheckUnionExecNode(0, 0, false); }\n\nReview comment:\n       And conversely above in TestNonEmpty, the comment is redundant since there's a constant.\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node_test.cc\n##########\n@@ -17,187 +17,126 @@\n \n #include <gmock/gmock-matchers.h>\n \n-#include <iostream>\n-\n #include \"arrow/api.h\"\n #include \"arrow/compute/exec/options.h\"\n #include \"arrow/compute/exec/test_util.h\"\n-#include \"arrow/pretty_print.h\"\n #include \"arrow/testing/gtest_util.h\"\n #include \"arrow/testing/matchers.h\"\n+#include \"arrow/testing/random.h\"\n \n using testing::UnorderedElementsAreArray;\n \n namespace arrow {\n namespace compute {\n \n-void GenerateBatchesFromString(const std::shared_ptr<Schema>& schema,\n-                               const std::vector<util::string_view>& json_strings,\n-                               BatchesWithSchema* out_batches, int multiplicity = 1) {\n-  std::vector<ValueDescr> descrs;\n-  for (auto&& field : schema->fields()) {\n-    descrs.emplace_back(field->type());\n-  }\n+struct TestUnionNode : public ::testing::Test {\n+  TestUnionNode() : rng_(seed_) {}\n \n-  for (auto&& s : json_strings) {\n-    out_batches->batches.push_back(ExecBatchFromJSON(descrs, s));\n-  }\n+  std::shared_ptr<Schema> GenerateRandomSchema(size_t num_inputs) {\n+    static std::vector<std::shared_ptr<DataType>> some_arrow_types = {\n+        arrow::null(),    arrow::boolean(), arrow::int8(),    arrow::int16(),\n+        arrow::int32(),   arrow::int64(),   arrow::float16(), arrow::float32(),\n+        arrow::float64(), arrow::utf8(),    arrow::binary(),  arrow::date32()};\n \n-  size_t batch_count = out_batches->batches.size();\n-  for (int repeat = 1; repeat < multiplicity; ++repeat) {\n-    for (size_t i = 0; i < batch_count; ++i) {\n-      out_batches->batches.push_back(out_batches->batches[i]);\n+    std::vector<std::shared_ptr<Field>> fields(num_inputs);\n+    for (size_t i = 0; i < num_inputs; i++) {\n+      auto col_type = some_arrow_types.at(rand() % some_arrow_types.size());\n+      fields[i] =\n+          field(\"column_\" + std::to_string(i) + \"_\" + col_type->ToString(), col_type);\n     }\n+    return schema(fields);\n   }\n \n-  out_batches->schema = schema;\n-}\n-\n-void CheckRunOutput(const BatchesWithSchema& l_batches,\n-                    const BatchesWithSchema& r_batches,\n-                    const BatchesWithSchema& exp_batches, bool parallel = false) {\n-  SCOPED_TRACE(parallel ? \"parallel\" : \"single threaded\");\n-\n-  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n-\n-  Declaration union_decl{\"union\", ExecNodeOptions{}};\n-\n-  // add left source\n-  union_decl.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  // add right source\n-  union_decl.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n-\n-  ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n-                .AddToPlan(plan.get()));\n-\n-  Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n-\n-  auto expected_matcher =\n-      Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n-  ASSERT_THAT(actual, expected_matcher);\n-}\n-\n-void RunNonEmptyTest(bool parallel) {\n-  auto l_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n-  auto r_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n-  BatchesWithSchema l_batches, r_batches, exp_batches;\n-\n-  int multiplicity = parallel ? 100 : 1;\n-\n-  GenerateBatchesFromString(l_schema,\n-                            {\n-                                R\"([[0,\"d\"], [1,\"b\"]])\",\n-                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n-                            },\n-                            &l_batches, multiplicity);\n-\n-  GenerateBatchesFromString(r_schema,\n-                            {\n-                                R\"([[10,\"A\"]])\",\n-                            },\n-                            &r_batches, multiplicity);\n-\n-  GenerateBatchesFromString(l_schema,\n-                            {\n-                                R\"([[0,\"d\"], [1,\"b\"]])\",\n-                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n-\n-                                R\"([[10,\"A\"]])\",\n-                            },\n-                            &exp_batches, multiplicity);\n-  CheckRunOutput(l_batches, r_batches, exp_batches, parallel);\n-}\n+  void GenerateBatchesFromSchema(const std::shared_ptr<Schema>& schema,\n+                                 size_t num_batches, BatchesWithSchema* out_batches,\n+                                 int multiplicity = 1, int64_t batch_size = 4) {\n+    if (num_batches == 0) {\n+      auto empty_record_batch = ExecBatch(*rng_.BatchOf(schema->fields(), 0));\n+      out_batches->batches.push_back(empty_record_batch);\n+    } else {\n+      for (size_t j = 0; j < num_batches; j++) {\n+        out_batches->batches.push_back(\n+            ExecBatch(*rng_.BatchOf(schema->fields(), batch_size)));\n+      }\n+    }\n \n-void RunEmptyTest(bool parallel) {\n-  auto l_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n-  auto r_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n+    size_t batch_count = out_batches->batches.size();\n+    for (int repeat = 1; repeat < multiplicity; ++repeat) {\n+      for (size_t i = 0; i < batch_count; ++i) {\n+        out_batches->batches.push_back(out_batches->batches[i]);\n+      }\n+    }\n+    out_batches->schema = schema;\n+  }\n \n-  int multiplicity = parallel ? 100 : 1;\n+  void CheckRunOutput(const std::vector<BatchesWithSchema>& batches,\n+                      const BatchesWithSchema& exp_batches, bool parallel = false) {\n+    SCOPED_TRACE(parallel ? \"parallel\" : \"single threaded\");\n \n-  BatchesWithSchema l_empty, r_empty, output_batches;\n+    ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n \n-  GenerateBatchesFromString(l_schema, {R\"([])\"}, &l_empty, multiplicity);\n-  GenerateBatchesFromString(r_schema, {R\"([])\"}, &r_empty, multiplicity);\n+    Declaration union_decl{\"union\", ExecNodeOptions{}};\n \n-  GenerateBatchesFromString(l_schema, {R\"([])\", R\"([])\"}, &output_batches, multiplicity);\n+    for (const auto& batch : batches) {\n+      union_decl.inputs.emplace_back(Declaration{\n+          \"source\", SourceNodeOptions{batch.schema, batch.gen(parallel,\n+                                                              /*slow=*/false)}});\n+    }\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    // Test UnionNode::Make with zero inputs\n+    if (batches.size() == 0) {\n+      ASSERT_RAISES(Invalid, Declaration::Sequence(\n+                                 {union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                                 .AddToPlan(plan.get()));\n+      return;\n+    } else {\n+      ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                    .AddToPlan(plan.get()));\n+    }\n \n-  CheckRunOutput(l_empty, r_empty, output_batches);\n-}\n+    Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n \n-TEST(UnionTest, TestNonEmpty) {\n-  for (bool parallel : {false, true}) {\n-    RunNonEmptyTest(parallel);\n+    auto expected_matcher =\n+        Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n+    ASSERT_THAT(actual, expected_matcher);\n   }\n-}\n \n-TEST(UnionTest, TestEmpty) {\n-  for (bool parallel : {false, true}) {\n-    RunEmptyTest(parallel);\n+  void CheckUnionExecNode(size_t num_input_nodes, size_t num_batches, bool parallel) {\n+    auto random_schema = GenerateRandomSchema(num_input_nodes);\n+\n+    int multiplicity = parallel ? 10 : 1;\n+    std::vector<std::shared_ptr<RecordBatch>> all_record_batches;\n+    std::vector<BatchesWithSchema> input_batches(num_input_nodes);\n+    BatchesWithSchema exp_batches;\n+    exp_batches.schema = random_schema;\n+    for (size_t i = 0; i < num_input_nodes; i++) {\n+      GenerateBatchesFromSchema(random_schema, num_batches, &input_batches[i],\n+                                multiplicity, kBatchSize);\n+      for (const auto& batch : input_batches[i].batches) {\n+        exp_batches.batches.push_back(batch);\n+      }\n+    }\n+    CheckRunOutput(input_batches, exp_batches, parallel);\n   }\n-}\n-\n-void TestUnionRandom(const std::shared_ptr<DataType>& data_type, bool parallel,\n-                     int num_batches, int batch_size) {\n-  auto l_schema = schema({field(\"colum0\", data_type), field(\"colum1\", data_type)});\n-  auto r_schema = schema({field(\"colum0\", data_type), field(\"colum1\", data_type)});\n-\n-  // generate data\n-  auto l_batches = MakeRandomBatches(l_schema, num_batches, batch_size);\n-  auto r_batches = MakeRandomBatches(r_schema, num_batches, batch_size);\n-\n-  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n-\n-  Declaration Union{\"union\", ExecNodeOptions{}};\n-\n-  // add left source\n-  Union.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  // add right source\n-  Union.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n \n-  ASSERT_OK(Declaration::Sequence({Union, {\"sink\", SinkNodeOptions{&sink_gen}}})\n-                .AddToPlan(plan.get()));\n+  ::arrow::random::SeedType seed_ = 0xdeadbeef;\n+  ::arrow::random::RandomArrayGenerator rng_;\n \n-  auto actual = StartAndCollect(plan.get(), sink_gen);\n+  static constexpr int kNumBatches = 10;\n+  static constexpr int kBatchSize = 10;\n+};\n \n-  BatchesWithSchema exp_batches;\n-  exp_batches.schema = l_schema;\n-  exp_batches.batches.reserve(l_batches.batches.size() + r_batches.batches.size());\n-\n-  std::copy(l_batches.batches.begin(), l_batches.batches.end(),\n-            std::back_inserter(exp_batches.batches));\n-  std::copy(r_batches.batches.begin(), r_batches.batches.end(),\n-            std::back_inserter(exp_batches.batches));\n-\n-  auto expected_matcher =\n-      Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n-  ASSERT_THAT(actual, expected_matcher);\n+TEST_F(TestUnionNode, TestNonEmpty) {\n+  for (bool parallel : {false, true}) {\n+    for (int64_t num_input_nodes : {1, 2, 4, 8}) {\n+      this->CheckUnionExecNode(num_input_nodes, /*num_batches=*/kNumBatches, parallel);\n+    }\n+  }\n }\n+TEST_F(TestUnionNode, TestWithAnEmptyBatch) { this->CheckUnionExecNode(2, 0, false); }\n \n-class UnionTestRand\n-    : public testing::TestWithParam<std::tuple<std::shared_ptr<DataType>, bool>> {};\n-\n-static constexpr int kNumBatches = 100;\n-static constexpr int kBatchSize = 10;\n-\n-INSTANTIATE_TEST_SUITE_P(UnionTestRand, UnionTestRand,\n-                         ::testing::Combine(::testing::Values(int8(), int32(), int64(),\n-                                                              float32(), float64()),\n-                                            ::testing::Values(false, true)));\n-\n-TEST_P(UnionTestRand, TestingTypes) {\n-  TestUnionRandom(std::get<0>(GetParam()), std::get<1>(GetParam()), kNumBatches,\n-                  kBatchSize);\n-}\n+TEST_F(TestUnionNode, TestEmpty) { this->CheckUnionExecNode(0, 0, false); }\n\nReview comment:\n       Nit: usually for constant parameters like this, we prefix the value with the argument name. See https://google.github.io/styleguide/cppguide.html#Function_Argument_Comments\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node_test.cc\n##########\n@@ -17,187 +17,126 @@\n \n #include <gmock/gmock-matchers.h>\n \n-#include <iostream>\n-\n #include \"arrow/api.h\"\n #include \"arrow/compute/exec/options.h\"\n #include \"arrow/compute/exec/test_util.h\"\n-#include \"arrow/pretty_print.h\"\n #include \"arrow/testing/gtest_util.h\"\n #include \"arrow/testing/matchers.h\"\n+#include \"arrow/testing/random.h\"\n \n using testing::UnorderedElementsAreArray;\n \n namespace arrow {\n namespace compute {\n \n-void GenerateBatchesFromString(const std::shared_ptr<Schema>& schema,\n-                               const std::vector<util::string_view>& json_strings,\n-                               BatchesWithSchema* out_batches, int multiplicity = 1) {\n-  std::vector<ValueDescr> descrs;\n-  for (auto&& field : schema->fields()) {\n-    descrs.emplace_back(field->type());\n-  }\n+struct TestUnionNode : public ::testing::Test {\n+  TestUnionNode() : rng_(seed_) {}\n \n-  for (auto&& s : json_strings) {\n-    out_batches->batches.push_back(ExecBatchFromJSON(descrs, s));\n-  }\n+  std::shared_ptr<Schema> GenerateRandomSchema(size_t num_inputs) {\n+    static std::vector<std::shared_ptr<DataType>> some_arrow_types = {\n+        arrow::null(),    arrow::boolean(), arrow::int8(),    arrow::int16(),\n+        arrow::int32(),   arrow::int64(),   arrow::float16(), arrow::float32(),\n+        arrow::float64(), arrow::utf8(),    arrow::binary(),  arrow::date32()};\n \n-  size_t batch_count = out_batches->batches.size();\n-  for (int repeat = 1; repeat < multiplicity; ++repeat) {\n-    for (size_t i = 0; i < batch_count; ++i) {\n-      out_batches->batches.push_back(out_batches->batches[i]);\n+    std::vector<std::shared_ptr<Field>> fields(num_inputs);\n+    for (size_t i = 0; i < num_inputs; i++) {\n+      auto col_type = some_arrow_types.at(rand() % some_arrow_types.size());\n+      fields[i] =\n+          field(\"column_\" + std::to_string(i) + \"_\" + col_type->ToString(), col_type);\n     }\n+    return schema(fields);\n   }\n \n-  out_batches->schema = schema;\n-}\n-\n-void CheckRunOutput(const BatchesWithSchema& l_batches,\n-                    const BatchesWithSchema& r_batches,\n-                    const BatchesWithSchema& exp_batches, bool parallel = false) {\n-  SCOPED_TRACE(parallel ? \"parallel\" : \"single threaded\");\n-\n-  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n-\n-  Declaration union_decl{\"union\", ExecNodeOptions{}};\n-\n-  // add left source\n-  union_decl.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  // add right source\n-  union_decl.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n-\n-  ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n-                .AddToPlan(plan.get()));\n-\n-  Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n-\n-  auto expected_matcher =\n-      Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n-  ASSERT_THAT(actual, expected_matcher);\n-}\n-\n-void RunNonEmptyTest(bool parallel) {\n-  auto l_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n-  auto r_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n-  BatchesWithSchema l_batches, r_batches, exp_batches;\n-\n-  int multiplicity = parallel ? 100 : 1;\n-\n-  GenerateBatchesFromString(l_schema,\n-                            {\n-                                R\"([[0,\"d\"], [1,\"b\"]])\",\n-                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n-                            },\n-                            &l_batches, multiplicity);\n-\n-  GenerateBatchesFromString(r_schema,\n-                            {\n-                                R\"([[10,\"A\"]])\",\n-                            },\n-                            &r_batches, multiplicity);\n-\n-  GenerateBatchesFromString(l_schema,\n-                            {\n-                                R\"([[0,\"d\"], [1,\"b\"]])\",\n-                                R\"([[2,\"d\"], [3,\"a\"], [4,\"a\"]])\",\n-\n-                                R\"([[10,\"A\"]])\",\n-                            },\n-                            &exp_batches, multiplicity);\n-  CheckRunOutput(l_batches, r_batches, exp_batches, parallel);\n-}\n+  void GenerateBatchesFromSchema(const std::shared_ptr<Schema>& schema,\n+                                 size_t num_batches, BatchesWithSchema* out_batches,\n+                                 int multiplicity = 1, int64_t batch_size = 4) {\n+    if (num_batches == 0) {\n+      auto empty_record_batch = ExecBatch(*rng_.BatchOf(schema->fields(), 0));\n+      out_batches->batches.push_back(empty_record_batch);\n+    } else {\n+      for (size_t j = 0; j < num_batches; j++) {\n+        out_batches->batches.push_back(\n+            ExecBatch(*rng_.BatchOf(schema->fields(), batch_size)));\n+      }\n+    }\n \n-void RunEmptyTest(bool parallel) {\n-  auto l_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n-  auto r_schema = schema({field(\"colum_i32\", int32()), field(\"colum_str\", utf8())});\n+    size_t batch_count = out_batches->batches.size();\n+    for (int repeat = 1; repeat < multiplicity; ++repeat) {\n+      for (size_t i = 0; i < batch_count; ++i) {\n+        out_batches->batches.push_back(out_batches->batches[i]);\n+      }\n+    }\n+    out_batches->schema = schema;\n+  }\n \n-  int multiplicity = parallel ? 100 : 1;\n+  void CheckRunOutput(const std::vector<BatchesWithSchema>& batches,\n+                      const BatchesWithSchema& exp_batches, bool parallel = false) {\n+    SCOPED_TRACE(parallel ? \"parallel\" : \"single threaded\");\n \n-  BatchesWithSchema l_empty, r_empty, output_batches;\n+    ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n \n-  GenerateBatchesFromString(l_schema, {R\"([])\"}, &l_empty, multiplicity);\n-  GenerateBatchesFromString(r_schema, {R\"([])\"}, &r_empty, multiplicity);\n+    Declaration union_decl{\"union\", ExecNodeOptions{}};\n \n-  GenerateBatchesFromString(l_schema, {R\"([])\", R\"([])\"}, &output_batches, multiplicity);\n+    for (const auto& batch : batches) {\n+      union_decl.inputs.emplace_back(Declaration{\n+          \"source\", SourceNodeOptions{batch.schema, batch.gen(parallel,\n+                                                              /*slow=*/false)}});\n+    }\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    // Test UnionNode::Make with zero inputs\n+    if (batches.size() == 0) {\n+      ASSERT_RAISES(Invalid, Declaration::Sequence(\n+                                 {union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                                 .AddToPlan(plan.get()));\n+      return;\n+    } else {\n+      ASSERT_OK(Declaration::Sequence({union_decl, {\"sink\", SinkNodeOptions{&sink_gen}}})\n+                    .AddToPlan(plan.get()));\n+    }\n \n-  CheckRunOutput(l_empty, r_empty, output_batches);\n-}\n+    Future<std::vector<ExecBatch>> actual = StartAndCollect(plan.get(), sink_gen);\n \n-TEST(UnionTest, TestNonEmpty) {\n-  for (bool parallel : {false, true}) {\n-    RunNonEmptyTest(parallel);\n+    auto expected_matcher =\n+        Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n+    ASSERT_THAT(actual, expected_matcher);\n   }\n-}\n \n-TEST(UnionTest, TestEmpty) {\n-  for (bool parallel : {false, true}) {\n-    RunEmptyTest(parallel);\n+  void CheckUnionExecNode(size_t num_input_nodes, size_t num_batches, bool parallel) {\n+    auto random_schema = GenerateRandomSchema(num_input_nodes);\n+\n+    int multiplicity = parallel ? 10 : 1;\n+    std::vector<std::shared_ptr<RecordBatch>> all_record_batches;\n+    std::vector<BatchesWithSchema> input_batches(num_input_nodes);\n+    BatchesWithSchema exp_batches;\n+    exp_batches.schema = random_schema;\n+    for (size_t i = 0; i < num_input_nodes; i++) {\n+      GenerateBatchesFromSchema(random_schema, num_batches, &input_batches[i],\n+                                multiplicity, kBatchSize);\n+      for (const auto& batch : input_batches[i].batches) {\n+        exp_batches.batches.push_back(batch);\n+      }\n+    }\n+    CheckRunOutput(input_batches, exp_batches, parallel);\n   }\n-}\n-\n-void TestUnionRandom(const std::shared_ptr<DataType>& data_type, bool parallel,\n-                     int num_batches, int batch_size) {\n-  auto l_schema = schema({field(\"colum0\", data_type), field(\"colum1\", data_type)});\n-  auto r_schema = schema({field(\"colum0\", data_type), field(\"colum1\", data_type)});\n-\n-  // generate data\n-  auto l_batches = MakeRandomBatches(l_schema, num_batches, batch_size);\n-  auto r_batches = MakeRandomBatches(r_schema, num_batches, batch_size);\n-\n-  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n-\n-  Declaration Union{\"union\", ExecNodeOptions{}};\n-\n-  // add left source\n-  Union.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{l_batches.schema, l_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  // add right source\n-  Union.inputs.emplace_back(Declaration{\n-      \"source\", SourceNodeOptions{r_batches.schema, r_batches.gen(parallel,\n-                                                                  /*slow=*/false)}});\n-  AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n \n-  ASSERT_OK(Declaration::Sequence({Union, {\"sink\", SinkNodeOptions{&sink_gen}}})\n-                .AddToPlan(plan.get()));\n+  ::arrow::random::SeedType seed_ = 0xdeadbeef;\n+  ::arrow::random::RandomArrayGenerator rng_;\n \n-  auto actual = StartAndCollect(plan.get(), sink_gen);\n+  static constexpr int kNumBatches = 10;\n+  static constexpr int kBatchSize = 10;\n+};\n \n-  BatchesWithSchema exp_batches;\n-  exp_batches.schema = l_schema;\n-  exp_batches.batches.reserve(l_batches.batches.size() + r_batches.batches.size());\n-\n-  std::copy(l_batches.batches.begin(), l_batches.batches.end(),\n-            std::back_inserter(exp_batches.batches));\n-  std::copy(r_batches.batches.begin(), r_batches.batches.end(),\n-            std::back_inserter(exp_batches.batches));\n-\n-  auto expected_matcher =\n-      Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches)));\n-  ASSERT_THAT(actual, expected_matcher);\n+TEST_F(TestUnionNode, TestNonEmpty) {\n+  for (bool parallel : {false, true}) {\n+    for (int64_t num_input_nodes : {1, 2, 4, 8}) {\n+      this->CheckUnionExecNode(num_input_nodes, /*num_batches=*/kNumBatches, parallel);\n+    }\n+  }\n }\n+TEST_F(TestUnionNode, TestWithAnEmptyBatch) { this->CheckUnionExecNode(2, 0, false); }\n \n-class UnionTestRand\n-    : public testing::TestWithParam<std::tuple<std::shared_ptr<DataType>, bool>> {};\n-\n-static constexpr int kNumBatches = 100;\n-static constexpr int kBatchSize = 10;\n-\n-INSTANTIATE_TEST_SUITE_P(UnionTestRand, UnionTestRand,\n-                         ::testing::Combine(::testing::Values(int8(), int32(), int64(),\n-                                                              float32(), float64()),\n-                                            ::testing::Values(false, true)));\n-\n-TEST_P(UnionTestRand, TestingTypes) {\n-  TestUnionRandom(std::get<0>(GetParam()), std::get<1>(GetParam()), kNumBatches,\n-                  kBatchSize);\n-}\n+TEST_F(TestUnionNode, TestEmpty) { this->CheckUnionExecNode(0, 0, false); }\n\nReview comment:\n       ```suggestion\r\n   TEST_F(TestUnionNode, TestEmpty) {\r\n     this->CheckUnionExecNode(/*num_input_nodes*/0, /*num_batches=*/0, /*parallel=*/false);\r\n   }\r\n   ```\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T12:52:27.299+0000",
                    "updated": "2021-08-17T12:52:27.299+0000",
                    "started": "2021-08-17T12:52:27.299+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638635",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638636",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r690339984\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(ExecNode::NodeVector inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, inputs.size(), \"UnionNode\"));\n+    if (inputs.size() < 2) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 2\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"Constructing a `UnionNode` with inputs with different schemas\");\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  inline bool IsLeftInput(ExecNode* input) { return input == inputs_[0]; }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n\nReview comment:\n       Thanks. @aocsa we can leave this as-is then.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T12:53:00.924+0000",
                    "updated": "2021-08-17T12:53:00.924+0000",
                    "started": "2021-08-17T12:53:00.924+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638636",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638674",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r690422823\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -48,31 +48,29 @@ struct UnionNode : ExecNode {\n       : ExecNode(plan, inputs, GetInputLabels(inputs),\n                  /*output_schema=*/inputs[0]->output_schema(),\n                  /*num_outputs=*/1) {\n-    if (this->input_count_.SetTotal(static_cast<int>(inputs.size()))) {\n-      finished_.MarkFinished();\n-    }\n+    ARROW_DCHECK(this->input_count_.SetTotal(static_cast<int>(inputs.size())) == false);\n\nReview comment:\n       In particular I think this is responsible for the MinGW CI failures (which compile in release mode vs the others which compile in debug mode)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T14:24:12.091+0000",
                    "updated": "2021-08-17T14:24:12.091+0000",
                    "started": "2021-08-17T14:24:12.090+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638674",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638684",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r690433922\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(const ExecNode::NodeVector& inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    ARROW_DCHECK(this->input_count_.SetTotal(static_cast<int>(inputs.size())) == false);\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, static_cast<int>(inputs.size()),\n+                                         \"UnionNode\"));\n+    if (inputs.size() < 1) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 1\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"UnionNode input schemas must all match, first schema was: \", *schema,\n+            \" got schema: \", *input->output_schema());\n\nReview comment:\n       ```suggestion\r\n               \"UnionNode input schemas must all match, first schema was: \", *schema.ToString(),\r\n               \" got schema: \", *input->output_schema().ToString());\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(const ExecNode::NodeVector& inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    ARROW_DCHECK(this->input_count_.SetTotal(static_cast<int>(inputs.size())) == false);\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, static_cast<int>(inputs.size()),\n+                                         \"UnionNode\"));\n+    if (inputs.size() < 1) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 1\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"UnionNode input schemas must all match, first schema was: \", *schema,\n+            \" got schema: \", *input->output_schema());\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+    if (batch_count_.Increment()) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    total_batches_.fetch_add(num_total);\n+\n+    if (input_count_.Increment()) {\n+      outputs_[0]->InputFinished(this, total_batches_.load());\n+      if (batch_count_.SetTotal(total_batches_.load())) {\n+        finished_.MarkFinished();\n+      }\n+    }\n\nReview comment:\n       I feel like this `total_batches_` is redundant. Cant we do this instead?\r\n   ```suggestion\r\n       batch_count_.Increment(num_total);\r\n   \r\n       if (input_count_.Increment()) {\r\n         outputs_[0]->InputFinished(this, total_batches_.load());\r\n         int total_batches = batch_count_.count();\r\n         if (batch_count_.SetTotal(total_batches)) {\r\n           finished_.MarkFinished();\r\n         }\r\n       }\r\n   ```\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(const ExecNode::NodeVector& inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    ARROW_DCHECK(this->input_count_.SetTotal(static_cast<int>(inputs.size())) == false);\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, static_cast<int>(inputs.size()),\n+                                         \"UnionNode\"));\n+    if (inputs.size() < 1) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 1\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"UnionNode input schemas must all match, first schema was: \", *schema,\n+            \" got schema: \", *input->output_schema());\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+    if (batch_count_.Increment()) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n\nReview comment:\n       ```suggestion\r\n       ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\r\n   ```\r\n   There's no need to use `find_if` here IMO. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T14:48:19.307+0000",
                    "updated": "2021-08-17T14:48:19.307+0000",
                    "started": "2021-08-17T14:48:19.306+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638684",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638701",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r690474004\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(const ExecNode::NodeVector& inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    ARROW_DCHECK(this->input_count_.SetTotal(static_cast<int>(inputs.size())) == false);\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, static_cast<int>(inputs.size()),\n+                                         \"UnionNode\"));\n+    if (inputs.size() < 1) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 1\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"UnionNode input schemas must all match, first schema was: \", *schema,\n+            \" got schema: \", *input->output_schema());\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+    if (batch_count_.Increment()) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    total_batches_.fetch_add(num_total);\n+\n+    if (input_count_.Increment()) {\n+      outputs_[0]->InputFinished(this, total_batches_.load());\n+      if (batch_count_.SetTotal(total_batches_.load())) {\n+        finished_.MarkFinished();\n+      }\n+    }\n\nReview comment:\n       you mean:\r\n   ```cpp\r\n   if (input_count_.Increment()) {\r\n         int total_batches = batch_count_.count();\r\n         outputs_[0]->InputFinished(this, total_batches);\r\n         if (batch_count_.SetTotal(total_batches)) {\r\n           finished_.MarkFinished();\r\n         }\r\n       }\r\n   ```\r\n   right? \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T15:18:35.981+0000",
                    "updated": "2021-08-17T15:18:35.981+0000",
                    "started": "2021-08-17T15:18:35.981+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638701",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638713",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r690502753\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,145 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(const ExecNode::NodeVector& inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    bool counter_completed = input_count_.SetTotal(static_cast<int>(inputs.size()));\n+    ARROW_DCHECK(counter_completed == false);\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, static_cast<int>(inputs.size()),\n+                                         \"UnionNode\"));\n+    if (inputs.size() < 1) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 1\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"UnionNode input schemas must all match, first schema was: \",\n+            schema->ToString(), \" got schema: \", input->output_schema()->ToString());\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+    if (batch_count_.Increment()) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n+\n+    if (input_count_.Increment()) {\n+      int total_batches = batch_count_.count();\n+      outputs_[0]->InputFinished(this, total_batches);\n+      if (batch_count_.SetTotal(total_batches)) {\n+        finished_.MarkFinished();\n+      }\n+    }\n\nReview comment:\n       This has a logic error again: InputFinished can be called before InputReceived. We need to make use of num_total here.\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,145 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(const ExecNode::NodeVector& inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    bool counter_completed = input_count_.SetTotal(static_cast<int>(inputs.size()));\n+    ARROW_DCHECK(counter_completed == false);\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, static_cast<int>(inputs.size()),\n+                                         \"UnionNode\"));\n+    if (inputs.size() < 1) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 1\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"UnionNode input schemas must all match, first schema was: \",\n+            schema->ToString(), \" got schema: \", input->output_schema()->ToString());\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+    if (batch_count_.Increment()) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n+\n+    if (input_count_.Increment()) {\n+      int total_batches = batch_count_.count();\n+      outputs_[0]->InputFinished(this, total_batches);\n+      if (batch_count_.SetTotal(total_batches)) {\n+        finished_.MarkFinished();\n+      }\n+    }\n\nReview comment:\n       @nirandaperera I don't think the proposal in https://github.com/apache/arrow/pull/10927#discussion_r690444907 works because we need to track both 1) batches seen so far and 2) total batches as reported by our inputs and we can't reuse the same counter for this, since setting the total of an AtomicCounter is effectively a one-time-only operation. (You could imagine ways to stuff it into the encoding: for example, an AccumulateTotal() that adds a *negative* value to total_, and a separate method SetTotal(void) that inverts the value - that would work modulo having to express all this with just atomics.)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T15:56:35.683+0000",
                    "updated": "2021-08-17T15:56:35.683+0000",
                    "started": "2021-08-17T15:56:35.683+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638713",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638728",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r690522264\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,145 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(const ExecNode::NodeVector& inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    bool counter_completed = input_count_.SetTotal(static_cast<int>(inputs.size()));\n+    ARROW_DCHECK(counter_completed == false);\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, static_cast<int>(inputs.size()),\n+                                         \"UnionNode\"));\n+    if (inputs.size() < 1) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 1\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"UnionNode input schemas must all match, first schema was: \",\n+            schema->ToString(), \" got schema: \", input->output_schema()->ToString());\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+    if (batch_count_.Increment()) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n+\n+    if (input_count_.Increment()) {\n+      int total_batches = batch_count_.count();\n+      outputs_[0]->InputFinished(this, total_batches);\n+      if (batch_count_.SetTotal(total_batches)) {\n+        finished_.MarkFinished();\n+      }\n+    }\n\nReview comment:\n       Ah. thanks @lidavidm for pointing that out. this certainly is a logic error. In that case, the previous `atomic<int>` approach is the way to go! @aocsa sorry for the confusion. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T16:14:21.111+0000",
                    "updated": "2021-08-17T16:14:21.111+0000",
                    "started": "2021-08-17T16:14:21.111+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638728",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638731",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "aocsa commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r690524292\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,145 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(const ExecNode::NodeVector& inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    bool counter_completed = input_count_.SetTotal(static_cast<int>(inputs.size()));\n+    ARROW_DCHECK(counter_completed == false);\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, static_cast<int>(inputs.size()),\n+                                         \"UnionNode\"));\n+    if (inputs.size() < 1) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 1\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"UnionNode input schemas must all match, first schema was: \",\n+            schema->ToString(), \" got schema: \", input->output_schema()->ToString());\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+    if (batch_count_.Increment()) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(std::find(inputs_.begin(), inputs_.end(), input) != inputs_.end());\n+\n+    if (input_count_.Increment()) {\n+      int total_batches = batch_count_.count();\n+      outputs_[0]->InputFinished(this, total_batches);\n+      if (batch_count_.SetTotal(total_batches)) {\n+        finished_.MarkFinished();\n+      }\n+    }\n\nReview comment:\n       got it, thanks @lidavidm \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T16:17:03.214+0000",
                    "updated": "2021-08-17T16:17:03.214+0000",
                    "started": "2021-08-17T16:17:03.213+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638731",
                    "issueId": "13365513"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/worklog/638734",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nirandaperera commented on a change in pull request #10927:\nURL: https://github.com/apache/arrow/pull/10927#discussion_r690525450\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec/union_node.cc\n##########\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <mutex>\n+\n+#include \"arrow/api.h\"\n+#include \"arrow/compute/api.h\"\n+#include \"arrow/compute/exec/exec_plan.h\"\n+#include \"arrow/compute/exec/options.h\"\n+#include \"arrow/compute/exec/util.h\"\n+#include \"arrow/util/bitmap_ops.h\"\n+#include \"arrow/util/checked_cast.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/thread_pool.h\"\n+\n+namespace arrow {\n+\n+using internal::checked_cast;\n+\n+namespace compute {\n+\n+namespace {\n+std::vector<std::string> GetInputLabels(const ExecNode::NodeVector& inputs) {\n+  std::vector<std::string> labels(inputs.size());\n+  for (size_t i = 0; i < inputs.size(); i++) {\n+    labels[i] = \"input_\" + std::to_string(i) + \"_label\";\n+  }\n+  return labels;\n+}\n+}  // namespace\n+struct UnionNode : ExecNode {\n+  UnionNode(ExecPlan* plan, std::vector<ExecNode*> inputs)\n+      : ExecNode(plan, inputs, GetInputLabels(inputs),\n+                 /*output_schema=*/inputs[0]->output_schema(),\n+                 /*num_outputs=*/1) {\n+    ARROW_DCHECK(this->input_count_.SetTotal(static_cast<int>(inputs.size())) == false);\n+  }\n+\n+  const char* kind_name() override { return \"UnionNode\"; }\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, static_cast<int>(inputs.size()),\n+                                         \"UnionNode\"));\n+    if (inputs.size() < 1) {\n+      return Status::Invalid(\"Constructing a `UnionNode` with inputs size less than 1\");\n+    }\n+    auto schema = inputs.at(0)->output_schema();\n+    for (auto input : inputs) {\n+      if (!input->output_schema()->Equals(schema)) {\n+        return Status::Invalid(\n+            \"UnionNode input schemas must all match, first schema was: \", *schema,\n+            \" got schema: \", *input->output_schema());\n+      }\n+    }\n+    return plan->EmplaceNode<UnionNode>(plan, std::move(inputs));\n+  }\n+\n+  void InputReceived(ExecNode* input, int seq, ExecBatch batch) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    if (finished_.is_finished()) {\n+      return;\n+    }\n+    outputs_[0]->InputReceived(this, seq, std::move(batch));\n+    if (batch_count_.Increment()) {\n+      finished_.MarkFinished();\n+    }\n+  }\n+\n+  void ErrorReceived(ExecNode* input, Status error) override {\n+    DCHECK_EQ(input, inputs_[0]);\n+    outputs_[0]->ErrorReceived(this, std::move(error));\n+\n+    StopProducing();\n+  }\n+\n+  void InputFinished(ExecNode* input, int num_total) override {\n+    ARROW_DCHECK(std::find_if(inputs_.begin(), inputs_.end(), [input](ExecNode* n) {\n+                   return n == input;\n+                 }) != inputs_.end());\n+\n+    total_batches_.fetch_add(num_total);\n+\n+    if (input_count_.Increment()) {\n+      outputs_[0]->InputFinished(this, total_batches_.load());\n+      if (batch_count_.SetTotal(total_batches_.load())) {\n+        finished_.MarkFinished();\n+      }\n+    }\n\nReview comment:\n       Please ignore this suggestion. This leads to a logic error as pointed out by @lidavidm  \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-17T16:18:41.123+0000",
                    "updated": "2021-08-17T16:18:41.123+0000",
                    "started": "2021-08-17T16:18:41.123+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "638734",
                    "issueId": "13365513"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 19800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1d37cf6a[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5b16016a[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@64e7b9b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@6db83769[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@560c65a1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7ee344d6[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@b046a32[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@272b0744[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@123f5f6d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@761e7c08[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5ee3dd03[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@210df0bc[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 19800,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Aug 18 12:04:15 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-08-18T12:04:15.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11981/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2021-03-16T13:17:35.000+0000",
        "updated": "2021-08-18T17:01:56.000+0000",
        "timeoriginalestimate": null,
        "description": "UnionDataset allows Fragments of multiple schemas and differing file formats to be scanned together as a single Dataset. This is useful functionality but makes the Dataset interface somewhat difficult to reason about since it must be general enough to accommodate UnionDataset.\r\n\r\nAfter ARROW-11928 it will probably be more natural to support unioning of datasets through a subclass of ExecNode. Reconciliation of differing schemas can then be trivially handled by a full ProjectNode.\r\n\r\nNote this would obviate both ARROW-11001 and ARROW-11749. In addition, Dataset could be simplified to a concrete class containing a set of compatibly typed/formatted Fragments.\r\n",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 19800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Dataset][Compute] Replace UnionDataset with Union ExecNode",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/comment/17302515",
                    "id": "17302515",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "[~davidli] [~westonpace]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-03-16T13:19:13.825+0000",
                    "updated": "2021-03-16T13:19:13.825+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/comment/17302832",
                    "id": "17302832",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "It does raise the question of whether dataset scanning itself should be an exec node?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-03-16T19:09:49.833+0000",
                    "updated": "2021-03-16T19:09:49.833+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/comment/17302908",
                    "id": "17302908",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=davidli",
                        "name": "davidli",
                        "key": "davidli",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "[~bkietz] Sorry, you've got the wrong\u00a0[~davidli]. I am not associated with this project! :D",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=davidli",
                        "name": "davidli",
                        "key": "davidli",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-03-16T21:30:35.252+0000",
                    "updated": "2021-03-16T21:31:25.619+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/comment/17302910",
                    "id": "17302910",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "body": "[~lidavidm]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
                        "name": "westonpace",
                        "key": "westonpace",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
                        },
                        "displayName": "Weston Pace",
                        "active": true,
                        "timeZone": "America/Los_Angeles"
                    },
                    "created": "2021-03-16T21:38:28.833+0000",
                    "updated": "2021-03-16T21:38:28.833+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/comment/17302912",
                    "id": "17302912",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "(I usually go by lidavidm since my name is rather common, but I wonder if I shouldn't just change my name sometimes\u2026)\r\n\r\nTo Weston's question - I think that's the plan, to have datasets as just another note in the pipeline, and to move projection/filtering into the pipeline and out of the datasets code.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-03-16T21:39:32.360+0000",
                    "updated": "2021-03-16T21:39:32.360+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365513/comment/17400997",
                    "id": "17400997",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 10927\n[https://github.com/apache/arrow/pull/10927]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-08-18T12:04:15.172+0000",
                    "updated": "2021-08-18T12:04:15.172+0000"
                }
            ],
            "maxResults": 6,
            "total": 6,
            "startAt": 0
        },
        "customfield_12311820": "0|z0ou5c:",
        "customfield_12314139": null
    }
}