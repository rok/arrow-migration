{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13341864",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864",
    "key": "ARROW-10669",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345977",
                "id": "12345977",
                "description": "",
                "name": "2.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-10-19"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
            "name": "bkietz",
            "key": "bkietz",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
            },
            "displayName": "Ben Kietzman",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10669/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 16,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/514888",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz opened a new pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728\n\n\n   - \"and\", \"or\", \"xor\", \"and_kleene\", and \"or_kleene\" gain support for scalar arguments.\r\n   - Added new functions \"and_not\" and \"and_not_kleene\"\r\n   - repaired and simplified some null propagation logic\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-20T22:06:35.699+0000",
                    "updated": "2020-11-20T22:06:35.699+0000",
                    "started": "2020-11-20T22:06:35.699+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "514888",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/514897",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#issuecomment-731442083\n\n\n   https://issues.apache.org/jira/browse/ARROW-10669\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-20T22:35:11.636+0000",
                    "updated": "2020-11-20T22:35:11.636+0000",
                    "started": "2020-11-20T22:35:11.636+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "514897",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515379",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "cyb70289 commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528486641\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_scalar.h\n##########\n@@ -253,6 +253,33 @@ Result<Datum> KleeneOr(const Datum& left, const Datum& right, ExecContext* ctx =\n ARROW_EXPORT\n Result<Datum> Xor(const Datum& left, const Datum& right, ExecContext* ctx = NULLPTR);\n \n+/// \\brief Element-wise AND NOT of two boolean datums which always propagates nulls\n+/// (null and not true is null).\n+///\n+/// \\param[in] left left operand\n+/// \\param[in] right right operand\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 1.0.0\n\nReview comment:\n       3.0.0? or 2.0.0?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T06:11:04.527+0000",
                    "updated": "2020-11-23T06:11:04.527+0000",
                    "started": "2020-11-23T06:11:04.527+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515379",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515521",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528677163\n\n\n\n##########\nFile path: cpp/src/arrow/compute/api_scalar.h\n##########\n@@ -253,6 +253,33 @@ Result<Datum> KleeneOr(const Datum& left, const Datum& right, ExecContext* ctx =\n ARROW_EXPORT\n Result<Datum> Xor(const Datum& left, const Datum& right, ExecContext* ctx = NULLPTR);\n \n+/// \\brief Element-wise AND NOT of two boolean datums which always propagates nulls\n+/// (null and not true is null).\n+///\n+/// \\param[in] left left operand\n+/// \\param[in] right right operand\n+/// \\param[in] ctx the function execution context, optional\n+/// \\return the resulting datum\n+///\n+/// \\since 1.0.0\n\nReview comment:\n       Ah, thanks. Copy paste error\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T12:45:16.565+0000",
                    "updated": "2020-11-23T12:45:16.565+0000",
                    "started": "2020-11-23T12:45:16.565+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515521",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515558",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528714541\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec.cc\n##########\n@@ -213,20 +214,33 @@ bool ExecBatchIterator::Next(ExecBatch* batch) {\n \n namespace {\n \n-bool ArrayHasNulls(const ArrayData& data) {\n-  // As discovered in ARROW-8863 (and not only for that reason)\n-  // ArrayData::null_count can -1 even when buffers[0] is nullptr. So we check\n-  // for both cases (nullptr means no nulls, or null_count already computed)\n-  if (data.type->id() == Type::NA) {\n-    return true;\n-  } else if (data.buffers[0] == nullptr) {\n-    return false;\n-  } else {\n+struct NullGeneralization {\n+  enum type { NONE, ALL_VALID, ALL_NULL };\n\nReview comment:\n       Rather than \"NONE\", \"UNKNOWN\" (or \"PERHAPS_NULL\") sounds less confusing perhaps.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean_test.cc\n##########\n@@ -27,185 +27,114 @@\n #include \"arrow/compute/kernels/test_util.h\"\n #include \"arrow/testing/gtest_common.h\"\n #include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n \n namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n namespace compute {\n \n-using BinaryKernelFunc =\n-    std::function<Result<Datum>(const Datum&, const Datum&, ExecContext*)>;\n-\n-class TestBooleanKernel : public TestBase {\n- public:\n-  void TestArrayBinary(const BinaryKernelFunc& kernel, const std::shared_ptr<Array>& left,\n-                       const std::shared_ptr<Array>& right,\n-                       const std::shared_ptr<Array>& expected) {\n-    ASSERT_OK_AND_ASSIGN(Datum result, kernel(left, right, &ctx_));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    std::shared_ptr<Array> result_array = result.make_array();\n-    ASSERT_OK(result_array->ValidateFull());\n-    AssertArraysEqual(*expected, *result_array, /*verbose=*/true);\n-\n-    ASSERT_OK_AND_ASSIGN(result, kernel(right, left, &ctx_));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    result_array = result.make_array();\n-    ASSERT_OK(result_array->ValidateFull());\n-    AssertArraysEqual(*expected, *result_array, /*verbose=*/true);\n-  }\n+void CheckBooleanScalarArrayBinary(std::string func_name, Datum array) {\n+  for (std::shared_ptr<Scalar> scalar :\n+       {std::make_shared<BooleanScalar>(), std::make_shared<BooleanScalar>(true),\n+        std::make_shared<BooleanScalar>(false)}) {\n+    ASSERT_OK_AND_ASSIGN(Datum actual, CallFunction(func_name, {Datum(scalar), array}));\n \n-  void TestChunkedArrayBinary(const BinaryKernelFunc& kernel,\n-                              const std::shared_ptr<ChunkedArray>& left,\n-                              const std::shared_ptr<ChunkedArray>& right,\n-                              const std::shared_ptr<ChunkedArray>& expected) {\n-    ASSERT_OK_AND_ASSIGN(Datum result, kernel(left, right, &ctx_));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-    AssertChunkedEquivalent(*expected, *result_ca);\n-\n-    ASSERT_OK_AND_ASSIGN(result, kernel(right, left, &ctx_));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    result_ca = result.chunked_array();\n-    AssertChunkedEquivalent(*expected, *result_ca);\n-  }\n+    ASSERT_OK_AND_ASSIGN(auto constant_array,\n+                         MakeArrayFromScalar(*scalar, array.length()));\n \n-  void TestBinaryKernel(const BinaryKernelFunc& kernel,\n-                        const std::shared_ptr<Array>& left,\n-                        const std::shared_ptr<Array>& right,\n-                        const std::shared_ptr<Array>& expected) {\n-    TestArrayBinary(kernel, left, right, expected);\n-    TestArrayBinary(kernel, left->Slice(1), right->Slice(1), expected->Slice(1));\n-\n-    // ChunkedArray\n-    auto cleft = std::make_shared<ChunkedArray>(ArrayVector{left, left->Slice(1)});\n-    auto cright = std::make_shared<ChunkedArray>(ArrayVector{right, right->Slice(1)});\n-    auto cexpected =\n-        std::make_shared<ChunkedArray>(ArrayVector{expected, expected->Slice(1)});\n-    TestChunkedArrayBinary(kernel, cleft, cright, cexpected);\n-\n-    // ChunkedArray with different chunks\n-    cleft = std::make_shared<ChunkedArray>(ArrayVector{\n-        left->Slice(0, 1), left->Slice(1), left->Slice(1, 1), left->Slice(2)});\n-    TestChunkedArrayBinary(kernel, cleft, cright, cexpected);\n-  }\n+    ASSERT_OK_AND_ASSIGN(Datum expected,\n+                         CallFunction(func_name, {Datum(constant_array), array}));\n+    AssertDatumsEqual(expected, actual);\n \n-  void TestBinaryKernelPropagate(const BinaryKernelFunc& kernel,\n-                                 const std::vector<bool>& left,\n-                                 const std::vector<bool>& right,\n-                                 const std::vector<bool>& expected,\n-                                 const std::vector<bool>& expected_nulls) {\n-    auto type = boolean();\n-    TestBinaryKernel(kernel, _MakeArray<BooleanType, bool>(type, left, {}),\n-                     _MakeArray<BooleanType, bool>(type, right, {}),\n-                     _MakeArray<BooleanType, bool>(type, expected, {}));\n-\n-    TestBinaryKernel(kernel, _MakeArray<BooleanType, bool>(type, left, left),\n-                     _MakeArray<BooleanType, bool>(type, right, right),\n-                     _MakeArray<BooleanType, bool>(type, expected, expected_nulls));\n+    ASSERT_OK_AND_ASSIGN(actual, CallFunction(func_name, {array, Datum(scalar)}));\n+    ASSERT_OK_AND_ASSIGN(expected,\n+                         CallFunction(func_name, {array, Datum(constant_array)}));\n+    AssertDatumsEqual(expected, actual);\n   }\n-\n- protected:\n-  ExecContext ctx_;\n-};\n-\n-TEST_F(TestBooleanKernel, Invert) {\n-  std::vector<bool> values1 = {true, false, true, false};\n-  std::vector<bool> values2 = {false, true, false, true};\n-\n-  auto type = boolean();\n-  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {true, true, true, false});\n-  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {true, true, true, false});\n-\n-  // Plain array\n-  ASSERT_OK_AND_ASSIGN(Datum result, Invert(a1));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  ASSERT_ARRAYS_EQUAL(*a2, *result.make_array());\n-\n-  // Array with offset\n-  ASSERT_OK_AND_ASSIGN(result, Invert(a1->Slice(1)));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  ASSERT_ARRAYS_EQUAL(*a2->Slice(1), *result.make_array());\n-\n-  // ChunkedArray\n-  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n-  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n-  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n-  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n-  ASSERT_OK_AND_ASSIGN(result, Invert(ca1));\n-  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-\n-  // Contiguous preallocation, so a single output chunk even though there were\n-  // two input chunks\n-  ASSERT_EQ(1, result_ca->num_chunks());\n-  AssertChunkedEquivalent(*ca2, *result_ca);\n }\n \n-TEST_F(TestBooleanKernel, InvertEmptyArray) {\n-  std::vector<std::shared_ptr<Buffer>> data_buffers(2);\n-  Datum input;\n-  input.value = ArrayData::Make(boolean(), 0 /* length */, std::move(data_buffers),\n-                                0 /* null_count */);\n-\n-  ASSERT_OK_AND_ASSIGN(Datum result, Invert(input));\n-  ASSERT_ARRAYS_EQUAL(*input.make_array(), *result.make_array());\n+TEST(TestBooleanKernel, Invert) {\n+  auto arr =\n+      ArrayFromJSON(boolean(), \"[true, false, true, null, false, true, false, null]\");\n+  auto expected =\n+      ArrayFromJSON(boolean(), \"[false, true, false, null, true, false, true, null]\");\n+  CheckScalarUnary(\"invert\", arr, expected);\n }\n \n-TEST_F(TestBooleanKernel, BinaryOpOnEmptyArray) {\n-  auto type = boolean();\n-  std::vector<std::shared_ptr<Buffer>> data_buffers(2);\n-  Datum input;\n-  input.value = ArrayData::Make(boolean(), 0 /* length */, std::move(data_buffers),\n-                                0 /* null_count */);\n-\n-  ASSERT_OK_AND_ASSIGN(Datum result, And(input, input));\n-  // Result should be empty as well.\n-  ASSERT_ARRAYS_EQUAL(*input.make_array(), *result.make_array());\n+TEST(TestBooleanKernel, And) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[true, false, null, false, null,  null]\");\n+  // CheckScalarBinary(\"and\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and\", left);\n }\n \n-TEST_F(TestBooleanKernel, And) {\n-  std::vector<bool> values1 = {true, false, true, false, true, true};\n-  std::vector<bool> values2 = {true, true, false, false, true, false};\n-  std::vector<bool> values3 = {true, false, false, false, true, false};\n-  TestBinaryKernelPropagate(And, values1, values2, values3, values3);\n+TEST(TestBooleanKernel, Or) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[true, true,  null, false, null,  null]\");\n+  CheckScalarBinary(\"or\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"or\", left);\n }\n \n-TEST_F(TestBooleanKernel, Or) {\n-  std::vector<bool> values1 = {true, false, true, false, true, true};\n-  std::vector<bool> values2 = {true, true, false, false, true, false};\n-  std::vector<bool> values3 = {true, true, true, false, true, true};\n-  std::vector<bool> values3_nulls = {true, false, false, false, true, false};\n-  TestBinaryKernelPropagate(Or, values1, values2, values3, values3_nulls);\n+TEST(TestBooleanKernel, Xor) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true,  true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true,  false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[false, true,  null, false, null,  null]\");\n+  CheckScalarBinary(\"xor\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"xor\", left);\n }\n \n-TEST_F(TestBooleanKernel, Xor) {\n-  std::vector<bool> values1 = {true, false, true, false, true, true};\n-  std::vector<bool> values2 = {true, true, false, false, true, false};\n-  std::vector<bool> values3 = {false, true, true, false, false, true};\n-  std::vector<bool> values3_nulls = {true, false, false, false, true, false};\n-  TestBinaryKernelPropagate(Xor, values1, values2, values3, values3_nulls);\n+TEST(TestBooleanKernel, AndNot) {\n+  auto left = ArrayFromJSON(\n+      boolean(), \"[true,  true,  true, false, false, false, null, null,  null]\");\n+  auto right = ArrayFromJSON(\n+      boolean(), \"[true,  false, null, true,  false, null,  true, false, null]\");\n+  auto expected = ArrayFromJSON(\n+      boolean(), \"[false, true,  null, false, false, null,  null, null,  null]\");\n+  CheckScalarBinary(\"and_not\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and_not\", left);\n }\n \n-TEST_F(TestBooleanKernel, KleeneAnd) {\n+TEST(TestBooleanKernel, KleeneAnd) {\n   auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n   auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n   auto expected = ArrayFromJSON(boolean(), \"[true, false, null, false, false, null]\");\n-  TestBinaryKernel(KleeneAnd, left, right, expected);\n+  CheckScalarBinary(\"and_kleene\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and_kleene\", left);\n \n   left = ArrayFromJSON(boolean(), \"    [true, true,  false, null, null]\");\n   right = ArrayFromJSON(boolean(), \"   [true, false, false, true, false]\");\n   expected = ArrayFromJSON(boolean(), \"[true, false, false, null, false]\");\n-  TestBinaryKernel(KleeneAnd, left, right, expected);\n+  CheckScalarBinary(\"and_kleene\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and_kleene\", left);\n\nReview comment:\n       Are you running almost the same tests twice here?\n\n##########\nFile path: cpp/src/arrow/compute/exec.cc\n##########\n@@ -272,79 +287,61 @@ class NullPropagator {\n     return Status::OK();\n   }\n \n-  Result<bool> ShortCircuitIfAllNull() {\n-    // An all-null value (scalar null or all-null array) gives us a short\n-    // circuit opportunity\n-    bool is_all_null = false;\n-    std::shared_ptr<Buffer> all_null_bitmap;\n+  Status AllNullShortCircuit() {\n+    // OK, the output should be all null\n+    output_->null_count = output_->length;\n+\n+    if (bitmap_preallocated_) {\n+      BitUtil::SetBitsTo(bitmap_, output_->offset, output_->length, false);\n+      return Status::OK();\n+    }\n \n     // Walk all the values with nulls instead of breaking on the first in case\n     // we find a bitmap that can be reused in the non-preallocated case\n-    for (const Datum* value : values_with_nulls_) {\n-      if (value->type()->id() == Type::NA) {\n-        // No bitmap\n-        is_all_null = true;\n-      } else if (value->kind() == Datum::ARRAY) {\n-        const ArrayData& arr = *value->array();\n-        if (arr.null_count.load() == arr.length) {\n-          // Pluck the all null bitmap so we can set it in the output if it was\n-          // not pre-allocated\n-          all_null_bitmap = arr.buffers[0];\n-          is_all_null = true;\n-        }\n-      } else {\n-        // Scalar\n-        is_all_null = !value->scalar()->is_valid;\n+    for (const ArrayData* arr : arrays_with_nulls_) {\n+      if (arr->null_count.load() == arr->length && arr->buffers[0] != nullptr) {\n+        // Reuse this all null bitmap\n+        output_->buffers[0] = arr->buffers[0];\n+        return Status::OK();\n       }\n     }\n-    if (!is_all_null) {\n-      return false;\n-    }\n \n-    // OK, the output should be all null\n-    output_->null_count = output_->length;\n-\n-    if (!bitmap_preallocated_ && all_null_bitmap) {\n-      // If we did not pre-allocate memory, and we observed an all-null bitmap,\n-      // then we can zero-copy it into the output\n-      output_->buffers[0] = std::move(all_null_bitmap);\n-    } else {\n-      RETURN_NOT_OK(EnsureAllocated());\n-      BitUtil::SetBitsTo(bitmap_, output_->offset, output_->length, false);\n-    }\n-    return true;\n+    RETURN_NOT_OK(EnsureAllocated());\n+    BitUtil::SetBitsTo(bitmap_, output_->offset, output_->length, false);\n+    return Status::OK();\n   }\n \n   Status PropagateSingle() {\n     // One array\n-    const ArrayData& arr = *values_with_nulls_[0]->array();\n+    const ArrayData& arr = *arrays_with_nulls_[0];\n     const std::shared_ptr<Buffer>& arr_bitmap = arr.buffers[0];\n \n     // Reuse the null count if it's known\n     output_->null_count = arr.null_count.load();\n \n     if (bitmap_preallocated_) {\n       CopyBitmap(arr_bitmap->data(), arr.offset, arr.length, bitmap_, output_->offset);\n+      return Status::OK();\n+    }\n+\n+    // Two cases when memory was not pre-allocated:\n+    //\n+    // * Offset is zero: we reuse the bitmap as is\n+    // * Offset is nonzero but a multiple of 8: we can slice the bitmap\n+    // * Offset is not a multiple of 8: we must allocate and use CopyBitmap\n+    //\n+    // Keep in mind that output_->offset is not permitted to be nonzero when\n+    // the bitmap is not preallocated, and that precondition is asserted\n+    // higher in the call stack.\n+    if (arr.offset == 0) {\n+      output_->buffers[0] = arr_bitmap;\n+    } else if (arr.offset % 8 == 0) {\n+      output_->buffers[0] =\n+          SliceBuffer(arr_bitmap, arr.offset / 8, BitUtil::BytesForBits(arr.length));\n\nReview comment:\n       Would it be useful to add a `SliceBitmap` helper to `bitmap_ops.h`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/codegen_internal.h\n##########\n@@ -427,12 +427,28 @@ void SimpleUnary(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n //\n // static void Call(KernelContext*, const ArrayData& arg0, const ArrayData& arg1,\n //                  ArrayData* out)\n+// static void Call(KernelContext*, const ArrayData& arg0, const Scalar& arg1,\n+//                  ArrayData* out)\n+// static void Call(KernelContext*, const Scalar& arg0, const ArrayData& arg1,\n+//                  ArrayData* out)\n+// static void Call(KernelContext*, const Scalar& arg0, const Scalar& arg1,\n+//                  Scalar* out)\n\nReview comment:\n       Mention that heterogenous implementation ((scalar, array) and (array, scalar)) must broadcast the scalar value?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean_test.cc\n##########\n@@ -27,185 +27,114 @@\n #include \"arrow/compute/kernels/test_util.h\"\n #include \"arrow/testing/gtest_common.h\"\n #include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n \n namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n namespace compute {\n \n-using BinaryKernelFunc =\n-    std::function<Result<Datum>(const Datum&, const Datum&, ExecContext*)>;\n-\n-class TestBooleanKernel : public TestBase {\n- public:\n-  void TestArrayBinary(const BinaryKernelFunc& kernel, const std::shared_ptr<Array>& left,\n-                       const std::shared_ptr<Array>& right,\n-                       const std::shared_ptr<Array>& expected) {\n-    ASSERT_OK_AND_ASSIGN(Datum result, kernel(left, right, &ctx_));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    std::shared_ptr<Array> result_array = result.make_array();\n-    ASSERT_OK(result_array->ValidateFull());\n-    AssertArraysEqual(*expected, *result_array, /*verbose=*/true);\n-\n-    ASSERT_OK_AND_ASSIGN(result, kernel(right, left, &ctx_));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    result_array = result.make_array();\n-    ASSERT_OK(result_array->ValidateFull());\n-    AssertArraysEqual(*expected, *result_array, /*verbose=*/true);\n-  }\n+void CheckBooleanScalarArrayBinary(std::string func_name, Datum array) {\n+  for (std::shared_ptr<Scalar> scalar :\n+       {std::make_shared<BooleanScalar>(), std::make_shared<BooleanScalar>(true),\n+        std::make_shared<BooleanScalar>(false)}) {\n+    ASSERT_OK_AND_ASSIGN(Datum actual, CallFunction(func_name, {Datum(scalar), array}));\n \n-  void TestChunkedArrayBinary(const BinaryKernelFunc& kernel,\n-                              const std::shared_ptr<ChunkedArray>& left,\n-                              const std::shared_ptr<ChunkedArray>& right,\n-                              const std::shared_ptr<ChunkedArray>& expected) {\n-    ASSERT_OK_AND_ASSIGN(Datum result, kernel(left, right, &ctx_));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-    AssertChunkedEquivalent(*expected, *result_ca);\n-\n-    ASSERT_OK_AND_ASSIGN(result, kernel(right, left, &ctx_));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    result_ca = result.chunked_array();\n-    AssertChunkedEquivalent(*expected, *result_ca);\n-  }\n+    ASSERT_OK_AND_ASSIGN(auto constant_array,\n+                         MakeArrayFromScalar(*scalar, array.length()));\n \n-  void TestBinaryKernel(const BinaryKernelFunc& kernel,\n-                        const std::shared_ptr<Array>& left,\n-                        const std::shared_ptr<Array>& right,\n-                        const std::shared_ptr<Array>& expected) {\n-    TestArrayBinary(kernel, left, right, expected);\n-    TestArrayBinary(kernel, left->Slice(1), right->Slice(1), expected->Slice(1));\n-\n-    // ChunkedArray\n-    auto cleft = std::make_shared<ChunkedArray>(ArrayVector{left, left->Slice(1)});\n-    auto cright = std::make_shared<ChunkedArray>(ArrayVector{right, right->Slice(1)});\n-    auto cexpected =\n-        std::make_shared<ChunkedArray>(ArrayVector{expected, expected->Slice(1)});\n-    TestChunkedArrayBinary(kernel, cleft, cright, cexpected);\n-\n-    // ChunkedArray with different chunks\n-    cleft = std::make_shared<ChunkedArray>(ArrayVector{\n-        left->Slice(0, 1), left->Slice(1), left->Slice(1, 1), left->Slice(2)});\n-    TestChunkedArrayBinary(kernel, cleft, cright, cexpected);\n-  }\n+    ASSERT_OK_AND_ASSIGN(Datum expected,\n+                         CallFunction(func_name, {Datum(constant_array), array}));\n+    AssertDatumsEqual(expected, actual);\n \n-  void TestBinaryKernelPropagate(const BinaryKernelFunc& kernel,\n-                                 const std::vector<bool>& left,\n-                                 const std::vector<bool>& right,\n-                                 const std::vector<bool>& expected,\n-                                 const std::vector<bool>& expected_nulls) {\n-    auto type = boolean();\n-    TestBinaryKernel(kernel, _MakeArray<BooleanType, bool>(type, left, {}),\n-                     _MakeArray<BooleanType, bool>(type, right, {}),\n-                     _MakeArray<BooleanType, bool>(type, expected, {}));\n-\n-    TestBinaryKernel(kernel, _MakeArray<BooleanType, bool>(type, left, left),\n-                     _MakeArray<BooleanType, bool>(type, right, right),\n-                     _MakeArray<BooleanType, bool>(type, expected, expected_nulls));\n+    ASSERT_OK_AND_ASSIGN(actual, CallFunction(func_name, {array, Datum(scalar)}));\n+    ASSERT_OK_AND_ASSIGN(expected,\n+                         CallFunction(func_name, {array, Datum(constant_array)}));\n+    AssertDatumsEqual(expected, actual);\n   }\n-\n- protected:\n-  ExecContext ctx_;\n-};\n-\n-TEST_F(TestBooleanKernel, Invert) {\n-  std::vector<bool> values1 = {true, false, true, false};\n-  std::vector<bool> values2 = {false, true, false, true};\n-\n-  auto type = boolean();\n-  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {true, true, true, false});\n-  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {true, true, true, false});\n-\n-  // Plain array\n-  ASSERT_OK_AND_ASSIGN(Datum result, Invert(a1));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  ASSERT_ARRAYS_EQUAL(*a2, *result.make_array());\n-\n-  // Array with offset\n-  ASSERT_OK_AND_ASSIGN(result, Invert(a1->Slice(1)));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  ASSERT_ARRAYS_EQUAL(*a2->Slice(1), *result.make_array());\n-\n-  // ChunkedArray\n-  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n-  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n-  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n-  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n-  ASSERT_OK_AND_ASSIGN(result, Invert(ca1));\n-  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-\n-  // Contiguous preallocation, so a single output chunk even though there were\n-  // two input chunks\n-  ASSERT_EQ(1, result_ca->num_chunks());\n-  AssertChunkedEquivalent(*ca2, *result_ca);\n }\n \n-TEST_F(TestBooleanKernel, InvertEmptyArray) {\n-  std::vector<std::shared_ptr<Buffer>> data_buffers(2);\n-  Datum input;\n-  input.value = ArrayData::Make(boolean(), 0 /* length */, std::move(data_buffers),\n-                                0 /* null_count */);\n-\n-  ASSERT_OK_AND_ASSIGN(Datum result, Invert(input));\n-  ASSERT_ARRAYS_EQUAL(*input.make_array(), *result.make_array());\n+TEST(TestBooleanKernel, Invert) {\n+  auto arr =\n+      ArrayFromJSON(boolean(), \"[true, false, true, null, false, true, false, null]\");\n+  auto expected =\n+      ArrayFromJSON(boolean(), \"[false, true, false, null, true, false, true, null]\");\n+  CheckScalarUnary(\"invert\", arr, expected);\n }\n \n-TEST_F(TestBooleanKernel, BinaryOpOnEmptyArray) {\n-  auto type = boolean();\n-  std::vector<std::shared_ptr<Buffer>> data_buffers(2);\n-  Datum input;\n-  input.value = ArrayData::Make(boolean(), 0 /* length */, std::move(data_buffers),\n-                                0 /* null_count */);\n-\n-  ASSERT_OK_AND_ASSIGN(Datum result, And(input, input));\n-  // Result should be empty as well.\n-  ASSERT_ARRAYS_EQUAL(*input.make_array(), *result.make_array());\n+TEST(TestBooleanKernel, And) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[true, false, null, false, null,  null]\");\n+  // CheckScalarBinary(\"and\", left, right, expected);\n\nReview comment:\n       Is there a reason this is commented out?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean.cc\n##########\n@@ -61,40 +59,78 @@ void ComputeKleene(ComputeWord&& compute_word, KernelContext* ctx, const ArrayDa\n     ++i;\n   };\n \n-  if (right.null_count == 0 || left.null_count == 0) {\n-    if (left.null_count == 0) {\n-      // ensure only bitmaps[RIGHT_VALID].buffer might be null\n-      std::swap(bitmaps[LEFT_VALID], bitmaps[RIGHT_VALID]);\n-      std::swap(bitmaps[LEFT_DATA], bitmaps[RIGHT_DATA]);\n-    }\n-    // override bitmaps[RIGHT_VALID] to make it safe for Visit()\n+  if (right.null_count == 0) {\n+    // bitmaps[RIGHT_VALID] might be null; override to make it safe for Visit()\n     bitmaps[RIGHT_VALID] = bitmaps[RIGHT_DATA];\n-\n     Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n       apply(words[LEFT_VALID], words[LEFT_DATA], ~uint64_t(0), words[RIGHT_DATA]);\n     });\n-  } else {\n+    return;\n+  }\n+\n+  if (left.null_count == 0) {\n+    // bitmaps[LEFT_VALID] might be null; override to make it safe for Visit()\n+    bitmaps[LEFT_VALID] = bitmaps[LEFT_DATA];\n     Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n-      apply(words[LEFT_VALID], words[LEFT_DATA], words[RIGHT_VALID], words[RIGHT_DATA]);\n+      apply(~uint64_t(0), words[LEFT_DATA], words[RIGHT_VALID], words[RIGHT_DATA]);\n     });\n+    return;\n   }\n+\n+  DCHECK(left.null_count != 0 || right.null_count != 0);\n+  Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+    apply(words[LEFT_VALID], words[LEFT_DATA], words[RIGHT_VALID], words[RIGHT_DATA]);\n+  });\n+}\n+\n+inline BooleanScalar InvertScalar(const Scalar& in) {\n+  return in.is_valid ? BooleanScalar(!checked_cast<const BooleanScalar&>(in).value)\n+                     : BooleanScalar();\n+}\n+\n+inline Bitmap GetBitmap(const ArrayData& arr, int index) {\n+  return Bitmap{arr.buffers[index], arr.offset, arr.length};\n }\n \n struct Invert {\n   static void Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n-    if (in.is_valid) {\n-      checked_cast<BooleanScalar*>(out)->value =\n-          !checked_cast<const BooleanScalar&>(in).value;\n-    }\n+    *checked_cast<BooleanScalar*>(out) = InvertScalar(in);\n   }\n \n   static void Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n-    ::arrow::internal::InvertBitmap(in.buffers[1]->data(), in.offset, in.length,\n-                                    out->buffers[1]->mutable_data(), out->offset);\n+    GetBitmap(*out, 1).CopyFromInverted(GetBitmap(in, 1));\n   }\n };\n \n-struct And {\n+template <typename Op>\n+struct Commutative {\n+  static void Call(KernelContext* ctx, const Scalar& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    Op::Call(ctx, right, left, out);\n+  }\n+};\n+\n+struct And : Commutative<And> {\n+  using Commutative<And>::Call;\n+\n+  static void Call(KernelContext* ctx, const Scalar& left, const Scalar& right,\n+                   Scalar* out) {\n+    if (left.is_valid && right.is_valid) {\n+      checked_cast<BooleanScalar*>(out)->value =\n+          checked_cast<const BooleanScalar&>(left).value &&\n+          checked_cast<const BooleanScalar&>(right).value;\n+    }\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const Scalar& right,\n+                   ArrayData* out) {\n+    if (!right.is_valid) return;  // all null case\n+\n+    return checked_cast<const BooleanScalar&>(right).value\n+               ? GetBitmap(*out, 1).CopyFrom(GetBitmap(left, 1))\n\nReview comment:\n       Hmm... Perhaps we can avoid a copy in most cases and just re-use the bitmap buffer?\r\n   (do we need a `BitmapSliceOrCopy` helper?)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean.cc\n##########\n@@ -156,14 +307,94 @@ struct Xor {\n   }\n };\n \n+struct AndNot {\n+  static void Call(KernelContext* ctx, const Scalar& left, const Scalar& right,\n+                   Scalar* out) {\n+    And::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const Scalar& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    if (!left.is_valid) return;  // all null case\n+\n+    return checked_cast<const BooleanScalar&>(left).value\n+               ? GetBitmap(*out, 1).CopyFromInverted(GetBitmap(right, 1))\n+               : GetBitmap(*out, 1).SetBitsTo(false);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const Scalar& right,\n+                   ArrayData* out) {\n+    And::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    ::arrow::internal::BitmapAndNot(left.buffers[1]->data(), left.offset,\n+                                    right.buffers[1]->data(), right.offset, right.length,\n+                                    out->offset, out->buffers[1]->mutable_data());\n+  }\n+};\n+\n+struct KleeneAndNot {\n+  static void Call(KernelContext* ctx, const Scalar& left, const Scalar& right,\n+                   Scalar* out) {\n+    KleeneAnd::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const Scalar& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    bool left_true = left.is_valid && checked_cast<const BooleanScalar&>(left).value;\n+    bool left_false = left.is_valid && !checked_cast<const BooleanScalar&>(left).value;\n+\n+    if (left_false) {\n+      return GetBitmap(*out, 0).SetBitsTo(true),\n+             GetBitmap(*out, 1).SetBitsTo(false);  // all false case\n+    }\n+\n+    if (left_true) {\n+      return GetBitmap(*out, 0).CopyFrom(GetBitmap(right, 0)),\n+             GetBitmap(*out, 1).CopyFromInverted(GetBitmap(right, 1));\n+    }\n+\n+    // scalar was null: out[i] is valid iff right[i] was true\n+    ::arrow::internal::BitmapAnd(right.buffers[0]->data(), right.offset,\n+                                 right.buffers[1]->data(), right.offset, right.length,\n+                                 out->offset, out->buffers[0]->mutable_data());\n+    ::arrow::internal::InvertBitmap(right.buffers[1]->data(), right.offset, right.length,\n+                                    out->buffers[1]->mutable_data(), out->offset);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const Scalar& right,\n+                   ArrayData* out) {\n+    KleeneAnd::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    if (left.GetNullCount() == 0 && right.GetNullCount() == 0) {\n+      GetBitmap(*out, 0).SetBitsTo(true);\n+      return AndNot::Call(ctx, left, right, out);\n+    }\n+\n+    static auto compute_word = [](uint64_t left_true, uint64_t left_false,\n+                                  uint64_t right_true, uint64_t right_false,\n+                                  uint64_t* out_valid, uint64_t* out_data) {\n+      *out_data = left_true & right_false;\n+      *out_valid = left_false | right_true | (left_true & right_false);\n\nReview comment:\n       I would expect `~right_false` to be involved here. Am I missing something? Otherwise, the tests should also be expanded to exercise this code path.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean.cc\n##########\n@@ -129,13 +222,51 @@ struct Or {\n   }\n };\n \n-struct KleeneOr {\n+struct KleeneOr : Commutative<KleeneOr> {\n+  using Commutative<KleeneOr>::Call;\n+\n+  static void Call(KernelContext* ctx, const Scalar& left, const Scalar& right,\n+                   Scalar* out) {\n+    bool left_true = left.is_valid && checked_cast<const BooleanScalar&>(left).value;\n+    bool left_false = left.is_valid && !checked_cast<const BooleanScalar&>(left).value;\n+\n+    bool right_true = right.is_valid && checked_cast<const BooleanScalar&>(right).value;\n+    bool right_false = right.is_valid && !checked_cast<const BooleanScalar&>(right).value;\n+\n+    checked_cast<BooleanScalar*>(out)->value = left_true || right_true;\n+    out->is_valid = left_true || right_true || (left_false && right_false);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const Scalar& right,\n+                   ArrayData* out) {\n+    bool right_true = right.is_valid && checked_cast<const BooleanScalar&>(right).value;\n+    bool right_false = right.is_valid && !checked_cast<const BooleanScalar&>(right).value;\n+\n+    if (right_true) {\n+      return GetBitmap(*out, 0).SetBitsTo(true),\n+             GetBitmap(*out, 1).SetBitsTo(true);  // all true case\n+    }\n+\n+    if (right_false) {\n+      return GetBitmap(*out, 0).CopyFrom(GetBitmap(left, 0)),\n+             GetBitmap(*out, 1).CopyFrom(GetBitmap(left, 1));\n+    }\n+\n+    // scalar was null: out[i] is valid iff left[i] was true\n+    ::arrow::internal::BitmapAnd(left.buffers[0]->data(), left.offset,\n+                                 left.buffers[1]->data(), left.offset, left.length,\n+                                 out->offset, out->buffers[0]->mutable_data());\n+    ::arrow::internal::CopyBitmap(left.buffers[1]->data(), left.offset, left.length,\n+                                  out->buffers[1]->mutable_data(), out->offset);\n+  }\n+\n   static void Call(KernelContext* ctx, const ArrayData& left, const ArrayData& right,\n                    ArrayData* out) {\n     if (left.GetNullCount() == 0 && right.GetNullCount() == 0) {\n-      BitUtil::SetBitsTo(out->buffers[0]->mutable_data(), out->offset, out->length, true);\n+      GetBitmap(*out, 0).SetBitsTo(true);\n\nReview comment:\n       Should you make the same change in `KleeneAnd::Call(KernelContext*, const ArrayData&, const ArrayData&, ArrayData*)`?\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean.cc\n##########\n@@ -61,40 +59,78 @@ void ComputeKleene(ComputeWord&& compute_word, KernelContext* ctx, const ArrayDa\n     ++i;\n   };\n \n-  if (right.null_count == 0 || left.null_count == 0) {\n-    if (left.null_count == 0) {\n-      // ensure only bitmaps[RIGHT_VALID].buffer might be null\n-      std::swap(bitmaps[LEFT_VALID], bitmaps[RIGHT_VALID]);\n-      std::swap(bitmaps[LEFT_DATA], bitmaps[RIGHT_DATA]);\n-    }\n-    // override bitmaps[RIGHT_VALID] to make it safe for Visit()\n+  if (right.null_count == 0) {\n+    // bitmaps[RIGHT_VALID] might be null; override to make it safe for Visit()\n     bitmaps[RIGHT_VALID] = bitmaps[RIGHT_DATA];\n-\n     Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n       apply(words[LEFT_VALID], words[LEFT_DATA], ~uint64_t(0), words[RIGHT_DATA]);\n     });\n-  } else {\n+    return;\n+  }\n+\n+  if (left.null_count == 0) {\n+    // bitmaps[LEFT_VALID] might be null; override to make it safe for Visit()\n+    bitmaps[LEFT_VALID] = bitmaps[LEFT_DATA];\n     Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n-      apply(words[LEFT_VALID], words[LEFT_DATA], words[RIGHT_VALID], words[RIGHT_DATA]);\n+      apply(~uint64_t(0), words[LEFT_DATA], words[RIGHT_VALID], words[RIGHT_DATA]);\n     });\n+    return;\n   }\n+\n+  DCHECK(left.null_count != 0 || right.null_count != 0);\n\nReview comment:\n       You mean `&&`?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T14:15:26.869+0000",
                    "updated": "2020-11-23T14:15:26.869+0000",
                    "started": "2020-11-23T14:15:26.869+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515558",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515584",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528766456\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean_test.cc\n##########\n@@ -27,185 +27,114 @@\n #include \"arrow/compute/kernels/test_util.h\"\n #include \"arrow/testing/gtest_common.h\"\n #include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n \n namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n namespace compute {\n \n-using BinaryKernelFunc =\n-    std::function<Result<Datum>(const Datum&, const Datum&, ExecContext*)>;\n-\n-class TestBooleanKernel : public TestBase {\n- public:\n-  void TestArrayBinary(const BinaryKernelFunc& kernel, const std::shared_ptr<Array>& left,\n-                       const std::shared_ptr<Array>& right,\n-                       const std::shared_ptr<Array>& expected) {\n-    ASSERT_OK_AND_ASSIGN(Datum result, kernel(left, right, &ctx_));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    std::shared_ptr<Array> result_array = result.make_array();\n-    ASSERT_OK(result_array->ValidateFull());\n-    AssertArraysEqual(*expected, *result_array, /*verbose=*/true);\n-\n-    ASSERT_OK_AND_ASSIGN(result, kernel(right, left, &ctx_));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    result_array = result.make_array();\n-    ASSERT_OK(result_array->ValidateFull());\n-    AssertArraysEqual(*expected, *result_array, /*verbose=*/true);\n-  }\n+void CheckBooleanScalarArrayBinary(std::string func_name, Datum array) {\n+  for (std::shared_ptr<Scalar> scalar :\n+       {std::make_shared<BooleanScalar>(), std::make_shared<BooleanScalar>(true),\n+        std::make_shared<BooleanScalar>(false)}) {\n+    ASSERT_OK_AND_ASSIGN(Datum actual, CallFunction(func_name, {Datum(scalar), array}));\n \n-  void TestChunkedArrayBinary(const BinaryKernelFunc& kernel,\n-                              const std::shared_ptr<ChunkedArray>& left,\n-                              const std::shared_ptr<ChunkedArray>& right,\n-                              const std::shared_ptr<ChunkedArray>& expected) {\n-    ASSERT_OK_AND_ASSIGN(Datum result, kernel(left, right, &ctx_));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-    AssertChunkedEquivalent(*expected, *result_ca);\n-\n-    ASSERT_OK_AND_ASSIGN(result, kernel(right, left, &ctx_));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    result_ca = result.chunked_array();\n-    AssertChunkedEquivalent(*expected, *result_ca);\n-  }\n+    ASSERT_OK_AND_ASSIGN(auto constant_array,\n+                         MakeArrayFromScalar(*scalar, array.length()));\n \n-  void TestBinaryKernel(const BinaryKernelFunc& kernel,\n-                        const std::shared_ptr<Array>& left,\n-                        const std::shared_ptr<Array>& right,\n-                        const std::shared_ptr<Array>& expected) {\n-    TestArrayBinary(kernel, left, right, expected);\n-    TestArrayBinary(kernel, left->Slice(1), right->Slice(1), expected->Slice(1));\n-\n-    // ChunkedArray\n-    auto cleft = std::make_shared<ChunkedArray>(ArrayVector{left, left->Slice(1)});\n-    auto cright = std::make_shared<ChunkedArray>(ArrayVector{right, right->Slice(1)});\n-    auto cexpected =\n-        std::make_shared<ChunkedArray>(ArrayVector{expected, expected->Slice(1)});\n-    TestChunkedArrayBinary(kernel, cleft, cright, cexpected);\n-\n-    // ChunkedArray with different chunks\n-    cleft = std::make_shared<ChunkedArray>(ArrayVector{\n-        left->Slice(0, 1), left->Slice(1), left->Slice(1, 1), left->Slice(2)});\n-    TestChunkedArrayBinary(kernel, cleft, cright, cexpected);\n-  }\n+    ASSERT_OK_AND_ASSIGN(Datum expected,\n+                         CallFunction(func_name, {Datum(constant_array), array}));\n+    AssertDatumsEqual(expected, actual);\n \n-  void TestBinaryKernelPropagate(const BinaryKernelFunc& kernel,\n-                                 const std::vector<bool>& left,\n-                                 const std::vector<bool>& right,\n-                                 const std::vector<bool>& expected,\n-                                 const std::vector<bool>& expected_nulls) {\n-    auto type = boolean();\n-    TestBinaryKernel(kernel, _MakeArray<BooleanType, bool>(type, left, {}),\n-                     _MakeArray<BooleanType, bool>(type, right, {}),\n-                     _MakeArray<BooleanType, bool>(type, expected, {}));\n-\n-    TestBinaryKernel(kernel, _MakeArray<BooleanType, bool>(type, left, left),\n-                     _MakeArray<BooleanType, bool>(type, right, right),\n-                     _MakeArray<BooleanType, bool>(type, expected, expected_nulls));\n+    ASSERT_OK_AND_ASSIGN(actual, CallFunction(func_name, {array, Datum(scalar)}));\n+    ASSERT_OK_AND_ASSIGN(expected,\n+                         CallFunction(func_name, {array, Datum(constant_array)}));\n+    AssertDatumsEqual(expected, actual);\n   }\n-\n- protected:\n-  ExecContext ctx_;\n-};\n-\n-TEST_F(TestBooleanKernel, Invert) {\n-  std::vector<bool> values1 = {true, false, true, false};\n-  std::vector<bool> values2 = {false, true, false, true};\n-\n-  auto type = boolean();\n-  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {true, true, true, false});\n-  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {true, true, true, false});\n-\n-  // Plain array\n-  ASSERT_OK_AND_ASSIGN(Datum result, Invert(a1));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  ASSERT_ARRAYS_EQUAL(*a2, *result.make_array());\n-\n-  // Array with offset\n-  ASSERT_OK_AND_ASSIGN(result, Invert(a1->Slice(1)));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  ASSERT_ARRAYS_EQUAL(*a2->Slice(1), *result.make_array());\n-\n-  // ChunkedArray\n-  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n-  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n-  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n-  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n-  ASSERT_OK_AND_ASSIGN(result, Invert(ca1));\n-  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-\n-  // Contiguous preallocation, so a single output chunk even though there were\n-  // two input chunks\n-  ASSERT_EQ(1, result_ca->num_chunks());\n-  AssertChunkedEquivalent(*ca2, *result_ca);\n }\n \n-TEST_F(TestBooleanKernel, InvertEmptyArray) {\n-  std::vector<std::shared_ptr<Buffer>> data_buffers(2);\n-  Datum input;\n-  input.value = ArrayData::Make(boolean(), 0 /* length */, std::move(data_buffers),\n-                                0 /* null_count */);\n-\n-  ASSERT_OK_AND_ASSIGN(Datum result, Invert(input));\n-  ASSERT_ARRAYS_EQUAL(*input.make_array(), *result.make_array());\n+TEST(TestBooleanKernel, Invert) {\n+  auto arr =\n+      ArrayFromJSON(boolean(), \"[true, false, true, null, false, true, false, null]\");\n+  auto expected =\n+      ArrayFromJSON(boolean(), \"[false, true, false, null, true, false, true, null]\");\n+  CheckScalarUnary(\"invert\", arr, expected);\n }\n \n-TEST_F(TestBooleanKernel, BinaryOpOnEmptyArray) {\n-  auto type = boolean();\n-  std::vector<std::shared_ptr<Buffer>> data_buffers(2);\n-  Datum input;\n-  input.value = ArrayData::Make(boolean(), 0 /* length */, std::move(data_buffers),\n-                                0 /* null_count */);\n-\n-  ASSERT_OK_AND_ASSIGN(Datum result, And(input, input));\n-  // Result should be empty as well.\n-  ASSERT_ARRAYS_EQUAL(*input.make_array(), *result.make_array());\n+TEST(TestBooleanKernel, And) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[true, false, null, false, null,  null]\");\n+  // CheckScalarBinary(\"and\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and\", left);\n }\n \n-TEST_F(TestBooleanKernel, And) {\n-  std::vector<bool> values1 = {true, false, true, false, true, true};\n-  std::vector<bool> values2 = {true, true, false, false, true, false};\n-  std::vector<bool> values3 = {true, false, false, false, true, false};\n-  TestBinaryKernelPropagate(And, values1, values2, values3, values3);\n+TEST(TestBooleanKernel, Or) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[true, true,  null, false, null,  null]\");\n+  CheckScalarBinary(\"or\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"or\", left);\n }\n \n-TEST_F(TestBooleanKernel, Or) {\n-  std::vector<bool> values1 = {true, false, true, false, true, true};\n-  std::vector<bool> values2 = {true, true, false, false, true, false};\n-  std::vector<bool> values3 = {true, true, true, false, true, true};\n-  std::vector<bool> values3_nulls = {true, false, false, false, true, false};\n-  TestBinaryKernelPropagate(Or, values1, values2, values3, values3_nulls);\n+TEST(TestBooleanKernel, Xor) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true,  true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true,  false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[false, true,  null, false, null,  null]\");\n+  CheckScalarBinary(\"xor\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"xor\", left);\n }\n \n-TEST_F(TestBooleanKernel, Xor) {\n-  std::vector<bool> values1 = {true, false, true, false, true, true};\n-  std::vector<bool> values2 = {true, true, false, false, true, false};\n-  std::vector<bool> values3 = {false, true, true, false, false, true};\n-  std::vector<bool> values3_nulls = {true, false, false, false, true, false};\n-  TestBinaryKernelPropagate(Xor, values1, values2, values3, values3_nulls);\n+TEST(TestBooleanKernel, AndNot) {\n+  auto left = ArrayFromJSON(\n+      boolean(), \"[true,  true,  true, false, false, false, null, null,  null]\");\n+  auto right = ArrayFromJSON(\n+      boolean(), \"[true,  false, null, true,  false, null,  true, false, null]\");\n+  auto expected = ArrayFromJSON(\n+      boolean(), \"[false, true,  null, false, false, null,  null, null,  null]\");\n+  CheckScalarBinary(\"and_not\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and_not\", left);\n }\n \n-TEST_F(TestBooleanKernel, KleeneAnd) {\n+TEST(TestBooleanKernel, KleeneAnd) {\n   auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n   auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n   auto expected = ArrayFromJSON(boolean(), \"[true, false, null, false, false, null]\");\n-  TestBinaryKernel(KleeneAnd, left, right, expected);\n+  CheckScalarBinary(\"and_kleene\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and_kleene\", left);\n \n   left = ArrayFromJSON(boolean(), \"    [true, true,  false, null, null]\");\n   right = ArrayFromJSON(boolean(), \"   [true, false, false, true, false]\");\n   expected = ArrayFromJSON(boolean(), \"[true, false, false, null, false]\");\n-  TestBinaryKernel(KleeneAnd, left, right, expected);\n+  CheckScalarBinary(\"and_kleene\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and_kleene\", left);\n\nReview comment:\n       No, the second tests exclusively `array, scalar` and `scalar, array` which isn't covered by CheckScalarBinary\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T15:02:17.928+0000",
                    "updated": "2020-11-23T15:02:17.928+0000",
                    "started": "2020-11-23T15:02:17.927+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515584",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515585",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528767005\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean_test.cc\n##########\n@@ -27,185 +27,114 @@\n #include \"arrow/compute/kernels/test_util.h\"\n #include \"arrow/testing/gtest_common.h\"\n #include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n \n namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n namespace compute {\n \n-using BinaryKernelFunc =\n-    std::function<Result<Datum>(const Datum&, const Datum&, ExecContext*)>;\n-\n-class TestBooleanKernel : public TestBase {\n- public:\n-  void TestArrayBinary(const BinaryKernelFunc& kernel, const std::shared_ptr<Array>& left,\n-                       const std::shared_ptr<Array>& right,\n-                       const std::shared_ptr<Array>& expected) {\n-    ASSERT_OK_AND_ASSIGN(Datum result, kernel(left, right, &ctx_));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    std::shared_ptr<Array> result_array = result.make_array();\n-    ASSERT_OK(result_array->ValidateFull());\n-    AssertArraysEqual(*expected, *result_array, /*verbose=*/true);\n-\n-    ASSERT_OK_AND_ASSIGN(result, kernel(right, left, &ctx_));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    result_array = result.make_array();\n-    ASSERT_OK(result_array->ValidateFull());\n-    AssertArraysEqual(*expected, *result_array, /*verbose=*/true);\n-  }\n+void CheckBooleanScalarArrayBinary(std::string func_name, Datum array) {\n+  for (std::shared_ptr<Scalar> scalar :\n+       {std::make_shared<BooleanScalar>(), std::make_shared<BooleanScalar>(true),\n+        std::make_shared<BooleanScalar>(false)}) {\n+    ASSERT_OK_AND_ASSIGN(Datum actual, CallFunction(func_name, {Datum(scalar), array}));\n \n-  void TestChunkedArrayBinary(const BinaryKernelFunc& kernel,\n-                              const std::shared_ptr<ChunkedArray>& left,\n-                              const std::shared_ptr<ChunkedArray>& right,\n-                              const std::shared_ptr<ChunkedArray>& expected) {\n-    ASSERT_OK_AND_ASSIGN(Datum result, kernel(left, right, &ctx_));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-    AssertChunkedEquivalent(*expected, *result_ca);\n-\n-    ASSERT_OK_AND_ASSIGN(result, kernel(right, left, &ctx_));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    result_ca = result.chunked_array();\n-    AssertChunkedEquivalent(*expected, *result_ca);\n-  }\n+    ASSERT_OK_AND_ASSIGN(auto constant_array,\n+                         MakeArrayFromScalar(*scalar, array.length()));\n \n-  void TestBinaryKernel(const BinaryKernelFunc& kernel,\n-                        const std::shared_ptr<Array>& left,\n-                        const std::shared_ptr<Array>& right,\n-                        const std::shared_ptr<Array>& expected) {\n-    TestArrayBinary(kernel, left, right, expected);\n-    TestArrayBinary(kernel, left->Slice(1), right->Slice(1), expected->Slice(1));\n-\n-    // ChunkedArray\n-    auto cleft = std::make_shared<ChunkedArray>(ArrayVector{left, left->Slice(1)});\n-    auto cright = std::make_shared<ChunkedArray>(ArrayVector{right, right->Slice(1)});\n-    auto cexpected =\n-        std::make_shared<ChunkedArray>(ArrayVector{expected, expected->Slice(1)});\n-    TestChunkedArrayBinary(kernel, cleft, cright, cexpected);\n-\n-    // ChunkedArray with different chunks\n-    cleft = std::make_shared<ChunkedArray>(ArrayVector{\n-        left->Slice(0, 1), left->Slice(1), left->Slice(1, 1), left->Slice(2)});\n-    TestChunkedArrayBinary(kernel, cleft, cright, cexpected);\n-  }\n+    ASSERT_OK_AND_ASSIGN(Datum expected,\n+                         CallFunction(func_name, {Datum(constant_array), array}));\n+    AssertDatumsEqual(expected, actual);\n \n-  void TestBinaryKernelPropagate(const BinaryKernelFunc& kernel,\n-                                 const std::vector<bool>& left,\n-                                 const std::vector<bool>& right,\n-                                 const std::vector<bool>& expected,\n-                                 const std::vector<bool>& expected_nulls) {\n-    auto type = boolean();\n-    TestBinaryKernel(kernel, _MakeArray<BooleanType, bool>(type, left, {}),\n-                     _MakeArray<BooleanType, bool>(type, right, {}),\n-                     _MakeArray<BooleanType, bool>(type, expected, {}));\n-\n-    TestBinaryKernel(kernel, _MakeArray<BooleanType, bool>(type, left, left),\n-                     _MakeArray<BooleanType, bool>(type, right, right),\n-                     _MakeArray<BooleanType, bool>(type, expected, expected_nulls));\n+    ASSERT_OK_AND_ASSIGN(actual, CallFunction(func_name, {array, Datum(scalar)}));\n+    ASSERT_OK_AND_ASSIGN(expected,\n+                         CallFunction(func_name, {array, Datum(constant_array)}));\n+    AssertDatumsEqual(expected, actual);\n   }\n-\n- protected:\n-  ExecContext ctx_;\n-};\n-\n-TEST_F(TestBooleanKernel, Invert) {\n-  std::vector<bool> values1 = {true, false, true, false};\n-  std::vector<bool> values2 = {false, true, false, true};\n-\n-  auto type = boolean();\n-  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {true, true, true, false});\n-  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {true, true, true, false});\n-\n-  // Plain array\n-  ASSERT_OK_AND_ASSIGN(Datum result, Invert(a1));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  ASSERT_ARRAYS_EQUAL(*a2, *result.make_array());\n-\n-  // Array with offset\n-  ASSERT_OK_AND_ASSIGN(result, Invert(a1->Slice(1)));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  ASSERT_ARRAYS_EQUAL(*a2->Slice(1), *result.make_array());\n-\n-  // ChunkedArray\n-  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n-  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n-  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n-  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n-  ASSERT_OK_AND_ASSIGN(result, Invert(ca1));\n-  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-\n-  // Contiguous preallocation, so a single output chunk even though there were\n-  // two input chunks\n-  ASSERT_EQ(1, result_ca->num_chunks());\n-  AssertChunkedEquivalent(*ca2, *result_ca);\n }\n \n-TEST_F(TestBooleanKernel, InvertEmptyArray) {\n-  std::vector<std::shared_ptr<Buffer>> data_buffers(2);\n-  Datum input;\n-  input.value = ArrayData::Make(boolean(), 0 /* length */, std::move(data_buffers),\n-                                0 /* null_count */);\n-\n-  ASSERT_OK_AND_ASSIGN(Datum result, Invert(input));\n-  ASSERT_ARRAYS_EQUAL(*input.make_array(), *result.make_array());\n+TEST(TestBooleanKernel, Invert) {\n+  auto arr =\n+      ArrayFromJSON(boolean(), \"[true, false, true, null, false, true, false, null]\");\n+  auto expected =\n+      ArrayFromJSON(boolean(), \"[false, true, false, null, true, false, true, null]\");\n+  CheckScalarUnary(\"invert\", arr, expected);\n }\n \n-TEST_F(TestBooleanKernel, BinaryOpOnEmptyArray) {\n-  auto type = boolean();\n-  std::vector<std::shared_ptr<Buffer>> data_buffers(2);\n-  Datum input;\n-  input.value = ArrayData::Make(boolean(), 0 /* length */, std::move(data_buffers),\n-                                0 /* null_count */);\n-\n-  ASSERT_OK_AND_ASSIGN(Datum result, And(input, input));\n-  // Result should be empty as well.\n-  ASSERT_ARRAYS_EQUAL(*input.make_array(), *result.make_array());\n+TEST(TestBooleanKernel, And) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[true, false, null, false, null,  null]\");\n+  // CheckScalarBinary(\"and\", left, right, expected);\n\nReview comment:\n       Not a good one; I was debugging the `array, scalar` case and wanted to skip this. Will uncomment\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T15:03:03.014+0000",
                    "updated": "2020-11-23T15:03:03.014+0000",
                    "started": "2020-11-23T15:03:03.013+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515585",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515586",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528767500\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/codegen_internal.h\n##########\n@@ -427,12 +427,28 @@ void SimpleUnary(KernelContext* ctx, const ExecBatch& batch, Datum* out) {\n //\n // static void Call(KernelContext*, const ArrayData& arg0, const ArrayData& arg1,\n //                  ArrayData* out)\n+// static void Call(KernelContext*, const ArrayData& arg0, const Scalar& arg1,\n+//                  ArrayData* out)\n+// static void Call(KernelContext*, const Scalar& arg0, const ArrayData& arg1,\n+//                  ArrayData* out)\n+// static void Call(KernelContext*, const Scalar& arg0, const Scalar& arg1,\n+//                  Scalar* out)\n\nReview comment:\n       That's implicit in the contract of ScalarFunctions though\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T15:03:47.200+0000",
                    "updated": "2020-11-23T15:03:47.200+0000",
                    "started": "2020-11-23T15:03:47.200+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515586",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515587",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528767690\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec.cc\n##########\n@@ -213,20 +214,33 @@ bool ExecBatchIterator::Next(ExecBatch* batch) {\n \n namespace {\n \n-bool ArrayHasNulls(const ArrayData& data) {\n-  // As discovered in ARROW-8863 (and not only for that reason)\n-  // ArrayData::null_count can -1 even when buffers[0] is nullptr. So we check\n-  // for both cases (nullptr means no nulls, or null_count already computed)\n-  if (data.type->id() == Type::NA) {\n-    return true;\n-  } else if (data.buffers[0] == nullptr) {\n-    return false;\n-  } else {\n+struct NullGeneralization {\n+  enum type { NONE, ALL_VALID, ALL_NULL };\n\nReview comment:\n       Alright\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T15:04:00.190+0000",
                    "updated": "2020-11-23T15:04:00.190+0000",
                    "started": "2020-11-23T15:04:00.189+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515587",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515588",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528768308\n\n\n\n##########\nFile path: cpp/src/arrow/compute/exec.cc\n##########\n@@ -272,79 +287,61 @@ class NullPropagator {\n     return Status::OK();\n   }\n \n-  Result<bool> ShortCircuitIfAllNull() {\n-    // An all-null value (scalar null or all-null array) gives us a short\n-    // circuit opportunity\n-    bool is_all_null = false;\n-    std::shared_ptr<Buffer> all_null_bitmap;\n+  Status AllNullShortCircuit() {\n+    // OK, the output should be all null\n+    output_->null_count = output_->length;\n+\n+    if (bitmap_preallocated_) {\n+      BitUtil::SetBitsTo(bitmap_, output_->offset, output_->length, false);\n+      return Status::OK();\n+    }\n \n     // Walk all the values with nulls instead of breaking on the first in case\n     // we find a bitmap that can be reused in the non-preallocated case\n-    for (const Datum* value : values_with_nulls_) {\n-      if (value->type()->id() == Type::NA) {\n-        // No bitmap\n-        is_all_null = true;\n-      } else if (value->kind() == Datum::ARRAY) {\n-        const ArrayData& arr = *value->array();\n-        if (arr.null_count.load() == arr.length) {\n-          // Pluck the all null bitmap so we can set it in the output if it was\n-          // not pre-allocated\n-          all_null_bitmap = arr.buffers[0];\n-          is_all_null = true;\n-        }\n-      } else {\n-        // Scalar\n-        is_all_null = !value->scalar()->is_valid;\n+    for (const ArrayData* arr : arrays_with_nulls_) {\n+      if (arr->null_count.load() == arr->length && arr->buffers[0] != nullptr) {\n+        // Reuse this all null bitmap\n+        output_->buffers[0] = arr->buffers[0];\n+        return Status::OK();\n       }\n     }\n-    if (!is_all_null) {\n-      return false;\n-    }\n \n-    // OK, the output should be all null\n-    output_->null_count = output_->length;\n-\n-    if (!bitmap_preallocated_ && all_null_bitmap) {\n-      // If we did not pre-allocate memory, and we observed an all-null bitmap,\n-      // then we can zero-copy it into the output\n-      output_->buffers[0] = std::move(all_null_bitmap);\n-    } else {\n-      RETURN_NOT_OK(EnsureAllocated());\n-      BitUtil::SetBitsTo(bitmap_, output_->offset, output_->length, false);\n-    }\n-    return true;\n+    RETURN_NOT_OK(EnsureAllocated());\n+    BitUtil::SetBitsTo(bitmap_, output_->offset, output_->length, false);\n+    return Status::OK();\n   }\n \n   Status PropagateSingle() {\n     // One array\n-    const ArrayData& arr = *values_with_nulls_[0]->array();\n+    const ArrayData& arr = *arrays_with_nulls_[0];\n     const std::shared_ptr<Buffer>& arr_bitmap = arr.buffers[0];\n \n     // Reuse the null count if it's known\n     output_->null_count = arr.null_count.load();\n \n     if (bitmap_preallocated_) {\n       CopyBitmap(arr_bitmap->data(), arr.offset, arr.length, bitmap_, output_->offset);\n+      return Status::OK();\n+    }\n+\n+    // Two cases when memory was not pre-allocated:\n+    //\n+    // * Offset is zero: we reuse the bitmap as is\n+    // * Offset is nonzero but a multiple of 8: we can slice the bitmap\n+    // * Offset is not a multiple of 8: we must allocate and use CopyBitmap\n+    //\n+    // Keep in mind that output_->offset is not permitted to be nonzero when\n+    // the bitmap is not preallocated, and that precondition is asserted\n+    // higher in the call stack.\n+    if (arr.offset == 0) {\n+      output_->buffers[0] = arr_bitmap;\n+    } else if (arr.offset % 8 == 0) {\n+      output_->buffers[0] =\n+          SliceBuffer(arr_bitmap, arr.offset / 8, BitUtil::BytesForBits(arr.length));\n\nReview comment:\n       Sounds worthwhile but I'd prefer to do it in follow up\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T15:04:45.570+0000",
                    "updated": "2020-11-23T15:04:45.570+0000",
                    "started": "2020-11-23T15:04:45.570+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515588",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515589",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528768746\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean_test.cc\n##########\n@@ -27,185 +27,114 @@\n #include \"arrow/compute/kernels/test_util.h\"\n #include \"arrow/testing/gtest_common.h\"\n #include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n \n namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n namespace compute {\n \n-using BinaryKernelFunc =\n-    std::function<Result<Datum>(const Datum&, const Datum&, ExecContext*)>;\n-\n-class TestBooleanKernel : public TestBase {\n- public:\n-  void TestArrayBinary(const BinaryKernelFunc& kernel, const std::shared_ptr<Array>& left,\n-                       const std::shared_ptr<Array>& right,\n-                       const std::shared_ptr<Array>& expected) {\n-    ASSERT_OK_AND_ASSIGN(Datum result, kernel(left, right, &ctx_));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    std::shared_ptr<Array> result_array = result.make_array();\n-    ASSERT_OK(result_array->ValidateFull());\n-    AssertArraysEqual(*expected, *result_array, /*verbose=*/true);\n-\n-    ASSERT_OK_AND_ASSIGN(result, kernel(right, left, &ctx_));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    result_array = result.make_array();\n-    ASSERT_OK(result_array->ValidateFull());\n-    AssertArraysEqual(*expected, *result_array, /*verbose=*/true);\n-  }\n+void CheckBooleanScalarArrayBinary(std::string func_name, Datum array) {\n+  for (std::shared_ptr<Scalar> scalar :\n+       {std::make_shared<BooleanScalar>(), std::make_shared<BooleanScalar>(true),\n+        std::make_shared<BooleanScalar>(false)}) {\n+    ASSERT_OK_AND_ASSIGN(Datum actual, CallFunction(func_name, {Datum(scalar), array}));\n \n-  void TestChunkedArrayBinary(const BinaryKernelFunc& kernel,\n-                              const std::shared_ptr<ChunkedArray>& left,\n-                              const std::shared_ptr<ChunkedArray>& right,\n-                              const std::shared_ptr<ChunkedArray>& expected) {\n-    ASSERT_OK_AND_ASSIGN(Datum result, kernel(left, right, &ctx_));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-    AssertChunkedEquivalent(*expected, *result_ca);\n-\n-    ASSERT_OK_AND_ASSIGN(result, kernel(right, left, &ctx_));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    result_ca = result.chunked_array();\n-    AssertChunkedEquivalent(*expected, *result_ca);\n-  }\n+    ASSERT_OK_AND_ASSIGN(auto constant_array,\n+                         MakeArrayFromScalar(*scalar, array.length()));\n \n-  void TestBinaryKernel(const BinaryKernelFunc& kernel,\n-                        const std::shared_ptr<Array>& left,\n-                        const std::shared_ptr<Array>& right,\n-                        const std::shared_ptr<Array>& expected) {\n-    TestArrayBinary(kernel, left, right, expected);\n-    TestArrayBinary(kernel, left->Slice(1), right->Slice(1), expected->Slice(1));\n-\n-    // ChunkedArray\n-    auto cleft = std::make_shared<ChunkedArray>(ArrayVector{left, left->Slice(1)});\n-    auto cright = std::make_shared<ChunkedArray>(ArrayVector{right, right->Slice(1)});\n-    auto cexpected =\n-        std::make_shared<ChunkedArray>(ArrayVector{expected, expected->Slice(1)});\n-    TestChunkedArrayBinary(kernel, cleft, cright, cexpected);\n-\n-    // ChunkedArray with different chunks\n-    cleft = std::make_shared<ChunkedArray>(ArrayVector{\n-        left->Slice(0, 1), left->Slice(1), left->Slice(1, 1), left->Slice(2)});\n-    TestChunkedArrayBinary(kernel, cleft, cright, cexpected);\n-  }\n+    ASSERT_OK_AND_ASSIGN(Datum expected,\n+                         CallFunction(func_name, {Datum(constant_array), array}));\n+    AssertDatumsEqual(expected, actual);\n \n-  void TestBinaryKernelPropagate(const BinaryKernelFunc& kernel,\n-                                 const std::vector<bool>& left,\n-                                 const std::vector<bool>& right,\n-                                 const std::vector<bool>& expected,\n-                                 const std::vector<bool>& expected_nulls) {\n-    auto type = boolean();\n-    TestBinaryKernel(kernel, _MakeArray<BooleanType, bool>(type, left, {}),\n-                     _MakeArray<BooleanType, bool>(type, right, {}),\n-                     _MakeArray<BooleanType, bool>(type, expected, {}));\n-\n-    TestBinaryKernel(kernel, _MakeArray<BooleanType, bool>(type, left, left),\n-                     _MakeArray<BooleanType, bool>(type, right, right),\n-                     _MakeArray<BooleanType, bool>(type, expected, expected_nulls));\n+    ASSERT_OK_AND_ASSIGN(actual, CallFunction(func_name, {array, Datum(scalar)}));\n+    ASSERT_OK_AND_ASSIGN(expected,\n+                         CallFunction(func_name, {array, Datum(constant_array)}));\n+    AssertDatumsEqual(expected, actual);\n   }\n-\n- protected:\n-  ExecContext ctx_;\n-};\n-\n-TEST_F(TestBooleanKernel, Invert) {\n-  std::vector<bool> values1 = {true, false, true, false};\n-  std::vector<bool> values2 = {false, true, false, true};\n-\n-  auto type = boolean();\n-  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {true, true, true, false});\n-  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {true, true, true, false});\n-\n-  // Plain array\n-  ASSERT_OK_AND_ASSIGN(Datum result, Invert(a1));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  ASSERT_ARRAYS_EQUAL(*a2, *result.make_array());\n-\n-  // Array with offset\n-  ASSERT_OK_AND_ASSIGN(result, Invert(a1->Slice(1)));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  ASSERT_ARRAYS_EQUAL(*a2->Slice(1), *result.make_array());\n-\n-  // ChunkedArray\n-  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n-  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n-  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n-  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n-  ASSERT_OK_AND_ASSIGN(result, Invert(ca1));\n-  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-\n-  // Contiguous preallocation, so a single output chunk even though there were\n-  // two input chunks\n-  ASSERT_EQ(1, result_ca->num_chunks());\n-  AssertChunkedEquivalent(*ca2, *result_ca);\n }\n \n-TEST_F(TestBooleanKernel, InvertEmptyArray) {\n-  std::vector<std::shared_ptr<Buffer>> data_buffers(2);\n-  Datum input;\n-  input.value = ArrayData::Make(boolean(), 0 /* length */, std::move(data_buffers),\n-                                0 /* null_count */);\n-\n-  ASSERT_OK_AND_ASSIGN(Datum result, Invert(input));\n-  ASSERT_ARRAYS_EQUAL(*input.make_array(), *result.make_array());\n+TEST(TestBooleanKernel, Invert) {\n+  auto arr =\n+      ArrayFromJSON(boolean(), \"[true, false, true, null, false, true, false, null]\");\n+  auto expected =\n+      ArrayFromJSON(boolean(), \"[false, true, false, null, true, false, true, null]\");\n+  CheckScalarUnary(\"invert\", arr, expected);\n }\n \n-TEST_F(TestBooleanKernel, BinaryOpOnEmptyArray) {\n-  auto type = boolean();\n-  std::vector<std::shared_ptr<Buffer>> data_buffers(2);\n-  Datum input;\n-  input.value = ArrayData::Make(boolean(), 0 /* length */, std::move(data_buffers),\n-                                0 /* null_count */);\n-\n-  ASSERT_OK_AND_ASSIGN(Datum result, And(input, input));\n-  // Result should be empty as well.\n-  ASSERT_ARRAYS_EQUAL(*input.make_array(), *result.make_array());\n+TEST(TestBooleanKernel, And) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[true, false, null, false, null,  null]\");\n+  // CheckScalarBinary(\"and\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and\", left);\n }\n \n-TEST_F(TestBooleanKernel, And) {\n-  std::vector<bool> values1 = {true, false, true, false, true, true};\n-  std::vector<bool> values2 = {true, true, false, false, true, false};\n-  std::vector<bool> values3 = {true, false, false, false, true, false};\n-  TestBinaryKernelPropagate(And, values1, values2, values3, values3);\n+TEST(TestBooleanKernel, Or) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[true, true,  null, false, null,  null]\");\n+  CheckScalarBinary(\"or\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"or\", left);\n }\n \n-TEST_F(TestBooleanKernel, Or) {\n-  std::vector<bool> values1 = {true, false, true, false, true, true};\n-  std::vector<bool> values2 = {true, true, false, false, true, false};\n-  std::vector<bool> values3 = {true, true, true, false, true, true};\n-  std::vector<bool> values3_nulls = {true, false, false, false, true, false};\n-  TestBinaryKernelPropagate(Or, values1, values2, values3, values3_nulls);\n+TEST(TestBooleanKernel, Xor) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true,  true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true,  false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[false, true,  null, false, null,  null]\");\n+  CheckScalarBinary(\"xor\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"xor\", left);\n }\n \n-TEST_F(TestBooleanKernel, Xor) {\n-  std::vector<bool> values1 = {true, false, true, false, true, true};\n-  std::vector<bool> values2 = {true, true, false, false, true, false};\n-  std::vector<bool> values3 = {false, true, true, false, false, true};\n-  std::vector<bool> values3_nulls = {true, false, false, false, true, false};\n-  TestBinaryKernelPropagate(Xor, values1, values2, values3, values3_nulls);\n+TEST(TestBooleanKernel, AndNot) {\n+  auto left = ArrayFromJSON(\n+      boolean(), \"[true,  true,  true, false, false, false, null, null,  null]\");\n+  auto right = ArrayFromJSON(\n+      boolean(), \"[true,  false, null, true,  false, null,  true, false, null]\");\n+  auto expected = ArrayFromJSON(\n+      boolean(), \"[false, true,  null, false, false, null,  null, null,  null]\");\n+  CheckScalarBinary(\"and_not\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and_not\", left);\n }\n \n-TEST_F(TestBooleanKernel, KleeneAnd) {\n+TEST(TestBooleanKernel, KleeneAnd) {\n   auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n   auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n   auto expected = ArrayFromJSON(boolean(), \"[true, false, null, false, false, null]\");\n-  TestBinaryKernel(KleeneAnd, left, right, expected);\n+  CheckScalarBinary(\"and_kleene\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and_kleene\", left);\n \n   left = ArrayFromJSON(boolean(), \"    [true, true,  false, null, null]\");\n   right = ArrayFromJSON(boolean(), \"   [true, false, false, true, false]\");\n   expected = ArrayFromJSON(boolean(), \"[true, false, false, null, false]\");\n-  TestBinaryKernel(KleeneAnd, left, right, expected);\n+  CheckScalarBinary(\"and_kleene\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and_kleene\", left);\n\nReview comment:\n       No, I mean you test a set of left / right inputs above, and another set of inputs here. Is there a reason to them separately? (just trying to understand if there is a particular reason...)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T15:05:18.901+0000",
                    "updated": "2020-11-23T15:05:18.901+0000",
                    "started": "2020-11-23T15:05:18.901+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515589",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515598",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528776241\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean.cc\n##########\n@@ -156,14 +307,94 @@ struct Xor {\n   }\n };\n \n+struct AndNot {\n+  static void Call(KernelContext* ctx, const Scalar& left, const Scalar& right,\n+                   Scalar* out) {\n+    And::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const Scalar& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    if (!left.is_valid) return;  // all null case\n+\n+    return checked_cast<const BooleanScalar&>(left).value\n+               ? GetBitmap(*out, 1).CopyFromInverted(GetBitmap(right, 1))\n+               : GetBitmap(*out, 1).SetBitsTo(false);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const Scalar& right,\n+                   ArrayData* out) {\n+    And::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    ::arrow::internal::BitmapAndNot(left.buffers[1]->data(), left.offset,\n+                                    right.buffers[1]->data(), right.offset, right.length,\n+                                    out->offset, out->buffers[1]->mutable_data());\n+  }\n+};\n+\n+struct KleeneAndNot {\n+  static void Call(KernelContext* ctx, const Scalar& left, const Scalar& right,\n+                   Scalar* out) {\n+    KleeneAnd::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const Scalar& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    bool left_true = left.is_valid && checked_cast<const BooleanScalar&>(left).value;\n+    bool left_false = left.is_valid && !checked_cast<const BooleanScalar&>(left).value;\n+\n+    if (left_false) {\n+      return GetBitmap(*out, 0).SetBitsTo(true),\n+             GetBitmap(*out, 1).SetBitsTo(false);  // all false case\n+    }\n+\n+    if (left_true) {\n+      return GetBitmap(*out, 0).CopyFrom(GetBitmap(right, 0)),\n+             GetBitmap(*out, 1).CopyFromInverted(GetBitmap(right, 1));\n+    }\n+\n+    // scalar was null: out[i] is valid iff right[i] was true\n+    ::arrow::internal::BitmapAnd(right.buffers[0]->data(), right.offset,\n+                                 right.buffers[1]->data(), right.offset, right.length,\n+                                 out->offset, out->buffers[0]->mutable_data());\n+    ::arrow::internal::InvertBitmap(right.buffers[1]->data(), right.offset, right.length,\n+                                    out->buffers[1]->mutable_data(), out->offset);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const Scalar& right,\n+                   ArrayData* out) {\n+    KleeneAnd::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    if (left.GetNullCount() == 0 && right.GetNullCount() == 0) {\n+      GetBitmap(*out, 0).SetBitsTo(true);\n+      return AndNot::Call(ctx, left, right, out);\n+    }\n+\n+    static auto compute_word = [](uint64_t left_true, uint64_t left_false,\n+                                  uint64_t right_true, uint64_t right_false,\n+                                  uint64_t* out_valid, uint64_t* out_data) {\n+      *out_data = left_true & right_false;\n+      *out_valid = left_false | right_true | (left_true & right_false);\n\nReview comment:\n       `right_false` is derived from both the validity and the value bitmaps; it's true iff a slot was valid&false. To unpack this expression a bit: `and_not_kleene(left, right)` is valid if\r\n   - `left` is false, since `and_kleene(false, x)` is false (even if `x` is null)\r\n   - `right` is true, since `and_kleene(x, not true)` is false (even if `x` is null)\r\n   - `left` is true AND `right` is false, since `and_kleene(true, not false)` is true\r\n   \r\n   I believe the tests exercise the full truth table of and_not_kleene so if this still looks suspicious then I'd look there first.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T15:15:14.824+0000",
                    "updated": "2020-11-23T15:15:14.824+0000",
                    "started": "2020-11-23T15:15:14.824+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515598",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515600",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528777466\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean.cc\n##########\n@@ -156,14 +307,94 @@ struct Xor {\n   }\n };\n \n+struct AndNot {\n+  static void Call(KernelContext* ctx, const Scalar& left, const Scalar& right,\n+                   Scalar* out) {\n+    And::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const Scalar& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    if (!left.is_valid) return;  // all null case\n+\n+    return checked_cast<const BooleanScalar&>(left).value\n+               ? GetBitmap(*out, 1).CopyFromInverted(GetBitmap(right, 1))\n+               : GetBitmap(*out, 1).SetBitsTo(false);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const Scalar& right,\n+                   ArrayData* out) {\n+    And::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    ::arrow::internal::BitmapAndNot(left.buffers[1]->data(), left.offset,\n+                                    right.buffers[1]->data(), right.offset, right.length,\n+                                    out->offset, out->buffers[1]->mutable_data());\n+  }\n+};\n+\n+struct KleeneAndNot {\n+  static void Call(KernelContext* ctx, const Scalar& left, const Scalar& right,\n+                   Scalar* out) {\n+    KleeneAnd::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const Scalar& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    bool left_true = left.is_valid && checked_cast<const BooleanScalar&>(left).value;\n+    bool left_false = left.is_valid && !checked_cast<const BooleanScalar&>(left).value;\n+\n+    if (left_false) {\n+      return GetBitmap(*out, 0).SetBitsTo(true),\n+             GetBitmap(*out, 1).SetBitsTo(false);  // all false case\n+    }\n+\n+    if (left_true) {\n+      return GetBitmap(*out, 0).CopyFrom(GetBitmap(right, 0)),\n+             GetBitmap(*out, 1).CopyFromInverted(GetBitmap(right, 1));\n+    }\n+\n+    // scalar was null: out[i] is valid iff right[i] was true\n+    ::arrow::internal::BitmapAnd(right.buffers[0]->data(), right.offset,\n+                                 right.buffers[1]->data(), right.offset, right.length,\n+                                 out->offset, out->buffers[0]->mutable_data());\n+    ::arrow::internal::InvertBitmap(right.buffers[1]->data(), right.offset, right.length,\n+                                    out->buffers[1]->mutable_data(), out->offset);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const Scalar& right,\n+                   ArrayData* out) {\n+    KleeneAnd::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    if (left.GetNullCount() == 0 && right.GetNullCount() == 0) {\n+      GetBitmap(*out, 0).SetBitsTo(true);\n+      return AndNot::Call(ctx, left, right, out);\n+    }\n+\n+    static auto compute_word = [](uint64_t left_true, uint64_t left_false,\n+                                  uint64_t right_true, uint64_t right_false,\n+                                  uint64_t* out_valid, uint64_t* out_data) {\n+      *out_data = left_true & right_false;\n+      *out_valid = left_false | right_true | (left_true & right_false);\n\nReview comment:\n       Wow, sorry, I was reading this badly (I use my eyes more and my brain less :-)).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean.cc\n##########\n@@ -156,14 +307,94 @@ struct Xor {\n   }\n };\n \n+struct AndNot {\n+  static void Call(KernelContext* ctx, const Scalar& left, const Scalar& right,\n+                   Scalar* out) {\n+    And::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const Scalar& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    if (!left.is_valid) return;  // all null case\n+\n+    return checked_cast<const BooleanScalar&>(left).value\n+               ? GetBitmap(*out, 1).CopyFromInverted(GetBitmap(right, 1))\n+               : GetBitmap(*out, 1).SetBitsTo(false);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const Scalar& right,\n+                   ArrayData* out) {\n+    And::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    ::arrow::internal::BitmapAndNot(left.buffers[1]->data(), left.offset,\n+                                    right.buffers[1]->data(), right.offset, right.length,\n+                                    out->offset, out->buffers[1]->mutable_data());\n+  }\n+};\n+\n+struct KleeneAndNot {\n+  static void Call(KernelContext* ctx, const Scalar& left, const Scalar& right,\n+                   Scalar* out) {\n+    KleeneAnd::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const Scalar& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    bool left_true = left.is_valid && checked_cast<const BooleanScalar&>(left).value;\n+    bool left_false = left.is_valid && !checked_cast<const BooleanScalar&>(left).value;\n+\n+    if (left_false) {\n+      return GetBitmap(*out, 0).SetBitsTo(true),\n+             GetBitmap(*out, 1).SetBitsTo(false);  // all false case\n+    }\n+\n+    if (left_true) {\n+      return GetBitmap(*out, 0).CopyFrom(GetBitmap(right, 0)),\n+             GetBitmap(*out, 1).CopyFromInverted(GetBitmap(right, 1));\n+    }\n+\n+    // scalar was null: out[i] is valid iff right[i] was true\n+    ::arrow::internal::BitmapAnd(right.buffers[0]->data(), right.offset,\n+                                 right.buffers[1]->data(), right.offset, right.length,\n+                                 out->offset, out->buffers[0]->mutable_data());\n+    ::arrow::internal::InvertBitmap(right.buffers[1]->data(), right.offset, right.length,\n+                                    out->buffers[1]->mutable_data(), out->offset);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const Scalar& right,\n+                   ArrayData* out) {\n+    KleeneAnd::Call(ctx, left, InvertScalar(right), out);\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    if (left.GetNullCount() == 0 && right.GetNullCount() == 0) {\n+      GetBitmap(*out, 0).SetBitsTo(true);\n+      return AndNot::Call(ctx, left, right, out);\n+    }\n+\n+    static auto compute_word = [](uint64_t left_true, uint64_t left_false,\n+                                  uint64_t right_true, uint64_t right_false,\n+                                  uint64_t* out_valid, uint64_t* out_data) {\n+      *out_data = left_true & right_false;\n+      *out_valid = left_false | right_true | (left_true & right_false);\n\nReview comment:\n       Wow, sorry, I was reading this badly (I should use my eyes more and my brain less :-)).\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T15:17:01.183+0000",
                    "updated": "2020-11-23T15:17:01.183+0000",
                    "started": "2020-11-23T15:17:01.183+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515600",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515602",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528781337\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean.cc\n##########\n@@ -61,40 +59,78 @@ void ComputeKleene(ComputeWord&& compute_word, KernelContext* ctx, const ArrayDa\n     ++i;\n   };\n \n-  if (right.null_count == 0 || left.null_count == 0) {\n-    if (left.null_count == 0) {\n-      // ensure only bitmaps[RIGHT_VALID].buffer might be null\n-      std::swap(bitmaps[LEFT_VALID], bitmaps[RIGHT_VALID]);\n-      std::swap(bitmaps[LEFT_DATA], bitmaps[RIGHT_DATA]);\n-    }\n-    // override bitmaps[RIGHT_VALID] to make it safe for Visit()\n+  if (right.null_count == 0) {\n+    // bitmaps[RIGHT_VALID] might be null; override to make it safe for Visit()\n     bitmaps[RIGHT_VALID] = bitmaps[RIGHT_DATA];\n-\n     Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n       apply(words[LEFT_VALID], words[LEFT_DATA], ~uint64_t(0), words[RIGHT_DATA]);\n     });\n-  } else {\n+    return;\n+  }\n+\n+  if (left.null_count == 0) {\n+    // bitmaps[LEFT_VALID] might be null; override to make it safe for Visit()\n+    bitmaps[LEFT_VALID] = bitmaps[LEFT_DATA];\n     Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n-      apply(words[LEFT_VALID], words[LEFT_DATA], words[RIGHT_VALID], words[RIGHT_DATA]);\n+      apply(~uint64_t(0), words[LEFT_DATA], words[RIGHT_VALID], words[RIGHT_DATA]);\n     });\n+    return;\n   }\n+\n+  DCHECK(left.null_count != 0 || right.null_count != 0);\n+  Bitmap::VisitWords(bitmaps, [&](std::array<uint64_t, 4> words) {\n+    apply(words[LEFT_VALID], words[LEFT_DATA], words[RIGHT_VALID], words[RIGHT_DATA]);\n+  });\n+}\n+\n+inline BooleanScalar InvertScalar(const Scalar& in) {\n+  return in.is_valid ? BooleanScalar(!checked_cast<const BooleanScalar&>(in).value)\n+                     : BooleanScalar();\n+}\n+\n+inline Bitmap GetBitmap(const ArrayData& arr, int index) {\n+  return Bitmap{arr.buffers[index], arr.offset, arr.length};\n }\n \n struct Invert {\n   static void Call(KernelContext* ctx, const Scalar& in, Scalar* out) {\n-    if (in.is_valid) {\n-      checked_cast<BooleanScalar*>(out)->value =\n-          !checked_cast<const BooleanScalar&>(in).value;\n-    }\n+    *checked_cast<BooleanScalar*>(out) = InvertScalar(in);\n   }\n \n   static void Call(KernelContext* ctx, const ArrayData& in, ArrayData* out) {\n-    ::arrow::internal::InvertBitmap(in.buffers[1]->data(), in.offset, in.length,\n-                                    out->buffers[1]->mutable_data(), out->offset);\n+    GetBitmap(*out, 1).CopyFromInverted(GetBitmap(in, 1));\n   }\n };\n \n-struct And {\n+template <typename Op>\n+struct Commutative {\n+  static void Call(KernelContext* ctx, const Scalar& left, const ArrayData& right,\n+                   ArrayData* out) {\n+    Op::Call(ctx, right, left, out);\n+  }\n+};\n+\n+struct And : Commutative<And> {\n+  using Commutative<And>::Call;\n+\n+  static void Call(KernelContext* ctx, const Scalar& left, const Scalar& right,\n+                   Scalar* out) {\n+    if (left.is_valid && right.is_valid) {\n+      checked_cast<BooleanScalar*>(out)->value =\n+          checked_cast<const BooleanScalar&>(left).value &&\n+          checked_cast<const BooleanScalar&>(right).value;\n+    }\n+  }\n+\n+  static void Call(KernelContext* ctx, const ArrayData& left, const Scalar& right,\n+                   ArrayData* out) {\n+    if (!right.is_valid) return;  // all null case\n+\n+    return checked_cast<const BooleanScalar&>(right).value\n+               ? GetBitmap(*out, 1).CopyFrom(GetBitmap(left, 1))\n\nReview comment:\n       Reusing the bitmap like this will make it harder to refactor Kleene kernels to support writing into slices, which (I'm guessing) would be the greater performance win. In any case, it can wait till follow up\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T15:22:21.285+0000",
                    "updated": "2020-11-23T15:22:21.285+0000",
                    "started": "2020-11-23T15:22:21.284+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515602",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515620",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728#discussion_r528793473\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/scalar_boolean_test.cc\n##########\n@@ -27,185 +27,114 @@\n #include \"arrow/compute/kernels/test_util.h\"\n #include \"arrow/testing/gtest_common.h\"\n #include \"arrow/testing/gtest_util.h\"\n+#include \"arrow/util/checked_cast.h\"\n \n namespace arrow {\n+\n+using internal::checked_pointer_cast;\n+\n namespace compute {\n \n-using BinaryKernelFunc =\n-    std::function<Result<Datum>(const Datum&, const Datum&, ExecContext*)>;\n-\n-class TestBooleanKernel : public TestBase {\n- public:\n-  void TestArrayBinary(const BinaryKernelFunc& kernel, const std::shared_ptr<Array>& left,\n-                       const std::shared_ptr<Array>& right,\n-                       const std::shared_ptr<Array>& expected) {\n-    ASSERT_OK_AND_ASSIGN(Datum result, kernel(left, right, &ctx_));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    std::shared_ptr<Array> result_array = result.make_array();\n-    ASSERT_OK(result_array->ValidateFull());\n-    AssertArraysEqual(*expected, *result_array, /*verbose=*/true);\n-\n-    ASSERT_OK_AND_ASSIGN(result, kernel(right, left, &ctx_));\n-    ASSERT_EQ(Datum::ARRAY, result.kind());\n-    result_array = result.make_array();\n-    ASSERT_OK(result_array->ValidateFull());\n-    AssertArraysEqual(*expected, *result_array, /*verbose=*/true);\n-  }\n+void CheckBooleanScalarArrayBinary(std::string func_name, Datum array) {\n+  for (std::shared_ptr<Scalar> scalar :\n+       {std::make_shared<BooleanScalar>(), std::make_shared<BooleanScalar>(true),\n+        std::make_shared<BooleanScalar>(false)}) {\n+    ASSERT_OK_AND_ASSIGN(Datum actual, CallFunction(func_name, {Datum(scalar), array}));\n \n-  void TestChunkedArrayBinary(const BinaryKernelFunc& kernel,\n-                              const std::shared_ptr<ChunkedArray>& left,\n-                              const std::shared_ptr<ChunkedArray>& right,\n-                              const std::shared_ptr<ChunkedArray>& expected) {\n-    ASSERT_OK_AND_ASSIGN(Datum result, kernel(left, right, &ctx_));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-    AssertChunkedEquivalent(*expected, *result_ca);\n-\n-    ASSERT_OK_AND_ASSIGN(result, kernel(right, left, &ctx_));\n-    ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-    result_ca = result.chunked_array();\n-    AssertChunkedEquivalent(*expected, *result_ca);\n-  }\n+    ASSERT_OK_AND_ASSIGN(auto constant_array,\n+                         MakeArrayFromScalar(*scalar, array.length()));\n \n-  void TestBinaryKernel(const BinaryKernelFunc& kernel,\n-                        const std::shared_ptr<Array>& left,\n-                        const std::shared_ptr<Array>& right,\n-                        const std::shared_ptr<Array>& expected) {\n-    TestArrayBinary(kernel, left, right, expected);\n-    TestArrayBinary(kernel, left->Slice(1), right->Slice(1), expected->Slice(1));\n-\n-    // ChunkedArray\n-    auto cleft = std::make_shared<ChunkedArray>(ArrayVector{left, left->Slice(1)});\n-    auto cright = std::make_shared<ChunkedArray>(ArrayVector{right, right->Slice(1)});\n-    auto cexpected =\n-        std::make_shared<ChunkedArray>(ArrayVector{expected, expected->Slice(1)});\n-    TestChunkedArrayBinary(kernel, cleft, cright, cexpected);\n-\n-    // ChunkedArray with different chunks\n-    cleft = std::make_shared<ChunkedArray>(ArrayVector{\n-        left->Slice(0, 1), left->Slice(1), left->Slice(1, 1), left->Slice(2)});\n-    TestChunkedArrayBinary(kernel, cleft, cright, cexpected);\n-  }\n+    ASSERT_OK_AND_ASSIGN(Datum expected,\n+                         CallFunction(func_name, {Datum(constant_array), array}));\n+    AssertDatumsEqual(expected, actual);\n \n-  void TestBinaryKernelPropagate(const BinaryKernelFunc& kernel,\n-                                 const std::vector<bool>& left,\n-                                 const std::vector<bool>& right,\n-                                 const std::vector<bool>& expected,\n-                                 const std::vector<bool>& expected_nulls) {\n-    auto type = boolean();\n-    TestBinaryKernel(kernel, _MakeArray<BooleanType, bool>(type, left, {}),\n-                     _MakeArray<BooleanType, bool>(type, right, {}),\n-                     _MakeArray<BooleanType, bool>(type, expected, {}));\n-\n-    TestBinaryKernel(kernel, _MakeArray<BooleanType, bool>(type, left, left),\n-                     _MakeArray<BooleanType, bool>(type, right, right),\n-                     _MakeArray<BooleanType, bool>(type, expected, expected_nulls));\n+    ASSERT_OK_AND_ASSIGN(actual, CallFunction(func_name, {array, Datum(scalar)}));\n+    ASSERT_OK_AND_ASSIGN(expected,\n+                         CallFunction(func_name, {array, Datum(constant_array)}));\n+    AssertDatumsEqual(expected, actual);\n   }\n-\n- protected:\n-  ExecContext ctx_;\n-};\n-\n-TEST_F(TestBooleanKernel, Invert) {\n-  std::vector<bool> values1 = {true, false, true, false};\n-  std::vector<bool> values2 = {false, true, false, true};\n-\n-  auto type = boolean();\n-  auto a1 = _MakeArray<BooleanType, bool>(type, values1, {true, true, true, false});\n-  auto a2 = _MakeArray<BooleanType, bool>(type, values2, {true, true, true, false});\n-\n-  // Plain array\n-  ASSERT_OK_AND_ASSIGN(Datum result, Invert(a1));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  ASSERT_ARRAYS_EQUAL(*a2, *result.make_array());\n-\n-  // Array with offset\n-  ASSERT_OK_AND_ASSIGN(result, Invert(a1->Slice(1)));\n-  ASSERT_EQ(Datum::ARRAY, result.kind());\n-  ASSERT_ARRAYS_EQUAL(*a2->Slice(1), *result.make_array());\n-\n-  // ChunkedArray\n-  std::vector<std::shared_ptr<Array>> ca1_arrs = {a1, a1->Slice(1)};\n-  auto ca1 = std::make_shared<ChunkedArray>(ca1_arrs);\n-  std::vector<std::shared_ptr<Array>> ca2_arrs = {a2, a2->Slice(1)};\n-  auto ca2 = std::make_shared<ChunkedArray>(ca2_arrs);\n-  ASSERT_OK_AND_ASSIGN(result, Invert(ca1));\n-  ASSERT_EQ(Datum::CHUNKED_ARRAY, result.kind());\n-  std::shared_ptr<ChunkedArray> result_ca = result.chunked_array();\n-\n-  // Contiguous preallocation, so a single output chunk even though there were\n-  // two input chunks\n-  ASSERT_EQ(1, result_ca->num_chunks());\n-  AssertChunkedEquivalent(*ca2, *result_ca);\n }\n \n-TEST_F(TestBooleanKernel, InvertEmptyArray) {\n-  std::vector<std::shared_ptr<Buffer>> data_buffers(2);\n-  Datum input;\n-  input.value = ArrayData::Make(boolean(), 0 /* length */, std::move(data_buffers),\n-                                0 /* null_count */);\n-\n-  ASSERT_OK_AND_ASSIGN(Datum result, Invert(input));\n-  ASSERT_ARRAYS_EQUAL(*input.make_array(), *result.make_array());\n+TEST(TestBooleanKernel, Invert) {\n+  auto arr =\n+      ArrayFromJSON(boolean(), \"[true, false, true, null, false, true, false, null]\");\n+  auto expected =\n+      ArrayFromJSON(boolean(), \"[false, true, false, null, true, false, true, null]\");\n+  CheckScalarUnary(\"invert\", arr, expected);\n }\n \n-TEST_F(TestBooleanKernel, BinaryOpOnEmptyArray) {\n-  auto type = boolean();\n-  std::vector<std::shared_ptr<Buffer>> data_buffers(2);\n-  Datum input;\n-  input.value = ArrayData::Make(boolean(), 0 /* length */, std::move(data_buffers),\n-                                0 /* null_count */);\n-\n-  ASSERT_OK_AND_ASSIGN(Datum result, And(input, input));\n-  // Result should be empty as well.\n-  ASSERT_ARRAYS_EQUAL(*input.make_array(), *result.make_array());\n+TEST(TestBooleanKernel, And) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[true, false, null, false, null,  null]\");\n+  // CheckScalarBinary(\"and\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and\", left);\n }\n \n-TEST_F(TestBooleanKernel, And) {\n-  std::vector<bool> values1 = {true, false, true, false, true, true};\n-  std::vector<bool> values2 = {true, true, false, false, true, false};\n-  std::vector<bool> values3 = {true, false, false, false, true, false};\n-  TestBinaryKernelPropagate(And, values1, values2, values3, values3);\n+TEST(TestBooleanKernel, Or) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[true, true,  null, false, null,  null]\");\n+  CheckScalarBinary(\"or\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"or\", left);\n }\n \n-TEST_F(TestBooleanKernel, Or) {\n-  std::vector<bool> values1 = {true, false, true, false, true, true};\n-  std::vector<bool> values2 = {true, true, false, false, true, false};\n-  std::vector<bool> values3 = {true, true, true, false, true, true};\n-  std::vector<bool> values3_nulls = {true, false, false, false, true, false};\n-  TestBinaryKernelPropagate(Or, values1, values2, values3, values3_nulls);\n+TEST(TestBooleanKernel, Xor) {\n+  auto left = ArrayFromJSON(boolean(), \"    [true,  true,  true, false, false, null]\");\n+  auto right = ArrayFromJSON(boolean(), \"   [true,  false, null, false, null,  null]\");\n+  auto expected = ArrayFromJSON(boolean(), \"[false, true,  null, false, null,  null]\");\n+  CheckScalarBinary(\"xor\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"xor\", left);\n }\n \n-TEST_F(TestBooleanKernel, Xor) {\n-  std::vector<bool> values1 = {true, false, true, false, true, true};\n-  std::vector<bool> values2 = {true, true, false, false, true, false};\n-  std::vector<bool> values3 = {false, true, true, false, false, true};\n-  std::vector<bool> values3_nulls = {true, false, false, false, true, false};\n-  TestBinaryKernelPropagate(Xor, values1, values2, values3, values3_nulls);\n+TEST(TestBooleanKernel, AndNot) {\n+  auto left = ArrayFromJSON(\n+      boolean(), \"[true,  true,  true, false, false, false, null, null,  null]\");\n+  auto right = ArrayFromJSON(\n+      boolean(), \"[true,  false, null, true,  false, null,  true, false, null]\");\n+  auto expected = ArrayFromJSON(\n+      boolean(), \"[false, true,  null, false, false, null,  null, null,  null]\");\n+  CheckScalarBinary(\"and_not\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and_not\", left);\n }\n \n-TEST_F(TestBooleanKernel, KleeneAnd) {\n+TEST(TestBooleanKernel, KleeneAnd) {\n   auto left = ArrayFromJSON(boolean(), \"    [true, true,  true, false, false, null]\");\n   auto right = ArrayFromJSON(boolean(), \"   [true, false, null, false, null,  null]\");\n   auto expected = ArrayFromJSON(boolean(), \"[true, false, null, false, false, null]\");\n-  TestBinaryKernel(KleeneAnd, left, right, expected);\n+  CheckScalarBinary(\"and_kleene\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and_kleene\", left);\n \n   left = ArrayFromJSON(boolean(), \"    [true, true,  false, null, null]\");\n   right = ArrayFromJSON(boolean(), \"   [true, false, false, true, false]\");\n   expected = ArrayFromJSON(boolean(), \"[true, false, false, null, false]\");\n-  TestBinaryKernel(KleeneAnd, left, right, expected);\n+  CheckScalarBinary(\"and_kleene\", left, right, expected);\n+  CheckBooleanScalarArrayBinary(\"and_kleene\", left);\n\nReview comment:\n       Ah, I see. Yes they're the same input values (the full truth table) just with a the different call signatures\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T15:37:53.526+0000",
                    "updated": "2020-11-23T15:37:53.526+0000",
                    "started": "2020-11-23T15:37:53.526+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515620",
                    "issueId": "13341864"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/worklog/515653",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz closed pull request #8728:\nURL: https://github.com/apache/arrow/pull/8728\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-23T16:45:06.117+0000",
                    "updated": "2020-11-23T16:45:06.117+0000",
                    "started": "2020-11-23T16:45:06.117+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "515653",
                    "issueId": "13341864"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 9600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@35fb73e2[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@685f512a[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@67274072[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@75e39bbd[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@571511ad[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@34ed66ef[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@699484d0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@c3d42c[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7fa425e0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@20a1eee5[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6d5e4c25[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@73a28716[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 9600,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Nov 23 16:44:56 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-11-23T16:44:56.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10669/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-11-20T22:02:43.000+0000",
        "updated": "2020-11-23T16:45:07.000+0000",
        "timeoriginalestimate": null,
        "description": "Currently only Invert supports scalar arguments",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 9600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Compute] Support Scalar inputs to boolean kernels",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13341864/comment/17237492",
                    "id": "17237492",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 8728\n[https://github.com/apache/arrow/pull/8728]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-11-23T16:44:56.319+0000",
                    "updated": "2020-11-23T16:44:56.319+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0ksww:",
        "customfield_12314139": null
    }
}