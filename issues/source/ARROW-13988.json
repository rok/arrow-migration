{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13400878",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878",
    "key": "ARROW-13988",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350591",
                "id": "12350591",
                "description": "",
                "name": "7.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-02-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "kernel",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 15000,
            "total": 15000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 15000,
            "total": 15000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13988/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 25,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/666552",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#issuecomment-946171449\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-18T21:14:25.863+0000",
                    "updated": "2021-10-18T21:14:25.863+0000",
                    "started": "2021-10-18T21:14:25.863+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "666552",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/667419",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r732380062\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n\nReview comment:\n       Wouldn't the `Resize` operation only be needed if `mins_[g]` was not allocated right before it? The allocation is of the same size as the resize operation.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-20T02:59:51.137+0000",
                    "updated": "2021-10-20T02:59:51.137+0000",
                    "started": "2021-10-20T02:59:51.137+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "667419",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/667420",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r732380632\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n\nReview comment:\n       missing a `std::move(null_bitmap)` for `mins`?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-20T03:01:31.813+0000",
                    "updated": "2021-10-20T03:01:31.813+0000",
                    "started": "2021-10-20T03:01:31.812+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "667420",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/667710",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r732737804\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n\nReview comment:\n       Sure, but rather than branching, it's easier to just always call resize. It's effectively a no-op anyways: https://github.com/apache/arrow/blob/29892ba5c556072c8ed86b156d2a18d560b2ebff/cpp/src/arrow/memory_pool.cc#L707-L746\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n\nReview comment:\n       That would be an error since then null_bitmap wouldn't be available for maxes.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-20T12:46:46.293+0000",
                    "updated": "2021-10-20T12:46:46.293+0000",
                    "started": "2021-10-20T12:46:46.293+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "667710",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/667766",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r732799239\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n\nReview comment:\n       Oops, I thought they were different variables.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-20T13:50:39.703+0000",
                    "updated": "2021-10-20T13:50:39.703+0000",
                    "started": "2021-10-20T13:50:39.703+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "667766",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/667768",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#issuecomment-947688493\n\n\n   This PR LGTM.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-10-20T13:51:39.538+0000",
                    "updated": "2021-10-20T13:51:39.538+0000",
                    "started": "2021-10-20T13:51:39.538+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "667768",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/674262",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r741473297\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -603,8 +603,9 @@ struct GroupedValueTraits<BooleanType> {\n };\n \n template <typename Type, typename ConsumeValue, typename ConsumeNull>\n-void VisitGroupedValues(const ExecBatch& batch, ConsumeValue&& valid_func,\n-                        ConsumeNull&& null_func) {\n+typename arrow::internal::call_traits::enable_if_return<ConsumeValue, void>::type\n\nReview comment:\n       The `enable_if_return` only checks for `ConsumeValue` so `ConsumeNull` can be non-conformant, but ok. Obviously this is done deliberately to allow compile-time dispatching for the visitors. I think this falls under the \"TODO: revise/generalize visitor patterns\".\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    int64_t total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        total_length += values[i]->size();\n+      }\n+      if (total_length > std::numeric_limits<offset_type>::max()) {\n+        return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                               \" cast to large_ variant of type\");\n\nReview comment:\n       If `offset_type` is of type `int64_t` then this limit check will never trigger and will allow overflow:\r\n   ```c++\r\n   if (BitUtil::GetBit(null_bitmap, i)) {\r\n       auto value_size = values[i]->size();\r\n       if ((total_length > 0) && (value_size > (std::numeric_limits<offset_type>::max() - total_length)) {\r\n           return Status::Invalid(...);\r\n       }\r\n       total_length += value_size;\r\n   }\r\n   ```\r\n   \r\n   Or use [safe-math.h utils](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n\nReview comment:\n       If the `Resize()` operation reduces the number of groups, `std::vector<>.resize()` does not triggers an exception. [In `Notes` docs](https://en.cppreference.com/w/cpp/container/vector/resize) state that capacity is never reduced even if requested, so maybe add a `DCHECK_GT(added_groups, 0);`.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-02T23:22:25.897+0000",
                    "updated": "2021-11-02T23:22:25.897+0000",
                    "started": "2021-11-02T23:22:25.896+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674262",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/674264",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r741528772\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n\nReview comment:\n       We don't actually care about reducing capacity, so long as the vector is at least big enough. (Also I don't think it's possible to reduce capacity; the number of groups can only ever increase.)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-02T23:24:35.826+0000",
                    "updated": "2021-11-02T23:24:35.826+0000",
                    "started": "2021-11-02T23:24:35.826+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674264",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/674265",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r741528938\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    int64_t total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        total_length += values[i]->size();\n+      }\n+      if (total_length > std::numeric_limits<offset_type>::max()) {\n+        return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                               \" cast to large_ variant of type\");\n\nReview comment:\n       Frankly we're awful about checking for overflow in general; most kernel code is like this and only checks for the case of overflowing int32_t. That said I'll add the check here.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-02T23:25:09.309+0000",
                    "updated": "2021-11-02T23:25:09.309+0000",
                    "started": "2021-11-02T23:25:09.308+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674265",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/674884",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r742267291\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    int64_t total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        total_length += values[i]->size();\n+      }\n+      if (total_length > std::numeric_limits<offset_type>::max()) {\n+        return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                               \" cast to large_ variant of type\");\n\nReview comment:\n       Added an overflow check.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-03T19:30:51.196+0000",
                    "updated": "2021-11-03T19:30:51.196+0000",
                    "started": "2021-11-03T19:30:51.196+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "674884",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/675111",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "edponce commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r741473297\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -603,8 +603,9 @@ struct GroupedValueTraits<BooleanType> {\n };\n \n template <typename Type, typename ConsumeValue, typename ConsumeNull>\n-void VisitGroupedValues(const ExecBatch& batch, ConsumeValue&& valid_func,\n-                        ConsumeNull&& null_func) {\n+typename arrow::internal::call_traits::enable_if_return<ConsumeValue, void>::type\n\nReview comment:\n       The `enable_if_return` only checks for `ConsumeValue` so `ConsumeNull` can be non-conformant, but ok. Obviously this is done deliberately to allow compile-time dispatching for the visitors. I think this falls under the \"TODO: revise/generalize visitor patterns\".\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    int64_t total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        total_length += values[i]->size();\n+      }\n+      if (total_length > std::numeric_limits<offset_type>::max()) {\n+        return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                               \" cast to large_ variant of type\");\n\nReview comment:\n       If `offset_type` is of type `int64_t` then this limit check will never trigger and will allow overflow:\r\n   ```c++\r\n   if (BitUtil::GetBit(null_bitmap, i)) {\r\n       auto value_size = values[i]->size();\r\n       if ((total_length > 0) && (value_size > (std::numeric_limits<offset_type>::max() - total_length)) {\r\n           return Status::Invalid(...);\r\n       }\r\n       total_length += value_size;\r\n   }\r\n   ```\r\n   \r\n   Or use [safe-math.h utils](https://github.com/apache/arrow/blob/master/cpp/src/arrow/vendored/portable-snippets/safe-math.h).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n\nReview comment:\n       If the `Resize()` operation reduces the number of groups, `std::vector<>.resize()` does not triggers an exception. [In `Notes` docs](https://en.cppreference.com/w/cpp/container/vector/resize) state that capacity is never reduced even if requested, so maybe add a `DCHECK_GT(added_groups, 0);`.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-04T00:12:53.741+0000",
                    "updated": "2021-11-04T00:12:53.741+0000",
                    "started": "2021-11-04T00:12:53.741+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "675111",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/675164",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r741528772\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n\nReview comment:\n       We don't actually care about reducing capacity, so long as the vector is at least big enough. (Also I don't think it's possible to reduce capacity; the number of groups can only ever increase.)\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    int64_t total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        total_length += values[i]->size();\n+      }\n+      if (total_length > std::numeric_limits<offset_type>::max()) {\n+        return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                               \" cast to large_ variant of type\");\n\nReview comment:\n       Frankly we're awful about checking for overflow in general; most kernel code is like this and only checks for the case of overflowing int32_t. That said I'll add the check here.\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    int64_t total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        total_length += values[i]->size();\n+      }\n+      if (total_length > std::numeric_limits<offset_type>::max()) {\n+        return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                               \" cast to large_ variant of type\");\n\nReview comment:\n       Added an overflow check.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-04T00:18:57.548+0000",
                    "updated": "2021-11-04T00:18:57.548+0000",
                    "started": "2021-11-04T00:18:57.548+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "675164",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/675670",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r742267291\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    int64_t total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        total_length += values[i]->size();\n+      }\n+      if (total_length > std::numeric_limits<offset_type>::max()) {\n+        return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                               \" cast to large_ variant of type\");\n\nReview comment:\n       Added an overflow check.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-04T01:15:24.070+0000",
                    "updated": "2021-11-04T01:15:24.070+0000",
                    "started": "2021-11-04T01:15:24.070+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "675670",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/675888",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r742267291\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1677,6 +1703,177 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    int64_t total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        total_length += values[i]->size();\n+      }\n+      if (total_length > std::numeric_limits<offset_type>::max()) {\n+        return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                               \" cast to large_ variant of type\");\n\nReview comment:\n       Added an overflow check.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-04T01:38:26.058+0000",
                    "updated": "2021-11-04T01:38:26.058+0000",
                    "started": "2021-11-04T01:38:26.058+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "675888",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/678562",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r744850086\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1658,6 +1685,181 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    DCHECK_GE(added_groups, 0);\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    offset_type total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        if (values[i]->size() > std::numeric_limits<offset_type>::max() ||\n+            arrow::internal::AddWithOverflow(total_length,\n+                                             static_cast<offset_type>(values[i]->size()),\n+                                             &total_length)) {\n+          return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                                 \" cast to large_ variant of type\");\n+        }\n+      }\n+      offsets[i] = total_length;\n+    }\n+    ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(total_length, ctx_->memory_pool()));\n+    int64_t offset = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const auto& value = values[i];\n+        std::memcpy(data->mutable_data() + offset, value->data(), value->size());\n+        offset += value->size();\n+      }\n+    }\n+    array->buffers[1] = std::move(raw_offsets);\n+    array->buffers.push_back(std::move(data));\n+    return Status::OK();\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_same<T, FixedSizeBinaryType, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    const int32_t slot_width =\n+        checked_cast<const FixedSizeBinaryType&>(*array->type).byte_width();\n+    int64_t total_length = values.size() * slot_width;\n+    ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(total_length, ctx_->memory_pool()));\n+    int64_t offset = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const auto& value = values[i];\n+        std::memcpy(data->mutable_data() + offset, value->data(), slot_width);\n+      } else {\n+        std::memset(data->mutable_data() + offset, 0x00, slot_width);\n+      }\n+      offset += slot_width;\n+    }\n+    array->buffers[1] = std::move(data);\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override {\n+    return struct_({field(\"min\", type_), field(\"max\", type_)});\n+  }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_;\n+  std::vector<std::shared_ptr<ResizableBuffer>> mins_, maxes_;\n\nReview comment:\n       I wonder if something like `util::optional<std::string>` would be faster. The vector shouldn't be very large, and `std::string` often has small string optimization which could inline at least some of the values directly into the vector (as opposed to two indirections).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-08T15:44:06.561+0000",
                    "updated": "2021-11-08T15:44:06.561+0000",
                    "started": "2021-11-08T15:44:06.560+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "678562",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/678563",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r744850086\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1658,6 +1685,181 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    DCHECK_GE(added_groups, 0);\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    offset_type total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        if (values[i]->size() > std::numeric_limits<offset_type>::max() ||\n+            arrow::internal::AddWithOverflow(total_length,\n+                                             static_cast<offset_type>(values[i]->size()),\n+                                             &total_length)) {\n+          return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                                 \" cast to large_ variant of type\");\n+        }\n+      }\n+      offsets[i] = total_length;\n+    }\n+    ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(total_length, ctx_->memory_pool()));\n+    int64_t offset = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const auto& value = values[i];\n+        std::memcpy(data->mutable_data() + offset, value->data(), value->size());\n+        offset += value->size();\n+      }\n+    }\n+    array->buffers[1] = std::move(raw_offsets);\n+    array->buffers.push_back(std::move(data));\n+    return Status::OK();\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_same<T, FixedSizeBinaryType, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    const int32_t slot_width =\n+        checked_cast<const FixedSizeBinaryType&>(*array->type).byte_width();\n+    int64_t total_length = values.size() * slot_width;\n+    ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(total_length, ctx_->memory_pool()));\n+    int64_t offset = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const auto& value = values[i];\n+        std::memcpy(data->mutable_data() + offset, value->data(), slot_width);\n+      } else {\n+        std::memset(data->mutable_data() + offset, 0x00, slot_width);\n+      }\n+      offset += slot_width;\n+    }\n+    array->buffers[1] = std::move(data);\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override {\n+    return struct_({field(\"min\", type_), field(\"max\", type_)});\n+  }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_;\n+  std::vector<std::shared_ptr<ResizableBuffer>> mins_, maxes_;\n\nReview comment:\n       I wonder if something like `std::vector<util::optional<std::string>>` would be faster. The vector shouldn't be very large, and `std::string` often has small string optimization which could inline at least some of the values directly into the vector (as opposed to two indirections).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-08T15:44:19.557+0000",
                    "updated": "2021-11-08T15:44:19.557+0000",
                    "started": "2021-11-08T15:44:19.557+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "678563",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/678742",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r745088219\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1658,6 +1685,181 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    DCHECK_GE(added_groups, 0);\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    offset_type total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        if (values[i]->size() > std::numeric_limits<offset_type>::max() ||\n+            arrow::internal::AddWithOverflow(total_length,\n+                                             static_cast<offset_type>(values[i]->size()),\n+                                             &total_length)) {\n+          return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                                 \" cast to large_ variant of type\");\n+        }\n+      }\n+      offsets[i] = total_length;\n+    }\n+    ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(total_length, ctx_->memory_pool()));\n+    int64_t offset = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const auto& value = values[i];\n+        std::memcpy(data->mutable_data() + offset, value->data(), value->size());\n+        offset += value->size();\n+      }\n+    }\n+    array->buffers[1] = std::move(raw_offsets);\n+    array->buffers.push_back(std::move(data));\n+    return Status::OK();\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_same<T, FixedSizeBinaryType, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    const int32_t slot_width =\n+        checked_cast<const FixedSizeBinaryType&>(*array->type).byte_width();\n+    int64_t total_length = values.size() * slot_width;\n+    ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(total_length, ctx_->memory_pool()));\n+    int64_t offset = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const auto& value = values[i];\n+        std::memcpy(data->mutable_data() + offset, value->data(), slot_width);\n+      } else {\n+        std::memset(data->mutable_data() + offset, 0x00, slot_width);\n+      }\n+      offset += slot_width;\n+    }\n+    array->buffers[1] = std::move(data);\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override {\n+    return struct_({field(\"min\", type_), field(\"max\", type_)});\n+  }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_;\n+  std::vector<std::shared_ptr<ResizableBuffer>> mins_, maxes_;\n\nReview comment:\n       I'll benchmark the two. I considered std::vector<optional<string>>> originally but decided on this to keep all the scratch space allocated by Arrow (I didn't consider performance there).\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1658,6 +1685,181 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    DCHECK_GE(added_groups, 0);\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    offset_type total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        if (values[i]->size() > std::numeric_limits<offset_type>::max() ||\n+            arrow::internal::AddWithOverflow(total_length,\n+                                             static_cast<offset_type>(values[i]->size()),\n+                                             &total_length)) {\n+          return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                                 \" cast to large_ variant of type\");\n+        }\n+      }\n+      offsets[i] = total_length;\n+    }\n+    ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(total_length, ctx_->memory_pool()));\n+    int64_t offset = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const auto& value = values[i];\n+        std::memcpy(data->mutable_data() + offset, value->data(), value->size());\n+        offset += value->size();\n+      }\n+    }\n+    array->buffers[1] = std::move(raw_offsets);\n+    array->buffers.push_back(std::move(data));\n+    return Status::OK();\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_same<T, FixedSizeBinaryType, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    const int32_t slot_width =\n+        checked_cast<const FixedSizeBinaryType&>(*array->type).byte_width();\n+    int64_t total_length = values.size() * slot_width;\n+    ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(total_length, ctx_->memory_pool()));\n+    int64_t offset = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const auto& value = values[i];\n+        std::memcpy(data->mutable_data() + offset, value->data(), slot_width);\n+      } else {\n+        std::memset(data->mutable_data() + offset, 0x00, slot_width);\n+      }\n+      offset += slot_width;\n+    }\n+    array->buffers[1] = std::move(data);\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override {\n+    return struct_({field(\"min\", type_), field(\"max\", type_)});\n+  }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_;\n+  std::vector<std::shared_ptr<ResizableBuffer>> mins_, maxes_;\n\nReview comment:\n       I'll benchmark the two. I considered `std::vector<optional<string>>>` originally but decided on this to keep all the scratch space allocated by Arrow (I didn't consider performance there).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-08T20:59:37.515+0000",
                    "updated": "2021-11-08T20:59:37.515+0000",
                    "started": "2021-11-08T20:59:37.515+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "678742",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/679135",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r745780242\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1658,6 +1685,181 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    DCHECK_GE(added_groups, 0);\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < util::string_view(*mins_[g])) {\n+            if (!mins_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  mins_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(mins_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(mins_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          if (!maxes_[g] || val > util::string_view(*maxes_[g])) {\n+            if (!maxes_[g]) {\n+              ARROW_ASSIGN_OR_RAISE(\n+                  maxes_[g], AllocateResizableBuffer(val.size(), ctx_->memory_pool()));\n+            }\n+            RETURN_NOT_OK(maxes_[g]->Resize(val.size(), /*shrink_to_fit=*/false));\n+            std::memcpy(maxes_[g]->mutable_data(), val.data(), val.size());\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] &&\n+           util::string_view(*mins_[*g]) > util::string_view(*other->mins_[other_g]))) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] ||\n+          (maxes_[*g] && other->maxes_[other_g] &&\n+           util::string_view(*maxes_[*g]) < util::string_view(*other->maxes_[other_g]))) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    offset_type total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        if (values[i]->size() > std::numeric_limits<offset_type>::max() ||\n+            arrow::internal::AddWithOverflow(total_length,\n+                                             static_cast<offset_type>(values[i]->size()),\n+                                             &total_length)) {\n+          return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                                 \" cast to large_ variant of type\");\n+        }\n+      }\n+      offsets[i] = total_length;\n+    }\n+    ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(total_length, ctx_->memory_pool()));\n+    int64_t offset = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const auto& value = values[i];\n+        std::memcpy(data->mutable_data() + offset, value->data(), value->size());\n+        offset += value->size();\n+      }\n+    }\n+    array->buffers[1] = std::move(raw_offsets);\n+    array->buffers.push_back(std::move(data));\n+    return Status::OK();\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_same<T, FixedSizeBinaryType, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<std::shared_ptr<ResizableBuffer>>& values) {\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    const int32_t slot_width =\n+        checked_cast<const FixedSizeBinaryType&>(*array->type).byte_width();\n+    int64_t total_length = values.size() * slot_width;\n+    ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(total_length, ctx_->memory_pool()));\n+    int64_t offset = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const auto& value = values[i];\n+        std::memcpy(data->mutable_data() + offset, value->data(), slot_width);\n+      } else {\n+        std::memset(data->mutable_data() + offset, 0x00, slot_width);\n+      }\n+      offset += slot_width;\n+    }\n+    array->buffers[1] = std::move(data);\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override {\n+    return struct_({field(\"min\", type_), field(\"max\", type_)});\n+  }\n+\n+  ExecContext* ctx_;\n+  int64_t num_groups_;\n+  std::vector<std::shared_ptr<ResizableBuffer>> mins_, maxes_;\n\nReview comment:\n       Updated the docs, and benchmarked `optional<string>` - it's about the same speed and the code is cleaner so I went with this. A quick profile shows most of the time spent in string comparisons.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T16:16:31.881+0000",
                    "updated": "2021-11-09T16:16:31.881+0000",
                    "started": "2021-11-09T16:16:31.880+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679135",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/679143",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#issuecomment-964317263\n\n\n   Hmm, there are a bunch of CI failures now.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T16:28:18.875+0000",
                    "updated": "2021-11-09T16:28:18.875+0000",
                    "started": "2021-11-09T16:28:18.875+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679143",
                    "issueId": "13400878"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/worklog/679217",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11452:\nURL: https://github.com/apache/arrow/pull/11452#discussion_r745863925\n\n\n\n##########\nFile path: cpp/src/arrow/compute/kernels/hash_aggregate.cc\n##########\n@@ -1658,6 +1686,178 @@ struct GroupedMinMaxImpl final : public GroupedAggregator {\n   ScalarAggregateOptions options_;\n };\n \n+// For binary-like types\n+// In principle, FixedSizeBinary could use base implementation\n+template <typename Type>\n+struct GroupedMinMaxImpl<Type,\n+                         enable_if_t<is_base_binary_type<Type>::value ||\n+                                     std::is_same<Type, FixedSizeBinaryType>::value>>\n+    final : public GroupedAggregator {\n+  using Allocator = arrow::stl::allocator<char>;\n+  using StringType = std::basic_string<char, std::char_traits<char>, Allocator>;\n+\n+  Status Init(ExecContext* ctx, const std::vector<ValueDescr>&,\n+              const FunctionOptions* options) override {\n+    ctx_ = ctx;\n+    allocator_ = Allocator(ctx->memory_pool());\n+    options_ = *checked_cast<const ScalarAggregateOptions*>(options);\n+    // type_ initialized by MinMaxInit\n+    has_values_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    has_nulls_ = TypedBufferBuilder<bool>(ctx->memory_pool());\n+    return Status::OK();\n+  }\n+\n+  Status Resize(int64_t new_num_groups) override {\n+    auto added_groups = new_num_groups - num_groups_;\n+    DCHECK_GE(added_groups, 0);\n+    num_groups_ = new_num_groups;\n+    mins_.resize(new_num_groups);\n+    maxes_.resize(new_num_groups);\n+    RETURN_NOT_OK(has_values_.Append(added_groups, false));\n+    RETURN_NOT_OK(has_nulls_.Append(added_groups, false));\n+    return Status::OK();\n+  }\n+\n+  Status Consume(const ExecBatch& batch) override {\n+    return VisitGroupedValues<Type>(\n+        batch,\n+        [&](uint32_t g, util::string_view val) {\n+          if (!mins_[g] || val < *mins_[g]) {\n+            mins_[g].emplace(val.data(), val.size(), allocator_);\n+          }\n+          if (!maxes_[g] || val > *maxes_[g]) {\n+            maxes_[g].emplace(val.data(), val.size(), allocator_);\n+          }\n+          BitUtil::SetBit(has_values_.mutable_data(), g);\n+          return Status::OK();\n+        },\n+        [&](uint32_t g) {\n+          BitUtil::SetBit(has_nulls_.mutable_data(), g);\n+          return Status::OK();\n+        });\n+  }\n+\n+  Status Merge(GroupedAggregator&& raw_other,\n+               const ArrayData& group_id_mapping) override {\n+    auto other = checked_cast<GroupedMinMaxImpl*>(&raw_other);\n+    auto g = group_id_mapping.GetValues<uint32_t>(1);\n+    for (uint32_t other_g = 0; static_cast<int64_t>(other_g) < group_id_mapping.length;\n+         ++other_g, ++g) {\n+      if (!mins_[*g] ||\n+          (mins_[*g] && other->mins_[other_g] && *mins_[*g] > *other->mins_[other_g])) {\n+        mins_[*g] = std::move(other->mins_[other_g]);\n+      }\n+      if (!maxes_[*g] || (maxes_[*g] && other->maxes_[other_g] &&\n+                          *maxes_[*g] < *other->maxes_[other_g])) {\n+        maxes_[*g] = std::move(other->maxes_[other_g]);\n+      }\n+\n+      if (BitUtil::GetBit(other->has_values_.data(), other_g)) {\n+        BitUtil::SetBit(has_values_.mutable_data(), *g);\n+      }\n+      if (BitUtil::GetBit(other->has_nulls_.data(), other_g)) {\n+        BitUtil::SetBit(has_nulls_.mutable_data(), *g);\n+      }\n+    }\n+    return Status::OK();\n+  }\n+\n+  Result<Datum> Finalize() override {\n+    // aggregation for group is valid if there was at least one value in that group\n+    ARROW_ASSIGN_OR_RAISE(auto null_bitmap, has_values_.Finish());\n+\n+    if (!options_.skip_nulls) {\n+      // ... and there were no nulls in that group\n+      ARROW_ASSIGN_OR_RAISE(auto has_nulls, has_nulls_.Finish());\n+      arrow::internal::BitmapAndNot(null_bitmap->data(), 0, has_nulls->data(), 0,\n+                                    num_groups_, 0, null_bitmap->mutable_data());\n+    }\n+\n+    auto mins = ArrayData::Make(type_, num_groups_, {null_bitmap, nullptr});\n+    auto maxes = ArrayData::Make(type_, num_groups_, {std::move(null_bitmap), nullptr});\n+    RETURN_NOT_OK(MakeOffsetsValues(mins.get(), mins_));\n+    RETURN_NOT_OK(MakeOffsetsValues(maxes.get(), maxes_));\n+    return ArrayData::Make(out_type(), num_groups_, {nullptr},\n+                           {std::move(mins), std::move(maxes)});\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_base_binary<T, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<util::optional<StringType>>& values) {\n+    using offset_type = typename T::offset_type;\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto raw_offsets,\n+        AllocateBuffer((1 + values.size()) * sizeof(offset_type), ctx_->memory_pool()));\n+    offset_type* offsets = reinterpret_cast<offset_type*>(raw_offsets->mutable_data());\n+    offsets[0] = 0;\n+    offsets++;\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    offset_type total_length = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const util::optional<StringType>& value = values[i];\n+        DCHECK(value.has_value());\n+        if (value->size() >\n+                static_cast<size_t>(std::numeric_limits<offset_type>::max()) ||\n+            arrow::internal::AddWithOverflow(\n+                total_length, static_cast<offset_type>(value->size()), &total_length)) {\n+          return Status::Invalid(\"Result is too large to fit in \", *array->type,\n+                                 \" cast to large_ variant of type\");\n+        }\n+      }\n+      offsets[i] = total_length;\n+    }\n+    ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(total_length, ctx_->memory_pool()));\n+    int64_t offset = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const util::optional<StringType>& value = values[i];\n+        DCHECK(value.has_value());\n+        std::memcpy(data->mutable_data() + offset, value->data(), value->size());\n+        offset += value->size();\n+      }\n+    }\n+    array->buffers[1] = std::move(raw_offsets);\n+    array->buffers.push_back(std::move(data));\n+    return Status::OK();\n+  }\n+\n+  template <typename T = Type>\n+  enable_if_same<T, FixedSizeBinaryType, Status> MakeOffsetsValues(\n+      ArrayData* array, const std::vector<util::optional<StringType>>& values) {\n+    const uint8_t* null_bitmap = array->buffers[0]->data();\n+    const int32_t slot_width =\n+        checked_cast<const FixedSizeBinaryType&>(*array->type).byte_width();\n+    int64_t total_length = values.size() * slot_width;\n+    ARROW_ASSIGN_OR_RAISE(auto data, AllocateBuffer(total_length, ctx_->memory_pool()));\n+    int64_t offset = 0;\n+    for (size_t i = 0; i < values.size(); i++) {\n+      if (BitUtil::GetBit(null_bitmap, i)) {\n+        const util::optional<StringType>& value = values[i];\n+        DCHECK(value.has_value());\n+        std::memcpy(data->mutable_data() + offset, value->data(), slot_width);\n+      } else {\n+        std::memset(data->mutable_data() + offset, 0x00, slot_width);\n+      }\n+      offset += slot_width;\n+    }\n+    array->buffers[1] = std::move(data);\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<DataType> out_type() const override {\n+    return struct_({field(\"min\", type_), field(\"max\", type_)});\n+  }\n+\n+  ExecContext* ctx_;\n+  Allocator allocator_;\n+  int64_t num_groups_;\n+  std::vector<util::optional<StringType>> mins_, maxes_;\n\nReview comment:\n       Now that I think of it, perhaps this can just be `std::vector<std::string>`. Basically `has_values_[g]` is true iff both `mins_[g]` and `maxes_[g]` have already been set. So the `util::optional` wrapper is redundant.\r\n   \r\n   That said, it probably wouldn't make much of a difference, anyway.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-09T17:47:48.303+0000",
                    "updated": "2021-11-09T17:47:48.303+0000",
                    "started": "2021-11-09T17:47:48.303+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "679217",
                    "issueId": "13400878"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 15000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3bcfa34b[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5e9a3d88[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@18ce9a7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@e75e263[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@76be203c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@4f672170[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@29c028ea[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@887a14b[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@fbfcfa7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@79250381[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@510ae337[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@64329da4[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 15000,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Nov 09 17:48:54 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-11-09T17:48:53.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13988/watchers",
            "watchCount": 3,
            "isWatching": false
        },
        "created": "2021-09-13T20:19:28.000+0000",
        "updated": "2021-11-10T05:32:29.000+0000",
        "timeoriginalestimate": null,
        "description": "An extension to ARROW-13882. Non-fixed-width types will need a separate approach, so this was split out to a new JIRA.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 15000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Support binary-like types in hash_min_max, hash_min, hash_max",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13400878/comment/17441305",
                    "id": "17441305",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 11452\n[https://github.com/apache/arrow/pull/11452]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-11-09T17:48:54.002+0000",
                    "updated": "2021-11-09T17:48:54.002+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0uvew:",
        "customfield_12314139": null
    }
}