{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13144590",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590",
    "key": "ARROW-2299",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12342562",
                "id": "12342562",
                "description": "",
                "name": "0.10.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-08-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=stuartcarnie",
            "name": "stuartcarnie",
            "key": "stuartcarnie",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=stuartcarnie&avatarId=35027",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=stuartcarnie&avatarId=35027",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=stuartcarnie&avatarId=35027",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=stuartcarnie&avatarId=35027"
            },
            "displayName": "Stuart Carnie",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333772",
                "id": "12333772",
                "name": "Go"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2299/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@356c9ced[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@159a55ea[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7f49baa5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@38bb85a3[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@32840a2a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2a42ca4[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@300a32c7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@54f82ff8[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@463fba17[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@655d6f78[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@420f51e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@11b28d8d[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Mar 21 20:14:06 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-03-21T20:04:25.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2299/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2018-03-13T02:32:50.000+0000",
        "updated": "2018-03-21T20:14:06.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Go] Go language implementation",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16396429",
                    "id": "16396429",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1739: DONOTMERGE ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739#issuecomment-372526683\n \n \n   Thanks @stuartcarnie! Steps from here:\r\n   \r\n   - [x] PMC vote to accept code donation\r\n   - [ ] Receive software grant from InfluxData, Inc.\r\n   - [ ] IP Clearance vote on Incubator general mailing list\r\n   \r\n   See http://incubator.apache.org/ip-clearance/arrow-go-library.html for status on the IP Clearance process\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-13T02:34:43.190+0000",
                    "updated": "2018-03-13T02:34:43.190+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16401186",
                    "id": "16401186",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1739: DONOTMERGE ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739#issuecomment-372526683\n \n \n   Thanks @stuartcarnie! Steps from here:\r\n   \r\n   - [x] PMC vote to accept code donation\r\n   - [x] Receive software grant from InfluxData, Inc.\r\n   - [ ] IP Clearance vote on Incubator general mailing list\r\n   \r\n   See http://incubator.apache.org/ip-clearance/arrow-go-library.html for status on the IP Clearance process\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-15T22:25:06.664+0000",
                    "updated": "2018-03-15T22:25:06.664+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16401381",
                    "id": "16401381",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on a change in pull request #1739: DONOTMERGE ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739#discussion_r174980861\n \n \n\n ##########\n File path: go/arrow/internal/cpu/README.md\n ##########\n @@ -0,0 +1,23 @@\n+# Package cpu\n \n Review comment:\n   Copyright header\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-16T01:58:46.869+0000",
                    "updated": "2018-03-16T01:58:46.869+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16401382",
                    "id": "16401382",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on a change in pull request #1739: DONOTMERGE ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739#discussion_r174980420\n \n \n\n ##########\n File path: go/arrow/README.md\n ##########\n @@ -0,0 +1,155 @@\n+Arrow\n \n Review comment:\n   Change this to \"Apache Arrow\" (or Apache Arrow for Go). This file needs a copyright header, see https://raw.githubusercontent.com/apache/arrow/master/README.md for example\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-16T01:58:46.908+0000",
                    "updated": "2018-03-16T01:58:46.908+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16401938",
                    "id": "16401938",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "stuartcarnie commented on a change in pull request #1739: DONOTMERGE ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739#discussion_r175097052\n \n \n\n ##########\n File path: go/arrow/internal/cpu/README.md\n ##########\n @@ -0,0 +1,23 @@\n+# Package cpu\n \n Review comment:\n   \ud83d\udc4d \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-16T13:57:49.066+0000",
                    "updated": "2018-03-16T13:57:49.066+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16408453",
                    "id": "16408453",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1739: DONOTMERGE ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739#issuecomment-372526683\n \n \n   Thanks @stuartcarnie! Steps from here:\r\n   \r\n   - [x] PMC vote to accept code donation\r\n   - [x] Receive software grant from InfluxData, Inc.\r\n   - [x] IP Clearance vote on Incubator general mailing list\r\n   \r\n   See http://incubator.apache.org/ip-clearance/arrow-go-library.html for status on the IP Clearance process\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-21T19:21:25.378+0000",
                    "updated": "2018-03-21T19:21:25.378+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16408463",
                    "id": "16408463",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1739: DONOTMERGE ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739#issuecomment-375067024\n \n \n   I'm working on fixing the RAT checks (and also the fact that the release audit wasn't run in this CI build -- since it is a part of the C++ build at the moment), and then will merge this\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-21T19:27:23.105+0000",
                    "updated": "2018-03-21T19:27:23.105+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16408466",
                    "id": "16408466",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1739: ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739#issuecomment-375068231\n \n \n   +1. Merging on green build\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-21T19:31:35.722+0000",
                    "updated": "2018-03-21T19:31:35.722+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16408495",
                    "id": "16408495",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 1739\n[https://github.com/apache/arrow/pull/1739]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-03-21T20:04:25.126+0000",
                    "updated": "2018-03-21T20:04:25.126+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16408496",
                    "id": "16408496",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm closed pull request #1739: ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/.travis.yml b/.travis.yml\nindex b1241e793..03bc8e26a 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -56,6 +56,8 @@ matrix:\n     - CC=\"clang-5.0\"\n     - CXX=\"clang++-5.0\"\n     before_script:\n+    # Always run RAT checks, in case another build in matrix breaks RAT\n+    - $TRAVIS_BUILD_DIR/ci/travis_release_audit.sh\n     # (ARROW_CI_CPP_AFFECTED implies ARROW_CI_PYTHON_AFFECTED)\n     - if [ $ARROW_CI_PYTHON_AFFECTED != \"1\" ]; then exit; fi\n     - $TRAVIS_BUILD_DIR/ci/travis_install_linux.sh\ndiff --git a/ci/travis_release_audit.sh b/ci/travis_release_audit.sh\nnew file mode 100755\nindex 000000000..8da71a09c\n--- /dev/null\n+++ b/ci/travis_release_audit.sh\n@@ -0,0 +1,24 @@\n+#!/usr/bin/env bash\n+\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+set -e\n+\n+# Check licenses according to Apache policy\n+git archive HEAD --prefix=apache-arrow/ --output=arrow-src.tar.gz\n+./dev/release/run-rat.sh arrow-src.tar.gz\ndiff --git a/ci/travis_script_cpp.sh b/ci/travis_script_cpp.sh\nindex 3d61bc5b8..27ab88ba9 100755\n--- a/ci/travis_script_cpp.sh\n+++ b/ci/travis_script_cpp.sh\n@@ -21,10 +21,6 @@ set -e\n \n source $TRAVIS_BUILD_DIR/ci/travis_env_common.sh\n \n-# Check licenses according to Apache policy\n-git archive HEAD --prefix=apache-arrow/ --output=arrow-src.tar.gz\n-./dev/release/run-rat.sh arrow-src.tar.gz\n-\n pushd $CPP_BUILD_DIR\n \n ctest -VV -L unittest\ndiff --git a/dev/release/rat_exclude_files.txt b/dev/release/rat_exclude_files.txt\nindex bf962bcd4..eb735604f 100644\n--- a/dev/release/rat_exclude_files.txt\n+++ b/dev/release/rat_exclude_files.txt\n@@ -39,6 +39,11 @@ cpp/src/plasma/thirdparty/dlmalloc.c\n cpp/src/plasma/thirdparty/xxhash.cc\n cpp/src/plasma/thirdparty/xxhash.h\n dev/release/rat_exclude_files.txt\n+go/arrow/Gopkg.lock\n+go/arrow/internal/cpu/*\n+go/arrow/type_string.go\n+go/*.tmpldata\n+go/*.s\n js/.npmignore\n js/closure-compiler-scripts/*\n python/cmake_modules\ndiff --git a/go/arrow/.editorconfig b/go/arrow/.editorconfig\nnew file mode 100644\nindex 000000000..a7ceaf938\n--- /dev/null\n+++ b/go/arrow/.editorconfig\n@@ -0,0 +1,21 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+root = true\n+\n+[*.tmpl]\n+indent_style = tab\n+indent_size = 4\n\\ No newline at end of file\ndiff --git a/go/arrow/.gitignore b/go/arrow/.gitignore\nnew file mode 100644\nindex 000000000..d4b831ae8\n--- /dev/null\n+++ b/go/arrow/.gitignore\n@@ -0,0 +1,35 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+### Go template\n+# Binaries for programs and plugins\n+*.exe\n+*.dll\n+*.so\n+*.dylib\n+*.o\n+\n+# Test binary, build with `go test -c`\n+*.test\n+\n+# Output of the go coverage tool, specifically when used with LiteIDE\n+*.out\n+\n+# Project-local glide cache, RE: https://github.com/Masterminds/glide/issues/736\n+.glide/\n+\n+bin/\n+vendor/\n\\ No newline at end of file\ndiff --git a/go/arrow/Gopkg.lock b/go/arrow/Gopkg.lock\nnew file mode 100644\nindex 000000000..30a0d82f4\n--- /dev/null\n+++ b/go/arrow/Gopkg.lock\n@@ -0,0 +1,27 @@\n+# This file is autogenerated, do not edit; changes may be undone by the next 'dep ensure'.\n+\n+\n+[[projects]]\n+  name = \"github.com/davecgh/go-spew\"\n+  packages = [\"spew\"]\n+  revision = \"346938d642f2ec3594ed81d874461961cd0faa76\"\n+  version = \"v1.1.0\"\n+\n+[[projects]]\n+  name = \"github.com/pmezard/go-difflib\"\n+  packages = [\"difflib\"]\n+  revision = \"792786c7400a136282c1664665ae0a8db921c6c2\"\n+  version = \"v1.0.0\"\n+\n+[[projects]]\n+  name = \"github.com/stretchr/testify\"\n+  packages = [\"assert\"]\n+  revision = \"b91bfb9ebec76498946beb6af7c0230c7cc7ba6c\"\n+  version = \"v1.2.0\"\n+\n+[solve-meta]\n+  analyzer-name = \"dep\"\n+  analyzer-version = 1\n+  inputs-digest = \"a9dd4821c4522b2069722c1be94b191e7aff1736aeb5c12ab0070f87cdbc5af2\"\n+  solver-name = \"gps-cdcl\"\n+  solver-version = 1\ndiff --git a/go/arrow/Gopkg.toml b/go/arrow/Gopkg.toml\nnew file mode 100644\nindex 000000000..03bbeba1c\n--- /dev/null\n+++ b/go/arrow/Gopkg.toml\n@@ -0,0 +1,19 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+[[constraint]]\n+  name = \"github.com/stretchr/testify\"\n+  version = \"1.2.0\"\ndiff --git a/go/arrow/Makefile b/go/arrow/Makefile\nnew file mode 100644\nindex 000000000..a1fd22589\n--- /dev/null\n+++ b/go/arrow/Makefile\n@@ -0,0 +1,54 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+GO_BUILD=go build\n+GO_GEN=go generate\n+GO_TEST?=go test\n+GOPATH=$(realpath ../../../../../..)\n+\n+GO_SOURCES  := $(shell find . -path ./_lib -prune -o -name '*.go' -not -name '*_test.go')\n+ALL_SOURCES := $(shell find . -path ./_lib -prune -o -name '*.go' -name '*.s' -not -name '*_test.go')\n+SOURCES_NO_VENDOR := $(shell find . -path ./vendor -prune -o -name \"*.go\" -not -name '*_test.go' -print)\n+\n+.PHONEY: test bench assembly generate\n+\n+assembly:\n+\t@$(MAKE) -C memory assembly\n+\t@$(MAKE) -C math assembly\n+\n+generate: bin/tmpl\n+\tbin/tmpl -i -data=numeric.tmpldata type_traits_numeric.gen.go.tmpl array/numeric.gen.go.tmpl array/numericbuilder.gen.go.tmpl array/bufferbuilder_numeric.gen.go.tmpl\n+\tbin/tmpl -i -data=datatype_numeric.gen.go.tmpldata datatype_numeric.gen.go.tmpl\n+\t@$(MAKE) -C math generate\n+\n+fmt: $(SOURCES_NO_VENDOR)\n+\tgoimports -w $^\n+\n+bench: $(GO_SOURCES) | assembly\n+\t$(GO_TEST) $(GO_TEST_ARGS) -bench=. -run=- ./...\n+\n+bench-noasm: $(GO_SOURCES)\n+\t$(GO_TEST) $(GO_TEST_ARGS) -tags='noasm' -bench=. -run=- ./...\n+\n+test: $(GO_SOURCES) | assembly\n+\t$(GO_TEST) $(GO_TEST_ARGS) ./...\n+\n+test-noasm: $(GO_SOURCES)\n+\t$(GO_TEST) $(GO_TEST_ARGS) -tags='noasm' ./...\n+\n+bin/tmpl: _tools/tmpl/main.go\n+\t$(GO_BUILD) -o $@ ./_tools/tmpl\n+\ndiff --git a/go/arrow/README.md b/go/arrow/README.md\nnew file mode 100644\nindex 000000000..e4d349de9\n--- /dev/null\n+++ b/go/arrow/README.md\n@@ -0,0 +1,174 @@\n+<!---\n+  Licensed to the Apache Software Foundation (ASF) under one\n+  or more contributor license agreements.  See the NOTICE file\n+  distributed with this work for additional information\n+  regarding copyright ownership.  The ASF licenses this file\n+  to you under the Apache License, Version 2.0 (the\n+  \"License\"); you may not use this file except in compliance\n+  with the License.  You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing,\n+  software distributed under the License is distributed on an\n+  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  KIND, either express or implied.  See the License for the\n+  specific language governing permissions and limitations\n+  under the License.\n+-->\n+\n+Apache Arrow for Go\n+===================\n+\n+[Apache Arrow][arrow] is a cross-language development platform for in-memory data. It specifies a \n+standardized language-independent columnar memory format for flat and hierarchical data, \n+organized for efficient analytic operations on modern hardware. It also provides computational \n+libraries and zero-copy streaming messaging and inter-process communication.\n+\n+\n+Reference Counting\n+------------------\n+\n+arrow makes use of reference counting so that it can track when memory buffers are no longer used. This allows \n+arrow to update resource accounting, pool memory such and track overall memory usage as objects are created \n+and released. Types expose two methods to deal with this pattern. The `Retain` method will increase the \n+reference count by 1 and `Release` method will reduce the count by 1. Once the reference count of an object \n+is zero, any associated object will be freed. `Retain` and `Release` are safe to call from multiple goroutines.\n+\n+### When to call `Retain` / `Release`?\n+\n+* If you are passed an object and wish to take ownership of it, you must call `Retain`. You must later pair this \n+  with a call to `Release` when you no longer need the object.  \"Taking ownership\" typically means you\n+  wish to access the object outside the scope of the current function call.\n+  \n+* You own any object you create via functions whose name begins with `New` or `Copy` or when receiving\n+  an object over a channel. Therefore you must call `Release` once you no longer need the object.\n+  \n+* If you send an object over a channel, you must call `Retain` before sending it as the receiver is\n+  assumed to own the object and will later call `Release` when it no longer needs the object. \n+\n+\n+Performance\n+-----------\n+\n+The arrow package makes extensive use of [c2goasm][] to leverage LLVM's advanced optimizer and generate PLAN9 \n+assembly functions from C/C++ code. The arrow package can be compiled without these optimizations using the `noasm` \n+build tag. Alternatively, by configuring an environment variable, it is possible to dynamically configure which \n+architecture optimizations are used at runtime. \n+See the `cpu` package [README](internal/cpu/README.md) for a description of this environment variable.\n+\n+### Example Usage\n+\n+The following benchmarks demonstrate summing an array of 8192 values using various optimizations. \n+\n+Disable no architecture optimizations (thus using AVX2):\n+\n+```sh\n+$ INTEL_DISABLE_EXT=NONE go test -bench=8192 -run=. ./math\n+goos: darwin\n+goarch: amd64\n+pkg: github.com/apache/arrow/go/arrow/math\n+BenchmarkFloat64Funcs_Sum_8192-8   \t 2000000\t       687 ns/op\t95375.41 MB/s\n+BenchmarkInt64Funcs_Sum_8192-8     \t 2000000\t       719 ns/op\t91061.06 MB/s\n+BenchmarkUint64Funcs_Sum_8192-8    \t 2000000\t       691 ns/op\t94797.29 MB/s\n+PASS\n+ok  \tgithub.com/apache/arrow/go/arrow/math\t6.444s\n+```\n+\n+**NOTE:** `NONE` is simply ignored, thus enabling optimizations for AVX2 and SSE4\n+\n+----\n+\n+Disable AVX2 architecture optimizations:\n+\n+```sh\n+$ INTEL_DISABLE_EXT=AVX2 go test -bench=8192 -run=. ./math\n+goos: darwin\n+goarch: amd64\n+pkg: github.com/apache/arrow/go/arrow/math\n+BenchmarkFloat64Funcs_Sum_8192-8   \t 1000000\t      1912 ns/op\t34263.63 MB/s\n+BenchmarkInt64Funcs_Sum_8192-8     \t 1000000\t      1392 ns/op\t47065.57 MB/s\n+BenchmarkUint64Funcs_Sum_8192-8    \t 1000000\t      1405 ns/op\t46636.41 MB/s\n+PASS\n+ok  \tgithub.com/apache/arrow/go/arrow/math\t4.786s\n+```\n+\n+----\n+\n+Disable ALL architecture optimizations, thus using pure Go implementation:\n+\n+```sh\n+$ INTEL_DISABLE_EXT=ALL go test -bench=8192 -run=. ./math\n+goos: darwin\n+goarch: amd64\n+pkg: github.com/apache/arrow/go/arrow/math\n+BenchmarkFloat64Funcs_Sum_8192-8   \t  200000\t     10285 ns/op\t6371.41 MB/s\n+BenchmarkInt64Funcs_Sum_8192-8     \t  500000\t      3892 ns/op\t16837.37 MB/s\n+BenchmarkUint64Funcs_Sum_8192-8    \t  500000\t      3929 ns/op\t16680.00 MB/s\n+PASS\n+ok  \tgithub.com/apache/arrow/go/arrow/math\t6.179s\n+```\n+\n+Status\n+------\n+\n+The first milestone was to implement the necessary Array types in order to use\n+them internally in the [ifql][] execution engine and storage layers of [InfluxDB][].\n+\n+\n+### Memory Management\n+\n+- [x] Allocations are 64-byte aligned and padded to 8-bytes\n+\n+\n+### Array and builder support\n+\n+**Primitive types**\n+\n+- [x] Signed and unsigned 8, 16, 32 and 64 bit integers\n+- [x] 32 and 64 bit floats\n+- [x] Packed LSB booleans\n+- [x] Variable-length binary\n+- [ ] String (valid UTF-8)\n+- [ ] Half-float (16-bit)\n+- [ ] Null (no physical storage)\n+\n+**Parametric types**\n+\n+- [x] Timestamp\n+- [ ] Interval (year/month or day/time)\n+- [ ] Date32 (days since UNIX epoch)\n+- [ ] Date64 (milliseconds since UNIX epoch)\n+- [ ] Time32 (seconds or milliseconds since midnight)\n+- [ ] Time64 (microseconds or nanoseconds since midnight)\n+- [ ] Decimal (128-bit)\n+- [ ] Fixed-sized binary\n+- [ ] List\n+- [ ] Struct\n+- [ ] Union\n+    - [ ] Dense\n+    - [ ] Sparse\n+- [ ] Dictionary \n+    - [ ] Dictionary encoding\n+\n+### Type metadata\n+\n+- [x] Data types (implemented arrays)\n+- [ ] Field\n+- [ ] Schema\n+  \n+\n+### I/O \n+\n+Serialization is planned for a future iteration.\n+\n+- [ ] Flat buffers for serializing metadata\n+- [ ] Record Batch\n+- [ ] Table\n+\n+\n+\n+[arrow]:    https://arrow.apache.org\n+[ifql]:     https://github.com/influxdata/ifql\n+[InfluxDB]: https://github.com/influxdata/influxdb\n+[c2goasm]:  https://github.com/minio/c2goasm\n\\ No newline at end of file\ndiff --git a/go/arrow/_examples/helloworld/main.go b/go/arrow/_examples/helloworld/main.go\nnew file mode 100644\nindex 000000000..ab21f6b42\n--- /dev/null\n+++ b/go/arrow/_examples/helloworld/main.go\n@@ -0,0 +1,32 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package main\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+\t\"github.com/apache/arrow/go/arrow/math\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+)\n+\n+func main() {\n+\tfb := array.NewFloat64Builder(memory.DefaultAllocator)\n+\n+\tfb.AppendValues([]float64{1, 3, 5, 7, 9, 11}, nil)\n+\n+\tvec := fb.NewFloat64Array()\n+\tmath.Float64.Sum(vec)\n+}\ndiff --git a/go/arrow/_tools/tmpl/main.go b/go/arrow/_tools/tmpl/main.go\nnew file mode 100644\nindex 000000000..0cabef3db\n--- /dev/null\n+++ b/go/arrow/_tools/tmpl/main.go\n@@ -0,0 +1,267 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/json\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"go/format\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"text/template\"\n+)\n+\n+const Ext = \".tmpl\"\n+\n+type pathSpec struct {\n+\tin, out string\n+}\n+\n+func (p *pathSpec) String() string { return p.in + \" \u2192 \" + p.out }\n+func (p *pathSpec) IsGoFile() bool { return filepath.Ext(p.out) == \".go\" }\n+\n+func parsePath(path string) (string, string) {\n+\tp := strings.IndexByte(path, '=')\n+\tif p == -1 {\n+\t\tif filepath.Ext(path) != Ext {\n+\t\t\terrExit(\"template file '%s' must have .tmpl extension\", path)\n+\t\t}\n+\t\treturn path, path[:len(path)-len(Ext)]\n+\t}\n+\n+\treturn path[:p], path[p+1:]\n+}\n+\n+type data struct {\n+\tIn interface{}\n+\tD  listValue\n+}\n+\n+func errExit(format string, a ...interface{}) {\n+\tfmt.Fprintf(os.Stderr, format, a...)\n+\tfmt.Fprintln(os.Stderr)\n+\tos.Exit(1)\n+}\n+\n+type listValue map[string]string\n+\n+func (l listValue) String() string {\n+\tres := make([]string, 0, len(l))\n+\tfor k, v := range l {\n+\t\tres = append(res, fmt.Sprintf(\"%s=%s\", k, v))\n+\t}\n+\treturn strings.Join(res, \", \")\n+}\n+\n+func (l listValue) Set(v string) error {\n+\tnv := strings.Split(v, \"=\")\n+\tif len(nv) != 2 {\n+\t\treturn fmt.Errorf(\"expected NAME=VALUE, got %s\", v)\n+\t}\n+\tl[nv[0]] = nv[1]\n+\treturn nil\n+}\n+\n+func main() {\n+\tvar (\n+\t\tdataArg = flag.String(\"data\", \"\", \"input JSON data\")\n+\t\tgi      = flag.Bool(\"i\", false, \"run goimports\")\n+\t\tin      = &data{D: make(listValue)}\n+\t)\n+\n+\tflag.Var(&in.D, \"d\", \"-d NAME=VALUE\")\n+\n+\tflag.Parse()\n+\tif *dataArg == \"\" {\n+\t\terrExit(\"data option is required\")\n+\t}\n+\n+\tif *gi {\n+\t\tif _, err := exec.LookPath(\"goimports\"); err != nil {\n+\t\t\terrExit(\"failed to find goimports: %s\", err.Error())\n+\t\t}\n+\t\tformatter = formatSource\n+\t} else {\n+\t\tformatter = format.Source\n+\t}\n+\n+\tpaths := flag.Args()\n+\tif len(paths) == 0 {\n+\t\terrExit(\"no tmpl files specified\")\n+\t}\n+\n+\tspecs := make([]pathSpec, len(paths))\n+\tfor i, p := range paths {\n+\t\tin, out := parsePath(p)\n+\t\tspecs[i] = pathSpec{in: in, out: out}\n+\t}\n+\n+\tin.In = readData(*dataArg)\n+\tprocess(in, specs)\n+}\n+\n+func mustReadAll(path string) []byte {\n+\tdata, err := ioutil.ReadFile(path)\n+\tif err != nil {\n+\t\terrExit(err.Error())\n+\t}\n+\n+\treturn data\n+}\n+\n+func readData(path string) interface{} {\n+\tdata := mustReadAll(path)\n+\tvar v interface{}\n+\tif err := json.Unmarshal(StripComments(data), &v); err != nil {\n+\t\terrExit(\"invalid JSON data: %s\", err.Error())\n+\t}\n+\treturn v\n+}\n+\n+func fileMode(path string) os.FileMode {\n+\tstat, err := os.Stat(path)\n+\tif err != nil {\n+\t\terrExit(err.Error())\n+\t}\n+\treturn stat.Mode()\n+}\n+\n+var funcs = template.FuncMap{\n+\t\"lower\": strings.ToLower,\n+\t\"upper\": strings.ToUpper,\n+}\n+\n+func process(data interface{}, specs []pathSpec) {\n+\tfor _, spec := range specs {\n+\t\tvar (\n+\t\t\tt   *template.Template\n+\t\t\terr error\n+\t\t)\n+\t\tt, err = template.New(\"gen\").Funcs(funcs).Parse(string(mustReadAll(spec.in)))\n+\t\tif err != nil {\n+\t\t\terrExit(\"error processing template '%s': %s\", spec.in, err.Error())\n+\t\t}\n+\n+\t\tvar buf bytes.Buffer\n+\t\tif spec.IsGoFile() {\n+\t\t\t// preamble\n+\t\t\tfmt.Fprintf(&buf, \"// Code generated by %s. DO NOT EDIT.\\n\", spec.in)\n+\t\t\tfmt.Fprintln(&buf)\n+\t\t}\n+\t\terr = t.Execute(&buf, data)\n+\t\tif err != nil {\n+\t\t\terrExit(\"error executing template '%s': %s\", spec.in, err.Error())\n+\t\t}\n+\n+\t\tgenerated := buf.Bytes()\n+\t\tif spec.IsGoFile() {\n+\t\t\tgenerated, err = formatter(generated)\n+\t\t\tif err != nil {\n+\t\t\t\terrExit(\"error formatting '%s': %s\", spec.in, err.Error())\n+\t\t\t}\n+\t\t}\n+\n+\t\tioutil.WriteFile(spec.out, generated, fileMode(spec.in))\n+\t}\n+}\n+\n+var (\n+\tformatter func([]byte) ([]byte, error)\n+)\n+\n+func formatSource(in []byte) ([]byte, error) {\n+\tr := bytes.NewReader(in)\n+\tcmd := exec.Command(\"goimports\")\n+\tcmd.Stdin = r\n+\tout, err := cmd.Output()\n+\tif err != nil {\n+\t\tif ee, ok := err.(*exec.ExitError); ok {\n+\t\t\treturn nil, fmt.Errorf(\"error running goimports: %s\", string(ee.Stderr))\n+\t\t}\n+\t\treturn nil, fmt.Errorf(\"error running goimports: %s\", string(out))\n+\t}\n+\n+\treturn out, nil\n+}\n+\n+func StripComments(raw []byte) []byte {\n+\tvar (\n+\t\tquoted, esc bool\n+\t\tcomment     bool\n+\t)\n+\n+\tbuf := bytes.Buffer{}\n+\n+\tfor i := 0; i < len(raw); i++ {\n+\t\tb := raw[i]\n+\n+\t\tif comment {\n+\t\t\tswitch b {\n+\t\t\tcase '/':\n+\t\t\t\tcomment = false\n+\t\t\t\tj := bytes.IndexByte(raw[i+1:], '\\n')\n+\t\t\t\tif j == -1 {\n+\t\t\t\t\ti = len(raw)\n+\t\t\t\t} else {\n+\t\t\t\t\ti += j // keep new line\n+\t\t\t\t}\n+\t\t\tcase '*':\n+\t\t\t\tj := bytes.Index(raw[i+1:], []byte(\"*/\"))\n+\t\t\t\tif j == -1 {\n+\t\t\t\t\ti = len(raw)\n+\t\t\t\t} else {\n+\t\t\t\t\ti += j + 2\n+\t\t\t\t\tcomment = false\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif esc {\n+\t\t\tesc = false\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif b == '\\\\' && quoted {\n+\t\t\tesc = true\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif b == '\"' || b == '\\'' {\n+\t\t\tquoted = !quoted\n+\t\t}\n+\n+\t\tif b == '/' && !quoted {\n+\t\t\tcomment = true\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tbuf.WriteByte(b)\n+\t}\n+\n+\tif quoted || esc || comment {\n+\t\t// unexpected state, so return raw bytes\n+\t\treturn raw\n+\t}\n+\n+\treturn buf.Bytes()\n+}\ndiff --git a/go/arrow/_tools/tmpl/main_test.go b/go/arrow/_tools/tmpl/main_test.go\nnew file mode 100644\nindex 000000000..831cf791e\n--- /dev/null\n+++ b/go/arrow/_tools/tmpl/main_test.go\n@@ -0,0 +1,73 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package main\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestStripComments(t *testing.T) {\n+\ttests := []struct {\n+\t\tname string\n+\t\tin   string\n+\t\texp  string\n+\t}{\n+\t\t{name: \"none\", in: `[1,2,3]`, exp: `[1,2,3]`},\n+\t\t{name: \"single-line, line comment at end\", in: `[1,2,3] // foo bar`, exp: `[1,2,3] `},\n+\t\t{name: \"single-line, block comment at end\", in: `[1,2,3] /* foo bar */  `, exp: `[1,2,3]   `},\n+\t\t{name: \"single-line, block comment at end\", in: `[1,2,3] /* /* // */`, exp: `[1,2,3] `},\n+\t\t{name: \"single-line, block comment in middle\", in: `[1,/* foo bar */2,3]`, exp: `[1,2,3]`},\n+\t\t{name: \"single-line, block comment in string\", in: `[1,\"/* foo bar */\"]`, exp: `[1,\"/* foo bar */\"]`},\n+\t\t{name: \"single-line, malformed block comment\", in: `[1,2,/*]`, exp: `[1,2,/*]`},\n+\t\t{name: \"single-line, malformed JSON\", in: `[1,2,/]`, exp: `[1,2,/]`},\n+\n+\t\t{\n+\t\t\tname: \"multi-line\",\n+\t\t\tin: `[\n+  1,\n+  2,\n+  3\n+]`,\n+\t\t\texp: `[\n+  1,\n+  2,\n+  3\n+]`,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"multi-line, multiple line comments\",\n+\t\t\tin: `[ // foo\n+  1, // bar\n+  2,\n+  3\n+] // fit`,\n+\t\t\texp: `[ \n+  1, \n+  2,\n+  3\n+] `,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tgot := string(StripComments([]byte(test.in)))\n+\t\t\tif got != test.exp {\n+\t\t\t\tt.Errorf(\"got:\\n%s\\nexp:\\n%s\", got, test.exp)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\ndiff --git a/go/arrow/array/array.go b/go/arrow/array/array.go\nnew file mode 100644\nindex 000000000..a789d75b3\n--- /dev/null\n+++ b/go/arrow/array/array.go\n@@ -0,0 +1,185 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"sync/atomic\"\n+\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/apache/arrow/go/arrow/internal/bitutil\"\n+\t\"github.com/apache/arrow/go/arrow/internal/debug\"\n+)\n+\n+// A type which satisfies array.Interface represents an immutable sequence of values.\n+type Interface interface {\n+\t// DataType returns the type metadata for this instance.\n+\tDataType() arrow.DataType\n+\n+\t// NullN returns the number of null values in the array.\n+\tNullN() int\n+\n+\t// NullBitmapBytes returns a byte slice of the validity bitmap.\n+\tNullBitmapBytes() []byte\n+\n+\t// IsNull returns true if value at index is null.\n+\t// NOTE: IsNull will panic if NullBitmapBytes is not empty and 0 > i \u2265 Len.\n+\tIsNull(i int) bool\n+\n+\t// IsValid returns true if value at index is not null.\n+\t// NOTE: IsValid will panic if NullBitmapBytes is not empty and 0 > i \u2265 Len.\n+\tIsValid(i int) bool\n+\n+\tData() *Data\n+\n+\t// Len returns the number of elements in the array.\n+\tLen() int\n+\n+\t// Retain increases the reference count by 1.\n+\t// Retain may be called simultaneously from multiple goroutines.\n+\tRetain()\n+\n+\t// Release decreases the reference count by 1.\n+\t// Release may be called simultaneously from multiple goroutines.\n+\t// When the reference count goes to zero, the memory is freed.\n+\tRelease()\n+}\n+\n+const (\n+\t// UnknownNullCount specifies the NullN should be calculated from the null bitmap buffer.\n+\tUnknownNullCount = -1\n+)\n+\n+type array struct {\n+\trefCount        int64\n+\tdata            *Data\n+\tnullBitmapBytes []byte\n+}\n+\n+// Retain increases the reference count by 1.\n+// Retain may be called simultaneously from multiple goroutines.\n+func (a *array) Retain() {\n+\tatomic.AddInt64(&a.refCount, 1)\n+}\n+\n+// Release decreases the reference count by 1.\n+// Release may be called simultaneously from multiple goroutines.\n+// When the reference count goes to zero, the memory is freed.\n+func (a *array) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&a.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&a.refCount, -1) == 0 {\n+\t\ta.data.Release()\n+\t\ta.data, a.nullBitmapBytes = nil, nil\n+\t}\n+}\n+\n+// DataType returns the type metadata for this instance.\n+func (a *array) DataType() arrow.DataType { return a.data.typE }\n+\n+// NullN returns the number of null values in the array.\n+func (a *array) NullN() int {\n+\tif a.data.nullN < 0 {\n+\t\ta.data.nullN = a.data.length - bitutil.CountSetBits(a.nullBitmapBytes, a.data.length)\n+\t}\n+\treturn a.data.nullN\n+}\n+\n+// NullBitmapBytes returns a byte slice of the validity bitmap.\n+func (a *array) NullBitmapBytes() []byte { return a.nullBitmapBytes }\n+\n+func (a *array) Data() *Data { return a.data }\n+\n+// Len returns the number of elements in the array.\n+func (a *array) Len() int { return a.data.length }\n+\n+// IsNull returns true if value at index is null.\n+// NOTE: IsNull will panic if NullBitmapBytes is not empty and 0 > i \u2265 Len.\n+func (a *array) IsNull(i int) bool {\n+\treturn len(a.nullBitmapBytes) != 0 && bitutil.BitIsNotSet(a.nullBitmapBytes, i)\n+}\n+\n+// IsValid returns true if value at index is not null.\n+// NOTE: IsValid will panic if NullBitmapBytes is not empty and 0 > i \u2265 Len.\n+func (a *array) IsValid(i int) bool {\n+\treturn len(a.nullBitmapBytes) == 0 || bitutil.BitIsSet(a.nullBitmapBytes, i)\n+}\n+\n+func (a *array) setData(data *Data) {\n+\tif a.data != nil {\n+\t\ta.data.Release()\n+\t}\n+\n+\tdata.Retain()\n+\tif len(data.buffers) > 0 && data.buffers[0] != nil {\n+\t\ta.nullBitmapBytes = data.buffers[0].Bytes()\n+\t}\n+\ta.data = data\n+}\n+\n+type arrayConstructorFn func(*Data) Interface\n+\n+var (\n+\tmakeArrayFn = [...]arrayConstructorFn{\n+\t\tarrow.NULL:              unsupportedArrayType,\n+\t\tarrow.BOOL:              func(data *Data) Interface { return NewBooleanData(data) },\n+\t\tarrow.UINT8:             unsupportedArrayType,\n+\t\tarrow.INT8:              unsupportedArrayType,\n+\t\tarrow.UINT16:            unsupportedArrayType,\n+\t\tarrow.INT16:             unsupportedArrayType,\n+\t\tarrow.UINT32:            unsupportedArrayType,\n+\t\tarrow.INT32:             func(data *Data) Interface { return NewInt32Data(data) },\n+\t\tarrow.UINT64:            func(data *Data) Interface { return NewUint64Data(data) },\n+\t\tarrow.INT64:             func(data *Data) Interface { return NewInt64Data(data) },\n+\t\tarrow.HALF_FLOAT:        unsupportedArrayType,\n+\t\tarrow.FLOAT32:           unsupportedArrayType,\n+\t\tarrow.FLOAT64:           func(data *Data) Interface { return NewFloat64Data(data) },\n+\t\tarrow.STRING:            unsupportedArrayType,\n+\t\tarrow.BINARY:            func(data *Data) Interface { return NewBinaryData(data) },\n+\t\tarrow.FIXED_SIZE_BINARY: unsupportedArrayType,\n+\t\tarrow.DATE32:            unsupportedArrayType,\n+\t\tarrow.DATE64:            unsupportedArrayType,\n+\t\tarrow.TIMESTAMP:         func(data *Data) Interface { return NewTimestampData(data) },\n+\t\tarrow.TIME32:            unsupportedArrayType,\n+\t\tarrow.TIME64:            unsupportedArrayType,\n+\t\tarrow.INTERVAL:          unsupportedArrayType,\n+\t\tarrow.DECIMAL:           unsupportedArrayType,\n+\t\tarrow.LIST:              unsupportedArrayType,\n+\t\tarrow.STRUCT:            unsupportedArrayType,\n+\t\tarrow.UNION:             unsupportedArrayType,\n+\t\tarrow.DICTIONARY:        unsupportedArrayType,\n+\t\tarrow.MAP:               unsupportedArrayType,\n+\n+\t\t// invalid data types to fill out array size 2\u2075-1\n+\t\t28: invalidDataType,\n+\t\t29: invalidDataType,\n+\t\t30: invalidDataType,\n+\t\t31: invalidDataType,\n+\t}\n+)\n+\n+func unsupportedArrayType(data *Data) Interface {\n+\tpanic(\"unsupported data type: \" + data.typE.ID().String())\n+}\n+\n+func invalidDataType(data *Data) Interface {\n+\tpanic(\"invalid data type: \" + data.typE.ID().String())\n+}\n+\n+// MakeFromData constructs a strongly-typed array instance from generic Data.\n+func MakeFromData(data *Data) Interface {\n+\treturn makeArrayFn[byte(data.typE.ID()&0x1f)](data)\n+}\ndiff --git a/go/arrow/array/array_test.go b/go/arrow/array/array_test.go\nnew file mode 100644\nindex 000000000..6d505cf9f\n--- /dev/null\n+++ b/go/arrow/array/array_test.go\n@@ -0,0 +1,99 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+\t\"github.com/apache/arrow/go/arrow/internal/testing/tools\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+type testDataType struct {\n+\tid arrow.Type\n+}\n+\n+func (d *testDataType) ID() arrow.Type { return d.id }\n+func (d *testDataType) Name() string   { panic(\"implement me\") }\n+\n+func TestMakeFromData(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\td        arrow.DataType\n+\t\texpPanic bool\n+\t\texpError string\n+\t}{\n+\t\t// unsupported types\n+\t\t{name: \"null\", d: &testDataType{arrow.NULL}, expPanic: true, expError: \"unsupported data type: NULL\"},\n+\t\t{name: \"map\", d: &testDataType{arrow.MAP}, expPanic: true, expError: \"unsupported data type: MAP\"},\n+\n+\t\t// supported types\n+\t\t{name: \"bool\", d: &testDataType{arrow.BOOL}},\n+\n+\t\t// invalid types\n+\t\t{name: \"invalid(-1)\", d: &testDataType{arrow.Type(-1)}, expPanic: true, expError: \"invalid data type: Type(-1)\"},\n+\t\t{name: \"invalid(28)\", d: &testDataType{arrow.Type(28)}, expPanic: true, expError: \"invalid data type: Type(28)\"},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tvar b [4]*memory.Buffer\n+\t\t\tdata := array.NewData(test.d, 0, b[:], 0)\n+\n+\t\t\tif test.expPanic {\n+\t\t\t\tassert.PanicsWithValue(t, test.expError, func() {\n+\t\t\t\t\tarray.MakeFromData(data)\n+\t\t\t\t})\n+\t\t\t} else {\n+\t\t\t\tassert.NotNil(t, array.MakeFromData(data))\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func bbits(v ...int32) []byte {\n+\treturn tools.IntsToBitsLSB(v...)\n+}\n+\n+func TestArray_NullN(t *testing.T) {\n+\ttests := []struct {\n+\t\tname string\n+\t\tl    int\n+\t\tbm   []byte\n+\t\tn    int\n+\t\texp  int\n+\t}{\n+\t\t{name: \"unknown,l16\", l: 16, bm: bbits(0x11001010, 0x00110011), n: array.UnknownNullCount, exp: 8},\n+\t\t{name: \"unknown,l12,ignores last nibble\", l: 12, bm: bbits(0x11001010, 0x00111111), n: array.UnknownNullCount, exp: 6},\n+\t\t{name: \"unknown,l12,12 nulls\", l: 12, bm: bbits(0x00000000, 0x00000000), n: array.UnknownNullCount, exp: 12},\n+\t\t{name: \"unknown,l12,00 nulls\", l: 12, bm: bbits(0x11111111, 0x11111111), n: array.UnknownNullCount, exp: 0},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tbuf := memory.NewBufferBytes(test.bm)\n+\t\t\tdata := array.NewData(arrow.FixedWidthTypes.Boolean, test.l, []*memory.Buffer{buf, nil}, test.n)\n+\t\t\tbuf.Release()\n+\t\t\tar := array.MakeFromData(data)\n+\t\t\tdata.Release()\n+\t\t\tgot := ar.NullN()\n+\t\t\tar.Release()\n+\t\t\tassert.Equal(t, test.exp, got)\n+\t\t})\n+\t}\n+}\ndiff --git a/go/arrow/array/binary.go b/go/arrow/array/binary.go\nnew file mode 100644\nindex 000000000..0b89b7e58\n--- /dev/null\n+++ b/go/arrow/array/binary.go\n@@ -0,0 +1,69 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"unsafe\"\n+\n+\t\"github.com/apache/arrow/go/arrow\"\n+)\n+\n+// A type which represents an immutable sequence of variable-length binary strings.\n+type Binary struct {\n+\tarray\n+\tvalueOffsets []int32\n+\tvalueBytes   []byte\n+}\n+\n+// NewBinaryData constructs a new Binary array from data.\n+func NewBinaryData(data *Data) *Binary {\n+\ta := &Binary{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+// Value returns the slice at index i. This value should not be mutated.\n+func (a *Binary) Value(i int) []byte { return a.valueBytes[a.valueOffsets[i]:a.valueOffsets[i+1]] }\n+\n+// ValueString returns the string at index i without performing additional allocations.\n+// The string is only valid for the lifetime of the Binary array.\n+func (a *Binary) ValueString(i int) string {\n+\tb := a.Value(i)\n+\treturn *(*string)(unsafe.Pointer(&b))\n+}\n+\n+func (a *Binary) ValueOffset(i int) int { return int(a.valueOffsets[i]) }\n+func (a *Binary) ValueLen(i int) int    { return int(a.valueOffsets[i+1] - a.valueOffsets[i]) }\n+func (a *Binary) ValueOffsets() []int32 { return a.valueOffsets }\n+func (a *Binary) ValueBytes() []byte    { return a.valueBytes }\n+\n+func (a *Binary) setData(data *Data) {\n+\tif len(data.buffers) != 3 {\n+\t\tpanic(\"len(data.buffers) != 3\")\n+\t}\n+\n+\ta.array.setData(data)\n+\n+\tif valueData := data.buffers[2]; valueData != nil {\n+\t\ta.valueBytes = valueData.Bytes()\n+\t}\n+\n+\tif valueOffsets := data.buffers[1]; valueOffsets != nil {\n+\t\ta.valueOffsets = arrow.Int32Traits.CastFromBytes(valueOffsets.Bytes())\n+\t}\n+}\ndiff --git a/go/arrow/array/binarybuilder.go b/go/arrow/array/binarybuilder.go\nnew file mode 100644\nindex 000000000..71aa4ccd5\n--- /dev/null\n+++ b/go/arrow/array/binarybuilder.go\n@@ -0,0 +1,184 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"math\"\n+\t\"sync/atomic\"\n+\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/apache/arrow/go/arrow/internal/debug\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+)\n+\n+const (\n+\tbinaryArrayMaximumCapacity = math.MaxInt32\n+)\n+\n+// A BinaryBuilder is used to build a Binary array using the Append methods.\n+type BinaryBuilder struct {\n+\tbuilder\n+\n+\ttypE    arrow.BinaryDataType\n+\toffsets *int32BufferBuilder\n+\tvalues  *byteBufferBuilder\n+}\n+\n+func NewBinaryBuilder(mem memory.Allocator, typE arrow.BinaryDataType) *BinaryBuilder {\n+\tb := &BinaryBuilder{\n+\t\tbuilder: builder{refCount: 1, mem: mem},\n+\t\ttypE:    typE,\n+\t\toffsets: newInt32BufferBuilder(mem),\n+\t\tvalues:  newByteBufferBuilder(mem),\n+\t}\n+\treturn b\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+// Release may be called simultaneously from multiple goroutines.\n+func (b *BinaryBuilder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.offsets != nil {\n+\t\t\tb.offsets.Release()\n+\t\t\tb.offsets = nil\n+\t\t}\n+\t\tif b.values != nil {\n+\t\t\tb.values.Release()\n+\t\t\tb.values = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *BinaryBuilder) Append(v []byte) {\n+\tb.Reserve(1)\n+\tb.appendNextOffset()\n+\tb.values.Append(v)\n+\tb.UnsafeAppendBoolToBitmap(true)\n+}\n+\n+func (b *BinaryBuilder) AppendString(v string) {\n+\tb.Append([]byte(v))\n+}\n+\n+func (b *BinaryBuilder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.appendNextOffset()\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *BinaryBuilder) AppendValues(v [][]byte, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tfor _, vv := range v {\n+\t\tb.appendNextOffset()\n+\t\tb.values.Append(vv)\n+\t}\n+\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+// AppendStringValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *BinaryBuilder) AppendStringValues(v []string, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tfor _, vv := range v {\n+\t\tb.appendNextOffset()\n+\t\tb.values.Append([]byte(vv))\n+\t}\n+\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *BinaryBuilder) Value(i int) []byte {\n+\toffsets := b.offsets.Values()\n+\tstart := int(offsets[i])\n+\tvar end int\n+\tif i == (b.length - 1) {\n+\t\tend = b.values.Len()\n+\t} else {\n+\t\tend = int(offsets[i+1])\n+\t}\n+\treturn b.values.Bytes()[start:end]\n+}\n+\n+func (b *BinaryBuilder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\tb.offsets.resize((capacity + 1) * arrow.Int32SizeBytes)\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *BinaryBuilder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *BinaryBuilder) Resize(n int) {\n+\tb.offsets.resize((n + 1) * arrow.Int32SizeBytes)\n+\tb.builder.resize(n, b.init)\n+}\n+\n+// NewBinaryArray creates a Binary array from the memory buffers used by the builder and resets the BinaryBuilder\n+// so it can be used to build a new array.\n+func (b *BinaryBuilder) NewBinaryArray() (a *Binary) {\n+\tdata := b.newData()\n+\ta = NewBinaryData(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *BinaryBuilder) newData() (data *Data) {\n+\tb.appendNextOffset()\n+\toffsets, values := b.offsets.Finish(), b.values.Finish()\n+\tdata = NewData(b.typE, b.length, []*memory.Buffer{b.nullBitmap, offsets, values}, b.nullN)\n+\tif offsets != nil {\n+\t\toffsets.Release()\n+\t}\n+\n+\tif values != nil {\n+\t\tvalues.Release()\n+\t}\n+\n+\tb.builder.reset()\n+\n+\treturn\n+}\n+\n+func (b *BinaryBuilder) appendNextOffset() {\n+\tnumBytes := b.values.Len()\n+\t// TODO(sgc): check binaryArrayMaximumCapacity?\n+\tb.offsets.AppendValue(int32(numBytes))\n+}\ndiff --git a/go/arrow/array/binarybuilder_test.go b/go/arrow/array/binarybuilder_test.go\nnew file mode 100644\nindex 000000000..4de512499\n--- /dev/null\n+++ b/go/arrow/array/binarybuilder_test.go\n@@ -0,0 +1,61 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestBinaryBuilder(t *testing.T) {\n+\tmem := memory.NewCheckedAllocator(memory.NewGoAllocator())\n+\tdefer mem.AssertSize(t, 0)\n+\n+\tab := array.NewBinaryBuilder(mem, arrow.BinaryTypes.Binary)\n+\n+\texp := [][]byte{[]byte(\"foo\"), []byte(\"bar\"), nil, []byte(\"sydney\"), []byte(\"cameron\")}\n+\tfor _, v := range exp {\n+\t\tif v == nil {\n+\t\t\tab.AppendNull()\n+\t\t} else {\n+\t\t\tab.Append(v)\n+\t\t}\n+\t}\n+\n+\tassert.Equal(t, len(exp), ab.Len(), \"unexpected Len()\")\n+\tassert.Equal(t, 1, ab.NullN(), \"unexpected NullN()\")\n+\n+\tfor i, v := range exp {\n+\t\tif v == nil {\n+\t\t\tv = []byte{}\n+\t\t}\n+\t\tassert.Equal(t, v, ab.Value(i), \"unexpected BinaryArrayBuilder.Value(%d)\", i)\n+\t}\n+\n+\tar := ab.NewBinaryArray()\n+\tab.Release()\n+\tar.Release()\n+\n+\t// check state of builder after NewBinaryArray\n+\tassert.Zero(t, ab.Len(), \"unexpected ArrayBuilder.Len(), NewBinaryArray did not reset state\")\n+\tassert.Zero(t, ab.Cap(), \"unexpected ArrayBuilder.Cap(), NewBinaryArray did not reset state\")\n+\tassert.Zero(t, ab.NullN(), \"unexpected ArrayBuilder.NullN(), NewBinaryArray did not reset state\")\n+}\ndiff --git a/go/arrow/array/boolean.go b/go/arrow/array/boolean.go\nnew file mode 100644\nindex 000000000..0d41381b0\n--- /dev/null\n+++ b/go/arrow/array/boolean.go\n@@ -0,0 +1,53 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/apache/arrow/go/arrow/internal/bitutil\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+)\n+\n+// A type which represents an immutable sequence of boolean values.\n+type Boolean struct {\n+\tarray\n+\tvalues []byte\n+}\n+\n+// NewBoolean creates a boolean array from the data memory.Buffer and contains length elements.\n+// The nullBitmap buffer can be nil of there are no null values.\n+// If nullN is not known, use UnknownNullCount to calculate the value of NullN at runtime from the nullBitmap buffer.\n+func NewBoolean(length int, data *memory.Buffer, nullBitmap *memory.Buffer, nullN int) *Boolean {\n+\treturn NewBooleanData(NewData(arrow.FixedWidthTypes.Boolean, length, []*memory.Buffer{nullBitmap, data}, nullN))\n+}\n+\n+func NewBooleanData(data *Data) *Boolean {\n+\ta := &Boolean{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *Boolean) Value(i int) bool { return bitutil.BitIsSet(a.values, i) }\n+\n+func (a *Boolean) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = vals.Bytes()\n+\t}\n+}\ndiff --git a/go/arrow/array/booleanbuilder.go b/go/arrow/array/booleanbuilder.go\nnew file mode 100644\nindex 000000000..05e506fb2\n--- /dev/null\n+++ b/go/arrow/array/booleanbuilder.go\n@@ -0,0 +1,150 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"sync/atomic\"\n+\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/apache/arrow/go/arrow/internal/bitutil\"\n+\t\"github.com/apache/arrow/go/arrow/internal/debug\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+)\n+\n+type BooleanBuilder struct {\n+\tbuilder\n+\n+\tdata    *memory.Buffer\n+\trawData []byte\n+}\n+\n+func NewBooleanBuilder(mem memory.Allocator) *BooleanBuilder {\n+\treturn &BooleanBuilder{builder: builder{refCount: 1, mem: mem}}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+// Release may be called simultaneously from multiple goroutines.\n+func (b *BooleanBuilder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *BooleanBuilder) Append(v bool) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *BooleanBuilder) AppendByte(v byte) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v != 0)\n+}\n+\n+func (b *BooleanBuilder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *BooleanBuilder) UnsafeAppend(v bool) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tif v {\n+\t\tbitutil.SetBit(b.rawData, b.length)\n+\t} else {\n+\t\tbitutil.ClearBit(b.rawData, b.length)\n+\t}\n+\tb.length++\n+}\n+\n+func (b *BooleanBuilder) AppendValues(v []bool, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tfor i, vv := range v {\n+\t\tbitutil.SetBitTo(b.rawData, b.length+i, vv)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *BooleanBuilder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.BooleanTraits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = b.data.Bytes()\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *BooleanBuilder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *BooleanBuilder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.BooleanTraits.BytesRequired(n))\n+\t\tb.rawData = b.data.Bytes()\n+\t}\n+}\n+\n+// NewBooleanArray creates a Boolean array from the memory buffers used by the builder and resets the BooleanBuilder\n+// so it can be used to build a new array.\n+func (b *BooleanBuilder) NewBooleanArray() (a *Boolean) {\n+\tdata := b.newData()\n+\ta = NewBooleanData(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *BooleanBuilder) newData() *Data {\n+\tbytesRequired := arrow.BooleanTraits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+\tres := NewData(arrow.FixedWidthTypes.Boolean, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn res\n+}\ndiff --git a/go/arrow/array/booleanbuilder_test.go b/go/arrow/array/booleanbuilder_test.go\nnew file mode 100644\nindex 000000000..5540c9b33\n--- /dev/null\n+++ b/go/arrow/array/booleanbuilder_test.go\n@@ -0,0 +1,45 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+\t\"github.com/apache/arrow/go/arrow/internal/testing/tools\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestBooleanBuilder_AppendValues(t *testing.T) {\n+\tmem := memory.NewCheckedAllocator(memory.NewGoAllocator())\n+\tdefer mem.AssertSize(t, 0)\n+\n+\tb := array.NewBooleanBuilder(mem)\n+\n+\texp := tools.Bools(1, 1, 0, 1, 1, 0, 1, 0)\n+\tgot := make([]bool, len(exp))\n+\n+\tb.AppendValues(exp, nil)\n+\ta := b.NewBooleanArray()\n+\tb.Release()\n+\tfor i := 0; i < a.Len(); i++ {\n+\t\tgot[i] = a.Value(i)\n+\t}\n+\tassert.Equal(t, exp, got)\n+\ta.Release()\n+}\ndiff --git a/go/arrow/array/bufferbuilder.go b/go/arrow/array/bufferbuilder.go\nnew file mode 100644\nindex 000000000..29d97fc8d\n--- /dev/null\n+++ b/go/arrow/array/bufferbuilder.go\n@@ -0,0 +1,127 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"sync/atomic\"\n+\n+\t\"github.com/apache/arrow/go/arrow/internal/bitutil\"\n+\t\"github.com/apache/arrow/go/arrow/internal/debug\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+)\n+\n+// A bufferBuilder provides common functionality for populating memory with a sequence of type-specific values.\n+// Specialized implementations provide type-safe APIs for appending and accessing the memory.\n+type bufferBuilder struct {\n+\trefCount int64\n+\tmem      memory.Allocator\n+\tbuffer   *memory.Buffer\n+\tlength   int\n+\tcapacity int\n+\n+\tbytes []byte\n+}\n+\n+// Retain increases the reference count by 1.\n+// Retain may be called simultaneously from multiple goroutines.\n+func (b *bufferBuilder) Retain() {\n+\tatomic.AddInt64(&b.refCount, 1)\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+// Release may be called simultaneously from multiple goroutines.\n+func (b *bufferBuilder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.buffer != nil {\n+\t\t\tb.buffer.Release()\n+\t\t\tb.buffer, b.bytes = nil, nil\n+\t\t}\n+\t}\n+}\n+\n+// Len returns the length of the memory buffer in bytes.\n+func (b *bufferBuilder) Len() int { return b.length }\n+\n+// Cap returns the total number of bytes that can be stored without allocating additional memory.\n+func (b *bufferBuilder) Cap() int { return b.capacity }\n+\n+// Bytes returns a slice of length b.Len().\n+// The slice is only valid for use until the next buffer modification. That is, until the next call\n+// to Advance, Reset, Finish or any Append function. The slice aliases the buffer content at least until the next\n+// buffer modification.\n+func (b *bufferBuilder) Bytes() []byte { return b.bytes[:b.length] }\n+\n+func (b *bufferBuilder) resize(elements int) {\n+\tif b.buffer == nil {\n+\t\tb.buffer = memory.NewResizableBuffer(b.mem)\n+\t}\n+\n+\tb.buffer.Resize(elements)\n+\toldCapacity := b.capacity\n+\tb.capacity = b.buffer.Cap()\n+\tb.bytes = b.buffer.Buf()\n+\n+\tif b.capacity > oldCapacity {\n+\t\tmemory.Set(b.bytes[oldCapacity:], 0)\n+\t}\n+}\n+\n+// Advance increases the buffer by length and initializes the skipped bytes to zero.\n+func (b *bufferBuilder) Advance(length int) {\n+\tif b.capacity < b.length+length {\n+\t\tnewCapacity := bitutil.NextPowerOf2(b.length + length)\n+\t\tb.resize(newCapacity)\n+\t}\n+\tb.length += length\n+}\n+\n+// Append appends the contents of v to the buffer, resizing it if necessary.\n+func (b *bufferBuilder) Append(v []byte) {\n+\tif b.capacity < b.length+len(v) {\n+\t\tnewCapacity := bitutil.NextPowerOf2(b.length + len(v))\n+\t\tb.resize(newCapacity)\n+\t}\n+\tb.unsafeAppend(v)\n+}\n+\n+// Reset returns the buffer to an empty state. Reset releases the memory and sets the length and capacity to zero.\n+func (b *bufferBuilder) Reset() {\n+\tif b.buffer != nil {\n+\t\tb.buffer.Release()\n+\t}\n+\tb.buffer, b.bytes = nil, nil\n+\tb.capacity, b.length = 0, 0\n+}\n+\n+// Finish TODO(sgc)\n+func (b *bufferBuilder) Finish() (buffer *memory.Buffer) {\n+\tif b.length > 0 {\n+\t\tb.buffer.ResizeNoShrink(b.length)\n+\t}\n+\tbuffer = b.buffer\n+\tb.buffer = nil\n+\tb.Reset()\n+\treturn\n+}\n+\n+func (b *bufferBuilder) unsafeAppend(data []byte) {\n+\tcopy(b.bytes[b.length:], data)\n+\tb.length += len(data)\n+}\ndiff --git a/go/arrow/array/bufferbuilder_byte.go b/go/arrow/array/bufferbuilder_byte.go\nnew file mode 100644\nindex 000000000..f5f5445b7\n--- /dev/null\n+++ b/go/arrow/array/bufferbuilder_byte.go\n@@ -0,0 +1,30 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import \"github.com/apache/arrow/go/arrow/memory\"\n+\n+type byteBufferBuilder struct {\n+\tbufferBuilder\n+}\n+\n+func newByteBufferBuilder(mem memory.Allocator) *byteBufferBuilder {\n+\treturn &byteBufferBuilder{bufferBuilder: bufferBuilder{refCount: 1, mem: mem}}\n+}\n+\n+func (b *byteBufferBuilder) Values() []byte   { return b.Bytes() }\n+func (b *byteBufferBuilder) Value(i int) byte { return b.bytes[i] }\ndiff --git a/go/arrow/array/bufferbuilder_numeric.gen.go b/go/arrow/array/bufferbuilder_numeric.gen.go\nnew file mode 100644\nindex 000000000..e39b2528a\n--- /dev/null\n+++ b/go/arrow/array/bufferbuilder_numeric.gen.go\n@@ -0,0 +1,58 @@\n+// Code generated by array/bufferbuilder_numeric.gen.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/apache/arrow/go/arrow/internal/bitutil\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+)\n+\n+type int32BufferBuilder struct {\n+\tbufferBuilder\n+}\n+\n+func newInt32BufferBuilder(mem memory.Allocator) *int32BufferBuilder {\n+\treturn &int32BufferBuilder{bufferBuilder: bufferBuilder{refCount: 1, mem: mem}}\n+}\n+\n+// AppendValues appends the contents of v to the buffer, growing the buffer as needed.\n+func (b *int32BufferBuilder) AppendValues(v []int32) { b.Append(arrow.Int32Traits.CastToBytes(v)) }\n+\n+// Values returns a slice of length b.Len().\n+// The slice is only valid for use until the next buffer modification. That is, until the next call\n+// to Advance, Reset, Finish or any Append function. The slice aliases the buffer content at least until the next\n+// buffer modification.\n+func (b *int32BufferBuilder) Values() []int32 { return arrow.Int32Traits.CastFromBytes(b.Bytes()) }\n+\n+// Value returns the int32 element at the index i. Value will panic if i is negative or \u2265 Len.\n+func (b *int32BufferBuilder) Value(i int) int32 { return b.Values()[i] }\n+\n+// Len returns the number of int32 elements in the buffer.\n+func (b *int32BufferBuilder) Len() int { return b.length / arrow.Int32SizeBytes }\n+\n+// AppendValue appends v to the buffer, growing the buffer as needed.\n+func (b *int32BufferBuilder) AppendValue(v int32) {\n+\tif b.capacity < b.length+arrow.Int32SizeBytes {\n+\t\tnewCapacity := bitutil.NextPowerOf2(b.length + arrow.Int32SizeBytes)\n+\t\tb.resize(newCapacity)\n+\t}\n+\tarrow.Int32Traits.PutValue(b.bytes[b.length:], v)\n+\tb.length += arrow.Int32SizeBytes\n+}\ndiff --git a/go/arrow/array/bufferbuilder_numeric.gen.go.tmpl b/go/arrow/array/bufferbuilder_numeric.gen.go.tmpl\nnew file mode 100644\nindex 000000000..d8b03b06c\n--- /dev/null\n+++ b/go/arrow/array/bufferbuilder_numeric.gen.go.tmpl\n@@ -0,0 +1,61 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/apache/arrow/go/arrow/internal/bitutil\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+)\n+\n+{{range .In}}\n+{{$TypeNamePrefix := .name}}\n+{{if .Opt.BufferBuilder}}\n+type {{$TypeNamePrefix}}BufferBuilder struct {\n+\tbufferBuilder\n+}\n+\n+func new{{.Name}}BufferBuilder(mem memory.Allocator) *{{$TypeNamePrefix}}BufferBuilder {\n+\treturn &{{$TypeNamePrefix}}BufferBuilder{bufferBuilder:bufferBuilder{refCount: 1, mem:mem}}\n+}\n+\n+// AppendValues appends the contents of v to the buffer, growing the buffer as needed.\n+func (b *{{$TypeNamePrefix}}BufferBuilder) AppendValues(v []{{.Type}}) { b.Append(arrow.{{.Name}}Traits.CastToBytes(v)) }\n+\n+// Values returns a slice of length b.Len().\n+// The slice is only valid for use until the next buffer modification. That is, until the next call\n+// to Advance, Reset, Finish or any Append function. The slice aliases the buffer content at least until the next\n+// buffer modification.\n+func (b *{{$TypeNamePrefix}}BufferBuilder) Values() []{{.Type}}           { return arrow.{{.Name}}Traits.CastFromBytes(b.Bytes()) }\n+\n+// Value returns the {{.Type}} element at the index i. Value will panic if i is negative or \u2265 Len.\n+func (b *{{$TypeNamePrefix}}BufferBuilder) Value(i int) {{.Type}}         { return b.Values()[i] }\n+\n+// Len returns the number of {{.Type}} elements in the buffer.\n+func (b *{{$TypeNamePrefix}}BufferBuilder) Len() int                      { return b.length/arrow.{{.Name}}SizeBytes }\n+\n+// AppendValue appends v to the buffer, growing the buffer as needed.\n+func (b *{{$TypeNamePrefix}}BufferBuilder) AppendValue(v {{.Type}}) {\n+\tif b.capacity < b.length+arrow.{{.Name}}SizeBytes {\n+\t\tnewCapacity := bitutil.NextPowerOf2(b.length + arrow.{{.Name}}SizeBytes)\n+\t\tb.resize(newCapacity)\n+\t}\n+\tarrow.{{.Name}}Traits.PutValue(b.bytes[b.length:], v)\n+\tb.length+=arrow.{{.Name}}SizeBytes\n+}\n+{{end}}\n+{{end}}\n\\ No newline at end of file\ndiff --git a/go/arrow/array/bufferbuilder_numeric_test.go b/go/arrow/array/bufferbuilder_numeric_test.go\nnew file mode 100644\nindex 000000000..a2205ea48\n--- /dev/null\n+++ b/go/arrow/array/bufferbuilder_numeric_test.go\n@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"testing\"\n+\t\"unsafe\"\n+\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestInt32BufferBuilder(t *testing.T) {\n+\tmem := memory.NewCheckedAllocator(memory.NewGoAllocator())\n+\tdefer mem.AssertSize(t, 0)\n+\n+\tbb := newInt32BufferBuilder(mem)\n+\texp := []int32{0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f01, 0x02030405, 0x06070809}\n+\tbb.AppendValues(exp[:3])\n+\tbb.AppendValues(exp[3:])\n+\n+\texpBuf := []byte{\n+\t\t0x04, 0x03, 0x02, 0x01,\n+\t\t0x08, 0x07, 0x06, 0x05,\n+\t\t0x0c, 0x0b, 0x0a, 0x09,\n+\t\t0x01, 0x0f, 0x0e, 0x0d,\n+\t\t0x05, 0x04, 0x03, 0x02,\n+\t\t0x09, 0x08, 0x07, 0x06,\n+\t}\n+\tassert.Equal(t, expBuf, bb.Bytes(), \"unexpected byte values\")\n+\tassert.Equal(t, exp, bb.Values(), \"unexpected int32 values\")\n+\tassert.Equal(t, len(exp), bb.Len(), \"unexpected Len()\")\n+\n+\tbuflen := bb.Len()\n+\tbfr := bb.Finish()\n+\tassert.Equal(t, buflen*int(unsafe.Sizeof(int32(0))), bfr.Len(), \"Buffer was not resized\")\n+\tassert.Len(t, bfr.Bytes(), bfr.Len(), \"Buffer.Bytes() != Buffer.Len()\")\n+\tbfr.Release()\n+\n+\tassert.Len(t, bb.Bytes(), 0, \"BufferBuilder was not reset after Finish\")\n+\tassert.Zero(t, bb.Len(), \"BufferBuilder was not reset after Finish\")\n+\tbb.Release()\n+}\n+\n+func TestInt32BufferBuilder_AppendValue(t *testing.T) {\n+\tmem := memory.NewCheckedAllocator(memory.NewGoAllocator())\n+\tdefer mem.AssertSize(t, 0)\n+\n+\tbb := newInt32BufferBuilder(mem)\n+\texp := []int32{0x01020304, 0x05060708, 0x090a0b0c, 0x0d0e0f01, 0x02030405, 0x06070809}\n+\tfor _, v := range exp {\n+\t\tbb.AppendValue(v)\n+\t}\n+\n+\texpBuf := []byte{\n+\t\t0x04, 0x03, 0x02, 0x01,\n+\t\t0x08, 0x07, 0x06, 0x05,\n+\t\t0x0c, 0x0b, 0x0a, 0x09,\n+\t\t0x01, 0x0f, 0x0e, 0x0d,\n+\t\t0x05, 0x04, 0x03, 0x02,\n+\t\t0x09, 0x08, 0x07, 0x06,\n+\t}\n+\tassert.Equal(t, expBuf, bb.Bytes(), \"unexpected byte values\")\n+\tassert.Equal(t, exp, bb.Values(), \"unexpected int32 values\")\n+\tassert.Equal(t, len(exp), bb.Len(), \"unexpected Len()\")\n+\tbb.Release()\n+}\ndiff --git a/go/arrow/array/builder.go b/go/arrow/array/builder.go\nnew file mode 100644\nindex 000000000..bde12fbc8\n--- /dev/null\n+++ b/go/arrow/array/builder.go\n@@ -0,0 +1,164 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"sync/atomic\"\n+\n+\t\"github.com/apache/arrow/go/arrow/internal/bitutil\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+)\n+\n+const (\n+\tminBuilderCapacity = 1 << 5\n+)\n+\n+// builder provides common functionality for managing the validity bitmap (nulls) when building arrays.\n+type builder struct {\n+\trefCount   int64\n+\tmem        memory.Allocator\n+\tnullBitmap *memory.Buffer\n+\tnullN      int\n+\tlength     int\n+\tcapacity   int\n+}\n+\n+// Retain increases the reference count by 1.\n+// Retain may be called simultaneously from multiple goroutines.\n+func (b *builder) Retain() {\n+\tatomic.AddInt64(&b.refCount, 1)\n+}\n+\n+// Len returns the number of elements in the array builder.\n+func (b *builder) Len() int { return b.length }\n+\n+// Cap returns the total number of elements that can be stored without allocating additional memory.\n+func (b *builder) Cap() int { return b.capacity }\n+\n+// NullN returns the number of null values in the array builder.\n+func (b *builder) NullN() int { return b.nullN }\n+\n+func (b *builder) init(capacity int) {\n+\ttoAlloc := bitutil.CeilByte(capacity) / 8\n+\tb.nullBitmap = memory.NewResizableBuffer(b.mem)\n+\tb.nullBitmap.Resize(toAlloc)\n+\tb.capacity = capacity\n+\tmemory.Set(b.nullBitmap.Buf(), 0)\n+}\n+\n+func (b *builder) reset() {\n+\tif b.nullBitmap != nil {\n+\t\tb.nullBitmap.Release()\n+\t\tb.nullBitmap = nil\n+\t}\n+\n+\tb.nullN = 0\n+\tb.length = 0\n+\tb.capacity = 0\n+}\n+\n+func (b *builder) resize(newBits int, init func(int)) {\n+\tif b.nullBitmap == nil {\n+\t\tinit(newBits)\n+\t\treturn\n+\t}\n+\n+\tnewBytesN := bitutil.CeilByte(newBits) / 8\n+\toldBytesN := b.nullBitmap.Len()\n+\tb.nullBitmap.Resize(newBytesN)\n+\tb.capacity = newBits\n+\tif oldBytesN < newBytesN {\n+\t\t// TODO(sgc): necessary?\n+\t\tmemory.Set(b.nullBitmap.Buf()[oldBytesN:], 0)\n+\t}\n+}\n+\n+func (b *builder) reserve(elements int, resize func(int)) {\n+\tif b.length+elements > b.capacity {\n+\t\tnewCap := bitutil.NextPowerOf2(b.length + elements)\n+\t\tresize(newCap)\n+\t}\n+}\n+\n+// unsafeAppendBoolsToBitmap appends the contents of valid to the validity bitmap.\n+// As an optimization, if the valid slice is empty, the next length bits will be set to valid (not null).\n+func (b *builder) unsafeAppendBoolsToBitmap(valid []bool, length int) {\n+\tif len(valid) == 0 {\n+\t\tb.unsafeSetValid(length)\n+\t\treturn\n+\t}\n+\n+\tbyteOffset := b.length / 8\n+\tbitOffset := byte(b.length % 8)\n+\tnullBitmap := b.nullBitmap.Bytes()\n+\tbitSet := nullBitmap[byteOffset]\n+\n+\tfor _, v := range valid {\n+\t\tif bitOffset == 8 {\n+\t\t\tbitOffset = 0\n+\t\t\tnullBitmap[byteOffset] = bitSet\n+\t\t\tbyteOffset++\n+\t\t\tbitSet = nullBitmap[byteOffset]\n+\t\t}\n+\n+\t\tif v {\n+\t\t\tbitSet |= bitutil.BitMask[bitOffset]\n+\t\t} else {\n+\t\t\tbitSet &= bitutil.FlippedBitMask[bitOffset]\n+\t\t\tb.nullN++\n+\t\t}\n+\t\tbitOffset++\n+\t}\n+\n+\tif bitOffset != 0 {\n+\t\tnullBitmap[byteOffset] = bitSet\n+\t}\n+\tb.length += len(valid)\n+}\n+\n+// unsafeSetValid sets the next length bits to valid in the validity bitmap.\n+func (b *builder) unsafeSetValid(length int) {\n+\tpadToByte := min(8-(b.length%8), length)\n+\tif padToByte == 8 {\n+\t\tpadToByte = 0\n+\t}\n+\tbits := b.nullBitmap.Bytes()\n+\tfor i := b.length; i < b.length+padToByte; i++ {\n+\t\tbitutil.SetBit(bits, i)\n+\t}\n+\n+\tstart := (b.length + padToByte) / 8\n+\tfastLength := (length - padToByte) / 8\n+\tmemory.Set(bits[start:start+fastLength], 0xff)\n+\n+\tnewLength := b.length + length\n+\t// trailing bytes\n+\tfor i := b.length + padToByte + (fastLength * 8); i < newLength; i++ {\n+\t\tbitutil.SetBit(bits, i)\n+\t}\n+\n+\tb.length = newLength\n+}\n+\n+func (b *builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\ndiff --git a/go/arrow/array/builder_test.go b/go/arrow/array/builder_test.go\nnew file mode 100644\nindex 000000000..1ac8f5aa7\n--- /dev/null\n+++ b/go/arrow/array/builder_test.go\n@@ -0,0 +1,57 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow/internal/testing/tools\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestBuilder_Init(t *testing.T) {\n+\ttype exp struct{ size int }\n+\ttests := []struct {\n+\t\tname string\n+\t\tcap  int\n+\n+\t\texp exp\n+\t}{\n+\t\t{\"07 bits\", 07, exp{size: 1}},\n+\t\t{\"19 bits\", 19, exp{size: 3}},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tab := &builder{mem: memory.NewGoAllocator()}\n+\t\t\tab.init(test.cap)\n+\t\t\tassert.Equal(t, test.cap, ab.Cap(), \"invalid capacity\")\n+\t\t\tassert.Equal(t, test.exp.size, ab.nullBitmap.Len(), \"invalid length\")\n+\t\t})\n+\t}\n+}\n+\n+func TestBuilder_UnsafeSetValid(t *testing.T) {\n+\tab := &builder{mem: memory.NewGoAllocator()}\n+\tab.init(32)\n+\tab.unsafeAppendBoolsToBitmap(tools.Bools(0, 0, 0, 0, 0), 5)\n+\tassert.Equal(t, 5, ab.Len())\n+\tassert.Equal(t, []byte{0, 0, 0, 0}, ab.nullBitmap.Bytes())\n+\n+\tab.unsafeSetValid(17)\n+\tassert.Equal(t, []byte{0xe0, 0xff, 0x3f, 0}, ab.nullBitmap.Bytes())\n+}\ndiff --git a/go/arrow/array/data.go b/go/arrow/array/data.go\nnew file mode 100644\nindex 000000000..e689f0fe4\n--- /dev/null\n+++ b/go/arrow/array/data.go\n@@ -0,0 +1,81 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"sync/atomic\"\n+\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/apache/arrow/go/arrow/internal/debug\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+)\n+\n+// A type which represents the memory and metadata for an Arrow array.\n+type Data struct {\n+\trefCount  int64\n+\ttypE      arrow.DataType\n+\tnullN     int\n+\tlength    int\n+\tbuffers   []*memory.Buffer // TODO(sgc): should this be an interface?\n+\tchildData []*Data          // TODO(sgc): managed by ListArray, StructArray and UnionArray types\n+}\n+\n+func NewData(typE arrow.DataType, length int, buffers []*memory.Buffer, nullN int) *Data {\n+\tfor _, b := range buffers {\n+\t\tif b != nil {\n+\t\t\tb.Retain()\n+\t\t}\n+\t}\n+\n+\treturn &Data{\n+\t\trefCount: 1,\n+\t\ttypE:     typE,\n+\t\tnullN:    nullN,\n+\t\tlength:   length,\n+\t\tbuffers:  buffers,\n+\t}\n+}\n+\n+// Retain increases the reference count by 1.\n+// Retain may be called simultaneously from multiple goroutines.\n+func (d *Data) Retain() {\n+\tatomic.AddInt64(&d.refCount, 1)\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+// Release may be called simultaneously from multiple goroutines.\n+func (d *Data) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&d.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&d.refCount, -1) == 0 {\n+\t\tfor _, b := range d.buffers {\n+\t\t\tif b != nil {\n+\t\t\t\tb.Release()\n+\t\t\t}\n+\t\t}\n+\n+\t\tfor _, b := range d.childData {\n+\t\t\tb.Release()\n+\t\t}\n+\t\td.buffers, d.childData = nil, nil\n+\t}\n+}\n+\n+func (d *Data) DataType() arrow.DataType { return d.typE }\n+func (d *Data) NullN() int               { return d.nullN }\n+func (d *Data) Len() int                 { return d.length }\ndiff --git a/go/arrow/array/doc.go b/go/arrow/array/doc.go\nnew file mode 100644\nindex 000000000..5cf854086\n--- /dev/null\n+++ b/go/arrow/array/doc.go\n@@ -0,0 +1,20 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*\n+Package array provides implementations of various Arrow array types.\n+*/\n+package array\ndiff --git a/go/arrow/array/numeric.gen.go b/go/arrow/array/numeric.gen.go\nnew file mode 100644\nindex 000000000..02903f9e3\n--- /dev/null\n+++ b/go/arrow/array/numeric.gen.go\n@@ -0,0 +1,287 @@\n+// Code generated by array/numeric.gen.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow\"\n+)\n+\n+// A type which represents an immutable sequence of int64 values.\n+type Int64 struct {\n+\tarray\n+\tvalues []int64\n+}\n+\n+func NewInt64Data(data *Data) *Int64 {\n+\ta := &Int64{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *Int64) Value(i int) int64    { return a.values[i] }\n+func (a *Int64) Int64Values() []int64 { return a.values }\n+\n+func (a *Int64) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.Int64Traits.CastFromBytes(vals.Bytes())\n+\t}\n+}\n+\n+// A type which represents an immutable sequence of uint64 values.\n+type Uint64 struct {\n+\tarray\n+\tvalues []uint64\n+}\n+\n+func NewUint64Data(data *Data) *Uint64 {\n+\ta := &Uint64{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *Uint64) Value(i int) uint64     { return a.values[i] }\n+func (a *Uint64) Uint64Values() []uint64 { return a.values }\n+\n+func (a *Uint64) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.Uint64Traits.CastFromBytes(vals.Bytes())\n+\t}\n+}\n+\n+// A type which represents an immutable sequence of float64 values.\n+type Float64 struct {\n+\tarray\n+\tvalues []float64\n+}\n+\n+func NewFloat64Data(data *Data) *Float64 {\n+\ta := &Float64{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *Float64) Value(i int) float64      { return a.values[i] }\n+func (a *Float64) Float64Values() []float64 { return a.values }\n+\n+func (a *Float64) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.Float64Traits.CastFromBytes(vals.Bytes())\n+\t}\n+}\n+\n+// A type which represents an immutable sequence of int32 values.\n+type Int32 struct {\n+\tarray\n+\tvalues []int32\n+}\n+\n+func NewInt32Data(data *Data) *Int32 {\n+\ta := &Int32{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *Int32) Value(i int) int32    { return a.values[i] }\n+func (a *Int32) Int32Values() []int32 { return a.values }\n+\n+func (a *Int32) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.Int32Traits.CastFromBytes(vals.Bytes())\n+\t}\n+}\n+\n+// A type which represents an immutable sequence of uint32 values.\n+type Uint32 struct {\n+\tarray\n+\tvalues []uint32\n+}\n+\n+func NewUint32Data(data *Data) *Uint32 {\n+\ta := &Uint32{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *Uint32) Value(i int) uint32     { return a.values[i] }\n+func (a *Uint32) Uint32Values() []uint32 { return a.values }\n+\n+func (a *Uint32) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.Uint32Traits.CastFromBytes(vals.Bytes())\n+\t}\n+}\n+\n+// A type which represents an immutable sequence of float32 values.\n+type Float32 struct {\n+\tarray\n+\tvalues []float32\n+}\n+\n+func NewFloat32Data(data *Data) *Float32 {\n+\ta := &Float32{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *Float32) Value(i int) float32      { return a.values[i] }\n+func (a *Float32) Float32Values() []float32 { return a.values }\n+\n+func (a *Float32) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.Float32Traits.CastFromBytes(vals.Bytes())\n+\t}\n+}\n+\n+// A type which represents an immutable sequence of int16 values.\n+type Int16 struct {\n+\tarray\n+\tvalues []int16\n+}\n+\n+func NewInt16Data(data *Data) *Int16 {\n+\ta := &Int16{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *Int16) Value(i int) int16    { return a.values[i] }\n+func (a *Int16) Int16Values() []int16 { return a.values }\n+\n+func (a *Int16) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.Int16Traits.CastFromBytes(vals.Bytes())\n+\t}\n+}\n+\n+// A type which represents an immutable sequence of uint16 values.\n+type Uint16 struct {\n+\tarray\n+\tvalues []uint16\n+}\n+\n+func NewUint16Data(data *Data) *Uint16 {\n+\ta := &Uint16{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *Uint16) Value(i int) uint16     { return a.values[i] }\n+func (a *Uint16) Uint16Values() []uint16 { return a.values }\n+\n+func (a *Uint16) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.Uint16Traits.CastFromBytes(vals.Bytes())\n+\t}\n+}\n+\n+// A type which represents an immutable sequence of int8 values.\n+type Int8 struct {\n+\tarray\n+\tvalues []int8\n+}\n+\n+func NewInt8Data(data *Data) *Int8 {\n+\ta := &Int8{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *Int8) Value(i int) int8   { return a.values[i] }\n+func (a *Int8) Int8Values() []int8 { return a.values }\n+\n+func (a *Int8) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.Int8Traits.CastFromBytes(vals.Bytes())\n+\t}\n+}\n+\n+// A type which represents an immutable sequence of uint8 values.\n+type Uint8 struct {\n+\tarray\n+\tvalues []uint8\n+}\n+\n+func NewUint8Data(data *Data) *Uint8 {\n+\ta := &Uint8{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *Uint8) Value(i int) uint8    { return a.values[i] }\n+func (a *Uint8) Uint8Values() []uint8 { return a.values }\n+\n+func (a *Uint8) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.Uint8Traits.CastFromBytes(vals.Bytes())\n+\t}\n+}\n+\n+// A type which represents an immutable sequence of arrow.Timestamp values.\n+type Timestamp struct {\n+\tarray\n+\tvalues []arrow.Timestamp\n+}\n+\n+func NewTimestampData(data *Data) *Timestamp {\n+\ta := &Timestamp{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *Timestamp) Value(i int) arrow.Timestamp        { return a.values[i] }\n+func (a *Timestamp) TimestampValues() []arrow.Timestamp { return a.values }\n+\n+func (a *Timestamp) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.TimestampTraits.CastFromBytes(vals.Bytes())\n+\t}\n+}\ndiff --git a/go/arrow/array/numeric.gen.go.tmpl b/go/arrow/array/numeric.gen.go.tmpl\nnew file mode 100644\nindex 000000000..5c33a36d5\n--- /dev/null\n+++ b/go/arrow/array/numeric.gen.go.tmpl\n@@ -0,0 +1,48 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow\"\n+)\n+\n+{{range .In}}\n+\n+// A type which represents an immutable sequence of {{or .QualifiedType .Type}} values.\n+type {{.Name}} struct {\n+\tarray\n+\tvalues []{{or .QualifiedType .Type}}\n+}\n+\n+func New{{.Name}}Data(data *Data) *{{.Name}} {\n+\ta := &{{.Name}}{}\n+\ta.refCount = 1\n+\ta.setData(data)\n+\treturn a\n+}\n+\n+func (a *{{.Name}}) Value(i int)      {{or .QualifiedType .Type}} { return a.values[i] }\n+func (a *{{.Name}}) {{.Name}}Values() []{{or .QualifiedType .Type}} { return a.values }\n+\n+func (a *{{.Name}}) setData(data *Data) {\n+\ta.array.setData(data)\n+\tvals := data.buffers[1]\n+\tif vals != nil {\n+\t\ta.values = arrow.{{.Name}}Traits.CastFromBytes(vals.Bytes())\n+\t}\n+}\n+{{end}}\n\\ No newline at end of file\ndiff --git a/go/arrow/array/numeric_test.go b/go/arrow/array/numeric_test.go\nnew file mode 100644\nindex 000000000..d5b798f3d\n--- /dev/null\n+++ b/go/arrow/array/numeric_test.go\n@@ -0,0 +1,36 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestNewFloat64Data(t *testing.T) {\n+\texp := []float64{1.0, 2.0, 4.0, 8.0, 16.0}\n+\n+\tad := array.NewData(arrow.PrimitiveTypes.Float64, len(exp), []*memory.Buffer{nil, memory.NewBufferBytes(arrow.Float64Traits.CastToBytes(exp))}, 0)\n+\tfa := array.NewFloat64Data(ad)\n+\n+\tassert.Equal(t, len(exp), fa.Len(), \"unexpected Len()\")\n+\tassert.Equal(t, exp, fa.Float64Values(), \"unexpected Float64Values()\")\n+}\ndiff --git a/go/arrow/array/numericbuilder.gen.go b/go/arrow/array/numericbuilder.gen.go\nnew file mode 100644\nindex 000000000..c4e3508bb\n--- /dev/null\n+++ b/go/arrow/array/numericbuilder.gen.go\n@@ -0,0 +1,1415 @@\n+// Code generated by array/numericbuilder.gen.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"sync/atomic\"\n+\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/apache/arrow/go/arrow/internal/bitutil\"\n+\t\"github.com/apache/arrow/go/arrow/internal/debug\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+)\n+\n+type Int64Builder struct {\n+\tbuilder\n+\n+\tdata    *memory.Buffer\n+\trawData []int64\n+}\n+\n+func NewInt64Builder(mem memory.Allocator) *Int64Builder {\n+\treturn &Int64Builder{builder: builder{refCount: 1, mem: mem}}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Int64Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *Int64Builder) Append(v int64) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *Int64Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *Int64Builder) UnsafeAppend(v int64) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *Int64Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *Int64Builder) AppendValues(v []int64, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tif len(v) > 0 {\n+\t\tarrow.Int64Traits.Copy(b.rawData[b.length:], v)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *Int64Builder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.Int64Traits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = arrow.Int64Traits.CastFromBytes(b.data.Bytes())\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *Int64Builder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *Int64Builder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.Int64Traits.BytesRequired(n))\n+\t\tb.rawData = arrow.Int64Traits.CastFromBytes(b.data.Bytes())\n+\t}\n+}\n+\n+// NewInt64Array creates a Int64 array from the memory buffers used by the builder and resets the Int64Builder\n+// so it can be used to build a new array.\n+func (b *Int64Builder) NewInt64Array() (a *Int64) {\n+\tdata := b.newData()\n+\ta = NewInt64Data(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *Int64Builder) newData() (data *Data) {\n+\tbytesRequired := arrow.Int64Traits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+\tdata = NewData(arrow.PrimitiveTypes.Int64, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn\n+}\n+\n+type Uint64Builder struct {\n+\tbuilder\n+\n+\tdata    *memory.Buffer\n+\trawData []uint64\n+}\n+\n+func NewUint64Builder(mem memory.Allocator) *Uint64Builder {\n+\treturn &Uint64Builder{builder: builder{refCount: 1, mem: mem}}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Uint64Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *Uint64Builder) Append(v uint64) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *Uint64Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *Uint64Builder) UnsafeAppend(v uint64) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *Uint64Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *Uint64Builder) AppendValues(v []uint64, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tif len(v) > 0 {\n+\t\tarrow.Uint64Traits.Copy(b.rawData[b.length:], v)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *Uint64Builder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.Uint64Traits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = arrow.Uint64Traits.CastFromBytes(b.data.Bytes())\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *Uint64Builder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *Uint64Builder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.Uint64Traits.BytesRequired(n))\n+\t\tb.rawData = arrow.Uint64Traits.CastFromBytes(b.data.Bytes())\n+\t}\n+}\n+\n+// NewUint64Array creates a Uint64 array from the memory buffers used by the builder and resets the Uint64Builder\n+// so it can be used to build a new array.\n+func (b *Uint64Builder) NewUint64Array() (a *Uint64) {\n+\tdata := b.newData()\n+\ta = NewUint64Data(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *Uint64Builder) newData() (data *Data) {\n+\tbytesRequired := arrow.Uint64Traits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+\tdata = NewData(arrow.PrimitiveTypes.Uint64, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn\n+}\n+\n+type Float64Builder struct {\n+\tbuilder\n+\n+\tdata    *memory.Buffer\n+\trawData []float64\n+}\n+\n+func NewFloat64Builder(mem memory.Allocator) *Float64Builder {\n+\treturn &Float64Builder{builder: builder{refCount: 1, mem: mem}}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Float64Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *Float64Builder) Append(v float64) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *Float64Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *Float64Builder) UnsafeAppend(v float64) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *Float64Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *Float64Builder) AppendValues(v []float64, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tif len(v) > 0 {\n+\t\tarrow.Float64Traits.Copy(b.rawData[b.length:], v)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *Float64Builder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.Float64Traits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = arrow.Float64Traits.CastFromBytes(b.data.Bytes())\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *Float64Builder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *Float64Builder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.Float64Traits.BytesRequired(n))\n+\t\tb.rawData = arrow.Float64Traits.CastFromBytes(b.data.Bytes())\n+\t}\n+}\n+\n+// NewFloat64Array creates a Float64 array from the memory buffers used by the builder and resets the Float64Builder\n+// so it can be used to build a new array.\n+func (b *Float64Builder) NewFloat64Array() (a *Float64) {\n+\tdata := b.newData()\n+\ta = NewFloat64Data(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *Float64Builder) newData() (data *Data) {\n+\tbytesRequired := arrow.Float64Traits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+\tdata = NewData(arrow.PrimitiveTypes.Float64, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn\n+}\n+\n+type Int32Builder struct {\n+\tbuilder\n+\n+\tdata    *memory.Buffer\n+\trawData []int32\n+}\n+\n+func NewInt32Builder(mem memory.Allocator) *Int32Builder {\n+\treturn &Int32Builder{builder: builder{refCount: 1, mem: mem}}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Int32Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *Int32Builder) Append(v int32) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *Int32Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *Int32Builder) UnsafeAppend(v int32) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *Int32Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *Int32Builder) AppendValues(v []int32, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tif len(v) > 0 {\n+\t\tarrow.Int32Traits.Copy(b.rawData[b.length:], v)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *Int32Builder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.Int32Traits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = arrow.Int32Traits.CastFromBytes(b.data.Bytes())\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *Int32Builder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *Int32Builder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.Int32Traits.BytesRequired(n))\n+\t\tb.rawData = arrow.Int32Traits.CastFromBytes(b.data.Bytes())\n+\t}\n+}\n+\n+// NewInt32Array creates a Int32 array from the memory buffers used by the builder and resets the Int32Builder\n+// so it can be used to build a new array.\n+func (b *Int32Builder) NewInt32Array() (a *Int32) {\n+\tdata := b.newData()\n+\ta = NewInt32Data(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *Int32Builder) newData() (data *Data) {\n+\tbytesRequired := arrow.Int32Traits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+\tdata = NewData(arrow.PrimitiveTypes.Int32, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn\n+}\n+\n+type Uint32Builder struct {\n+\tbuilder\n+\n+\tdata    *memory.Buffer\n+\trawData []uint32\n+}\n+\n+func NewUint32Builder(mem memory.Allocator) *Uint32Builder {\n+\treturn &Uint32Builder{builder: builder{refCount: 1, mem: mem}}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Uint32Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *Uint32Builder) Append(v uint32) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *Uint32Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *Uint32Builder) UnsafeAppend(v uint32) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *Uint32Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *Uint32Builder) AppendValues(v []uint32, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tif len(v) > 0 {\n+\t\tarrow.Uint32Traits.Copy(b.rawData[b.length:], v)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *Uint32Builder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.Uint32Traits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = arrow.Uint32Traits.CastFromBytes(b.data.Bytes())\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *Uint32Builder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *Uint32Builder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.Uint32Traits.BytesRequired(n))\n+\t\tb.rawData = arrow.Uint32Traits.CastFromBytes(b.data.Bytes())\n+\t}\n+}\n+\n+// NewUint32Array creates a Uint32 array from the memory buffers used by the builder and resets the Uint32Builder\n+// so it can be used to build a new array.\n+func (b *Uint32Builder) NewUint32Array() (a *Uint32) {\n+\tdata := b.newData()\n+\ta = NewUint32Data(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *Uint32Builder) newData() (data *Data) {\n+\tbytesRequired := arrow.Uint32Traits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+\tdata = NewData(arrow.PrimitiveTypes.Uint32, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn\n+}\n+\n+type Float32Builder struct {\n+\tbuilder\n+\n+\tdata    *memory.Buffer\n+\trawData []float32\n+}\n+\n+func NewFloat32Builder(mem memory.Allocator) *Float32Builder {\n+\treturn &Float32Builder{builder: builder{refCount: 1, mem: mem}}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Float32Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *Float32Builder) Append(v float32) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *Float32Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *Float32Builder) UnsafeAppend(v float32) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *Float32Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *Float32Builder) AppendValues(v []float32, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tif len(v) > 0 {\n+\t\tarrow.Float32Traits.Copy(b.rawData[b.length:], v)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *Float32Builder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.Float32Traits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = arrow.Float32Traits.CastFromBytes(b.data.Bytes())\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *Float32Builder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *Float32Builder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.Float32Traits.BytesRequired(n))\n+\t\tb.rawData = arrow.Float32Traits.CastFromBytes(b.data.Bytes())\n+\t}\n+}\n+\n+// NewFloat32Array creates a Float32 array from the memory buffers used by the builder and resets the Float32Builder\n+// so it can be used to build a new array.\n+func (b *Float32Builder) NewFloat32Array() (a *Float32) {\n+\tdata := b.newData()\n+\ta = NewFloat32Data(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *Float32Builder) newData() (data *Data) {\n+\tbytesRequired := arrow.Float32Traits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+\tdata = NewData(arrow.PrimitiveTypes.Float32, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn\n+}\n+\n+type Int16Builder struct {\n+\tbuilder\n+\n+\tdata    *memory.Buffer\n+\trawData []int16\n+}\n+\n+func NewInt16Builder(mem memory.Allocator) *Int16Builder {\n+\treturn &Int16Builder{builder: builder{refCount: 1, mem: mem}}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Int16Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *Int16Builder) Append(v int16) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *Int16Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *Int16Builder) UnsafeAppend(v int16) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *Int16Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *Int16Builder) AppendValues(v []int16, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tif len(v) > 0 {\n+\t\tarrow.Int16Traits.Copy(b.rawData[b.length:], v)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *Int16Builder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.Int16Traits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = arrow.Int16Traits.CastFromBytes(b.data.Bytes())\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *Int16Builder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *Int16Builder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.Int16Traits.BytesRequired(n))\n+\t\tb.rawData = arrow.Int16Traits.CastFromBytes(b.data.Bytes())\n+\t}\n+}\n+\n+// NewInt16Array creates a Int16 array from the memory buffers used by the builder and resets the Int16Builder\n+// so it can be used to build a new array.\n+func (b *Int16Builder) NewInt16Array() (a *Int16) {\n+\tdata := b.newData()\n+\ta = NewInt16Data(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *Int16Builder) newData() (data *Data) {\n+\tbytesRequired := arrow.Int16Traits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+\tdata = NewData(arrow.PrimitiveTypes.Int16, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn\n+}\n+\n+type Uint16Builder struct {\n+\tbuilder\n+\n+\tdata    *memory.Buffer\n+\trawData []uint16\n+}\n+\n+func NewUint16Builder(mem memory.Allocator) *Uint16Builder {\n+\treturn &Uint16Builder{builder: builder{refCount: 1, mem: mem}}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Uint16Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *Uint16Builder) Append(v uint16) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *Uint16Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *Uint16Builder) UnsafeAppend(v uint16) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *Uint16Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *Uint16Builder) AppendValues(v []uint16, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tif len(v) > 0 {\n+\t\tarrow.Uint16Traits.Copy(b.rawData[b.length:], v)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *Uint16Builder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.Uint16Traits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = arrow.Uint16Traits.CastFromBytes(b.data.Bytes())\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *Uint16Builder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *Uint16Builder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.Uint16Traits.BytesRequired(n))\n+\t\tb.rawData = arrow.Uint16Traits.CastFromBytes(b.data.Bytes())\n+\t}\n+}\n+\n+// NewUint16Array creates a Uint16 array from the memory buffers used by the builder and resets the Uint16Builder\n+// so it can be used to build a new array.\n+func (b *Uint16Builder) NewUint16Array() (a *Uint16) {\n+\tdata := b.newData()\n+\ta = NewUint16Data(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *Uint16Builder) newData() (data *Data) {\n+\tbytesRequired := arrow.Uint16Traits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+\tdata = NewData(arrow.PrimitiveTypes.Uint16, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn\n+}\n+\n+type Int8Builder struct {\n+\tbuilder\n+\n+\tdata    *memory.Buffer\n+\trawData []int8\n+}\n+\n+func NewInt8Builder(mem memory.Allocator) *Int8Builder {\n+\treturn &Int8Builder{builder: builder{refCount: 1, mem: mem}}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Int8Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *Int8Builder) Append(v int8) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *Int8Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *Int8Builder) UnsafeAppend(v int8) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *Int8Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *Int8Builder) AppendValues(v []int8, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tif len(v) > 0 {\n+\t\tarrow.Int8Traits.Copy(b.rawData[b.length:], v)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *Int8Builder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.Int8Traits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = arrow.Int8Traits.CastFromBytes(b.data.Bytes())\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *Int8Builder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *Int8Builder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.Int8Traits.BytesRequired(n))\n+\t\tb.rawData = arrow.Int8Traits.CastFromBytes(b.data.Bytes())\n+\t}\n+}\n+\n+// NewInt8Array creates a Int8 array from the memory buffers used by the builder and resets the Int8Builder\n+// so it can be used to build a new array.\n+func (b *Int8Builder) NewInt8Array() (a *Int8) {\n+\tdata := b.newData()\n+\ta = NewInt8Data(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *Int8Builder) newData() (data *Data) {\n+\tbytesRequired := arrow.Int8Traits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+\tdata = NewData(arrow.PrimitiveTypes.Int8, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn\n+}\n+\n+type Uint8Builder struct {\n+\tbuilder\n+\n+\tdata    *memory.Buffer\n+\trawData []uint8\n+}\n+\n+func NewUint8Builder(mem memory.Allocator) *Uint8Builder {\n+\treturn &Uint8Builder{builder: builder{refCount: 1, mem: mem}}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Uint8Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *Uint8Builder) Append(v uint8) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *Uint8Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *Uint8Builder) UnsafeAppend(v uint8) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *Uint8Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *Uint8Builder) AppendValues(v []uint8, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tif len(v) > 0 {\n+\t\tarrow.Uint8Traits.Copy(b.rawData[b.length:], v)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *Uint8Builder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.Uint8Traits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = arrow.Uint8Traits.CastFromBytes(b.data.Bytes())\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *Uint8Builder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *Uint8Builder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.Uint8Traits.BytesRequired(n))\n+\t\tb.rawData = arrow.Uint8Traits.CastFromBytes(b.data.Bytes())\n+\t}\n+}\n+\n+// NewUint8Array creates a Uint8 array from the memory buffers used by the builder and resets the Uint8Builder\n+// so it can be used to build a new array.\n+func (b *Uint8Builder) NewUint8Array() (a *Uint8) {\n+\tdata := b.newData()\n+\ta = NewUint8Data(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *Uint8Builder) newData() (data *Data) {\n+\tbytesRequired := arrow.Uint8Traits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+\tdata = NewData(arrow.PrimitiveTypes.Uint8, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn\n+}\n+\n+type TimestampBuilder struct {\n+\tbuilder\n+\n+\ttypE    *arrow.TimestampType\n+\tdata    *memory.Buffer\n+\trawData []arrow.Timestamp\n+}\n+\n+func NewTimestampBuilder(mem memory.Allocator, typE *arrow.TimestampType) *TimestampBuilder {\n+\treturn &TimestampBuilder{builder: builder{refCount: 1, mem: mem}, typE: typE}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *TimestampBuilder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *TimestampBuilder) Append(v arrow.Timestamp) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *TimestampBuilder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *TimestampBuilder) UnsafeAppend(v arrow.Timestamp) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *TimestampBuilder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *TimestampBuilder) AppendValues(v []arrow.Timestamp, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tif len(v) > 0 {\n+\t\tarrow.TimestampTraits.Copy(b.rawData[b.length:], v)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *TimestampBuilder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.TimestampTraits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = arrow.TimestampTraits.CastFromBytes(b.data.Bytes())\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *TimestampBuilder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *TimestampBuilder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.TimestampTraits.BytesRequired(n))\n+\t\tb.rawData = arrow.TimestampTraits.CastFromBytes(b.data.Bytes())\n+\t}\n+}\n+\n+// NewTimestampArray creates a Timestamp array from the memory buffers used by the builder and resets the TimestampBuilder\n+// so it can be used to build a new array.\n+func (b *TimestampBuilder) NewTimestampArray() (a *Timestamp) {\n+\tdata := b.newData()\n+\ta = NewTimestampData(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *TimestampBuilder) newData() (data *Data) {\n+\tbytesRequired := arrow.TimestampTraits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+\tdata = NewData(b.typE, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn\n+}\ndiff --git a/go/arrow/array/numericbuilder.gen.go.tmpl b/go/arrow/array/numericbuilder.gen.go.tmpl\nnew file mode 100644\nindex 000000000..1b2aaf08a\n--- /dev/null\n+++ b/go/arrow/array/numericbuilder.gen.go.tmpl\n@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/apache/arrow/go/arrow/internal/debug\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+)\n+\n+{{range .In}}\n+\n+type {{.Name}}Builder struct {\n+\tbuilder\n+\n+{{if .Opt.Parametric -}}\n+\ttypE    *arrow.{{.Name}}Type\n+{{end -}}\n+\tdata    *memory.Buffer\n+\trawData []{{or .QualifiedType .Type}}\n+}\n+\n+{{if .Opt.Parametric}}\n+func New{{.Name}}Builder(mem memory.Allocator, typE *arrow.{{.Name}}Type) *{{.Name}}Builder {\n+\treturn &{{.Name}}Builder{builder: builder{refCount:1, mem: mem}, typE: typE}\n+}\n+{{else}}\n+func New{{.Name}}Builder(mem memory.Allocator) *{{.Name}}Builder {\n+\treturn &{{.Name}}Builder{builder: builder{refCount:1, mem: mem}}\n+}\n+{{end}}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *{{.Name}}Builder) Release() {\n+\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\tif b.nullBitmap != nil {\n+\t\t\tb.nullBitmap.Release()\n+\t\t\tb.nullBitmap = nil\n+\t\t}\n+\t\tif b.data != nil {\n+\t\t\tb.data.Release()\n+\t\t\tb.data = nil\n+\t\t}\n+\t}\n+}\n+\n+func (b *{{.Name}}Builder) Append(v {{or .QualifiedType .Type}}) {\n+\tb.Reserve(1)\n+\tb.UnsafeAppend(v)\n+}\n+\n+func (b *{{.Name}}Builder) AppendNull() {\n+\tb.Reserve(1)\n+\tb.UnsafeAppendBoolToBitmap(false)\n+}\n+\n+func (b *{{.Name}}Builder) UnsafeAppend(v {{or .QualifiedType .Type}}) {\n+\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\tb.rawData[b.length] = v\n+\tb.length++\n+}\n+\n+func (b *{{.Name}}Builder) UnsafeAppendBoolToBitmap(isValid bool) {\n+\tif isValid {\n+\t\tbitutil.SetBit(b.nullBitmap.Bytes(), b.length)\n+\t} else {\n+\t\tb.nullN++\n+\t}\n+\tb.length++\n+}\n+\n+// AppendValues will append the values in the v slice. The valid slice determines which values\n+// in v are valid (not null). The valid slice must either be empty or be equal in length to v. If empty,\n+// all values in v are appended and considered valid.\n+func (b *{{.Name}}Builder) AppendValues(v []{{or .QualifiedType .Type}}, valid []bool) {\n+\tif len(v) != len(valid) && len(valid) != 0 {\n+\t\tpanic(\"len(v) != len(valid) && len(valid) != 0\")\n+\t}\n+\n+\tb.Reserve(len(v))\n+\tif len(v) > 0 {\n+\t\tarrow.{{.Name}}Traits.Copy(b.rawData[b.length:], v)\n+\t}\n+\tb.builder.unsafeAppendBoolsToBitmap(valid, len(v))\n+}\n+\n+func (b *{{.Name}}Builder) init(capacity int) {\n+\tb.builder.init(capacity)\n+\n+\tb.data = memory.NewResizableBuffer(b.mem)\n+\tbytesN := arrow.{{.Name}}Traits.BytesRequired(capacity)\n+\tb.data.Resize(bytesN)\n+\tb.rawData = arrow.{{.Name}}Traits.CastFromBytes(b.data.Bytes())\n+}\n+\n+// Reserve ensures there is enough space for appending n elements\n+// by checking the capacity and calling Resize if necessary.\n+func (b *{{.Name}}Builder) Reserve(n int) {\n+\tb.builder.reserve(n, b.Resize)\n+}\n+\n+// Resize adjusts the space allocated by b to n elements. If n is greater than b.Cap(),\n+// additional memory will be allocated. If n is smaller, the allocated memory may reduced.\n+func (b *{{.Name}}Builder) Resize(n int) {\n+\tif n < minBuilderCapacity {\n+\t\tn = minBuilderCapacity\n+\t}\n+\n+\tif b.capacity == 0 {\n+\t\tb.init(n)\n+\t} else {\n+\t\tb.builder.resize(n, b.init)\n+\t\tb.data.Resize(arrow.{{.Name}}Traits.BytesRequired(n))\n+\t\tb.rawData = arrow.{{.Name}}Traits.CastFromBytes(b.data.Bytes())\n+\t}\n+}\n+\n+// New{{.Name}}Array creates a {{.Name}} array from the memory buffers used by the builder and resets the {{.Name}}Builder\n+// so it can be used to build a new array.\n+func (b *{{.Name}}Builder) New{{.Name}}Array() (a *{{.Name}}) {\n+\tdata := b.newData()\n+\ta = New{{.Name}}Data(data)\n+\tdata.Release()\n+\treturn\n+}\n+\n+func (b *{{.Name}}Builder) newData() (data *Data) {\n+\tbytesRequired := arrow.{{.Name}}Traits.BytesRequired(b.length)\n+\tif bytesRequired > 0 && bytesRequired < b.data.Len() {\n+\t\t// trim buffers\n+\t\tb.data.Resize(bytesRequired)\n+\t}\n+{{if .Opt.Parametric -}}\n+\tdata = NewData(b.typE, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+{{else -}}\n+\tdata = NewData(arrow.PrimitiveTypes.{{.Name}}, b.length, []*memory.Buffer{b.nullBitmap, b.data}, b.nullN)\n+{{end -}}\n+\tb.reset()\n+\n+\tif b.data != nil {\n+\t\tb.data.Release()\n+\t\tb.data = nil\n+\t\tb.rawData = nil\n+\t}\n+\n+\treturn\n+}\n+{{end}}\n\\ No newline at end of file\ndiff --git a/go/arrow/array/numericbuilder_test.go b/go/arrow/array/numericbuilder_test.go\nnew file mode 100644\nindex 000000000..c0cd7adc2\n--- /dev/null\n+++ b/go/arrow/array/numericbuilder_test.go\n@@ -0,0 +1,107 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestNewFloat64Builder(t *testing.T) {\n+\tmem := memory.NewCheckedAllocator(memory.NewGoAllocator())\n+\tdefer mem.AssertSize(t, 0)\n+\n+\tab := array.NewFloat64Builder(mem)\n+\n+\tab.Append(1)\n+\tab.Append(2)\n+\tab.Append(3)\n+\tab.AppendNull()\n+\tab.Append(5)\n+\tab.Append(6)\n+\tab.AppendNull()\n+\tab.Append(8)\n+\tab.Append(9)\n+\tab.Append(10)\n+\n+\t// check state of builder before NewFloat64Array\n+\tassert.Equal(t, 10, ab.Len(), \"unexpected Len()\")\n+\tassert.Equal(t, 2, ab.NullN(), \"unexpected NullN()\")\n+\n+\ta := ab.NewFloat64Array()\n+\n+\t// check state of builder after NewFloat64Array\n+\tassert.Zero(t, ab.Len(), \"unexpected ArrayBuilder.Len(), NewFloat64Array did not reset state\")\n+\tassert.Zero(t, ab.Cap(), \"unexpected ArrayBuilder.Cap(), NewFloat64Array did not reset state\")\n+\tassert.Zero(t, ab.NullN(), \"unexpected ArrayBuilder.NullN(), NewFloat64Array did not reset state\")\n+\n+\t// check state of array\n+\tassert.Equal(t, 2, a.NullN(), \"unexpected null count\")\n+\tassert.Equal(t, []float64{1, 2, 3, 0, 5, 6, 0, 8, 9, 10}, a.Float64Values(), \"unexpected Float64Values\")\n+\tassert.Equal(t, []byte{0xb7}, a.NullBitmapBytes()[:1]) // 4 bytes due to minBuilderCapacity\n+\tassert.Len(t, a.Float64Values(), 10, \"unexpected length of Float64Values\")\n+\n+\ta.Release()\n+\n+\tab.Append(7)\n+\tab.Append(8)\n+\n+\ta = ab.NewFloat64Array()\n+\n+\tassert.Equal(t, 0, a.NullN())\n+\tassert.Equal(t, []float64{7, 8}, a.Float64Values())\n+\tassert.Len(t, a.Float64Values(), 2)\n+\n+\ta.Release()\n+}\n+\n+func TestFloat32Builder_AppendValues(t *testing.T) {\n+\tmem := memory.NewCheckedAllocator(memory.NewGoAllocator())\n+\tdefer mem.AssertSize(t, 0)\n+\n+\tab := array.NewFloat64Builder(mem)\n+\n+\texp := []float64{1.0, 1.1, 1.2, 1.3}\n+\tab.AppendValues(exp, nil)\n+\ta := ab.NewFloat64Array()\n+\tassert.Equal(t, exp, a.Float64Values())\n+\n+\ta.Release()\n+\tab.Release()\n+}\n+\n+func TestFloat32Builder_Empty(t *testing.T) {\n+\tmem := memory.NewCheckedAllocator(memory.NewGoAllocator())\n+\tdefer mem.AssertSize(t, 0)\n+\n+\tab := array.NewFloat64Builder(mem)\n+\n+\texp := []float64{1.0, 1.1, 1.2, 1.3}\n+\tab.AppendValues(exp, nil)\n+\ta := ab.NewFloat64Array()\n+\tassert.Equal(t, exp, a.Float64Values())\n+\ta.Release()\n+\n+\ta = ab.NewFloat64Array()\n+\tassert.Zero(t, a.Len())\n+\ta.Release()\n+\n+\tab.Release()\n+}\ndiff --git a/go/arrow/array/util.go b/go/arrow/array/util.go\nnew file mode 100644\nindex 000000000..c8d7e17c2\n--- /dev/null\n+++ b/go/arrow/array/util.go\n@@ -0,0 +1,24 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package array\n+\n+func min(a, b int) int {\n+\tif a < b {\n+\t\treturn a\n+\t}\n+\treturn b\n+}\ndiff --git a/go/arrow/datatype.go b/go/arrow/datatype.go\nnew file mode 100644\nindex 000000000..3329e5085\n--- /dev/null\n+++ b/go/arrow/datatype.go\n@@ -0,0 +1,133 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package arrow\n+\n+// Type is a logical type. They can be expressed as\n+// either a primitive physical type (bytes or bits of some fixed size), a\n+// nested type consisting of other data types, or another data type (e.g. a\n+// timestamp encoded as an int64)\n+type Type int\n+\n+const (\n+\t// NULL type having no physical storage\n+\tNULL Type = iota\n+\n+\t// BOOL is a 1 bit, LSB bit-packed ordering\n+\tBOOL\n+\n+\t// UINT8 is an Unsigned 8-bit little-endian integer\n+\tUINT8\n+\n+\t// INT8 is a Signed 8-bit little-endian integer\n+\tINT8\n+\n+\t// UINT16 is an Unsigned 16-bit little-endian integer\n+\tUINT16\n+\n+\t// INT16 is a Signed 16-bit little-endian integer\n+\tINT16\n+\n+\t// UINT32 is an Unsigned 32-bit little-endian integer\n+\tUINT32\n+\n+\t// INT32 is a Signed 32-bit little-endian integer\n+\tINT32\n+\n+\t// UINT64 is an Unsigned 64-bit little-endian integer\n+\tUINT64\n+\n+\t// INT64 is a Signed 64-bit little-endian integer\n+\tINT64\n+\n+\t// HALF_FLOAT is a 2-byte floating point value\n+\tHALF_FLOAT\n+\n+\t// FLOAT32 is a 4-byte floating point value\n+\tFLOAT32\n+\n+\t// FLOAT64 is an 8-byte floating point value\n+\tFLOAT64\n+\n+\t// STRING is a UTF8 variable-length string\n+\tSTRING\n+\n+\t// BINARY is a Variable-length byte type (no guarantee of UTF8-ness)\n+\tBINARY\n+\n+\t// FIXED_SIZE_BINARY is a binary where each value occupies the same number of bytes\n+\tFIXED_SIZE_BINARY\n+\n+\t// DATE32 is int32 days since the UNIX epoch\n+\tDATE32\n+\n+\t// DATE64 is int64 milliseconds since the UNIX epoch\n+\tDATE64\n+\n+\t// TIMESTAMP is an exact timestamp encoded with int64 since UNIX epoch\n+\t// Default unit millisecond\n+\tTIMESTAMP\n+\n+\t// TIME32 is a signed 32-bit integer, representing either seconds or\n+\t// milliseconds since midnight\n+\tTIME32\n+\n+\t// TIME64 is a signed 64-bit integer, representing either microseconds or\n+\t// nanoseconds since midnight\n+\tTIME64\n+\n+\t// INTERVAL is YEAR_MONTH or DAY_TIME interval in SQL style\n+\tINTERVAL\n+\n+\t// DECIMAL is a precision- and scale-based decimal type. Storage type depends on the\n+\t// parameters.\n+\tDECIMAL\n+\n+\t// LIST is a list of some logical data type\n+\tLIST\n+\n+\t// STRUCT of logical types\n+\tSTRUCT\n+\n+\t// UNION of logical types\n+\tUNION\n+\n+\t// DICTIONARY aka Category type\n+\tDICTIONARY\n+\n+\t// MAP is a repeated struct logical type\n+\tMAP\n+)\n+\n+// DataType is the representation of an Arrow type.\n+type DataType interface {\n+\tID() Type\n+\t// Name is name of the data type.\n+\tName() string\n+}\n+\n+// FixedWidthDataType is the representation of an Arrow type that\n+// requires a fixed number of bits in memory for each element.\n+type FixedWidthDataType interface {\n+\tDataType\n+\t// BitWidth returns the number of bits required to store a single element of this data type in memory.\n+\tBitWidth() int\n+}\n+\n+type BinaryDataType interface {\n+\tDataType\n+\tbinary()\n+}\ndiff --git a/go/arrow/datatype_binary.go b/go/arrow/datatype_binary.go\nnew file mode 100644\nindex 000000000..40ab860de\n--- /dev/null\n+++ b/go/arrow/datatype_binary.go\n@@ -0,0 +1,39 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package arrow\n+\n+type BinaryType struct{}\n+\n+func (t *BinaryType) ID() Type     { return BINARY }\n+func (t *BinaryType) Name() string { return \"binary\" }\n+func (t *BinaryType) binary()      {}\n+\n+type StringType struct{}\n+\n+func (t *StringType) ID() Type     { return STRING }\n+func (t *StringType) Name() string { return \"utf8\" }\n+func (t *StringType) binary()      {}\n+\n+var (\n+\tBinaryTypes = struct {\n+\t\tBinary BinaryDataType\n+\t\tString BinaryDataType\n+\t}{\n+\t\tBinary: &BinaryType{},\n+\t\tString: &StringType{},\n+\t}\n+)\ndiff --git a/go/arrow/datatype_fixedwidth.go b/go/arrow/datatype_fixedwidth.go\nnew file mode 100644\nindex 000000000..de96ccba4\n--- /dev/null\n+++ b/go/arrow/datatype_fixedwidth.go\n@@ -0,0 +1,61 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package arrow\n+\n+type BooleanType struct{}\n+\n+func (t *BooleanType) ID() Type     { return BOOL }\n+func (t *BooleanType) Name() string { return \"bool\" }\n+\n+// BitWidth returns the number of bits required to store a single element of this data type in memory.\n+func (t *BooleanType) BitWidth() int { return 1 }\n+\n+type (\n+\tTimestamp int64\n+\tTimeUnit  int\n+)\n+\n+const (\n+\tNanosecond TimeUnit = iota\n+\tMicrosecond\n+\tMillisecond\n+\tSecond\n+)\n+\n+func (u TimeUnit) String() string { return [...]string{\"ns\", \"\u00b5s\", \"ms\", \"s\"}[uint(u)&3] }\n+\n+// TimestampType is encoded as a 64-bit signed integer since the UNIX epoch (2017-01-01T00:00:00Z).\n+// The zero-value is a nanosecond and time zone neutral. Time zone neutral can be\n+// considered UTC without having \"UTC\" as a time zone.\n+type TimestampType struct {\n+\tUnit     TimeUnit\n+\tTimeZone string\n+}\n+\n+func (*TimestampType) ID() Type     { return TIMESTAMP }\n+func (*TimestampType) Name() string { return \"timestamp\" }\n+\n+// BitWidth returns the number of bits required to store a single element of this data type in memory.\n+func (*TimestampType) BitWidth() int { return 64 }\n+\n+var (\n+\tFixedWidthTypes = struct {\n+\t\tBoolean FixedWidthDataType\n+\t}{\n+\t\tBoolean: &BooleanType{},\n+\t}\n+)\ndiff --git a/go/arrow/datatype_fixedwidth_test.go b/go/arrow/datatype_fixedwidth_test.go\nnew file mode 100644\nindex 000000000..44fbdd135\n--- /dev/null\n+++ b/go/arrow/datatype_fixedwidth_test.go\n@@ -0,0 +1,42 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package arrow_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+// TestTimeUnit_String verifies each time unit matches its string representation.\n+func TestTimeUnit_String(t *testing.T) {\n+\ttests := []struct {\n+\t\tu   arrow.TimeUnit\n+\t\texp string\n+\t}{\n+\t\t{arrow.Nanosecond, \"ns\"},\n+\t\t{arrow.Microsecond, \"\u00b5s\"},\n+\t\t{arrow.Millisecond, \"ms\"},\n+\t\t{arrow.Second, \"s\"},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.exp, func(t *testing.T) {\n+\t\t\tassert.Equal(t, test.exp, test.u.String())\n+\t\t})\n+\t}\n+}\ndiff --git a/go/arrow/datatype_numeric.gen.go b/go/arrow/datatype_numeric.gen.go\nnew file mode 100644\nindex 000000000..30537be74\n--- /dev/null\n+++ b/go/arrow/datatype_numeric.gen.go\n@@ -0,0 +1,96 @@\n+// Code generated by datatype_numeric.gen.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package arrow\n+\n+type Int8Type struct{}\n+\n+func (t *Int8Type) ID() Type     { return INT8 }\n+func (t *Int8Type) Name() string { return \"int8\" }\n+\n+type Int16Type struct{}\n+\n+func (t *Int16Type) ID() Type     { return INT16 }\n+func (t *Int16Type) Name() string { return \"int16\" }\n+\n+type Int32Type struct{}\n+\n+func (t *Int32Type) ID() Type     { return INT32 }\n+func (t *Int32Type) Name() string { return \"int32\" }\n+\n+type Int64Type struct{}\n+\n+func (t *Int64Type) ID() Type     { return INT64 }\n+func (t *Int64Type) Name() string { return \"int64\" }\n+\n+type Uint8Type struct{}\n+\n+func (t *Uint8Type) ID() Type     { return UINT8 }\n+func (t *Uint8Type) Name() string { return \"uint8\" }\n+\n+type Uint16Type struct{}\n+\n+func (t *Uint16Type) ID() Type     { return UINT16 }\n+func (t *Uint16Type) Name() string { return \"uint16\" }\n+\n+type Uint32Type struct{}\n+\n+func (t *Uint32Type) ID() Type     { return UINT32 }\n+func (t *Uint32Type) Name() string { return \"uint32\" }\n+\n+type Uint64Type struct{}\n+\n+func (t *Uint64Type) ID() Type     { return UINT64 }\n+func (t *Uint64Type) Name() string { return \"uint64\" }\n+\n+type Float32Type struct{}\n+\n+func (t *Float32Type) ID() Type     { return FLOAT32 }\n+func (t *Float32Type) Name() string { return \"float32\" }\n+\n+type Float64Type struct{}\n+\n+func (t *Float64Type) ID() Type     { return FLOAT64 }\n+func (t *Float64Type) Name() string { return \"float64\" }\n+\n+var (\n+\tPrimitiveTypes = struct {\n+\t\tInt8    DataType\n+\t\tInt16   DataType\n+\t\tInt32   DataType\n+\t\tInt64   DataType\n+\t\tUint8   DataType\n+\t\tUint16  DataType\n+\t\tUint32  DataType\n+\t\tUint64  DataType\n+\t\tFloat32 DataType\n+\t\tFloat64 DataType\n+\t}{\n+\n+\t\tInt8:    &Int8Type{},\n+\t\tInt16:   &Int16Type{},\n+\t\tInt32:   &Int32Type{},\n+\t\tInt64:   &Int64Type{},\n+\t\tUint8:   &Uint8Type{},\n+\t\tUint16:  &Uint16Type{},\n+\t\tUint32:  &Uint32Type{},\n+\t\tUint64:  &Uint64Type{},\n+\t\tFloat32: &Float32Type{},\n+\t\tFloat64: &Float64Type{},\n+\t}\n+)\ndiff --git a/go/arrow/datatype_numeric.gen.go.tmpl b/go/arrow/datatype_numeric.gen.go.tmpl\nnew file mode 100644\nindex 000000000..582c89525\n--- /dev/null\n+++ b/go/arrow/datatype_numeric.gen.go.tmpl\n@@ -0,0 +1,38 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package arrow\n+\n+{{range .In}}\n+type {{.Name}}Type struct {}\n+\n+func (t *{{.Name}}Type) ID() Type { return {{.Name|upper}} }\n+func (t *{{.Name}}Type) Name() string { return \"{{.Name|lower}}\" }\n+\n+\n+{{end}}\n+\n+var (\n+        PrimitiveTypes = struct {\n+{{range .In}}\n+                {{.Name}} DataType\n+{{- end}}\n+        }{\n+{{range .In}}\n+                {{.Name}}: &{{.Name}}Type{},\n+{{- end}}\n+        }\n+)\n\\ No newline at end of file\ndiff --git a/go/arrow/datatype_numeric.gen.go.tmpldata b/go/arrow/datatype_numeric.gen.go.tmpldata\nnew file mode 100644\nindex 000000000..1f40fd502\n--- /dev/null\n+++ b/go/arrow/datatype_numeric.gen.go.tmpldata\n@@ -0,0 +1,32 @@\n+[\n+  {\n+    \"Name\": \"Int8\"\n+  },\n+  {\n+    \"Name\": \"Int16\"\n+  },\n+  {\n+    \"Name\": \"Int32\"\n+  },\n+  {\n+    \"Name\": \"Int64\"\n+  },\n+  {\n+    \"Name\": \"Uint8\"\n+  },\n+  {\n+    \"Name\": \"Uint16\"\n+  },\n+  {\n+    \"Name\": \"Uint32\"\n+  },\n+  {\n+    \"Name\": \"Uint64\"\n+  },\n+  {\n+    \"Name\": \"Float32\"\n+  },\n+  {\n+    \"Name\": \"Float64\"\n+  }\n+]\n\\ No newline at end of file\ndiff --git a/go/arrow/doc.go b/go/arrow/doc.go\nnew file mode 100644\nindex 000000000..6ee0c2a43\n--- /dev/null\n+++ b/go/arrow/doc.go\n@@ -0,0 +1,38 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*\n+Package arrow provides an implementation of Apache Arrow.\n+\n+Apache Arrow is a cross-language development platform for in-memory data. It specifies a standardized\n+language-independent columnar memory format for flat and hierarchical data, organized for efficient analytic\n+operations on modern hardware. It also provides computational libraries and zero-copy streaming\n+messaging and inter-process communication.\n+\n+Basics\n+\n+The fundamental data structure in Arrow is an Array, which holds a sequence of values of the same type. An array\n+consists of memory holding the data and an additional validity bitmap that indicates if the corresponding entry in the\n+array is valid (not null). If the array has no null entries, it is possible to omit this bitmap.\n+\n+*/\n+package arrow\n+\n+//go:generate go run _tools/tmpl/main.go -i -data=numeric.tmpldata type_traits_numeric.gen.go.tmpl array/numeric.gen.go.tmpl array/numericbuilder.gen.go.tmpl array/bufferbuilder_numeric.gen.go.tmpl\n+//go:generate go run _tools/tmpl/main.go -i -data=datatype_numeric.gen.go.tmpldata datatype_numeric.gen.go.tmpl\n+\n+// stringer\n+//go:generate stringer -type=Type\ndiff --git a/go/arrow/example_test.go b/go/arrow/example_test.go\nnew file mode 100644\nindex 000000000..96fd3e55f\n--- /dev/null\n+++ b/go/arrow/example_test.go\n@@ -0,0 +1,116 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package arrow_test\n+\n+import (\n+\t\"fmt\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+)\n+\n+// This example demonstrates how to build an array of int64 values using a builder and Append.\n+// Whilst convenient for small arrays,\n+func Example_minimal() {\n+\t// Create an allocator.\n+\tpool := memory.NewGoAllocator()\n+\n+\t// Create an int64 array builder.\n+\tbuilder := array.NewInt64Builder(pool)\n+\n+\tbuilder.Append(1)\n+\tbuilder.Append(2)\n+\tbuilder.Append(3)\n+\tbuilder.AppendNull()\n+\tbuilder.Append(5)\n+\tbuilder.Append(6)\n+\tbuilder.Append(7)\n+\tbuilder.Append(8)\n+\n+\t// Finish building the int64 array and reset the builder.\n+\tints := builder.NewInt64Array()\n+\n+\t// Enumerate the values.\n+\tfor i, v := range ints.Int64Values() {\n+\t\tfmt.Printf(\"ints[%d] = \", i)\n+\t\tif ints.IsNull(i) {\n+\t\t\tfmt.Println(\"(null)\")\n+\t\t} else {\n+\t\t\tfmt.Println(v)\n+\t\t}\n+\t}\n+\n+\t// Output:\n+\t// ints[0] = 1\n+\t// ints[1] = 2\n+\t// ints[2] = 3\n+\t// ints[3] = (null)\n+\t// ints[4] = 5\n+\t// ints[5] = 6\n+\t// ints[6] = 7\n+\t// ints[7] = 8\n+}\n+\n+// This example demonstrates creating an array, sourcing the values and\n+// null bitmaps directly from byte slices. The null count is set to\n+// UnknownNullCount, instructing the array to calculate the\n+// null count from the bitmap when NullN is called.\n+func Example_fromMemory() {\n+\t// create LSB packed bits with the following pattern:\n+\t// 01010011 11000101\n+\tdata := memory.NewBufferBytes([]byte{0xca, 0xa3})\n+\n+\t// create LSB packed validity (null) bitmap, where every 4th element is null:\n+\t// 11101110 11101110\n+\tnullBitmap := memory.NewBufferBytes([]byte{0x77, 0x77})\n+\n+\t// Create a boolean array and lazily determine NullN using UnknownNullCount\n+\tbools := array.NewBoolean(16, data, nullBitmap, array.UnknownNullCount)\n+\n+\t// Show the null count\n+\tfmt.Printf(\"NullN()  = %d\\n\", bools.NullN())\n+\n+\t// Enumerate the values.\n+\tn := bools.Len()\n+\tfor i := 0; i < n; i++ {\n+\t\tfmt.Printf(\"bools[%d] = \", i)\n+\t\tif bools.IsNull(i) {\n+\t\t\tfmt.Println(\"(null)\")\n+\t\t} else {\n+\t\t\tfmt.Printf(\"%t\\n\", bools.Value(i))\n+\t\t}\n+\t}\n+\n+\t// Output:\n+\t// NullN()  = 4\n+\t// bools[0] = false\n+\t// bools[1] = true\n+\t// bools[2] = false\n+\t// bools[3] = (null)\n+\t// bools[4] = false\n+\t// bools[5] = false\n+\t// bools[6] = true\n+\t// bools[7] = (null)\n+\t// bools[8] = true\n+\t// bools[9] = true\n+\t// bools[10] = false\n+\t// bools[11] = (null)\n+\t// bools[12] = false\n+\t// bools[13] = true\n+\t// bools[14] = false\n+\t// bools[15] = (null)\n+}\ndiff --git a/go/arrow/internal/bitutil/bitutil.go b/go/arrow/internal/bitutil/bitutil.go\nnew file mode 100644\nindex 000000000..00f169336\n--- /dev/null\n+++ b/go/arrow/internal/bitutil/bitutil.go\n@@ -0,0 +1,95 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package bitutil\n+\n+import (\n+\t\"math/bits\"\n+\t\"reflect\"\n+\t\"unsafe\"\n+)\n+\n+var (\n+\tBitMask        = [8]byte{1, 2, 4, 8, 16, 32, 64, 128}\n+\tFlippedBitMask = [8]byte{254, 253, 251, 247, 239, 223, 191, 127}\n+)\n+\n+// NextPowerOf2 rounds x to the next power of two.\n+func NextPowerOf2(x int) int { return 1 << uint(bits.Len(uint(x))) }\n+\n+// CeilByte rounds size to the next multiple of 8.\n+func CeilByte(size int) int { return (size + 7) &^ 7 }\n+\n+// BitIsSet returns true if the bit at index i in buf is set (1).\n+func BitIsSet(buf []byte, i int) bool { return (buf[uint(i)/8] & BitMask[byte(i)%8]) != 0 }\n+\n+// BitIsNotSet returns true if the bit at index i in buf is not set (0).\n+func BitIsNotSet(buf []byte, i int) bool { return (buf[uint(i)/8] & BitMask[byte(i)%8]) == 0 }\n+\n+// SetBit sets the bit at index i in buf to 1.\n+func SetBit(buf []byte, i int) { buf[uint(i)/8] |= BitMask[byte(i)%8] }\n+\n+// ClearBit sets the bit at index i in buf to 0.\n+func ClearBit(buf []byte, i int) { buf[uint(i)/8] &= FlippedBitMask[byte(i)%8] }\n+\n+// SetBitTo sets the bit at index i in buf to val.\n+func SetBitTo(buf []byte, i int, val bool) {\n+\tif val {\n+\t\tSetBit(buf, i)\n+\t} else {\n+\t\tClearBit(buf, i)\n+\t}\n+}\n+\n+// CountSetBits counts the number of 1's in buf up to n bits.\n+func CountSetBits(buf []byte, n int) int {\n+\tcount := 0\n+\n+\tuint64Bytes := n / uint64SizeBits * 8\n+\tfor _, v := range bytesToUint64(buf[:uint64Bytes]) {\n+\t\tcount += bits.OnesCount64(v)\n+\t}\n+\n+\tfor _, v := range buf[uint64Bytes : n/8] {\n+\t\tcount += bits.OnesCount8(v)\n+\t}\n+\n+\t// tail bits\n+\tfor i := n &^ 0x7; i < n; i++ {\n+\t\tif BitIsSet(buf, i) {\n+\t\t\tcount++\n+\t\t}\n+\t}\n+\n+\treturn count\n+}\n+\n+const (\n+\tuint64SizeBytes = int(unsafe.Sizeof(uint64(0)))\n+\tuint64SizeBits  = uint64SizeBytes * 8\n+)\n+\n+func bytesToUint64(b []byte) []uint64 {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []uint64\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len / uint64SizeBytes\n+\ts.Cap = h.Cap / uint64SizeBytes\n+\n+\treturn res\n+}\ndiff --git a/go/arrow/internal/bitutil/bitutil_test.go b/go/arrow/internal/bitutil/bitutil_test.go\nnew file mode 100644\nindex 000000000..b1890ec4f\n--- /dev/null\n+++ b/go/arrow/internal/bitutil/bitutil_test.go\n@@ -0,0 +1,190 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package bitutil_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow/internal/bitutil\"\n+\t\"github.com/apache/arrow/go/arrow/internal/testing/tools\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestCeilByte(t *testing.T) {\n+\ttests := []struct {\n+\t\tname    string\n+\t\tin, exp int\n+\t}{\n+\t\t{\"zero\", 0, 0},\n+\t\t{\"five\", 5, 8},\n+\t\t{\"sixteen\", 16, 16},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tgot := bitutil.CeilByte(test.in)\n+\t\t\tassert.Equal(t, test.exp, got)\n+\t\t})\n+\t}\n+}\n+\n+func TestBitIsSet(t *testing.T) {\n+\tbuf := make([]byte, 2)\n+\tbuf[0] = 0xa1\n+\tbuf[1] = 0xc2\n+\texp := []bool{true, false, false, false, false, true, false, true, false, true, false, false, false, false, true, true}\n+\tvar got []bool\n+\tfor i := 0; i < 0x10; i++ {\n+\t\tgot = append(got, bitutil.BitIsSet(buf, i))\n+\t}\n+\tassert.Equal(t, exp, got)\n+}\n+\n+func TestBitIsNotSet(t *testing.T) {\n+\tbuf := make([]byte, 2)\n+\tbuf[0] = 0xa1\n+\tbuf[1] = 0xc2\n+\texp := []bool{false, true, true, true, true, false, true, false, true, false, true, true, true, true, false, false}\n+\tvar got []bool\n+\tfor i := 0; i < 0x10; i++ {\n+\t\tgot = append(got, bitutil.BitIsNotSet(buf, i))\n+\t}\n+\tassert.Equal(t, exp, got)\n+}\n+\n+func TestClearBit(t *testing.T) {\n+\tbuf := make([]byte, 2)\n+\tbuf[0] = 0xff\n+\tbuf[1] = 0xff\n+\tfor i, v := range []bool{false, true, true, true, true, false, true, false, true, false, true, true, true, true, false, false} {\n+\t\tif v {\n+\t\t\tbitutil.ClearBit(buf, i)\n+\t\t}\n+\t}\n+\tassert.Equal(t, []byte{0xa1, 0xc2}, buf)\n+}\n+\n+func TestSetBit(t *testing.T) {\n+\tbuf := make([]byte, 2)\n+\tfor i, v := range []bool{true, false, false, false, false, true, false, true, false, true, false, false, false, false, true, true} {\n+\t\tif v {\n+\t\t\tbitutil.SetBit(buf, i)\n+\t\t}\n+\t}\n+\tassert.Equal(t, []byte{0xa1, 0xc2}, buf)\n+}\n+\n+func TestSetBitTo(t *testing.T) {\n+\tbuf := make([]byte, 2)\n+\tfor i, v := range []bool{true, false, false, false, false, true, false, true, false, true, false, false, false, false, true, true} {\n+\t\tbitutil.SetBitTo(buf, i, v)\n+\t}\n+\tassert.Equal(t, []byte{0xa1, 0xc2}, buf)\n+}\n+\n+func TestCountSetBits(t *testing.T) {\n+\ttests := []struct {\n+\t\tname string\n+\t\tbuf  []byte\n+\t\tn    int\n+\t\texp  int\n+\t}{\n+\t\t{\"some 03 bits\", bbits(0x11000000), 3, 2},\n+\t\t{\"some 11 bits\", bbits(0x11000011, 0x01000000), 11, 5},\n+\t\t{\"some 72 bits\", bbits(0x11001010, 0x11110000, 0x00001111, 0x11000011, 0x11001010, 0x11110000, 0x00001111, 0x11000011, 0x10001001), 9 * 8, 35},\n+\t\t{\"all  03 bits\", bbits(0x11100001), 3, 3},\n+\t\t{\"all  11 bits\", bbits(0x11111111, 0x11111111), 11, 11},\n+\t\t{\"all  72 bits\", bbits(0x11111111, 0x11111111, 0x11111111, 0x11111111, 0x11111111, 0x11111111, 0x11111111, 0x11111111, 0x11111111), 9 * 8, 72},\n+\t\t{\"none 03 bits\", bbits(0x00000001), 3, 0},\n+\t\t{\"none 11 bits\", bbits(0x00000000, 0x00000000), 11, 0},\n+\t\t{\"none 72 bits\", bbits(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000), 9 * 8, 0},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tgot := bitutil.CountSetBits(test.buf, test.n)\n+\t\t\tassert.Equal(t, test.exp, got)\n+\t\t})\n+\t}\n+}\n+\n+func bbits(v ...int32) []byte {\n+\treturn tools.IntsToBitsLSB(v...)\n+}\n+\n+func BenchmarkBitIsSet(b *testing.B) {\n+\tbuf := make([]byte, 32)\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbitutil.BitIsSet(buf, (i%32)&0x1a)\n+\t}\n+}\n+\n+func BenchmarkSetBit(b *testing.B) {\n+\tbuf := make([]byte, 32)\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbitutil.SetBit(buf, (i%32)&0x1a)\n+\t}\n+}\n+\n+func BenchmarkSetBitTo(b *testing.B) {\n+\tvals := []bool{true, false, false, false, false, true, false, true, false, true, false, false, false, false, true, true}\n+\tbuf := make([]byte, 32)\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbitutil.SetBitTo(buf, i%32, vals[i%len(vals)])\n+\t}\n+}\n+\n+var (\n+\tintval int\n+)\n+\n+func benchmarkCountSetBitsN(b *testing.B, n int) {\n+\tnn := n/8 + 1\n+\tbuf := make([]byte, nn)\n+\t//src := [4]byte{0x1f, 0xaa, 0xba, 0x11}\n+\tsrc := [4]byte{0x01, 0x01, 0x01, 0x01}\n+\tfor i := 0; i < nn; i++ {\n+\t\tbuf[i] = src[i&0x3]\n+\t}\n+\tb.ResetTimer()\n+\tvar res int\n+\tfor i := 0; i < b.N; i++ {\n+\t\tres = bitutil.CountSetBits(buf, n)\n+\t}\n+\tintval = res\n+}\n+\n+func BenchmarkCountSetBits_3(b *testing.B) {\n+\tbenchmarkCountSetBitsN(b, 3)\n+}\n+\n+func BenchmarkCountSetBits_32(b *testing.B) {\n+\tbenchmarkCountSetBitsN(b, 32)\n+}\n+\n+func BenchmarkCountSetBits_128(b *testing.B) {\n+\tbenchmarkCountSetBitsN(b, 128)\n+}\n+\n+func BenchmarkCountSetBits_1000(b *testing.B) {\n+\tbenchmarkCountSetBitsN(b, 1000)\n+}\n+\n+func BenchmarkCountSetBits_1024(b *testing.B) {\n+\tbenchmarkCountSetBitsN(b, 1024)\n+}\ndiff --git a/go/arrow/internal/cpu/README.md b/go/arrow/internal/cpu/README.md\nnew file mode 100644\nindex 000000000..2619b38c1\n--- /dev/null\n+++ b/go/arrow/internal/cpu/README.md\n@@ -0,0 +1,42 @@\n+<!---\n+  Licensed to the Apache Software Foundation (ASF) under one\n+  or more contributor license agreements.  See the NOTICE file\n+  distributed with this work for additional information\n+  regarding copyright ownership.  The ASF licenses this file\n+  to you under the Apache License, Version 2.0 (the\n+  \"License\"); you may not use this file except in compliance\n+  with the License.  You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing,\n+  software distributed under the License is distributed on an\n+  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  KIND, either express or implied.  See the License for the\n+  specific language governing permissions and limitations\n+  under the License.\n+-->\n+\n+# Package cpu\n+\n+Copied from Go src/internal/cpu\n+\n+## Extras\n+\n+### Intel\n+\n+The `INTEL_DISABLE_EXT` environment variable can control which CPU extensions are available for\n+the running process. It should be a comma-separate list of upper-case strings as follows\n+\n+|   Flag   | Description |\n+| -------- | ----------- |\n+| `ALL`    | Disable all CPU extensions and fall back to Go implementation |\n+| `AVX2`   | Disable AVX2 optimizations |  \n+| `AVX`    | Disable AVX optimizations |  \n+| `SSE`    | Disable all SSE optimizations |  \n+| `SSE4`   | Disable SSE42, SSE41 optimizations |  \n+| `SSSE3`  | Disable supplemental SSE3 optimizations |  \n+| `SSE3`   | Disable SSE3 optimizations |  \n+| `SSE2`   | Disable SSE2 optimizations |\n+\n+Any unrecognized flags will be ignored and therefore it is possible to leave the environment variable with a bogus value such as `NONE` when experimenting.\n\\ No newline at end of file\ndiff --git a/go/arrow/internal/cpu/cpu.go b/go/arrow/internal/cpu/cpu.go\nnew file mode 100644\nindex 000000000..22fc56100\n--- /dev/null\n+++ b/go/arrow/internal/cpu/cpu.go\n@@ -0,0 +1,77 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package cpu implements processor feature detection\n+// used by the Go standard library.\n+package cpu\n+\n+var X86 x86\n+\n+// The booleans in x86 contain the correspondingly named cpuid feature bit.\n+// HasAVX and HasAVX2 are only set if the OS does support XMM and YMM registers\n+// in addition to the cpuid feature bit being set.\n+// The struct is padded to avoid false sharing.\n+type x86 struct {\n+\t_            [CacheLineSize]byte\n+\tHasAES       bool\n+\tHasADX       bool\n+\tHasAVX       bool\n+\tHasAVX2      bool\n+\tHasBMI1      bool\n+\tHasBMI2      bool\n+\tHasERMS      bool\n+\tHasFMA       bool\n+\tHasOSXSAVE   bool\n+\tHasPCLMULQDQ bool\n+\tHasPOPCNT    bool\n+\tHasSSE2      bool\n+\tHasSSE3      bool\n+\tHasSSSE3     bool\n+\tHasSSE41     bool\n+\tHasSSE42     bool\n+\t_            [CacheLineSize]byte\n+}\n+\n+var PPC64 ppc64\n+\n+// For ppc64x, it is safe to check only for ISA level starting on ISA v3.00,\n+// since there are no optional categories. There are some exceptions that also\n+// require kernel support to work (darn, scv), so there are capability bits for\n+// those as well. The minimum processor requirement is POWER8 (ISA 2.07), so we\n+// maintain some of the old capability checks for optional categories for\n+// safety.\n+// The struct is padded to avoid false sharing.\n+type ppc64 struct {\n+\t_          [CacheLineSize]byte\n+\tHasVMX     bool // Vector unit (Altivec)\n+\tHasDFP     bool // Decimal Floating Point unit\n+\tHasVSX     bool // Vector-scalar unit\n+\tHasHTM     bool // Hardware Transactional Memory\n+\tHasISEL    bool // Integer select\n+\tHasVCRYPTO bool // Vector cryptography\n+\tHasHTMNOSC bool // HTM: kernel-aborted transaction in syscalls\n+\tHasDARN    bool // Hardware random number generator (requires kernel enablement)\n+\tHasSCV     bool // Syscall vectored (requires kernel enablement)\n+\tIsPOWER8   bool // ISA v2.07 (POWER8)\n+\tIsPOWER9   bool // ISA v3.00 (POWER9)\n+\t_          [CacheLineSize]byte\n+}\n+\n+var ARM64 arm64\n+\n+// The booleans in arm64 contain the correspondingly named cpu feature bit.\n+// The struct is padded to avoid false sharing.\n+type arm64 struct {\n+\t_          [CacheLineSize]byte\n+\tHasFP      bool\n+\tHasASIMD   bool\n+\tHasEVTSTRM bool\n+\tHasAES     bool\n+\tHasPMULL   bool\n+\tHasSHA1    bool\n+\tHasSHA2    bool\n+\tHasCRC32   bool\n+\tHasATOMICS bool\n+\t_          [CacheLineSize]byte\n+}\ndiff --git a/go/arrow/internal/cpu/cpu_test.go b/go/arrow/internal/cpu/cpu_test.go\nnew file mode 100644\nindex 000000000..02f09d3d5\n--- /dev/null\n+++ b/go/arrow/internal/cpu/cpu_test.go\n@@ -0,0 +1,51 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package cpu_test\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow/internal/cpu\"\n+)\n+\n+func TestAMD64minimalFeatures(t *testing.T) {\n+\tif runtime.GOARCH == \"amd64\" {\n+\t\tif !cpu.X86.HasSSE2 {\n+\t\t\tt.Fatalf(\"HasSSE2 expected true, got false\")\n+\t\t}\n+\t}\n+}\n+\n+func TestAVX2hasAVX(t *testing.T) {\n+\tif runtime.GOARCH == \"amd64\" {\n+\t\tif cpu.X86.HasAVX2 && !cpu.X86.HasAVX {\n+\t\t\tt.Fatalf(\"HasAVX expected true, got false\")\n+\t\t}\n+\t}\n+}\n+\n+func TestPPC64minimalFeatures(t *testing.T) {\n+\tif runtime.GOARCH == \"ppc64\" || runtime.GOARCH == \"ppc64le\" {\n+\t\tif !cpu.PPC64.IsPOWER8 {\n+\t\t\tt.Fatalf(\"IsPOWER8 expected true, got false\")\n+\t\t}\n+\t\tif !cpu.PPC64.HasVMX {\n+\t\t\tt.Fatalf(\"HasVMX expected true, got false\")\n+\t\t}\n+\t\tif !cpu.PPC64.HasDFP {\n+\t\t\tt.Fatalf(\"HasDFP expected true, got false\")\n+\t\t}\n+\t\tif !cpu.PPC64.HasVSX {\n+\t\t\tt.Fatalf(\"HasVSX expected true, got false\")\n+\t\t}\n+\t\tif !cpu.PPC64.HasISEL {\n+\t\t\tt.Fatalf(\"HasISEL expected true, got false\")\n+\t\t}\n+\t\tif !cpu.PPC64.HasVCRYPTO {\n+\t\t\tt.Fatalf(\"HasVCRYPTO expected true, got false\")\n+\t\t}\n+\t}\n+}\ndiff --git a/go/arrow/internal/cpu/cpu_x86.go b/go/arrow/internal/cpu/cpu_x86.go\nnew file mode 100644\nindex 000000000..777269f1a\n--- /dev/null\n+++ b/go/arrow/internal/cpu/cpu_x86.go\n@@ -0,0 +1,107 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build 386 amd64 amd64p32\n+\n+package cpu\n+\n+import (\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+const CacheLineSize = 64\n+\n+// cpuid is implemented in cpu_x86.s.\n+func cpuid(eaxArg, ecxArg uint32) (eax, ebx, ecx, edx uint32)\n+\n+// xgetbv with ecx = 0 is implemented in cpu_x86.s.\n+func xgetbv() (eax, edx uint32)\n+\n+func init() {\n+\tmaxID, _, _, _ := cpuid(0, 0)\n+\n+\tif maxID < 1 {\n+\t\treturn\n+\t}\n+\n+\t_, _, ecx1, edx1 := cpuid(1, 0)\n+\tX86.HasSSE2 = isSet(26, edx1)\n+\n+\tX86.HasSSE3 = isSet(0, ecx1)\n+\tX86.HasPCLMULQDQ = isSet(1, ecx1)\n+\tX86.HasSSSE3 = isSet(9, ecx1)\n+\tX86.HasFMA = isSet(12, ecx1)\n+\tX86.HasSSE41 = isSet(19, ecx1)\n+\tX86.HasSSE42 = isSet(20, ecx1)\n+\tX86.HasPOPCNT = isSet(23, ecx1)\n+\tX86.HasAES = isSet(25, ecx1)\n+\tX86.HasOSXSAVE = isSet(27, ecx1)\n+\n+\tosSupportsAVX := false\n+\t// For XGETBV, OSXSAVE bit is required and sufficient.\n+\tif X86.HasOSXSAVE {\n+\t\teax, _ := xgetbv()\n+\t\t// Check if XMM and YMM registers have OS support.\n+\t\tosSupportsAVX = isSet(1, eax) && isSet(2, eax)\n+\t}\n+\n+\tX86.HasAVX = isSet(28, ecx1) && osSupportsAVX\n+\n+\tif maxID < 7 {\n+\t\treturn\n+\t}\n+\n+\t_, ebx7, _, _ := cpuid(7, 0)\n+\tX86.HasBMI1 = isSet(3, ebx7)\n+\tX86.HasAVX2 = isSet(5, ebx7) && osSupportsAVX\n+\tX86.HasBMI2 = isSet(8, ebx7)\n+\tX86.HasERMS = isSet(9, ebx7)\n+\tX86.HasADX = isSet(19, ebx7)\n+\n+\t// NOTE(sgc): added ability to disable extension via environment\n+\tcheckEnvironment()\n+}\n+func checkEnvironment() {\n+\tif ext, ok := os.LookupEnv(\"INTEL_DISABLE_EXT\"); ok {\n+\t\texts := strings.Split(ext, \",\")\n+\n+\t\tfor _, x := range exts {\n+\t\t\tswitch x {\n+\t\t\tcase \"ALL\":\n+\t\t\t\tX86.HasAVX2 = false\n+\t\t\t\tX86.HasAVX = false\n+\t\t\t\tX86.HasSSE42 = false\n+\t\t\t\tX86.HasSSE41 = false\n+\t\t\t\tX86.HasSSSE3 = false\n+\t\t\t\tX86.HasSSE3 = false\n+\t\t\t\tX86.HasSSE2 = false\n+\n+\t\t\tcase \"AVX2\":\n+\t\t\t\tX86.HasAVX2 = false\n+\t\t\tcase \"AVX\":\n+\t\t\t\tX86.HasAVX = false\n+\t\t\tcase \"SSE\":\n+\t\t\t\tX86.HasSSE42 = false\n+\t\t\t\tX86.HasSSE41 = false\n+\t\t\t\tX86.HasSSSE3 = false\n+\t\t\t\tX86.HasSSE3 = false\n+\t\t\t\tX86.HasSSE2 = false\n+\t\t\tcase \"SSE4\":\n+\t\t\t\tX86.HasSSE42 = false\n+\t\t\t\tX86.HasSSE41 = false\n+\t\t\tcase \"SSSE3\":\n+\t\t\t\tX86.HasSSSE3 = false\n+\t\t\tcase \"SSE3\":\n+\t\t\t\tX86.HasSSE3 = false\n+\t\t\tcase \"SSE2\":\n+\t\t\t\tX86.HasSSE2 = false\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func isSet(bitpos uint, value uint32) bool {\n+\treturn value&(1<<bitpos) != 0\n+}\ndiff --git a/go/arrow/internal/cpu/cpu_x86.s b/go/arrow/internal/cpu/cpu_x86.s\nnew file mode 100644\nindex 000000000..228fbcf6d\n--- /dev/null\n+++ b/go/arrow/internal/cpu/cpu_x86.s\n@@ -0,0 +1,32 @@\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build 386 amd64 amd64p32\n+\n+#include \"textflag.h\"\n+\n+// func cpuid(eaxArg, ecxArg uint32) (eax, ebx, ecx, edx uint32)\n+TEXT \u00b7cpuid(SB), NOSPLIT, $0-24\n+\tMOVL eaxArg+0(FP), AX\n+\tMOVL ecxArg+4(FP), CX\n+\tCPUID\n+\tMOVL AX, eax+8(FP)\n+\tMOVL BX, ebx+12(FP)\n+\tMOVL CX, ecx+16(FP)\n+\tMOVL DX, edx+20(FP)\n+\tRET\n+\n+// func xgetbv() (eax, edx uint32)\n+TEXT \u00b7xgetbv(SB),NOSPLIT,$0-8\n+#ifdef GOOS_nacl\n+\t// nacl does not support XGETBV.\n+\tMOVL $0, eax+0(FP)\n+\tMOVL $0, edx+4(FP)\n+#else\n+\tMOVL $0, CX\n+\tXGETBV\n+\tMOVL AX, eax+0(FP)\n+\tMOVL DX, edx+4(FP)\n+#endif\n+\tRET\ndiff --git a/go/arrow/internal/debug/assert_off.go b/go/arrow/internal/debug/assert_off.go\nnew file mode 100644\nindex 000000000..52b9a2331\n--- /dev/null\n+++ b/go/arrow/internal/debug/assert_off.go\n@@ -0,0 +1,24 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !assert\n+\n+package debug\n+\n+// Assert will panic with msg if cond is false.\n+//\n+// msg must be a string, func() string or fmt.Stringer.\n+func Assert(cond bool, msg interface{}) {}\ndiff --git a/go/arrow/internal/debug/assert_on.go b/go/arrow/internal/debug/assert_on.go\nnew file mode 100644\nindex 000000000..2aa5d6ace\n--- /dev/null\n+++ b/go/arrow/internal/debug/assert_on.go\n@@ -0,0 +1,28 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build assert\n+\n+package debug\n+\n+// Assert will panic with msg if cond is false.\n+//\n+// msg must be a string, func() string or fmt.Stringer.\n+func Assert(cond bool, msg interface{}) {\n+\tif !cond {\n+\t\tpanic(getStringValue(msg))\n+\t}\n+}\ndiff --git a/go/arrow/internal/debug/doc.go b/go/arrow/internal/debug/doc.go\nnew file mode 100644\nindex 000000000..3ee1783ca\n--- /dev/null\n+++ b/go/arrow/internal/debug/doc.go\n@@ -0,0 +1,32 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*\n+Package debug provides APIs for conditional runtime assertions and debug logging.\n+\n+\n+Using Assert\n+\n+To enable runtime assertions, build with the assert tag. When the assert tag is omitted,\n+the code for the assertion will be omitted from the binary.\n+\n+\n+Using Log\n+\n+To enable runtime debug logs, build with the debug tag. When the debug tag is omitted,\n+the code for logging will be omitted from the binary.\n+*/\n+package debug\ndiff --git a/go/arrow/internal/debug/log_off.go b/go/arrow/internal/debug/log_off.go\nnew file mode 100644\nindex 000000000..48da8e1ee\n--- /dev/null\n+++ b/go/arrow/internal/debug/log_off.go\n@@ -0,0 +1,21 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !debug\n+\n+package debug\n+\n+func Log(interface{}) {}\ndiff --git a/go/arrow/internal/debug/log_on.go b/go/arrow/internal/debug/log_on.go\nnew file mode 100644\nindex 000000000..99d0c8ae3\n--- /dev/null\n+++ b/go/arrow/internal/debug/log_on.go\n@@ -0,0 +1,32 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build debug\n+\n+package debug\n+\n+import (\n+\t\"log\"\n+\t\"os\"\n+)\n+\n+var (\n+\tdebug = log.New(os.Stderr, \"[D] \", log.LstdFlags)\n+)\n+\n+func Log(msg interface{}) {\n+\tdebug.Output(1, getStringValue(msg))\n+}\ndiff --git a/go/arrow/internal/debug/util.go b/go/arrow/internal/debug/util.go\nnew file mode 100644\nindex 000000000..7bd3d5389\n--- /dev/null\n+++ b/go/arrow/internal/debug/util.go\n@@ -0,0 +1,37 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build debug assert\n+\n+package debug\n+\n+import \"fmt\"\n+\n+func getStringValue(v interface{}) string {\n+\tswitch a := v.(type) {\n+\tcase func() string:\n+\t\treturn a()\n+\n+\tcase string:\n+\t\treturn a\n+\n+\tcase fmt.Stringer:\n+\t\treturn a.String()\n+\n+\tdefault:\n+\t\tpanic(fmt.Sprintf(\"unexpected type, %t\", v))\n+\t}\n+}\ndiff --git a/go/arrow/internal/testing/tools/bits.go b/go/arrow/internal/testing/tools/bits.go\nnew file mode 100644\nindex 000000000..c123573e2\n--- /dev/null\n+++ b/go/arrow/internal/testing/tools/bits.go\n@@ -0,0 +1,40 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package tools\n+\n+import \"math/bits\"\n+\n+// IntsToBitsLSB encodes ints as LSB 0 bit numbering per https://en.wikipedia.org/wiki/Bit_numbering#LSB_0_bit_numbering\n+// The low bit of each nibble is tested, therefore integers should be written as 8-digit\n+// hex numbers consisting of 1s or 0s.\n+//\n+//     IntsToBitsLSB(0x11001010) -> 0x35\n+func IntsToBitsLSB(v ...int32) []byte {\n+\tres := make([]byte, 0, len(v))\n+\tfor _, b := range v {\n+\t\tc := uint8(0)\n+\t\tfor i := uint(0); i < 8; i++ {\n+\t\t\tif b&1 == 1 {\n+\t\t\t\tc |= 1 << i\n+\t\t\t}\n+\t\t\tb >>= 4\n+\t\t}\n+\t\tc = bits.Reverse8(c)\n+\t\tres = append(res, c)\n+\t}\n+\treturn res\n+}\ndiff --git a/go/arrow/internal/testing/tools/bits_test.go b/go/arrow/internal/testing/tools/bits_test.go\nnew file mode 100644\nindex 000000000..ba790eabc\n--- /dev/null\n+++ b/go/arrow/internal/testing/tools/bits_test.go\n@@ -0,0 +1,42 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package tools_test\n+\n+import (\n+\t\"fmt\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow/internal/testing/tools\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestIntsToBitsLSB(t *testing.T) {\n+\ttests := []struct {\n+\t\tin  int32\n+\t\texp byte\n+\t}{\n+\t\t{0x11001010, 0x53},\n+\t\t{0x00001111, 0xf0},\n+\t\t{0x11110000, 0x0f},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(fmt.Sprintf(\"%08x\", test.in), func(t *testing.T) {\n+\t\t\tgot := tools.IntsToBitsLSB(test.in)\n+\t\t\tassert.Equal(t, []byte{test.exp}, got)\n+\t\t})\n+\t}\n+}\ndiff --git a/go/arrow/internal/testing/tools/bool.go b/go/arrow/internal/testing/tools/bool.go\nnew file mode 100644\nindex 000000000..757a8f528\n--- /dev/null\n+++ b/go/arrow/internal/testing/tools/bool.go\n@@ -0,0 +1,25 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package tools\n+\n+func Bools(v ...int) []bool {\n+\tres := make([]bool, len(v))\n+\tfor i, b := range v {\n+\t\tres[i] = b != 0\n+\t}\n+\treturn res\n+}\ndiff --git a/go/arrow/math/Makefile b/go/arrow/math/Makefile\nnew file mode 100644\nindex 000000000..89f5d2fa5\n--- /dev/null\n+++ b/go/arrow/math/Makefile\n@@ -0,0 +1,90 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+GO_BUILD=go build\n+GO_GEN=go generate\n+GO_TEST=go test\n+GOPATH=$(realpath ../../../../../..)\n+\n+# this converts rotate instructions from \"ro[lr] <reg>\" -> \"ro[lr] <reg>, 1\" for yasm compatibility\n+PERL_FIXUP_ROTATE=perl -i -pe 's/(ro[rl]\\s+\\w{2,3})$$/\\1, 1/'\n+\n+C2GOASM=c2goasm -a -f\n+CC=clang\n+C_FLAGS=-target x86_64-unknown-none -masm=intel -mno-red-zone -mstackrealign -mllvm -inline-threshold=1000 -fno-asynchronous-unwind-tables \\\n+\t-fno-exceptions -fno-rtti -O3 -fno-builtin -ffast-math -fno-jump-tables -I_lib\n+ASM_FLAGS_AVX2=-mavx2 -mfma -mllvm -force-vector-width=32\n+ASM_FLAGS_SSE4=-msse4\n+\n+GO_SOURCES  := $(shell find . -path ./_lib -prune -o -name '*.go' -not -name '*_test.go')\n+ALL_SOURCES := $(shell find . -path ./_lib -prune -o -name '*.go' -name '*.s' -not -name '*_test.go')\n+\n+INTEL_SOURCES := \\\n+\tfloat64_avx2_amd64.s float64_sse4_amd64.s \\\n+\tint64_avx2_amd64.s int64_sse4_amd64.s \\\n+\tuint64_avx2_amd64.s uint64_sse4_amd64.s\n+\n+.PHONEY: assembly\n+\n+assembly: $(INTEL_SOURCES)\n+\n+generate: ../bin/tmpl\n+\t../bin/tmpl -i -data=float64.tmpldata type.go.tmpl=float64.go type_amd64.go.tmpl=float64_amd64.go type_noasm.go.tmpl=float64_noasm.go type_test.go.tmpl=float64_test.go\n+\t../bin/tmpl -i -data=float64.tmpldata -d arch=avx2 type_simd_amd64.go.tmpl=float64_avx2_amd64.go\n+\t../bin/tmpl -i -data=float64.tmpldata -d arch=sse4 type_simd_amd64.go.tmpl=float64_sse4_amd64.go\n+\t../bin/tmpl -i -data=int64.tmpldata type.go.tmpl=int64.go type_amd64.go.tmpl=int64_amd64.go type_noasm.go.tmpl=int64_noasm.go type_test.go.tmpl=int64_test.go\n+\t../bin/tmpl -i -data=int64.tmpldata -d arch=avx2 type_simd_amd64.go.tmpl=int64_avx2_amd64.go\n+\t../bin/tmpl -i -data=int64.tmpldata -d arch=sse4 type_simd_amd64.go.tmpl=int64_sse4_amd64.go\n+\t../bin/tmpl -i -data=uint64.tmpldata type.go.tmpl=uint64.go type_amd64.go.tmpl=uint64_amd64.go type_noasm.go.tmpl=uint64_noasm.go type_test.go.tmpl=uint64_test.go\n+\t../bin/tmpl -i -data=uint64.tmpldata -d arch=avx2 type_simd_amd64.go.tmpl=uint64_avx2_amd64.go\n+\t../bin/tmpl -i -data=uint64.tmpldata -d arch=sse4 type_simd_amd64.go.tmpl=uint64_sse4_amd64.go\n+\n+_lib/float64_avx2.s: _lib/float64.c\n+\t$(CC) -S $(C_FLAGS) $(ASM_FLAGS_AVX2) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@\n+\n+_lib/float64_sse4.s: _lib/float64.c\n+\t$(CC) -S $(C_FLAGS) $(ASM_FLAGS_SSE4) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@\n+\n+float64_avx2_amd64.s: _lib/float64_avx2.s\n+\t$(C2GOASM) -a -f $^ $@\n+\n+float64_sse4_amd64.s: _lib/float64_sse4.s\n+\t$(C2GOASM) -a -f $^ $@\n+\n+_lib/int64_avx2.s: _lib/int64.c\n+\t$(CC) -S $(C_FLAGS) $(ASM_FLAGS_AVX2) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@\n+\n+_lib/int64_sse4.s: _lib/int64.c\n+\t$(CC) -S $(C_FLAGS) $(ASM_FLAGS_SSE4) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@\n+\n+int64_avx2_amd64.s: _lib/int64_avx2.s\n+\t$(C2GOASM) -a -f $^ $@\n+\n+int64_sse4_amd64.s: _lib/int64_sse4.s\n+\t$(C2GOASM) -a -f $^ $@\n+\n+_lib/uint64_avx2.s: _lib/uint64.c\n+\t$(CC) -S $(C_FLAGS) $(ASM_FLAGS_AVX2) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@\n+\n+_lib/uint64_sse4.s: _lib/uint64.c\n+\t$(CC) -S $(C_FLAGS) $(ASM_FLAGS_SSE4) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@\n+\n+uint64_avx2_amd64.s: _lib/uint64_avx2.s\n+\t$(C2GOASM) -a -f $^ $@\n+\n+uint64_sse4_amd64.s: _lib/uint64_sse4.s\n+\t$(C2GOASM) -a -f $^ $@\n+\ndiff --git a/go/arrow/math/_lib/.gitignore b/go/arrow/math/_lib/.gitignore\nnew file mode 100644\nindex 000000000..72757d396\n--- /dev/null\n+++ b/go/arrow/math/_lib/.gitignore\n@@ -0,0 +1,18 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+.idea\n+cmake-build-*\n\\ No newline at end of file\ndiff --git a/go/arrow/math/_lib/CMakeLists.txt b/go/arrow/math/_lib/CMakeLists.txt\nnew file mode 100644\nindex 000000000..ec1558b25\n--- /dev/null\n+++ b/go/arrow/math/_lib/CMakeLists.txt\n@@ -0,0 +1,24 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+cmake_minimum_required(VERSION 3.6)\n+\n+project(math-func)\n+set(CMAKE_C_STANDARD 99)\n+\n+add_library(memory STATIC float64.c int64.c uint64.c)\n+\n+\ndiff --git a/go/arrow/math/_lib/arch.h b/go/arrow/math/_lib/arch.h\nnew file mode 100644\nindex 000000000..d9c7d98bf\n--- /dev/null\n+++ b/go/arrow/math/_lib/arch.h\n@@ -0,0 +1,27 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#undef FULL_NAME\n+\n+#if  defined(__AVX2__)\n+    #define FULL_NAME(x) x##_avx2\n+#elif __SSE4_2__ == 1\n+    #define FULL_NAME(x) x##_sse4\n+#elif __SSE3__ == 1\n+    #define FULL_NAME(x) x##_sse3\n+#else\n+    #define FULL_NAME(x) x##_x86\n+#endif\n\\ No newline at end of file\ndiff --git a/go/arrow/math/_lib/float64.c b/go/arrow/math/_lib/float64.c\nnew file mode 100644\nindex 000000000..24f8c6105\n--- /dev/null\n+++ b/go/arrow/math/_lib/float64.c\n@@ -0,0 +1,26 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <arch.h>\n+#include <memory.h>\n+\n+void FULL_NAME(sum_float64)(double buf[], size_t len, double *res) {\n+    double acc = 0.0;\n+    for(int i = 0; i < len; i++) {\n+        acc += buf[i];\n+    }\n+    *res = acc;\n+}\n\\ No newline at end of file\ndiff --git a/go/arrow/math/_lib/float64_avx2.s b/go/arrow/math/_lib/float64_avx2.s\nnew file mode 100644\nindex 000000000..8d90a9493\n--- /dev/null\n+++ b/go/arrow/math/_lib/float64_avx2.s\n@@ -0,0 +1,176 @@\n+\t.text\n+\t.intel_syntax noprefix\n+\t.file\t\"_lib/float64.c\"\n+\t.globl\tsum_float64_avx2\n+\t.p2align\t4, 0x90\n+\t.type\tsum_float64_avx2,@function\n+sum_float64_avx2:                       # @sum_float64_avx2\n+# BB#0:\n+\tpush\trbp\n+\tmov\trbp, rsp\n+\tand\trsp, -8\n+\tvxorpd\txmm0, xmm0, xmm0\n+\ttest\trsi, rsi\n+\tje\t.LBB0_14\n+# BB#1:\n+\tcmp\trsi, 31\n+\tjbe\t.LBB0_2\n+# BB#5:\n+\tmov\tr9, rsi\n+\tand\tr9, -32\n+\tje\t.LBB0_2\n+# BB#6:\n+\tlea\tr8, [r9 - 32]\n+\tmov\teax, r8d\n+\tshr\teax, 5\n+\tinc\teax\n+\tand\trax, 7\n+\tje\t.LBB0_7\n+# BB#8:\n+\tneg\trax\n+\tvxorpd\tymm0, ymm0, ymm0\n+\txor\tecx, ecx\n+\tvxorpd\tymm1, ymm1, ymm1\n+\tvxorpd\tymm2, ymm2, ymm2\n+\tvxorpd\tymm3, ymm3, ymm3\n+\tvxorpd\tymm4, ymm4, ymm4\n+\tvxorpd\tymm5, ymm5, ymm5\n+\tvxorpd\tymm6, ymm6, ymm6\n+\tvxorpd\tymm7, ymm7, ymm7\n+\t.p2align\t4, 0x90\n+.LBB0_9:                                # =>This Inner Loop Header: Depth=1\n+\tvaddpd\tymm0, ymm0, ymmword ptr [rdi + 8*rcx]\n+\tvaddpd\tymm1, ymm1, ymmword ptr [rdi + 8*rcx + 32]\n+\tvaddpd\tymm2, ymm2, ymmword ptr [rdi + 8*rcx + 64]\n+\tvaddpd\tymm3, ymm3, ymmword ptr [rdi + 8*rcx + 96]\n+\tvaddpd\tymm4, ymm4, ymmword ptr [rdi + 8*rcx + 128]\n+\tvaddpd\tymm5, ymm5, ymmword ptr [rdi + 8*rcx + 160]\n+\tvaddpd\tymm6, ymm6, ymmword ptr [rdi + 8*rcx + 192]\n+\tvaddpd\tymm7, ymm7, ymmword ptr [rdi + 8*rcx + 224]\n+\tadd\trcx, 32\n+\tinc\trax\n+\tjne\t.LBB0_9\n+\tjmp\t.LBB0_10\n+.LBB0_2:\n+\txor\tr9d, r9d\n+.LBB0_3:\n+\tlea\trax, [rdi + 8*r9]\n+\tsub\trsi, r9\n+\t.p2align\t4, 0x90\n+.LBB0_4:                                # =>This Inner Loop Header: Depth=1\n+\tvaddsd\txmm0, xmm0, qword ptr [rax]\n+\tadd\trax, 8\n+\tdec\trsi\n+\tjne\t.LBB0_4\n+.LBB0_14:\n+\tvmovsd\tqword ptr [rdx], xmm0\n+\tmov\trsp, rbp\n+\tpop\trbp\n+\tvzeroupper\n+\tret\n+.LBB0_7:\n+\txor\tecx, ecx\n+\tvxorpd\tymm0, ymm0, ymm0\n+\tvxorpd\tymm1, ymm1, ymm1\n+\tvxorpd\tymm2, ymm2, ymm2\n+\tvxorpd\tymm3, ymm3, ymm3\n+\tvxorpd\tymm4, ymm4, ymm4\n+\tvxorpd\tymm5, ymm5, ymm5\n+\tvxorpd\tymm6, ymm6, ymm6\n+\tvxorpd\tymm7, ymm7, ymm7\n+.LBB0_10:\n+\tcmp\tr8, 224\n+\tjb\t.LBB0_13\n+# BB#11:\n+\tmov\trax, r9\n+\tsub\trax, rcx\n+\tlea\trcx, [rdi + 8*rcx + 1792]\n+\t.p2align\t4, 0x90\n+.LBB0_12:                               # =>This Inner Loop Header: Depth=1\n+\tvaddpd\tymm7, ymm7, ymmword ptr [rcx - 1568]\n+\tvaddpd\tymm6, ymm6, ymmword ptr [rcx - 1600]\n+\tvaddpd\tymm5, ymm5, ymmword ptr [rcx - 1632]\n+\tvaddpd\tymm4, ymm4, ymmword ptr [rcx - 1664]\n+\tvaddpd\tymm3, ymm3, ymmword ptr [rcx - 1696]\n+\tvaddpd\tymm2, ymm2, ymmword ptr [rcx - 1728]\n+\tvaddpd\tymm1, ymm1, ymmword ptr [rcx - 1760]\n+\tvaddpd\tymm0, ymm0, ymmword ptr [rcx - 1792]\n+\tvaddpd\tymm0, ymm0, ymmword ptr [rcx - 1536]\n+\tvaddpd\tymm1, ymm1, ymmword ptr [rcx - 1504]\n+\tvaddpd\tymm2, ymm2, ymmword ptr [rcx - 1472]\n+\tvaddpd\tymm3, ymm3, ymmword ptr [rcx - 1440]\n+\tvaddpd\tymm4, ymm4, ymmword ptr [rcx - 1408]\n+\tvaddpd\tymm5, ymm5, ymmword ptr [rcx - 1376]\n+\tvaddpd\tymm6, ymm6, ymmword ptr [rcx - 1344]\n+\tvaddpd\tymm7, ymm7, ymmword ptr [rcx - 1312]\n+\tvaddpd\tymm7, ymm7, ymmword ptr [rcx - 1056]\n+\tvaddpd\tymm6, ymm6, ymmword ptr [rcx - 1088]\n+\tvaddpd\tymm5, ymm5, ymmword ptr [rcx - 1120]\n+\tvaddpd\tymm4, ymm4, ymmword ptr [rcx - 1152]\n+\tvaddpd\tymm3, ymm3, ymmword ptr [rcx - 1184]\n+\tvaddpd\tymm2, ymm2, ymmword ptr [rcx - 1216]\n+\tvaddpd\tymm1, ymm1, ymmword ptr [rcx - 1248]\n+\tvaddpd\tymm0, ymm0, ymmword ptr [rcx - 1280]\n+\tvaddpd\tymm0, ymm0, ymmword ptr [rcx - 1024]\n+\tvaddpd\tymm1, ymm1, ymmword ptr [rcx - 992]\n+\tvaddpd\tymm2, ymm2, ymmword ptr [rcx - 960]\n+\tvaddpd\tymm3, ymm3, ymmword ptr [rcx - 928]\n+\tvaddpd\tymm4, ymm4, ymmword ptr [rcx - 896]\n+\tvaddpd\tymm5, ymm5, ymmword ptr [rcx - 864]\n+\tvaddpd\tymm6, ymm6, ymmword ptr [rcx - 832]\n+\tvaddpd\tymm7, ymm7, ymmword ptr [rcx - 800]\n+\tvaddpd\tymm7, ymm7, ymmword ptr [rcx - 544]\n+\tvaddpd\tymm6, ymm6, ymmword ptr [rcx - 576]\n+\tvaddpd\tymm5, ymm5, ymmword ptr [rcx - 608]\n+\tvaddpd\tymm4, ymm4, ymmword ptr [rcx - 640]\n+\tvaddpd\tymm3, ymm3, ymmword ptr [rcx - 672]\n+\tvaddpd\tymm2, ymm2, ymmword ptr [rcx - 704]\n+\tvaddpd\tymm1, ymm1, ymmword ptr [rcx - 736]\n+\tvaddpd\tymm0, ymm0, ymmword ptr [rcx - 768]\n+\tvaddpd\tymm0, ymm0, ymmword ptr [rcx - 512]\n+\tvaddpd\tymm1, ymm1, ymmword ptr [rcx - 480]\n+\tvaddpd\tymm2, ymm2, ymmword ptr [rcx - 448]\n+\tvaddpd\tymm3, ymm3, ymmword ptr [rcx - 416]\n+\tvaddpd\tymm4, ymm4, ymmword ptr [rcx - 384]\n+\tvaddpd\tymm5, ymm5, ymmword ptr [rcx - 352]\n+\tvaddpd\tymm6, ymm6, ymmword ptr [rcx - 320]\n+\tvaddpd\tymm7, ymm7, ymmword ptr [rcx - 288]\n+\tvaddpd\tymm7, ymm7, ymmword ptr [rcx - 32]\n+\tvaddpd\tymm6, ymm6, ymmword ptr [rcx - 64]\n+\tvaddpd\tymm5, ymm5, ymmword ptr [rcx - 96]\n+\tvaddpd\tymm4, ymm4, ymmword ptr [rcx - 128]\n+\tvaddpd\tymm3, ymm3, ymmword ptr [rcx - 160]\n+\tvaddpd\tymm2, ymm2, ymmword ptr [rcx - 192]\n+\tvaddpd\tymm1, ymm1, ymmword ptr [rcx - 224]\n+\tvaddpd\tymm0, ymm0, ymmword ptr [rcx - 256]\n+\tvaddpd\tymm0, ymm0, ymmword ptr [rcx]\n+\tvaddpd\tymm1, ymm1, ymmword ptr [rcx + 32]\n+\tvaddpd\tymm2, ymm2, ymmword ptr [rcx + 64]\n+\tvaddpd\tymm3, ymm3, ymmword ptr [rcx + 96]\n+\tvaddpd\tymm4, ymm4, ymmword ptr [rcx + 128]\n+\tvaddpd\tymm5, ymm5, ymmword ptr [rcx + 160]\n+\tvaddpd\tymm6, ymm6, ymmword ptr [rcx + 192]\n+\tvaddpd\tymm7, ymm7, ymmword ptr [rcx + 224]\n+\tadd\trcx, 2048\n+\tadd\trax, -256\n+\tjne\t.LBB0_12\n+.LBB0_13:\n+\tvaddpd\tymm1, ymm1, ymm5\n+\tvaddpd\tymm3, ymm3, ymm7\n+\tvaddpd\tymm0, ymm0, ymm4\n+\tvaddpd\tymm2, ymm2, ymm6\n+\tvaddpd\tymm0, ymm0, ymm2\n+\tvaddpd\tymm1, ymm1, ymm3\n+\tvaddpd\tymm0, ymm0, ymm1\n+\tvextractf128\txmm1, ymm0, 1\n+\tvaddpd\tymm0, ymm0, ymm1\n+\tvhaddpd\tymm0, ymm0, ymm0\n+\tcmp\tr9, rsi\n+\tjne\t.LBB0_3\n+\tjmp\t.LBB0_14\n+.Lfunc_end0:\n+\t.size\tsum_float64_avx2, .Lfunc_end0-sum_float64_avx2\n+\n+\n+\t.ident\t\"Apple LLVM version 9.0.0 (clang-900.0.39.2)\"\n+\t.section\t\".note.GNU-stack\",\"\",@progbits\ndiff --git a/go/arrow/math/_lib/float64_sse4.s b/go/arrow/math/_lib/float64_sse4.s\nnew file mode 100644\nindex 000000000..7a454ee2d\n--- /dev/null\n+++ b/go/arrow/math/_lib/float64_sse4.s\n@@ -0,0 +1,103 @@\n+\t.text\n+\t.intel_syntax noprefix\n+\t.file\t\"_lib/float64.c\"\n+\t.globl\tsum_float64_sse4\n+\t.p2align\t4, 0x90\n+\t.type\tsum_float64_sse4,@function\n+sum_float64_sse4:                       # @sum_float64_sse4\n+# BB#0:\n+\tpush\trbp\n+\tmov\trbp, rsp\n+\tand\trsp, -8\n+\txorpd\txmm0, xmm0\n+\ttest\trsi, rsi\n+\tje\t.LBB0_14\n+# BB#1:\n+\tcmp\trsi, 3\n+\tjbe\t.LBB0_2\n+# BB#5:\n+\tmov\tr9, rsi\n+\tand\tr9, -4\n+\tje\t.LBB0_2\n+# BB#6:\n+\tlea\tr8, [r9 - 4]\n+\tmov\teax, r8d\n+\tshr\teax, 2\n+\tinc\teax\n+\tand\trax, 3\n+\tje\t.LBB0_7\n+# BB#8:\n+\tneg\trax\n+\txorpd\txmm0, xmm0\n+\txor\tecx, ecx\n+\txorpd\txmm1, xmm1\n+\t.p2align\t4, 0x90\n+.LBB0_9:                                # =>This Inner Loop Header: Depth=1\n+\tmovupd\txmm2, xmmword ptr [rdi + 8*rcx]\n+\tmovupd\txmm3, xmmword ptr [rdi + 8*rcx + 16]\n+\taddpd\txmm0, xmm2\n+\taddpd\txmm1, xmm3\n+\tadd\trcx, 4\n+\tinc\trax\n+\tjne\t.LBB0_9\n+\tjmp\t.LBB0_10\n+.LBB0_2:\n+\txor\tr9d, r9d\n+.LBB0_3:\n+\tlea\trax, [rdi + 8*r9]\n+\tsub\trsi, r9\n+\t.p2align\t4, 0x90\n+.LBB0_4:                                # =>This Inner Loop Header: Depth=1\n+\taddsd\txmm0, qword ptr [rax]\n+\tadd\trax, 8\n+\tdec\trsi\n+\tjne\t.LBB0_4\n+.LBB0_14:\n+\tmovsd\tqword ptr [rdx], xmm0\n+\tmov\trsp, rbp\n+\tpop\trbp\n+\tret\n+.LBB0_7:\n+\txor\tecx, ecx\n+\txorpd\txmm0, xmm0\n+\txorpd\txmm1, xmm1\n+.LBB0_10:\n+\tcmp\tr8, 12\n+\tjb\t.LBB0_13\n+# BB#11:\n+\tmov\trax, r9\n+\tsub\trax, rcx\n+\tlea\trcx, [rdi + 8*rcx + 112]\n+\t.p2align\t4, 0x90\n+.LBB0_12:                               # =>This Inner Loop Header: Depth=1\n+\tmovupd\txmm2, xmmword ptr [rcx - 112]\n+\tmovupd\txmm3, xmmword ptr [rcx - 96]\n+\tmovupd\txmm4, xmmword ptr [rcx - 80]\n+\tmovupd\txmm5, xmmword ptr [rcx - 64]\n+\taddpd\txmm2, xmm0\n+\taddpd\txmm3, xmm1\n+\tmovupd\txmm6, xmmword ptr [rcx - 48]\n+\tmovupd\txmm7, xmmword ptr [rcx - 32]\n+\taddpd\txmm6, xmm4\n+\taddpd\txmm6, xmm2\n+\taddpd\txmm7, xmm5\n+\taddpd\txmm7, xmm3\n+\tmovupd\txmm0, xmmword ptr [rcx - 16]\n+\tmovupd\txmm1, xmmword ptr [rcx]\n+\taddpd\txmm0, xmm6\n+\taddpd\txmm1, xmm7\n+\tsub\trcx, -128\n+\tadd\trax, -16\n+\tjne\t.LBB0_12\n+.LBB0_13:\n+\taddpd\txmm0, xmm1\n+\thaddpd\txmm0, xmm0\n+\tcmp\tr9, rsi\n+\tjne\t.LBB0_3\n+\tjmp\t.LBB0_14\n+.Lfunc_end0:\n+\t.size\tsum_float64_sse4, .Lfunc_end0-sum_float64_sse4\n+\n+\n+\t.ident\t\"Apple LLVM version 9.0.0 (clang-900.0.39.2)\"\n+\t.section\t\".note.GNU-stack\",\"\",@progbits\ndiff --git a/go/arrow/math/_lib/int64.c b/go/arrow/math/_lib/int64.c\nnew file mode 100644\nindex 000000000..5afe505f4\n--- /dev/null\n+++ b/go/arrow/math/_lib/int64.c\n@@ -0,0 +1,27 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <arch.h>\n+#include <memory.h>\n+#include <stdint.h>\n+\n+void FULL_NAME(sum_int64)(int64_t buf[], size_t len, int64_t *res) {\n+    int64_t acc = 0;\n+    for(int i = 0; i < len; i++) {\n+        acc += buf[i];\n+    }\n+    *res = acc;\n+}\n\\ No newline at end of file\ndiff --git a/go/arrow/math/_lib/int64_avx2.s b/go/arrow/math/_lib/int64_avx2.s\nnew file mode 100644\nindex 000000000..f088c49e8\n--- /dev/null\n+++ b/go/arrow/math/_lib/int64_avx2.s\n@@ -0,0 +1,181 @@\n+\t.text\n+\t.intel_syntax noprefix\n+\t.file\t\"_lib/int64.c\"\n+\t.globl\tsum_int64_avx2\n+\t.p2align\t4, 0x90\n+\t.type\tsum_int64_avx2,@function\n+sum_int64_avx2:                         # @sum_int64_avx2\n+# BB#0:\n+\tpush\trbp\n+\tmov\trbp, rsp\n+\tand\trsp, -8\n+\ttest\trsi, rsi\n+\tje\t.LBB0_1\n+# BB#2:\n+\tcmp\trsi, 31\n+\tjbe\t.LBB0_3\n+# BB#6:\n+\tmov\tr9, rsi\n+\tand\tr9, -32\n+\tje\t.LBB0_3\n+# BB#7:\n+\tlea\tr8, [r9 - 32]\n+\tmov\teax, r8d\n+\tshr\teax, 5\n+\tinc\teax\n+\tand\trax, 7\n+\tje\t.LBB0_8\n+# BB#9:\n+\tneg\trax\n+\tvpxor\tymm0, ymm0, ymm0\n+\txor\tecx, ecx\n+\tvpxor\tymm1, ymm1, ymm1\n+\tvpxor\tymm2, ymm2, ymm2\n+\tvpxor\tymm3, ymm3, ymm3\n+\tvpxor\tymm4, ymm4, ymm4\n+\tvpxor\tymm5, ymm5, ymm5\n+\tvpxor\tymm6, ymm6, ymm6\n+\tvpxor\tymm7, ymm7, ymm7\n+\t.p2align\t4, 0x90\n+.LBB0_10:                               # =>This Inner Loop Header: Depth=1\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rdi + 8*rcx]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rdi + 8*rcx + 32]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rdi + 8*rcx + 64]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rdi + 8*rcx + 96]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rdi + 8*rcx + 128]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rdi + 8*rcx + 160]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rdi + 8*rcx + 192]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rdi + 8*rcx + 224]\n+\tadd\trcx, 32\n+\tinc\trax\n+\tjne\t.LBB0_10\n+\tjmp\t.LBB0_11\n+.LBB0_3:\n+\txor\tr9d, r9d\n+\txor\teax, eax\n+.LBB0_4:\n+\tlea\trcx, [rdi + 8*r9]\n+\tsub\trsi, r9\n+\t.p2align\t4, 0x90\n+.LBB0_5:                                # =>This Inner Loop Header: Depth=1\n+\tadd\trax, qword ptr [rcx]\n+\tadd\trcx, 8\n+\tdec\trsi\n+\tjne\t.LBB0_5\n+\tjmp\t.LBB0_15\n+.LBB0_1:\n+\txor\teax, eax\n+.LBB0_15:\n+\tmov\tqword ptr [rdx], rax\n+\tmov\trsp, rbp\n+\tpop\trbp\n+\tvzeroupper\n+\tret\n+.LBB0_8:\n+\txor\tecx, ecx\n+\tvpxor\tymm0, ymm0, ymm0\n+\tvpxor\tymm1, ymm1, ymm1\n+\tvpxor\tymm2, ymm2, ymm2\n+\tvpxor\tymm3, ymm3, ymm3\n+\tvpxor\tymm4, ymm4, ymm4\n+\tvpxor\tymm5, ymm5, ymm5\n+\tvpxor\tymm6, ymm6, ymm6\n+\tvpxor\tymm7, ymm7, ymm7\n+.LBB0_11:\n+\tcmp\tr8, 224\n+\tjb\t.LBB0_14\n+# BB#12:\n+\tmov\trax, r9\n+\tsub\trax, rcx\n+\tlea\trcx, [rdi + 8*rcx + 1792]\n+\t.p2align\t4, 0x90\n+.LBB0_13:                               # =>This Inner Loop Header: Depth=1\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 1568]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 1600]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 1632]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 1664]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 1696]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 1728]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 1760]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 1792]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 1536]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 1504]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 1472]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 1440]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 1408]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 1376]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 1344]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 1312]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 1056]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 1088]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 1120]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 1152]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 1184]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 1216]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 1248]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 1280]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 1024]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 992]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 960]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 928]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 896]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 864]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 832]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 800]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 544]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 576]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 608]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 640]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 672]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 704]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 736]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 768]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 512]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 480]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 448]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 416]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 384]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 352]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 320]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 288]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 32]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 64]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 96]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 128]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 160]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 192]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 224]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 256]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx + 32]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx + 64]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx + 96]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx + 128]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx + 160]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx + 192]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx + 224]\n+\tadd\trcx, 2048\n+\tadd\trax, -256\n+\tjne\t.LBB0_13\n+.LBB0_14:\n+\tvpaddq\tymm1, ymm1, ymm5\n+\tvpaddq\tymm3, ymm3, ymm7\n+\tvpaddq\tymm0, ymm0, ymm4\n+\tvpaddq\tymm2, ymm2, ymm6\n+\tvpaddq\tymm0, ymm0, ymm2\n+\tvpaddq\tymm1, ymm1, ymm3\n+\tvpaddq\tymm0, ymm0, ymm1\n+\tvextracti128\txmm1, ymm0, 1\n+\tvpaddq\tymm0, ymm0, ymm1\n+\tvpshufd\txmm1, xmm0, 78          # xmm1 = xmm0[2,3,0,1]\n+\tvpaddq\tymm0, ymm0, ymm1\n+\tvmovq\trax, xmm0\n+\tcmp\tr9, rsi\n+\tjne\t.LBB0_4\n+\tjmp\t.LBB0_15\n+.Lfunc_end0:\n+\t.size\tsum_int64_avx2, .Lfunc_end0-sum_int64_avx2\n+\n+\n+\t.ident\t\"Apple LLVM version 9.0.0 (clang-900.0.39.2)\"\n+\t.section\t\".note.GNU-stack\",\"\",@progbits\ndiff --git a/go/arrow/math/_lib/int64_sse4.s b/go/arrow/math/_lib/int64_sse4.s\nnew file mode 100644\nindex 000000000..d433260f7\n--- /dev/null\n+++ b/go/arrow/math/_lib/int64_sse4.s\n@@ -0,0 +1,108 @@\n+\t.text\n+\t.intel_syntax noprefix\n+\t.file\t\"_lib/int64.c\"\n+\t.globl\tsum_int64_sse4\n+\t.p2align\t4, 0x90\n+\t.type\tsum_int64_sse4,@function\n+sum_int64_sse4:                         # @sum_int64_sse4\n+# BB#0:\n+\tpush\trbp\n+\tmov\trbp, rsp\n+\tand\trsp, -8\n+\ttest\trsi, rsi\n+\tje\t.LBB0_1\n+# BB#2:\n+\tcmp\trsi, 3\n+\tjbe\t.LBB0_3\n+# BB#6:\n+\tmov\tr9, rsi\n+\tand\tr9, -4\n+\tje\t.LBB0_3\n+# BB#7:\n+\tlea\tr8, [r9 - 4]\n+\tmov\teax, r8d\n+\tshr\teax, 2\n+\tinc\teax\n+\tand\trax, 3\n+\tje\t.LBB0_8\n+# BB#9:\n+\tneg\trax\n+\tpxor\txmm0, xmm0\n+\txor\tecx, ecx\n+\tpxor\txmm1, xmm1\n+\t.p2align\t4, 0x90\n+.LBB0_10:                               # =>This Inner Loop Header: Depth=1\n+\tmovdqu\txmm2, xmmword ptr [rdi + 8*rcx]\n+\tmovdqu\txmm3, xmmword ptr [rdi + 8*rcx + 16]\n+\tpaddq\txmm0, xmm2\n+\tpaddq\txmm1, xmm3\n+\tadd\trcx, 4\n+\tinc\trax\n+\tjne\t.LBB0_10\n+\tjmp\t.LBB0_11\n+.LBB0_3:\n+\txor\tr9d, r9d\n+\txor\teax, eax\n+.LBB0_4:\n+\tlea\trcx, [rdi + 8*r9]\n+\tsub\trsi, r9\n+\t.p2align\t4, 0x90\n+.LBB0_5:                                # =>This Inner Loop Header: Depth=1\n+\tadd\trax, qword ptr [rcx]\n+\tadd\trcx, 8\n+\tdec\trsi\n+\tjne\t.LBB0_5\n+\tjmp\t.LBB0_15\n+.LBB0_1:\n+\txor\teax, eax\n+.LBB0_15:\n+\tmov\tqword ptr [rdx], rax\n+\tmov\trsp, rbp\n+\tpop\trbp\n+\tret\n+.LBB0_8:\n+\txor\tecx, ecx\n+\tpxor\txmm0, xmm0\n+\tpxor\txmm1, xmm1\n+.LBB0_11:\n+\tcmp\tr8, 12\n+\tjb\t.LBB0_14\n+# BB#12:\n+\tmov\trax, r9\n+\tsub\trax, rcx\n+\tlea\trcx, [rdi + 8*rcx + 112]\n+\t.p2align\t4, 0x90\n+.LBB0_13:                               # =>This Inner Loop Header: Depth=1\n+\tmovdqu\txmm2, xmmword ptr [rcx - 112]\n+\tmovdqu\txmm3, xmmword ptr [rcx - 96]\n+\tmovdqu\txmm4, xmmword ptr [rcx - 80]\n+\tmovdqu\txmm5, xmmword ptr [rcx - 64]\n+\tpaddq\txmm2, xmm0\n+\tpaddq\txmm3, xmm1\n+\tmovdqu\txmm6, xmmword ptr [rcx - 48]\n+\tmovdqu\txmm7, xmmword ptr [rcx - 32]\n+\tpaddq\txmm6, xmm4\n+\tpaddq\txmm6, xmm2\n+\tpaddq\txmm7, xmm5\n+\tpaddq\txmm7, xmm3\n+\tmovdqu\txmm0, xmmword ptr [rcx - 16]\n+\tmovdqu\txmm1, xmmword ptr [rcx]\n+\tpaddq\txmm0, xmm6\n+\tpaddq\txmm1, xmm7\n+\tsub\trcx, -128\n+\tadd\trax, -16\n+\tjne\t.LBB0_13\n+.LBB0_14:\n+\tpaddq\txmm0, xmm1\n+\tpshufd\txmm1, xmm0, 78          # xmm1 = xmm0[2,3,0,1]\n+\tpaddq\txmm1, xmm0\n+\tmovq\trax, xmm1\n+\tcmp\tr9, rsi\n+\tjne\t.LBB0_4\n+\tjmp\t.LBB0_15\n+.Lfunc_end0:\n+\t.size\tsum_int64_sse4, .Lfunc_end0-sum_int64_sse4\n+\n+\n+\t.ident\t\"Apple LLVM version 9.0.0 (clang-900.0.39.2)\"\n+\t.section\t\".note.GNU-stack\",\"\",@progbits\ndiff --git a/go/arrow/math/_lib/uint64.c b/go/arrow/math/_lib/uint64.c\nnew file mode 100644\nindex 000000000..91d3d9add\n--- /dev/null\n+++ b/go/arrow/math/_lib/uint64.c\n@@ -0,0 +1,27 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include <arch.h>\n+#include <memory.h>\n+#include <stdint.h>\n+\n+void FULL_NAME(sum_uint64)(uint64_t buf[], size_t len, uint64_t *res) {\n+    uint64_t acc = 0;\n+    for(int i = 0; i < len; i++) {\n+        acc += buf[i];\n+    }\n+    *res = acc;\n+}\n\\ No newline at end of file\ndiff --git a/go/arrow/math/_lib/uint64_avx2.s b/go/arrow/math/_lib/uint64_avx2.s\nnew file mode 100644\nindex 000000000..e4502ee06\n--- /dev/null\n+++ b/go/arrow/math/_lib/uint64_avx2.s\n@@ -0,0 +1,181 @@\n+\t.text\n+\t.intel_syntax noprefix\n+\t.file\t\"_lib/uint64.c\"\n+\t.globl\tsum_uint64_avx2\n+\t.p2align\t4, 0x90\n+\t.type\tsum_uint64_avx2,@function\n+sum_uint64_avx2:                        # @sum_uint64_avx2\n+# BB#0:\n+\tpush\trbp\n+\tmov\trbp, rsp\n+\tand\trsp, -8\n+\ttest\trsi, rsi\n+\tje\t.LBB0_1\n+# BB#2:\n+\tcmp\trsi, 31\n+\tjbe\t.LBB0_3\n+# BB#6:\n+\tmov\tr9, rsi\n+\tand\tr9, -32\n+\tje\t.LBB0_3\n+# BB#7:\n+\tlea\tr8, [r9 - 32]\n+\tmov\teax, r8d\n+\tshr\teax, 5\n+\tinc\teax\n+\tand\trax, 7\n+\tje\t.LBB0_8\n+# BB#9:\n+\tneg\trax\n+\tvpxor\tymm0, ymm0, ymm0\n+\txor\tecx, ecx\n+\tvpxor\tymm1, ymm1, ymm1\n+\tvpxor\tymm2, ymm2, ymm2\n+\tvpxor\tymm3, ymm3, ymm3\n+\tvpxor\tymm4, ymm4, ymm4\n+\tvpxor\tymm5, ymm5, ymm5\n+\tvpxor\tymm6, ymm6, ymm6\n+\tvpxor\tymm7, ymm7, ymm7\n+\t.p2align\t4, 0x90\n+.LBB0_10:                               # =>This Inner Loop Header: Depth=1\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rdi + 8*rcx]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rdi + 8*rcx + 32]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rdi + 8*rcx + 64]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rdi + 8*rcx + 96]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rdi + 8*rcx + 128]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rdi + 8*rcx + 160]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rdi + 8*rcx + 192]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rdi + 8*rcx + 224]\n+\tadd\trcx, 32\n+\tinc\trax\n+\tjne\t.LBB0_10\n+\tjmp\t.LBB0_11\n+.LBB0_3:\n+\txor\tr9d, r9d\n+\txor\teax, eax\n+.LBB0_4:\n+\tlea\trcx, [rdi + 8*r9]\n+\tsub\trsi, r9\n+\t.p2align\t4, 0x90\n+.LBB0_5:                                # =>This Inner Loop Header: Depth=1\n+\tadd\trax, qword ptr [rcx]\n+\tadd\trcx, 8\n+\tdec\trsi\n+\tjne\t.LBB0_5\n+\tjmp\t.LBB0_15\n+.LBB0_1:\n+\txor\teax, eax\n+.LBB0_15:\n+\tmov\tqword ptr [rdx], rax\n+\tmov\trsp, rbp\n+\tpop\trbp\n+\tvzeroupper\n+\tret\n+.LBB0_8:\n+\txor\tecx, ecx\n+\tvpxor\tymm0, ymm0, ymm0\n+\tvpxor\tymm1, ymm1, ymm1\n+\tvpxor\tymm2, ymm2, ymm2\n+\tvpxor\tymm3, ymm3, ymm3\n+\tvpxor\tymm4, ymm4, ymm4\n+\tvpxor\tymm5, ymm5, ymm5\n+\tvpxor\tymm6, ymm6, ymm6\n+\tvpxor\tymm7, ymm7, ymm7\n+.LBB0_11:\n+\tcmp\tr8, 224\n+\tjb\t.LBB0_14\n+# BB#12:\n+\tmov\trax, r9\n+\tsub\trax, rcx\n+\tlea\trcx, [rdi + 8*rcx + 1792]\n+\t.p2align\t4, 0x90\n+.LBB0_13:                               # =>This Inner Loop Header: Depth=1\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 1568]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 1600]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 1632]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 1664]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 1696]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 1728]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 1760]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 1792]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 1536]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 1504]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 1472]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 1440]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 1408]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 1376]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 1344]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 1312]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 1056]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 1088]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 1120]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 1152]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 1184]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 1216]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 1248]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 1280]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 1024]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 992]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 960]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 928]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 896]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 864]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 832]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 800]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 544]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 576]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 608]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 640]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 672]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 704]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 736]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 768]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 512]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 480]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 448]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 416]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 384]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 352]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 320]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 288]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx - 32]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx - 64]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx - 96]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx - 128]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx - 160]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx - 192]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx - 224]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx - 256]\n+\tvpaddq\tymm0, ymm0, ymmword ptr [rcx]\n+\tvpaddq\tymm1, ymm1, ymmword ptr [rcx + 32]\n+\tvpaddq\tymm2, ymm2, ymmword ptr [rcx + 64]\n+\tvpaddq\tymm3, ymm3, ymmword ptr [rcx + 96]\n+\tvpaddq\tymm4, ymm4, ymmword ptr [rcx + 128]\n+\tvpaddq\tymm5, ymm5, ymmword ptr [rcx + 160]\n+\tvpaddq\tymm6, ymm6, ymmword ptr [rcx + 192]\n+\tvpaddq\tymm7, ymm7, ymmword ptr [rcx + 224]\n+\tadd\trcx, 2048\n+\tadd\trax, -256\n+\tjne\t.LBB0_13\n+.LBB0_14:\n+\tvpaddq\tymm1, ymm1, ymm5\n+\tvpaddq\tymm3, ymm3, ymm7\n+\tvpaddq\tymm0, ymm0, ymm4\n+\tvpaddq\tymm2, ymm2, ymm6\n+\tvpaddq\tymm0, ymm0, ymm2\n+\tvpaddq\tymm1, ymm1, ymm3\n+\tvpaddq\tymm0, ymm0, ymm1\n+\tvextracti128\txmm1, ymm0, 1\n+\tvpaddq\tymm0, ymm0, ymm1\n+\tvpshufd\txmm1, xmm0, 78          # xmm1 = xmm0[2,3,0,1]\n+\tvpaddq\tymm0, ymm0, ymm1\n+\tvmovq\trax, xmm0\n+\tcmp\tr9, rsi\n+\tjne\t.LBB0_4\n+\tjmp\t.LBB0_15\n+.Lfunc_end0:\n+\t.size\tsum_uint64_avx2, .Lfunc_end0-sum_uint64_avx2\n+\n+\n+\t.ident\t\"Apple LLVM version 9.0.0 (clang-900.0.39.2)\"\n+\t.section\t\".note.GNU-stack\",\"\",@progbits\ndiff --git a/go/arrow/math/_lib/uint64_sse4.s b/go/arrow/math/_lib/uint64_sse4.s\nnew file mode 100644\nindex 000000000..04b4cc853\n--- /dev/null\n+++ b/go/arrow/math/_lib/uint64_sse4.s\n@@ -0,0 +1,108 @@\n+\t.text\n+\t.intel_syntax noprefix\n+\t.file\t\"_lib/uint64.c\"\n+\t.globl\tsum_uint64_sse4\n+\t.p2align\t4, 0x90\n+\t.type\tsum_uint64_sse4,@function\n+sum_uint64_sse4:                        # @sum_uint64_sse4\n+# BB#0:\n+\tpush\trbp\n+\tmov\trbp, rsp\n+\tand\trsp, -8\n+\ttest\trsi, rsi\n+\tje\t.LBB0_1\n+# BB#2:\n+\tcmp\trsi, 3\n+\tjbe\t.LBB0_3\n+# BB#6:\n+\tmov\tr9, rsi\n+\tand\tr9, -4\n+\tje\t.LBB0_3\n+# BB#7:\n+\tlea\tr8, [r9 - 4]\n+\tmov\teax, r8d\n+\tshr\teax, 2\n+\tinc\teax\n+\tand\trax, 3\n+\tje\t.LBB0_8\n+# BB#9:\n+\tneg\trax\n+\tpxor\txmm0, xmm0\n+\txor\tecx, ecx\n+\tpxor\txmm1, xmm1\n+\t.p2align\t4, 0x90\n+.LBB0_10:                               # =>This Inner Loop Header: Depth=1\n+\tmovdqu\txmm2, xmmword ptr [rdi + 8*rcx]\n+\tmovdqu\txmm3, xmmword ptr [rdi + 8*rcx + 16]\n+\tpaddq\txmm0, xmm2\n+\tpaddq\txmm1, xmm3\n+\tadd\trcx, 4\n+\tinc\trax\n+\tjne\t.LBB0_10\n+\tjmp\t.LBB0_11\n+.LBB0_3:\n+\txor\tr9d, r9d\n+\txor\teax, eax\n+.LBB0_4:\n+\tlea\trcx, [rdi + 8*r9]\n+\tsub\trsi, r9\n+\t.p2align\t4, 0x90\n+.LBB0_5:                                # =>This Inner Loop Header: Depth=1\n+\tadd\trax, qword ptr [rcx]\n+\tadd\trcx, 8\n+\tdec\trsi\n+\tjne\t.LBB0_5\n+\tjmp\t.LBB0_15\n+.LBB0_1:\n+\txor\teax, eax\n+.LBB0_15:\n+\tmov\tqword ptr [rdx], rax\n+\tmov\trsp, rbp\n+\tpop\trbp\n+\tret\n+.LBB0_8:\n+\txor\tecx, ecx\n+\tpxor\txmm0, xmm0\n+\tpxor\txmm1, xmm1\n+.LBB0_11:\n+\tcmp\tr8, 12\n+\tjb\t.LBB0_14\n+# BB#12:\n+\tmov\trax, r9\n+\tsub\trax, rcx\n+\tlea\trcx, [rdi + 8*rcx + 112]\n+\t.p2align\t4, 0x90\n+.LBB0_13:                               # =>This Inner Loop Header: Depth=1\n+\tmovdqu\txmm2, xmmword ptr [rcx - 112]\n+\tmovdqu\txmm3, xmmword ptr [rcx - 96]\n+\tmovdqu\txmm4, xmmword ptr [rcx - 80]\n+\tmovdqu\txmm5, xmmword ptr [rcx - 64]\n+\tpaddq\txmm2, xmm0\n+\tpaddq\txmm3, xmm1\n+\tmovdqu\txmm6, xmmword ptr [rcx - 48]\n+\tmovdqu\txmm7, xmmword ptr [rcx - 32]\n+\tpaddq\txmm6, xmm4\n+\tpaddq\txmm6, xmm2\n+\tpaddq\txmm7, xmm5\n+\tpaddq\txmm7, xmm3\n+\tmovdqu\txmm0, xmmword ptr [rcx - 16]\n+\tmovdqu\txmm1, xmmword ptr [rcx]\n+\tpaddq\txmm0, xmm6\n+\tpaddq\txmm1, xmm7\n+\tsub\trcx, -128\n+\tadd\trax, -16\n+\tjne\t.LBB0_13\n+.LBB0_14:\n+\tpaddq\txmm0, xmm1\n+\tpshufd\txmm1, xmm0, 78          # xmm1 = xmm0[2,3,0,1]\n+\tpaddq\txmm1, xmm0\n+\tmovq\trax, xmm1\n+\tcmp\tr9, rsi\n+\tjne\t.LBB0_4\n+\tjmp\t.LBB0_15\n+.Lfunc_end0:\n+\t.size\tsum_uint64_sse4, .Lfunc_end0-sum_uint64_sse4\n+\n+\n+\t.ident\t\"Apple LLVM version 9.0.0 (clang-900.0.39.2)\"\n+\t.section\t\".note.GNU-stack\",\"\",@progbits\ndiff --git a/go/arrow/math/doc.go b/go/arrow/math/doc.go\nnew file mode 100644\nindex 000000000..30d50a2f1\n--- /dev/null\n+++ b/go/arrow/math/doc.go\n@@ -0,0 +1,30 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*\n+Package math provides optimized mathematical functions for processing Arrow arrays.\n+*/\n+package math\n+\n+//go:generate go run ../_tools/tmpl/main.go -i -data=float64.tmpldata type.go.tmpl=float64.go type_amd64.go.tmpl=float64_amd64.go type_test.go.tmpl=float64_test.go\n+//go:generate go run ../_tools/tmpl/main.go -i -data=float64.tmpldata -d arch=avx2 type_simd_amd64.go.tmpl=float64_avx2_amd64.go\n+//go:generate go run ../_tools/tmpl/main.go -i -data=float64.tmpldata -d arch=sse4 type_simd_amd64.go.tmpl=float64_sse4_amd64.go\n+//go:generate go run ../_tools/tmpl/main.go -i -data=int64.tmpldata type.go.tmpl=int64.go type_amd64.go.tmpl=int64_amd64.go type_test.go.tmpl=int64_test.go\n+//go:generate go run ../_tools/tmpl/main.go -i -data=int64.tmpldata -d arch=avx2 type_simd_amd64.go.tmpl=int64_avx2_amd64.go\n+//go:generate go run ../_tools/tmpl/main.go -i -data=int64.tmpldata -d arch=sse4 type_simd_amd64.go.tmpl=int64_sse4_amd64.go\n+//go:generate go run ../_tools/tmpl/main.go -i -data=uint64.tmpldata type.go.tmpl=uint64.go type_amd64.go.tmpl=uint64_amd64.go type_test.go.tmpl=uint64_test.go\n+//go:generate go run ../_tools/tmpl/main.go -i -data=uint64.tmpldata -d arch=avx2 type_simd_amd64.go.tmpl=uint64_avx2_amd64.go\n+//go:generate go run ../_tools/tmpl/main.go -i -data=uint64.tmpldata -d arch=sse4 type_simd_amd64.go.tmpl=uint64_sse4_amd64.go\ndiff --git a/go/arrow/math/float64.go b/go/arrow/math/float64.go\nnew file mode 100644\nindex 000000000..a9c54665e\n--- /dev/null\n+++ b/go/arrow/math/float64.go\n@@ -0,0 +1,44 @@\n+// Code generated by type.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package math\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+)\n+\n+type Float64Funcs struct {\n+\tsum func(a *array.Float64) float64\n+}\n+\n+var (\n+\tFloat64 Float64Funcs\n+)\n+\n+// Sum returns the summation of all elements in a.\n+func (f Float64Funcs) Sum(a *array.Float64) float64 {\n+\treturn f.sum(a)\n+}\n+\n+func sum_float64_go(a *array.Float64) float64 {\n+\tacc := float64(0)\n+\tfor _, v := range a.Float64Values() {\n+\t\tacc += v\n+\t}\n+\treturn acc\n+}\ndiff --git a/go/arrow/math/float64.tmpldata b/go/arrow/math/float64.tmpldata\nnew file mode 100644\nindex 000000000..de54eea2a\n--- /dev/null\n+++ b/go/arrow/math/float64.tmpldata\n@@ -0,0 +1,4 @@\n+{\n+  \"Name\": \"Float64\",\n+  \"Type\": \"float64\"\n+}\n\\ No newline at end of file\ndiff --git a/go/arrow/math/float64_amd64.go b/go/arrow/math/float64_amd64.go\nnew file mode 100644\nindex 000000000..87227d5fa\n--- /dev/null\n+++ b/go/arrow/math/float64_amd64.go\n@@ -0,0 +1,33 @@\n+// Code generated by type_amd64.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package math\n+\n+func initFloat64AVX2() {\n+\tFloat64.sum = sum_float64_avx2\n+}\n+\n+func initFloat64SSE4() {\n+\tFloat64.sum = sum_float64_sse4\n+}\n+\n+func initFloat64Go() {\n+\tFloat64.sum = sum_float64_go\n+}\ndiff --git a/go/arrow/math/float64_avx2_amd64.go b/go/arrow/math/float64_avx2_amd64.go\nnew file mode 100644\nindex 000000000..9301b3284\n--- /dev/null\n+++ b/go/arrow/math/float64_avx2_amd64.go\n@@ -0,0 +1,41 @@\n+// Code generated by type_simd_amd64.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package math\n+\n+import (\n+\t\"unsafe\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+)\n+\n+//go:noescape\n+func _sum_float64_avx2(buf, len, res unsafe.Pointer)\n+\n+func sum_float64_avx2(a *array.Float64) float64 {\n+\tbuf := a.Float64Values()\n+\tvar (\n+\t\tp1  = unsafe.Pointer(&buf[0])\n+\t\tp2  = unsafe.Pointer(uintptr(len(buf)))\n+\t\tres float64\n+\t)\n+\t_sum_float64_avx2(p1, p2, unsafe.Pointer(&res))\n+\treturn res\n+}\ndiff --git a/go/arrow/math/float64_avx2_amd64.s b/go/arrow/math/float64_avx2_amd64.s\nnew file mode 100644\nindex 000000000..e5fe247ec\n--- /dev/null\n+++ b/go/arrow/math/float64_avx2_amd64.s\n@@ -0,0 +1,167 @@\n+//+build !noasm !appengine\n+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT\n+\n+TEXT \u00b7_sum_float64_avx2(SB), $0-24\n+\n+\tMOVQ buf+0(FP), DI\n+\tMOVQ len+8(FP), SI\n+\tMOVQ res+16(FP), DX\n+\n+\tLONG $0xc057f9c5         // vxorpd    xmm0, xmm0, xmm0\n+\tWORD $0x8548; BYTE $0xf6 // test    rsi, rsi\n+\tJE   LBB0_14\n+\tLONG $0x1ffe8348         // cmp    rsi, 31\n+\tJBE  LBB0_2\n+\tWORD $0x8949; BYTE $0xf1 // mov    r9, rsi\n+\tLONG $0xe0e18349         // and    r9, -32\n+\tJE   LBB0_2\n+\tLONG $0xe0418d4d         // lea    r8, [r9 - 32]\n+\tWORD $0x8944; BYTE $0xc0 // mov    eax, r8d\n+\tWORD $0xe8c1; BYTE $0x05 // shr    eax, 5\n+\tWORD $0xc0ff             // inc    eax\n+\tLONG $0x07e08348         // and    rax, 7\n+\tJE   LBB0_7\n+\tWORD $0xf748; BYTE $0xd8 // neg    rax\n+\tLONG $0xc057fdc5         // vxorpd    ymm0, ymm0, ymm0\n+\tWORD $0xc931             // xor    ecx, ecx\n+\tLONG $0xc957f5c5         // vxorpd    ymm1, ymm1, ymm1\n+\tLONG $0xd257edc5         // vxorpd    ymm2, ymm2, ymm2\n+\tLONG $0xdb57e5c5         // vxorpd    ymm3, ymm3, ymm3\n+\tLONG $0xe457ddc5         // vxorpd    ymm4, ymm4, ymm4\n+\tLONG $0xed57d5c5         // vxorpd    ymm5, ymm5, ymm5\n+\tLONG $0xf657cdc5         // vxorpd    ymm6, ymm6, ymm6\n+\tLONG $0xff57c5c5         // vxorpd    ymm7, ymm7, ymm7\n+\n+LBB0_9:\n+\tLONG $0x0458fdc5; BYTE $0xcf         // vaddpd    ymm0, ymm0, yword [rdi + 8*rcx]\n+\tLONG $0x4c58f5c5; WORD $0x20cf       // vaddpd    ymm1, ymm1, yword [rdi + 8*rcx + 32]\n+\tLONG $0x5458edc5; WORD $0x40cf       // vaddpd    ymm2, ymm2, yword [rdi + 8*rcx + 64]\n+\tLONG $0x5c58e5c5; WORD $0x60cf       // vaddpd    ymm3, ymm3, yword [rdi + 8*rcx + 96]\n+\tQUAD $0x000080cfa458ddc5; BYTE $0x00 // vaddpd    ymm4, ymm4, yword [rdi + 8*rcx + 128]\n+\tQUAD $0x0000a0cfac58d5c5; BYTE $0x00 // vaddpd    ymm5, ymm5, yword [rdi + 8*rcx + 160]\n+\tQUAD $0x0000c0cfb458cdc5; BYTE $0x00 // vaddpd    ymm6, ymm6, yword [rdi + 8*rcx + 192]\n+\tQUAD $0x0000e0cfbc58c5c5; BYTE $0x00 // vaddpd    ymm7, ymm7, yword [rdi + 8*rcx + 224]\n+\tLONG $0x20c18348                     // add    rcx, 32\n+\tWORD $0xff48; BYTE $0xc0             // inc    rax\n+\tJNE  LBB0_9\n+\tJMP  LBB0_10\n+\n+LBB0_2:\n+\tWORD $0x3145; BYTE $0xc9 // xor    r9d, r9d\n+\n+LBB0_3:\n+\tLONG $0xcf048d4a         // lea    rax, [rdi + 8*r9]\n+\tWORD $0x294c; BYTE $0xce // sub    rsi, r9\n+\n+LBB0_4:\n+\tLONG $0x0058fbc5         // vaddsd    xmm0, xmm0, qword [rax]\n+\tLONG $0x08c08348         // add    rax, 8\n+\tWORD $0xff48; BYTE $0xce // dec    rsi\n+\tJNE  LBB0_4\n+\n+LBB0_14:\n+\tLONG $0x0211fbc5 // vmovsd    qword [rdx], xmm0\n+\tVZEROUPPER\n+\tRET\n+\n+LBB0_7:\n+\tWORD $0xc931     // xor    ecx, ecx\n+\tLONG $0xc057fdc5 // vxorpd    ymm0, ymm0, ymm0\n+\tLONG $0xc957f5c5 // vxorpd    ymm1, ymm1, ymm1\n+\tLONG $0xd257edc5 // vxorpd    ymm2, ymm2, ymm2\n+\tLONG $0xdb57e5c5 // vxorpd    ymm3, ymm3, ymm3\n+\tLONG $0xe457ddc5 // vxorpd    ymm4, ymm4, ymm4\n+\tLONG $0xed57d5c5 // vxorpd    ymm5, ymm5, ymm5\n+\tLONG $0xf657cdc5 // vxorpd    ymm6, ymm6, ymm6\n+\tLONG $0xff57c5c5 // vxorpd    ymm7, ymm7, ymm7\n+\n+LBB0_10:\n+\tLONG $0xe0f88149; WORD $0x0000; BYTE $0x00 // cmp    r8, 224\n+\tJB   LBB0_13\n+\tWORD $0x894c; BYTE $0xc8                   // mov    rax, r9\n+\tWORD $0x2948; BYTE $0xc8                   // sub    rax, rcx\n+\tQUAD $0x00000700cf8c8d48                   // lea    rcx, [rdi + 8*rcx + 1792]\n+\n+LBB0_12:\n+\tQUAD $0xfffff9e0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx - 1568]\n+\tQUAD $0xfffff9c0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx - 1600]\n+\tQUAD $0xfffff9a0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx - 1632]\n+\tQUAD $0xfffff980a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx - 1664]\n+\tQUAD $0xfffff9609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 1696]\n+\tQUAD $0xfffff9409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 1728]\n+\tQUAD $0xfffff9208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 1760]\n+\tQUAD $0xfffff9008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 1792]\n+\tQUAD $0xfffffa008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 1536]\n+\tQUAD $0xfffffa208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 1504]\n+\tQUAD $0xfffffa409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 1472]\n+\tQUAD $0xfffffa609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 1440]\n+\tQUAD $0xfffffa80a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx - 1408]\n+\tQUAD $0xfffffaa0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx - 1376]\n+\tQUAD $0xfffffac0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx - 1344]\n+\tQUAD $0xfffffae0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx - 1312]\n+\tQUAD $0xfffffbe0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx - 1056]\n+\tQUAD $0xfffffbc0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx - 1088]\n+\tQUAD $0xfffffba0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx - 1120]\n+\tQUAD $0xfffffb80a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx - 1152]\n+\tQUAD $0xfffffb609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 1184]\n+\tQUAD $0xfffffb409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 1216]\n+\tQUAD $0xfffffb208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 1248]\n+\tQUAD $0xfffffb008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 1280]\n+\tQUAD $0xfffffc008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 1024]\n+\tQUAD $0xfffffc208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 992]\n+\tQUAD $0xfffffc409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 960]\n+\tQUAD $0xfffffc609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 928]\n+\tQUAD $0xfffffc80a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx - 896]\n+\tQUAD $0xfffffca0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx - 864]\n+\tQUAD $0xfffffcc0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx - 832]\n+\tQUAD $0xfffffce0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx - 800]\n+\tQUAD $0xfffffde0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx - 544]\n+\tQUAD $0xfffffdc0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx - 576]\n+\tQUAD $0xfffffda0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx - 608]\n+\tQUAD $0xfffffd80a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx - 640]\n+\tQUAD $0xfffffd609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 672]\n+\tQUAD $0xfffffd409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 704]\n+\tQUAD $0xfffffd208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 736]\n+\tQUAD $0xfffffd008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 768]\n+\tQUAD $0xfffffe008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 512]\n+\tQUAD $0xfffffe208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 480]\n+\tQUAD $0xfffffe409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 448]\n+\tQUAD $0xfffffe609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 416]\n+\tQUAD $0xfffffe80a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx - 384]\n+\tQUAD $0xfffffea0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx - 352]\n+\tQUAD $0xfffffec0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx - 320]\n+\tQUAD $0xfffffee0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx - 288]\n+\tLONG $0x7958c5c5; BYTE $0xe0               // vaddpd    ymm7, ymm7, yword [rcx - 32]\n+\tLONG $0x7158cdc5; BYTE $0xc0               // vaddpd    ymm6, ymm6, yword [rcx - 64]\n+\tLONG $0x6958d5c5; BYTE $0xa0               // vaddpd    ymm5, ymm5, yword [rcx - 96]\n+\tLONG $0x6158ddc5; BYTE $0x80               // vaddpd    ymm4, ymm4, yword [rcx - 128]\n+\tQUAD $0xffffff609958e5c5                   // vaddpd    ymm3, ymm3, yword [rcx - 160]\n+\tQUAD $0xffffff409158edc5                   // vaddpd    ymm2, ymm2, yword [rcx - 192]\n+\tQUAD $0xffffff208958f5c5                   // vaddpd    ymm1, ymm1, yword [rcx - 224]\n+\tQUAD $0xffffff008158fdc5                   // vaddpd    ymm0, ymm0, yword [rcx - 256]\n+\tLONG $0x0158fdc5                           // vaddpd    ymm0, ymm0, yword [rcx]\n+\tLONG $0x4958f5c5; BYTE $0x20               // vaddpd    ymm1, ymm1, yword [rcx + 32]\n+\tLONG $0x5158edc5; BYTE $0x40               // vaddpd    ymm2, ymm2, yword [rcx + 64]\n+\tLONG $0x5958e5c5; BYTE $0x60               // vaddpd    ymm3, ymm3, yword [rcx + 96]\n+\tQUAD $0x00000080a158ddc5                   // vaddpd    ymm4, ymm4, yword [rcx + 128]\n+\tQUAD $0x000000a0a958d5c5                   // vaddpd    ymm5, ymm5, yword [rcx + 160]\n+\tQUAD $0x000000c0b158cdc5                   // vaddpd    ymm6, ymm6, yword [rcx + 192]\n+\tQUAD $0x000000e0b958c5c5                   // vaddpd    ymm7, ymm7, yword [rcx + 224]\n+\tLONG $0x00c18148; WORD $0x0008; BYTE $0x00 // add    rcx, 2048\n+\tLONG $0xff000548; WORD $0xffff             // add    rax, -256\n+\tJNE  LBB0_12\n+\n+LBB0_13:\n+\tLONG $0xcd58f5c5               // vaddpd    ymm1, ymm1, ymm5\n+\tLONG $0xdf58e5c5               // vaddpd    ymm3, ymm3, ymm7\n+\tLONG $0xc458fdc5               // vaddpd    ymm0, ymm0, ymm4\n+\tLONG $0xd658edc5               // vaddpd    ymm2, ymm2, ymm6\n+\tLONG $0xc258fdc5               // vaddpd    ymm0, ymm0, ymm2\n+\tLONG $0xcb58f5c5               // vaddpd    ymm1, ymm1, ymm3\n+\tLONG $0xc158fdc5               // vaddpd    ymm0, ymm0, ymm1\n+\tLONG $0x197de3c4; WORD $0x01c1 // vextractf128    xmm1, ymm0, 1\n+\tLONG $0xc158fdc5               // vaddpd    ymm0, ymm0, ymm1\n+\tLONG $0xc07cfdc5               // vhaddpd    ymm0, ymm0, ymm0\n+\tWORD $0x3949; BYTE $0xf1       // cmp    r9, rsi\n+\tJNE  LBB0_3\n+\tJMP  LBB0_14\ndiff --git a/go/arrow/math/float64_noasm.go b/go/arrow/math/float64_noasm.go\nnew file mode 100644\nindex 000000000..b480ad34f\n--- /dev/null\n+++ b/go/arrow/math/float64_noasm.go\n@@ -0,0 +1,25 @@\n+// Code generated by type_noasm.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build noasm\n+\n+package math\n+\n+func initFloat64Go() {\n+\tFloat64.sum = sum_float64_go\n+}\ndiff --git a/go/arrow/math/float64_sse4_amd64.go b/go/arrow/math/float64_sse4_amd64.go\nnew file mode 100644\nindex 000000000..30a79f48a\n--- /dev/null\n+++ b/go/arrow/math/float64_sse4_amd64.go\n@@ -0,0 +1,41 @@\n+// Code generated by type_simd_amd64.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package math\n+\n+import (\n+\t\"unsafe\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+)\n+\n+//go:noescape\n+func _sum_float64_sse4(buf, len, res unsafe.Pointer)\n+\n+func sum_float64_sse4(a *array.Float64) float64 {\n+\tbuf := a.Float64Values()\n+\tvar (\n+\t\tp1  = unsafe.Pointer(&buf[0])\n+\t\tp2  = unsafe.Pointer(uintptr(len(buf)))\n+\t\tres float64\n+\t)\n+\t_sum_float64_sse4(p1, p2, unsafe.Pointer(&res))\n+\treturn res\n+}\ndiff --git a/go/arrow/math/float64_sse4_amd64.s b/go/arrow/math/float64_sse4_amd64.s\nnew file mode 100644\nindex 000000000..957efa427\n--- /dev/null\n+++ b/go/arrow/math/float64_sse4_amd64.s\n@@ -0,0 +1,94 @@\n+//+build !noasm !appengine\n+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT\n+\n+TEXT \u00b7_sum_float64_sse4(SB), $0-24\n+\n+\tMOVQ buf+0(FP), DI\n+\tMOVQ len+8(FP), SI\n+\tMOVQ res+16(FP), DX\n+\n+\tLONG $0xc0570f66         // xorpd    xmm0, xmm0\n+\tWORD $0x8548; BYTE $0xf6 // test    rsi, rsi\n+\tJE   LBB0_14\n+\tLONG $0x03fe8348         // cmp    rsi, 3\n+\tJBE  LBB0_2\n+\tWORD $0x8949; BYTE $0xf1 // mov    r9, rsi\n+\tLONG $0xfce18349         // and    r9, -4\n+\tJE   LBB0_2\n+\tLONG $0xfc418d4d         // lea    r8, [r9 - 4]\n+\tWORD $0x8944; BYTE $0xc0 // mov    eax, r8d\n+\tWORD $0xe8c1; BYTE $0x02 // shr    eax, 2\n+\tWORD $0xc0ff             // inc    eax\n+\tLONG $0x03e08348         // and    rax, 3\n+\tJE   LBB0_7\n+\tWORD $0xf748; BYTE $0xd8 // neg    rax\n+\tLONG $0xc0570f66         // xorpd    xmm0, xmm0\n+\tWORD $0xc931             // xor    ecx, ecx\n+\tLONG $0xc9570f66         // xorpd    xmm1, xmm1\n+\n+LBB0_9:\n+\tLONG $0x14100f66; BYTE $0xcf   // movupd    xmm2, oword [rdi + 8*rcx]\n+\tLONG $0x5c100f66; WORD $0x10cf // movupd    xmm3, oword [rdi + 8*rcx + 16]\n+\tLONG $0xc2580f66               // addpd    xmm0, xmm2\n+\tLONG $0xcb580f66               // addpd    xmm1, xmm3\n+\tLONG $0x04c18348               // add    rcx, 4\n+\tWORD $0xff48; BYTE $0xc0       // inc    rax\n+\tJNE  LBB0_9\n+\tJMP  LBB0_10\n+\n+LBB0_2:\n+\tWORD $0x3145; BYTE $0xc9 // xor    r9d, r9d\n+\n+LBB0_3:\n+\tLONG $0xcf048d4a         // lea    rax, [rdi + 8*r9]\n+\tWORD $0x294c; BYTE $0xce // sub    rsi, r9\n+\n+LBB0_4:\n+\tLONG $0x00580ff2         // addsd    xmm0, qword [rax]\n+\tLONG $0x08c08348         // add    rax, 8\n+\tWORD $0xff48; BYTE $0xce // dec    rsi\n+\tJNE  LBB0_4\n+\n+LBB0_14:\n+\tLONG $0x02110ff2 // movsd    qword [rdx], xmm0\n+\tRET\n+\n+LBB0_7:\n+\tWORD $0xc931     // xor    ecx, ecx\n+\tLONG $0xc0570f66 // xorpd    xmm0, xmm0\n+\tLONG $0xc9570f66 // xorpd    xmm1, xmm1\n+\n+LBB0_10:\n+\tLONG $0x0cf88349             // cmp    r8, 12\n+\tJB   LBB0_13\n+\tWORD $0x894c; BYTE $0xc8     // mov    rax, r9\n+\tWORD $0x2948; BYTE $0xc8     // sub    rax, rcx\n+\tLONG $0xcf4c8d48; BYTE $0x70 // lea    rcx, [rdi + 8*rcx + 112]\n+\n+LBB0_12:\n+\tLONG $0x51100f66; BYTE $0x90 // movupd    xmm2, oword [rcx - 112]\n+\tLONG $0x59100f66; BYTE $0xa0 // movupd    xmm3, oword [rcx - 96]\n+\tLONG $0x61100f66; BYTE $0xb0 // movupd    xmm4, oword [rcx - 80]\n+\tLONG $0x69100f66; BYTE $0xc0 // movupd    xmm5, oword [rcx - 64]\n+\tLONG $0xd0580f66             // addpd    xmm2, xmm0\n+\tLONG $0xd9580f66             // addpd    xmm3, xmm1\n+\tLONG $0x71100f66; BYTE $0xd0 // movupd    xmm6, oword [rcx - 48]\n+\tLONG $0x79100f66; BYTE $0xe0 // movupd    xmm7, oword [rcx - 32]\n+\tLONG $0xf4580f66             // addpd    xmm6, xmm4\n+\tLONG $0xf2580f66             // addpd    xmm6, xmm2\n+\tLONG $0xfd580f66             // addpd    xmm7, xmm5\n+\tLONG $0xfb580f66             // addpd    xmm7, xmm3\n+\tLONG $0x41100f66; BYTE $0xf0 // movupd    xmm0, oword [rcx - 16]\n+\tLONG $0x09100f66             // movupd    xmm1, oword [rcx]\n+\tLONG $0xc6580f66             // addpd    xmm0, xmm6\n+\tLONG $0xcf580f66             // addpd    xmm1, xmm7\n+\tLONG $0x80e98348             // sub    rcx, -128\n+\tLONG $0xf0c08348             // add    rax, -16\n+\tJNE  LBB0_12\n+\n+LBB0_13:\n+\tLONG $0xc1580f66         // addpd    xmm0, xmm1\n+\tLONG $0xc07c0f66         // haddpd    xmm0, xmm0\n+\tWORD $0x3949; BYTE $0xf1 // cmp    r9, rsi\n+\tJNE  LBB0_3\n+\tJMP  LBB0_14\ndiff --git a/go/arrow/math/float64_test.go b/go/arrow/math/float64_test.go\nnew file mode 100644\nindex 000000000..ad33e0f77\n--- /dev/null\n+++ b/go/arrow/math/float64_test.go\n@@ -0,0 +1,68 @@\n+// Code generated by type_test.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package math_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+\t\"github.com/apache/arrow/go/arrow/math\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestFloat64Funcs_Sum(t *testing.T) {\n+\tvec := makeArrayFloat64(10000)\n+\tres := math.Float64.Sum(vec)\n+\tassert.Equal(t, res, float64(49995000))\n+}\n+\n+func makeArrayFloat64(l int) *array.Float64 {\n+\tfb := array.NewFloat64Builder(memory.NewGoAllocator())\n+\tfb.Reserve(l)\n+\tfor i := 0; i < l; i++ {\n+\t\tfb.Append(float64(i))\n+\t}\n+\treturn fb.NewFloat64Array()\n+}\n+\n+func benchmarkFloat64Funcs_Sum(b *testing.B, n int) {\n+\tvec := makeArrayFloat64(n)\n+\tb.SetBytes(int64(vec.Len() * 8))\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tmath.Float64.Sum(vec)\n+\t}\n+}\n+\n+func BenchmarkFloat64Funcs_Sum_256(b *testing.B) {\n+\tbenchmarkFloat64Funcs_Sum(b, 256)\n+}\n+\n+func BenchmarkFloat64Funcs_Sum_1024(b *testing.B) {\n+\tbenchmarkFloat64Funcs_Sum(b, 1024)\n+}\n+\n+func BenchmarkFloat64Funcs_Sum_8192(b *testing.B) {\n+\tbenchmarkFloat64Funcs_Sum(b, 8192)\n+}\n+\n+func BenchmarkFloat64Funcs_Sum_1000000(b *testing.B) {\n+\tbenchmarkFloat64Funcs_Sum(b, 1e6)\n+}\ndiff --git a/go/arrow/math/int64.go b/go/arrow/math/int64.go\nnew file mode 100644\nindex 000000000..4f70d2e32\n--- /dev/null\n+++ b/go/arrow/math/int64.go\n@@ -0,0 +1,44 @@\n+// Code generated by type.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package math\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+)\n+\n+type Int64Funcs struct {\n+\tsum func(a *array.Int64) int64\n+}\n+\n+var (\n+\tInt64 Int64Funcs\n+)\n+\n+// Sum returns the summation of all elements in a.\n+func (f Int64Funcs) Sum(a *array.Int64) int64 {\n+\treturn f.sum(a)\n+}\n+\n+func sum_int64_go(a *array.Int64) int64 {\n+\tacc := int64(0)\n+\tfor _, v := range a.Int64Values() {\n+\t\tacc += v\n+\t}\n+\treturn acc\n+}\ndiff --git a/go/arrow/math/int64.tmpldata b/go/arrow/math/int64.tmpldata\nnew file mode 100644\nindex 000000000..94669f9d3\n--- /dev/null\n+++ b/go/arrow/math/int64.tmpldata\n@@ -0,0 +1,4 @@\n+{\n+  \"Name\": \"Int64\",\n+  \"Type\": \"int64\"\n+}\n\\ No newline at end of file\ndiff --git a/go/arrow/math/int64_amd64.go b/go/arrow/math/int64_amd64.go\nnew file mode 100644\nindex 000000000..2703bebd0\n--- /dev/null\n+++ b/go/arrow/math/int64_amd64.go\n@@ -0,0 +1,33 @@\n+// Code generated by type_amd64.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package math\n+\n+func initInt64AVX2() {\n+\tInt64.sum = sum_int64_avx2\n+}\n+\n+func initInt64SSE4() {\n+\tInt64.sum = sum_int64_sse4\n+}\n+\n+func initInt64Go() {\n+\tInt64.sum = sum_int64_go\n+}\ndiff --git a/go/arrow/math/int64_avx2_amd64.go b/go/arrow/math/int64_avx2_amd64.go\nnew file mode 100644\nindex 000000000..55e03cd63\n--- /dev/null\n+++ b/go/arrow/math/int64_avx2_amd64.go\n@@ -0,0 +1,41 @@\n+// Code generated by type_simd_amd64.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package math\n+\n+import (\n+\t\"unsafe\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+)\n+\n+//go:noescape\n+func _sum_int64_avx2(buf, len, res unsafe.Pointer)\n+\n+func sum_int64_avx2(a *array.Int64) int64 {\n+\tbuf := a.Int64Values()\n+\tvar (\n+\t\tp1  = unsafe.Pointer(&buf[0])\n+\t\tp2  = unsafe.Pointer(uintptr(len(buf)))\n+\t\tres int64\n+\t)\n+\t_sum_int64_avx2(p1, p2, unsafe.Pointer(&res))\n+\treturn res\n+}\ndiff --git a/go/arrow/math/int64_avx2_amd64.s b/go/arrow/math/int64_avx2_amd64.s\nnew file mode 100644\nindex 000000000..10d234cc4\n--- /dev/null\n+++ b/go/arrow/math/int64_avx2_amd64.s\n@@ -0,0 +1,173 @@\n+//+build !noasm !appengine\n+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT\n+\n+TEXT \u00b7_sum_int64_avx2(SB), $0-24\n+\n+\tMOVQ buf+0(FP), DI\n+\tMOVQ len+8(FP), SI\n+\tMOVQ res+16(FP), DX\n+\n+\tWORD $0x8548; BYTE $0xf6 // test    rsi, rsi\n+\tJE   LBB0_1\n+\tLONG $0x1ffe8348         // cmp    rsi, 31\n+\tJBE  LBB0_3\n+\tWORD $0x8949; BYTE $0xf1 // mov    r9, rsi\n+\tLONG $0xe0e18349         // and    r9, -32\n+\tJE   LBB0_3\n+\tLONG $0xe0418d4d         // lea    r8, [r9 - 32]\n+\tWORD $0x8944; BYTE $0xc0 // mov    eax, r8d\n+\tWORD $0xe8c1; BYTE $0x05 // shr    eax, 5\n+\tWORD $0xc0ff             // inc    eax\n+\tLONG $0x07e08348         // and    rax, 7\n+\tJE   LBB0_8\n+\tWORD $0xf748; BYTE $0xd8 // neg    rax\n+\tLONG $0xc0effdc5         // vpxor    ymm0, ymm0, ymm0\n+\tWORD $0xc931             // xor    ecx, ecx\n+\tLONG $0xc9eff5c5         // vpxor    ymm1, ymm1, ymm1\n+\tLONG $0xd2efedc5         // vpxor    ymm2, ymm2, ymm2\n+\tLONG $0xdbefe5c5         // vpxor    ymm3, ymm3, ymm3\n+\tLONG $0xe4efddc5         // vpxor    ymm4, ymm4, ymm4\n+\tLONG $0xedefd5c5         // vpxor    ymm5, ymm5, ymm5\n+\tLONG $0xf6efcdc5         // vpxor    ymm6, ymm6, ymm6\n+\tLONG $0xffefc5c5         // vpxor    ymm7, ymm7, ymm7\n+\n+LBB0_10:\n+\tLONG $0x04d4fdc5; BYTE $0xcf         // vpaddq    ymm0, ymm0, yword [rdi + 8*rcx]\n+\tLONG $0x4cd4f5c5; WORD $0x20cf       // vpaddq    ymm1, ymm1, yword [rdi + 8*rcx + 32]\n+\tLONG $0x54d4edc5; WORD $0x40cf       // vpaddq    ymm2, ymm2, yword [rdi + 8*rcx + 64]\n+\tLONG $0x5cd4e5c5; WORD $0x60cf       // vpaddq    ymm3, ymm3, yword [rdi + 8*rcx + 96]\n+\tQUAD $0x000080cfa4d4ddc5; BYTE $0x00 // vpaddq    ymm4, ymm4, yword [rdi + 8*rcx + 128]\n+\tQUAD $0x0000a0cfacd4d5c5; BYTE $0x00 // vpaddq    ymm5, ymm5, yword [rdi + 8*rcx + 160]\n+\tQUAD $0x0000c0cfb4d4cdc5; BYTE $0x00 // vpaddq    ymm6, ymm6, yword [rdi + 8*rcx + 192]\n+\tQUAD $0x0000e0cfbcd4c5c5; BYTE $0x00 // vpaddq    ymm7, ymm7, yword [rdi + 8*rcx + 224]\n+\tLONG $0x20c18348                     // add    rcx, 32\n+\tWORD $0xff48; BYTE $0xc0             // inc    rax\n+\tJNE  LBB0_10\n+\tJMP  LBB0_11\n+\n+LBB0_3:\n+\tWORD $0x3145; BYTE $0xc9 // xor    r9d, r9d\n+\tWORD $0xc031             // xor    eax, eax\n+\n+LBB0_4:\n+\tLONG $0xcf0c8d4a         // lea    rcx, [rdi + 8*r9]\n+\tWORD $0x294c; BYTE $0xce // sub    rsi, r9\n+\n+LBB0_5:\n+\tWORD $0x0348; BYTE $0x01 // add    rax, qword [rcx]\n+\tLONG $0x08c18348         // add    rcx, 8\n+\tWORD $0xff48; BYTE $0xce // dec    rsi\n+\tJNE  LBB0_5\n+\tJMP  LBB0_15\n+\n+LBB0_1:\n+\tWORD $0xc031 // xor    eax, eax\n+\n+LBB0_15:\n+\tWORD $0x8948; BYTE $0x02 // mov    qword [rdx], rax\n+\tVZEROUPPER\n+\tRET\n+\n+LBB0_8:\n+\tWORD $0xc931     // xor    ecx, ecx\n+\tLONG $0xc0effdc5 // vpxor    ymm0, ymm0, ymm0\n+\tLONG $0xc9eff5c5 // vpxor    ymm1, ymm1, ymm1\n+\tLONG $0xd2efedc5 // vpxor    ymm2, ymm2, ymm2\n+\tLONG $0xdbefe5c5 // vpxor    ymm3, ymm3, ymm3\n+\tLONG $0xe4efddc5 // vpxor    ymm4, ymm4, ymm4\n+\tLONG $0xedefd5c5 // vpxor    ymm5, ymm5, ymm5\n+\tLONG $0xf6efcdc5 // vpxor    ymm6, ymm6, ymm6\n+\tLONG $0xffefc5c5 // vpxor    ymm7, ymm7, ymm7\n+\n+LBB0_11:\n+\tLONG $0xe0f88149; WORD $0x0000; BYTE $0x00 // cmp    r8, 224\n+\tJB   LBB0_14\n+\tWORD $0x894c; BYTE $0xc8                   // mov    rax, r9\n+\tWORD $0x2948; BYTE $0xc8                   // sub    rax, rcx\n+\tQUAD $0x00000700cf8c8d48                   // lea    rcx, [rdi + 8*rcx + 1792]\n+\n+LBB0_13:\n+\tQUAD $0xfffff9e0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 1568]\n+\tQUAD $0xfffff9c0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 1600]\n+\tQUAD $0xfffff9a0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 1632]\n+\tQUAD $0xfffff980a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 1664]\n+\tQUAD $0xfffff96099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 1696]\n+\tQUAD $0xfffff94091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 1728]\n+\tQUAD $0xfffff92089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 1760]\n+\tQUAD $0xfffff90081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1792]\n+\tQUAD $0xfffffa0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1536]\n+\tQUAD $0xfffffa2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 1504]\n+\tQUAD $0xfffffa4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 1472]\n+\tQUAD $0xfffffa6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 1440]\n+\tQUAD $0xfffffa80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 1408]\n+\tQUAD $0xfffffaa0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 1376]\n+\tQUAD $0xfffffac0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 1344]\n+\tQUAD $0xfffffae0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 1312]\n+\tQUAD $0xfffffbe0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 1056]\n+\tQUAD $0xfffffbc0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 1088]\n+\tQUAD $0xfffffba0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 1120]\n+\tQUAD $0xfffffb80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 1152]\n+\tQUAD $0xfffffb6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 1184]\n+\tQUAD $0xfffffb4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 1216]\n+\tQUAD $0xfffffb2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 1248]\n+\tQUAD $0xfffffb0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1280]\n+\tQUAD $0xfffffc0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1024]\n+\tQUAD $0xfffffc2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 992]\n+\tQUAD $0xfffffc4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 960]\n+\tQUAD $0xfffffc6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 928]\n+\tQUAD $0xfffffc80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 896]\n+\tQUAD $0xfffffca0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 864]\n+\tQUAD $0xfffffcc0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 832]\n+\tQUAD $0xfffffce0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 800]\n+\tQUAD $0xfffffde0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 544]\n+\tQUAD $0xfffffdc0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 576]\n+\tQUAD $0xfffffda0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 608]\n+\tQUAD $0xfffffd80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 640]\n+\tQUAD $0xfffffd6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 672]\n+\tQUAD $0xfffffd4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 704]\n+\tQUAD $0xfffffd2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 736]\n+\tQUAD $0xfffffd0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 768]\n+\tQUAD $0xfffffe0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 512]\n+\tQUAD $0xfffffe2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 480]\n+\tQUAD $0xfffffe4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 448]\n+\tQUAD $0xfffffe6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 416]\n+\tQUAD $0xfffffe80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 384]\n+\tQUAD $0xfffffea0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 352]\n+\tQUAD $0xfffffec0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 320]\n+\tQUAD $0xfffffee0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 288]\n+\tLONG $0x79d4c5c5; BYTE $0xe0               // vpaddq    ymm7, ymm7, yword [rcx - 32]\n+\tLONG $0x71d4cdc5; BYTE $0xc0               // vpaddq    ymm6, ymm6, yword [rcx - 64]\n+\tLONG $0x69d4d5c5; BYTE $0xa0               // vpaddq    ymm5, ymm5, yword [rcx - 96]\n+\tLONG $0x61d4ddc5; BYTE $0x80               // vpaddq    ymm4, ymm4, yword [rcx - 128]\n+\tQUAD $0xffffff6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 160]\n+\tQUAD $0xffffff4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 192]\n+\tQUAD $0xffffff2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 224]\n+\tQUAD $0xffffff0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 256]\n+\tLONG $0x01d4fdc5                           // vpaddq    ymm0, ymm0, yword [rcx]\n+\tLONG $0x49d4f5c5; BYTE $0x20               // vpaddq    ymm1, ymm1, yword [rcx + 32]\n+\tLONG $0x51d4edc5; BYTE $0x40               // vpaddq    ymm2, ymm2, yword [rcx + 64]\n+\tLONG $0x59d4e5c5; BYTE $0x60               // vpaddq    ymm3, ymm3, yword [rcx + 96]\n+\tQUAD $0x00000080a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx + 128]\n+\tQUAD $0x000000a0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx + 160]\n+\tQUAD $0x000000c0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx + 192]\n+\tQUAD $0x000000e0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx + 224]\n+\tLONG $0x00c18148; WORD $0x0008; BYTE $0x00 // add    rcx, 2048\n+\tLONG $0xff000548; WORD $0xffff             // add    rax, -256\n+\tJNE  LBB0_13\n+\n+LBB0_14:\n+\tLONG $0xcdd4f5c5               // vpaddq    ymm1, ymm1, ymm5\n+\tLONG $0xdfd4e5c5               // vpaddq    ymm3, ymm3, ymm7\n+\tLONG $0xc4d4fdc5               // vpaddq    ymm0, ymm0, ymm4\n+\tLONG $0xd6d4edc5               // vpaddq    ymm2, ymm2, ymm6\n+\tLONG $0xc2d4fdc5               // vpaddq    ymm0, ymm0, ymm2\n+\tLONG $0xcbd4f5c5               // vpaddq    ymm1, ymm1, ymm3\n+\tLONG $0xc1d4fdc5               // vpaddq    ymm0, ymm0, ymm1\n+\tLONG $0x397de3c4; WORD $0x01c1 // vextracti128    xmm1, ymm0, 1\n+\tLONG $0xc1d4fdc5               // vpaddq    ymm0, ymm0, ymm1\n+\tLONG $0xc870f9c5; BYTE $0x4e   // vpshufd    xmm1, xmm0, 78\n+\tLONG $0xc1d4fdc5               // vpaddq    ymm0, ymm0, ymm1\n+\tLONG $0x7ef9e1c4; BYTE $0xc0   // vmovq    rax, xmm0\n+\tWORD $0x3949; BYTE $0xf1       // cmp    r9, rsi\n+\tJNE  LBB0_4\n+\tJMP  LBB0_15\ndiff --git a/go/arrow/math/int64_noasm.go b/go/arrow/math/int64_noasm.go\nnew file mode 100644\nindex 000000000..5a5efc31b\n--- /dev/null\n+++ b/go/arrow/math/int64_noasm.go\n@@ -0,0 +1,25 @@\n+// Code generated by type_noasm.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build noasm\n+\n+package math\n+\n+func initInt64Go() {\n+\tInt64.sum = sum_int64_go\n+}\ndiff --git a/go/arrow/math/int64_sse4_amd64.go b/go/arrow/math/int64_sse4_amd64.go\nnew file mode 100644\nindex 000000000..c13c8de14\n--- /dev/null\n+++ b/go/arrow/math/int64_sse4_amd64.go\n@@ -0,0 +1,41 @@\n+// Code generated by type_simd_amd64.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package math\n+\n+import (\n+\t\"unsafe\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+)\n+\n+//go:noescape\n+func _sum_int64_sse4(buf, len, res unsafe.Pointer)\n+\n+func sum_int64_sse4(a *array.Int64) int64 {\n+\tbuf := a.Int64Values()\n+\tvar (\n+\t\tp1  = unsafe.Pointer(&buf[0])\n+\t\tp2  = unsafe.Pointer(uintptr(len(buf)))\n+\t\tres int64\n+\t)\n+\t_sum_int64_sse4(p1, p2, unsafe.Pointer(&res))\n+\treturn res\n+}\ndiff --git a/go/arrow/math/int64_sse4_amd64.s b/go/arrow/math/int64_sse4_amd64.s\nnew file mode 100644\nindex 000000000..ef27eee16\n--- /dev/null\n+++ b/go/arrow/math/int64_sse4_amd64.s\n@@ -0,0 +1,100 @@\n+//+build !noasm !appengine\n+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT\n+\n+TEXT \u00b7_sum_int64_sse4(SB), $0-24\n+\n+\tMOVQ buf+0(FP), DI\n+\tMOVQ len+8(FP), SI\n+\tMOVQ res+16(FP), DX\n+\n+\tWORD $0x8548; BYTE $0xf6 // test    rsi, rsi\n+\tJE   LBB0_1\n+\tLONG $0x03fe8348         // cmp    rsi, 3\n+\tJBE  LBB0_3\n+\tWORD $0x8949; BYTE $0xf1 // mov    r9, rsi\n+\tLONG $0xfce18349         // and    r9, -4\n+\tJE   LBB0_3\n+\tLONG $0xfc418d4d         // lea    r8, [r9 - 4]\n+\tWORD $0x8944; BYTE $0xc0 // mov    eax, r8d\n+\tWORD $0xe8c1; BYTE $0x02 // shr    eax, 2\n+\tWORD $0xc0ff             // inc    eax\n+\tLONG $0x03e08348         // and    rax, 3\n+\tJE   LBB0_8\n+\tWORD $0xf748; BYTE $0xd8 // neg    rax\n+\tLONG $0xc0ef0f66         // pxor    xmm0, xmm0\n+\tWORD $0xc931             // xor    ecx, ecx\n+\tLONG $0xc9ef0f66         // pxor    xmm1, xmm1\n+\n+LBB0_10:\n+\tLONG $0x146f0ff3; BYTE $0xcf   // movdqu    xmm2, oword [rdi + 8*rcx]\n+\tLONG $0x5c6f0ff3; WORD $0x10cf // movdqu    xmm3, oword [rdi + 8*rcx + 16]\n+\tLONG $0xc2d40f66               // paddq    xmm0, xmm2\n+\tLONG $0xcbd40f66               // paddq    xmm1, xmm3\n+\tLONG $0x04c18348               // add    rcx, 4\n+\tWORD $0xff48; BYTE $0xc0       // inc    rax\n+\tJNE  LBB0_10\n+\tJMP  LBB0_11\n+\n+LBB0_3:\n+\tWORD $0x3145; BYTE $0xc9 // xor    r9d, r9d\n+\tWORD $0xc031             // xor    eax, eax\n+\n+LBB0_4:\n+\tLONG $0xcf0c8d4a         // lea    rcx, [rdi + 8*r9]\n+\tWORD $0x294c; BYTE $0xce // sub    rsi, r9\n+\n+LBB0_5:\n+\tWORD $0x0348; BYTE $0x01 // add    rax, qword [rcx]\n+\tLONG $0x08c18348         // add    rcx, 8\n+\tWORD $0xff48; BYTE $0xce // dec    rsi\n+\tJNE  LBB0_5\n+\tJMP  LBB0_15\n+\n+LBB0_1:\n+\tWORD $0xc031 // xor    eax, eax\n+\n+LBB0_15:\n+\tWORD $0x8948; BYTE $0x02 // mov    qword [rdx], rax\n+\tRET\n+\n+LBB0_8:\n+\tWORD $0xc931     // xor    ecx, ecx\n+\tLONG $0xc0ef0f66 // pxor    xmm0, xmm0\n+\tLONG $0xc9ef0f66 // pxor    xmm1, xmm1\n+\n+LBB0_11:\n+\tLONG $0x0cf88349             // cmp    r8, 12\n+\tJB   LBB0_14\n+\tWORD $0x894c; BYTE $0xc8     // mov    rax, r9\n+\tWORD $0x2948; BYTE $0xc8     // sub    rax, rcx\n+\tLONG $0xcf4c8d48; BYTE $0x70 // lea    rcx, [rdi + 8*rcx + 112]\n+\n+LBB0_13:\n+\tLONG $0x516f0ff3; BYTE $0x90 // movdqu    xmm2, oword [rcx - 112]\n+\tLONG $0x596f0ff3; BYTE $0xa0 // movdqu    xmm3, oword [rcx - 96]\n+\tLONG $0x616f0ff3; BYTE $0xb0 // movdqu    xmm4, oword [rcx - 80]\n+\tLONG $0x696f0ff3; BYTE $0xc0 // movdqu    xmm5, oword [rcx - 64]\n+\tLONG $0xd0d40f66             // paddq    xmm2, xmm0\n+\tLONG $0xd9d40f66             // paddq    xmm3, xmm1\n+\tLONG $0x716f0ff3; BYTE $0xd0 // movdqu    xmm6, oword [rcx - 48]\n+\tLONG $0x796f0ff3; BYTE $0xe0 // movdqu    xmm7, oword [rcx - 32]\n+\tLONG $0xf4d40f66             // paddq    xmm6, xmm4\n+\tLONG $0xf2d40f66             // paddq    xmm6, xmm2\n+\tLONG $0xfdd40f66             // paddq    xmm7, xmm5\n+\tLONG $0xfbd40f66             // paddq    xmm7, xmm3\n+\tLONG $0x416f0ff3; BYTE $0xf0 // movdqu    xmm0, oword [rcx - 16]\n+\tLONG $0x096f0ff3             // movdqu    xmm1, oword [rcx]\n+\tLONG $0xc6d40f66             // paddq    xmm0, xmm6\n+\tLONG $0xcfd40f66             // paddq    xmm1, xmm7\n+\tLONG $0x80e98348             // sub    rcx, -128\n+\tLONG $0xf0c08348             // add    rax, -16\n+\tJNE  LBB0_13\n+\n+LBB0_14:\n+\tLONG $0xc1d40f66             // paddq    xmm0, xmm1\n+\tLONG $0xc8700f66; BYTE $0x4e // pshufd    xmm1, xmm0, 78\n+\tLONG $0xc8d40f66             // paddq    xmm1, xmm0\n+\tLONG $0x7e0f4866; BYTE $0xc8 // movq    rax, xmm1\n+\tWORD $0x3949; BYTE $0xf1     // cmp    r9, rsi\n+\tJNE  LBB0_4\n+\tJMP  LBB0_15\ndiff --git a/go/arrow/math/int64_test.go b/go/arrow/math/int64_test.go\nnew file mode 100644\nindex 000000000..19722828e\n--- /dev/null\n+++ b/go/arrow/math/int64_test.go\n@@ -0,0 +1,68 @@\n+// Code generated by type_test.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package math_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+\t\"github.com/apache/arrow/go/arrow/math\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestInt64Funcs_Sum(t *testing.T) {\n+\tvec := makeArrayInt64(10000)\n+\tres := math.Int64.Sum(vec)\n+\tassert.Equal(t, res, int64(49995000))\n+}\n+\n+func makeArrayInt64(l int) *array.Int64 {\n+\tfb := array.NewInt64Builder(memory.NewGoAllocator())\n+\tfb.Reserve(l)\n+\tfor i := 0; i < l; i++ {\n+\t\tfb.Append(int64(i))\n+\t}\n+\treturn fb.NewInt64Array()\n+}\n+\n+func benchmarkInt64Funcs_Sum(b *testing.B, n int) {\n+\tvec := makeArrayInt64(n)\n+\tb.SetBytes(int64(vec.Len() * 8))\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tmath.Int64.Sum(vec)\n+\t}\n+}\n+\n+func BenchmarkInt64Funcs_Sum_256(b *testing.B) {\n+\tbenchmarkInt64Funcs_Sum(b, 256)\n+}\n+\n+func BenchmarkInt64Funcs_Sum_1024(b *testing.B) {\n+\tbenchmarkInt64Funcs_Sum(b, 1024)\n+}\n+\n+func BenchmarkInt64Funcs_Sum_8192(b *testing.B) {\n+\tbenchmarkInt64Funcs_Sum(b, 8192)\n+}\n+\n+func BenchmarkInt64Funcs_Sum_1000000(b *testing.B) {\n+\tbenchmarkInt64Funcs_Sum(b, 1e6)\n+}\ndiff --git a/go/arrow/math/math_amd64.go b/go/arrow/math/math_amd64.go\nnew file mode 100644\nindex 000000000..73789de6d\n--- /dev/null\n+++ b/go/arrow/math/math_amd64.go\n@@ -0,0 +1,51 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package math\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow/internal/cpu\"\n+)\n+\n+func init() {\n+\tif cpu.X86.HasAVX2 {\n+\t\tinitAVX2()\n+\t} else if cpu.X86.HasSSE42 {\n+\t\tinitSSE4()\n+\t} else {\n+\t\tinitGo()\n+\t}\n+}\n+\n+func initAVX2() {\n+\tinitFloat64AVX2()\n+\tinitInt64AVX2()\n+\tinitUint64AVX2()\n+}\n+\n+func initSSE4() {\n+\tinitFloat64SSE4()\n+\tinitInt64SSE4()\n+\tinitUint64SSE4()\n+}\n+\n+func initGo() {\n+\tinitFloat64Go()\n+\tinitInt64Go()\n+\tinitUint64Go()\n+}\ndiff --git a/go/arrow/math/math_noasm.go b/go/arrow/math/math_noasm.go\nnew file mode 100644\nindex 000000000..0fa924d90\n--- /dev/null\n+++ b/go/arrow/math/math_noasm.go\n@@ -0,0 +1,29 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build noasm\n+\n+package math\n+\n+func init() {\n+\tinitGo()\n+}\n+\n+func initGo() {\n+\tinitFloat64Go()\n+\tinitInt64Go()\n+\tinitUint64Go()\n+}\ndiff --git a/go/arrow/math/type.go.tmpl b/go/arrow/math/type.go.tmpl\nnew file mode 100644\nindex 000000000..1b2dd6966\n--- /dev/null\n+++ b/go/arrow/math/type.go.tmpl\n@@ -0,0 +1,45 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package math\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+)\n+\n+{{$def := .D}}\n+{{with .In}}\n+type {{.Name}}Funcs struct {\n+\tsum func(a *array.{{.Name}}) {{.Type}}\n+}\n+\n+var (\n+\t{{.Name}} {{.Name}}Funcs\n+)\n+\n+// Sum returns the summation of all elements in a.\n+func (f {{.Name}}Funcs) Sum(a *array.{{.Name}}) {{.Type}} {\n+\treturn f.sum(a)\n+}\n+\n+func sum_{{.Type}}_go(a *array.{{.Name}}) {{.Type}} {\n+\tacc := {{.Type}}(0)\n+\tfor _, v := range a.{{.Name}}Values() {\n+\t\tacc += v\n+\t}\n+\treturn acc\n+}\n+{{end}}\n\\ No newline at end of file\ndiff --git a/go/arrow/math/type_amd64.go.tmpl b/go/arrow/math/type_amd64.go.tmpl\nnew file mode 100644\nindex 000000000..c3c27498b\n--- /dev/null\n+++ b/go/arrow/math/type_amd64.go.tmpl\n@@ -0,0 +1,33 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package math\n+\n+{{with .In}}\n+func init{{.Name}}AVX2() {\n+\t{{.Name}}.sum = sum_{{.Type}}_avx2\n+}\n+\n+func init{{.Name}}SSE4() {\n+\t{{.Name}}.sum = sum_{{.Type}}_sse4\n+}\n+\n+func init{{.Name}}Go() {\n+\t{{.Name}}.sum = sum_{{.Type}}_go\n+}\n+{{end}}\n\\ No newline at end of file\ndiff --git a/go/arrow/math/type_noasm.go.tmpl b/go/arrow/math/type_noasm.go.tmpl\nnew file mode 100644\nindex 000000000..66802f0fe\n--- /dev/null\n+++ b/go/arrow/math/type_noasm.go.tmpl\n@@ -0,0 +1,25 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build noasm\n+\n+package math\n+\n+{{with .In}}\n+func init{{.Name}}Go() {\n+\t{{.Name}}.sum = sum_{{.Type}}_go\n+}\n+{{end}}\n\\ No newline at end of file\ndiff --git a/go/arrow/math/type_simd_amd64.go.tmpl b/go/arrow/math/type_simd_amd64.go.tmpl\nnew file mode 100644\nindex 000000000..b572290cc\n--- /dev/null\n+++ b/go/arrow/math/type_simd_amd64.go.tmpl\n@@ -0,0 +1,42 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package math\n+\n+import (\n+\t\"unsafe\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+)\n+\n+{{$name := printf \"%s_%s\" .In.Type .D.arch}}\n+{{with .In}}\n+//go:noescape\n+func _sum_{{$name}}(buf, len, res unsafe.Pointer)\n+\n+func sum_{{$name}}(a *array.{{.Name}}) {{.Type}} {\n+\tbuf := a.{{.Name}}Values()\n+\tvar (\n+\t\tp1  = unsafe.Pointer(&buf[0])\n+\t\tp2  = unsafe.Pointer(uintptr(len(buf)))\n+\t\tres {{.Type}}\n+\t)\n+\t_sum_{{$name}}(p1, p2, unsafe.Pointer(&res))\n+\treturn res\n+}\n+{{end}}\n\\ No newline at end of file\ndiff --git a/go/arrow/math/type_test.go.tmpl b/go/arrow/math/type_test.go.tmpl\nnew file mode 100644\nindex 000000000..f1b744ca4\n--- /dev/null\n+++ b/go/arrow/math/type_test.go.tmpl\n@@ -0,0 +1,69 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package math_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+\t\"github.com/apache/arrow/go/arrow/math\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+{{$name := printf \"%s_%s\" .In.Type .D.arch}}\n+{{with .In}}\n+func Test{{.Name}}Funcs_Sum(t *testing.T) {\n+\tvec := makeArray{{.Name}}(10000)\n+\tres := math.{{.Name}}.Sum(vec)\n+\tassert.Equal(t, res, {{.Type}}(49995000))\n+}\n+\n+func makeArray{{.Name}}(l int) *array.{{.Name}} {\n+\tfb := array.New{{.Name}}Builder(memory.NewGoAllocator())\n+\tfb.Reserve(l)\n+\tfor i := 0; i < l; i++ {\n+\t\tfb.Append({{.Type}}(i))\n+\t}\n+\treturn fb.New{{.Name}}Array()\n+}\n+\n+func benchmark{{.Name}}Funcs_Sum(b *testing.B, n int) {\n+\tvec := makeArray{{.Name}}(n)\n+\tb.SetBytes(int64(vec.Len() * 8))\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tmath.{{.Name}}.Sum(vec)\n+\t}\n+}\n+\n+func Benchmark{{.Name}}Funcs_Sum_256(b *testing.B) {\n+\tbenchmark{{.Name}}Funcs_Sum(b, 256)\n+}\n+\n+func Benchmark{{.Name}}Funcs_Sum_1024(b *testing.B) {\n+\tbenchmark{{.Name}}Funcs_Sum(b, 1024)\n+}\n+\n+func Benchmark{{.Name}}Funcs_Sum_8192(b *testing.B) {\n+\tbenchmark{{.Name}}Funcs_Sum(b, 8192)\n+}\n+\n+func Benchmark{{.Name}}Funcs_Sum_1000000(b *testing.B) {\n+\tbenchmark{{.Name}}Funcs_Sum(b, 1e6)\n+}\n+{{end}}\n\\ No newline at end of file\ndiff --git a/go/arrow/math/uint64.go b/go/arrow/math/uint64.go\nnew file mode 100644\nindex 000000000..875e82143\n--- /dev/null\n+++ b/go/arrow/math/uint64.go\n@@ -0,0 +1,44 @@\n+// Code generated by type.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package math\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+)\n+\n+type Uint64Funcs struct {\n+\tsum func(a *array.Uint64) uint64\n+}\n+\n+var (\n+\tUint64 Uint64Funcs\n+)\n+\n+// Sum returns the summation of all elements in a.\n+func (f Uint64Funcs) Sum(a *array.Uint64) uint64 {\n+\treturn f.sum(a)\n+}\n+\n+func sum_uint64_go(a *array.Uint64) uint64 {\n+\tacc := uint64(0)\n+\tfor _, v := range a.Uint64Values() {\n+\t\tacc += v\n+\t}\n+\treturn acc\n+}\ndiff --git a/go/arrow/math/uint64.tmpldata b/go/arrow/math/uint64.tmpldata\nnew file mode 100644\nindex 000000000..22165eb1d\n--- /dev/null\n+++ b/go/arrow/math/uint64.tmpldata\n@@ -0,0 +1,4 @@\n+{\n+  \"Name\": \"Uint64\",\n+  \"Type\": \"uint64\"\n+}\n\\ No newline at end of file\ndiff --git a/go/arrow/math/uint64_amd64.go b/go/arrow/math/uint64_amd64.go\nnew file mode 100644\nindex 000000000..c6bc29c4e\n--- /dev/null\n+++ b/go/arrow/math/uint64_amd64.go\n@@ -0,0 +1,33 @@\n+// Code generated by type_amd64.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package math\n+\n+func initUint64AVX2() {\n+\tUint64.sum = sum_uint64_avx2\n+}\n+\n+func initUint64SSE4() {\n+\tUint64.sum = sum_uint64_sse4\n+}\n+\n+func initUint64Go() {\n+\tUint64.sum = sum_uint64_go\n+}\ndiff --git a/go/arrow/math/uint64_avx2_amd64.go b/go/arrow/math/uint64_avx2_amd64.go\nnew file mode 100644\nindex 000000000..ff0500e7c\n--- /dev/null\n+++ b/go/arrow/math/uint64_avx2_amd64.go\n@@ -0,0 +1,41 @@\n+// Code generated by type_simd_amd64.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package math\n+\n+import (\n+\t\"unsafe\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+)\n+\n+//go:noescape\n+func _sum_uint64_avx2(buf, len, res unsafe.Pointer)\n+\n+func sum_uint64_avx2(a *array.Uint64) uint64 {\n+\tbuf := a.Uint64Values()\n+\tvar (\n+\t\tp1  = unsafe.Pointer(&buf[0])\n+\t\tp2  = unsafe.Pointer(uintptr(len(buf)))\n+\t\tres uint64\n+\t)\n+\t_sum_uint64_avx2(p1, p2, unsafe.Pointer(&res))\n+\treturn res\n+}\ndiff --git a/go/arrow/math/uint64_avx2_amd64.s b/go/arrow/math/uint64_avx2_amd64.s\nnew file mode 100644\nindex 000000000..7edfd476a\n--- /dev/null\n+++ b/go/arrow/math/uint64_avx2_amd64.s\n@@ -0,0 +1,173 @@\n+//+build !noasm !appengine\n+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT\n+\n+TEXT \u00b7_sum_uint64_avx2(SB), $0-24\n+\n+\tMOVQ buf+0(FP), DI\n+\tMOVQ len+8(FP), SI\n+\tMOVQ res+16(FP), DX\n+\n+\tWORD $0x8548; BYTE $0xf6 // test    rsi, rsi\n+\tJE   LBB0_1\n+\tLONG $0x1ffe8348         // cmp    rsi, 31\n+\tJBE  LBB0_3\n+\tWORD $0x8949; BYTE $0xf1 // mov    r9, rsi\n+\tLONG $0xe0e18349         // and    r9, -32\n+\tJE   LBB0_3\n+\tLONG $0xe0418d4d         // lea    r8, [r9 - 32]\n+\tWORD $0x8944; BYTE $0xc0 // mov    eax, r8d\n+\tWORD $0xe8c1; BYTE $0x05 // shr    eax, 5\n+\tWORD $0xc0ff             // inc    eax\n+\tLONG $0x07e08348         // and    rax, 7\n+\tJE   LBB0_8\n+\tWORD $0xf748; BYTE $0xd8 // neg    rax\n+\tLONG $0xc0effdc5         // vpxor    ymm0, ymm0, ymm0\n+\tWORD $0xc931             // xor    ecx, ecx\n+\tLONG $0xc9eff5c5         // vpxor    ymm1, ymm1, ymm1\n+\tLONG $0xd2efedc5         // vpxor    ymm2, ymm2, ymm2\n+\tLONG $0xdbefe5c5         // vpxor    ymm3, ymm3, ymm3\n+\tLONG $0xe4efddc5         // vpxor    ymm4, ymm4, ymm4\n+\tLONG $0xedefd5c5         // vpxor    ymm5, ymm5, ymm5\n+\tLONG $0xf6efcdc5         // vpxor    ymm6, ymm6, ymm6\n+\tLONG $0xffefc5c5         // vpxor    ymm7, ymm7, ymm7\n+\n+LBB0_10:\n+\tLONG $0x04d4fdc5; BYTE $0xcf         // vpaddq    ymm0, ymm0, yword [rdi + 8*rcx]\n+\tLONG $0x4cd4f5c5; WORD $0x20cf       // vpaddq    ymm1, ymm1, yword [rdi + 8*rcx + 32]\n+\tLONG $0x54d4edc5; WORD $0x40cf       // vpaddq    ymm2, ymm2, yword [rdi + 8*rcx + 64]\n+\tLONG $0x5cd4e5c5; WORD $0x60cf       // vpaddq    ymm3, ymm3, yword [rdi + 8*rcx + 96]\n+\tQUAD $0x000080cfa4d4ddc5; BYTE $0x00 // vpaddq    ymm4, ymm4, yword [rdi + 8*rcx + 128]\n+\tQUAD $0x0000a0cfacd4d5c5; BYTE $0x00 // vpaddq    ymm5, ymm5, yword [rdi + 8*rcx + 160]\n+\tQUAD $0x0000c0cfb4d4cdc5; BYTE $0x00 // vpaddq    ymm6, ymm6, yword [rdi + 8*rcx + 192]\n+\tQUAD $0x0000e0cfbcd4c5c5; BYTE $0x00 // vpaddq    ymm7, ymm7, yword [rdi + 8*rcx + 224]\n+\tLONG $0x20c18348                     // add    rcx, 32\n+\tWORD $0xff48; BYTE $0xc0             // inc    rax\n+\tJNE  LBB0_10\n+\tJMP  LBB0_11\n+\n+LBB0_3:\n+\tWORD $0x3145; BYTE $0xc9 // xor    r9d, r9d\n+\tWORD $0xc031             // xor    eax, eax\n+\n+LBB0_4:\n+\tLONG $0xcf0c8d4a         // lea    rcx, [rdi + 8*r9]\n+\tWORD $0x294c; BYTE $0xce // sub    rsi, r9\n+\n+LBB0_5:\n+\tWORD $0x0348; BYTE $0x01 // add    rax, qword [rcx]\n+\tLONG $0x08c18348         // add    rcx, 8\n+\tWORD $0xff48; BYTE $0xce // dec    rsi\n+\tJNE  LBB0_5\n+\tJMP  LBB0_15\n+\n+LBB0_1:\n+\tWORD $0xc031 // xor    eax, eax\n+\n+LBB0_15:\n+\tWORD $0x8948; BYTE $0x02 // mov    qword [rdx], rax\n+\tVZEROUPPER\n+\tRET\n+\n+LBB0_8:\n+\tWORD $0xc931     // xor    ecx, ecx\n+\tLONG $0xc0effdc5 // vpxor    ymm0, ymm0, ymm0\n+\tLONG $0xc9eff5c5 // vpxor    ymm1, ymm1, ymm1\n+\tLONG $0xd2efedc5 // vpxor    ymm2, ymm2, ymm2\n+\tLONG $0xdbefe5c5 // vpxor    ymm3, ymm3, ymm3\n+\tLONG $0xe4efddc5 // vpxor    ymm4, ymm4, ymm4\n+\tLONG $0xedefd5c5 // vpxor    ymm5, ymm5, ymm5\n+\tLONG $0xf6efcdc5 // vpxor    ymm6, ymm6, ymm6\n+\tLONG $0xffefc5c5 // vpxor    ymm7, ymm7, ymm7\n+\n+LBB0_11:\n+\tLONG $0xe0f88149; WORD $0x0000; BYTE $0x00 // cmp    r8, 224\n+\tJB   LBB0_14\n+\tWORD $0x894c; BYTE $0xc8                   // mov    rax, r9\n+\tWORD $0x2948; BYTE $0xc8                   // sub    rax, rcx\n+\tQUAD $0x00000700cf8c8d48                   // lea    rcx, [rdi + 8*rcx + 1792]\n+\n+LBB0_13:\n+\tQUAD $0xfffff9e0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 1568]\n+\tQUAD $0xfffff9c0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 1600]\n+\tQUAD $0xfffff9a0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 1632]\n+\tQUAD $0xfffff980a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 1664]\n+\tQUAD $0xfffff96099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 1696]\n+\tQUAD $0xfffff94091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 1728]\n+\tQUAD $0xfffff92089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 1760]\n+\tQUAD $0xfffff90081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1792]\n+\tQUAD $0xfffffa0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1536]\n+\tQUAD $0xfffffa2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 1504]\n+\tQUAD $0xfffffa4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 1472]\n+\tQUAD $0xfffffa6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 1440]\n+\tQUAD $0xfffffa80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 1408]\n+\tQUAD $0xfffffaa0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 1376]\n+\tQUAD $0xfffffac0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 1344]\n+\tQUAD $0xfffffae0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 1312]\n+\tQUAD $0xfffffbe0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 1056]\n+\tQUAD $0xfffffbc0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 1088]\n+\tQUAD $0xfffffba0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 1120]\n+\tQUAD $0xfffffb80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 1152]\n+\tQUAD $0xfffffb6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 1184]\n+\tQUAD $0xfffffb4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 1216]\n+\tQUAD $0xfffffb2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 1248]\n+\tQUAD $0xfffffb0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1280]\n+\tQUAD $0xfffffc0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 1024]\n+\tQUAD $0xfffffc2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 992]\n+\tQUAD $0xfffffc4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 960]\n+\tQUAD $0xfffffc6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 928]\n+\tQUAD $0xfffffc80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 896]\n+\tQUAD $0xfffffca0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 864]\n+\tQUAD $0xfffffcc0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 832]\n+\tQUAD $0xfffffce0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 800]\n+\tQUAD $0xfffffde0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 544]\n+\tQUAD $0xfffffdc0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 576]\n+\tQUAD $0xfffffda0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 608]\n+\tQUAD $0xfffffd80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 640]\n+\tQUAD $0xfffffd6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 672]\n+\tQUAD $0xfffffd4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 704]\n+\tQUAD $0xfffffd2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 736]\n+\tQUAD $0xfffffd0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 768]\n+\tQUAD $0xfffffe0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 512]\n+\tQUAD $0xfffffe2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 480]\n+\tQUAD $0xfffffe4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 448]\n+\tQUAD $0xfffffe6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 416]\n+\tQUAD $0xfffffe80a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx - 384]\n+\tQUAD $0xfffffea0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx - 352]\n+\tQUAD $0xfffffec0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx - 320]\n+\tQUAD $0xfffffee0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx - 288]\n+\tLONG $0x79d4c5c5; BYTE $0xe0               // vpaddq    ymm7, ymm7, yword [rcx - 32]\n+\tLONG $0x71d4cdc5; BYTE $0xc0               // vpaddq    ymm6, ymm6, yword [rcx - 64]\n+\tLONG $0x69d4d5c5; BYTE $0xa0               // vpaddq    ymm5, ymm5, yword [rcx - 96]\n+\tLONG $0x61d4ddc5; BYTE $0x80               // vpaddq    ymm4, ymm4, yword [rcx - 128]\n+\tQUAD $0xffffff6099d4e5c5                   // vpaddq    ymm3, ymm3, yword [rcx - 160]\n+\tQUAD $0xffffff4091d4edc5                   // vpaddq    ymm2, ymm2, yword [rcx - 192]\n+\tQUAD $0xffffff2089d4f5c5                   // vpaddq    ymm1, ymm1, yword [rcx - 224]\n+\tQUAD $0xffffff0081d4fdc5                   // vpaddq    ymm0, ymm0, yword [rcx - 256]\n+\tLONG $0x01d4fdc5                           // vpaddq    ymm0, ymm0, yword [rcx]\n+\tLONG $0x49d4f5c5; BYTE $0x20               // vpaddq    ymm1, ymm1, yword [rcx + 32]\n+\tLONG $0x51d4edc5; BYTE $0x40               // vpaddq    ymm2, ymm2, yword [rcx + 64]\n+\tLONG $0x59d4e5c5; BYTE $0x60               // vpaddq    ymm3, ymm3, yword [rcx + 96]\n+\tQUAD $0x00000080a1d4ddc5                   // vpaddq    ymm4, ymm4, yword [rcx + 128]\n+\tQUAD $0x000000a0a9d4d5c5                   // vpaddq    ymm5, ymm5, yword [rcx + 160]\n+\tQUAD $0x000000c0b1d4cdc5                   // vpaddq    ymm6, ymm6, yword [rcx + 192]\n+\tQUAD $0x000000e0b9d4c5c5                   // vpaddq    ymm7, ymm7, yword [rcx + 224]\n+\tLONG $0x00c18148; WORD $0x0008; BYTE $0x00 // add    rcx, 2048\n+\tLONG $0xff000548; WORD $0xffff             // add    rax, -256\n+\tJNE  LBB0_13\n+\n+LBB0_14:\n+\tLONG $0xcdd4f5c5               // vpaddq    ymm1, ymm1, ymm5\n+\tLONG $0xdfd4e5c5               // vpaddq    ymm3, ymm3, ymm7\n+\tLONG $0xc4d4fdc5               // vpaddq    ymm0, ymm0, ymm4\n+\tLONG $0xd6d4edc5               // vpaddq    ymm2, ymm2, ymm6\n+\tLONG $0xc2d4fdc5               // vpaddq    ymm0, ymm0, ymm2\n+\tLONG $0xcbd4f5c5               // vpaddq    ymm1, ymm1, ymm3\n+\tLONG $0xc1d4fdc5               // vpaddq    ymm0, ymm0, ymm1\n+\tLONG $0x397de3c4; WORD $0x01c1 // vextracti128    xmm1, ymm0, 1\n+\tLONG $0xc1d4fdc5               // vpaddq    ymm0, ymm0, ymm1\n+\tLONG $0xc870f9c5; BYTE $0x4e   // vpshufd    xmm1, xmm0, 78\n+\tLONG $0xc1d4fdc5               // vpaddq    ymm0, ymm0, ymm1\n+\tLONG $0x7ef9e1c4; BYTE $0xc0   // vmovq    rax, xmm0\n+\tWORD $0x3949; BYTE $0xf1       // cmp    r9, rsi\n+\tJNE  LBB0_4\n+\tJMP  LBB0_15\ndiff --git a/go/arrow/math/uint64_noasm.go b/go/arrow/math/uint64_noasm.go\nnew file mode 100644\nindex 000000000..b7174b3d7\n--- /dev/null\n+++ b/go/arrow/math/uint64_noasm.go\n@@ -0,0 +1,25 @@\n+// Code generated by type_noasm.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build noasm\n+\n+package math\n+\n+func initUint64Go() {\n+\tUint64.sum = sum_uint64_go\n+}\ndiff --git a/go/arrow/math/uint64_sse4_amd64.go b/go/arrow/math/uint64_sse4_amd64.go\nnew file mode 100644\nindex 000000000..428bbe69f\n--- /dev/null\n+++ b/go/arrow/math/uint64_sse4_amd64.go\n@@ -0,0 +1,41 @@\n+// Code generated by type_simd_amd64.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package math\n+\n+import (\n+\t\"unsafe\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+)\n+\n+//go:noescape\n+func _sum_uint64_sse4(buf, len, res unsafe.Pointer)\n+\n+func sum_uint64_sse4(a *array.Uint64) uint64 {\n+\tbuf := a.Uint64Values()\n+\tvar (\n+\t\tp1  = unsafe.Pointer(&buf[0])\n+\t\tp2  = unsafe.Pointer(uintptr(len(buf)))\n+\t\tres uint64\n+\t)\n+\t_sum_uint64_sse4(p1, p2, unsafe.Pointer(&res))\n+\treturn res\n+}\ndiff --git a/go/arrow/math/uint64_sse4_amd64.s b/go/arrow/math/uint64_sse4_amd64.s\nnew file mode 100644\nindex 000000000..1af9cfeb5\n--- /dev/null\n+++ b/go/arrow/math/uint64_sse4_amd64.s\n@@ -0,0 +1,100 @@\n+//+build !noasm !appengine\n+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT\n+\n+TEXT \u00b7_sum_uint64_sse4(SB), $0-24\n+\n+\tMOVQ buf+0(FP), DI\n+\tMOVQ len+8(FP), SI\n+\tMOVQ res+16(FP), DX\n+\n+\tWORD $0x8548; BYTE $0xf6 // test    rsi, rsi\n+\tJE   LBB0_1\n+\tLONG $0x03fe8348         // cmp    rsi, 3\n+\tJBE  LBB0_3\n+\tWORD $0x8949; BYTE $0xf1 // mov    r9, rsi\n+\tLONG $0xfce18349         // and    r9, -4\n+\tJE   LBB0_3\n+\tLONG $0xfc418d4d         // lea    r8, [r9 - 4]\n+\tWORD $0x8944; BYTE $0xc0 // mov    eax, r8d\n+\tWORD $0xe8c1; BYTE $0x02 // shr    eax, 2\n+\tWORD $0xc0ff             // inc    eax\n+\tLONG $0x03e08348         // and    rax, 3\n+\tJE   LBB0_8\n+\tWORD $0xf748; BYTE $0xd8 // neg    rax\n+\tLONG $0xc0ef0f66         // pxor    xmm0, xmm0\n+\tWORD $0xc931             // xor    ecx, ecx\n+\tLONG $0xc9ef0f66         // pxor    xmm1, xmm1\n+\n+LBB0_10:\n+\tLONG $0x146f0ff3; BYTE $0xcf   // movdqu    xmm2, oword [rdi + 8*rcx]\n+\tLONG $0x5c6f0ff3; WORD $0x10cf // movdqu    xmm3, oword [rdi + 8*rcx + 16]\n+\tLONG $0xc2d40f66               // paddq    xmm0, xmm2\n+\tLONG $0xcbd40f66               // paddq    xmm1, xmm3\n+\tLONG $0x04c18348               // add    rcx, 4\n+\tWORD $0xff48; BYTE $0xc0       // inc    rax\n+\tJNE  LBB0_10\n+\tJMP  LBB0_11\n+\n+LBB0_3:\n+\tWORD $0x3145; BYTE $0xc9 // xor    r9d, r9d\n+\tWORD $0xc031             // xor    eax, eax\n+\n+LBB0_4:\n+\tLONG $0xcf0c8d4a         // lea    rcx, [rdi + 8*r9]\n+\tWORD $0x294c; BYTE $0xce // sub    rsi, r9\n+\n+LBB0_5:\n+\tWORD $0x0348; BYTE $0x01 // add    rax, qword [rcx]\n+\tLONG $0x08c18348         // add    rcx, 8\n+\tWORD $0xff48; BYTE $0xce // dec    rsi\n+\tJNE  LBB0_5\n+\tJMP  LBB0_15\n+\n+LBB0_1:\n+\tWORD $0xc031 // xor    eax, eax\n+\n+LBB0_15:\n+\tWORD $0x8948; BYTE $0x02 // mov    qword [rdx], rax\n+\tRET\n+\n+LBB0_8:\n+\tWORD $0xc931     // xor    ecx, ecx\n+\tLONG $0xc0ef0f66 // pxor    xmm0, xmm0\n+\tLONG $0xc9ef0f66 // pxor    xmm1, xmm1\n+\n+LBB0_11:\n+\tLONG $0x0cf88349             // cmp    r8, 12\n+\tJB   LBB0_14\n+\tWORD $0x894c; BYTE $0xc8     // mov    rax, r9\n+\tWORD $0x2948; BYTE $0xc8     // sub    rax, rcx\n+\tLONG $0xcf4c8d48; BYTE $0x70 // lea    rcx, [rdi + 8*rcx + 112]\n+\n+LBB0_13:\n+\tLONG $0x516f0ff3; BYTE $0x90 // movdqu    xmm2, oword [rcx - 112]\n+\tLONG $0x596f0ff3; BYTE $0xa0 // movdqu    xmm3, oword [rcx - 96]\n+\tLONG $0x616f0ff3; BYTE $0xb0 // movdqu    xmm4, oword [rcx - 80]\n+\tLONG $0x696f0ff3; BYTE $0xc0 // movdqu    xmm5, oword [rcx - 64]\n+\tLONG $0xd0d40f66             // paddq    xmm2, xmm0\n+\tLONG $0xd9d40f66             // paddq    xmm3, xmm1\n+\tLONG $0x716f0ff3; BYTE $0xd0 // movdqu    xmm6, oword [rcx - 48]\n+\tLONG $0x796f0ff3; BYTE $0xe0 // movdqu    xmm7, oword [rcx - 32]\n+\tLONG $0xf4d40f66             // paddq    xmm6, xmm4\n+\tLONG $0xf2d40f66             // paddq    xmm6, xmm2\n+\tLONG $0xfdd40f66             // paddq    xmm7, xmm5\n+\tLONG $0xfbd40f66             // paddq    xmm7, xmm3\n+\tLONG $0x416f0ff3; BYTE $0xf0 // movdqu    xmm0, oword [rcx - 16]\n+\tLONG $0x096f0ff3             // movdqu    xmm1, oword [rcx]\n+\tLONG $0xc6d40f66             // paddq    xmm0, xmm6\n+\tLONG $0xcfd40f66             // paddq    xmm1, xmm7\n+\tLONG $0x80e98348             // sub    rcx, -128\n+\tLONG $0xf0c08348             // add    rax, -16\n+\tJNE  LBB0_13\n+\n+LBB0_14:\n+\tLONG $0xc1d40f66             // paddq    xmm0, xmm1\n+\tLONG $0xc8700f66; BYTE $0x4e // pshufd    xmm1, xmm0, 78\n+\tLONG $0xc8d40f66             // paddq    xmm1, xmm0\n+\tLONG $0x7e0f4866; BYTE $0xc8 // movq    rax, xmm1\n+\tWORD $0x3949; BYTE $0xf1     // cmp    r9, rsi\n+\tJNE  LBB0_4\n+\tJMP  LBB0_15\ndiff --git a/go/arrow/math/uint64_test.go b/go/arrow/math/uint64_test.go\nnew file mode 100644\nindex 000000000..7b8a16579\n--- /dev/null\n+++ b/go/arrow/math/uint64_test.go\n@@ -0,0 +1,68 @@\n+// Code generated by type_test.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package math_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow/array\"\n+\t\"github.com/apache/arrow/go/arrow/math\"\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestUint64Funcs_Sum(t *testing.T) {\n+\tvec := makeArrayUint64(10000)\n+\tres := math.Uint64.Sum(vec)\n+\tassert.Equal(t, res, uint64(49995000))\n+}\n+\n+func makeArrayUint64(l int) *array.Uint64 {\n+\tfb := array.NewUint64Builder(memory.NewGoAllocator())\n+\tfb.Reserve(l)\n+\tfor i := 0; i < l; i++ {\n+\t\tfb.Append(uint64(i))\n+\t}\n+\treturn fb.NewUint64Array()\n+}\n+\n+func benchmarkUint64Funcs_Sum(b *testing.B, n int) {\n+\tvec := makeArrayUint64(n)\n+\tb.SetBytes(int64(vec.Len() * 8))\n+\tb.ResetTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tmath.Uint64.Sum(vec)\n+\t}\n+}\n+\n+func BenchmarkUint64Funcs_Sum_256(b *testing.B) {\n+\tbenchmarkUint64Funcs_Sum(b, 256)\n+}\n+\n+func BenchmarkUint64Funcs_Sum_1024(b *testing.B) {\n+\tbenchmarkUint64Funcs_Sum(b, 1024)\n+}\n+\n+func BenchmarkUint64Funcs_Sum_8192(b *testing.B) {\n+\tbenchmarkUint64Funcs_Sum(b, 8192)\n+}\n+\n+func BenchmarkUint64Funcs_Sum_1000000(b *testing.B) {\n+\tbenchmarkUint64Funcs_Sum(b, 1e6)\n+}\ndiff --git a/go/arrow/memory/Makefile b/go/arrow/memory/Makefile\nnew file mode 100644\nindex 000000000..e50d94e60\n--- /dev/null\n+++ b/go/arrow/memory/Makefile\n@@ -0,0 +1,54 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+GO_BUILD=go build\n+GO_GEN=go generate\n+GO_TEST=go test\n+GOPATH=$(realpath ../../../..)\n+\n+# this converts rotate instructions from \"ro[lr] <reg>\" -> \"ro[lr] <reg>, 1\" for yasm compatibility\n+PERL_FIXUP_ROTATE=perl -i -pe 's/(ro[rl]\\s+\\w{2,3})$$/\\1, 1/'\n+\n+C2GOASM=c2goasm -a -f\n+CC=clang\n+C_FLAGS=-target x86_64-unknown-none -masm=intel -mno-red-zone -mstackrealign -mllvm -inline-threshold=1000 -fno-asynchronous-unwind-tables \\\n+\t-fno-exceptions -fno-rtti -O3 -fno-builtin -ffast-math -fno-jump-tables -I_lib\n+ASM_FLAGS_AVX2=-mavx2 -mfma -mllvm -force-vector-width=32\n+ASM_FLAGS_SSE3=-msse3\n+ASM_FLAGS_SSE4=-msse4\n+\n+GO_SOURCES  := $(shell find . -path ./_lib -prune -o -name '*.go' -not -name '*_test.go')\n+ALL_SOURCES := $(shell find . -path ./_lib -prune -o -name '*.go' -name '*.s' -not -name '*_test.go')\n+\n+INTEL_SOURCES := \\\n+\tmemory_avx2_amd64.s memory_sse4_amd64.s\n+\n+.PHONEY: assembly\n+\n+assembly: $(INTEL_SOURCES)\n+\n+_lib/memory_avx2.s: _lib/memory.c\n+\t$(CC) -S $(C_FLAGS) $(ASM_FLAGS_AVX2) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@\n+\n+_lib/memory_sse4.s: _lib/memory.c\n+\t$(CC) -S $(C_FLAGS) $(ASM_FLAGS_SSE4) $^ -o $@ ; $(PERL_FIXUP_ROTATE) $@\n+\n+memory_avx2_amd64.s: _lib/memory_avx2.s\n+\t$(C2GOASM) -a -f $^ $@\n+\n+memory_sse4_amd64.s: _lib/memory_sse4.s\n+\t$(C2GOASM) -a -f $^ $@\n+\ndiff --git a/go/arrow/memory/_lib/.gitignore b/go/arrow/memory/_lib/.gitignore\nnew file mode 100644\nindex 000000000..72757d396\n--- /dev/null\n+++ b/go/arrow/memory/_lib/.gitignore\n@@ -0,0 +1,18 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+.idea\n+cmake-build-*\n\\ No newline at end of file\ndiff --git a/go/arrow/memory/_lib/CMakeLists.txt b/go/arrow/memory/_lib/CMakeLists.txt\nnew file mode 100644\nindex 000000000..f6815302d\n--- /dev/null\n+++ b/go/arrow/memory/_lib/CMakeLists.txt\n@@ -0,0 +1,24 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+# http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+cmake_minimum_required(VERSION 3.6)\n+\n+project(memory-func)\n+set(CMAKE_C_STANDARD 99)\n+\n+add_library(memory STATIC memory.c)\n+\n+\ndiff --git a/go/arrow/memory/_lib/arch.h b/go/arrow/memory/_lib/arch.h\nnew file mode 100644\nindex 000000000..d9c7d98bf\n--- /dev/null\n+++ b/go/arrow/memory/_lib/arch.h\n@@ -0,0 +1,27 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#undef FULL_NAME\n+\n+#if  defined(__AVX2__)\n+    #define FULL_NAME(x) x##_avx2\n+#elif __SSE4_2__ == 1\n+    #define FULL_NAME(x) x##_sse4\n+#elif __SSE3__ == 1\n+    #define FULL_NAME(x) x##_sse3\n+#else\n+    #define FULL_NAME(x) x##_x86\n+#endif\n\\ No newline at end of file\ndiff --git a/go/arrow/memory/_lib/memory.c b/go/arrow/memory/_lib/memory.c\nnew file mode 100644\nindex 000000000..0e57237c3\n--- /dev/null\n+++ b/go/arrow/memory/_lib/memory.c\n@@ -0,0 +1,27 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#include \"arch.h\"\n+#include <memory.h>\n+\n+void FULL_NAME(memset)(void *buf, size_t len, int v) {\n+    char *bytes = buf;\n+    char *end   = buf+len;\n+    const char val = v;\n+    while (bytes < end) {\n+        *bytes++ = val;\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/go/arrow/memory/_lib/memory_avx2.s b/go/arrow/memory/_lib/memory_avx2.s\nnew file mode 100644\nindex 000000000..f53fa15c5\n--- /dev/null\n+++ b/go/arrow/memory/_lib/memory_avx2.s\n@@ -0,0 +1,97 @@\n+\t.text\n+\t.intel_syntax noprefix\n+\t.file\t\"_lib/memory.c\"\n+\t.globl\tmemset_avx2\n+\t.p2align\t4, 0x90\n+\t.type\tmemset_avx2,@function\n+memset_avx2:                            # @memset_avx2\n+# BB#0:\n+\tpush\trbp\n+\tmov\trbp, rsp\n+\tand\trsp, -8\n+\tlea\tr11, [rdi + rsi]\n+\tcmp\tr11, rdi\n+\tjbe\t.LBB0_13\n+# BB#1:\n+\tcmp\trsi, 128\n+\tjb\t.LBB0_12\n+# BB#2:\n+\tmov\tr8, rsi\n+\tand\tr8, -128\n+\tmov\tr10, rsi\n+\tand\tr10, -128\n+\tje\t.LBB0_12\n+# BB#3:\n+\tvmovd\txmm0, edx\n+\tvpbroadcastb\tymm0, xmm0\n+\tlea\tr9, [r10 - 128]\n+\tmov\teax, r9d\n+\tshr\teax, 7\n+\tinc\teax\n+\tand\trax, 3\n+\tje\t.LBB0_4\n+# BB#5:\n+\tneg\trax\n+\txor\tecx, ecx\n+\t.p2align\t4, 0x90\n+.LBB0_6:                                # =>This Inner Loop Header: Depth=1\n+\tvmovdqu\tymmword ptr [rdi + rcx], ymm0\n+\tvmovdqu\tymmword ptr [rdi + rcx + 32], ymm0\n+\tvmovdqu\tymmword ptr [rdi + rcx + 64], ymm0\n+\tvmovdqu\tymmword ptr [rdi + rcx + 96], ymm0\n+\tsub\trcx, -128\n+\tinc\trax\n+\tjne\t.LBB0_6\n+\tjmp\t.LBB0_7\n+.LBB0_4:\n+\txor\tecx, ecx\n+.LBB0_7:\n+\tcmp\tr9, 384\n+\tjb\t.LBB0_10\n+# BB#8:\n+\tmov\trax, r10\n+\tsub\trax, rcx\n+\tlea\trcx, [rdi + rcx + 480]\n+\t.p2align\t4, 0x90\n+.LBB0_9:                                # =>This Inner Loop Header: Depth=1\n+\tvmovdqu\tymmword ptr [rcx - 480], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 448], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 416], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 384], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 352], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 320], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 288], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 256], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 224], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 192], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 160], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 128], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 96], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 64], ymm0\n+\tvmovdqu\tymmword ptr [rcx - 32], ymm0\n+\tvmovdqu\tymmword ptr [rcx], ymm0\n+\tadd\trcx, 512\n+\tadd\trax, -512\n+\tjne\t.LBB0_9\n+.LBB0_10:\n+\tcmp\tr10, rsi\n+\tje\t.LBB0_13\n+# BB#11:\n+\tadd\trdi, r8\n+\t.p2align\t4, 0x90\n+.LBB0_12:                               # =>This Inner Loop Header: Depth=1\n+\tmov\tbyte ptr [rdi], dl\n+\tinc\trdi\n+\tcmp\tr11, rdi\n+\tjne\t.LBB0_12\n+.LBB0_13:\n+\tmov\trsp, rbp\n+\tpop\trbp\n+\tvzeroupper\n+\tret\n+.Lfunc_end0:\n+\t.size\tmemset_avx2, .Lfunc_end0-memset_avx2\n+\n+\n+\t.ident\t\"Apple LLVM version 9.0.0 (clang-900.0.39.2)\"\n+\t.section\t\".note.GNU-stack\",\"\",@progbits\ndiff --git a/go/arrow/memory/_lib/memory_sse4.s b/go/arrow/memory/_lib/memory_sse4.s\nnew file mode 100644\nindex 000000000..4b44cd31c\n--- /dev/null\n+++ b/go/arrow/memory/_lib/memory_sse4.s\n@@ -0,0 +1,96 @@\n+\t.text\n+\t.intel_syntax noprefix\n+\t.file\t\"_lib/memory.c\"\n+\t.globl\tmemset_sse4\n+\t.p2align\t4, 0x90\n+\t.type\tmemset_sse4,@function\n+memset_sse4:                            # @memset_sse4\n+# BB#0:\n+\tpush\trbp\n+\tmov\trbp, rsp\n+\tand\trsp, -8\n+\tlea\tr11, [rdi + rsi]\n+\tcmp\tr11, rdi\n+\tjbe\t.LBB0_13\n+# BB#1:\n+\tcmp\trsi, 32\n+\tjb\t.LBB0_12\n+# BB#2:\n+\tmov\tr8, rsi\n+\tand\tr8, -32\n+\tmov\tr10, rsi\n+\tand\tr10, -32\n+\tje\t.LBB0_12\n+# BB#3:\n+\tmovzx\teax, dl\n+\tmovd\txmm0, eax\n+\tpxor\txmm1, xmm1\n+\tpshufb\txmm0, xmm1\n+\tlea\tr9, [r10 - 32]\n+\tmov\tecx, r9d\n+\tshr\tecx, 5\n+\tinc\tecx\n+\tand\trcx, 7\n+\tje\t.LBB0_4\n+# BB#5:\n+\tneg\trcx\n+\txor\teax, eax\n+\t.p2align\t4, 0x90\n+.LBB0_6:                                # =>This Inner Loop Header: Depth=1\n+\tmovdqu\txmmword ptr [rdi + rax], xmm0\n+\tmovdqu\txmmword ptr [rdi + rax + 16], xmm0\n+\tadd\trax, 32\n+\tinc\trcx\n+\tjne\t.LBB0_6\n+\tjmp\t.LBB0_7\n+.LBB0_4:\n+\txor\teax, eax\n+.LBB0_7:\n+\tcmp\tr9, 224\n+\tjb\t.LBB0_10\n+# BB#8:\n+\tmov\trcx, r10\n+\tsub\trcx, rax\n+\tlea\trax, [rdi + rax + 240]\n+\t.p2align\t4, 0x90\n+.LBB0_9:                                # =>This Inner Loop Header: Depth=1\n+\tmovdqu\txmmword ptr [rax - 240], xmm0\n+\tmovdqu\txmmword ptr [rax - 224], xmm0\n+\tmovdqu\txmmword ptr [rax - 208], xmm0\n+\tmovdqu\txmmword ptr [rax - 192], xmm0\n+\tmovdqu\txmmword ptr [rax - 176], xmm0\n+\tmovdqu\txmmword ptr [rax - 160], xmm0\n+\tmovdqu\txmmword ptr [rax - 144], xmm0\n+\tmovdqu\txmmword ptr [rax - 128], xmm0\n+\tmovdqu\txmmword ptr [rax - 112], xmm0\n+\tmovdqu\txmmword ptr [rax - 96], xmm0\n+\tmovdqu\txmmword ptr [rax - 80], xmm0\n+\tmovdqu\txmmword ptr [rax - 64], xmm0\n+\tmovdqu\txmmword ptr [rax - 48], xmm0\n+\tmovdqu\txmmword ptr [rax - 32], xmm0\n+\tmovdqu\txmmword ptr [rax - 16], xmm0\n+\tmovdqu\txmmword ptr [rax], xmm0\n+\tadd\trax, 256\n+\tadd\trcx, -256\n+\tjne\t.LBB0_9\n+.LBB0_10:\n+\tcmp\tr10, rsi\n+\tje\t.LBB0_13\n+# BB#11:\n+\tadd\trdi, r8\n+\t.p2align\t4, 0x90\n+.LBB0_12:                               # =>This Inner Loop Header: Depth=1\n+\tmov\tbyte ptr [rdi], dl\n+\tinc\trdi\n+\tcmp\tr11, rdi\n+\tjne\t.LBB0_12\n+.LBB0_13:\n+\tmov\trsp, rbp\n+\tpop\trbp\n+\tret\n+.Lfunc_end0:\n+\t.size\tmemset_sse4, .Lfunc_end0-memset_sse4\n+\n+\n+\t.ident\t\"Apple LLVM version 9.0.0 (clang-900.0.39.2)\"\n+\t.section\t\".note.GNU-stack\",\"\",@progbits\ndiff --git a/go/arrow/memory/allocator.go b/go/arrow/memory/allocator.go\nnew file mode 100644\nindex 000000000..da6be44e3\n--- /dev/null\n+++ b/go/arrow/memory/allocator.go\n@@ -0,0 +1,33 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package memory\n+\n+const (\n+\talignment = 64\n+)\n+\n+type Allocator interface {\n+\tAllocate(size int) []byte\n+\tReallocate(size int, b []byte) []byte\n+\tFree(b []byte)\n+}\n+\n+// DefaultAllocator is a default implementation of Allocator and can be used anywhere\n+// an Allocator is required.\n+//\n+// DefaultAllocator is safe to use from multiple goroutines.\n+var DefaultAllocator Allocator = NewGoAllocator()\ndiff --git a/go/arrow/memory/buffer.go b/go/arrow/memory/buffer.go\nnew file mode 100644\nindex 000000000..234f5d433\n--- /dev/null\n+++ b/go/arrow/memory/buffer.go\n@@ -0,0 +1,108 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package memory\n+\n+import (\n+\t\"sync/atomic\"\n+\n+\t\"github.com/apache/arrow/go/arrow/internal/debug\"\n+)\n+\n+type Buffer struct {\n+\trefCount int64\n+\tbuf      []byte\n+\tlength   int\n+\tmutable  bool\n+\tmem      Allocator\n+}\n+\n+// NewBufferBytes creates a fixed-size buffer from the specified data.\n+func NewBufferBytes(data []byte) *Buffer {\n+\treturn &Buffer{refCount: 0, buf: data, length: len(data)}\n+}\n+\n+// NewBuffer creates a mutable, resizable buffer with an Allocator for managing memory.\n+func NewResizableBuffer(mem Allocator) *Buffer {\n+\treturn &Buffer{refCount: 1, mutable: true, mem: mem}\n+}\n+\n+// Retain increases the reference count by 1.\n+func (b *Buffer) Retain() {\n+\tif b.mem != nil {\n+\t\tatomic.AddInt64(&b.refCount, 1)\n+\t}\n+}\n+\n+// Release decreases the reference count by 1.\n+// When the reference count goes to zero, the memory is freed.\n+func (b *Buffer) Release() {\n+\tif b.mem != nil {\n+\t\tdebug.Assert(atomic.LoadInt64(&b.refCount) > 0, \"too many releases\")\n+\n+\t\tif atomic.AddInt64(&b.refCount, -1) == 0 {\n+\t\t\tb.mem.Free(b.buf)\n+\t\t\tb.buf, b.length = nil, 0\n+\t\t}\n+\t}\n+}\n+\n+// Buf returns the slice of memory allocated by the Buffer, which is adjusted by calling Reserve.\n+func (b *Buffer) Buf() []byte { return b.buf }\n+\n+// Bytes returns a slice of size Len, which is adjusted by calling Resize.\n+func (b *Buffer) Bytes() []byte { return b.buf[:b.length] }\n+func (b *Buffer) Mutable() bool { return b.mutable }\n+func (b *Buffer) Len() int      { return b.length }\n+func (b *Buffer) Cap() int      { return len(b.buf) }\n+\n+func (b *Buffer) Reserve(capacity int) {\n+\tif capacity > len(b.buf) {\n+\t\tnewCap := roundUpToMultipleOf64(capacity)\n+\t\tif len(b.buf) == 0 {\n+\t\t\tb.buf = b.mem.Allocate(newCap)\n+\t\t} else {\n+\t\t\tb.buf = b.mem.Reallocate(newCap, b.buf)\n+\t\t}\n+\t}\n+}\n+\n+func (b *Buffer) Resize(newSize int) {\n+\tb.resize(newSize, true)\n+}\n+\n+func (b *Buffer) ResizeNoShrink(newSize int) {\n+\tb.resize(newSize, false)\n+}\n+\n+func (b *Buffer) resize(newSize int, shrink bool) {\n+\tif !shrink || newSize > b.length {\n+\t\tb.Reserve(newSize)\n+\t} else {\n+\t\t// Buffer is not growing, so shrink to the requested size without\n+\t\t// excess space.\n+\t\tnewCap := roundUpToMultipleOf64(newSize)\n+\t\tif len(b.buf) != newCap {\n+\t\t\tif newSize == 0 {\n+\t\t\t\tb.mem.Free(b.buf)\n+\t\t\t\tb.buf = nil\n+\t\t\t} else {\n+\t\t\t\tb.buf = b.mem.Reallocate(newCap, b.buf)\n+\t\t\t}\n+\t\t}\n+\t}\n+\tb.length = newSize\n+}\ndiff --git a/go/arrow/memory/buffer_test.go b/go/arrow/memory/buffer_test.go\nnew file mode 100644\nindex 000000000..918175cb6\n--- /dev/null\n+++ b/go/arrow/memory/buffer_test.go\n@@ -0,0 +1,45 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package memory_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestNewResizableBuffer(t *testing.T) {\n+\tmem := memory.NewCheckedAllocator(memory.NewGoAllocator())\n+\tdefer mem.AssertSize(t, 0)\n+\n+\tbuf := memory.NewResizableBuffer(mem)\n+\tbuf.Retain() // refCount == 2\n+\n+\texp := 10\n+\tbuf.Resize(exp)\n+\tassert.NotNil(t, buf.Bytes())\n+\tassert.Equal(t, exp, len(buf.Bytes()))\n+\tassert.Equal(t, exp, buf.Len())\n+\n+\tbuf.Release() // refCount == 1\n+\tassert.NotNil(t, buf.Bytes())\n+\n+\tbuf.Release() // refCount == 0\n+\tassert.Nil(t, buf.Bytes())\n+\tassert.Zero(t, buf.Len())\n+}\ndiff --git a/go/arrow/memory/checked_allocator.go b/go/arrow/memory/checked_allocator.go\nnew file mode 100644\nindex 000000000..4cce89f24\n--- /dev/null\n+++ b/go/arrow/memory/checked_allocator.go\n@@ -0,0 +1,70 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package memory\n+\n+type CheckedAllocator struct {\n+\tmem  Allocator\n+\tbase int\n+\tsz   int\n+}\n+\n+func NewCheckedAllocator(mem Allocator) *CheckedAllocator {\n+\treturn &CheckedAllocator{mem: mem}\n+}\n+\n+func (a *CheckedAllocator) Allocate(size int) []byte {\n+\ta.sz += size\n+\treturn a.mem.Allocate(size)\n+}\n+\n+func (a *CheckedAllocator) Reallocate(size int, b []byte) []byte {\n+\ta.sz += size - len(b)\n+\treturn a.mem.Reallocate(size, b)\n+}\n+\n+func (a *CheckedAllocator) Free(b []byte) {\n+\ta.sz -= len(b)\n+\ta.mem.Free(b)\n+}\n+\n+type TestingT interface {\n+\tErrorf(format string, args ...interface{})\n+\tHelper()\n+}\n+\n+func (a *CheckedAllocator) AssertSize(t TestingT, sz int) {\n+\tif a.sz != sz {\n+\t\tt.Helper()\n+\t\tt.Errorf(\"invalid memory size exp=%d, got=%d\", sz, a.sz)\n+\t}\n+}\n+\n+type CheckedAllocatorScope struct {\n+\talloc *CheckedAllocator\n+\tsz    int\n+}\n+\n+func NewCheckedAllocatorScope(alloc *CheckedAllocator) *CheckedAllocatorScope {\n+\treturn &CheckedAllocatorScope{alloc: alloc, sz: alloc.sz}\n+}\n+\n+func (c *CheckedAllocatorScope) CheckSize(t TestingT) {\n+\tif c.sz != c.alloc.sz {\n+\t\tt.Helper()\n+\t\tt.Errorf(\"invalid memory size exp=%d, got=%d\", c.sz, c.alloc.sz)\n+\t}\n+}\ndiff --git a/go/arrow/memory/doc.go b/go/arrow/memory/doc.go\nnew file mode 100644\nindex 000000000..959f88b4f\n--- /dev/null\n+++ b/go/arrow/memory/doc.go\n@@ -0,0 +1,20 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+/*\n+Package memory provides support for allocating and manipulating memory at a low level.\n+*/\n+package memory\ndiff --git a/go/arrow/memory/go_allocator.go b/go/arrow/memory/go_allocator.go\nnew file mode 100644\nindex 000000000..a85baee71\n--- /dev/null\n+++ b/go/arrow/memory/go_allocator.go\n@@ -0,0 +1,44 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package memory\n+\n+type GoAllocator struct{}\n+\n+func NewGoAllocator() *GoAllocator { return &GoAllocator{} }\n+\n+func (a *GoAllocator) Allocate(size int) []byte {\n+\tbuf := make([]byte, size+alignment) // padding for 64-byte alignment\n+\taddr := int(addressOf(buf))\n+\tnext := roundUpToMultipleOf64(addr)\n+\tif addr != next {\n+\t\tshift := next - addr\n+\t\treturn buf[shift : size+shift : size+shift]\n+\t}\n+\treturn buf[:size:size]\n+}\n+\n+func (a *GoAllocator) Reallocate(size int, b []byte) []byte {\n+\tif size == len(b) {\n+\t\treturn b\n+\t}\n+\n+\tnewBuf := a.Allocate(size)\n+\tcopy(newBuf, b)\n+\treturn newBuf\n+}\n+\n+func (a *GoAllocator) Free(b []byte) {}\ndiff --git a/go/arrow/memory/go_allocator_test.go b/go/arrow/memory/go_allocator_test.go\nnew file mode 100644\nindex 000000000..d146e301a\n--- /dev/null\n+++ b/go/arrow/memory/go_allocator_test.go\n@@ -0,0 +1,76 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package memory\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func isAlignedTo(addr, alignment int) bool {\n+\treturn addr&(alignment-1) == 0\n+}\n+\n+func TestGoAllocator_Allocate(t *testing.T) {\n+\ttests := []struct {\n+\t\tname string\n+\t\tsz   int\n+\t}{\n+\t\t{\"lt alignment\", 33},\n+\t\t{\"gt alignment unaligned\", 65},\n+\t\t{\"eq alignment\", 64},\n+\t\t{\"large unaligned\", 4097},\n+\t\t{\"large aligned\", 8192},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\ta := &GoAllocator{}\n+\t\t\tbuf := a.Allocate(test.sz)\n+\t\t\taddr := addressOf(buf)\n+\t\t\tassert.True(t, isAlignedTo(int(addr), alignment))\n+\t\t\tassert.Equal(t, test.sz, len(buf), \"invalid len\")\n+\t\t\tassert.Equal(t, test.sz, cap(buf), \"invalid cap\")\n+\t\t})\n+\t}\n+}\n+\n+func TestGoAllocator_Reallocate(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tsz1, sz2 int\n+\t}{\n+\t\t{\"smaller\", 200, 100},\n+\t\t{\"same\", 200, 200},\n+\t\t{\"larger\", 200, 300},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\ta := &GoAllocator{}\n+\t\t\tbuf := a.Allocate(test.sz1)\n+\t\t\tfor i := range buf {\n+\t\t\t\tbuf[i] = byte(i & 0xff)\n+\t\t\t}\n+\n+\t\t\texp := make([]byte, test.sz2)\n+\t\t\tcopy(exp, buf)\n+\n+\t\t\tnewBuf := a.Reallocate(test.sz2, buf)\n+\t\t\tassert.Equal(t, exp, newBuf)\n+\t\t})\n+\t}\n+}\ndiff --git a/go/arrow/memory/memory.go b/go/arrow/memory/memory.go\nnew file mode 100644\nindex 000000000..de2a3a663\n--- /dev/null\n+++ b/go/arrow/memory/memory.go\n@@ -0,0 +1,33 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package memory\n+\n+var (\n+\tmemset func(b []byte, c byte)\n+)\n+\n+// Set assigns the value c to every element of the slice buf.\n+func Set(buf []byte, c byte) {\n+\tmemset(buf, c)\n+}\n+\n+// memory_memset_go reference implementation\n+func memory_memset_go(buf []byte, c byte) {\n+\tfor i := 0; i < len(buf); i++ {\n+\t\tbuf[i] = c\n+\t}\n+}\ndiff --git a/go/arrow/memory/memory_amd64.go b/go/arrow/memory/memory_amd64.go\nnew file mode 100644\nindex 000000000..5ea4a3fe1\n--- /dev/null\n+++ b/go/arrow/memory/memory_amd64.go\n@@ -0,0 +1,33 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package memory\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow/internal/cpu\"\n+)\n+\n+func init() {\n+\tif cpu.X86.HasAVX2 {\n+\t\tmemset = memory_memset_avx2\n+\t} else if cpu.X86.HasSSE42 {\n+\t\tmemset = memory_memset_sse4\n+\t} else {\n+\t\tmemset = memory_memset_go\n+\t}\n+}\ndiff --git a/go/arrow/memory/memory_avx2_amd64.go b/go/arrow/memory/memory_avx2_amd64.go\nnew file mode 100644\nindex 000000000..1f9d176cc\n--- /dev/null\n+++ b/go/arrow/memory/memory_avx2_amd64.go\n@@ -0,0 +1,41 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package memory\n+\n+import \"unsafe\"\n+\n+//go:noescape\n+func _memset_avx2(buf, len, c unsafe.Pointer)\n+\n+func memory_memset_avx2(buf []byte, c byte) {\n+\tif len(buf) == 0 {\n+\t\treturn\n+\t}\n+\n+\tvar (\n+\t\tp1 = unsafe.Pointer(&buf[0])\n+\t\tp2 = unsafe.Pointer(uintptr(len(buf)))\n+\t\tp3 = unsafe.Pointer(uintptr(c))\n+\t)\n+\tif len(buf) > 2000 || isMultipleOfPowerOf2(len(buf), 256) {\n+\t\t_memset_avx2(p1, p2, p3)\n+\t} else {\n+\t\t_memset_sse4(p1, p2, p3)\n+\t}\n+}\ndiff --git a/go/arrow/memory/memory_avx2_amd64.s b/go/arrow/memory/memory_avx2_amd64.s\nnew file mode 100644\nindex 000000000..2a77807cb\n--- /dev/null\n+++ b/go/arrow/memory/memory_avx2_amd64.s\n@@ -0,0 +1,85 @@\n+//+build !noasm !appengine\n+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT\n+\n+TEXT \u00b7_memset_avx2(SB), $0-24\n+\n+\tMOVQ buf+0(FP), DI\n+\tMOVQ len+8(FP), SI\n+\tMOVQ c+16(FP), DX\n+\n+\tLONG $0x371c8d4c                           // lea    r11, [rdi + rsi]\n+\tWORD $0x3949; BYTE $0xfb                   // cmp    r11, rdi\n+\tJBE  LBB0_13\n+\tLONG $0x80fe8148; WORD $0x0000; BYTE $0x00 // cmp    rsi, 128\n+\tJB   LBB0_12\n+\tWORD $0x8949; BYTE $0xf0                   // mov    r8, rsi\n+\tLONG $0x80e08349                           // and    r8, -128\n+\tWORD $0x8949; BYTE $0xf2                   // mov    r10, rsi\n+\tLONG $0x80e28349                           // and    r10, -128\n+\tJE   LBB0_12\n+\tLONG $0xc26ef9c5                           // vmovd    xmm0, edx\n+\tLONG $0x787de2c4; BYTE $0xc0               // vpbroadcastb    ymm0, xmm0\n+\tLONG $0x804a8d4d                           // lea    r9, [r10 - 128]\n+\tWORD $0x8944; BYTE $0xc8                   // mov    eax, r9d\n+\tWORD $0xe8c1; BYTE $0x07                   // shr    eax, 7\n+\tWORD $0xc0ff                               // inc    eax\n+\tLONG $0x03e08348                           // and    rax, 3\n+\tJE   LBB0_4\n+\tWORD $0xf748; BYTE $0xd8                   // neg    rax\n+\tWORD $0xc931                               // xor    ecx, ecx\n+\n+LBB0_6:\n+\tLONG $0x047ffec5; BYTE $0x0f   // vmovdqu    yword [rdi + rcx], ymm0\n+\tLONG $0x447ffec5; WORD $0x200f // vmovdqu    yword [rdi + rcx + 32], ymm0\n+\tLONG $0x447ffec5; WORD $0x400f // vmovdqu    yword [rdi + rcx + 64], ymm0\n+\tLONG $0x447ffec5; WORD $0x600f // vmovdqu    yword [rdi + rcx + 96], ymm0\n+\tLONG $0x80e98348               // sub    rcx, -128\n+\tWORD $0xff48; BYTE $0xc0       // inc    rax\n+\tJNE  LBB0_6\n+\tJMP  LBB0_7\n+\n+LBB0_4:\n+\tWORD $0xc931 // xor    ecx, ecx\n+\n+LBB0_7:\n+\tLONG $0x80f98149; WORD $0x0001; BYTE $0x00 // cmp    r9, 384\n+\tJB   LBB0_10\n+\tWORD $0x894c; BYTE $0xd0                   // mov    rax, r10\n+\tWORD $0x2948; BYTE $0xc8                   // sub    rax, rcx\n+\tQUAD $0x000001e00f8c8d48                   // lea    rcx, [rdi + rcx + 480]\n+\n+LBB0_9:\n+\tQUAD $0xfffffe20817ffec5                   // vmovdqu    yword [rcx - 480], ymm0\n+\tQUAD $0xfffffe40817ffec5                   // vmovdqu    yword [rcx - 448], ymm0\n+\tQUAD $0xfffffe60817ffec5                   // vmovdqu    yword [rcx - 416], ymm0\n+\tQUAD $0xfffffe80817ffec5                   // vmovdqu    yword [rcx - 384], ymm0\n+\tQUAD $0xfffffea0817ffec5                   // vmovdqu    yword [rcx - 352], ymm0\n+\tQUAD $0xfffffec0817ffec5                   // vmovdqu    yword [rcx - 320], ymm0\n+\tQUAD $0xfffffee0817ffec5                   // vmovdqu    yword [rcx - 288], ymm0\n+\tQUAD $0xffffff00817ffec5                   // vmovdqu    yword [rcx - 256], ymm0\n+\tQUAD $0xffffff20817ffec5                   // vmovdqu    yword [rcx - 224], ymm0\n+\tQUAD $0xffffff40817ffec5                   // vmovdqu    yword [rcx - 192], ymm0\n+\tQUAD $0xffffff60817ffec5                   // vmovdqu    yword [rcx - 160], ymm0\n+\tLONG $0x417ffec5; BYTE $0x80               // vmovdqu    yword [rcx - 128], ymm0\n+\tLONG $0x417ffec5; BYTE $0xa0               // vmovdqu    yword [rcx - 96], ymm0\n+\tLONG $0x417ffec5; BYTE $0xc0               // vmovdqu    yword [rcx - 64], ymm0\n+\tLONG $0x417ffec5; BYTE $0xe0               // vmovdqu    yword [rcx - 32], ymm0\n+\tLONG $0x017ffec5                           // vmovdqu    yword [rcx], ymm0\n+\tLONG $0x00c18148; WORD $0x0002; BYTE $0x00 // add    rcx, 512\n+\tLONG $0xfe000548; WORD $0xffff             // add    rax, -512\n+\tJNE  LBB0_9\n+\n+LBB0_10:\n+\tWORD $0x3949; BYTE $0xf2 // cmp    r10, rsi\n+\tJE   LBB0_13\n+\tWORD $0x014c; BYTE $0xc7 // add    rdi, r8\n+\n+LBB0_12:\n+\tWORD $0x1788             // mov    byte [rdi], dl\n+\tWORD $0xff48; BYTE $0xc7 // inc    rdi\n+\tWORD $0x3949; BYTE $0xfb // cmp    r11, rdi\n+\tJNE  LBB0_12\n+\n+LBB0_13:\n+\tVZEROUPPER\n+\tRET\ndiff --git a/go/arrow/memory/memory_noasm.go b/go/arrow/memory/memory_noasm.go\nnew file mode 100644\nindex 000000000..bf8846fa2\n--- /dev/null\n+++ b/go/arrow/memory/memory_noasm.go\n@@ -0,0 +1,23 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build noasm\n+\n+package memory\n+\n+func init() {\n+\tmemset = memory_memset_go\n+}\ndiff --git a/go/arrow/memory/memory_sse4_amd64.go b/go/arrow/memory/memory_sse4_amd64.go\nnew file mode 100644\nindex 000000000..61da4665a\n--- /dev/null\n+++ b/go/arrow/memory/memory_sse4_amd64.go\n@@ -0,0 +1,31 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// +build !noasm\n+\n+package memory\n+\n+import \"unsafe\"\n+\n+//go:noescape\n+func _memset_sse4(buf, len, c unsafe.Pointer)\n+\n+func memory_memset_sse4(buf []byte, c byte) {\n+\tif len(buf) == 0 {\n+\t\treturn\n+\t}\n+\t_memset_sse4(unsafe.Pointer(&buf[0]), unsafe.Pointer(uintptr(len(buf))), unsafe.Pointer(uintptr(c)))\n+}\ndiff --git a/go/arrow/memory/memory_sse4_amd64.s b/go/arrow/memory/memory_sse4_amd64.s\nnew file mode 100644\nindex 000000000..b1906f99b\n--- /dev/null\n+++ b/go/arrow/memory/memory_sse4_amd64.s\n@@ -0,0 +1,84 @@\n+//+build !noasm !appengine\n+// AUTO-GENERATED BY C2GOASM -- DO NOT EDIT\n+\n+TEXT \u00b7_memset_sse4(SB), $0-24\n+\n+\tMOVQ buf+0(FP), DI\n+\tMOVQ len+8(FP), SI\n+\tMOVQ c+16(FP), DX\n+\n+\tLONG $0x371c8d4c             // lea    r11, [rdi + rsi]\n+\tWORD $0x3949; BYTE $0xfb     // cmp    r11, rdi\n+\tJBE  LBB0_13\n+\tLONG $0x20fe8348             // cmp    rsi, 32\n+\tJB   LBB0_12\n+\tWORD $0x8949; BYTE $0xf0     // mov    r8, rsi\n+\tLONG $0xe0e08349             // and    r8, -32\n+\tWORD $0x8949; BYTE $0xf2     // mov    r10, rsi\n+\tLONG $0xe0e28349             // and    r10, -32\n+\tJE   LBB0_12\n+\tWORD $0xb60f; BYTE $0xc2     // movzx    eax, dl\n+\tLONG $0xc06e0f66             // movd    xmm0, eax\n+\tLONG $0xc9ef0f66             // pxor    xmm1, xmm1\n+\tLONG $0x00380f66; BYTE $0xc1 // pshufb    xmm0, xmm1\n+\tLONG $0xe04a8d4d             // lea    r9, [r10 - 32]\n+\tWORD $0x8944; BYTE $0xc9     // mov    ecx, r9d\n+\tWORD $0xe9c1; BYTE $0x05     // shr    ecx, 5\n+\tWORD $0xc1ff                 // inc    ecx\n+\tLONG $0x07e18348             // and    rcx, 7\n+\tJE   LBB0_4\n+\tWORD $0xf748; BYTE $0xd9     // neg    rcx\n+\tWORD $0xc031                 // xor    eax, eax\n+\n+LBB0_6:\n+\tLONG $0x047f0ff3; BYTE $0x07   // movdqu    oword [rdi + rax], xmm0\n+\tLONG $0x447f0ff3; WORD $0x1007 // movdqu    oword [rdi + rax + 16], xmm0\n+\tLONG $0x20c08348               // add    rax, 32\n+\tWORD $0xff48; BYTE $0xc1       // inc    rcx\n+\tJNE  LBB0_6\n+\tJMP  LBB0_7\n+\n+LBB0_4:\n+\tWORD $0xc031 // xor    eax, eax\n+\n+LBB0_7:\n+\tLONG $0xe0f98149; WORD $0x0000; BYTE $0x00 // cmp    r9, 224\n+\tJB   LBB0_10\n+\tWORD $0x894c; BYTE $0xd1                   // mov    rcx, r10\n+\tWORD $0x2948; BYTE $0xc1                   // sub    rcx, rax\n+\tQUAD $0x000000f007848d48                   // lea    rax, [rdi + rax + 240]\n+\n+LBB0_9:\n+\tQUAD $0xffffff10807f0ff3                   // movdqu    oword [rax - 240], xmm0\n+\tQUAD $0xffffff20807f0ff3                   // movdqu    oword [rax - 224], xmm0\n+\tQUAD $0xffffff30807f0ff3                   // movdqu    oword [rax - 208], xmm0\n+\tQUAD $0xffffff40807f0ff3                   // movdqu    oword [rax - 192], xmm0\n+\tQUAD $0xffffff50807f0ff3                   // movdqu    oword [rax - 176], xmm0\n+\tQUAD $0xffffff60807f0ff3                   // movdqu    oword [rax - 160], xmm0\n+\tQUAD $0xffffff70807f0ff3                   // movdqu    oword [rax - 144], xmm0\n+\tLONG $0x407f0ff3; BYTE $0x80               // movdqu    oword [rax - 128], xmm0\n+\tLONG $0x407f0ff3; BYTE $0x90               // movdqu    oword [rax - 112], xmm0\n+\tLONG $0x407f0ff3; BYTE $0xa0               // movdqu    oword [rax - 96], xmm0\n+\tLONG $0x407f0ff3; BYTE $0xb0               // movdqu    oword [rax - 80], xmm0\n+\tLONG $0x407f0ff3; BYTE $0xc0               // movdqu    oword [rax - 64], xmm0\n+\tLONG $0x407f0ff3; BYTE $0xd0               // movdqu    oword [rax - 48], xmm0\n+\tLONG $0x407f0ff3; BYTE $0xe0               // movdqu    oword [rax - 32], xmm0\n+\tLONG $0x407f0ff3; BYTE $0xf0               // movdqu    oword [rax - 16], xmm0\n+\tLONG $0x007f0ff3                           // movdqu    oword [rax], xmm0\n+\tLONG $0x01000548; WORD $0x0000             // add    rax, 256\n+\tLONG $0x00c18148; WORD $0xffff; BYTE $0xff // add    rcx, -256\n+\tJNE  LBB0_9\n+\n+LBB0_10:\n+\tWORD $0x3949; BYTE $0xf2 // cmp    r10, rsi\n+\tJE   LBB0_13\n+\tWORD $0x014c; BYTE $0xc7 // add    rdi, r8\n+\n+LBB0_12:\n+\tWORD $0x1788             // mov    byte [rdi], dl\n+\tWORD $0xff48; BYTE $0xc7 // inc    rdi\n+\tWORD $0x3949; BYTE $0xfb // cmp    r11, rdi\n+\tJNE  LBB0_12\n+\n+LBB0_13:\n+\tRET\ndiff --git a/go/arrow/memory/memory_test.go b/go/arrow/memory/memory_test.go\nnew file mode 100644\nindex 000000000..2ee5bfbe8\n--- /dev/null\n+++ b/go/arrow/memory/memory_test.go\n@@ -0,0 +1,125 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package memory_test\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/arrow/go/arrow/memory\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func makeExpectedBuf(sz, lo, hi int, c byte) []byte {\n+\tbuf := make([]byte, sz)\n+\tfor i := lo; i < hi; i++ {\n+\t\tbuf[i] = c\n+\t}\n+\treturn buf\n+}\n+\n+func TestSet(t *testing.T) {\n+\ttests := []struct {\n+\t\tname   string\n+\t\tsz     int\n+\t\tlo, hi int\n+\t\tc      byte\n+\t}{\n+\t\t{\"sz=0\", 0, 0, 0, 0x00},\n+\t\t{\"all,sz=7\", 7, 0, 7, 0x1f},\n+\t\t{\"part,sz=7\", 7, 3, 4, 0x1f},\n+\t\t{\"last,sz=7\", 7, 6, 7, 0x1f},\n+\t\t{\"all,sz=25\", 25, 0, 25, 0x1f},\n+\t\t{\"part,sz=25\", 25, 13, 19, 0x1f},\n+\t\t{\"last,sz=25\", 25, 24, 25, 0x1f},\n+\t\t{\"all,sz=4096\", 4096, 0, 4096, 0x1f},\n+\t\t{\"part,sz=4096\", 4096, 1000, 3000, 0x1f},\n+\t\t{\"last,sz=4096\", 4096, 4095, 4096, 0x1f},\n+\t\t{\"all,sz=16384\", 16384, 0, 16384, 0x1f},\n+\t\t{\"part,sz=16384\", 16384, 3333, 10000, 0x1f},\n+\t\t{\"last,sz=16384\", 16384, 16383, 16384, 0x1f},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tbuf := make([]byte, test.sz)\n+\t\t\tmemory.Set(buf[test.lo:test.hi], test.c)\n+\t\t\texp := makeExpectedBuf(test.sz, test.lo, test.hi, test.c)\n+\t\t\tassert.Equal(t, exp, buf)\n+\t\t})\n+\t}\n+}\n+\n+func benchmarkSet(b *testing.B, n int64) {\n+\tbuf := make([]byte, n)\n+\tb.SetBytes(n)\n+\tb.ResetTimer()\n+\n+\tfor i := 0; i < b.N; i++ {\n+\t\tmemory.Set(buf, 0x1f)\n+\t}\n+}\n+\n+func BenchmarkSet_8(b *testing.B) {\n+\tbenchmarkSet(b, 8)\n+}\n+\n+func BenchmarkSet_32(b *testing.B) {\n+\tbenchmarkSet(b, 32)\n+}\n+\n+func BenchmarkSet_64(b *testing.B) {\n+\tbenchmarkSet(b, 64)\n+}\n+\n+func BenchmarkSet_500(b *testing.B) {\n+\tbenchmarkSet(b, 500)\n+}\n+\n+func BenchmarkSet_512(b *testing.B) {\n+\tbenchmarkSet(b, 512)\n+}\n+\n+func BenchmarkSet_1000(b *testing.B) {\n+\tbenchmarkSet(b, 1000)\n+}\n+\n+func BenchmarkSet_1024(b *testing.B) {\n+\tbenchmarkSet(b, 1024)\n+}\n+\n+func BenchmarkSet_2000(b *testing.B) {\n+\tbenchmarkSet(b, 2000)\n+}\n+\n+func BenchmarkSet_2048(b *testing.B) {\n+\tbenchmarkSet(b, 2048)\n+}\n+\n+func BenchmarkSet_4000(b *testing.B) {\n+\tbenchmarkSet(b, 4000)\n+}\n+\n+func BenchmarkSet_4096(b *testing.B) {\n+\tbenchmarkSet(b, 4096)\n+}\n+\n+func BenchmarkSet_8000(b *testing.B) {\n+\tbenchmarkSet(b, 8000)\n+}\n+\n+func BenchmarkSet_8192(b *testing.B) {\n+\tbenchmarkSet(b, 8192)\n+}\ndiff --git a/go/arrow/memory/util.go b/go/arrow/memory/util.go\nnew file mode 100644\nindex 000000000..3b0d3a5cb\n--- /dev/null\n+++ b/go/arrow/memory/util.go\n@@ -0,0 +1,37 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package memory\n+\n+import \"unsafe\"\n+\n+func roundToPowerOf2(v, round int) int {\n+\tforceCarry := round - 1\n+\ttruncateMask := ^forceCarry\n+\treturn (v + forceCarry) & truncateMask\n+}\n+\n+func roundUpToMultipleOf64(v int) int {\n+\treturn roundToPowerOf2(v, 64)\n+}\n+\n+func isMultipleOfPowerOf2(v int, d int) bool {\n+\treturn (v & (d - 1)) == 0\n+}\n+\n+func addressOf(b []byte) uintptr {\n+\treturn uintptr(unsafe.Pointer(&b[0]))\n+}\ndiff --git a/go/arrow/memory/util_test.go b/go/arrow/memory/util_test.go\nnew file mode 100644\nindex 000000000..d8afe80a0\n--- /dev/null\n+++ b/go/arrow/memory/util_test.go\n@@ -0,0 +1,61 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package memory\n+\n+import (\n+\t\"fmt\"\n+\t\"testing\"\n+\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+func TestRoundToPowerOf2(t *testing.T) {\n+\ttests := []struct {\n+\t\tv, round int\n+\t\texp      int\n+\t}{\n+\t\t{60, 64, 64},\n+\t\t{122, 64, 128},\n+\t\t{16, 64, 64},\n+\t\t{64, 64, 64},\n+\t\t{13, 8, 16},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(fmt.Sprintf(\"v%d_r%d\", test.v, test.round), func(t *testing.T) {\n+\t\t\ta := roundToPowerOf2(test.v, test.round)\n+\t\t\tassert.Equal(t, test.exp, a)\n+\t\t})\n+\t}\n+}\n+\n+func TestIsMultipleOfPowerOf2(t *testing.T) {\n+\ttests := []struct {\n+\t\tv, d int\n+\t\texp  bool\n+\t}{\n+\t\t{200, 256, false},\n+\t\t{256, 256, true},\n+\t\t{500, 256, false},\n+\t\t{512, 256, true},\n+\t}\n+\tfor _, test := range tests {\n+\t\tt.Run(fmt.Sprintf(\"%d_%d_%t\", test.v, test.d, test.exp), func(t *testing.T) {\n+\t\t\tgot := isMultipleOfPowerOf2(test.v, test.d)\n+\t\t\tassert.Equal(t, test.exp, got)\n+\t\t})\n+\t}\n+}\ndiff --git a/go/arrow/metadata/schema.go b/go/arrow/metadata/schema.go\nnew file mode 100644\nindex 000000000..021b6ee53\n--- /dev/null\n+++ b/go/arrow/metadata/schema.go\n@@ -0,0 +1,37 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metadata\n+\n+import \"github.com/apache/arrow/go/arrow\"\n+\n+type Schema struct {\n+\tfields      []Field\n+\tnameToIndex map[string]int\n+\tmetadata    KeyValueMetadata\n+}\n+\n+type Field struct {\n+\tname     string           // Field name\n+\ttyp      arrow.DataType   // The field's data type\n+\tnullable bool             // Fields can be nullable\n+\tmetadata KeyValueMetadata // The field's metadata, if any\n+}\n+\n+type KeyValueMetadata struct {\n+\tkeys   []string\n+\tvalues []string\n+}\ndiff --git a/go/arrow/numeric.schema.json b/go/arrow/numeric.schema.json\nnew file mode 100644\nindex 000000000..7fa2800a5\n--- /dev/null\n+++ b/go/arrow/numeric.schema.json\n@@ -0,0 +1,15 @@\n+{\n+  \"title\": \"templates\",\n+  \"type\": \"array\",\n+  \"items\": {\n+    \"title\": \"template\",\n+    \"type\": \"object\",\n+    \"properties\": {\n+      \"Name\": {\n+        \"type\": \"string\",\n+        \"description\": \"The name of the template type\"\n+      }\n+    },\n+    \"required\": [\"Name\"]\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/go/arrow/numeric.tmpldata b/go/arrow/numeric.tmpldata\nnew file mode 100644\nindex 000000000..ea08d8bde\n--- /dev/null\n+++ b/go/arrow/numeric.tmpldata\n@@ -0,0 +1,87 @@\n+[\n+  {\n+    \"Name\": \"Int64\",\n+    \"name\": \"int64\",\n+    \"Type\": \"int64\",\n+    \"Default\": \"0\",\n+    \"Size\": \"8\"\n+  },\n+  {\n+    \"Name\": \"Uint64\",\n+    \"name\": \"uint64\",\n+    \"Type\": \"uint64\",\n+    \"Default\": \"0\",\n+    \"Size\": \"8\"\n+  },\n+  {\n+    \"Name\": \"Float64\",\n+    \"name\": \"float64\",\n+    \"Type\": \"float64\",\n+    \"Default\": \"0\",\n+    \"Size\": \"8\"\n+  },\n+  {\n+    \"Name\": \"Int32\",\n+    \"name\": \"int32\",\n+    \"Type\": \"int32\",\n+    \"Default\": \"0\",\n+    \"Size\": \"4\",\n+    \"Opt\": {\n+      \"BufferBuilder\": true\n+    }\n+  },\n+  {\n+    \"Name\": \"Uint32\",\n+    \"name\": \"uint32\",\n+    \"Type\": \"uint32\",\n+    \"Default\": \"0\",\n+    \"Size\": \"4\"\n+  },\n+  {\n+    \"Name\": \"Float32\",\n+    \"name\": \"float32\",\n+    \"Type\": \"float32\",\n+    \"Default\": \"0\",\n+    \"Size\": \"4\"\n+  },\n+  {\n+    \"Name\": \"Int16\",\n+    \"name\": \"int16\",\n+    \"Type\": \"int16\",\n+    \"Default\": \"0\",\n+    \"Size\": \"2\"\n+  },\n+  {\n+    \"Name\": \"Uint16\",\n+    \"name\": \"uint16\",\n+    \"Type\": \"uint16\",\n+    \"Default\": \"0\",\n+    \"Size\": \"2\"\n+  },\n+  {\n+    \"Name\": \"Int8\",\n+    \"name\": \"int8\",\n+    \"Type\": \"int8\",\n+    \"Default\": \"0\",\n+    \"Size\": \"1\"\n+  },\n+  {\n+    \"Name\": \"Uint8\",\n+    \"name\": \"uint8\",\n+    \"Type\": \"uint8\",\n+    \"Default\": \"0\",\n+    \"Size\": \"1\"\n+  },\n+  {\n+    \"Name\": \"Timestamp\",\n+    \"name\": \"timestamp\",\n+    \"Type\": \"Timestamp\",\n+    \"QualifiedType\": \"arrow.Timestamp\",\n+    \"InternalType\": \"int64\",\n+    \"Default\": \"0\",\n+    \"Size\": \"8\",\n+    \"Opt\": {\n+      \"Parametric\": true\n+    }\n+  }\n+]\n\\ No newline at end of file\ndiff --git a/go/arrow/type_string.go b/go/arrow/type_string.go\nnew file mode 100644\nindex 000000000..9c82dbad4\n--- /dev/null\n+++ b/go/arrow/type_string.go\n@@ -0,0 +1,16 @@\n+// Code generated by \"stringer -type=Type\"; DO NOT EDIT.\n+\n+package arrow\n+\n+import \"fmt\"\n+\n+const _Type_name = \"NULLBOOLUINT8INT8UINT16INT16UINT32INT32UINT64INT64HALF_FLOATFLOAT32FLOAT64STRINGBINARYFIXED_SIZE_BINARYDATE32DATE64TIMESTAMPTIME32TIME64INTERVALDECIMALLISTSTRUCTUNIONDICTIONARYMAP\"\n+\n+var _Type_index = [...]uint8{0, 4, 8, 13, 17, 23, 28, 34, 39, 45, 50, 60, 67, 74, 80, 86, 103, 109, 115, 124, 130, 136, 144, 151, 155, 161, 166, 176, 179}\n+\n+func (i Type) String() string {\n+\tif i < 0 || i >= Type(len(_Type_index)-1) {\n+\t\treturn fmt.Sprintf(\"Type(%d)\", i)\n+\t}\n+\treturn _Type_name[_Type_index[i]:_Type_index[i+1]]\n+}\ndiff --git a/go/arrow/type_traits_boolean.go b/go/arrow/type_traits_boolean.go\nnew file mode 100644\nindex 000000000..c30ae0fec\n--- /dev/null\n+++ b/go/arrow/type_traits_boolean.go\n@@ -0,0 +1,28 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package arrow\n+\n+import (\n+\t\"github.com/apache/arrow/go/arrow/internal/bitutil\"\n+)\n+\n+type booleanTraits struct{}\n+\n+var BooleanTraits booleanTraits\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func (booleanTraits) BytesRequired(n int) int { return bitutil.CeilByte(n) / 8 }\ndiff --git a/go/arrow/type_traits_numeric.gen.go b/go/arrow/type_traits_numeric.gen.go\nnew file mode 100644\nindex 000000000..b51960b6d\n--- /dev/null\n+++ b/go/arrow/type_traits_numeric.gen.go\n@@ -0,0 +1,567 @@\n+// Code generated by type_traits_numeric.gen.go.tmpl. DO NOT EDIT.\n+\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package arrow\n+\n+import (\n+\t\"encoding/binary\"\n+\t\"reflect\"\n+\t\"unsafe\"\n+)\n+\n+var (\n+\tInt64Traits     int64Traits\n+\tUint64Traits    uint64Traits\n+\tFloat64Traits   float64Traits\n+\tInt32Traits     int32Traits\n+\tUint32Traits    uint32Traits\n+\tFloat32Traits   float32Traits\n+\tInt16Traits     int16Traits\n+\tUint16Traits    uint16Traits\n+\tInt8Traits      int8Traits\n+\tUint8Traits     uint8Traits\n+\tTimestampTraits timestampTraits\n+)\n+\n+// Int64 traits\n+\n+const (\n+\t// Int64SizeBytes specifies the number of bytes required to store a single int64 in memory\n+\tInt64SizeBytes = int(unsafe.Sizeof(int64(0)))\n+)\n+\n+type int64Traits struct{}\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func (int64Traits) BytesRequired(n int) int { return Int64SizeBytes * n }\n+\n+// PutValue\n+func (int64Traits) PutValue(b []byte, v int64) {\n+\tbinary.LittleEndian.PutUint64(b, uint64(v))\n+}\n+\n+// CastFromBytes reinterprets the slice b to a slice of type int64.\n+//\n+// NOTE: len(b) must be a multiple of Int64SizeBytes.\n+func (int64Traits) CastFromBytes(b []byte) []int64 {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []int64\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len / Int64SizeBytes\n+\ts.Cap = h.Cap / Int64SizeBytes\n+\n+\treturn res\n+}\n+\n+// CastToBytes reinterprets the slice b to a slice of bytes.\n+func (int64Traits) CastToBytes(b []int64) []byte {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []byte\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len * Int64SizeBytes\n+\ts.Cap = h.Cap * Int64SizeBytes\n+\n+\treturn res\n+}\n+\n+// Copy copies src to dst.\n+func (int64Traits) Copy(dst, src []int64) { copy(dst, src) }\n+\n+// Uint64 traits\n+\n+const (\n+\t// Uint64SizeBytes specifies the number of bytes required to store a single uint64 in memory\n+\tUint64SizeBytes = int(unsafe.Sizeof(uint64(0)))\n+)\n+\n+type uint64Traits struct{}\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func (uint64Traits) BytesRequired(n int) int { return Uint64SizeBytes * n }\n+\n+// PutValue\n+func (uint64Traits) PutValue(b []byte, v uint64) {\n+\tbinary.LittleEndian.PutUint64(b, uint64(v))\n+}\n+\n+// CastFromBytes reinterprets the slice b to a slice of type uint64.\n+//\n+// NOTE: len(b) must be a multiple of Uint64SizeBytes.\n+func (uint64Traits) CastFromBytes(b []byte) []uint64 {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []uint64\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len / Uint64SizeBytes\n+\ts.Cap = h.Cap / Uint64SizeBytes\n+\n+\treturn res\n+}\n+\n+// CastToBytes reinterprets the slice b to a slice of bytes.\n+func (uint64Traits) CastToBytes(b []uint64) []byte {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []byte\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len * Uint64SizeBytes\n+\ts.Cap = h.Cap * Uint64SizeBytes\n+\n+\treturn res\n+}\n+\n+// Copy copies src to dst.\n+func (uint64Traits) Copy(dst, src []uint64) { copy(dst, src) }\n+\n+// Float64 traits\n+\n+const (\n+\t// Float64SizeBytes specifies the number of bytes required to store a single float64 in memory\n+\tFloat64SizeBytes = int(unsafe.Sizeof(float64(0)))\n+)\n+\n+type float64Traits struct{}\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func (float64Traits) BytesRequired(n int) int { return Float64SizeBytes * n }\n+\n+// PutValue\n+func (float64Traits) PutValue(b []byte, v float64) {\n+\tbinary.LittleEndian.PutUint64(b, uint64(v))\n+}\n+\n+// CastFromBytes reinterprets the slice b to a slice of type float64.\n+//\n+// NOTE: len(b) must be a multiple of Float64SizeBytes.\n+func (float64Traits) CastFromBytes(b []byte) []float64 {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []float64\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len / Float64SizeBytes\n+\ts.Cap = h.Cap / Float64SizeBytes\n+\n+\treturn res\n+}\n+\n+// CastToBytes reinterprets the slice b to a slice of bytes.\n+func (float64Traits) CastToBytes(b []float64) []byte {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []byte\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len * Float64SizeBytes\n+\ts.Cap = h.Cap * Float64SizeBytes\n+\n+\treturn res\n+}\n+\n+// Copy copies src to dst.\n+func (float64Traits) Copy(dst, src []float64) { copy(dst, src) }\n+\n+// Int32 traits\n+\n+const (\n+\t// Int32SizeBytes specifies the number of bytes required to store a single int32 in memory\n+\tInt32SizeBytes = int(unsafe.Sizeof(int32(0)))\n+)\n+\n+type int32Traits struct{}\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func (int32Traits) BytesRequired(n int) int { return Int32SizeBytes * n }\n+\n+// PutValue\n+func (int32Traits) PutValue(b []byte, v int32) {\n+\tbinary.LittleEndian.PutUint32(b, uint32(v))\n+}\n+\n+// CastFromBytes reinterprets the slice b to a slice of type int32.\n+//\n+// NOTE: len(b) must be a multiple of Int32SizeBytes.\n+func (int32Traits) CastFromBytes(b []byte) []int32 {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []int32\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len / Int32SizeBytes\n+\ts.Cap = h.Cap / Int32SizeBytes\n+\n+\treturn res\n+}\n+\n+// CastToBytes reinterprets the slice b to a slice of bytes.\n+func (int32Traits) CastToBytes(b []int32) []byte {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []byte\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len * Int32SizeBytes\n+\ts.Cap = h.Cap * Int32SizeBytes\n+\n+\treturn res\n+}\n+\n+// Copy copies src to dst.\n+func (int32Traits) Copy(dst, src []int32) { copy(dst, src) }\n+\n+// Uint32 traits\n+\n+const (\n+\t// Uint32SizeBytes specifies the number of bytes required to store a single uint32 in memory\n+\tUint32SizeBytes = int(unsafe.Sizeof(uint32(0)))\n+)\n+\n+type uint32Traits struct{}\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func (uint32Traits) BytesRequired(n int) int { return Uint32SizeBytes * n }\n+\n+// PutValue\n+func (uint32Traits) PutValue(b []byte, v uint32) {\n+\tbinary.LittleEndian.PutUint32(b, uint32(v))\n+}\n+\n+// CastFromBytes reinterprets the slice b to a slice of type uint32.\n+//\n+// NOTE: len(b) must be a multiple of Uint32SizeBytes.\n+func (uint32Traits) CastFromBytes(b []byte) []uint32 {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []uint32\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len / Uint32SizeBytes\n+\ts.Cap = h.Cap / Uint32SizeBytes\n+\n+\treturn res\n+}\n+\n+// CastToBytes reinterprets the slice b to a slice of bytes.\n+func (uint32Traits) CastToBytes(b []uint32) []byte {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []byte\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len * Uint32SizeBytes\n+\ts.Cap = h.Cap * Uint32SizeBytes\n+\n+\treturn res\n+}\n+\n+// Copy copies src to dst.\n+func (uint32Traits) Copy(dst, src []uint32) { copy(dst, src) }\n+\n+// Float32 traits\n+\n+const (\n+\t// Float32SizeBytes specifies the number of bytes required to store a single float32 in memory\n+\tFloat32SizeBytes = int(unsafe.Sizeof(float32(0)))\n+)\n+\n+type float32Traits struct{}\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func (float32Traits) BytesRequired(n int) int { return Float32SizeBytes * n }\n+\n+// PutValue\n+func (float32Traits) PutValue(b []byte, v float32) {\n+\tbinary.LittleEndian.PutUint32(b, uint32(v))\n+}\n+\n+// CastFromBytes reinterprets the slice b to a slice of type float32.\n+//\n+// NOTE: len(b) must be a multiple of Float32SizeBytes.\n+func (float32Traits) CastFromBytes(b []byte) []float32 {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []float32\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len / Float32SizeBytes\n+\ts.Cap = h.Cap / Float32SizeBytes\n+\n+\treturn res\n+}\n+\n+// CastToBytes reinterprets the slice b to a slice of bytes.\n+func (float32Traits) CastToBytes(b []float32) []byte {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []byte\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len * Float32SizeBytes\n+\ts.Cap = h.Cap * Float32SizeBytes\n+\n+\treturn res\n+}\n+\n+// Copy copies src to dst.\n+func (float32Traits) Copy(dst, src []float32) { copy(dst, src) }\n+\n+// Int16 traits\n+\n+const (\n+\t// Int16SizeBytes specifies the number of bytes required to store a single int16 in memory\n+\tInt16SizeBytes = int(unsafe.Sizeof(int16(0)))\n+)\n+\n+type int16Traits struct{}\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func (int16Traits) BytesRequired(n int) int { return Int16SizeBytes * n }\n+\n+// PutValue\n+func (int16Traits) PutValue(b []byte, v int16) {\n+\tbinary.LittleEndian.PutUint16(b, uint16(v))\n+}\n+\n+// CastFromBytes reinterprets the slice b to a slice of type int16.\n+//\n+// NOTE: len(b) must be a multiple of Int16SizeBytes.\n+func (int16Traits) CastFromBytes(b []byte) []int16 {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []int16\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len / Int16SizeBytes\n+\ts.Cap = h.Cap / Int16SizeBytes\n+\n+\treturn res\n+}\n+\n+// CastToBytes reinterprets the slice b to a slice of bytes.\n+func (int16Traits) CastToBytes(b []int16) []byte {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []byte\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len * Int16SizeBytes\n+\ts.Cap = h.Cap * Int16SizeBytes\n+\n+\treturn res\n+}\n+\n+// Copy copies src to dst.\n+func (int16Traits) Copy(dst, src []int16) { copy(dst, src) }\n+\n+// Uint16 traits\n+\n+const (\n+\t// Uint16SizeBytes specifies the number of bytes required to store a single uint16 in memory\n+\tUint16SizeBytes = int(unsafe.Sizeof(uint16(0)))\n+)\n+\n+type uint16Traits struct{}\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func (uint16Traits) BytesRequired(n int) int { return Uint16SizeBytes * n }\n+\n+// PutValue\n+func (uint16Traits) PutValue(b []byte, v uint16) {\n+\tbinary.LittleEndian.PutUint16(b, uint16(v))\n+}\n+\n+// CastFromBytes reinterprets the slice b to a slice of type uint16.\n+//\n+// NOTE: len(b) must be a multiple of Uint16SizeBytes.\n+func (uint16Traits) CastFromBytes(b []byte) []uint16 {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []uint16\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len / Uint16SizeBytes\n+\ts.Cap = h.Cap / Uint16SizeBytes\n+\n+\treturn res\n+}\n+\n+// CastToBytes reinterprets the slice b to a slice of bytes.\n+func (uint16Traits) CastToBytes(b []uint16) []byte {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []byte\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len * Uint16SizeBytes\n+\ts.Cap = h.Cap * Uint16SizeBytes\n+\n+\treturn res\n+}\n+\n+// Copy copies src to dst.\n+func (uint16Traits) Copy(dst, src []uint16) { copy(dst, src) }\n+\n+// Int8 traits\n+\n+const (\n+\t// Int8SizeBytes specifies the number of bytes required to store a single int8 in memory\n+\tInt8SizeBytes = int(unsafe.Sizeof(int8(0)))\n+)\n+\n+type int8Traits struct{}\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func (int8Traits) BytesRequired(n int) int { return Int8SizeBytes * n }\n+\n+// PutValue\n+func (int8Traits) PutValue(b []byte, v int8) {\n+\tb[0] = byte(v)\n+}\n+\n+// CastFromBytes reinterprets the slice b to a slice of type int8.\n+//\n+// NOTE: len(b) must be a multiple of Int8SizeBytes.\n+func (int8Traits) CastFromBytes(b []byte) []int8 {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []int8\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len / Int8SizeBytes\n+\ts.Cap = h.Cap / Int8SizeBytes\n+\n+\treturn res\n+}\n+\n+// CastToBytes reinterprets the slice b to a slice of bytes.\n+func (int8Traits) CastToBytes(b []int8) []byte {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []byte\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len * Int8SizeBytes\n+\ts.Cap = h.Cap * Int8SizeBytes\n+\n+\treturn res\n+}\n+\n+// Copy copies src to dst.\n+func (int8Traits) Copy(dst, src []int8) { copy(dst, src) }\n+\n+// Uint8 traits\n+\n+const (\n+\t// Uint8SizeBytes specifies the number of bytes required to store a single uint8 in memory\n+\tUint8SizeBytes = int(unsafe.Sizeof(uint8(0)))\n+)\n+\n+type uint8Traits struct{}\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func (uint8Traits) BytesRequired(n int) int { return Uint8SizeBytes * n }\n+\n+// PutValue\n+func (uint8Traits) PutValue(b []byte, v uint8) {\n+\tb[0] = byte(v)\n+}\n+\n+// CastFromBytes reinterprets the slice b to a slice of type uint8.\n+//\n+// NOTE: len(b) must be a multiple of Uint8SizeBytes.\n+func (uint8Traits) CastFromBytes(b []byte) []uint8 {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []uint8\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len / Uint8SizeBytes\n+\ts.Cap = h.Cap / Uint8SizeBytes\n+\n+\treturn res\n+}\n+\n+// CastToBytes reinterprets the slice b to a slice of bytes.\n+func (uint8Traits) CastToBytes(b []uint8) []byte {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []byte\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len * Uint8SizeBytes\n+\ts.Cap = h.Cap * Uint8SizeBytes\n+\n+\treturn res\n+}\n+\n+// Copy copies src to dst.\n+func (uint8Traits) Copy(dst, src []uint8) { copy(dst, src) }\n+\n+// Timestamp traits\n+\n+const (\n+\t// TimestampSizeBytes specifies the number of bytes required to store a single Timestamp in memory\n+\tTimestampSizeBytes = int(unsafe.Sizeof(Timestamp(0)))\n+)\n+\n+type timestampTraits struct{}\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func (timestampTraits) BytesRequired(n int) int { return TimestampSizeBytes * n }\n+\n+// PutValue\n+func (timestampTraits) PutValue(b []byte, v Timestamp) {\n+\tbinary.LittleEndian.PutUint64(b, uint64(v))\n+}\n+\n+// CastFromBytes reinterprets the slice b to a slice of type Timestamp.\n+//\n+// NOTE: len(b) must be a multiple of TimestampSizeBytes.\n+func (timestampTraits) CastFromBytes(b []byte) []Timestamp {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []Timestamp\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len / TimestampSizeBytes\n+\ts.Cap = h.Cap / TimestampSizeBytes\n+\n+\treturn res\n+}\n+\n+// CastToBytes reinterprets the slice b to a slice of bytes.\n+func (timestampTraits) CastToBytes(b []Timestamp) []byte {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []byte\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len * TimestampSizeBytes\n+\ts.Cap = h.Cap * TimestampSizeBytes\n+\n+\treturn res\n+}\n+\n+// Copy copies src to dst.\n+func (timestampTraits) Copy(dst, src []Timestamp) { copy(dst, src) }\ndiff --git a/go/arrow/type_traits_numeric.gen.go.tmpl b/go/arrow/type_traits_numeric.gen.go.tmpl\nnew file mode 100644\nindex 000000000..362d2d850\n--- /dev/null\n+++ b/go/arrow/type_traits_numeric.gen.go.tmpl\n@@ -0,0 +1,89 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package arrow\n+\n+import (\n+\t\"encoding/binary\"\n+\t\"reflect\"\n+\t\"unsafe\"\n+)\n+\n+var (\n+{{range .In}}\n+\t{{.Name}}Traits {{.name}}Traits\n+{{- end}}\n+)\n+\n+{{range .In}}\n+// {{.Name}} traits\n+\n+const (\n+\t// {{.Name}}SizeBytes specifies the number of bytes required to store a single {{.Type}} in memory\n+\t{{.Name}}SizeBytes = int(unsafe.Sizeof({{.Type}}({{.Default}})))\n+)\n+\n+type {{.name}}Traits struct{}\n+\n+// BytesRequired returns the number of bytes required to store n elements in memory.\n+func ({{.name}}Traits) BytesRequired(n int) int { return {{.Name}}SizeBytes * n }\n+\n+// PutValue\n+func ({{.name}}Traits) PutValue(b []byte, v {{.Type}}) {\n+{{- if eq .Size \"1\" -}}\n+\tb[0] = byte(v)\n+{{- else if eq .Size \"2\" -}}\n+\tbinary.LittleEndian.PutUint16(b, uint16(v))\n+{{- else if eq .Size \"4\" -}}\n+\tbinary.LittleEndian.PutUint32(b, uint32(v))\n+{{- else if eq .Size \"8\" -}}\n+\tbinary.LittleEndian.PutUint64(b, uint64(v))\n+{{- else -}}\n+\tpanic(\"invalid type {{.Type}}\")\n+{{end}}\n+}\n+\n+// CastFromBytes reinterprets the slice b to a slice of type {{.Type}}.\n+//\n+// NOTE: len(b) must be a multiple of {{.Name}}SizeBytes.\n+func ({{.name}}Traits) CastFromBytes(b []byte) []{{.Type}} {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []{{.Type}}\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len/{{.Name}}SizeBytes\n+\ts.Cap = h.Cap/{{.Name}}SizeBytes\n+\n+\treturn res\n+}\n+\n+// CastToBytes reinterprets the slice b to a slice of bytes.\n+func ({{.name}}Traits) CastToBytes(b []{{.Type}}) []byte {\n+\th := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n+\n+\tvar res []byte\n+\ts := (*reflect.SliceHeader)(unsafe.Pointer(&res))\n+\ts.Data = h.Data\n+\ts.Len = h.Len*{{.Name}}SizeBytes\n+\ts.Cap = h.Cap*{{.Name}}SizeBytes\n+\n+\treturn res\n+}\n+\n+// Copy copies src to dst.\n+func ({{.name}}Traits) Copy(dst, src []{{.Type}}) { copy(dst, src) }\n+{{end}}\n\\ No newline at end of file\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-21T20:04:29.862+0000",
                    "updated": "2018-03-21T20:04:29.862+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16408497",
                    "id": "16408497",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1739: ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739#issuecomment-375077863\n \n \n   thanks @stuartcarnie! Would you mind creating an ID on JIRA so I can assign this to you https://issues.apache.org/jira/browse/ARROW-2299?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-21T20:05:03.151+0000",
                    "updated": "2018-03-21T20:05:03.151+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16408500",
                    "id": "16408500",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1739: ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739#issuecomment-375078570\n \n \n   Please let me know if you have opinions on https://issues.apache.org/jira/browse/ARROW-2335\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-21T20:07:34.797+0000",
                    "updated": "2018-03-21T20:07:34.797+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16408504",
                    "id": "16408504",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "stuartcarnie commented on issue #1739: ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739#issuecomment-375079827\n \n \n   @wesm done \u2013 username is same as GH\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-21T20:11:57.265+0000",
                    "updated": "2018-03-21T20:11:57.265+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13144590/comment/16408508",
                    "id": "16408508",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "wesm commented on issue #1739: ARROW-2299: [Go] Import Go arrow implementation from influxdata/arrow\nURL: https://github.com/apache/arrow/pull/1739#issuecomment-375080481\n \n \n   Great, thanks, I added you to the contributor list (so you can assign yourself JIRAs) and assigned this one to you\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-03-21T20:14:06.220+0000",
                    "updated": "2018-03-21T20:14:06.220+0000"
                }
            ],
            "maxResults": 14,
            "total": 14,
            "startAt": 0
        },
        "customfield_12311820": "0|i3r7lj:",
        "customfield_12314139": null
    }
}