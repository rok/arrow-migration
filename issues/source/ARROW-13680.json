{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13396255",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255",
    "key": "ARROW-13680",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350323",
                "id": "12350323",
                "description": "",
                "name": "6.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-10-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available",
            "query-engine"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 21000,
            "total": 21000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 21000,
            "total": 21000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13680/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 35,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/640115",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace opened a new pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968\n\n\n   Any type that wants to participate in an asynchronous nursery must extend `AsyncCloseable`.  These types can then communicate work that needs to be finished before the nursery can close in several ways.\r\n   \r\n    * Provide an overridden DoClose method that returns a future indicating when work is done\r\n    * Add children\r\n    * Add dependent tasks\r\n   \r\n   An AsyncCloseable is _finished_ when the future returned by DoClose has completed and any dependent tasks have completed and all of its children are _finished_.\r\n   \r\n   An object will not be destroyed until it is _finished_.  This means you can safely capture `this` (and references to parent state).\r\n   \r\n   For a real world example take a look at `dataset_writer.cc` in #10955 which uses an async nursery to capture a dataset writer, it's children (directory queues) and grandchildren (file queues).  File queues can be evicted from the nursery early.  The dataset writer is not \"finished\" until all queued files have been written.  `this` and `&` captures are used freely throughout the code.\r\n   \r\n   Cons:\r\n   \r\n    * It's a bit tricky to get it working with the pimpl pattern but `NurseryPimpl` helps here\r\n    * There are a lot of \"nursery-like\" objects starting to pop up (IOContext, ExecContext, cancellation tokens, ...) and we may want to consolidate at some point\r\n    * Doesn't really get rid of shared_ptr's so much as it hides them.  Objects owned by the nursery must be shared_ptr.  Can use \"dependent tasks\" to avoid creating a shared_ptr however.\r\n   \r\n   ToDo:\r\n   \r\n    * Investigate simply passing the nursery down by reference into all of the objects instead of bothering with the parent / child relationships and requiring inheritance.\r\n    * Fix up some of the APIs with some template hackery (e.g. merging `RunInNursery` and `RunInNurserySt`)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-20T04:06:08.327+0000",
                    "updated": "2021-08-20T04:06:08.327+0000",
                    "started": "2021-08-20T04:06:08.327+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "640115",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/640116",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#issuecomment-902414443\n\n\n   https://issues.apache.org/jira/browse/ARROW-13680\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-20T04:06:32.276+0000",
                    "updated": "2021-08-20T04:06:32.276+0000",
                    "started": "2021-08-20T04:06:32.276+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "640116",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/640117",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#issuecomment-902416095\n\n\n   @pitrou @bkietz @lidavidm curious to get your thoughts on the general idea.  I think I still have at least one good overhaul (hopefully getting rid of the base classes) but so far it has been very helpful keeping the dataset writer logic clean.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-20T04:11:33.643+0000",
                    "updated": "2021-08-20T04:11:33.643+0000",
                    "started": "2021-08-20T04:11:33.642+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "640117",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/640248",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#discussion_r692938917\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.cc\n##########\n@@ -0,0 +1,127 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/async_nursery.h\"\n+\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+AsyncCloseable::AsyncCloseable(AsyncCloseable* parent) : on_closed_(Future<>::Make()) {\n+  if (parent) {\n+    Mutex::Guard guard = mutex_.Lock();\n+    parent->children_.push_back(this);\n+    self_itr_ = --parent->children_.end();\n+  }\n+}\n+\n+AsyncCloseable::~AsyncCloseable() { DCHECK(close_complete_.load()); }\n+\n+Future<> AsyncCloseable::OnClosed() { return on_closed_; }\n+\n+Future<> AsyncCloseable::Close() {\n+  {\n+    Mutex::Guard guard = mutex_.Lock();\n+    if (closed_.load()) {\n+      return Future<>::MakeFinished();\n+    }\n+    closed_.store(true);\n+  }\n+  return DoClose()\n+      .Then([this] {\n+        close_complete_.store(true);\n+        on_closed_.MarkFinished();\n+        return CloseChildren();\n+      })\n+      .Then([] {},\n+            [this](const Status& err) {\n+              close_complete_.store(true);\n+              on_closed_.MarkFinished(err);\n+              return err;\n+            });\n+}\n+\n+Future<> AsyncCloseable::CloseChildren() {\n+  for (auto& child : children_) {\n+    tasks_.push_back(child->Close());\n+  }\n+  return AllComplete(tasks_);\n+}\n+\n+Status AsyncCloseable::CheckClosed() const {\n+  if (closed_.load()) {\n+    return Status::Invalid(\"Invalid operation after Close\");\n+  }\n+  return Status::OK();\n+}\n+\n+void AsyncCloseable::AssertNotCloseComplete() const { DCHECK(!close_complete_); }\n+\n+void AsyncCloseable::AddDependentTask(Future<> task) {\n+  tasks_.push_back(std::move(task));\n+}\n+\n+OwnedAsyncCloseable::OwnedAsyncCloseable(AsyncCloseable* parent)\n+    : AsyncCloseable(parent) {\n+  parent_ = parent;\n+}\n+\n+void OwnedAsyncCloseable::Init() {\n+  Mutex::Guard lock = parent_->mutex_.Lock();\n+  parent_->owned_children_.push_back(shared_from_this());\n+  owned_self_itr_ = --parent_->owned_children_.end();\n+}\n+\n+void OwnedAsyncCloseable::Evict() {\n+  {\n+    Mutex::Guard lock = parent_->mutex_.Lock();\n+    if (parent_->closed_) {\n+      // Parent is already closing, no need to do anything, the parent will call close on\n+      // this instance eventually\n+      return;\n+    }\n+    parent_->children_.erase(self_itr_);\n+  }\n+  // We need to add a dependent task to make sure our parent does not close itself\n\nReview comment:\n       Isn't it possible for Close() to get called between this block and AddDependentTask?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,144 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_ASYNC_NURSERY_H\n+#define ARROW_ASYNC_NURSERY_H\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class OwnedAsyncCloseable;\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class AsyncCloseable {\n+ public:\n+  /// \\brief Construct an AsyncCloseable as a child of `parent`\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  Future<> OnClosed();\n+\n+ protected:\n+  /// Closes the AsyncCloseable\n+  /// This will first call DoClose and then simultaneously close all children and\n+  /// tasks_\n+  virtual Future<> Close();\n+  /// Subclasses should override this and perform any cleanup that is not captured by\n+  /// tasks_.  Once the future returned by this method finishes then this object is\n+  /// eligible for destruction and any reference to `this` may be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(Future<> task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+  /// This can be used for sanity checking that a callback is not run after close has\n+  /// been finished.  It will assert if the object has been fully closed (and `this`\n+  /// references are unsafe)\n+  void AssertNotCloseComplete() const;\n+\n+ private:\n+  Future<> CloseChildren();\n+\n+  std::list<AsyncCloseable*> children_;\n+  std::list<AsyncCloseable*>::iterator self_itr_;\n+  std::list<std::shared_ptr<AsyncCloseable>> owned_children_;\n+  std::vector<Future<>> tasks_;\n+  Future<> on_closed_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<bool> close_complete_{false};\n+  util::Mutex mutex_;\n+\n+  friend OwnedAsyncCloseable;\n+};\n+\n+/// An override of AsyncCloseable which is eligible for eviction.  Instances must be\n\nReview comment:\n       eviction == may be destroyed before the parent?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-20T13:29:15.254+0000",
                    "updated": "2021-08-20T13:29:15.254+0000",
                    "started": "2021-08-20T13:29:15.254+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "640248",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/640573",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#discussion_r693638540\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,144 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_ASYNC_NURSERY_H\n+#define ARROW_ASYNC_NURSERY_H\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class OwnedAsyncCloseable;\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class AsyncCloseable {\n+ public:\n+  /// \\brief Construct an AsyncCloseable as a child of `parent`\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  Future<> OnClosed();\n+\n+ protected:\n+  /// Closes the AsyncCloseable\n+  /// This will first call DoClose and then simultaneously close all children and\n+  /// tasks_\n+  virtual Future<> Close();\n+  /// Subclasses should override this and perform any cleanup that is not captured by\n+  /// tasks_.  Once the future returned by this method finishes then this object is\n+  /// eligible for destruction and any reference to `this` may be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(Future<> task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+  /// This can be used for sanity checking that a callback is not run after close has\n+  /// been finished.  It will assert if the object has been fully closed (and `this`\n+  /// references are unsafe)\n+  void AssertNotCloseComplete() const;\n+\n+ private:\n+  Future<> CloseChildren();\n+\n+  std::list<AsyncCloseable*> children_;\n+  std::list<AsyncCloseable*>::iterator self_itr_;\n+  std::list<std::shared_ptr<AsyncCloseable>> owned_children_;\n+  std::vector<Future<>> tasks_;\n+  Future<> on_closed_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<bool> close_complete_{false};\n+  util::Mutex mutex_;\n+\n+  friend OwnedAsyncCloseable;\n+};\n+\n+/// An override of AsyncCloseable which is eligible for eviction.  Instances must be\n\nReview comment:\n       I removed the concept of eviction.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-23T04:07:37.894+0000",
                    "updated": "2021-08-23T04:07:37.894+0000",
                    "started": "2021-08-23T04:07:37.894+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "640573",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/640883",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#discussion_r694382572\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.cc\n##########\n@@ -0,0 +1,127 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/async_nursery.h\"\n+\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+AsyncCloseable::AsyncCloseable(AsyncCloseable* parent) : on_closed_(Future<>::Make()) {\n+  if (parent) {\n+    Mutex::Guard guard = mutex_.Lock();\n+    parent->children_.push_back(this);\n+    self_itr_ = --parent->children_.end();\n+  }\n+}\n+\n+AsyncCloseable::~AsyncCloseable() { DCHECK(close_complete_.load()); }\n+\n+Future<> AsyncCloseable::OnClosed() { return on_closed_; }\n+\n+Future<> AsyncCloseable::Close() {\n+  {\n+    Mutex::Guard guard = mutex_.Lock();\n+    if (closed_.load()) {\n+      return Future<>::MakeFinished();\n+    }\n+    closed_.store(true);\n+  }\n+  return DoClose()\n+      .Then([this] {\n+        close_complete_.store(true);\n+        on_closed_.MarkFinished();\n+        return CloseChildren();\n+      })\n+      .Then([] {},\n+            [this](const Status& err) {\n+              close_complete_.store(true);\n+              on_closed_.MarkFinished(err);\n+              return err;\n+            });\n+}\n+\n+Future<> AsyncCloseable::CloseChildren() {\n+  for (auto& child : children_) {\n+    tasks_.push_back(child->Close());\n+  }\n+  return AllComplete(tasks_);\n+}\n+\n+Status AsyncCloseable::CheckClosed() const {\n+  if (closed_.load()) {\n+    return Status::Invalid(\"Invalid operation after Close\");\n+  }\n+  return Status::OK();\n+}\n+\n+void AsyncCloseable::AssertNotCloseComplete() const { DCHECK(!close_complete_); }\n+\n+void AsyncCloseable::AddDependentTask(Future<> task) {\n+  tasks_.push_back(std::move(task));\n+}\n+\n+OwnedAsyncCloseable::OwnedAsyncCloseable(AsyncCloseable* parent)\n+    : AsyncCloseable(parent) {\n+  parent_ = parent;\n+}\n+\n+void OwnedAsyncCloseable::Init() {\n+  Mutex::Guard lock = parent_->mutex_.Lock();\n+  parent_->owned_children_.push_back(shared_from_this());\n+  owned_self_itr_ = --parent_->owned_children_.end();\n+}\n+\n+void OwnedAsyncCloseable::Evict() {\n+  {\n+    Mutex::Guard lock = parent_->mutex_.Lock();\n+    if (parent_->closed_) {\n+      // Parent is already closing, no need to do anything, the parent will call close on\n+      // this instance eventually\n+      return;\n+    }\n+    parent_->children_.erase(self_itr_);\n+  }\n+  // We need to add a dependent task to make sure our parent does not close itself\n\nReview comment:\n       I think I've addressed these sorts of race conditions in the new AddDependentTask\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-23T23:50:28.800+0000",
                    "updated": "2021-08-23T23:50:28.800+0000",
                    "started": "2021-08-23T23:50:28.800+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "640883",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/641211",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#discussion_r695032545\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,157 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_ASYNC_NURSERY_H\n\nReview comment:\n       nit: I think most other headers we have use `#pragma once` (though its not standard)\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.cc\n##########\n@@ -0,0 +1,130 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/async_nursery.h\"\n+\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+AsyncCloseable::AsyncCloseable() = default;\n+AsyncCloseable::AsyncCloseable(AsyncCloseable* parent) {\n+  parent->AddDependentTask(OnClosed());\n+}\n+\n+AsyncCloseable::~AsyncCloseable() {\n+  // FIXME - Would be awesome if there were a way to enforce this at compile time\n+  DCHECK_NE(nursery_, nullptr) << \"An AsyncCloseable must be created with a nursery \"\n+                                  \"using MakeSharedCloseable or MakeUniqueCloseable\";\n+}\n+\n+const Future<>& AsyncCloseable::OnClosed() {\n+  // Lazily create the future to save effort if we don't need it\n+  if (!on_closed_.is_valid()) {\n+    on_closed_ = Future<>::Make();\n+  }\n\nReview comment:\n       I'm a bit worried about this being race-prone. So far it looks like it's only used in the one constructor, perhaps it could be inlined there?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,157 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_ASYNC_NURSERY_H\n+#define ARROW_ASYNC_NURSERY_H\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n\nReview comment:\n       Don't we still need to delete p?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-24T17:09:21.682+0000",
                    "updated": "2021-08-24T17:09:21.682+0000",
                    "started": "2021-08-24T17:09:21.681+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "641211",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/641244",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#discussion_r695089760\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,157 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_ASYNC_NURSERY_H\n+#define ARROW_ASYNC_NURSERY_H\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n\nReview comment:\n       `Destroy` self-deletes in a callback which runs on success or error.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-24T18:14:42.252+0000",
                    "updated": "2021-08-24T18:14:42.252+0000",
                    "started": "2021-08-24T18:14:42.252+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "641244",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/641246",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#discussion_r695090984\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,157 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_ASYNC_NURSERY_H\n+#define ARROW_ASYNC_NURSERY_H\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n\nReview comment:\n       Ah, I missed that, sorry for the confusion.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-24T18:16:34.477+0000",
                    "updated": "2021-08-24T18:16:34.477+0000",
                    "started": "2021-08-24T18:16:34.476+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "641246",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/642961",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#discussion_r697666997\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.cc\n##########\n@@ -0,0 +1,130 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/async_nursery.h\"\n+\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+AsyncCloseable::AsyncCloseable() = default;\n+AsyncCloseable::AsyncCloseable(AsyncCloseable* parent) {\n+  parent->AddDependentTask(OnClosed());\n+}\n+\n+AsyncCloseable::~AsyncCloseable() {\n+  // FIXME - Would be awesome if there were a way to enforce this at compile time\n+  DCHECK_NE(nursery_, nullptr) << \"An AsyncCloseable must be created with a nursery \"\n+                                  \"using MakeSharedCloseable or MakeUniqueCloseable\";\n+}\n+\n+const Future<>& AsyncCloseable::OnClosed() {\n+  // Lazily create the future to save effort if we don't need it\n+  if (!on_closed_.is_valid()) {\n+    on_closed_ = Future<>::Make();\n+  }\n\nReview comment:\n       I think you're right about the danger.  It is used elsewhere at the moment in the dataset writer PR (https://github.com/apache/arrow/pull/10955/files#diff-387ad04c2450a38044e667e07183b8265866cb3736d10acdce137c2b83737b16R345-R346).  I use it decrement the number of open writers when the file has finished writing.  So I just changed it so we always create the future.  It was a bit of a premature optimization anyways.\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,157 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_ASYNC_NURSERY_H\n\nReview comment:\n       Switched to this.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-27T19:17:18.470+0000",
                    "updated": "2021-08-27T19:17:18.470+0000",
                    "started": "2021-08-27T19:17:18.470+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "642961",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/642962",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#issuecomment-907422603\n\n\n   I've cleaned up the todos and addressed PR comments.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-27T19:18:22.283+0000",
                    "updated": "2021-08-27T19:18:22.283+0000",
                    "started": "2021-08-27T19:18:22.282+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "642962",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/642969",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#discussion_r697668642\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,155 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n+ protected:\n+  void Init(AsyncCloseable* impl);\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  AsyncCloseable* impl_;\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+};\n+\n+class ARROW_EXPORT Nursery {\n+ public:\n+  // FIXME: Add static_assert that T extends AsyncCloseable for friendlier error message\n\nReview comment:\n       nit: this fixme is fixed\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-27T19:25:34.407+0000",
                    "updated": "2021-08-27T19:25:34.407+0000",
                    "started": "2021-08-27T19:25:34.407+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "642969",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/642980",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on a change in pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#discussion_r697684632\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,155 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n+ protected:\n+  void Init(AsyncCloseable* impl);\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  AsyncCloseable* impl_;\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+};\n+\n+class ARROW_EXPORT Nursery {\n+ public:\n+  // FIXME: Add static_assert that T extends AsyncCloseable for friendlier error message\n\nReview comment:\n       Good catch.  Removed.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-27T19:52:27.861+0000",
                    "updated": "2021-08-27T19:52:27.861+0000",
                    "started": "2021-08-27T19:52:27.861+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "642980",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/643468",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#issuecomment-908354676\n\n\n   I'm trying to understand the ergonomics of this API.\r\n   If I understand correctly, nothing here actually keeps the tasks alive. What this relies upon is that the user stored the `shared_ptr` or `unique_ptr` returned by `Nursery::MakeXXXCloseable` somewhere so that lifetimes are handled correctly?\r\n   Is there a risk that these pointers may be kept alive _too long_ (and delay the `DoClose` calls accordingly)? What is the recommended strategy for using this facility?\r\n   \r\n   Did you try to use this in the codebase to check that it actually reduces the burden of managing the sequencing of destructor calls?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-30T13:43:41.979+0000",
                    "updated": "2021-08-30T13:43:41.979+0000",
                    "started": "2021-08-30T13:43:41.978+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643468",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/643469",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#discussion_r698481775\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n+ protected:\n+  void Init(AsyncCloseable* impl);\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  AsyncCloseable* impl_;\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+};\n+\n+class ARROW_EXPORT Nursery {\n+ public:\n+  template <typename T, typename... Args>\n+  typename std::enable_if<!std::is_array<T>::value, std::shared_ptr<T>>::type\n+  MakeSharedCloseable(Args&&... args) {\n\nReview comment:\n       Can you add a docstring explaining what it does?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n+ protected:\n+  void Init(AsyncCloseable* impl);\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  AsyncCloseable* impl_;\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+};\n+\n+class ARROW_EXPORT Nursery {\n+ public:\n+  template <typename T, typename... Args>\n+  typename std::enable_if<!std::is_array<T>::value, std::shared_ptr<T>>::type\n\nReview comment:\n       The `enable_if` doesn't seem useful here (especially as you have a `static_assert` below that would catch arrays)\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n\nReview comment:\n       API ergonomics question: since this is the single point of customization, would it be easier if `AsyncCloseable` took a `std::function<Future<>> close_func` parameter, instead of having to write a subclass?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.cc\n##########\n@@ -0,0 +1,123 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/async_nursery.h\"\n+\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+AsyncCloseable::AsyncCloseable() : on_closed_(Future<>::Make()) {}\n+AsyncCloseable::AsyncCloseable(AsyncCloseable* parent) : on_closed_(Future<>::Make()) {\n+  parent->AddDependentTask(OnClosed());\n+}\n+\n+AsyncCloseable::~AsyncCloseable() {\n+  DCHECK_NE(nursery_, nullptr) << \"An AsyncCloseable must be created with a nursery \"\n+                                  \"using MakeSharedCloseable or MakeUniqueCloseable\";\n+}\n+\n+const Future<>& AsyncCloseable::OnClosed() { return on_closed_; }\n+\n+void AsyncCloseable::AddDependentTask(const Future<>& task) {\n+  DCHECK(!closed_);\n+  if (num_tasks_outstanding_.fetch_add(1) == 1) {\n+    tasks_finished_ = Future<>::Make();\n+  }\n+  task.AddCallback([this](const Status& st) {\n+    if (num_tasks_outstanding_.fetch_sub(1) == 1 && closed_.load()) {\n+      tasks_finished_.MarkFinished(st);\n+    }\n+  });\n+}\n+\n+void AsyncCloseable::SetNursery(Nursery* nursery) { nursery_ = nursery; }\n+\n+void AsyncCloseable::Destroy() {\n+  DCHECK_NE(nursery_, nullptr);\n+  closed_ = true;\n+  nursery_->num_closeables_destroyed_.fetch_add(1);\n+  Future<> finish_fut;\n+  if (tasks_finished_.is_valid()) {\n+    if (num_tasks_outstanding_.fetch_sub(1) > 1) {\n+      finish_fut = AllComplete({DoClose(), tasks_finished_});\n+    } else {\n+      // Any added tasks have already finished so there is nothing to wait for\n+      finish_fut = DoClose();\n+    }\n+  } else {\n+    // No dependent tasks were added\n\nReview comment:\n       Hmm... is it possible for dependent tasks to be added after this?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.cc\n##########\n@@ -0,0 +1,123 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/async_nursery.h\"\n+\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+AsyncCloseable::AsyncCloseable() : on_closed_(Future<>::Make()) {}\n+AsyncCloseable::AsyncCloseable(AsyncCloseable* parent) : on_closed_(Future<>::Make()) {\n+  parent->AddDependentTask(OnClosed());\n+}\n+\n+AsyncCloseable::~AsyncCloseable() {\n+  DCHECK_NE(nursery_, nullptr) << \"An AsyncCloseable must be created with a nursery \"\n+                                  \"using MakeSharedCloseable or MakeUniqueCloseable\";\n+}\n+\n+const Future<>& AsyncCloseable::OnClosed() { return on_closed_; }\n+\n+void AsyncCloseable::AddDependentTask(const Future<>& task) {\n+  DCHECK(!closed_);\n+  if (num_tasks_outstanding_.fetch_add(1) == 1) {\n+    tasks_finished_ = Future<>::Make();\n+  }\n+  task.AddCallback([this](const Status& st) {\n+    if (num_tasks_outstanding_.fetch_sub(1) == 1 && closed_.load()) {\n+      tasks_finished_.MarkFinished(st);\n+    }\n+  });\n+}\n+\n+void AsyncCloseable::SetNursery(Nursery* nursery) { nursery_ = nursery; }\n+\n+void AsyncCloseable::Destroy() {\n+  DCHECK_NE(nursery_, nullptr);\n+  closed_ = true;\n+  nursery_->num_closeables_destroyed_.fetch_add(1);\n+  Future<> finish_fut;\n+  if (tasks_finished_.is_valid()) {\n+    if (num_tasks_outstanding_.fetch_sub(1) > 1) {\n+      finish_fut = AllComplete({DoClose(), tasks_finished_});\n+    } else {\n+      // Any added tasks have already finished so there is nothing to wait for\n+      finish_fut = DoClose();\n+    }\n+  } else {\n+    // No dependent tasks were added\n+    finish_fut = DoClose();\n+  }\n+  finish_fut.AddCallback([this](const Status& st) {\n+    if (on_closed_.is_valid()) {\n+      on_closed_.MarkFinished(st);\n+    }\n+    nursery_->OnTaskFinished(st);\n+    delete this;\n\nReview comment:\n       Ok, so this mandates that this object is heap-allocated using the default C++ allocator, right? Can you mention this somewhere in the docstring?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n+ protected:\n+  void Init(AsyncCloseable* impl);\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  AsyncCloseable* impl_;\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+};\n+\n+class ARROW_EXPORT Nursery {\n+ public:\n+  template <typename T, typename... Args>\n+  typename std::enable_if<!std::is_array<T>::value, std::shared_ptr<T>>::type\n+  MakeSharedCloseable(Args&&... args) {\n+    static_assert(std::is_base_of<AsyncCloseable, T>::value,\n+                  \"Nursery::MakeSharedCloseable only works with AsyncCloseable types\");\n+    num_closeables_created_.fetch_add(1);\n+    num_tasks_outstanding_.fetch_add(1);\n+    std::shared_ptr<T> shared_closeable(new T(std::forward<Args&&>(args)...),\n+                                        DestroyingDeleter<T>());\n+    shared_closeable->SetNursery(this);\n+    return shared_closeable;\n+  }\n+\n+  template <typename T, typename... Args>\n+  typename std::enable_if<!std::is_array<T>::value,\n+                          std::unique_ptr<T, DestroyingDeleter<T>>>::type\n\nReview comment:\n       Same remarks here.\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n+ protected:\n+  void Init(AsyncCloseable* impl);\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  AsyncCloseable* impl_;\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+};\n+\n+class ARROW_EXPORT Nursery {\n\nReview comment:\n       Can you add a docstring explaining what this is/does?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n+ protected:\n+  void Init(AsyncCloseable* impl);\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  AsyncCloseable* impl_;\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+};\n+\n+class ARROW_EXPORT Nursery {\n+ public:\n+  template <typename T, typename... Args>\n+  typename std::enable_if<!std::is_array<T>::value, std::shared_ptr<T>>::type\n+  MakeSharedCloseable(Args&&... args) {\n+    static_assert(std::is_base_of<AsyncCloseable, T>::value,\n+                  \"Nursery::MakeSharedCloseable only works with AsyncCloseable types\");\n+    num_closeables_created_.fetch_add(1);\n+    num_tasks_outstanding_.fetch_add(1);\n+    std::shared_ptr<T> shared_closeable(new T(std::forward<Args&&>(args)...),\n+                                        DestroyingDeleter<T>());\n+    shared_closeable->SetNursery(this);\n+    return shared_closeable;\n+  }\n+\n+  template <typename T, typename... Args>\n+  typename std::enable_if<!std::is_array<T>::value,\n+                          std::unique_ptr<T, DestroyingDeleter<T>>>::type\n+  MakeUniqueCloseable(Args&&... args) {\n+    static_assert(std::is_base_of<AsyncCloseable, T>::value,\n+                  \"Nursery::MakeUniqueCloseable only works with AsyncCloseable types\");\n+    num_closeables_created_.fetch_add(1);\n+    num_tasks_outstanding_.fetch_add(1);\n+    auto unique_closeable = std::unique_ptr<T, DestroyingDeleter<T>>(\n+        new T(std::forward<Args>(args)...), DestroyingDeleter<T>());\n+    unique_closeable->SetNursery(this);\n+    return unique_closeable;\n+  }\n+\n+  template <typename T>\n+  void AddDependentTask(const Future<T>& task) {\n+    num_tasks_outstanding_.fetch_add(1);\n+    task.AddCallback([this](const Result<T>& res) { OnTaskFinished(res.status()); });\n+  }\n+\n+  /// Runs `task` within a nursery.  This method will not return until\n+  /// all roots added by the task have been closed and destroyed.\n\nReview comment:\n       What are \"roots\" in this context? AsyncCloseable objects?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n\nReview comment:\n       This doesn't seem used?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n\nReview comment:\n       What is this supposed to be? Is it useful as a public API?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery_test.cc\n##########\n@@ -0,0 +1,184 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/async_nursery.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <thread>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class GatingDoClose : public AsyncCloseable {\n+ public:\n+  GatingDoClose(AsyncCloseable* parent, Future<> close_future)\n+      : AsyncCloseable(parent), close_future_(std::move(close_future)) {}\n+  explicit GatingDoClose(Future<> close_future)\n+      : close_future_(std::move(close_future)) {}\n+\n+  Future<> DoClose() override { return close_future_; }\n+\n+  Future<> close_future_;\n+};\n+\n+class GatingDoCloseWithUniqueChild : public AsyncCloseable {\n+ public:\n+  GatingDoCloseWithUniqueChild(Nursery* nursery, Future<> close_future)\n+      : child_(\n+            nursery->MakeUniqueCloseable<GatingDoClose>(this, std::move(close_future))) {}\n+\n+  Future<> DoClose() override {\n+    child_.reset();\n+    return Future<>::MakeFinished();\n+  }\n+\n+  std::unique_ptr<GatingDoClose, DestroyingDeleter<GatingDoClose>> child_;\n+};\n+\n+class GatingDoCloseWithSharedChild : public AsyncCloseable {\n+ public:\n+  GatingDoCloseWithSharedChild(Nursery* nursery, Future<> close_future)\n+      : child_(\n+            nursery->MakeSharedCloseable<GatingDoClose>(this, std::move(close_future))) {}\n+\n+  Future<> DoClose() override {\n+    child_.reset();\n+    return Future<>::MakeFinished();\n+  }\n+\n+  std::shared_ptr<GatingDoClose> child_;\n+};\n+\n+class GatingDoCloseAsDependentTask : public AsyncCloseable {\n+ public:\n+  explicit GatingDoCloseAsDependentTask(Future<> close_future) {\n+    AddDependentTask(std::move(close_future));\n+  }\n+\n+  Future<> DoClose() override { return Future<>::MakeFinished(); }\n+};\n+\n+class MarkWhenDestroyed : public GatingDoClose {\n+ public:\n+  MarkWhenDestroyed(Future<> close_future, bool* destroyed)\n+      : GatingDoClose(std::move(close_future)), destroyed_(destroyed) {}\n+  ~MarkWhenDestroyed() { *destroyed_ = true; }\n+\n+ private:\n+  bool* destroyed_;\n+};\n+\n+class EvictsChild : public AsyncCloseable {\n\nReview comment:\n       Add a comment explaining what this does/exercises?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery_test.cc\n##########\n@@ -0,0 +1,184 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/async_nursery.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <thread>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class GatingDoClose : public AsyncCloseable {\n+ public:\n+  GatingDoClose(AsyncCloseable* parent, Future<> close_future)\n+      : AsyncCloseable(parent), close_future_(std::move(close_future)) {}\n+  explicit GatingDoClose(Future<> close_future)\n+      : close_future_(std::move(close_future)) {}\n+\n+  Future<> DoClose() override { return close_future_; }\n+\n+  Future<> close_future_;\n+};\n+\n+class GatingDoCloseWithUniqueChild : public AsyncCloseable {\n+ public:\n+  GatingDoCloseWithUniqueChild(Nursery* nursery, Future<> close_future)\n+      : child_(\n+            nursery->MakeUniqueCloseable<GatingDoClose>(this, std::move(close_future))) {}\n+\n+  Future<> DoClose() override {\n+    child_.reset();\n+    return Future<>::MakeFinished();\n+  }\n+\n+  std::unique_ptr<GatingDoClose, DestroyingDeleter<GatingDoClose>> child_;\n+};\n+\n+class GatingDoCloseWithSharedChild : public AsyncCloseable {\n+ public:\n+  GatingDoCloseWithSharedChild(Nursery* nursery, Future<> close_future)\n+      : child_(\n+            nursery->MakeSharedCloseable<GatingDoClose>(this, std::move(close_future))) {}\n+\n+  Future<> DoClose() override {\n+    child_.reset();\n+    return Future<>::MakeFinished();\n+  }\n+\n+  std::shared_ptr<GatingDoClose> child_;\n+};\n+\n+class GatingDoCloseAsDependentTask : public AsyncCloseable {\n+ public:\n+  explicit GatingDoCloseAsDependentTask(Future<> close_future) {\n+    AddDependentTask(std::move(close_future));\n+  }\n+\n+  Future<> DoClose() override { return Future<>::MakeFinished(); }\n+};\n+\n+class MarkWhenDestroyed : public GatingDoClose {\n+ public:\n+  MarkWhenDestroyed(Future<> close_future, bool* destroyed)\n+      : GatingDoClose(std::move(close_future)), destroyed_(destroyed) {}\n+  ~MarkWhenDestroyed() { *destroyed_ = true; }\n+\n+ private:\n+  bool* destroyed_;\n+};\n+\n+class EvictsChild : public AsyncCloseable {\n+ public:\n+  EvictsChild(Nursery* nursery, bool* child_destroyed, Future<> child_future,\n+              Future<> final_future)\n+      : final_close_future_(std::move(final_future)) {\n+    owned_child_ = nursery->MakeSharedCloseable<MarkWhenDestroyed>(\n+        std::move(child_future), child_destroyed);\n+  }\n+\n+  void EvictChild() { owned_child_.reset(); }\n+\n+  Future<> DoClose() override { return final_close_future_; }\n+\n+ private:\n+  Future<> final_close_future_;\n+  std::shared_ptr<GatingDoClose> owned_child_;\n+};\n+\n+template <typename T>\n+void AssertDoesNotCloseEarly() {\n+  Future<> gate = Future<>::Make();\n+  std::atomic<bool> finished{false};\n+  std::thread thread([&] {\n+    ASSERT_OK(Nursery::RunInNursery(\n+        [&](Nursery* nursery) { nursery->MakeSharedCloseable<T>(gate); }));\n+    finished.store(true);\n+  });\n+\n+  SleepABit();\n+  ASSERT_FALSE(finished.load());\n+  gate.MarkFinished();\n+  BusyWait(10, [&] { return finished.load(); });\n+  thread.join();\n+}\n+\n+template <typename T>\n+void AssertDoesNotCloseEarlyWithChild() {\n+  Future<> gate = Future<>::Make();\n+  std::atomic<bool> finished{false};\n+  std::thread thread([&] {\n+    ASSERT_OK(Nursery::RunInNursery(\n+        [&](Nursery* nursery) { nursery->MakeSharedCloseable<T>(nursery, gate); }));\n+    finished.store(true);\n+  });\n+\n+  SleepABit();\n+  ASSERT_FALSE(finished.load());\n+  gate.MarkFinished();\n+  BusyWait(10, [&] { return finished.load(); });\n+  thread.join();\n+}\n+\n+TEST(AsyncNursery, DoClose) { AssertDoesNotCloseEarly<GatingDoClose>(); }\n+\n+TEST(AsyncNursery, SharedChildDoClose) {\n+  AssertDoesNotCloseEarlyWithChild<GatingDoCloseWithSharedChild>();\n+}\n+\n+TEST(AsyncNursery, UniqueChildDoClose) {\n+  AssertDoesNotCloseEarlyWithChild<GatingDoCloseWithUniqueChild>();\n+}\n+\n+TEST(AsyncNursery, DependentTask) {\n+  AssertDoesNotCloseEarly<GatingDoCloseAsDependentTask>();\n+}\n+\n+TEST(AsyncNursery, EvictedChild) {\n+  Future<> child_future = Future<>::Make();\n+  Future<> final_future = Future<>::Make();\n+  std::atomic<bool> finished{false};\n+  std::thread thread([&] {\n+    ASSERT_OK(Nursery::RunInNursery([&](Nursery* nursery) {\n+      bool child_destroyed = false;\n+      std::shared_ptr<EvictsChild> evicts_child =\n+          nursery->MakeSharedCloseable<EvictsChild>(nursery, &child_destroyed,\n+                                                    child_future, final_future);\n+      evicts_child->EvictChild();\n+      // Owner no longer has reference to child here but it's kept alive by nursery\n+      // because it isn't done\n\nReview comment:\n       I don't understand this comment, because by reading the source code, I get the impression that the nursery doesn't keep anything alive (it does not have a container of tasks or futures).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-30T13:43:55.308+0000",
                    "updated": "2021-08-30T13:43:55.308+0000",
                    "started": "2021-08-30T13:43:55.307+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643469",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/643866",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#issuecomment-908913026\n\n\n   > If I understand correctly, nothing here actually keeps the tasks alive. What this relies upon is that the user stored the shared_ptr or unique_ptr returned by Nursery::MakeXXXCloseable somewhere so that lifetimes are handled correctly?\r\n   \r\n   There's two concerns here.  1) Keeping the object alive (the nursery does not do this, but the smart pointers do) and 2) Not returning until all tasks have finished (the nursery does this because it blocks until every task has finished).\r\n   \r\n   > Is there a risk that these pointers may be kept alive too long (and delay the DoClose calls accordingly)?\r\n   \r\n   Yes, the nursery could very much trigger deadlock if a task never finishes.  I'll call back to this later.\r\n   \r\n   > What is the recommended strategy for using this facility?\r\n   Did you try to use this in the codebase to check that it actually reduces the burden of managing the sequencing of destructor calls?\r\n   \r\n   See https://github.com/apache/arrow/pull/11017\r\n   @pitrou \r\n   ---\r\n   \r\n   I also received some negative feedback offline from @bkietz and so I tried today to rewrite this in another light, using only the asynchronous smart pointers and an asynchronous task group.  The result is [here](https://github.com/apache/arrow/compare/master...westonpace:experiment/async-smart-ptr?expand=1).  However, it still doesn't quite solve the problem.  So, let me try and state the problem I am trying to solve in clear terms and I am open to any solution someone can come up with but at the moment this PR is still my preferred solution.\r\n   \r\n   # Problem Statement\r\n   \r\n   The use case here is from the perspective of a developer trying to write some code and they want to ensure the code they write is used safely.  For example, let's consider the case of writing a file writer queue.  A synchronous declaration might look something like this...\r\n   \r\n   ```\r\n   class FileWriterQueue {\r\n   public:\r\n     FileWriterQueue(std::unique_ptr<FileWriter> writer, const FileWriteOptions& options);\r\n     ~FileWriterQueue();\r\n     Status QueueBatch(std::shared_ptr<RecordBatch> batch);\r\n     void Finish();\r\n   private:\r\n     std::unique_ptr<FileWriter> writer;\r\n     const FileWriteOptions& options;\r\n   };\r\n   ```\r\n   \r\n   Now, let's pretend our implementation creates a dedicated writer thread and every call to QueueBatch adds the batch to a producer consumer queue that the writer thread drains.  Our destructor would then look like this...\r\n   \r\n   ```\r\n   FileWriterQueue::~FileWriterQueue() {\r\n     EnsureFinished();\r\n     writer_thread.join();\r\n   }\r\n   ```\r\n   \r\n   Now let's look at how this is used...\r\n   \r\n   ```\r\n   void WriteBatches(std::vector<std::shared_ptr<RecordBatch>> batches, const FileWriterOptions& options) {\r\n     std::unique_ptr<FileWriter> file_writer = OpenWriter();\r\n     FileWriterQueue file_writer_queue(std::move(file_writer));\r\n     for (const auto& batch : batches) {\r\n       ARROW_RETURN_NOT_OK(file_writer_queue.QueueBatch(batch));\r\n     }\r\n     file_writer_queue.Finish(); // I could also skip this and just rely on the EnsureFinished in the destructor\r\n   }\r\n   ```\r\n   \r\n   We are ensured several things:\r\n   \r\n    1) The FileWriterQueue will not be deleted until the thread is joined\r\n    2) The options remain valid until the thread is joined\r\n    3) All work is completely done when WriteBatches returns\r\n   \r\n   My goal is to allow those same guarantees to exist if the \"finishing work\" (the stuff in the destructor) is a future. For example, the asynchronous analogue of above might be...\r\n   \r\n   ```\r\n   class FileWriterQueue {\r\n   public:\r\n     FileWriterQueue(std::unique_ptr<FileWriter> writer, const FileWriteOptions& options);\r\n     ~FileWriterQueue();\r\n     void QueueBatch(std::shared_ptr<RecordBatch> batch);\r\n     Future<> Finish();\r\n   private:\r\n     std::unique_ptr<FileWriter> writer;\r\n     const FileWriteOptions& options;\r\n   };\r\n   ```\r\n   \r\n   Now our destructor can't do anything.  It can't block on Finish() because that would defeat the purpose of being asynchronous.  Someone naively using this class might do...\r\n   \r\n   ```\r\n   void WriteBatches(std::vector<std::shared_ptr<RecordBatch>> batches, const FileWriterOptions& options) {\r\n     std::unique_ptr<FileWriter> file_writer = OpenWriter();\r\n     FileWriterQueue file_writer_queue(std::move(file_writer));\r\n     for (const auto& batch : batches) {\r\n       ARROW_RETURN_NOT_OK(file_writer_queue.QueueBatch(batch));\r\n     }\r\n     return file_writer_queue.Finish().status();\r\n   }\r\n   ```\r\n   \r\n   This works ok until a call to QueueBatch returns an error status halfway through the write.  Then the code will bail out and both `file_writer_queue` and `options` will go out of scope.  This means if there are any leftover captures and they get executed they will segfault.\r\n   \r\n   With the nursery you can write...\r\n   \r\n   ```\r\n   void WriteBatches(std::vector<std::shared_ptr<RecordBatch>> batches, const FileWriterOptions& options) {\r\n     return util::RunInNursery([] (Nursery* nursery) {\r\n       std::unique_ptr<FileWriter> file_writer = OpenWriter();\r\n       FileWriterQueue file_writer_queue(nursery, std::move(file_writer));\r\n       for (const auto& batch : batches) {\r\n         ARROW_RETURN_NOT_OK(file_writer_queue.QueueBatch(batch));\r\n       }\r\n       return file_writer_queue.status();\r\n     }\r\n   }\r\n   ```\r\n   \r\n   ...and now you can be assured that an error occurring during QueueBatch will not cause a segmentation fault because the nursery will still block until any outstanding captures have resolved.\r\n   \r\n   > Is there a risk that these pointers may be kept alive too long (and delay the DoClose calls accordingly)?\r\n   \r\n   Yes, if there is a bug, but, the risk is no greater than what you have with...\r\n   \r\n   ```\r\n   FileWriterQueue::~FileWriterQueue() {\r\n     EnsureFinished();\r\n     writer_thread.join(); // Could deadlock / delay for a long time if there is a bug\r\n   }\r\n   ```\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T05:33:27.032+0000",
                    "updated": "2021-08-31T05:33:27.032+0000",
                    "started": "2021-08-31T05:33:27.032+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643866",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/643867",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace edited a comment on pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#issuecomment-908913026\n\n\n   > If I understand correctly, nothing here actually keeps the tasks alive. What this relies upon is that the user stored the shared_ptr or unique_ptr returned by Nursery::MakeXXXCloseable somewhere so that lifetimes are handled correctly?\r\n   \r\n   There's two concerns here.  1) Keeping the object alive (the nursery does not do this, but the smart pointers do) and 2) Not returning until all tasks have finished (the nursery does this because it blocks until every task has finished).\r\n   \r\n   > Is there a risk that these pointers may be kept alive too long (and delay the DoClose calls accordingly)?\r\n   \r\n   Yes, the nursery could very much trigger deadlock if a task never finishes.  I'll call back to this later.\r\n   \r\n   > What is the recommended strategy for using this facility?\r\n   Did you try to use this in the codebase to check that it actually reduces the burden of managing the sequencing of destructor calls?\r\n   \r\n   See https://github.com/apache/arrow/pull/11017\r\n   @pitrou \r\n   \r\n   ---\r\n   \r\n   I also received some negative feedback offline from @bkietz and so I tried today to rewrite this in another light, using only the asynchronous smart pointers and an asynchronous task group.  The result is [here](https://github.com/apache/arrow/compare/master...westonpace:experiment/async-smart-ptr?expand=1).  However, it still doesn't quite solve the problem.  So, let me try and state the problem I am trying to solve in clear terms and I am open to any solution someone can come up with but at the moment this PR is still my preferred solution.\r\n   \r\n   # Problem Statement\r\n   \r\n   The use case here is from the perspective of a developer trying to write some code and they want to ensure the code they write is used safely.  For example, let's consider the case of writing a file writer queue.  A synchronous declaration might look something like this...\r\n   \r\n   ```\r\n   class FileWriterQueue {\r\n   public:\r\n     FileWriterQueue(std::unique_ptr<FileWriter> writer, const FileWriteOptions& options);\r\n     ~FileWriterQueue();\r\n     Status QueueBatch(std::shared_ptr<RecordBatch> batch);\r\n     void Finish();\r\n   private:\r\n     std::unique_ptr<FileWriter> writer;\r\n     const FileWriteOptions& options;\r\n   };\r\n   ```\r\n   \r\n   Now, let's pretend our implementation creates a dedicated writer thread and every call to QueueBatch adds the batch to a producer consumer queue that the writer thread drains.  Our destructor would then look like this...\r\n   \r\n   ```\r\n   FileWriterQueue::~FileWriterQueue() {\r\n     EnsureFinished();\r\n     writer_thread.join();\r\n   }\r\n   ```\r\n   \r\n   Now let's look at how this is used...\r\n   \r\n   ```\r\n   void WriteBatches(std::vector<std::shared_ptr<RecordBatch>> batches, const FileWriterOptions& options) {\r\n     std::unique_ptr<FileWriter> file_writer = OpenWriter();\r\n     FileWriterQueue file_writer_queue(std::move(file_writer));\r\n     for (const auto& batch : batches) {\r\n       ARROW_RETURN_NOT_OK(file_writer_queue.QueueBatch(batch));\r\n     }\r\n     file_writer_queue.Finish(); // I could also skip this and just rely on the EnsureFinished in the destructor\r\n   }\r\n   ```\r\n   \r\n   We are ensured several things:\r\n   \r\n    1) The FileWriterQueue will not be deleted until the thread is joined\r\n    2) The options remain valid until the thread is joined\r\n    3) All work is completely done when WriteBatches returns\r\n   \r\n   My goal is to allow those same guarantees to exist if the \"finishing work\" (the stuff in the destructor) is a future. For example, the asynchronous analogue of above might be...\r\n   \r\n   ```\r\n   class FileWriterQueue {\r\n   public:\r\n     FileWriterQueue(std::unique_ptr<FileWriter> writer, const FileWriteOptions& options);\r\n     ~FileWriterQueue();\r\n     void QueueBatch(std::shared_ptr<RecordBatch> batch);\r\n     Future<> Finish();\r\n   private:\r\n     std::unique_ptr<FileWriter> writer;\r\n     const FileWriteOptions& options;\r\n   };\r\n   ```\r\n   \r\n   Now our destructor can't do anything.  It can't block on Finish() because that would defeat the purpose of being asynchronous.  Someone naively using this class might do...\r\n   \r\n   ```\r\n   void WriteBatches(std::vector<std::shared_ptr<RecordBatch>> batches, const FileWriterOptions& options) {\r\n     std::unique_ptr<FileWriter> file_writer = OpenWriter();\r\n     FileWriterQueue file_writer_queue(std::move(file_writer));\r\n     for (const auto& batch : batches) {\r\n       ARROW_RETURN_NOT_OK(file_writer_queue.QueueBatch(batch));\r\n     }\r\n     return file_writer_queue.Finish().status();\r\n   }\r\n   ```\r\n   \r\n   This works ok until a call to QueueBatch returns an error status halfway through the write.  Then the code will bail out and both `file_writer_queue` and `options` will go out of scope.  This means if there are any leftover captures and they get executed they will segfault.\r\n   \r\n   With the nursery you can write...\r\n   \r\n   ```\r\n   void WriteBatches(std::vector<std::shared_ptr<RecordBatch>> batches, const FileWriterOptions& options) {\r\n     return util::RunInNursery([] (Nursery* nursery) {\r\n       std::unique_ptr<FileWriter> file_writer = OpenWriter();\r\n       FileWriterQueue file_writer_queue(nursery, std::move(file_writer));\r\n       for (const auto& batch : batches) {\r\n         ARROW_RETURN_NOT_OK(file_writer_queue.QueueBatch(batch));\r\n       }\r\n       return file_writer_queue.status();\r\n     }\r\n   }\r\n   ```\r\n   \r\n   ...and now you can be assured that an error occurring during QueueBatch will not cause a segmentation fault because the nursery will still block until any outstanding captures have resolved.\r\n   \r\n   > Is there a risk that these pointers may be kept alive too long (and delay the DoClose calls accordingly)?\r\n   \r\n   Yes, if there is a bug, but, the risk is no greater than what you have with...\r\n   \r\n   ```\r\n   FileWriterQueue::~FileWriterQueue() {\r\n     EnsureFinished();\r\n     writer_thread.join(); // Could deadlock / delay for a long time if there is a bug\r\n   }\r\n   ```\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T05:33:50.525+0000",
                    "updated": "2021-08-31T05:33:50.525+0000",
                    "started": "2021-08-31T05:33:50.524+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643867",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/643868",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#issuecomment-908914093\n\n\n   ## Why can't FileWriteOptions be a `shared_ptr`?\r\n   \r\n   It can, and if we force everything to be `shared_ptr` then we just have to keep `this` alive and an asynchronous smart pointer would be sufficient but there are still lots of things like `ExecContext`, `Executor`, `IOContext`, etc. which we often pass by pointer and can go out of scope when the operation finishes.\r\n   \r\n   Plus, it still seems disingenuous to return from a high-level function/operation when cleanup work is still outstanding.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T05:36:19.796+0000",
                    "updated": "2021-08-31T05:36:19.796+0000",
                    "started": "2021-08-31T05:36:19.795+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "643868",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/644179",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#discussion_r698481775\n\n\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n+ protected:\n+  void Init(AsyncCloseable* impl);\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  AsyncCloseable* impl_;\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+};\n+\n+class ARROW_EXPORT Nursery {\n+ public:\n+  template <typename T, typename... Args>\n+  typename std::enable_if<!std::is_array<T>::value, std::shared_ptr<T>>::type\n+  MakeSharedCloseable(Args&&... args) {\n\nReview comment:\n       Can you add a docstring explaining what it does?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n+ protected:\n+  void Init(AsyncCloseable* impl);\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  AsyncCloseable* impl_;\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+};\n+\n+class ARROW_EXPORT Nursery {\n+ public:\n+  template <typename T, typename... Args>\n+  typename std::enable_if<!std::is_array<T>::value, std::shared_ptr<T>>::type\n\nReview comment:\n       The `enable_if` doesn't seem useful here (especially as you have a `static_assert` below that would catch arrays)\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n\nReview comment:\n       API ergonomics question: since this is the single point of customization, would it be easier if `AsyncCloseable` took a `std::function<Future<>> close_func` parameter, instead of having to write a subclass?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.cc\n##########\n@@ -0,0 +1,123 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/async_nursery.h\"\n+\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+AsyncCloseable::AsyncCloseable() : on_closed_(Future<>::Make()) {}\n+AsyncCloseable::AsyncCloseable(AsyncCloseable* parent) : on_closed_(Future<>::Make()) {\n+  parent->AddDependentTask(OnClosed());\n+}\n+\n+AsyncCloseable::~AsyncCloseable() {\n+  DCHECK_NE(nursery_, nullptr) << \"An AsyncCloseable must be created with a nursery \"\n+                                  \"using MakeSharedCloseable or MakeUniqueCloseable\";\n+}\n+\n+const Future<>& AsyncCloseable::OnClosed() { return on_closed_; }\n+\n+void AsyncCloseable::AddDependentTask(const Future<>& task) {\n+  DCHECK(!closed_);\n+  if (num_tasks_outstanding_.fetch_add(1) == 1) {\n+    tasks_finished_ = Future<>::Make();\n+  }\n+  task.AddCallback([this](const Status& st) {\n+    if (num_tasks_outstanding_.fetch_sub(1) == 1 && closed_.load()) {\n+      tasks_finished_.MarkFinished(st);\n+    }\n+  });\n+}\n+\n+void AsyncCloseable::SetNursery(Nursery* nursery) { nursery_ = nursery; }\n+\n+void AsyncCloseable::Destroy() {\n+  DCHECK_NE(nursery_, nullptr);\n+  closed_ = true;\n+  nursery_->num_closeables_destroyed_.fetch_add(1);\n+  Future<> finish_fut;\n+  if (tasks_finished_.is_valid()) {\n+    if (num_tasks_outstanding_.fetch_sub(1) > 1) {\n+      finish_fut = AllComplete({DoClose(), tasks_finished_});\n+    } else {\n+      // Any added tasks have already finished so there is nothing to wait for\n+      finish_fut = DoClose();\n+    }\n+  } else {\n+    // No dependent tasks were added\n\nReview comment:\n       Hmm... is it possible for dependent tasks to be added after this?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.cc\n##########\n@@ -0,0 +1,123 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/async_nursery.h\"\n+\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+AsyncCloseable::AsyncCloseable() : on_closed_(Future<>::Make()) {}\n+AsyncCloseable::AsyncCloseable(AsyncCloseable* parent) : on_closed_(Future<>::Make()) {\n+  parent->AddDependentTask(OnClosed());\n+}\n+\n+AsyncCloseable::~AsyncCloseable() {\n+  DCHECK_NE(nursery_, nullptr) << \"An AsyncCloseable must be created with a nursery \"\n+                                  \"using MakeSharedCloseable or MakeUniqueCloseable\";\n+}\n+\n+const Future<>& AsyncCloseable::OnClosed() { return on_closed_; }\n+\n+void AsyncCloseable::AddDependentTask(const Future<>& task) {\n+  DCHECK(!closed_);\n+  if (num_tasks_outstanding_.fetch_add(1) == 1) {\n+    tasks_finished_ = Future<>::Make();\n+  }\n+  task.AddCallback([this](const Status& st) {\n+    if (num_tasks_outstanding_.fetch_sub(1) == 1 && closed_.load()) {\n+      tasks_finished_.MarkFinished(st);\n+    }\n+  });\n+}\n+\n+void AsyncCloseable::SetNursery(Nursery* nursery) { nursery_ = nursery; }\n+\n+void AsyncCloseable::Destroy() {\n+  DCHECK_NE(nursery_, nullptr);\n+  closed_ = true;\n+  nursery_->num_closeables_destroyed_.fetch_add(1);\n+  Future<> finish_fut;\n+  if (tasks_finished_.is_valid()) {\n+    if (num_tasks_outstanding_.fetch_sub(1) > 1) {\n+      finish_fut = AllComplete({DoClose(), tasks_finished_});\n+    } else {\n+      // Any added tasks have already finished so there is nothing to wait for\n+      finish_fut = DoClose();\n+    }\n+  } else {\n+    // No dependent tasks were added\n+    finish_fut = DoClose();\n+  }\n+  finish_fut.AddCallback([this](const Status& st) {\n+    if (on_closed_.is_valid()) {\n+      on_closed_.MarkFinished(st);\n+    }\n+    nursery_->OnTaskFinished(st);\n+    delete this;\n\nReview comment:\n       Ok, so this mandates that this object is heap-allocated using the default C++ allocator, right? Can you mention this somewhere in the docstring?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n+ protected:\n+  void Init(AsyncCloseable* impl);\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  AsyncCloseable* impl_;\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+};\n+\n+class ARROW_EXPORT Nursery {\n+ public:\n+  template <typename T, typename... Args>\n+  typename std::enable_if<!std::is_array<T>::value, std::shared_ptr<T>>::type\n+  MakeSharedCloseable(Args&&... args) {\n+    static_assert(std::is_base_of<AsyncCloseable, T>::value,\n+                  \"Nursery::MakeSharedCloseable only works with AsyncCloseable types\");\n+    num_closeables_created_.fetch_add(1);\n+    num_tasks_outstanding_.fetch_add(1);\n+    std::shared_ptr<T> shared_closeable(new T(std::forward<Args&&>(args)...),\n+                                        DestroyingDeleter<T>());\n+    shared_closeable->SetNursery(this);\n+    return shared_closeable;\n+  }\n+\n+  template <typename T, typename... Args>\n+  typename std::enable_if<!std::is_array<T>::value,\n+                          std::unique_ptr<T, DestroyingDeleter<T>>>::type\n\nReview comment:\n       Same remarks here.\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n+ protected:\n+  void Init(AsyncCloseable* impl);\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  AsyncCloseable* impl_;\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+};\n+\n+class ARROW_EXPORT Nursery {\n\nReview comment:\n       Can you add a docstring explaining what this is/does?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n+ protected:\n+  void Init(AsyncCloseable* impl);\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  AsyncCloseable* impl_;\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+};\n+\n+class ARROW_EXPORT Nursery {\n+ public:\n+  template <typename T, typename... Args>\n+  typename std::enable_if<!std::is_array<T>::value, std::shared_ptr<T>>::type\n+  MakeSharedCloseable(Args&&... args) {\n+    static_assert(std::is_base_of<AsyncCloseable, T>::value,\n+                  \"Nursery::MakeSharedCloseable only works with AsyncCloseable types\");\n+    num_closeables_created_.fetch_add(1);\n+    num_tasks_outstanding_.fetch_add(1);\n+    std::shared_ptr<T> shared_closeable(new T(std::forward<Args&&>(args)...),\n+                                        DestroyingDeleter<T>());\n+    shared_closeable->SetNursery(this);\n+    return shared_closeable;\n+  }\n+\n+  template <typename T, typename... Args>\n+  typename std::enable_if<!std::is_array<T>::value,\n+                          std::unique_ptr<T, DestroyingDeleter<T>>>::type\n+  MakeUniqueCloseable(Args&&... args) {\n+    static_assert(std::is_base_of<AsyncCloseable, T>::value,\n+                  \"Nursery::MakeUniqueCloseable only works with AsyncCloseable types\");\n+    num_closeables_created_.fetch_add(1);\n+    num_tasks_outstanding_.fetch_add(1);\n+    auto unique_closeable = std::unique_ptr<T, DestroyingDeleter<T>>(\n+        new T(std::forward<Args>(args)...), DestroyingDeleter<T>());\n+    unique_closeable->SetNursery(this);\n+    return unique_closeable;\n+  }\n+\n+  template <typename T>\n+  void AddDependentTask(const Future<T>& task) {\n+    num_tasks_outstanding_.fetch_add(1);\n+    task.AddCallback([this](const Result<T>& res) { OnTaskFinished(res.status()); });\n+  }\n+\n+  /// Runs `task` within a nursery.  This method will not return until\n+  /// all roots added by the task have been closed and destroyed.\n\nReview comment:\n       What are \"roots\" in this context? AsyncCloseable objects?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n\nReview comment:\n       This doesn't seem used?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery.h\n##########\n@@ -0,0 +1,154 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#pragma once\n+\n+#include <list>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n+#include \"arrow/util/mutex.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class Nursery;\n+class AsyncCloseablePimpl;\n+\n+template <typename T>\n+struct DestroyingDeleter {\n+  void operator()(T* p) { p->Destroy(); }\n+};\n+\n+/// An object which should be asynchronously closed before it is destroyed\n+///\n+/// Any AsyncCloseable must be kept alive until its parent is destroyed (this is a given\n+/// if the parent is a nursery).  For shorter lived tasks/objects consider\n+/// OwnedAsyncCloseable adding a dependent task.\n+class ARROW_EXPORT AsyncCloseable : public std::enable_shared_from_this<AsyncCloseable> {\n+ public:\n+  AsyncCloseable();\n+  explicit AsyncCloseable(AsyncCloseable* parent);\n+  virtual ~AsyncCloseable();\n+\n+  /// Returns a future that is completed when this object is finished closing\n+  const Future<>& OnClosed();\n+\n+ protected:\n+  /// Subclasses should override this and perform any cleanup.  Once the future returned\n+  /// by this method finishes then this object is eligible for destruction and any\n+  /// reference to `this` will be invalid\n+  virtual Future<> DoClose() = 0;\n+\n+  /// This method is called by subclasses to add tasks which must complete before the\n+  /// object can be safely deleted\n+  void AddDependentTask(const Future<>& task);\n+  /// This method can be called by subclasses for error checking purposes.  It will\n+  /// return an invalid status if this object has started closing\n+  Status CheckClosed() const;\n+\n+  Nursery* nursery_;\n+\n+ private:\n+  void SetNursery(Nursery* nursery);\n+  void Destroy();\n+\n+  Future<> on_closed_;\n+  Future<> tasks_finished_;\n+  std::atomic<bool> closed_{false};\n+  std::atomic<uint32_t> num_tasks_outstanding_{1};\n+\n+  friend Nursery;\n+  template <typename T>\n+  friend struct DestroyingDeleter;\n+  friend AsyncCloseablePimpl;\n+};\n+\n+class ARROW_EXPORT AsyncCloseablePimpl {\n\nReview comment:\n       What is this supposed to be? Is it useful as a public API?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery_test.cc\n##########\n@@ -0,0 +1,184 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/async_nursery.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <thread>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class GatingDoClose : public AsyncCloseable {\n+ public:\n+  GatingDoClose(AsyncCloseable* parent, Future<> close_future)\n+      : AsyncCloseable(parent), close_future_(std::move(close_future)) {}\n+  explicit GatingDoClose(Future<> close_future)\n+      : close_future_(std::move(close_future)) {}\n+\n+  Future<> DoClose() override { return close_future_; }\n+\n+  Future<> close_future_;\n+};\n+\n+class GatingDoCloseWithUniqueChild : public AsyncCloseable {\n+ public:\n+  GatingDoCloseWithUniqueChild(Nursery* nursery, Future<> close_future)\n+      : child_(\n+            nursery->MakeUniqueCloseable<GatingDoClose>(this, std::move(close_future))) {}\n+\n+  Future<> DoClose() override {\n+    child_.reset();\n+    return Future<>::MakeFinished();\n+  }\n+\n+  std::unique_ptr<GatingDoClose, DestroyingDeleter<GatingDoClose>> child_;\n+};\n+\n+class GatingDoCloseWithSharedChild : public AsyncCloseable {\n+ public:\n+  GatingDoCloseWithSharedChild(Nursery* nursery, Future<> close_future)\n+      : child_(\n+            nursery->MakeSharedCloseable<GatingDoClose>(this, std::move(close_future))) {}\n+\n+  Future<> DoClose() override {\n+    child_.reset();\n+    return Future<>::MakeFinished();\n+  }\n+\n+  std::shared_ptr<GatingDoClose> child_;\n+};\n+\n+class GatingDoCloseAsDependentTask : public AsyncCloseable {\n+ public:\n+  explicit GatingDoCloseAsDependentTask(Future<> close_future) {\n+    AddDependentTask(std::move(close_future));\n+  }\n+\n+  Future<> DoClose() override { return Future<>::MakeFinished(); }\n+};\n+\n+class MarkWhenDestroyed : public GatingDoClose {\n+ public:\n+  MarkWhenDestroyed(Future<> close_future, bool* destroyed)\n+      : GatingDoClose(std::move(close_future)), destroyed_(destroyed) {}\n+  ~MarkWhenDestroyed() { *destroyed_ = true; }\n+\n+ private:\n+  bool* destroyed_;\n+};\n+\n+class EvictsChild : public AsyncCloseable {\n\nReview comment:\n       Add a comment explaining what this does/exercises?\n\n##########\nFile path: cpp/src/arrow/util/async_nursery_test.cc\n##########\n@@ -0,0 +1,184 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/util/async_nursery.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <thread>\n+\n+#include \"arrow/result.h\"\n+#include \"arrow/testing/gtest_common.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+\n+namespace arrow {\n+namespace util {\n+\n+class GatingDoClose : public AsyncCloseable {\n+ public:\n+  GatingDoClose(AsyncCloseable* parent, Future<> close_future)\n+      : AsyncCloseable(parent), close_future_(std::move(close_future)) {}\n+  explicit GatingDoClose(Future<> close_future)\n+      : close_future_(std::move(close_future)) {}\n+\n+  Future<> DoClose() override { return close_future_; }\n+\n+  Future<> close_future_;\n+};\n+\n+class GatingDoCloseWithUniqueChild : public AsyncCloseable {\n+ public:\n+  GatingDoCloseWithUniqueChild(Nursery* nursery, Future<> close_future)\n+      : child_(\n+            nursery->MakeUniqueCloseable<GatingDoClose>(this, std::move(close_future))) {}\n+\n+  Future<> DoClose() override {\n+    child_.reset();\n+    return Future<>::MakeFinished();\n+  }\n+\n+  std::unique_ptr<GatingDoClose, DestroyingDeleter<GatingDoClose>> child_;\n+};\n+\n+class GatingDoCloseWithSharedChild : public AsyncCloseable {\n+ public:\n+  GatingDoCloseWithSharedChild(Nursery* nursery, Future<> close_future)\n+      : child_(\n+            nursery->MakeSharedCloseable<GatingDoClose>(this, std::move(close_future))) {}\n+\n+  Future<> DoClose() override {\n+    child_.reset();\n+    return Future<>::MakeFinished();\n+  }\n+\n+  std::shared_ptr<GatingDoClose> child_;\n+};\n+\n+class GatingDoCloseAsDependentTask : public AsyncCloseable {\n+ public:\n+  explicit GatingDoCloseAsDependentTask(Future<> close_future) {\n+    AddDependentTask(std::move(close_future));\n+  }\n+\n+  Future<> DoClose() override { return Future<>::MakeFinished(); }\n+};\n+\n+class MarkWhenDestroyed : public GatingDoClose {\n+ public:\n+  MarkWhenDestroyed(Future<> close_future, bool* destroyed)\n+      : GatingDoClose(std::move(close_future)), destroyed_(destroyed) {}\n+  ~MarkWhenDestroyed() { *destroyed_ = true; }\n+\n+ private:\n+  bool* destroyed_;\n+};\n+\n+class EvictsChild : public AsyncCloseable {\n+ public:\n+  EvictsChild(Nursery* nursery, bool* child_destroyed, Future<> child_future,\n+              Future<> final_future)\n+      : final_close_future_(std::move(final_future)) {\n+    owned_child_ = nursery->MakeSharedCloseable<MarkWhenDestroyed>(\n+        std::move(child_future), child_destroyed);\n+  }\n+\n+  void EvictChild() { owned_child_.reset(); }\n+\n+  Future<> DoClose() override { return final_close_future_; }\n+\n+ private:\n+  Future<> final_close_future_;\n+  std::shared_ptr<GatingDoClose> owned_child_;\n+};\n+\n+template <typename T>\n+void AssertDoesNotCloseEarly() {\n+  Future<> gate = Future<>::Make();\n+  std::atomic<bool> finished{false};\n+  std::thread thread([&] {\n+    ASSERT_OK(Nursery::RunInNursery(\n+        [&](Nursery* nursery) { nursery->MakeSharedCloseable<T>(gate); }));\n+    finished.store(true);\n+  });\n+\n+  SleepABit();\n+  ASSERT_FALSE(finished.load());\n+  gate.MarkFinished();\n+  BusyWait(10, [&] { return finished.load(); });\n+  thread.join();\n+}\n+\n+template <typename T>\n+void AssertDoesNotCloseEarlyWithChild() {\n+  Future<> gate = Future<>::Make();\n+  std::atomic<bool> finished{false};\n+  std::thread thread([&] {\n+    ASSERT_OK(Nursery::RunInNursery(\n+        [&](Nursery* nursery) { nursery->MakeSharedCloseable<T>(nursery, gate); }));\n+    finished.store(true);\n+  });\n+\n+  SleepABit();\n+  ASSERT_FALSE(finished.load());\n+  gate.MarkFinished();\n+  BusyWait(10, [&] { return finished.load(); });\n+  thread.join();\n+}\n+\n+TEST(AsyncNursery, DoClose) { AssertDoesNotCloseEarly<GatingDoClose>(); }\n+\n+TEST(AsyncNursery, SharedChildDoClose) {\n+  AssertDoesNotCloseEarlyWithChild<GatingDoCloseWithSharedChild>();\n+}\n+\n+TEST(AsyncNursery, UniqueChildDoClose) {\n+  AssertDoesNotCloseEarlyWithChild<GatingDoCloseWithUniqueChild>();\n+}\n+\n+TEST(AsyncNursery, DependentTask) {\n+  AssertDoesNotCloseEarly<GatingDoCloseAsDependentTask>();\n+}\n+\n+TEST(AsyncNursery, EvictedChild) {\n+  Future<> child_future = Future<>::Make();\n+  Future<> final_future = Future<>::Make();\n+  std::atomic<bool> finished{false};\n+  std::thread thread([&] {\n+    ASSERT_OK(Nursery::RunInNursery([&](Nursery* nursery) {\n+      bool child_destroyed = false;\n+      std::shared_ptr<EvictsChild> evicts_child =\n+          nursery->MakeSharedCloseable<EvictsChild>(nursery, &child_destroyed,\n+                                                    child_future, final_future);\n+      evicts_child->EvictChild();\n+      // Owner no longer has reference to child here but it's kept alive by nursery\n+      // because it isn't done\n\nReview comment:\n       I don't understand this comment, because by reading the source code, I get the impression that the nursery doesn't keep anything alive (it does not have a container of tasks or futures).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T14:56:02.853+0000",
                    "updated": "2021-08-31T14:56:02.853+0000",
                    "started": "2021-08-31T14:56:02.853+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644179",
                    "issueId": "13396255"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/worklog/644200",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace edited a comment on pull request #10968:\nURL: https://github.com/apache/arrow/pull/10968#issuecomment-908913026\n\n\n   > If I understand correctly, nothing here actually keeps the tasks alive. What this relies upon is that the user stored the shared_ptr or unique_ptr returned by Nursery::MakeXXXCloseable somewhere so that lifetimes are handled correctly?\r\n   \r\n   There's two concerns here.  1) Keeping the object alive (the nursery does not do this, but the smart pointers do) and 2) Not returning until all tasks have finished (the nursery does this because it blocks until every task has finished).\r\n   \r\n   > Is there a risk that these pointers may be kept alive too long (and delay the DoClose calls accordingly)?\r\n   \r\n   Yes, the nursery could very much trigger deadlock if a task never finishes.  I'll call back to this later.\r\n   \r\n   > What is the recommended strategy for using this facility?\r\n   Did you try to use this in the codebase to check that it actually reduces the burden of managing the sequencing of destructor calls?\r\n   \r\n   See https://github.com/apache/arrow/pull/11017\r\n   @pitrou \r\n   \r\n   ---\r\n   \r\n   I also received some negative feedback offline from @bkietz and so I tried today to rewrite this in another light, using only the asynchronous smart pointers and an asynchronous task group.  The result is [here](https://github.com/apache/arrow/compare/master...westonpace:experiment/async-smart-ptr?expand=1).  However, it still doesn't quite solve the problem.  So, let me try and state the problem I am trying to solve in clear terms and I am open to any solution someone can come up with but at the moment this PR is still my preferred solution.\r\n   \r\n   # Problem Statement\r\n   \r\n   The use case here is from the perspective of a developer trying to write some code and they want to ensure the code they write is used safely.  For example, let's consider the case of writing a file writer queue.  A synchronous declaration might look something like this...\r\n   \r\n   ```\r\n   class FileWriterQueue {\r\n   public:\r\n     FileWriterQueue(std::unique_ptr<FileWriter> writer, const FileWriteOptions& options);\r\n     ~FileWriterQueue();\r\n     Status QueueBatch(std::shared_ptr<RecordBatch> batch);\r\n     void Finish();\r\n   private:\r\n     std::unique_ptr<FileWriter> writer;\r\n     const FileWriteOptions& options;\r\n   };\r\n   ```\r\n   \r\n   Now, let's pretend our implementation creates a dedicated writer thread and every call to QueueBatch adds the batch to a producer consumer queue that the writer thread drains.  Our destructor would then look like this...\r\n   \r\n   ```\r\n   FileWriterQueue::~FileWriterQueue() {\r\n     EnsureFinished();\r\n     writer_thread.join();\r\n   }\r\n   ```\r\n   \r\n   Now let's look at how this is used...\r\n   \r\n   ```\r\n   void WriteBatches(std::vector<std::shared_ptr<RecordBatch>> batches, const FileWriterOptions& options) {\r\n     std::unique_ptr<FileWriter> file_writer = OpenWriter();\r\n     FileWriterQueue file_writer_queue(std::move(file_writer));\r\n     for (const auto& batch : batches) {\r\n       ARROW_RETURN_NOT_OK(file_writer_queue.QueueBatch(batch));\r\n     }\r\n     file_writer_queue.Finish(); // I could also skip this and just rely on the EnsureFinished in the destructor\r\n   }\r\n   ```\r\n   \r\n   We are ensured several things:\r\n   \r\n    1) The FileWriterQueue will not be deleted until the thread is joined\r\n    2) The options remain valid until the thread is joined\r\n    3) All work is completely done when WriteBatches returns\r\n   \r\n   My goal is to allow those same guarantees to exist if the \"finishing work\" (the stuff in the destructor) is a future. For example, the asynchronous analogue of above might be...\r\n   \r\n   ```\r\n   class FileWriterQueue {\r\n   public:\r\n     FileWriterQueue(std::unique_ptr<FileWriter> writer, const FileWriteOptions& options);\r\n     ~FileWriterQueue();\r\n     void QueueBatch(std::shared_ptr<RecordBatch> batch);\r\n     Future<> Finish();\r\n   private:\r\n     std::unique_ptr<FileWriter> writer;\r\n     const FileWriteOptions& options;\r\n   };\r\n   ```\r\n   \r\n   Now our destructor can't do anything.  It can't block on Finish() because that would defeat the purpose of being asynchronous.  Someone naively using this class might do...\r\n   \r\n   ```\r\n   void WriteBatches(std::vector<std::shared_ptr<RecordBatch>> batches, const FileWriterOptions& options) {\r\n     std::unique_ptr<FileWriter> file_writer = OpenWriter();\r\n     FileWriterQueue file_writer_queue(std::move(file_writer));\r\n     for (const auto& batch : batches) {\r\n       ARROW_RETURN_NOT_OK(file_writer_queue.QueueBatch(batch));\r\n     }\r\n     return file_writer_queue.Finish().status();\r\n   }\r\n   ```\r\n   \r\n   This works ok until a call to QueueBatch returns an error status halfway through the write.  Then the code will bail out and both `file_writer_queue` and `options` will go out of scope.  This means if there are any leftover captures and they get executed they will segfault.\r\n   \r\n   With the nursery you can write...\r\n   \r\n   ```\r\n   void WriteBatches(std::vector<std::shared_ptr<RecordBatch>> batches, const FileWriterOptions& options) {\r\n     return util::RunInNursery([] (Nursery* nursery) {\r\n       std::unique_ptr<FileWriter> file_writer = OpenWriter();\r\n       FileWriterQueue file_writer_queue(nursery, std::move(file_writer));\r\n       for (const auto& batch : batches) {\r\n         ARROW_RETURN_NOT_OK(file_writer_queue.QueueBatch(batch));\r\n       }\r\n       return file_writer_queue.status();\r\n     }\r\n   }\r\n   ```\r\n   \r\n   ...and now you can be assured that an error occurring during QueueBatch will not cause a segmentation fault because the nursery will still block until any outstanding captures have resolved.\r\n   \r\n   > Is there a risk that these pointers may be kept alive too long (and delay the DoClose calls accordingly)?\r\n   \r\n   Yes, if there is a bug, but, the risk is no greater than what you have with...\r\n   \r\n   ```\r\n   FileWriterQueue::~FileWriterQueue() {\r\n     EnsureFinished();\r\n     writer_thread.join(); // Could deadlock / delay for a long time if there is a bug\r\n   }\r\n   ```\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-08-31T14:58:29.467+0000",
                    "updated": "2021-08-31T14:58:29.467+0000",
                    "started": "2021-08-31T14:58:29.467+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "644200",
                    "issueId": "13396255"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 21000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@670a6900[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@50dc35c6[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4c854384[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7d463dd7[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6fddb4b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@65d2f898[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@32d0ec5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@4f4923f2[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@27069ed3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@55e2a493[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3ed2d3cc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@38023157[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 21000,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Sep 09 12:16:57 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-09-09T12:16:57.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-13680/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-08-20T03:44:05.000+0000",
        "updated": "2021-09-09T12:17:11.000+0000",
        "timeoriginalestimate": null,
        "description": "The asynchronous nursery manages a set of asynchronous tasks and objects.  The nursery will not exit until all of those tasks have finished.  This allows one to safely capture fields for asynchronous callbacks.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 21000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Create an asynchronous nursery to simplify capture logic",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13396255/comment/17412534",
                    "id": "17412534",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 11084\n[https://github.com/apache/arrow/pull/11084]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-09-09T12:16:57.084+0000",
                    "updated": "2021-09-09T12:16:57.084+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0u2w8:",
        "customfield_12314139": null
    }
}