{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13232034",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13232034",
    "key": "ARROW-5275",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12344925",
                "id": "12344925",
                "description": "",
                "name": "0.14.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-07-04"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "aggregateprogress": {
            "progress": 4800,
            "total": 4800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 4800,
            "total": 4800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-5275/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 10,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13232034/worklog/239767",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4283: ARROW-5275: [C++] Generic filesystem tests\nURL: https://github.com/apache/arrow/pull/4283\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-09T15:31:43.019+0000",
                    "updated": "2019-05-09T15:31:43.019+0000",
                    "started": "2019-05-09T15:31:43.018+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "239767",
                    "issueId": "13232034"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13232034/worklog/239949",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4283: ARROW-5275: [C++] Generic filesystem tests\nURL: https://github.com/apache/arrow/pull/4283#discussion_r282668510\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/test-util.cc\n ##########\n @@ -0,0 +1,688 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <chrono>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/filesystem/test-util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace {\n+\n+static constexpr double kTimeSlack = 2.0;  // In seconds\n+\n+std::vector<FileStats> GetAllWithType(FileSystem* fs, FileType type) {\n+  Selector selector;\n+  selector.base_dir = \"\";\n+  selector.recursive = true;\n+  std::vector<FileStats> stats;\n+  ABORT_NOT_OK(fs->GetTargetStats(selector, &stats));\n+  std::vector<FileStats> result;\n+  for (const auto& st : stats) {\n+    if (st.type() == type) {\n+      result.push_back(st);\n+    }\n+  }\n+  return result;\n+}\n+\n+std::vector<FileStats> GetAllDirs(FileSystem* fs) {\n+  return GetAllWithType(fs, FileType::Directory);\n+}\n+\n+std::vector<FileStats> GetAllFiles(FileSystem* fs) {\n+  return GetAllWithType(fs, FileType::File);\n+}\n+\n+// Sort of vector of FileStats by lexicographic path order\n+void SortStats(std::vector<FileStats>* stats) {\n+  std::sort(stats->begin(), stats->end(),\n+            [](const FileStats& left, const FileStats& right) -> bool {\n+              return left.path() < right.path();\n+            });\n+}\n+\n+void AssertPaths(const std::vector<FileStats>& stats,\n+                 const std::vector<std::string>& expected_paths) {\n+  auto sorted_stats = stats;\n+  SortStats(&sorted_stats);\n+  std::vector<std::string> paths(stats.size());\n+  std::transform(stats.begin(), stats.end(), paths.begin(),\n+                 [&](const FileStats& st) { return st.path(); });\n+\n+  ASSERT_EQ(paths, expected_paths);\n+}\n+\n+void AssertAllDirs(FileSystem* fs, const std::vector<std::string>& expected_paths) {\n+  AssertPaths(GetAllDirs(fs), expected_paths);\n+}\n+\n+void AssertAllFiles(FileSystem* fs, const std::vector<std::string>& expected_paths) {\n+  AssertPaths(GetAllFiles(fs), expected_paths);\n+}\n+\n+Status WriteString(io::OutputStream* stream, const std::string& s) {\n+  return stream->Write(s.data(), static_cast<int64_t>(s.length()));\n+}\n+\n+void CreateFile(FileSystem* fs, const std::string& path, const std::string& data) {\n+  std::shared_ptr<io::OutputStream> stream;\n+  ASSERT_OK(fs->OpenOutputStream(path, &stream));\n+  ASSERT_OK(WriteString(stream.get(), data));\n+  ASSERT_OK(stream->Close());\n+}\n+\n+void AssertFileStats(const FileStats& st, const std::string& path, FileType type) {\n+  ASSERT_EQ(st.path(), path);\n+  ASSERT_EQ(st.type(), type);\n+}\n+\n+void AssertFileStats(const FileStats& st, const std::string& path, FileType type,\n+                     int64_t size) {\n+  AssertFileStats(st, path, type);\n+  ASSERT_EQ(st.size(), size);\n+}\n+\n+template <typename... Args>\n+void AssertFileStats(FileSystem* fs, const std::string& path, Args&&... args) {\n+  FileStats st;\n+  ASSERT_OK(fs->GetTargetStats(path, &st));\n+  AssertFileStats(st, path, std::forward<Args>(args)...);\n+}\n+\n+void AssertFileContents(FileSystem* fs, const std::string& path,\n+                        const std::string& expected_data) {\n+  FileStats st;\n+  ASSERT_OK(fs->GetTargetStats(path, &st));\n+  ASSERT_EQ(st.type(), FileType::File);\n+  ASSERT_EQ(st.size(), static_cast<int64_t>(expected_data.length()));\n+\n+  std::shared_ptr<io::InputStream> stream;\n+  std::shared_ptr<Buffer> buffer, leftover;\n+  ASSERT_OK(fs->OpenInputStream(path, &stream));\n+  ASSERT_OK(stream->Read(st.size(), &buffer));\n+  AssertBufferEqual(*buffer, expected_data);\n+  // No data left in stream\n+  ASSERT_OK(stream->Read(1, &leftover));\n+  ASSERT_EQ(leftover->size(), 0);\n+\n+  ASSERT_OK(stream->Close());\n+}\n+\n+void ValidateTimePoint(TimePoint tp) { ASSERT_GE(tp.time_since_epoch().count(), 0); }\n+\n+template <typename Duration>\n+void AssertDurationBetween(Duration d, double min_secs, double max_secs) {\n+  auto seconds = std::chrono::duration_cast<std::chrono::duration<double>>(d);\n+  ASSERT_GE(seconds.count(), min_secs);\n+  ASSERT_LE(seconds.count(), max_secs);\n+}\n+\n+};  // namespace\n+\n+////////////////////////////////////////////////////////////////////////////\n+// GenericFileSystemTest implementation\n+\n+// XXX is there a way we can test mtimes reliably and precisely?\n+\n+GenericFileSystemTest::~GenericFileSystemTest() {}\n+\n+void GenericFileSystemTest::TestEmpty(FileSystem* fs) {\n+  auto dirs = GetAllDirs(fs);\n+  ASSERT_EQ(dirs.size(), 0);\n+  auto files = GetAllFiles(fs);\n+  ASSERT_EQ(files.size(), 0);\n+}\n+\n+void GenericFileSystemTest::TestCreateDir(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB\"));\n+  ASSERT_OK(fs->CreateDir(\"AB/CD/EF\"));  // Recursive\n+  // Non-recursive, parent doesn't exist\n+  ASSERT_RAISES(IOError, fs->CreateDir(\"AB/GH/IJ\", false /* recursive */));\n+  ASSERT_OK(fs->CreateDir(\"AB/GH\", false /* recursive */));\n+  ASSERT_OK(fs->CreateDir(\"AB/GH/IJ\", false /* recursive */));\n+  // Idempotency\n+  ASSERT_OK(fs->CreateDir(\"AB/GH/IJ\", false /* recursive */));\n+  ASSERT_OK(fs->CreateDir(\"XY\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/CD\", \"AB/CD/EF\", \"AB/GH\", \"AB/GH/IJ\", \"XY\"});\n+  AssertAllFiles(fs, {});\n+\n+  // Cannot create a directory as child of a file\n+  CreateFile(fs, \"AB/def\", \"\");\n+  ASSERT_RAISES(IOError, fs->CreateDir(\"AB/def/EF/GH\", true /* recursive */));\n+  ASSERT_RAISES(IOError, fs->CreateDir(\"AB/def/EF\", false /* recursive */));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/CD\", \"AB/CD/EF\", \"AB/GH\", \"AB/GH/IJ\", \"XY\"});\n+  AssertAllFiles(fs, {\"AB/def\"});\n+}\n+\n+void GenericFileSystemTest::TestDeleteDir(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD/EF\"));\n+  ASSERT_OK(fs->CreateDir(\"AB/GH/IJ\"));\n+  ASSERT_OK(fs->DeleteDir(\"AB/CD\"));\n \n Review comment:\n   Note to self: should create some files here too.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-09T21:15:22.224+0000",
                    "updated": "2019-05-09T21:15:22.224+0000",
                    "started": "2019-05-09T21:15:22.224+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "239949",
                    "issueId": "13232034"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13232034/worklog/239952",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4283: ARROW-5275: [C++] Generic filesystem tests\nURL: https://github.com/apache/arrow/pull/4283#discussion_r282669834\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/test-util.cc\n ##########\n @@ -0,0 +1,688 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <chrono>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/filesystem/test-util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace {\n+\n+static constexpr double kTimeSlack = 2.0;  // In seconds\n+\n+std::vector<FileStats> GetAllWithType(FileSystem* fs, FileType type) {\n+  Selector selector;\n+  selector.base_dir = \"\";\n+  selector.recursive = true;\n+  std::vector<FileStats> stats;\n+  ABORT_NOT_OK(fs->GetTargetStats(selector, &stats));\n+  std::vector<FileStats> result;\n+  for (const auto& st : stats) {\n+    if (st.type() == type) {\n+      result.push_back(st);\n+    }\n+  }\n+  return result;\n+}\n+\n+std::vector<FileStats> GetAllDirs(FileSystem* fs) {\n+  return GetAllWithType(fs, FileType::Directory);\n+}\n+\n+std::vector<FileStats> GetAllFiles(FileSystem* fs) {\n+  return GetAllWithType(fs, FileType::File);\n+}\n+\n+// Sort of vector of FileStats by lexicographic path order\n+void SortStats(std::vector<FileStats>* stats) {\n+  std::sort(stats->begin(), stats->end(),\n+            [](const FileStats& left, const FileStats& right) -> bool {\n+              return left.path() < right.path();\n+            });\n+}\n+\n+void AssertPaths(const std::vector<FileStats>& stats,\n+                 const std::vector<std::string>& expected_paths) {\n+  auto sorted_stats = stats;\n+  SortStats(&sorted_stats);\n+  std::vector<std::string> paths(stats.size());\n+  std::transform(stats.begin(), stats.end(), paths.begin(),\n+                 [&](const FileStats& st) { return st.path(); });\n+\n+  ASSERT_EQ(paths, expected_paths);\n+}\n+\n+void AssertAllDirs(FileSystem* fs, const std::vector<std::string>& expected_paths) {\n+  AssertPaths(GetAllDirs(fs), expected_paths);\n+}\n+\n+void AssertAllFiles(FileSystem* fs, const std::vector<std::string>& expected_paths) {\n+  AssertPaths(GetAllFiles(fs), expected_paths);\n+}\n+\n+Status WriteString(io::OutputStream* stream, const std::string& s) {\n+  return stream->Write(s.data(), static_cast<int64_t>(s.length()));\n+}\n+\n+void CreateFile(FileSystem* fs, const std::string& path, const std::string& data) {\n+  std::shared_ptr<io::OutputStream> stream;\n+  ASSERT_OK(fs->OpenOutputStream(path, &stream));\n+  ASSERT_OK(WriteString(stream.get(), data));\n+  ASSERT_OK(stream->Close());\n+}\n+\n+void AssertFileStats(const FileStats& st, const std::string& path, FileType type) {\n+  ASSERT_EQ(st.path(), path);\n+  ASSERT_EQ(st.type(), type);\n+}\n+\n+void AssertFileStats(const FileStats& st, const std::string& path, FileType type,\n+                     int64_t size) {\n+  AssertFileStats(st, path, type);\n+  ASSERT_EQ(st.size(), size);\n+}\n+\n+template <typename... Args>\n+void AssertFileStats(FileSystem* fs, const std::string& path, Args&&... args) {\n+  FileStats st;\n+  ASSERT_OK(fs->GetTargetStats(path, &st));\n+  AssertFileStats(st, path, std::forward<Args>(args)...);\n+}\n+\n+void AssertFileContents(FileSystem* fs, const std::string& path,\n+                        const std::string& expected_data) {\n+  FileStats st;\n+  ASSERT_OK(fs->GetTargetStats(path, &st));\n+  ASSERT_EQ(st.type(), FileType::File);\n+  ASSERT_EQ(st.size(), static_cast<int64_t>(expected_data.length()));\n+\n+  std::shared_ptr<io::InputStream> stream;\n+  std::shared_ptr<Buffer> buffer, leftover;\n+  ASSERT_OK(fs->OpenInputStream(path, &stream));\n+  ASSERT_OK(stream->Read(st.size(), &buffer));\n+  AssertBufferEqual(*buffer, expected_data);\n+  // No data left in stream\n+  ASSERT_OK(stream->Read(1, &leftover));\n+  ASSERT_EQ(leftover->size(), 0);\n+\n+  ASSERT_OK(stream->Close());\n+}\n+\n+void ValidateTimePoint(TimePoint tp) { ASSERT_GE(tp.time_since_epoch().count(), 0); }\n+\n+template <typename Duration>\n+void AssertDurationBetween(Duration d, double min_secs, double max_secs) {\n+  auto seconds = std::chrono::duration_cast<std::chrono::duration<double>>(d);\n+  ASSERT_GE(seconds.count(), min_secs);\n+  ASSERT_LE(seconds.count(), max_secs);\n+}\n+\n+};  // namespace\n+\n+////////////////////////////////////////////////////////////////////////////\n+// GenericFileSystemTest implementation\n+\n+// XXX is there a way we can test mtimes reliably and precisely?\n+\n+GenericFileSystemTest::~GenericFileSystemTest() {}\n+\n+void GenericFileSystemTest::TestEmpty(FileSystem* fs) {\n+  auto dirs = GetAllDirs(fs);\n+  ASSERT_EQ(dirs.size(), 0);\n+  auto files = GetAllFiles(fs);\n+  ASSERT_EQ(files.size(), 0);\n+}\n+\n+void GenericFileSystemTest::TestCreateDir(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB\"));\n+  ASSERT_OK(fs->CreateDir(\"AB/CD/EF\"));  // Recursive\n+  // Non-recursive, parent doesn't exist\n+  ASSERT_RAISES(IOError, fs->CreateDir(\"AB/GH/IJ\", false /* recursive */));\n+  ASSERT_OK(fs->CreateDir(\"AB/GH\", false /* recursive */));\n+  ASSERT_OK(fs->CreateDir(\"AB/GH/IJ\", false /* recursive */));\n+  // Idempotency\n+  ASSERT_OK(fs->CreateDir(\"AB/GH/IJ\", false /* recursive */));\n+  ASSERT_OK(fs->CreateDir(\"XY\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/CD\", \"AB/CD/EF\", \"AB/GH\", \"AB/GH/IJ\", \"XY\"});\n+  AssertAllFiles(fs, {});\n+\n+  // Cannot create a directory as child of a file\n+  CreateFile(fs, \"AB/def\", \"\");\n+  ASSERT_RAISES(IOError, fs->CreateDir(\"AB/def/EF/GH\", true /* recursive */));\n+  ASSERT_RAISES(IOError, fs->CreateDir(\"AB/def/EF\", false /* recursive */));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/CD\", \"AB/CD/EF\", \"AB/GH\", \"AB/GH/IJ\", \"XY\"});\n+  AssertAllFiles(fs, {\"AB/def\"});\n+}\n+\n+void GenericFileSystemTest::TestDeleteDir(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD/EF\"));\n+  ASSERT_OK(fs->CreateDir(\"AB/GH/IJ\"));\n+  ASSERT_OK(fs->DeleteDir(\"AB/CD\"));\n+  ASSERT_OK(fs->DeleteDir(\"AB/GH/IJ\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/GH\"});\n+\n+  // File doesn't exist\n+  ASSERT_RAISES(IOError, fs->DeleteDir(\"AB/GH/IJ\"));\n+  ASSERT_RAISES(IOError, fs->DeleteDir(\"\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/GH\"});\n+\n+  // Not a directory\n+  CreateFile(fs, \"AB/def\", \"\");\n+  ASSERT_RAISES(IOError, fs->DeleteDir(\"AB/def\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/GH\"});\n+  AssertAllFiles(fs, {\"AB/def\"});\n+}\n+\n+void GenericFileSystemTest::TestDeleteFile(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB\"));\n+  CreateFile(fs, \"AB/def\", \"\");\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/def\"});\n+\n+  ASSERT_OK(fs->DeleteFile(\"AB/def\"));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {});\n+\n+  CreateFile(fs, \"abc\", \"data\");\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"abc\"});\n+\n+  ASSERT_OK(fs->DeleteFile(\"abc\"));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {});\n+\n+  // File doesn't exist\n+  ASSERT_RAISES(IOError, fs->DeleteFile(\"abc\"));\n+  ASSERT_RAISES(IOError, fs->DeleteFile(\"AB/def\"));\n+\n+  // Not a file\n+  ASSERT_RAISES(IOError, fs->DeleteFile(\"AB\"));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {});\n+}\n+\n+void GenericFileSystemTest::TestDeleteFiles(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB\"));\n+  CreateFile(fs, \"abc\", \"\");\n+  CreateFile(fs, \"AB/def\", \"123\");\n+  CreateFile(fs, \"AB/ghi\", \"456\");\n+  CreateFile(fs, \"AB/jkl\", \"789\");\n+  CreateFile(fs, \"AB/mno\", \"789\");\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/def\", \"AB/ghi\", \"AB/jkl\", \"AB/mno\", \"abc\"});\n+\n+  // All successful\n+  ASSERT_OK(fs->DeleteFiles({\"abc\", \"AB/def\"}));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/ghi\", \"AB/jkl\", \"AB/mno\"});\n+\n+  // One error: file doesn't exist\n+  ASSERT_RAISES(IOError, fs->DeleteFiles({\"xx\", \"AB/jkl\"}));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/ghi\", \"AB/mno\"});\n+\n+  // One error: not a file\n+  ASSERT_RAISES(IOError, fs->DeleteFiles({\"AB\", \"AB/mno\"}));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/ghi\"});\n+}\n+\n+void GenericFileSystemTest::TestMoveFile(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  ASSERT_OK(fs->CreateDir(\"EF\"));\n+  CreateFile(fs, \"abc\", \"data\");\n+  std::vector<std::string> all_dirs{\"AB\", \"AB/CD\", \"EF\"};\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"abc\"});\n+\n+  // Move inside root dir\n+  FileStats st;\n+  ASSERT_OK(fs->Move(\"abc\", \"def\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"def\"});\n+  AssertFileStats(fs, \"def\", FileType::File, 4);\n+  AssertFileContents(fs, \"def\", \"data\");\n+\n+  // Move out of root dir\n+  ASSERT_OK(fs->Move(\"def\", \"AB/CD/ghi\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/CD/ghi\"});\n+  AssertFileStats(fs, \"AB/CD/ghi\", FileType::File, 4);\n+  AssertFileContents(fs, \"AB/CD/ghi\", \"data\");\n+\n+  ASSERT_OK(fs->Move(\"AB/CD/ghi\", \"EF/jkl\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"EF/jkl\"});\n+  AssertFileStats(fs, \"EF/jkl\", FileType::File, 4);\n+  AssertFileContents(fs, \"EF/jkl\", \"data\");\n+\n+  // Move back into root dir\n+  ASSERT_OK(fs->Move(\"EF/jkl\", \"mno\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"mno\"});\n+  AssertFileStats(fs, \"mno\", FileType::File, 4);\n+  AssertFileContents(fs, \"mno\", \"data\");\n+\n+  // Destination is a file => clobber\n+  CreateFile(fs, \"AB/pqr\", \"other data\");\n+  AssertAllFiles(fs, {\"AB/pqr\", \"mno\"});\n+  ASSERT_OK(fs->Move(\"mno\", \"AB/pqr\"));\n+  AssertAllFiles(fs, {\"AB/pqr\"});\n+  AssertFileStats(fs, \"AB/pqr\", FileType::File, 4);\n+  AssertFileContents(fs, \"AB/pqr\", \"data\");\n+\n+  // Identical source and destination: allowed to succeed or raise IOError,\n+  // but should not lose data.\n+  auto err = fs->Move(\"AB/pqr\", \"AB/pqr\");\n+  if (!err.ok()) {\n+    ASSERT_RAISES(IOError, err);\n+  }\n+  AssertAllFiles(fs, {\"AB/pqr\"});\n+  AssertFileStats(fs, \"AB/pqr\", FileType::File, 4);\n+  AssertFileContents(fs, \"AB/pqr\", \"data\");\n+\n+  // Source doesn't exist\n+  ASSERT_RAISES(IOError, fs->Move(\"abc\", \"def\"));\n+  // Parent destination doesn't exist\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/pqr\", \"XX/mno\"));\n+  // Parent destination is not a directory\n+  CreateFile(fs, \"xxx\", \"\");\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/pqr\", \"xxx/mno\"));\n+  // Destination is a directory\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/pqr\", \"EF\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/pqr\", \"xxx\"});\n+}\n+\n+void GenericFileSystemTest::TestMoveDir(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  ASSERT_OK(fs->CreateDir(\"EF\"));\n+  CreateFile(fs, \"AB/abc\", \"abc data\");\n+  CreateFile(fs, \"AB/CD/def\", \"def data\");\n+  CreateFile(fs, \"EF/ghi\", \"ghi data\");\n+  AssertAllDirs(fs, {\"AB\", \"AB/CD\", \"EF\"});\n+  AssertAllFiles(fs, {\"AB/CD/def\", \"AB/abc\", \"EF/ghi\"});\n+\n+  // Move inside root dir\n+  ASSERT_OK(fs->Move(\"AB\", \"GH\"));\n+  AssertAllDirs(fs, {\"EF\", \"GH\", \"GH/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"GH/CD/def\", \"GH/abc\"});\n+\n+  // Move out of root dir\n+  ASSERT_OK(fs->Move(\"GH\", \"EF/IJ\"));\n+  AssertAllDirs(fs, {\"EF\", \"EF/IJ\", \"EF/IJ/CD\"});\n+  AssertAllFiles(fs, {\"EF/IJ/CD/def\", \"EF/IJ/abc\", \"EF/ghi\"});\n+\n+  // Move back into root dir\n+  ASSERT_OK(fs->Move(\"EF/IJ\", \"KL\"));\n+  AssertAllDirs(fs, {\"EF\", \"KL\", \"KL/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"KL/CD/def\", \"KL/abc\"});\n+\n+  // Destination is a file => clobber\n+  CreateFile(fs, \"MN\", \"\");\n+  ASSERT_OK(fs->Move(\"KL\", \"MN\"));\n+  AssertAllDirs(fs, {\"EF\", \"MN\", \"MN/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"MN/CD/def\", \"MN/abc\"});\n+\n+  // Identical source and destination: allowed to succeed or raise IOError,\n+  // but should not lose data.\n+  Status st = fs->Move(\"MN\", \"MN\");\n+  if (!st.ok()) {\n+    ASSERT_RAISES(IOError, st);\n+  }\n+  AssertAllDirs(fs, {\"EF\", \"MN\", \"MN/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"MN/CD/def\", \"MN/abc\"});\n+\n+  // Destination is a directory\n+  ASSERT_RAISES(IOError, fs->Move(\"MN\", \"EF\"));\n+  AssertAllDirs(fs, {\"EF\", \"MN\", \"MN/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"MN/CD/def\", \"MN/abc\"});\n+\n+  // (other errors tested in TestMoveFile)\n+\n+  // File contents didn't change\n+  AssertFileContents(fs, \"MN/abc\", \"abc data\");\n+  AssertFileContents(fs, \"MN/CD/def\", \"def data\");\n+}\n+\n+void GenericFileSystemTest::TestCopyFile(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  ASSERT_OK(fs->CreateDir(\"EF\"));\n+  CreateFile(fs, \"AB/abc\", \"data\");\n+  std::vector<std::string> all_dirs{\"AB\", \"AB/CD\", \"EF\"};\n+\n+  // Copy into root dir\n+  ASSERT_OK(fs->CopyFile(\"AB/abc\", \"def\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/abc\", \"def\"});\n+\n+  // Copy out of root dir\n+  ASSERT_OK(fs->CopyFile(\"def\", \"EF/ghi\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/abc\", \"EF/ghi\", \"def\"});\n+\n+  // Overwrite contents for one file => other data shouldn't change\n+  CreateFile(fs, \"def\", \"other data\");\n+  AssertFileContents(fs, \"AB/abc\", \"data\");\n+  AssertFileContents(fs, \"def\", \"other data\");\n+  AssertFileContents(fs, \"EF/ghi\", \"data\");\n+\n+  // Destination is a file => clobber\n+  ASSERT_OK(fs->CopyFile(\"def\", \"AB/abc\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/abc\", \"EF/ghi\", \"def\"});\n+  AssertFileContents(fs, \"AB/abc\", \"other data\");\n+  AssertFileContents(fs, \"def\", \"other data\");\n+  AssertFileContents(fs, \"EF/ghi\", \"data\");\n+\n+  // Identical source and destination: allowed to succeed or raise IOError,\n+  // but should not lose data.\n+  Status st = fs->CopyFile(\"def\", \"def\");\n+  if (!st.ok()) {\n+    ASSERT_RAISES(IOError, st);\n+  }\n+  AssertAllFiles(fs, {\"AB/abc\", \"EF/ghi\", \"def\"});\n+  AssertFileContents(fs, \"def\", \"other data\");\n+\n+  // Destination is a directory\n+  ASSERT_RAISES(IOError, fs->CopyFile(\"def\", \"AB\"));\n+  // Source doesn't exist\n+  ASSERT_RAISES(IOError, fs->CopyFile(\"abc\", \"xxx\"));\n+  // Parent destination doesn't exist\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/abc\", \"XX/mno\"));\n+  // Parent destination is not a directory\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/abc\", \"def/mno\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/abc\", \"EF/ghi\", \"def\"});\n+}\n+\n+void GenericFileSystemTest::TestGetTargetStatsSingle(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  CreateFile(fs, \"AB/CD/ghi\", \"some data\");\n+\n+  FileStats st;\n+  TimePoint first_time;\n+  ASSERT_OK(fs->GetTargetStats(\"AB\", &st));\n+  AssertFileStats(st, \"AB\", FileType::Directory);\n+  ASSERT_EQ(st.base_name(), \"AB\");\n+  ASSERT_EQ(st.size(), kNoSize);\n+  first_time = st.mtime();\n+  ValidateTimePoint(first_time);\n+\n+  ASSERT_OK(fs->GetTargetStats(\"AB/CD\", &st));\n+  AssertFileStats(st, \"AB/CD\", FileType::Directory);\n+  ASSERT_EQ(st.base_name(), \"CD\");\n+  ASSERT_EQ(st.size(), kNoSize);\n+  // AB/CD was created a little after AB\n+  AssertDurationBetween(st.mtime() - first_time, 0.0, kTimeSlack);\n+\n+  ASSERT_OK(fs->GetTargetStats(\"AB/CD/ghi\", &st));\n+  AssertFileStats(st, \"AB/CD/ghi\", FileType::File, 9);\n+  ASSERT_EQ(st.base_name(), \"ghi\");\n+  AssertDurationBetween(st.mtime() - first_time, 0.0, kTimeSlack);\n+\n+  ASSERT_OK(fs->GetTargetStats(\"zz\", &st));\n+  AssertFileStats(st, \"zz\", FileType::NonExistent);\n+  ASSERT_EQ(st.base_name(), \"zz\");\n+  ASSERT_EQ(st.size(), kNoSize);\n+  ASSERT_EQ(st.mtime(), kNoTime);\n+\n+  // Invalid path\n+  // XXX will this really be rejected by all filesystems?\n+  ASSERT_RAISES(Invalid, fs->GetTargetStats(\"//foo//bar//baz//\", &st));\n+}\n+\n+void GenericFileSystemTest::TestGetTargetStatsVector(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  CreateFile(fs, \"AB/CD/ghi\", \"some data\");\n+\n+  std::vector<FileStats> stats;\n+  TimePoint first_time;\n+  ASSERT_OK(\n+      fs->GetTargetStats({\"AB\", \"AB/CD\", \"AB/zz\", \"zz\", \"XX/zz\", \"AB/CD/ghi\"}, &stats));\n+  ASSERT_EQ(stats.size(), 6);\n+  AssertFileStats(stats[0], \"AB\", FileType::Directory);\n+  first_time = stats[0].mtime();\n+  ValidateTimePoint(first_time);\n+  AssertFileStats(stats[1], \"AB/CD\", FileType::Directory);\n+  AssertFileStats(stats[2], \"AB/zz\", FileType::NonExistent);\n+  AssertFileStats(stats[3], \"zz\", FileType::NonExistent);\n+  AssertFileStats(stats[4], \"XX/zz\", FileType::NonExistent);\n+  ASSERT_EQ(stats[4].size(), kNoSize);\n+  ASSERT_EQ(stats[4].mtime(), kNoTime);\n+  AssertFileStats(stats[5], \"AB/CD/ghi\", FileType::File, 9);\n+  AssertDurationBetween(stats[5].mtime() - first_time, 0.0, kTimeSlack);\n+\n+  // Check the mtime is the same from one call to the other\n+  FileStats st;\n+  ASSERT_OK(fs->GetTargetStats(\"AB\", &st));\n+  AssertFileStats(st, \"AB\", FileType::Directory);\n+  ASSERT_EQ(st.mtime(), first_time);\n+\n+  // Invalid path\n+  // XXX will this really be rejected by all filesystems?\n+  ASSERT_RAISES(Invalid,\n+                fs->GetTargetStats({\"AB\", \"AB/CD\", \"//foo//bar//baz//\"}, &stats));\n+}\n+\n+void GenericFileSystemTest::TestGetTargetStatsSelector(FileSystem* fs) {\n+  // Non-recursive tests for GetTargetStats(Selector, ...).\n \n Review comment:\n   Note to self: forgot to add recursive tests.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-09T21:19:22.298+0000",
                    "updated": "2019-05-09T21:19:22.298+0000",
                    "started": "2019-05-09T21:19:22.298+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "239952",
                    "issueId": "13232034"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13232034/worklog/242752",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #4283: ARROW-5275: [C++] Generic filesystem tests\nURL: https://github.com/apache/arrow/pull/4283#issuecomment-492782700\n \n \n   Starting to review this\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-15T19:02:06.123+0000",
                    "updated": "2019-05-15T19:02:06.123+0000",
                    "started": "2019-05-15T19:02:06.123+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "242752",
                    "issueId": "13232034"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13232034/worklog/242995",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4283: ARROW-5275: [C++] Generic filesystem tests\nURL: https://github.com/apache/arrow/pull/4283#discussion_r284495441\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/test-util.cc\n ##########\n @@ -0,0 +1,704 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <chrono>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/filesystem/test-util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace {\n+\n+static constexpr double kTimeSlack = 2.0;  // In seconds\n+\n+std::vector<FileStats> GetAllWithType(FileSystem* fs, FileType type) {\n+  Selector selector;\n+  selector.base_dir = \"\";\n+  selector.recursive = true;\n+  std::vector<FileStats> stats;\n+  ABORT_NOT_OK(fs->GetTargetStats(selector, &stats));\n+  std::vector<FileStats> result;\n+  for (const auto& st : stats) {\n+    if (st.type() == type) {\n+      result.push_back(st);\n+    }\n+  }\n+  return result;\n+}\n+\n+std::vector<FileStats> GetAllDirs(FileSystem* fs) {\n+  return GetAllWithType(fs, FileType::Directory);\n+}\n+\n+std::vector<FileStats> GetAllFiles(FileSystem* fs) {\n+  return GetAllWithType(fs, FileType::File);\n+}\n+\n+// Sort of vector of FileStats by lexicographic path order\n+void SortStats(std::vector<FileStats>* stats) {\n+  std::sort(stats->begin(), stats->end(),\n+            [](const FileStats& left, const FileStats& right) -> bool {\n+              return left.path() < right.path();\n+            });\n+}\n+\n+void AssertPaths(const std::vector<FileStats>& stats,\n+                 const std::vector<std::string>& expected_paths) {\n+  auto sorted_stats = stats;\n+  SortStats(&sorted_stats);\n+  std::vector<std::string> paths(stats.size());\n+  std::transform(stats.begin(), stats.end(), paths.begin(),\n+                 [&](const FileStats& st) { return st.path(); });\n+\n+  ASSERT_EQ(paths, expected_paths);\n+}\n+\n+void AssertAllDirs(FileSystem* fs, const std::vector<std::string>& expected_paths) {\n+  AssertPaths(GetAllDirs(fs), expected_paths);\n+}\n+\n+void AssertAllFiles(FileSystem* fs, const std::vector<std::string>& expected_paths) {\n+  AssertPaths(GetAllFiles(fs), expected_paths);\n+}\n+\n+Status WriteString(io::OutputStream* stream, const std::string& s) {\n \n Review comment:\n   Not important here, but reminder for public APIs that argument order is in, in-out, then out\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-16T00:07:13.255+0000",
                    "updated": "2019-05-16T00:07:13.255+0000",
                    "started": "2019-05-16T00:07:13.254+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "242995",
                    "issueId": "13232034"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13232034/worklog/242997",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4283: ARROW-5275: [C++] Generic filesystem tests\nURL: https://github.com/apache/arrow/pull/4283#discussion_r284494286\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/path-util.cc\n ##########\n @@ -16,27 +16,37 @@\n // under the License.\n \n #include \"arrow/filesystem/path-util.h\"\n+#include \"arrow/util/logging.h\"\n+#include \"arrow/util/string_view.h\"\n \n namespace arrow {\n namespace fs {\n namespace internal {\n \n-// TODO Add unit tests for these functions.\n+static constexpr char kSep = '/';\n \n-std::vector<std::string> SplitAbstractPath(const std::string& s) {\n+std::vector<std::string> SplitAbstractPath(const std::string& path) {\n \n Review comment:\n   The input argument to this function could even be `util::string_view`\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-16T00:07:13.260+0000",
                    "updated": "2019-05-16T00:07:13.260+0000",
                    "started": "2019-05-16T00:07:13.260+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "242997",
                    "issueId": "13232034"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13232034/worklog/242996",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4283: ARROW-5275: [C++] Generic filesystem tests\nURL: https://github.com/apache/arrow/pull/4283#discussion_r284496544\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/test-util.cc\n ##########\n @@ -0,0 +1,704 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <chrono>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/filesystem/test-util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace {\n+\n+static constexpr double kTimeSlack = 2.0;  // In seconds\n+\n+std::vector<FileStats> GetAllWithType(FileSystem* fs, FileType type) {\n+  Selector selector;\n+  selector.base_dir = \"\";\n+  selector.recursive = true;\n+  std::vector<FileStats> stats;\n+  ABORT_NOT_OK(fs->GetTargetStats(selector, &stats));\n+  std::vector<FileStats> result;\n+  for (const auto& st : stats) {\n+    if (st.type() == type) {\n+      result.push_back(st);\n+    }\n+  }\n+  return result;\n+}\n+\n+std::vector<FileStats> GetAllDirs(FileSystem* fs) {\n+  return GetAllWithType(fs, FileType::Directory);\n+}\n+\n+std::vector<FileStats> GetAllFiles(FileSystem* fs) {\n+  return GetAllWithType(fs, FileType::File);\n+}\n+\n+// Sort of vector of FileStats by lexicographic path order\n+void SortStats(std::vector<FileStats>* stats) {\n+  std::sort(stats->begin(), stats->end(),\n+            [](const FileStats& left, const FileStats& right) -> bool {\n+              return left.path() < right.path();\n+            });\n+}\n+\n+void AssertPaths(const std::vector<FileStats>& stats,\n+                 const std::vector<std::string>& expected_paths) {\n+  auto sorted_stats = stats;\n+  SortStats(&sorted_stats);\n+  std::vector<std::string> paths(stats.size());\n+  std::transform(stats.begin(), stats.end(), paths.begin(),\n+                 [&](const FileStats& st) { return st.path(); });\n+\n+  ASSERT_EQ(paths, expected_paths);\n+}\n+\n+void AssertAllDirs(FileSystem* fs, const std::vector<std::string>& expected_paths) {\n+  AssertPaths(GetAllDirs(fs), expected_paths);\n+}\n+\n+void AssertAllFiles(FileSystem* fs, const std::vector<std::string>& expected_paths) {\n+  AssertPaths(GetAllFiles(fs), expected_paths);\n+}\n+\n+Status WriteString(io::OutputStream* stream, const std::string& s) {\n+  return stream->Write(s.data(), static_cast<int64_t>(s.length()));\n+}\n+\n+void CreateFile(FileSystem* fs, const std::string& path, const std::string& data) {\n+  std::shared_ptr<io::OutputStream> stream;\n+  ASSERT_OK(fs->OpenOutputStream(path, &stream));\n+  ASSERT_OK(WriteString(stream.get(), data));\n+  ASSERT_OK(stream->Close());\n+}\n+\n+void AssertFileStats(const FileStats& st, const std::string& path, FileType type) {\n+  ASSERT_EQ(st.path(), path);\n+  ASSERT_EQ(st.type(), type);\n+}\n+\n+void AssertFileStats(const FileStats& st, const std::string& path, FileType type,\n+                     int64_t size) {\n+  AssertFileStats(st, path, type);\n+  ASSERT_EQ(st.size(), size);\n+}\n+\n+template <typename... Args>\n+void AssertFileStats(FileSystem* fs, const std::string& path, Args&&... args) {\n+  FileStats st;\n+  ASSERT_OK(fs->GetTargetStats(path, &st));\n+  AssertFileStats(st, path, std::forward<Args>(args)...);\n+}\n+\n+void AssertFileContents(FileSystem* fs, const std::string& path,\n+                        const std::string& expected_data) {\n+  FileStats st;\n+  ASSERT_OK(fs->GetTargetStats(path, &st));\n+  ASSERT_EQ(st.type(), FileType::File);\n+  ASSERT_EQ(st.size(), static_cast<int64_t>(expected_data.length()));\n+\n+  std::shared_ptr<io::InputStream> stream;\n+  std::shared_ptr<Buffer> buffer, leftover;\n+  ASSERT_OK(fs->OpenInputStream(path, &stream));\n+  ASSERT_OK(stream->Read(st.size(), &buffer));\n+  AssertBufferEqual(*buffer, expected_data);\n+  // No data left in stream\n+  ASSERT_OK(stream->Read(1, &leftover));\n+  ASSERT_EQ(leftover->size(), 0);\n+\n+  ASSERT_OK(stream->Close());\n+}\n+\n+void ValidateTimePoint(TimePoint tp) { ASSERT_GE(tp.time_since_epoch().count(), 0); }\n+\n+template <typename Duration>\n+void AssertDurationBetween(Duration d, double min_secs, double max_secs) {\n+  auto seconds = std::chrono::duration_cast<std::chrono::duration<double>>(d);\n+  ASSERT_GE(seconds.count(), min_secs);\n+  ASSERT_LE(seconds.count(), max_secs);\n+}\n+\n+};  // namespace\n+\n+////////////////////////////////////////////////////////////////////////////\n+// GenericFileSystemTest implementation\n+\n+// XXX is there a way we can test mtimes reliably and precisely?\n+\n+GenericFileSystemTest::~GenericFileSystemTest() {}\n+\n+void GenericFileSystemTest::TestEmpty(FileSystem* fs) {\n+  auto dirs = GetAllDirs(fs);\n+  ASSERT_EQ(dirs.size(), 0);\n+  auto files = GetAllFiles(fs);\n+  ASSERT_EQ(files.size(), 0);\n+}\n+\n+void GenericFileSystemTest::TestCreateDir(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB\"));\n+  ASSERT_OK(fs->CreateDir(\"AB/CD/EF\"));  // Recursive\n+  // Non-recursive, parent doesn't exist\n+  ASSERT_RAISES(IOError, fs->CreateDir(\"AB/GH/IJ\", false /* recursive */));\n+  ASSERT_OK(fs->CreateDir(\"AB/GH\", false /* recursive */));\n+  ASSERT_OK(fs->CreateDir(\"AB/GH/IJ\", false /* recursive */));\n+  // Idempotency\n+  ASSERT_OK(fs->CreateDir(\"AB/GH/IJ\", false /* recursive */));\n+  ASSERT_OK(fs->CreateDir(\"XY\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/CD\", \"AB/CD/EF\", \"AB/GH\", \"AB/GH/IJ\", \"XY\"});\n+  AssertAllFiles(fs, {});\n+\n+  // Cannot create a directory as child of a file\n+  CreateFile(fs, \"AB/def\", \"\");\n+  ASSERT_RAISES(IOError, fs->CreateDir(\"AB/def/EF/GH\", true /* recursive */));\n+  ASSERT_RAISES(IOError, fs->CreateDir(\"AB/def/EF\", false /* recursive */));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/CD\", \"AB/CD/EF\", \"AB/GH\", \"AB/GH/IJ\", \"XY\"});\n+  AssertAllFiles(fs, {\"AB/def\"});\n+}\n+\n+void GenericFileSystemTest::TestDeleteDir(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD/EF\"));\n+  ASSERT_OK(fs->CreateDir(\"AB/GH/IJ\"));\n+  CreateFile(fs, \"AB/abc\", \"\");\n+  CreateFile(fs, \"AB/CD/def\", \"\");\n+  CreateFile(fs, \"AB/CD/EF/ghi\", \"\");\n+  ASSERT_OK(fs->DeleteDir(\"AB/CD\"));\n+  ASSERT_OK(fs->DeleteDir(\"AB/GH/IJ\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/GH\"});\n+  AssertAllFiles(fs, {\"AB/abc\"});\n+\n+  // File doesn't exist\n+  ASSERT_RAISES(IOError, fs->DeleteDir(\"AB/GH/IJ\"));\n+  ASSERT_RAISES(IOError, fs->DeleteDir(\"\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/GH\"});\n+\n+  // Not a directory\n+  CreateFile(fs, \"AB/def\", \"\");\n+  ASSERT_RAISES(IOError, fs->DeleteDir(\"AB/def\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/GH\"});\n+  AssertAllFiles(fs, {\"AB/abc\", \"AB/def\"});\n+}\n+\n+void GenericFileSystemTest::TestDeleteFile(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB\"));\n+  CreateFile(fs, \"AB/def\", \"\");\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/def\"});\n+\n+  ASSERT_OK(fs->DeleteFile(\"AB/def\"));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {});\n+\n+  CreateFile(fs, \"abc\", \"data\");\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"abc\"});\n+\n+  ASSERT_OK(fs->DeleteFile(\"abc\"));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {});\n+\n+  // File doesn't exist\n+  ASSERT_RAISES(IOError, fs->DeleteFile(\"abc\"));\n+  ASSERT_RAISES(IOError, fs->DeleteFile(\"AB/def\"));\n+\n+  // Not a file\n+  ASSERT_RAISES(IOError, fs->DeleteFile(\"AB\"));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {});\n+}\n+\n+void GenericFileSystemTest::TestDeleteFiles(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB\"));\n+  CreateFile(fs, \"abc\", \"\");\n+  CreateFile(fs, \"AB/def\", \"123\");\n+  CreateFile(fs, \"AB/ghi\", \"456\");\n+  CreateFile(fs, \"AB/jkl\", \"789\");\n+  CreateFile(fs, \"AB/mno\", \"789\");\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/def\", \"AB/ghi\", \"AB/jkl\", \"AB/mno\", \"abc\"});\n+\n+  // All successful\n+  ASSERT_OK(fs->DeleteFiles({\"abc\", \"AB/def\"}));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/ghi\", \"AB/jkl\", \"AB/mno\"});\n+\n+  // One error: file doesn't exist\n+  ASSERT_RAISES(IOError, fs->DeleteFiles({\"xx\", \"AB/jkl\"}));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/ghi\", \"AB/mno\"});\n+\n+  // One error: not a file\n+  ASSERT_RAISES(IOError, fs->DeleteFiles({\"AB\", \"AB/mno\"}));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/ghi\"});\n+}\n+\n+void GenericFileSystemTest::TestMoveFile(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  ASSERT_OK(fs->CreateDir(\"EF\"));\n+  CreateFile(fs, \"abc\", \"data\");\n+  std::vector<std::string> all_dirs{\"AB\", \"AB/CD\", \"EF\"};\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"abc\"});\n+\n+  // Move inside root dir\n+  FileStats st;\n+  ASSERT_OK(fs->Move(\"abc\", \"def\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"def\"});\n+  AssertFileStats(fs, \"def\", FileType::File, 4);\n+  AssertFileContents(fs, \"def\", \"data\");\n+\n+  // Move out of root dir\n+  ASSERT_OK(fs->Move(\"def\", \"AB/CD/ghi\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/CD/ghi\"});\n+  AssertFileStats(fs, \"AB/CD/ghi\", FileType::File, 4);\n+  AssertFileContents(fs, \"AB/CD/ghi\", \"data\");\n+\n+  ASSERT_OK(fs->Move(\"AB/CD/ghi\", \"EF/jkl\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"EF/jkl\"});\n+  AssertFileStats(fs, \"EF/jkl\", FileType::File, 4);\n+  AssertFileContents(fs, \"EF/jkl\", \"data\");\n+\n+  // Move back into root dir\n+  ASSERT_OK(fs->Move(\"EF/jkl\", \"mno\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"mno\"});\n+  AssertFileStats(fs, \"mno\", FileType::File, 4);\n+  AssertFileContents(fs, \"mno\", \"data\");\n+\n+  // Destination is a file => clobber\n+  CreateFile(fs, \"AB/pqr\", \"other data\");\n+  AssertAllFiles(fs, {\"AB/pqr\", \"mno\"});\n+  ASSERT_OK(fs->Move(\"mno\", \"AB/pqr\"));\n+  AssertAllFiles(fs, {\"AB/pqr\"});\n+  AssertFileStats(fs, \"AB/pqr\", FileType::File, 4);\n+  AssertFileContents(fs, \"AB/pqr\", \"data\");\n+\n+  // Identical source and destination: allowed to succeed or raise IOError,\n+  // but should not lose data.\n+  auto err = fs->Move(\"AB/pqr\", \"AB/pqr\");\n+  if (!err.ok()) {\n+    ASSERT_RAISES(IOError, err);\n+  }\n+  AssertAllFiles(fs, {\"AB/pqr\"});\n+  AssertFileStats(fs, \"AB/pqr\", FileType::File, 4);\n+  AssertFileContents(fs, \"AB/pqr\", \"data\");\n+\n+  // Source doesn't exist\n+  ASSERT_RAISES(IOError, fs->Move(\"abc\", \"def\"));\n+  // Parent destination doesn't exist\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/pqr\", \"XX/mno\"));\n+  // Parent destination is not a directory\n+  CreateFile(fs, \"xxx\", \"\");\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/pqr\", \"xxx/mno\"));\n+  // Destination is a directory\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/pqr\", \"EF\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/pqr\", \"xxx\"});\n+}\n+\n+void GenericFileSystemTest::TestMoveDir(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  ASSERT_OK(fs->CreateDir(\"EF\"));\n+  CreateFile(fs, \"AB/abc\", \"abc data\");\n+  CreateFile(fs, \"AB/CD/def\", \"def data\");\n+  CreateFile(fs, \"EF/ghi\", \"ghi data\");\n+  AssertAllDirs(fs, {\"AB\", \"AB/CD\", \"EF\"});\n+  AssertAllFiles(fs, {\"AB/CD/def\", \"AB/abc\", \"EF/ghi\"});\n+\n+  // Move inside root dir\n+  ASSERT_OK(fs->Move(\"AB\", \"GH\"));\n+  AssertAllDirs(fs, {\"EF\", \"GH\", \"GH/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"GH/CD/def\", \"GH/abc\"});\n+\n+  // Move out of root dir\n+  ASSERT_OK(fs->Move(\"GH\", \"EF/IJ\"));\n+  AssertAllDirs(fs, {\"EF\", \"EF/IJ\", \"EF/IJ/CD\"});\n+  AssertAllFiles(fs, {\"EF/IJ/CD/def\", \"EF/IJ/abc\", \"EF/ghi\"});\n+\n+  // Move back into root dir\n+  ASSERT_OK(fs->Move(\"EF/IJ\", \"KL\"));\n+  AssertAllDirs(fs, {\"EF\", \"KL\", \"KL/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"KL/CD/def\", \"KL/abc\"});\n+\n+  // Destination is a file => clobber\n+  CreateFile(fs, \"MN\", \"\");\n+  ASSERT_OK(fs->Move(\"KL\", \"MN\"));\n+  AssertAllDirs(fs, {\"EF\", \"MN\", \"MN/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"MN/CD/def\", \"MN/abc\"});\n+\n+  // Identical source and destination: allowed to succeed or raise IOError,\n+  // but should not lose data.\n+  Status st = fs->Move(\"MN\", \"MN\");\n+  if (!st.ok()) {\n+    ASSERT_RAISES(IOError, st);\n+  }\n+  AssertAllDirs(fs, {\"EF\", \"MN\", \"MN/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"MN/CD/def\", \"MN/abc\"});\n+\n+  // Destination is a directory\n+  ASSERT_RAISES(IOError, fs->Move(\"MN\", \"EF\"));\n+  AssertAllDirs(fs, {\"EF\", \"MN\", \"MN/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"MN/CD/def\", \"MN/abc\"});\n+\n+  // (other errors tested in TestMoveFile)\n+\n+  // File contents didn't change\n+  AssertFileContents(fs, \"MN/abc\", \"abc data\");\n+  AssertFileContents(fs, \"MN/CD/def\", \"def data\");\n+}\n+\n+void GenericFileSystemTest::TestCopyFile(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  ASSERT_OK(fs->CreateDir(\"EF\"));\n+  CreateFile(fs, \"AB/abc\", \"data\");\n+  std::vector<std::string> all_dirs{\"AB\", \"AB/CD\", \"EF\"};\n+\n+  // Copy into root dir\n+  ASSERT_OK(fs->CopyFile(\"AB/abc\", \"def\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/abc\", \"def\"});\n+\n+  // Copy out of root dir\n+  ASSERT_OK(fs->CopyFile(\"def\", \"EF/ghi\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/abc\", \"EF/ghi\", \"def\"});\n+\n+  // Overwrite contents for one file => other data shouldn't change\n+  CreateFile(fs, \"def\", \"other data\");\n+  AssertFileContents(fs, \"AB/abc\", \"data\");\n+  AssertFileContents(fs, \"def\", \"other data\");\n+  AssertFileContents(fs, \"EF/ghi\", \"data\");\n+\n+  // Destination is a file => clobber\n+  ASSERT_OK(fs->CopyFile(\"def\", \"AB/abc\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/abc\", \"EF/ghi\", \"def\"});\n+  AssertFileContents(fs, \"AB/abc\", \"other data\");\n+  AssertFileContents(fs, \"def\", \"other data\");\n+  AssertFileContents(fs, \"EF/ghi\", \"data\");\n+\n+  // Identical source and destination: allowed to succeed or raise IOError,\n+  // but should not lose data.\n+  Status st = fs->CopyFile(\"def\", \"def\");\n+  if (!st.ok()) {\n+    ASSERT_RAISES(IOError, st);\n+  }\n+  AssertAllFiles(fs, {\"AB/abc\", \"EF/ghi\", \"def\"});\n+  AssertFileContents(fs, \"def\", \"other data\");\n+\n+  // Destination is a directory\n+  ASSERT_RAISES(IOError, fs->CopyFile(\"def\", \"AB\"));\n+  // Source doesn't exist\n+  ASSERT_RAISES(IOError, fs->CopyFile(\"abc\", \"xxx\"));\n+  // Parent destination doesn't exist\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/abc\", \"XX/mno\"));\n+  // Parent destination is not a directory\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/abc\", \"def/mno\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/abc\", \"EF/ghi\", \"def\"});\n+}\n+\n+void GenericFileSystemTest::TestGetTargetStatsSingle(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  CreateFile(fs, \"AB/CD/ghi\", \"some data\");\n+\n+  FileStats st;\n+  TimePoint first_time;\n+  ASSERT_OK(fs->GetTargetStats(\"AB\", &st));\n+  AssertFileStats(st, \"AB\", FileType::Directory);\n+  ASSERT_EQ(st.base_name(), \"AB\");\n+  ASSERT_EQ(st.size(), kNoSize);\n+  first_time = st.mtime();\n+  ValidateTimePoint(first_time);\n+\n+  ASSERT_OK(fs->GetTargetStats(\"AB/CD\", &st));\n+  AssertFileStats(st, \"AB/CD\", FileType::Directory);\n+  ASSERT_EQ(st.base_name(), \"CD\");\n+  ASSERT_EQ(st.size(), kNoSize);\n+  // AB/CD was created a little after AB\n+  AssertDurationBetween(st.mtime() - first_time, 0.0, kTimeSlack);\n+\n+  ASSERT_OK(fs->GetTargetStats(\"AB/CD/ghi\", &st));\n+  AssertFileStats(st, \"AB/CD/ghi\", FileType::File, 9);\n+  ASSERT_EQ(st.base_name(), \"ghi\");\n+  AssertDurationBetween(st.mtime() - first_time, 0.0, kTimeSlack);\n+\n+  ASSERT_OK(fs->GetTargetStats(\"zz\", &st));\n+  AssertFileStats(st, \"zz\", FileType::NonExistent);\n+  ASSERT_EQ(st.base_name(), \"zz\");\n+  ASSERT_EQ(st.size(), kNoSize);\n+  ASSERT_EQ(st.mtime(), kNoTime);\n+\n+  // Invalid path\n+  // XXX will this really be rejected by all filesystems?\n \n Review comment:\n   Debatable. Note we also have to care about Windows filesystem. Speaking of Windows, are you thinking about translating user paths into Windows paths? It would be nice to work with just forward slashes :/\r\n   \r\n   I've seen some weird file paths for accessing network directories inside large enterprises so this may be a place we end up spending some time\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-16T00:07:13.260+0000",
                    "updated": "2019-05-16T00:07:13.260+0000",
                    "started": "2019-05-16T00:07:13.260+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "242996",
                    "issueId": "13232034"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13232034/worklog/242998",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4283: ARROW-5275: [C++] Generic filesystem tests\nURL: https://github.com/apache/arrow/pull/4283#discussion_r284494590\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/path-util.h\n ##########\n @@ -49,7 +53,7 @@ std::string JoinAbstractPath(StringIt it, StringIt end) {\n   std::string path;\n   for (; it != end; ++it) {\n     if (!path.empty()) {\n-      path += \"/\";\n+      path += '/';\n \n Review comment:\n   This nuance is subtle\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-16T00:07:13.566+0000",
                    "updated": "2019-05-16T00:07:13.566+0000",
                    "started": "2019-05-16T00:07:13.566+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "242998",
                    "issueId": "13232034"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13232034/worklog/243008",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on pull request #4283: ARROW-5275: [C++] Generic filesystem tests\nURL: https://github.com/apache/arrow/pull/4283\n \n \n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-16T00:21:54.367+0000",
                    "updated": "2019-05-16T00:21:54.367+0000",
                    "started": "2019-05-16T00:21:54.366+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "243008",
                    "issueId": "13232034"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13232034/worklog/243145",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #4283: ARROW-5275: [C++] Generic filesystem tests\nURL: https://github.com/apache/arrow/pull/4283#discussion_r284562674\n \n \n\n ##########\n File path: cpp/src/arrow/filesystem/test-util.cc\n ##########\n @@ -0,0 +1,704 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <chrono>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/filesystem/test-util.h\"\n+#include \"arrow/io/interfaces.h\"\n+#include \"arrow/testing/gtest_util.h\"\n+\n+namespace arrow {\n+namespace fs {\n+\n+namespace {\n+\n+static constexpr double kTimeSlack = 2.0;  // In seconds\n+\n+std::vector<FileStats> GetAllWithType(FileSystem* fs, FileType type) {\n+  Selector selector;\n+  selector.base_dir = \"\";\n+  selector.recursive = true;\n+  std::vector<FileStats> stats;\n+  ABORT_NOT_OK(fs->GetTargetStats(selector, &stats));\n+  std::vector<FileStats> result;\n+  for (const auto& st : stats) {\n+    if (st.type() == type) {\n+      result.push_back(st);\n+    }\n+  }\n+  return result;\n+}\n+\n+std::vector<FileStats> GetAllDirs(FileSystem* fs) {\n+  return GetAllWithType(fs, FileType::Directory);\n+}\n+\n+std::vector<FileStats> GetAllFiles(FileSystem* fs) {\n+  return GetAllWithType(fs, FileType::File);\n+}\n+\n+// Sort of vector of FileStats by lexicographic path order\n+void SortStats(std::vector<FileStats>* stats) {\n+  std::sort(stats->begin(), stats->end(),\n+            [](const FileStats& left, const FileStats& right) -> bool {\n+              return left.path() < right.path();\n+            });\n+}\n+\n+void AssertPaths(const std::vector<FileStats>& stats,\n+                 const std::vector<std::string>& expected_paths) {\n+  auto sorted_stats = stats;\n+  SortStats(&sorted_stats);\n+  std::vector<std::string> paths(stats.size());\n+  std::transform(stats.begin(), stats.end(), paths.begin(),\n+                 [&](const FileStats& st) { return st.path(); });\n+\n+  ASSERT_EQ(paths, expected_paths);\n+}\n+\n+void AssertAllDirs(FileSystem* fs, const std::vector<std::string>& expected_paths) {\n+  AssertPaths(GetAllDirs(fs), expected_paths);\n+}\n+\n+void AssertAllFiles(FileSystem* fs, const std::vector<std::string>& expected_paths) {\n+  AssertPaths(GetAllFiles(fs), expected_paths);\n+}\n+\n+Status WriteString(io::OutputStream* stream, const std::string& s) {\n+  return stream->Write(s.data(), static_cast<int64_t>(s.length()));\n+}\n+\n+void CreateFile(FileSystem* fs, const std::string& path, const std::string& data) {\n+  std::shared_ptr<io::OutputStream> stream;\n+  ASSERT_OK(fs->OpenOutputStream(path, &stream));\n+  ASSERT_OK(WriteString(stream.get(), data));\n+  ASSERT_OK(stream->Close());\n+}\n+\n+void AssertFileStats(const FileStats& st, const std::string& path, FileType type) {\n+  ASSERT_EQ(st.path(), path);\n+  ASSERT_EQ(st.type(), type);\n+}\n+\n+void AssertFileStats(const FileStats& st, const std::string& path, FileType type,\n+                     int64_t size) {\n+  AssertFileStats(st, path, type);\n+  ASSERT_EQ(st.size(), size);\n+}\n+\n+template <typename... Args>\n+void AssertFileStats(FileSystem* fs, const std::string& path, Args&&... args) {\n+  FileStats st;\n+  ASSERT_OK(fs->GetTargetStats(path, &st));\n+  AssertFileStats(st, path, std::forward<Args>(args)...);\n+}\n+\n+void AssertFileContents(FileSystem* fs, const std::string& path,\n+                        const std::string& expected_data) {\n+  FileStats st;\n+  ASSERT_OK(fs->GetTargetStats(path, &st));\n+  ASSERT_EQ(st.type(), FileType::File);\n+  ASSERT_EQ(st.size(), static_cast<int64_t>(expected_data.length()));\n+\n+  std::shared_ptr<io::InputStream> stream;\n+  std::shared_ptr<Buffer> buffer, leftover;\n+  ASSERT_OK(fs->OpenInputStream(path, &stream));\n+  ASSERT_OK(stream->Read(st.size(), &buffer));\n+  AssertBufferEqual(*buffer, expected_data);\n+  // No data left in stream\n+  ASSERT_OK(stream->Read(1, &leftover));\n+  ASSERT_EQ(leftover->size(), 0);\n+\n+  ASSERT_OK(stream->Close());\n+}\n+\n+void ValidateTimePoint(TimePoint tp) { ASSERT_GE(tp.time_since_epoch().count(), 0); }\n+\n+template <typename Duration>\n+void AssertDurationBetween(Duration d, double min_secs, double max_secs) {\n+  auto seconds = std::chrono::duration_cast<std::chrono::duration<double>>(d);\n+  ASSERT_GE(seconds.count(), min_secs);\n+  ASSERT_LE(seconds.count(), max_secs);\n+}\n+\n+};  // namespace\n+\n+////////////////////////////////////////////////////////////////////////////\n+// GenericFileSystemTest implementation\n+\n+// XXX is there a way we can test mtimes reliably and precisely?\n+\n+GenericFileSystemTest::~GenericFileSystemTest() {}\n+\n+void GenericFileSystemTest::TestEmpty(FileSystem* fs) {\n+  auto dirs = GetAllDirs(fs);\n+  ASSERT_EQ(dirs.size(), 0);\n+  auto files = GetAllFiles(fs);\n+  ASSERT_EQ(files.size(), 0);\n+}\n+\n+void GenericFileSystemTest::TestCreateDir(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB\"));\n+  ASSERT_OK(fs->CreateDir(\"AB/CD/EF\"));  // Recursive\n+  // Non-recursive, parent doesn't exist\n+  ASSERT_RAISES(IOError, fs->CreateDir(\"AB/GH/IJ\", false /* recursive */));\n+  ASSERT_OK(fs->CreateDir(\"AB/GH\", false /* recursive */));\n+  ASSERT_OK(fs->CreateDir(\"AB/GH/IJ\", false /* recursive */));\n+  // Idempotency\n+  ASSERT_OK(fs->CreateDir(\"AB/GH/IJ\", false /* recursive */));\n+  ASSERT_OK(fs->CreateDir(\"XY\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/CD\", \"AB/CD/EF\", \"AB/GH\", \"AB/GH/IJ\", \"XY\"});\n+  AssertAllFiles(fs, {});\n+\n+  // Cannot create a directory as child of a file\n+  CreateFile(fs, \"AB/def\", \"\");\n+  ASSERT_RAISES(IOError, fs->CreateDir(\"AB/def/EF/GH\", true /* recursive */));\n+  ASSERT_RAISES(IOError, fs->CreateDir(\"AB/def/EF\", false /* recursive */));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/CD\", \"AB/CD/EF\", \"AB/GH\", \"AB/GH/IJ\", \"XY\"});\n+  AssertAllFiles(fs, {\"AB/def\"});\n+}\n+\n+void GenericFileSystemTest::TestDeleteDir(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD/EF\"));\n+  ASSERT_OK(fs->CreateDir(\"AB/GH/IJ\"));\n+  CreateFile(fs, \"AB/abc\", \"\");\n+  CreateFile(fs, \"AB/CD/def\", \"\");\n+  CreateFile(fs, \"AB/CD/EF/ghi\", \"\");\n+  ASSERT_OK(fs->DeleteDir(\"AB/CD\"));\n+  ASSERT_OK(fs->DeleteDir(\"AB/GH/IJ\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/GH\"});\n+  AssertAllFiles(fs, {\"AB/abc\"});\n+\n+  // File doesn't exist\n+  ASSERT_RAISES(IOError, fs->DeleteDir(\"AB/GH/IJ\"));\n+  ASSERT_RAISES(IOError, fs->DeleteDir(\"\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/GH\"});\n+\n+  // Not a directory\n+  CreateFile(fs, \"AB/def\", \"\");\n+  ASSERT_RAISES(IOError, fs->DeleteDir(\"AB/def\"));\n+\n+  AssertAllDirs(fs, {\"AB\", \"AB/GH\"});\n+  AssertAllFiles(fs, {\"AB/abc\", \"AB/def\"});\n+}\n+\n+void GenericFileSystemTest::TestDeleteFile(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB\"));\n+  CreateFile(fs, \"AB/def\", \"\");\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/def\"});\n+\n+  ASSERT_OK(fs->DeleteFile(\"AB/def\"));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {});\n+\n+  CreateFile(fs, \"abc\", \"data\");\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"abc\"});\n+\n+  ASSERT_OK(fs->DeleteFile(\"abc\"));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {});\n+\n+  // File doesn't exist\n+  ASSERT_RAISES(IOError, fs->DeleteFile(\"abc\"));\n+  ASSERT_RAISES(IOError, fs->DeleteFile(\"AB/def\"));\n+\n+  // Not a file\n+  ASSERT_RAISES(IOError, fs->DeleteFile(\"AB\"));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {});\n+}\n+\n+void GenericFileSystemTest::TestDeleteFiles(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB\"));\n+  CreateFile(fs, \"abc\", \"\");\n+  CreateFile(fs, \"AB/def\", \"123\");\n+  CreateFile(fs, \"AB/ghi\", \"456\");\n+  CreateFile(fs, \"AB/jkl\", \"789\");\n+  CreateFile(fs, \"AB/mno\", \"789\");\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/def\", \"AB/ghi\", \"AB/jkl\", \"AB/mno\", \"abc\"});\n+\n+  // All successful\n+  ASSERT_OK(fs->DeleteFiles({\"abc\", \"AB/def\"}));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/ghi\", \"AB/jkl\", \"AB/mno\"});\n+\n+  // One error: file doesn't exist\n+  ASSERT_RAISES(IOError, fs->DeleteFiles({\"xx\", \"AB/jkl\"}));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/ghi\", \"AB/mno\"});\n+\n+  // One error: not a file\n+  ASSERT_RAISES(IOError, fs->DeleteFiles({\"AB\", \"AB/mno\"}));\n+  AssertAllDirs(fs, {\"AB\"});\n+  AssertAllFiles(fs, {\"AB/ghi\"});\n+}\n+\n+void GenericFileSystemTest::TestMoveFile(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  ASSERT_OK(fs->CreateDir(\"EF\"));\n+  CreateFile(fs, \"abc\", \"data\");\n+  std::vector<std::string> all_dirs{\"AB\", \"AB/CD\", \"EF\"};\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"abc\"});\n+\n+  // Move inside root dir\n+  FileStats st;\n+  ASSERT_OK(fs->Move(\"abc\", \"def\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"def\"});\n+  AssertFileStats(fs, \"def\", FileType::File, 4);\n+  AssertFileContents(fs, \"def\", \"data\");\n+\n+  // Move out of root dir\n+  ASSERT_OK(fs->Move(\"def\", \"AB/CD/ghi\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/CD/ghi\"});\n+  AssertFileStats(fs, \"AB/CD/ghi\", FileType::File, 4);\n+  AssertFileContents(fs, \"AB/CD/ghi\", \"data\");\n+\n+  ASSERT_OK(fs->Move(\"AB/CD/ghi\", \"EF/jkl\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"EF/jkl\"});\n+  AssertFileStats(fs, \"EF/jkl\", FileType::File, 4);\n+  AssertFileContents(fs, \"EF/jkl\", \"data\");\n+\n+  // Move back into root dir\n+  ASSERT_OK(fs->Move(\"EF/jkl\", \"mno\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"mno\"});\n+  AssertFileStats(fs, \"mno\", FileType::File, 4);\n+  AssertFileContents(fs, \"mno\", \"data\");\n+\n+  // Destination is a file => clobber\n+  CreateFile(fs, \"AB/pqr\", \"other data\");\n+  AssertAllFiles(fs, {\"AB/pqr\", \"mno\"});\n+  ASSERT_OK(fs->Move(\"mno\", \"AB/pqr\"));\n+  AssertAllFiles(fs, {\"AB/pqr\"});\n+  AssertFileStats(fs, \"AB/pqr\", FileType::File, 4);\n+  AssertFileContents(fs, \"AB/pqr\", \"data\");\n+\n+  // Identical source and destination: allowed to succeed or raise IOError,\n+  // but should not lose data.\n+  auto err = fs->Move(\"AB/pqr\", \"AB/pqr\");\n+  if (!err.ok()) {\n+    ASSERT_RAISES(IOError, err);\n+  }\n+  AssertAllFiles(fs, {\"AB/pqr\"});\n+  AssertFileStats(fs, \"AB/pqr\", FileType::File, 4);\n+  AssertFileContents(fs, \"AB/pqr\", \"data\");\n+\n+  // Source doesn't exist\n+  ASSERT_RAISES(IOError, fs->Move(\"abc\", \"def\"));\n+  // Parent destination doesn't exist\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/pqr\", \"XX/mno\"));\n+  // Parent destination is not a directory\n+  CreateFile(fs, \"xxx\", \"\");\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/pqr\", \"xxx/mno\"));\n+  // Destination is a directory\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/pqr\", \"EF\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/pqr\", \"xxx\"});\n+}\n+\n+void GenericFileSystemTest::TestMoveDir(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  ASSERT_OK(fs->CreateDir(\"EF\"));\n+  CreateFile(fs, \"AB/abc\", \"abc data\");\n+  CreateFile(fs, \"AB/CD/def\", \"def data\");\n+  CreateFile(fs, \"EF/ghi\", \"ghi data\");\n+  AssertAllDirs(fs, {\"AB\", \"AB/CD\", \"EF\"});\n+  AssertAllFiles(fs, {\"AB/CD/def\", \"AB/abc\", \"EF/ghi\"});\n+\n+  // Move inside root dir\n+  ASSERT_OK(fs->Move(\"AB\", \"GH\"));\n+  AssertAllDirs(fs, {\"EF\", \"GH\", \"GH/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"GH/CD/def\", \"GH/abc\"});\n+\n+  // Move out of root dir\n+  ASSERT_OK(fs->Move(\"GH\", \"EF/IJ\"));\n+  AssertAllDirs(fs, {\"EF\", \"EF/IJ\", \"EF/IJ/CD\"});\n+  AssertAllFiles(fs, {\"EF/IJ/CD/def\", \"EF/IJ/abc\", \"EF/ghi\"});\n+\n+  // Move back into root dir\n+  ASSERT_OK(fs->Move(\"EF/IJ\", \"KL\"));\n+  AssertAllDirs(fs, {\"EF\", \"KL\", \"KL/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"KL/CD/def\", \"KL/abc\"});\n+\n+  // Destination is a file => clobber\n+  CreateFile(fs, \"MN\", \"\");\n+  ASSERT_OK(fs->Move(\"KL\", \"MN\"));\n+  AssertAllDirs(fs, {\"EF\", \"MN\", \"MN/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"MN/CD/def\", \"MN/abc\"});\n+\n+  // Identical source and destination: allowed to succeed or raise IOError,\n+  // but should not lose data.\n+  Status st = fs->Move(\"MN\", \"MN\");\n+  if (!st.ok()) {\n+    ASSERT_RAISES(IOError, st);\n+  }\n+  AssertAllDirs(fs, {\"EF\", \"MN\", \"MN/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"MN/CD/def\", \"MN/abc\"});\n+\n+  // Destination is a directory\n+  ASSERT_RAISES(IOError, fs->Move(\"MN\", \"EF\"));\n+  AssertAllDirs(fs, {\"EF\", \"MN\", \"MN/CD\"});\n+  AssertAllFiles(fs, {\"EF/ghi\", \"MN/CD/def\", \"MN/abc\"});\n+\n+  // (other errors tested in TestMoveFile)\n+\n+  // File contents didn't change\n+  AssertFileContents(fs, \"MN/abc\", \"abc data\");\n+  AssertFileContents(fs, \"MN/CD/def\", \"def data\");\n+}\n+\n+void GenericFileSystemTest::TestCopyFile(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  ASSERT_OK(fs->CreateDir(\"EF\"));\n+  CreateFile(fs, \"AB/abc\", \"data\");\n+  std::vector<std::string> all_dirs{\"AB\", \"AB/CD\", \"EF\"};\n+\n+  // Copy into root dir\n+  ASSERT_OK(fs->CopyFile(\"AB/abc\", \"def\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/abc\", \"def\"});\n+\n+  // Copy out of root dir\n+  ASSERT_OK(fs->CopyFile(\"def\", \"EF/ghi\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/abc\", \"EF/ghi\", \"def\"});\n+\n+  // Overwrite contents for one file => other data shouldn't change\n+  CreateFile(fs, \"def\", \"other data\");\n+  AssertFileContents(fs, \"AB/abc\", \"data\");\n+  AssertFileContents(fs, \"def\", \"other data\");\n+  AssertFileContents(fs, \"EF/ghi\", \"data\");\n+\n+  // Destination is a file => clobber\n+  ASSERT_OK(fs->CopyFile(\"def\", \"AB/abc\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/abc\", \"EF/ghi\", \"def\"});\n+  AssertFileContents(fs, \"AB/abc\", \"other data\");\n+  AssertFileContents(fs, \"def\", \"other data\");\n+  AssertFileContents(fs, \"EF/ghi\", \"data\");\n+\n+  // Identical source and destination: allowed to succeed or raise IOError,\n+  // but should not lose data.\n+  Status st = fs->CopyFile(\"def\", \"def\");\n+  if (!st.ok()) {\n+    ASSERT_RAISES(IOError, st);\n+  }\n+  AssertAllFiles(fs, {\"AB/abc\", \"EF/ghi\", \"def\"});\n+  AssertFileContents(fs, \"def\", \"other data\");\n+\n+  // Destination is a directory\n+  ASSERT_RAISES(IOError, fs->CopyFile(\"def\", \"AB\"));\n+  // Source doesn't exist\n+  ASSERT_RAISES(IOError, fs->CopyFile(\"abc\", \"xxx\"));\n+  // Parent destination doesn't exist\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/abc\", \"XX/mno\"));\n+  // Parent destination is not a directory\n+  ASSERT_RAISES(IOError, fs->Move(\"AB/abc\", \"def/mno\"));\n+  AssertAllDirs(fs, all_dirs);\n+  AssertAllFiles(fs, {\"AB/abc\", \"EF/ghi\", \"def\"});\n+}\n+\n+void GenericFileSystemTest::TestGetTargetStatsSingle(FileSystem* fs) {\n+  ASSERT_OK(fs->CreateDir(\"AB/CD\"));\n+  CreateFile(fs, \"AB/CD/ghi\", \"some data\");\n+\n+  FileStats st;\n+  TimePoint first_time;\n+  ASSERT_OK(fs->GetTargetStats(\"AB\", &st));\n+  AssertFileStats(st, \"AB\", FileType::Directory);\n+  ASSERT_EQ(st.base_name(), \"AB\");\n+  ASSERT_EQ(st.size(), kNoSize);\n+  first_time = st.mtime();\n+  ValidateTimePoint(first_time);\n+\n+  ASSERT_OK(fs->GetTargetStats(\"AB/CD\", &st));\n+  AssertFileStats(st, \"AB/CD\", FileType::Directory);\n+  ASSERT_EQ(st.base_name(), \"CD\");\n+  ASSERT_EQ(st.size(), kNoSize);\n+  // AB/CD was created a little after AB\n+  AssertDurationBetween(st.mtime() - first_time, 0.0, kTimeSlack);\n+\n+  ASSERT_OK(fs->GetTargetStats(\"AB/CD/ghi\", &st));\n+  AssertFileStats(st, \"AB/CD/ghi\", FileType::File, 9);\n+  ASSERT_EQ(st.base_name(), \"ghi\");\n+  AssertDurationBetween(st.mtime() - first_time, 0.0, kTimeSlack);\n+\n+  ASSERT_OK(fs->GetTargetStats(\"zz\", &st));\n+  AssertFileStats(st, \"zz\", FileType::NonExistent);\n+  ASSERT_EQ(st.base_name(), \"zz\");\n+  ASSERT_EQ(st.size(), kNoSize);\n+  ASSERT_EQ(st.mtime(), kNoTime);\n+\n+  // Invalid path\n+  // XXX will this really be rejected by all filesystems?\n \n Review comment:\n   Right, we may need a translation layer between Windows paths and URI-like paths.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2019-05-16T07:00:39.153+0000",
                    "updated": "2019-05-16T07:00:39.153+0000",
                    "started": "2019-05-16T07:00:39.152+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "243145",
                    "issueId": "13232034"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/3",
            "id": "3",
            "description": "A task that needs to be done.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21148&avatarType=issuetype",
            "name": "Task",
            "subtask": false,
            "avatarId": 21148
        },
        "timespent": 4800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@3097e63a[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@10690961[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@56a030cc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@eda1978[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2c5f06bd[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@389d66f4[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6fec077b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@3123d227[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@659d5050[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@366420d1[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@393c3eb9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@16a16153[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 4800,
        "customfield_12312520": null,
        "customfield_12312521": "Thu May 16 00:21:33 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-05-16T00:21:33.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-5275/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2019-05-07T14:40:07.000+0000",
        "updated": "2019-05-16T07:00:39.000+0000",
        "timeoriginalestimate": null,
        "description": "We need a suite of implementation-agnostic tests for filesystem implementations, to make it easy to validate each implementation against the expected semantics.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 4800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Write generic filesystem tests",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13232034/comment/16840879",
                    "id": "16840879",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 4283\n[https://github.com/apache/arrow/pull/4283]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-05-16T00:21:33.668+0000",
                    "updated": "2019-05-16T00:21:33.668+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z02gvc:",
        "customfield_12314139": null
    }
}