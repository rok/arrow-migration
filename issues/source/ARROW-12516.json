{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13374515",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515",
    "key": "ARROW-12516",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12351051",
                "id": "12351051",
                "description": "",
                "name": "8.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-05-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/5",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/trivial.svg",
            "name": "Trivial",
            "id": "5"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=anthonylouis",
            "name": "anthonylouis",
            "key": "anthonylouis",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=anthonylouis&avatarId=46146",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=anthonylouis&avatarId=46146",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=anthonylouis&avatarId=46146",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=anthonylouis&avatarId=46146"
            },
            "displayName": "Anthony Louis Gotlib Ferreira",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334626",
                "id": "12334626",
                "name": "C++ - Gandiva"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=anthonylouis",
            "name": "anthonylouis",
            "key": "anthonylouis",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=anthonylouis&avatarId=46146",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=anthonylouis&avatarId=46146",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=anthonylouis&avatarId=46146",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=anthonylouis&avatarId=46146"
            },
            "displayName": "Anthony Louis Gotlib Ferreira",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=anthonylouis",
            "name": "anthonylouis",
            "key": "anthonylouis",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=anthonylouis&avatarId=46146",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=anthonylouis&avatarId=46146",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=anthonylouis&avatarId=46146",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=anthonylouis&avatarId=46146"
            },
            "displayName": "Anthony Louis Gotlib Ferreira",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 22800,
            "total": 22800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 22800,
            "total": 22800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12516/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 38,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/587560",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb opened a new pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-22T23:20:47.255+0000",
                    "updated": "2021-04-22T23:20:47.255+0000",
                    "started": "2021-04-22T23:20:47.254+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "587560",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/587561",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#issuecomment-825263443\n\n\n   https://issues.apache.org/jira/browse/ARROW-12516\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-04-22T23:21:10.920+0000",
                    "updated": "2021-04-22T23:21:10.920+0000",
                    "started": "2021-04-22T23:21:10.919+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "587561",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/593599",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#issuecomment-834902982\n\n\n   @projjal I want to move the logic to convert the period to interval_day to the **arrow/util/value_parsing.h** header. But I checked that the files inside the **arrow/util** folder do not use external dependencies, so I did not found any place in CmakeLists.txt to add the external libraries and some methods depend on the RE2 library to work.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-08T00:35:15.345+0000",
                    "updated": "2021-05-08T00:35:15.345+0000",
                    "started": "2021-05-08T00:35:15.345+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "593599",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/601459",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#issuecomment-847423271\n\n\n   @projjal [This thread in the date.h library](https://github.com/HowardHinnant/date/issues/666) updated. The values for interval still need to be parsed using `regex`, because it is not implemented by the library.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-05-24T23:39:38.664+0000",
                    "updated": "2021-05-24T23:39:38.664+0000",
                    "started": "2021-05-24T23:39:38.664+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "601459",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/613996",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#issuecomment-866787620\n\n\n   @jpedroantunes could you review the PR, please?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-06-23T12:20:27.412+0000",
                    "updated": "2021-06-23T12:20:27.412+0000",
                    "started": "2021-06-23T12:20:27.412+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "613996",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/684314",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rkavanap commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r753751946\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -794,6 +795,53 @@ const char* gdv_fn_initcap_utf8(int64_t context, const char* data, int32_t data_\n   *out_len = out_idx;\n   return out;\n }\n+\n+int64_t gdv_fn_cast_intervalday_utf8(int64_t context_ptr, int64_t holder_ptr,\n+                                     const char* data, int data_len, bool in1_validity,\n+                                     bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalDaysHolder* holder =\n+      reinterpret_cast<gandiva::IntervalDaysHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n+  return (*holder)(context, data_as_string, in1_validity, out_valid);\n+}\n+\n+int64_t gdv_fn_cast_intervalday_utf8_int32(int64_t context_ptr, int64_t holder_ptr,\n+                                           const char* data, int data_len,\n+                                           bool in1_validity, int32_t /*suppress_errors*/,\n+                                           bool /*in3_validity*/, bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalDaysHolder* holder =\n+      reinterpret_cast<gandiva::IntervalDaysHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n+  return (*holder)(context, data_as_string, in1_validity, out_valid);\n+}\n+\n+int32_t gdv_fn_cast_intervalyear_utf8(int64_t context_ptr, int64_t holder_ptr,\n+                                      const char* data, int data_len, bool in1_validity,\n+                                      bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalYearsHolder* holder =\n+      reinterpret_cast<gandiva::IntervalYearsHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n\nReview comment:\n       Isn't this expensive as std::string does an allocate and a deep copy and then a free? not sure if it easy to change the interface to take something other than a string, though \n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n+                                 qty_minutes * 60000 +  // millis in a minute\n+                                 qty_seconds * 1000;\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t total_days = qty_days + (millis_in_the_period / days_to_standard_millis);\n+  int64_t module_millis = millis_in_the_period % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (total_days & 0x00000000FFFFFFFF);\n+  out |= ((module_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+// The operator will cast a generic string defined by the user into an interval of days.\n+// There are two formats of strings that are acceptable:\n+//   - The period in millis: '238398430'\n+//   - The period using a ISO8601 compatible format: 'P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W'\n+int64_t IntervalDaysHolder::operator()(ExecutionContext* ctx, const std::string& data,\n+                                       bool in_valid, bool* out_valid) {\n+  *out_valid = false;\n+\n+  if (!in_valid) {\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, period_only_contains_numbers)) {\n+    return GetIntervalDayFromMillis(data, out_valid);\n+  }\n+\n+  std::string period_in_weeks;\n+  if (RE2::FullMatch(data, iso8601_period_with_weeks, &period_in_weeks)) {\n+    return GetIntervalDayFromWeeks(period_in_weeks, out_valid);\n+  }\n+\n+  std::string days_in_period;\n+  std::string hours_in_period;\n+  std::string minutes_in_period;\n+  std::string seconds_in_period;\n+  std::string ignored_string;  // string to store unnecessary captured groups\n+  if (std::regex_match(data, period_not_contains_time)) {\n+    if (RE2::FullMatch(data, iso8601_period_without_time, &ignored_string,\n+                       &ignored_string, &days_in_period)) {\n+      return GetIntervalDayFromCompletePeriod(days_in_period, hours_in_period,\n+                                              minutes_in_period, seconds_in_period,\n+                                              out_valid);\n+    }\n+\n+    return_error(ctx, data);\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, iso8601_complete_period, &ignored_string, &ignored_string,\n+                     &days_in_period, &hours_in_period, &minutes_in_period,\n+                     &seconds_in_period)) {\n+    return GetIntervalDayFromCompletePeriod(\n+        days_in_period, hours_in_period, minutes_in_period, seconds_in_period, out_valid);\n+  }\n+\n+  return_error(ctx, data);\n+  return 0;\n+}\n+\n+Status IntervalDaysHolder::Make(const FunctionNode& node,\n+                                std::shared_ptr<IntervalDaysHolder>* holder) {\n+  const std::string function_name(\"castINTERVALDAY\");\n+  return IntervalHolder<IntervalDaysHolder>::Make(node, holder, function_name);\n+}\n+\n+Status IntervalDaysHolder::Make(int32_t suppress_errors,\n+                                std::shared_ptr<IntervalDaysHolder>* holder) {\n+  return IntervalHolder<IntervalDaysHolder>::Make(suppress_errors, holder);\n+}\n+\n+Status IntervalYearsHolder::Make(const FunctionNode& node,\n+                                 std::shared_ptr<IntervalYearsHolder>* holder) {\n+  const std::string function_name(\"castINTERVALYEAR\");\n+  return IntervalHolder<IntervalYearsHolder>::Make(node, holder, function_name);\n+}\n+\n+Status IntervalYearsHolder::Make(int32_t suppress_errors,\n+                                 std::shared_ptr<IntervalYearsHolder>* holder) {\n+  return IntervalHolder<IntervalYearsHolder>::Make(suppress_errors, holder);\n+}\n+\n+// The operator will cast a generic string defined by the user into an interval of months.\n+// There are two formats of strings that are acceptable:\n+//   - The period in millis: '238398430'\n+//   - The period using a ISO8601 compatible format: 'P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W'\n+int32_t IntervalYearsHolder::operator()(ExecutionContext* ctx, const std::string& data,\n+                                        bool in_valid, bool* out_valid) {\n+  *out_valid = false;\n+\n+  if (!in_valid) {\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, period_only_contains_numbers)) {\n+    return GetIntervalYearFromNumber(data, out_valid);\n+  }\n+\n+  std::string period_in_weeks;\n+  if (RE2::FullMatch(data, iso8601_period_with_weeks, &period_in_weeks)) {\n+    *out_valid = true;\n\nReview comment:\n       did not understand this branch.  If we specify period in weeks (say > 52 weeks) won't it correspond to several months? or is this illegal..if it is illegal. shouln't we be returning an error?\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n\nReview comment:\n       same as above\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n\nReview comment:\n       can this number be defined in a common place as MILLIS_IN_A_DAY either as a static const or a #define?\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -794,6 +795,53 @@ const char* gdv_fn_initcap_utf8(int64_t context, const char* data, int32_t data_\n   *out_len = out_idx;\n   return out;\n }\n+\n+int64_t gdv_fn_cast_intervalday_utf8(int64_t context_ptr, int64_t holder_ptr,\n+                                     const char* data, int data_len, bool in1_validity,\n+                                     bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalDaysHolder* holder =\n+      reinterpret_cast<gandiva::IntervalDaysHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n+  return (*holder)(context, data_as_string, in1_validity, out_valid);\n+}\n+\n+int64_t gdv_fn_cast_intervalday_utf8_int32(int64_t context_ptr, int64_t holder_ptr,\n+                                           const char* data, int data_len,\n+                                           bool in1_validity, int32_t /*suppress_errors*/,\n+                                           bool /*in3_validity*/, bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalDaysHolder* holder =\n+      reinterpret_cast<gandiva::IntervalDaysHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n\nReview comment:\n       can data_len be zero or less? if so, what happens to std::string construction?\n\n##########\nFile path: cpp/src/gandiva/interval_holder_test.cc\n##########\n@@ -0,0 +1,423 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"gandiva/execution_context.h\"\n+\n+namespace gandiva {\n+\n+class TestIntervalHolder : public ::testing::Test {\n+ protected:\n+  ExecutionContext execution_context_;\n+};\n+\n+TEST_F(TestIntervalHolder, TestMatchAllPeriods) {\n+  std::shared_ptr<IntervalDaysHolder> interval_days_holder;\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_days_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_days_holder;\n+  auto& cast_interval_year = *interval_years_holder;\n+\n+  // Pass only numbers to cast\n+  bool out_valid;\n+  std::string data(\"73834992\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n\nReview comment:\n       why can't we exactly assert for the expected days and millis, by splitting the response to two 32 bits?\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n\nReview comment:\n       feel it is more readable if a pre-processor macro or a static const is used, e,g MILLIS_IN_AN_HOUR and so on..\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n\nReview comment:\n       this is not millis_in_a_week, isn't it total_millis_in_all_weeks?\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n+                                 qty_minutes * 60000 +  // millis in a minute\n+                                 qty_seconds * 1000;\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t total_days = qty_days + (millis_in_the_period / days_to_standard_millis);\n+  int64_t module_millis = millis_in_the_period % days_to_standard_millis;\n\nReview comment:\n       did you mean modulo_millis?. module_millis is a confusing name. maybe remainder_millis or something like that?\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n\nReview comment:\n       Can't millis in a week be pre-computed in the pre-processor stage,  either as a static const, e.g kMillisInAWeek = kMillisInADay * 7 or as a macro?\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n\nReview comment:\n       here a static cast on stod is used for qty_days, but an stol is used for qty_days in a previous method. any reason for this?\n\n##########\nFile path: cpp/src/gandiva/interval_holder_test.cc\n##########\n@@ -0,0 +1,423 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"gandiva/execution_context.h\"\n+\n+namespace gandiva {\n+\n+class TestIntervalHolder : public ::testing::Test {\n+ protected:\n+  ExecutionContext execution_context_;\n+};\n+\n+TEST_F(TestIntervalHolder, TestMatchAllPeriods) {\n+  std::shared_ptr<IntervalDaysHolder> interval_days_holder;\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_days_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_days_holder;\n+  auto& cast_interval_year = *interval_years_holder;\n+\n+  // Pass only numbers to cast\n+  bool out_valid;\n+  std::string data(\"73834992\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  int32_t response_interval_yrs =\n+      cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only years and days to cast\n+  data = \"P12Y15D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n\nReview comment:\n       please assert for exact expected value. similar comment for all EXPECT_GT below..\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n+                                 qty_minutes * 60000 +  // millis in a minute\n+                                 qty_seconds * 1000;\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t total_days = qty_days + (millis_in_the_period / days_to_standard_millis);\n+  int64_t module_millis = millis_in_the_period % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (total_days & 0x00000000FFFFFFFF);\n+  out |= ((module_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+// The operator will cast a generic string defined by the user into an interval of days.\n+// There are two formats of strings that are acceptable:\n+//   - The period in millis: '238398430'\n+//   - The period using a ISO8601 compatible format: 'P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W'\n+int64_t IntervalDaysHolder::operator()(ExecutionContext* ctx, const std::string& data,\n+                                       bool in_valid, bool* out_valid) {\n+  *out_valid = false;\n+\n+  if (!in_valid) {\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, period_only_contains_numbers)) {\n+    return GetIntervalDayFromMillis(data, out_valid);\n+  }\n+\n+  std::string period_in_weeks;\n+  if (RE2::FullMatch(data, iso8601_period_with_weeks, &period_in_weeks)) {\n+    return GetIntervalDayFromWeeks(period_in_weeks, out_valid);\n+  }\n+\n+  std::string days_in_period;\n+  std::string hours_in_period;\n+  std::string minutes_in_period;\n+  std::string seconds_in_period;\n+  std::string ignored_string;  // string to store unnecessary captured groups\n+  if (std::regex_match(data, period_not_contains_time)) {\n+    if (RE2::FullMatch(data, iso8601_period_without_time, &ignored_string,\n+                       &ignored_string, &days_in_period)) {\n+      return GetIntervalDayFromCompletePeriod(days_in_period, hours_in_period,\n+                                              minutes_in_period, seconds_in_period,\n+                                              out_valid);\n+    }\n+\n+    return_error(ctx, data);\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, iso8601_complete_period, &ignored_string, &ignored_string,\n+                     &days_in_period, &hours_in_period, &minutes_in_period,\n+                     &seconds_in_period)) {\n+    return GetIntervalDayFromCompletePeriod(\n+        days_in_period, hours_in_period, minutes_in_period, seconds_in_period, out_valid);\n+  }\n+\n+  return_error(ctx, data);\n+  return 0;\n+}\n+\n+Status IntervalDaysHolder::Make(const FunctionNode& node,\n+                                std::shared_ptr<IntervalDaysHolder>* holder) {\n+  const std::string function_name(\"castINTERVALDAY\");\n+  return IntervalHolder<IntervalDaysHolder>::Make(node, holder, function_name);\n+}\n+\n+Status IntervalDaysHolder::Make(int32_t suppress_errors,\n+                                std::shared_ptr<IntervalDaysHolder>* holder) {\n+  return IntervalHolder<IntervalDaysHolder>::Make(suppress_errors, holder);\n+}\n+\n+Status IntervalYearsHolder::Make(const FunctionNode& node,\n+                                 std::shared_ptr<IntervalYearsHolder>* holder) {\n+  const std::string function_name(\"castINTERVALYEAR\");\n+  return IntervalHolder<IntervalYearsHolder>::Make(node, holder, function_name);\n+}\n+\n+Status IntervalYearsHolder::Make(int32_t suppress_errors,\n+                                 std::shared_ptr<IntervalYearsHolder>* holder) {\n+  return IntervalHolder<IntervalYearsHolder>::Make(suppress_errors, holder);\n+}\n+\n+// The operator will cast a generic string defined by the user into an interval of months.\n+// There are two formats of strings that are acceptable:\n+//   - The period in millis: '238398430'\n+//   - The period using a ISO8601 compatible format: 'P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W'\n+int32_t IntervalYearsHolder::operator()(ExecutionContext* ctx, const std::string& data,\n+                                        bool in_valid, bool* out_valid) {\n+  *out_valid = false;\n+\n+  if (!in_valid) {\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, period_only_contains_numbers)) {\n+    return GetIntervalYearFromNumber(data, out_valid);\n\nReview comment:\n       the comment above says this is a period in millis that is converted to months..but GetIntervalYearFromNumber is reading it directly as number of months. either you have to fix the comments or the code, no?\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n\nReview comment:\n       any reason why stod is used here, whereas stol is used in the previous. Is it because weeks can be specified in partial weeks (e.g 2.5). If that is the case, will doing just a static_cast loose some information?\n\n##########\nFile path: cpp/src/gandiva/interval_holder_test.cc\n##########\n@@ -0,0 +1,423 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"gandiva/execution_context.h\"\n+\n+namespace gandiva {\n+\n+class TestIntervalHolder : public ::testing::Test {\n+ protected:\n+  ExecutionContext execution_context_;\n+};\n+\n+TEST_F(TestIntervalHolder, TestMatchAllPeriods) {\n+  std::shared_ptr<IntervalDaysHolder> interval_days_holder;\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_days_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_days_holder;\n+  auto& cast_interval_year = *interval_years_holder;\n+\n+  // Pass only numbers to cast\n+  bool out_valid;\n+  std::string data(\"73834992\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  int32_t response_interval_yrs =\n+      cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n\nReview comment:\n       I think we should assert for exact expected value\n\n##########\nFile path: cpp/src/gandiva/interval_holder_test.cc\n##########\n@@ -0,0 +1,423 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"gandiva/execution_context.h\"\n+\n+namespace gandiva {\n+\n+class TestIntervalHolder : public ::testing::Test {\n+ protected:\n+  ExecutionContext execution_context_;\n+};\n+\n+TEST_F(TestIntervalHolder, TestMatchAllPeriods) {\n+  std::shared_ptr<IntervalDaysHolder> interval_days_holder;\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_days_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_days_holder;\n+  auto& cast_interval_year = *interval_years_holder;\n+\n+  // Pass only numbers to cast\n+  bool out_valid;\n+  std::string data(\"73834992\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  int32_t response_interval_yrs =\n+      cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only years and days to cast\n+  data = \"P12Y15D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass years and days and months to cast\n+  data = \"P12Y2M15D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass days and months to cast\n+  data = \"P5M13D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass all possible fields cast\n+  data = \"P2Y5M13DT10H42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only time fields cast\n+  data = \"PT10H42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GE(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only time fields to cast without hours\n+  data = \"PT42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GE(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only weeks to cast\n+  data = \"P25W\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GE(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+}\n+\n+TEST_F(TestIntervalHolder, TestMatchErrorsForCastIntervalDay) {\n+  std::shared_ptr<IntervalDaysHolder> interval_days_holder;\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_days_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_days_holder;\n+  auto& cast_interval_year = *interval_years_holder;\n+\n+  // Pass an empty string\n+  bool out_valid;\n+  std::string data(\" \");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  int32_t response_interval_yrs =\n+      cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  // Pass only days before years\n+  data = \"P15D12Y\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  // Pass years and days and months in wrong order\n+  data = \"P12M15D2Y\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  // Forget the P in the first position\n+  data = \"5M13D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  // Use m instead M in the period format\n+  data = \"P2Y5M13DT10H42m21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  // Does not pass the T when defining only time fields\n+  data = \"P10H42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  // Pass weeks with other variables\n+  data = \"P2Y25W2M3D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+}\n+\n+TEST_F(TestIntervalHolder, TestUsingWeekFormatterForCastIntervalDay) {\n+  std::shared_ptr<IntervalDaysHolder> interval_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_holder;\n+\n+  bool out_valid;\n+  std::string data(\"P1W\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, 7);\n+\n+  data = \"P10W\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, 70);\n+\n+  execution_context_.Reset();\n+}\n+\n+TEST_F(TestIntervalHolder, TestUsingCompleteFormatterForCastIntervalDay) {\n+  std::shared_ptr<IntervalDaysHolder> interval_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_holder;\n+\n+  bool out_valid;\n+  std::string data(\"1742461111\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  int64_t qty_days_in_response = 20;\n+  int64_t qty_millis_in_response = 14461111;\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, (qty_millis_in_response << 32) | qty_days_in_response);\n+\n+  data = \"P1Y1M1DT1H1M1S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  qty_days_in_response = 1;\n+  qty_millis_in_response = 3661000;\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, (qty_millis_in_response << 32) | qty_days_in_response);\n+\n+  data = \"PT48H1M1S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  qty_days_in_response = 2;\n+  qty_millis_in_response = 61000;\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, (qty_millis_in_response << 32) | qty_days_in_response);\n+\n+  data = \"PT1S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  qty_days_in_response = 0;\n+  qty_millis_in_response = 1000;\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, (qty_millis_in_response << 32) | qty_days_in_response);\n+\n+  data = \"P10DT1S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  qty_days_in_response = 10;\n+  qty_millis_in_response = 1000;\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, (qty_millis_in_response << 32) | qty_days_in_response);\n+\n+  execution_context_.Reset();\n+\n+  data = \"P0DT0S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  qty_days_in_response = 0;\n+  qty_millis_in_response = 0;\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, (qty_millis_in_response << 32) | qty_days_in_response);\n+\n+  execution_context_.Reset();\n+}\n+\n+TEST_F(TestIntervalHolder, TestUsingCompleteFormatterForCastIntervalYear) {\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_years = *interval_years_holder;\n+\n+  bool out_valid;\n+  std::string data(\"65851111\");\n\nReview comment:\n       this looks a bit strange and confusing. If we are expecting input in months (and not millis), the comments in the operator above should be corrected. Also, if we expect months, something smaller like 623 months etc might be better as this looks like a large value for months.\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n+                                 qty_minutes * 60000 +  // millis in a minute\n+                                 qty_seconds * 1000;\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n\nReview comment:\n       millis in a day seems to be occuring more than once, so surely a pre-processor or a static const might be better\n\n##########\nFile path: cpp/src/gandiva/interval_holder_test.cc\n##########\n@@ -0,0 +1,423 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"gandiva/execution_context.h\"\n+\n+namespace gandiva {\n+\n+class TestIntervalHolder : public ::testing::Test {\n+ protected:\n+  ExecutionContext execution_context_;\n+};\n+\n+TEST_F(TestIntervalHolder, TestMatchAllPeriods) {\n+  std::shared_ptr<IntervalDaysHolder> interval_days_holder;\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_days_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_days_holder;\n+  auto& cast_interval_year = *interval_years_holder;\n+\n+  // Pass only numbers to cast\n+  bool out_valid;\n+  std::string data(\"73834992\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  int32_t response_interval_yrs =\n+      cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only years and days to cast\n+  data = \"P12Y15D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass years and days and months to cast\n+  data = \"P12Y2M15D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass days and months to cast\n+  data = \"P5M13D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass all possible fields cast\n+  data = \"P2Y5M13DT10H42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only time fields cast\n+  data = \"PT10H42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GE(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only time fields to cast without hours\n+  data = \"PT42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GE(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only weeks to cast\n+  data = \"P25W\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GE(response_interval_yrs, 0);\n\nReview comment:\n       can this really be zero, for me 25 weeks is around 5 months.? if this is an error or if one is not expected to do castIntervalYear on a week format, what is expected?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-21T14:23:41.274+0000",
                    "updated": "2021-11-21T14:23:41.274+0000",
                    "started": "2021-11-21T14:23:41.274+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "684314",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/684454",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rkavanap commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r753751946\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -794,6 +795,53 @@ const char* gdv_fn_initcap_utf8(int64_t context, const char* data, int32_t data_\n   *out_len = out_idx;\n   return out;\n }\n+\n+int64_t gdv_fn_cast_intervalday_utf8(int64_t context_ptr, int64_t holder_ptr,\n+                                     const char* data, int data_len, bool in1_validity,\n+                                     bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalDaysHolder* holder =\n+      reinterpret_cast<gandiva::IntervalDaysHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n+  return (*holder)(context, data_as_string, in1_validity, out_valid);\n+}\n+\n+int64_t gdv_fn_cast_intervalday_utf8_int32(int64_t context_ptr, int64_t holder_ptr,\n+                                           const char* data, int data_len,\n+                                           bool in1_validity, int32_t /*suppress_errors*/,\n+                                           bool /*in3_validity*/, bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalDaysHolder* holder =\n+      reinterpret_cast<gandiva::IntervalDaysHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n+  return (*holder)(context, data_as_string, in1_validity, out_valid);\n+}\n+\n+int32_t gdv_fn_cast_intervalyear_utf8(int64_t context_ptr, int64_t holder_ptr,\n+                                      const char* data, int data_len, bool in1_validity,\n+                                      bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalYearsHolder* holder =\n+      reinterpret_cast<gandiva::IntervalYearsHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n\nReview comment:\n       Isn't this expensive as std::string does an allocate and a deep copy and then a free? not sure if it easy to change the interface to take something other than a string, though \n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n+                                 qty_minutes * 60000 +  // millis in a minute\n+                                 qty_seconds * 1000;\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t total_days = qty_days + (millis_in_the_period / days_to_standard_millis);\n+  int64_t module_millis = millis_in_the_period % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (total_days & 0x00000000FFFFFFFF);\n+  out |= ((module_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+// The operator will cast a generic string defined by the user into an interval of days.\n+// There are two formats of strings that are acceptable:\n+//   - The period in millis: '238398430'\n+//   - The period using a ISO8601 compatible format: 'P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W'\n+int64_t IntervalDaysHolder::operator()(ExecutionContext* ctx, const std::string& data,\n+                                       bool in_valid, bool* out_valid) {\n+  *out_valid = false;\n+\n+  if (!in_valid) {\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, period_only_contains_numbers)) {\n+    return GetIntervalDayFromMillis(data, out_valid);\n+  }\n+\n+  std::string period_in_weeks;\n+  if (RE2::FullMatch(data, iso8601_period_with_weeks, &period_in_weeks)) {\n+    return GetIntervalDayFromWeeks(period_in_weeks, out_valid);\n+  }\n+\n+  std::string days_in_period;\n+  std::string hours_in_period;\n+  std::string minutes_in_period;\n+  std::string seconds_in_period;\n+  std::string ignored_string;  // string to store unnecessary captured groups\n+  if (std::regex_match(data, period_not_contains_time)) {\n+    if (RE2::FullMatch(data, iso8601_period_without_time, &ignored_string,\n+                       &ignored_string, &days_in_period)) {\n+      return GetIntervalDayFromCompletePeriod(days_in_period, hours_in_period,\n+                                              minutes_in_period, seconds_in_period,\n+                                              out_valid);\n+    }\n+\n+    return_error(ctx, data);\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, iso8601_complete_period, &ignored_string, &ignored_string,\n+                     &days_in_period, &hours_in_period, &minutes_in_period,\n+                     &seconds_in_period)) {\n+    return GetIntervalDayFromCompletePeriod(\n+        days_in_period, hours_in_period, minutes_in_period, seconds_in_period, out_valid);\n+  }\n+\n+  return_error(ctx, data);\n+  return 0;\n+}\n+\n+Status IntervalDaysHolder::Make(const FunctionNode& node,\n+                                std::shared_ptr<IntervalDaysHolder>* holder) {\n+  const std::string function_name(\"castINTERVALDAY\");\n+  return IntervalHolder<IntervalDaysHolder>::Make(node, holder, function_name);\n+}\n+\n+Status IntervalDaysHolder::Make(int32_t suppress_errors,\n+                                std::shared_ptr<IntervalDaysHolder>* holder) {\n+  return IntervalHolder<IntervalDaysHolder>::Make(suppress_errors, holder);\n+}\n+\n+Status IntervalYearsHolder::Make(const FunctionNode& node,\n+                                 std::shared_ptr<IntervalYearsHolder>* holder) {\n+  const std::string function_name(\"castINTERVALYEAR\");\n+  return IntervalHolder<IntervalYearsHolder>::Make(node, holder, function_name);\n+}\n+\n+Status IntervalYearsHolder::Make(int32_t suppress_errors,\n+                                 std::shared_ptr<IntervalYearsHolder>* holder) {\n+  return IntervalHolder<IntervalYearsHolder>::Make(suppress_errors, holder);\n+}\n+\n+// The operator will cast a generic string defined by the user into an interval of months.\n+// There are two formats of strings that are acceptable:\n+//   - The period in millis: '238398430'\n+//   - The period using a ISO8601 compatible format: 'P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W'\n+int32_t IntervalYearsHolder::operator()(ExecutionContext* ctx, const std::string& data,\n+                                        bool in_valid, bool* out_valid) {\n+  *out_valid = false;\n+\n+  if (!in_valid) {\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, period_only_contains_numbers)) {\n+    return GetIntervalYearFromNumber(data, out_valid);\n+  }\n+\n+  std::string period_in_weeks;\n+  if (RE2::FullMatch(data, iso8601_period_with_weeks, &period_in_weeks)) {\n+    *out_valid = true;\n\nReview comment:\n       did not understand this branch.  If we specify period in weeks (say > 52 weeks) won't it correspond to several months? or is this illegal..if it is illegal. shouln't we be returning an error?\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n\nReview comment:\n       same as above\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n\nReview comment:\n       can this number be defined in a common place as MILLIS_IN_A_DAY either as a static const or a #define?\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -794,6 +795,53 @@ const char* gdv_fn_initcap_utf8(int64_t context, const char* data, int32_t data_\n   *out_len = out_idx;\n   return out;\n }\n+\n+int64_t gdv_fn_cast_intervalday_utf8(int64_t context_ptr, int64_t holder_ptr,\n+                                     const char* data, int data_len, bool in1_validity,\n+                                     bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalDaysHolder* holder =\n+      reinterpret_cast<gandiva::IntervalDaysHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n+  return (*holder)(context, data_as_string, in1_validity, out_valid);\n+}\n+\n+int64_t gdv_fn_cast_intervalday_utf8_int32(int64_t context_ptr, int64_t holder_ptr,\n+                                           const char* data, int data_len,\n+                                           bool in1_validity, int32_t /*suppress_errors*/,\n+                                           bool /*in3_validity*/, bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalDaysHolder* holder =\n+      reinterpret_cast<gandiva::IntervalDaysHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n\nReview comment:\n       can data_len be zero or less? if so, what happens to std::string construction?\n\n##########\nFile path: cpp/src/gandiva/interval_holder_test.cc\n##########\n@@ -0,0 +1,423 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"gandiva/execution_context.h\"\n+\n+namespace gandiva {\n+\n+class TestIntervalHolder : public ::testing::Test {\n+ protected:\n+  ExecutionContext execution_context_;\n+};\n+\n+TEST_F(TestIntervalHolder, TestMatchAllPeriods) {\n+  std::shared_ptr<IntervalDaysHolder> interval_days_holder;\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_days_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_days_holder;\n+  auto& cast_interval_year = *interval_years_holder;\n+\n+  // Pass only numbers to cast\n+  bool out_valid;\n+  std::string data(\"73834992\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n\nReview comment:\n       why can't we exactly assert for the expected days and millis, by splitting the response to two 32 bits?\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n\nReview comment:\n       feel it is more readable if a pre-processor macro or a static const is used, e,g MILLIS_IN_AN_HOUR and so on..\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n\nReview comment:\n       this is not millis_in_a_week, isn't it total_millis_in_all_weeks?\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n+                                 qty_minutes * 60000 +  // millis in a minute\n+                                 qty_seconds * 1000;\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t total_days = qty_days + (millis_in_the_period / days_to_standard_millis);\n+  int64_t module_millis = millis_in_the_period % days_to_standard_millis;\n\nReview comment:\n       did you mean modulo_millis?. module_millis is a confusing name. maybe remainder_millis or something like that?\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n\nReview comment:\n       Can't millis in a week be pre-computed in the pre-processor stage,  either as a static const, e.g kMillisInAWeek = kMillisInADay * 7 or as a macro?\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n\nReview comment:\n       here a static cast on stod is used for qty_days, but an stol is used for qty_days in a previous method. any reason for this?\n\n##########\nFile path: cpp/src/gandiva/interval_holder_test.cc\n##########\n@@ -0,0 +1,423 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"gandiva/execution_context.h\"\n+\n+namespace gandiva {\n+\n+class TestIntervalHolder : public ::testing::Test {\n+ protected:\n+  ExecutionContext execution_context_;\n+};\n+\n+TEST_F(TestIntervalHolder, TestMatchAllPeriods) {\n+  std::shared_ptr<IntervalDaysHolder> interval_days_holder;\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_days_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_days_holder;\n+  auto& cast_interval_year = *interval_years_holder;\n+\n+  // Pass only numbers to cast\n+  bool out_valid;\n+  std::string data(\"73834992\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  int32_t response_interval_yrs =\n+      cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only years and days to cast\n+  data = \"P12Y15D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n\nReview comment:\n       please assert for exact expected value. similar comment for all EXPECT_GT below..\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n+                                 qty_minutes * 60000 +  // millis in a minute\n+                                 qty_seconds * 1000;\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t total_days = qty_days + (millis_in_the_period / days_to_standard_millis);\n+  int64_t module_millis = millis_in_the_period % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (total_days & 0x00000000FFFFFFFF);\n+  out |= ((module_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+// The operator will cast a generic string defined by the user into an interval of days.\n+// There are two formats of strings that are acceptable:\n+//   - The period in millis: '238398430'\n+//   - The period using a ISO8601 compatible format: 'P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W'\n+int64_t IntervalDaysHolder::operator()(ExecutionContext* ctx, const std::string& data,\n+                                       bool in_valid, bool* out_valid) {\n+  *out_valid = false;\n+\n+  if (!in_valid) {\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, period_only_contains_numbers)) {\n+    return GetIntervalDayFromMillis(data, out_valid);\n+  }\n+\n+  std::string period_in_weeks;\n+  if (RE2::FullMatch(data, iso8601_period_with_weeks, &period_in_weeks)) {\n+    return GetIntervalDayFromWeeks(period_in_weeks, out_valid);\n+  }\n+\n+  std::string days_in_period;\n+  std::string hours_in_period;\n+  std::string minutes_in_period;\n+  std::string seconds_in_period;\n+  std::string ignored_string;  // string to store unnecessary captured groups\n+  if (std::regex_match(data, period_not_contains_time)) {\n+    if (RE2::FullMatch(data, iso8601_period_without_time, &ignored_string,\n+                       &ignored_string, &days_in_period)) {\n+      return GetIntervalDayFromCompletePeriod(days_in_period, hours_in_period,\n+                                              minutes_in_period, seconds_in_period,\n+                                              out_valid);\n+    }\n+\n+    return_error(ctx, data);\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, iso8601_complete_period, &ignored_string, &ignored_string,\n+                     &days_in_period, &hours_in_period, &minutes_in_period,\n+                     &seconds_in_period)) {\n+    return GetIntervalDayFromCompletePeriod(\n+        days_in_period, hours_in_period, minutes_in_period, seconds_in_period, out_valid);\n+  }\n+\n+  return_error(ctx, data);\n+  return 0;\n+}\n+\n+Status IntervalDaysHolder::Make(const FunctionNode& node,\n+                                std::shared_ptr<IntervalDaysHolder>* holder) {\n+  const std::string function_name(\"castINTERVALDAY\");\n+  return IntervalHolder<IntervalDaysHolder>::Make(node, holder, function_name);\n+}\n+\n+Status IntervalDaysHolder::Make(int32_t suppress_errors,\n+                                std::shared_ptr<IntervalDaysHolder>* holder) {\n+  return IntervalHolder<IntervalDaysHolder>::Make(suppress_errors, holder);\n+}\n+\n+Status IntervalYearsHolder::Make(const FunctionNode& node,\n+                                 std::shared_ptr<IntervalYearsHolder>* holder) {\n+  const std::string function_name(\"castINTERVALYEAR\");\n+  return IntervalHolder<IntervalYearsHolder>::Make(node, holder, function_name);\n+}\n+\n+Status IntervalYearsHolder::Make(int32_t suppress_errors,\n+                                 std::shared_ptr<IntervalYearsHolder>* holder) {\n+  return IntervalHolder<IntervalYearsHolder>::Make(suppress_errors, holder);\n+}\n+\n+// The operator will cast a generic string defined by the user into an interval of months.\n+// There are two formats of strings that are acceptable:\n+//   - The period in millis: '238398430'\n+//   - The period using a ISO8601 compatible format: 'P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W'\n+int32_t IntervalYearsHolder::operator()(ExecutionContext* ctx, const std::string& data,\n+                                        bool in_valid, bool* out_valid) {\n+  *out_valid = false;\n+\n+  if (!in_valid) {\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, period_only_contains_numbers)) {\n+    return GetIntervalYearFromNumber(data, out_valid);\n\nReview comment:\n       the comment above says this is a period in millis that is converted to months..but GetIntervalYearFromNumber is reading it directly as number of months. either you have to fix the comments or the code, no?\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n\nReview comment:\n       any reason why stod is used here, whereas stol is used in the previous. Is it because weeks can be specified in partial weeks (e.g 2.5). If that is the case, will doing just a static_cast loose some information?\n\n##########\nFile path: cpp/src/gandiva/interval_holder_test.cc\n##########\n@@ -0,0 +1,423 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"gandiva/execution_context.h\"\n+\n+namespace gandiva {\n+\n+class TestIntervalHolder : public ::testing::Test {\n+ protected:\n+  ExecutionContext execution_context_;\n+};\n+\n+TEST_F(TestIntervalHolder, TestMatchAllPeriods) {\n+  std::shared_ptr<IntervalDaysHolder> interval_days_holder;\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_days_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_days_holder;\n+  auto& cast_interval_year = *interval_years_holder;\n+\n+  // Pass only numbers to cast\n+  bool out_valid;\n+  std::string data(\"73834992\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  int32_t response_interval_yrs =\n+      cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n\nReview comment:\n       I think we should assert for exact expected value\n\n##########\nFile path: cpp/src/gandiva/interval_holder_test.cc\n##########\n@@ -0,0 +1,423 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"gandiva/execution_context.h\"\n+\n+namespace gandiva {\n+\n+class TestIntervalHolder : public ::testing::Test {\n+ protected:\n+  ExecutionContext execution_context_;\n+};\n+\n+TEST_F(TestIntervalHolder, TestMatchAllPeriods) {\n+  std::shared_ptr<IntervalDaysHolder> interval_days_holder;\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_days_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_days_holder;\n+  auto& cast_interval_year = *interval_years_holder;\n+\n+  // Pass only numbers to cast\n+  bool out_valid;\n+  std::string data(\"73834992\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  int32_t response_interval_yrs =\n+      cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only years and days to cast\n+  data = \"P12Y15D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass years and days and months to cast\n+  data = \"P12Y2M15D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass days and months to cast\n+  data = \"P5M13D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass all possible fields cast\n+  data = \"P2Y5M13DT10H42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only time fields cast\n+  data = \"PT10H42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GE(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only time fields to cast without hours\n+  data = \"PT42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GE(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only weeks to cast\n+  data = \"P25W\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GE(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+}\n+\n+TEST_F(TestIntervalHolder, TestMatchErrorsForCastIntervalDay) {\n+  std::shared_ptr<IntervalDaysHolder> interval_days_holder;\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_days_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_days_holder;\n+  auto& cast_interval_year = *interval_years_holder;\n+\n+  // Pass an empty string\n+  bool out_valid;\n+  std::string data(\" \");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  int32_t response_interval_yrs =\n+      cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  // Pass only days before years\n+  data = \"P15D12Y\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  // Pass years and days and months in wrong order\n+  data = \"P12M15D2Y\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  // Forget the P in the first position\n+  data = \"5M13D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  // Use m instead M in the period format\n+  data = \"P2Y5M13DT10H42m21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  // Does not pass the T when defining only time fields\n+  data = \"P10H42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  // Pass weeks with other variables\n+  data = \"P2Y25W2M3D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_EQ(response_interval_yrs, 0);\n+  EXPECT_FALSE(out_valid);\n+  EXPECT_TRUE(execution_context_.has_error());\n+\n+  execution_context_.Reset();\n+}\n+\n+TEST_F(TestIntervalHolder, TestUsingWeekFormatterForCastIntervalDay) {\n+  std::shared_ptr<IntervalDaysHolder> interval_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_holder;\n+\n+  bool out_valid;\n+  std::string data(\"P1W\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, 7);\n+\n+  data = \"P10W\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, 70);\n+\n+  execution_context_.Reset();\n+}\n+\n+TEST_F(TestIntervalHolder, TestUsingCompleteFormatterForCastIntervalDay) {\n+  std::shared_ptr<IntervalDaysHolder> interval_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_holder;\n+\n+  bool out_valid;\n+  std::string data(\"1742461111\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  int64_t qty_days_in_response = 20;\n+  int64_t qty_millis_in_response = 14461111;\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, (qty_millis_in_response << 32) | qty_days_in_response);\n+\n+  data = \"P1Y1M1DT1H1M1S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  qty_days_in_response = 1;\n+  qty_millis_in_response = 3661000;\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, (qty_millis_in_response << 32) | qty_days_in_response);\n+\n+  data = \"PT48H1M1S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  qty_days_in_response = 2;\n+  qty_millis_in_response = 61000;\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, (qty_millis_in_response << 32) | qty_days_in_response);\n+\n+  data = \"PT1S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  qty_days_in_response = 0;\n+  qty_millis_in_response = 1000;\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, (qty_millis_in_response << 32) | qty_days_in_response);\n+\n+  data = \"P10DT1S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  qty_days_in_response = 10;\n+  qty_millis_in_response = 1000;\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, (qty_millis_in_response << 32) | qty_days_in_response);\n+\n+  execution_context_.Reset();\n+\n+  data = \"P0DT0S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  qty_days_in_response = 0;\n+  qty_millis_in_response = 0;\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+  EXPECT_EQ(response, (qty_millis_in_response << 32) | qty_days_in_response);\n+\n+  execution_context_.Reset();\n+}\n+\n+TEST_F(TestIntervalHolder, TestUsingCompleteFormatterForCastIntervalYear) {\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_years = *interval_years_holder;\n+\n+  bool out_valid;\n+  std::string data(\"65851111\");\n\nReview comment:\n       this looks a bit strange and confusing. If we are expecting input in months (and not millis), the comments in the operator above should be corrected. Also, if we expect months, something smaller like 623 months etc might be better as this looks like a large value for months.\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n+                                 qty_minutes * 60000 +  // millis in a minute\n+                                 qty_seconds * 1000;\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n\nReview comment:\n       millis in a day seems to be occuring more than once, so surely a pre-processor or a static const might be better\n\n##########\nFile path: cpp/src/gandiva/interval_holder_test.cc\n##########\n@@ -0,0 +1,423 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include <gtest/gtest.h>\n+\n+#include <memory>\n+#include <vector>\n+\n+#include \"gandiva/execution_context.h\"\n+\n+namespace gandiva {\n+\n+class TestIntervalHolder : public ::testing::Test {\n+ protected:\n+  ExecutionContext execution_context_;\n+};\n+\n+TEST_F(TestIntervalHolder, TestMatchAllPeriods) {\n+  std::shared_ptr<IntervalDaysHolder> interval_days_holder;\n+  std::shared_ptr<IntervalYearsHolder> interval_years_holder;\n+\n+  auto status = IntervalDaysHolder::Make(0, &interval_days_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  status = IntervalYearsHolder::Make(0, &interval_years_holder);\n+  EXPECT_EQ(status.ok(), true) << status.message();\n+\n+  auto& cast_interval_day = *interval_days_holder;\n+  auto& cast_interval_year = *interval_years_holder;\n+\n+  // Pass only numbers to cast\n+  bool out_valid;\n+  std::string data(\"73834992\");\n+  int64_t response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  int32_t response_interval_yrs =\n+      cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only years and days to cast\n+  data = \"P12Y15D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass years and days and months to cast\n+  data = \"P12Y2M15D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass days and months to cast\n+  data = \"P5M13D\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass all possible fields cast\n+  data = \"P2Y5M13DT10H42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only time fields cast\n+  data = \"PT10H42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GE(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only time fields to cast without hours\n+  data = \"PT42M21S\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GE(response_interval_yrs, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  // Pass only weeks to cast\n+  data = \"P25W\";\n+  response = cast_interval_day(&execution_context_, data, true, &out_valid);\n+  EXPECT_GT(response, 0);\n+  EXPECT_TRUE(out_valid);\n+  EXPECT_FALSE(execution_context_.has_error());\n+\n+  response_interval_yrs = cast_interval_year(&execution_context_, data, true, &out_valid);\n+  EXPECT_GE(response_interval_yrs, 0);\n\nReview comment:\n       can this really be zero, for me 25 weeks is around 5 months.? if this is an error or if one is not expected to do castIntervalYear on a week format, what is expected?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-21T19:42:42.962+0000",
                    "updated": "2021-11-21T19:42:42.962+0000",
                    "started": "2021-11-21T19:42:42.961+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "684454",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686136",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756483095\n\n\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n\nReview comment:\n       I put the value in a static const variable\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-24T23:41:18.278+0000",
                    "updated": "2021-11-24T23:41:18.278+0000",
                    "started": "2021-11-24T23:41:18.278+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686136",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686139",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756483745\n\n\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n\nReview comment:\n       I put the value in a static const variable\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-24T23:43:30.625+0000",
                    "updated": "2021-11-24T23:43:30.625+0000",
                    "started": "2021-11-24T23:43:30.624+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686139",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686140",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756483854\n\n\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n\nReview comment:\n       I put the value in a static const variable\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-24T23:43:53.599+0000",
                    "updated": "2021-11-24T23:43:53.599+0000",
                    "started": "2021-11-24T23:43:53.598+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686140",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686142",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756484071\n\n\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n\nReview comment:\n       I changed the variable name\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-24T23:44:41.221+0000",
                    "updated": "2021-11-24T23:44:41.221+0000",
                    "started": "2021-11-24T23:44:41.220+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686142",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686148",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756485328\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -794,6 +795,53 @@ const char* gdv_fn_initcap_utf8(int64_t context, const char* data, int32_t data_\n   *out_len = out_idx;\n   return out;\n }\n+\n+int64_t gdv_fn_cast_intervalday_utf8(int64_t context_ptr, int64_t holder_ptr,\n+                                     const char* data, int data_len, bool in1_validity,\n+                                     bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalDaysHolder* holder =\n+      reinterpret_cast<gandiva::IntervalDaysHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n+  return (*holder)(context, data_as_string, in1_validity, out_valid);\n+}\n+\n+int64_t gdv_fn_cast_intervalday_utf8_int32(int64_t context_ptr, int64_t holder_ptr,\n+                                           const char* data, int data_len,\n+                                           bool in1_validity, int32_t /*suppress_errors*/,\n+                                           bool /*in3_validity*/, bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalDaysHolder* holder =\n+      reinterpret_cast<gandiva::IntervalDaysHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n+  return (*holder)(context, data_as_string, in1_validity, out_valid);\n+}\n+\n+int32_t gdv_fn_cast_intervalyear_utf8(int64_t context_ptr, int64_t holder_ptr,\n+                                      const char* data, int data_len, bool in1_validity,\n+                                      bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalYearsHolder* holder =\n+      reinterpret_cast<gandiva::IntervalYearsHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n\nReview comment:\n       It is because there is a moment that I need to pass the value to the regex matcher, e.g: https://github.com/apache/arrow/blob/637c60eaa40cb6ce3a11813e5c0eee2096721f4c/cpp/src/gandiva/interval_holder.cc#L157\r\n   \r\n   And if I pass the pointer, It throws an error as the buffer contains all strings concatenated.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-24T23:49:15.729+0000",
                    "updated": "2021-11-24T23:49:15.729+0000",
                    "started": "2021-11-24T23:49:15.729+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686148",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686154",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756488410\n\n\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n\nReview comment:\n       The correct way is to use `stod` in all places because the ISO format allows the user to pass decimal numbers https://en.wikipedia.org/wiki/ISO_8601#Time_intervals.\r\n   \r\n   The reason that I cast as long is that I based on Joda Time implementation: https://www.joda.org/joda-time/apidocs/org/joda/time/Period.html that was the base of Java 8 Period API and that API returns only the integer part of the values.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-25T00:00:43.198+0000",
                    "updated": "2021-11-25T00:00:43.198+0000",
                    "started": "2021-11-25T00:00:43.198+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686154",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686155",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756488868\n\n\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n\nReview comment:\n       The answer is similar to that question: https://github.com/apache/arrow/pull/10137#discussion_r756488410\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-25T00:02:26.738+0000",
                    "updated": "2021-11-25T00:02:26.738+0000",
                    "started": "2021-11-25T00:02:26.738+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686155",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686156",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756489071\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -794,6 +795,53 @@ const char* gdv_fn_initcap_utf8(int64_t context, const char* data, int32_t data_\n   *out_len = out_idx;\n   return out;\n }\n+\n+int64_t gdv_fn_cast_intervalday_utf8(int64_t context_ptr, int64_t holder_ptr,\n+                                     const char* data, int data_len, bool in1_validity,\n+                                     bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalDaysHolder* holder =\n+      reinterpret_cast<gandiva::IntervalDaysHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n+  return (*holder)(context, data_as_string, in1_validity, out_valid);\n+}\n+\n+int64_t gdv_fn_cast_intervalday_utf8_int32(int64_t context_ptr, int64_t holder_ptr,\n+                                           const char* data, int data_len,\n+                                           bool in1_validity, int32_t /*suppress_errors*/,\n+                                           bool /*in3_validity*/, bool* out_valid) {\n+  gandiva::ExecutionContext* context =\n+      reinterpret_cast<gandiva::ExecutionContext*>(context_ptr);\n+  gandiva::IntervalDaysHolder* holder =\n+      reinterpret_cast<gandiva::IntervalDaysHolder*>(holder_ptr);\n+  std::string data_as_string(data, data_len);\n\nReview comment:\n       I add a check to return an error in that cases https://github.com/apache/arrow/blob/637c60eaa40cb6ce3a11813e5c0eee2096721f4c/cpp/src/gandiva/interval_holder.cc#L144\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-25T00:03:14.479+0000",
                    "updated": "2021-11-25T00:03:14.479+0000",
                    "started": "2021-11-25T00:03:14.478+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686156",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686158",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756489500\n\n\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n+                                 qty_minutes * 60000 +  // millis in a minute\n+                                 qty_seconds * 1000;\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n\nReview comment:\n       Done\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-25T00:05:05.701+0000",
                    "updated": "2021-11-25T00:05:05.701+0000",
                    "started": "2021-11-25T00:05:05.701+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686158",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686159",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756489852\n\n\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n+                                 qty_minutes * 60000 +  // millis in a minute\n+                                 qty_seconds * 1000;\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t total_days = qty_days + (millis_in_the_period / days_to_standard_millis);\n+  int64_t module_millis = millis_in_the_period % days_to_standard_millis;\n\nReview comment:\n       Changed the name to `remainder_millis`, thanks for the suggestion.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-25T00:06:18.493+0000",
                    "updated": "2021-11-25T00:06:18.493+0000",
                    "started": "2021-11-25T00:06:18.493+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686159",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686161",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756490792\n\n\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n+                                 qty_minutes * 60000 +  // millis in a minute\n+                                 qty_seconds * 1000;\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t total_days = qty_days + (millis_in_the_period / days_to_standard_millis);\n+  int64_t module_millis = millis_in_the_period % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (total_days & 0x00000000FFFFFFFF);\n+  out |= ((module_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+// The operator will cast a generic string defined by the user into an interval of days.\n+// There are two formats of strings that are acceptable:\n+//   - The period in millis: '238398430'\n+//   - The period using a ISO8601 compatible format: 'P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W'\n+int64_t IntervalDaysHolder::operator()(ExecutionContext* ctx, const std::string& data,\n+                                       bool in_valid, bool* out_valid) {\n+  *out_valid = false;\n+\n+  if (!in_valid) {\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, period_only_contains_numbers)) {\n+    return GetIntervalDayFromMillis(data, out_valid);\n+  }\n+\n+  std::string period_in_weeks;\n+  if (RE2::FullMatch(data, iso8601_period_with_weeks, &period_in_weeks)) {\n+    return GetIntervalDayFromWeeks(period_in_weeks, out_valid);\n+  }\n+\n+  std::string days_in_period;\n+  std::string hours_in_period;\n+  std::string minutes_in_period;\n+  std::string seconds_in_period;\n+  std::string ignored_string;  // string to store unnecessary captured groups\n+  if (std::regex_match(data, period_not_contains_time)) {\n+    if (RE2::FullMatch(data, iso8601_period_without_time, &ignored_string,\n+                       &ignored_string, &days_in_period)) {\n+      return GetIntervalDayFromCompletePeriod(days_in_period, hours_in_period,\n+                                              minutes_in_period, seconds_in_period,\n+                                              out_valid);\n+    }\n+\n+    return_error(ctx, data);\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, iso8601_complete_period, &ignored_string, &ignored_string,\n+                     &days_in_period, &hours_in_period, &minutes_in_period,\n+                     &seconds_in_period)) {\n+    return GetIntervalDayFromCompletePeriod(\n+        days_in_period, hours_in_period, minutes_in_period, seconds_in_period, out_valid);\n+  }\n+\n+  return_error(ctx, data);\n+  return 0;\n+}\n+\n+Status IntervalDaysHolder::Make(const FunctionNode& node,\n+                                std::shared_ptr<IntervalDaysHolder>* holder) {\n+  const std::string function_name(\"castINTERVALDAY\");\n+  return IntervalHolder<IntervalDaysHolder>::Make(node, holder, function_name);\n+}\n+\n+Status IntervalDaysHolder::Make(int32_t suppress_errors,\n+                                std::shared_ptr<IntervalDaysHolder>* holder) {\n+  return IntervalHolder<IntervalDaysHolder>::Make(suppress_errors, holder);\n+}\n+\n+Status IntervalYearsHolder::Make(const FunctionNode& node,\n+                                 std::shared_ptr<IntervalYearsHolder>* holder) {\n+  const std::string function_name(\"castINTERVALYEAR\");\n+  return IntervalHolder<IntervalYearsHolder>::Make(node, holder, function_name);\n+}\n+\n+Status IntervalYearsHolder::Make(int32_t suppress_errors,\n+                                 std::shared_ptr<IntervalYearsHolder>* holder) {\n+  return IntervalHolder<IntervalYearsHolder>::Make(suppress_errors, holder);\n+}\n+\n+// The operator will cast a generic string defined by the user into an interval of months.\n+// There are two formats of strings that are acceptable:\n+//   - The period in millis: '238398430'\n+//   - The period using a ISO8601 compatible format: 'P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W'\n+int32_t IntervalYearsHolder::operator()(ExecutionContext* ctx, const std::string& data,\n+                                        bool in_valid, bool* out_valid) {\n+  *out_valid = false;\n+\n+  if (!in_valid) {\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, period_only_contains_numbers)) {\n+    return GetIntervalYearFromNumber(data, out_valid);\n+  }\n+\n+  std::string period_in_weeks;\n+  if (RE2::FullMatch(data, iso8601_period_with_weeks, &period_in_weeks)) {\n+    *out_valid = true;\n\nReview comment:\n       The reason for the existence of that branch is because [in ISO](https://en.wikipedia.org/wiki/ISO_8601#Durations) the user must choose to represent a period using one of these two ways:\r\n   \r\n   - `PnYnMTnHnM`\r\n   - `PnW`\r\n   \r\n   So if the user represents using the second format, we will process the value in a different way.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-25T00:10:14.684+0000",
                    "updated": "2021-11-25T00:10:14.684+0000",
                    "started": "2021-11-25T00:10:14.684+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686161",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686162",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756491148\n\n\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n+                                 qty_minutes * 60000 +  // millis in a minute\n+                                 qty_seconds * 1000;\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t total_days = qty_days + (millis_in_the_period / days_to_standard_millis);\n+  int64_t module_millis = millis_in_the_period % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (total_days & 0x00000000FFFFFFFF);\n+  out |= ((module_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+// The operator will cast a generic string defined by the user into an interval of days.\n+// There are two formats of strings that are acceptable:\n+//   - The period in millis: '238398430'\n+//   - The period using a ISO8601 compatible format: 'P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W'\n+int64_t IntervalDaysHolder::operator()(ExecutionContext* ctx, const std::string& data,\n+                                       bool in_valid, bool* out_valid) {\n+  *out_valid = false;\n+\n+  if (!in_valid) {\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, period_only_contains_numbers)) {\n+    return GetIntervalDayFromMillis(data, out_valid);\n+  }\n+\n+  std::string period_in_weeks;\n+  if (RE2::FullMatch(data, iso8601_period_with_weeks, &period_in_weeks)) {\n+    return GetIntervalDayFromWeeks(period_in_weeks, out_valid);\n+  }\n+\n+  std::string days_in_period;\n+  std::string hours_in_period;\n+  std::string minutes_in_period;\n+  std::string seconds_in_period;\n+  std::string ignored_string;  // string to store unnecessary captured groups\n+  if (std::regex_match(data, period_not_contains_time)) {\n+    if (RE2::FullMatch(data, iso8601_period_without_time, &ignored_string,\n+                       &ignored_string, &days_in_period)) {\n+      return GetIntervalDayFromCompletePeriod(days_in_period, hours_in_period,\n+                                              minutes_in_period, seconds_in_period,\n+                                              out_valid);\n+    }\n+\n+    return_error(ctx, data);\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, iso8601_complete_period, &ignored_string, &ignored_string,\n+                     &days_in_period, &hours_in_period, &minutes_in_period,\n+                     &seconds_in_period)) {\n+    return GetIntervalDayFromCompletePeriod(\n+        days_in_period, hours_in_period, minutes_in_period, seconds_in_period, out_valid);\n+  }\n+\n+  return_error(ctx, data);\n+  return 0;\n+}\n+\n+Status IntervalDaysHolder::Make(const FunctionNode& node,\n+                                std::shared_ptr<IntervalDaysHolder>* holder) {\n+  const std::string function_name(\"castINTERVALDAY\");\n+  return IntervalHolder<IntervalDaysHolder>::Make(node, holder, function_name);\n+}\n+\n+Status IntervalDaysHolder::Make(int32_t suppress_errors,\n+                                std::shared_ptr<IntervalDaysHolder>* holder) {\n+  return IntervalHolder<IntervalDaysHolder>::Make(suppress_errors, holder);\n+}\n+\n+Status IntervalYearsHolder::Make(const FunctionNode& node,\n+                                 std::shared_ptr<IntervalYearsHolder>* holder) {\n+  const std::string function_name(\"castINTERVALYEAR\");\n+  return IntervalHolder<IntervalYearsHolder>::Make(node, holder, function_name);\n+}\n+\n+Status IntervalYearsHolder::Make(int32_t suppress_errors,\n+                                 std::shared_ptr<IntervalYearsHolder>* holder) {\n+  return IntervalHolder<IntervalYearsHolder>::Make(suppress_errors, holder);\n+}\n+\n+// The operator will cast a generic string defined by the user into an interval of months.\n+// There are two formats of strings that are acceptable:\n+//   - The period in millis: '238398430'\n+//   - The period using a ISO8601 compatible format: 'P[n]Y[n]M[n]DT[n]H[n]M[n]S or P[n]W'\n+int32_t IntervalYearsHolder::operator()(ExecutionContext* ctx, const std::string& data,\n+                                        bool in_valid, bool* out_valid) {\n+  *out_valid = false;\n+\n+  if (!in_valid) {\n+    return 0;\n+  }\n+\n+  if (RE2::FullMatch(data, period_only_contains_numbers)) {\n+    return GetIntervalYearFromNumber(data, out_valid);\n\nReview comment:\n       The comment is incorrect, the number that the user defines is the quantity o months, I will fix it in the comment.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-25T00:11:37.673+0000",
                    "updated": "2021-11-25T00:11:37.673+0000",
                    "started": "2021-11-25T00:11:37.673+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686162",
                    "issueId": "13374515"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/worklog/686164",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #10137:\nURL: https://github.com/apache/arrow/pull/10137#discussion_r756492227\n\n\n\n##########\nFile path: cpp/src/gandiva/interval_holder.cc\n##########\n@@ -0,0 +1,277 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"gandiva/interval_holder.h\"\n+\n+#include \"gandiva/node.h\"\n+#include \"gandiva/regex_util.h\"\n+\n+namespace gandiva {\n+\n+// pre-compiled pattern for matching period that only have numbers\n+static const RE2 period_only_contains_numbers(R\"(\\d+)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contains weeks.\n+static const RE2 iso8601_complete_period(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\"\n+    R\"(T([[:digit:]]+H)?([[:digit:]]+M)?([[:digit:]]+S|[[:digit:]]+\\.[[:digit:]]+S)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const RE2 iso8601_period_without_time(\n+    R\"(P([[:digit:]]+Y)?([[:digit:]]+M)?([[:digit:]]+D)?)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that not contain time\n+// (hours, minutes and seconds) information.\n+static const std::regex period_not_contains_time(R\"(^((?!T).)*$)\");\n+\n+// pre-compiled pattern for matching periods in 8601 formats that contains weeks inside\n+// them. The ISO8601 specification defines that if the string contains a week, it can not\n+// have other time granularities information, like day, years and months.\n+static const RE2 iso8601_period_with_weeks(R\"(P([[:digit:]]+W){1})\");\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromMillis(const std::string& number_as_string,\n+                                                     bool* out_valid) {\n+  int64_t period_in_millis = std::stol(number_as_string);\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+\n+  int64_t qty_days = period_in_millis / days_to_standard_millis;\n+  int64_t qty_millis = period_in_millis % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromWeeks(const std::string& number_as_string,\n+                                                    bool* out_valid) {\n+  auto qty_weeks = static_cast<int64_t>(std::stod(number_as_string));\n+\n+  // It considers that a day has exactly 24 hours of duration\n+  int64_t days_to_standard_millis = 86400000;\n+  int64_t week_to_qty_days = 7;\n+\n+  int64_t millis_in_a_week = qty_weeks * week_to_qty_days * days_to_standard_millis;\n+\n+  int64_t qty_days = millis_in_a_week / days_to_standard_millis;\n+  int64_t qty_millis = millis_in_a_week % days_to_standard_millis;\n+\n+  // The response is a 64-bit integer where the lower half of the bytes represents the\n+  // number of the days and the other half represents the number of milliseconds.\n+  int64_t out = (qty_days & 0x00000000FFFFFFFF);\n+  out |= ((qty_millis << 32) & 0xFFFFFFFF00000000);\n+\n+  *out_valid = true;\n+  return out;\n+}\n+\n+int64_t IntervalDaysHolder::GetIntervalDayFromCompletePeriod(\n+    const std::string& days_in_period, const std::string& hours_in_period,\n+    const std::string& minutes_in_period, const std::string& seconds_in_period,\n+    bool* out_valid) {\n+  int64_t qty_days = 0;\n+  int64_t qty_hours = 0;\n+  int64_t qty_minutes = 0;\n+  int64_t qty_seconds = 0;\n+\n+  if (!days_in_period.empty()) {\n+    qty_days = static_cast<int64_t>(std::stod(days_in_period));\n+  }\n+\n+  if (!hours_in_period.empty()) {\n+    qty_hours = static_cast<int64_t>(std::stod(hours_in_period));\n+  }\n+\n+  if (!minutes_in_period.empty()) {\n+    qty_minutes = static_cast<int64_t>(std::stod(minutes_in_period));\n+  }\n+\n+  if (!seconds_in_period.empty()) {\n+    qty_seconds = static_cast<int64_t>(std::stod(seconds_in_period));\n+  }\n+\n+  int64_t millis_in_the_period = qty_hours * 3600000 +  // millis in a hour\n\nReview comment:\n       Done. I add the variables as static const.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-25T00:15:58.111+0000",
                    "updated": "2021-11-25T00:15:58.111+0000",
                    "started": "2021-11-25T00:15:58.110+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "686164",
                    "issueId": "13374515"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 22800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@13e067a3[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@78a8a913[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3dbbc22d[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@e604b8[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@b5fb056[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@151d706f[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@76d4624b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@46277bed[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@300cbe7f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@4eec2e19[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1b7fdbb5[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@667a3324[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 22800,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Feb 01 06:12:54 UTC 2022",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2022-02-01T06:12:54.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-12516/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-04-22T23:16:38.000+0000",
        "updated": "2022-04-24T18:39:21.000+0000",
        "timeoriginalestimate": null,
        "description": "The functions get a string, that can be a number or a [period using the ISO8601 format|https://en.wikipedia.org/wiki/ISO_8601#Durations] and returns the respective time interval.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "6h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 22800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Gandiva] Implements castINTERVALDAY(varchar) and castINTERVALYEAR(varchar) functions",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13374515/comment/17485058",
                    "id": "17485058",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pravindra",
                        "name": "pravindra",
                        "key": "pravindra",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34055",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34055",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34055",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34055"
                        },
                        "displayName": "Pindikura Ravindra",
                        "active": true,
                        "timeZone": "Asia/Kolkata"
                    },
                    "body": "Issue resolved by pull request 10137\n[https://github.com/apache/arrow/pull/10137]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pravindra",
                        "name": "pravindra",
                        "key": "pravindra",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34055",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34055",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34055",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34055"
                        },
                        "displayName": "Pindikura Ravindra",
                        "active": true,
                        "timeZone": "Asia/Kolkata"
                    },
                    "created": "2022-02-01T06:12:54.388+0000",
                    "updated": "2022-02-01T06:12:54.388+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0qcyg:",
        "customfield_12314139": null
    }
}