{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13201499",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201499",
    "key": "ARROW-3912",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343858",
                "id": "12343858",
                "description": "",
                "name": "0.12.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-01-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
            "name": "kou",
            "key": "kou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
            },
            "displayName": "Kouhei Sutou",
            "active": true,
            "timeZone": "Asia/Tokyo"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12332956",
                "id": "12332956",
                "name": "C++ - Plasma"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12332430",
                "id": "12332430",
                "name": "GLib"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
            "name": "kou",
            "key": "kou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
            },
            "displayName": "Kouhei Sutou",
            "active": true,
            "timeZone": "Asia/Tokyo"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
            "name": "kou",
            "key": "kou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
            },
            "displayName": "Kouhei Sutou",
            "active": true,
            "timeZone": "Asia/Tokyo"
        },
        "aggregateprogress": {
            "progress": 4800,
            "total": 4800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 4800,
            "total": 4800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3912/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 9,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201499/worklog/170959",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou opened a new pull request #3056: ARROW-3912: [Plasma][GLib] Add support for creating and referring objects\nURL: https://github.com/apache/arrow/pull/3056\n \n \n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-30T03:06:18.968+0000",
                    "updated": "2018-11-30T03:06:18.968+0000",
                    "started": "2018-11-30T03:06:18.968+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170959",
                    "issueId": "13201499"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201499/worklog/171342",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "shiro615 commented on a change in pull request #3056: ARROW-3912: [Plasma][GLib] Add support for creating and referring objects\nURL: https://github.com/apache/arrow/pull/3056#discussion_r238085521\n \n \n\n ##########\n File path: c_glib/plasma-glib/client.cpp\n ##########\n @@ -21,47 +21,192 @@\n #  include <config.h>\n #endif\n \n+#include <arrow-glib/buffer.hpp>\n #include <arrow-glib/error.hpp>\n \n+#ifdef HAVE_ARROW_GPU\n+#  include <arrow-gpu-glib/cuda.hpp>\n+#endif\n+\n #include <plasma-glib/client.hpp>\n+#include <plasma-glib/object.hpp>\n \n G_BEGIN_DECLS\n \n /**\n  * SECTION: client\n- * @title: Client classes\n+ * @section_id: client-classes\n+ * @title: Client related classes\n  * @include: plasma-glib/plasma-glib.h\n  *\n+ * #GPlasmaClientCreateOptions is a class for customizing object creation.\n+ *\n  * #GPlasmaClient is a class for an interface with a plasma store\n  * and a plasma manager.\n  *\n  * Since: 0.12.0\n  */\n \n+typedef struct GPlasmaClientCreateOptionsPrivate_ {\n+  guint8 *metadata;\n+  gsize metadata_size;\n+  gint gpu_device;\n+} GPlasmaClientCreateOptionsPrivate;\n+\n+enum {\n+  PROP_GPU_DEVICE = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GPlasmaClientCreateOptions,\n+                           gplasma_client_create_options,\n+                           G_TYPE_OBJECT)\n+\n+#define GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(object)         \\\n+  static_cast<GPlasmaClientCreateOptionsPrivate *>(               \\\n+    gplasma_client_create_options_get_instance_private(           \\\n+      GPLASMA_CLIENT_CREATE_OPTIONS(object)))\n+\n+static void\n+gplasma_client_create_options_set_property(GObject *object,\n+                                           guint prop_id,\n+                                           const GValue *value,\n+                                           GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_GPU_DEVICE:\n+    priv->gpu_device = g_value_get_int(value);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_client_create_options_get_property(GObject *object,\n+                                           guint prop_id,\n+                                           GValue *value,\n+                                           GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_GPU_DEVICE:\n+    g_value_set_int(value, priv->gpu_device);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_client_create_options_init(GPlasmaClientCreateOptions *object)\n+{\n+}\n+\n+static void\n+gplasma_client_create_options_class_init(GPlasmaClientCreateOptionsClass *klass)\n+{\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->set_property = gplasma_client_create_options_set_property;\n+  gobject_class->get_property = gplasma_client_create_options_get_property;\n+\n+  GParamSpec *spec;\n+  spec = g_param_spec_int(\"gpu-device\",\n+                          \"GPU device\",\n+                          \"The GPU device number. -1 means GPU isn't used.\",\n+                          -1,\n+                          G_MAXINT,\n+                          -1,\n+                          static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                   G_PARAM_CONSTRUCT));\n+  g_object_class_install_property(gobject_class, PROP_GPU_DEVICE, spec);\n+}\n+\n+/**\n+ * gplasma_client_create_options_new:\n+ *\n+ * Returns: A newly created #GPlasmaClientCreateOptions.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaClientCreateOptions *\n+gplasma_client_create_options_new(void)\n+{\n+  auto options = g_object_new(GPLASMA_TYPE_CLIENT_CREATE_OPTIONS,\n+                              NULL);\n+  return GPLASMA_CLIENT_CREATE_OPTIONS(options);\n+}\n+\n+/**\n+ * gplasma_client_create_options_set_metadata:\n+ * @options: A #GPlasmaClientCreateOptions.\n+ * @metadata: (nullable) (array length=size): The metadata of a created object.\n+ * @size: The number of bytes of the metadata.\n+ *\n+ * Since: 0.12.0\n+ */\n+void\n+gplasma_client_create_options_set_metadata(GPlasmaClientCreateOptions *options,\n+                                           const guint8 *metadata,\n+                                           gsize size)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(options);\n+  if (priv->metadata) {\n+    g_free(priv->metadata);\n+  }\n+  priv->metadata = static_cast<guint8 *>(g_memdup(metadata, size));\n+  priv->metadata_size = size;\n+}\n+\n+/**\n+ * gplasma_client_create_options_get_metadata:\n+ * @options: A #GPlasmaClientCreateOptions.\n+ * @size: (nullable) (out): The number of bytes of the metadata.\n+ *\n+ * Returns: (nullable) (array length=size): The metadata of a created object.\n+ *\n+ * Since: 0.12.0\n+ */\n+const guint8 *\n+gplasma_client_create_options_get_metadata(GPlasmaClientCreateOptions *options,\n+                                           gsize *size)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(options);\n+  if (size) {\n+    *size = priv->metadata_size;\n+  }\n+  return priv->metadata;\n+}\n+\n typedef struct GPlasmaClientPrivate_ {\n-  std::shared_ptr<plasma::PlasmaClient> client;\n+  plasma::PlasmaClient *client;\n \n Review comment:\n   Is that because this change prevent a memory leak?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-02T05:36:35.813+0000",
                    "updated": "2018-12-02T05:36:35.813+0000",
                    "started": "2018-12-02T05:36:35.812+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "171342",
                    "issueId": "13201499"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201499/worklog/171343",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "shiro615 commented on a change in pull request #3056: ARROW-3912: [Plasma][GLib] Add support for creating and referring objects\nURL: https://github.com/apache/arrow/pull/3056#discussion_r238085554\n \n \n\n ##########\n File path: c_glib/plasma-glib/client.cpp\n ##########\n @@ -122,10 +267,160 @@ GPlasmaClient *\n gplasma_client_new(const gchar *store_socket_name,\n                    GError **error)\n {\n-  auto plasma_client = std::make_shared<plasma::PlasmaClient>();\n+  auto plasma_client = new plasma::PlasmaClient();\n   auto status = plasma_client->Connect(store_socket_name, \"\");\n   if (garrow_error_check(error, status, \"[plasma][client][new]\")) {\n-    return gplasma_client_new_raw(&plasma_client);\n+    return gplasma_client_new_raw(plasma_client);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+/**\n+ * gplasma_client_create:\n+ * @client: A #GPlasmaClient.\n+ * @id: The ID for a newly created object.\n+ * @data_size: The number of bytes of data for a newly created object.\n+ * @options: (nullable): The option for creating an object.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full): A newly created #GPlasmaCreatedObject\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaCreatedObject *\n+gplasma_client_create(GPlasmaClient *client,\n+                      GPlasmaObjectID *id,\n+                      gsize data_size,\n+                      GPlasmaClientCreateOptions *options,\n+                      GError **error)\n+{\n+  const auto context = \"[plasma][client][create]\";\n+  auto plasma_client = gplasma_client_get_raw(client);\n+  auto plasma_id = gplasma_object_id_get_raw(id);\n+  const uint8_t *raw_metadata = nullptr;\n+  int64_t raw_metadata_size = 0;\n+  int device_number = 0;\n+  if (options) {\n+    auto options_priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(options);\n+    raw_metadata = options_priv->metadata;\n+    raw_metadata_size = options_priv->metadata_size;\n+    if (options_priv->gpu_device >= 0) {\n+#ifndef HAVE_ARROW_GPU\n+      g_set_error(error,\n+                  GARROW_ERROR,\n+                  GARROW_ERROR_INVALID,\n+                  \"%s Arrow GPU GLib is needed to use GPU\",\n+                  context);\n+      return NULL;\n+#endif\n+      device_number = options_priv->gpu_device + 1;\n+    }\n+  }\n+  std::shared_ptr<arrow::Buffer> plasma_data;\n+  auto status = plasma_client->Create(plasma_id,\n+                                      data_size,\n+                                      raw_metadata,\n+                                      raw_metadata_size,\n+                                      &plasma_data,\n+                                      device_number);\n+  if (garrow_error_check(error, status, context)) {\n+    GArrowBuffer *data = nullptr;\n+    if (device_number == 0) {\n+      auto plasma_mutable_data =\n+        std::static_pointer_cast<arrow::MutableBuffer>(plasma_data);\n+      data = GARROW_BUFFER(garrow_mutable_buffer_new_raw(&plasma_mutable_data));\n+#ifdef HAVE_ARROW_GPU\n+    } else {\n+      auto plasma_cuda_data =\n+        std::static_pointer_cast<arrow::gpu::CudaBuffer>(plasma_data);\n+      data = GARROW_BUFFER(garrow_gpu_cuda_buffer_new_raw(&plasma_cuda_data));\n+#endif\n+    }\n+    GArrowBuffer *metadata = nullptr;\n+    if (raw_metadata_size > 0) {\n+      auto plasma_metadata =\n+        std::make_shared<arrow::Buffer>(raw_metadata, raw_metadata_size);\n+      metadata = garrow_buffer_new_raw(&plasma_metadata);\n+    }\n+    return gplasma_created_object_new_raw(client,\n+                                          id,\n+                                          data,\n+                                          metadata,\n+                                          device_number - 1);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+/**\n+ * gplasma_client_refer_object:\n+ * @client: A #GPlasmaClient.\n+ * @id: The ID of the target object.\n+ * @timeout_ms: The timeout in milliseconds. -1 means no timeout.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full): A found #GPlasmaReferredObject\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaReferredObject *\n+gplasma_client_refer_object(GPlasmaClient *client,\n+                            GPlasmaObjectID *id,\n+                            gint64 timeout_ms,\n+                            GError **error)\n+{\n+  const auto context = \"[plasma][client][refer-object]\";\n+  auto plasma_client = gplasma_client_get_raw(client);\n+  auto plasma_id = gplasma_object_id_get_raw(id);\n+  std::vector<plasma::ObjectID> plasma_ids;\n+  plasma_ids.push_back(plasma_id);\n+  std::vector<plasma::ObjectBuffer> plasma_object_buffers;\n+  auto status = plasma_client->Get(plasma_ids,\n+                                   timeout_ms,\n+                                   &plasma_object_buffers);\n+  if (garrow_error_check(error, status, context)) {\n+    auto plasma_object_buffer = plasma_object_buffers[0];\n+    auto plasma_data = plasma_object_buffer.data;\n+    auto plasma_metadata = plasma_object_buffer.metadata;\n+    GArrowBuffer *data;\n+    GArrowBuffer *metadata;\n \n Review comment:\n   Do we need to silence the warning?\r\n   https://travis-ci.org/apache/arrow/jobs/461631864#L3955\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-02T05:36:35.818+0000",
                    "updated": "2018-12-02T05:36:35.818+0000",
                    "started": "2018-12-02T05:36:35.817+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "171343",
                    "issueId": "13201499"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201499/worklog/171344",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "shiro615 commented on a change in pull request #3056: ARROW-3912: [Plasma][GLib] Add support for creating and referring objects\nURL: https://github.com/apache/arrow/pull/3056#discussion_r238085561\n \n \n\n ##########\n File path: c_glib/plasma-glib/object.cpp\n ##########\n @@ -0,0 +1,537 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#ifdef HAVE_CONFIG_H\n+#  include <config.h>\n+#endif\n+\n+#include <arrow-glib/error.hpp>\n+\n+#include <plasma-glib/client.hpp>\n+#include <plasma-glib/object.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: object\n+ * @section_id: object-classes\n+ * @title: Object related classes\n+ * @include: plasma-glib/plasma-glib.h\n+ *\n+ * #GPlasmaObjectID is a class for an object ID.\n+ *\n+ * #GPlasmaObject is a base class for an object stored in plasma store.\n+ *\n+ * #GPlasmaCreatedObject is a class for a created object. You can\n+ * change data of the object until the object is sealed or aborted.\n+ *\n+ * #GPlasmaReferredObject is a class for a created object. You can\n+ * only refer the data and metadata of the object. You can't change\n+ * the data of the object.\n+ *\n+ * Since: 0.12.0\n+ */\n+\n+typedef struct GPlasmaObjectIDPrivate_ {\n+  plasma::ObjectID id;\n+} GPlasmaObjectIDPrivate;\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GPlasmaObjectID,\n+                           gplasma_object_id,\n+                           G_TYPE_OBJECT)\n+\n+#define GPLASMA_OBJECT_ID_GET_PRIVATE(object)   \\\n+  static_cast<GPlasmaObjectIDPrivate *>(        \\\n+    gplasma_object_id_get_instance_private(     \\\n+      GPLASMA_OBJECT_ID(object)))\n+\n+static void\n+gplasma_object_id_init(GPlasmaObjectID *object)\n+{\n+}\n+\n+static void\n+gplasma_object_id_class_init(GPlasmaObjectIDClass *klass)\n+{\n+}\n+\n+/**\n+ * gplasma_object_id_new:\n+ * @id: (array length=size): The raw ID bytes.\n+ * @size: The number of bytes of the ID. It must be 1..20.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable): A newly created #GPlasmaObjectID on success,\n+ *   %NULL on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaObjectID *\n+gplasma_object_id_new(const guint8 *id,\n+                      gsize size,\n+                      GError **error)\n+{\n+  if (size == 0 || size > plasma::kUniqueIDSize) {\n+    g_set_error(error,\n+                GARROW_ERROR,\n+                GARROW_ERROR_INVALID,\n+                \"[plasma][object-id][new] \"\n+                \"ID must be 1..20 bytes: <%\" G_GSIZE_FORMAT \">\",\n+                size);\n+    return NULL;\n+  }\n+\n+  auto object_id = g_object_new(GPLASMA_TYPE_OBJECT_ID, NULL);\n+  auto priv = GPLASMA_OBJECT_ID_GET_PRIVATE(object_id);\n+  memcpy(priv->id.mutable_data(), id, size);\n+  if (size != plasma::kUniqueIDSize) {\n+    memset(priv->id.mutable_data() + size, 0, plasma::kUniqueIDSize - size);\n+  }\n+  return GPLASMA_OBJECT_ID(object_id);\n+}\n+\n+/**\n+ * gplasma_object_id_to_binary:\n+ * @id: A #GPlasmaObjectID.\n+ * @size: (nullable) (out): The number of bytes of the byte string of\n+ *   the object ID. It's always 20. 20 is `plasma::kUniqueIDSize`.\n+ *\n+ * Returns: (array length=size): The byte string of the object ID.\n+ *\n+ * Since: 0.12.0\n+ */\n+const guint8 *\n+gplasma_object_id_to_binary(GPlasmaObjectID *id,\n+                            gsize *size)\n+{\n+  auto priv = GPLASMA_OBJECT_ID_GET_PRIVATE(id);\n+  if (size) {\n+    *size = plasma::kUniqueIDSize;\n+  }\n+  return priv->id.data();\n+}\n+\n+/**\n+ * gplasma_object_id_to_hex:\n+ * @id: A #GPlasmaObjectID.\n+ *\n+ * Returns: The hex representation of the object ID.\n+ *\n+ *   It should be freed with g_free() when no longer needed.\n+ *\n+ * Since: 0.12.0\n+ */\n+gchar *\n+gplasma_object_id_to_hex(GPlasmaObjectID *id)\n+{\n+  auto priv = GPLASMA_OBJECT_ID_GET_PRIVATE(id);\n+  return g_strdup(priv->id.hex().c_str());\n+}\n+\n+typedef struct GPlasmaObjectPrivate_ {\n+  GPlasmaClient *client;\n+  GPlasmaObjectID *id;\n+  GArrowBuffer *data;\n+  GArrowBuffer *metadata;\n+  gint gpu_device;\n+} GPlasmaObjectPrivate;\n+\n+enum {\n+  PROP_CLIENT = 1,\n+  PROP_ID,\n+  PROP_DATA,\n+  PROP_METADATA,\n+  PROP_GPU_DEVICE\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GPlasmaObject,\n+                           gplasma_object,\n+                           G_TYPE_OBJECT)\n+\n+#define GPLASMA_OBJECT_GET_PRIVATE(object)      \\\n+  static_cast<GPlasmaObjectPrivate *>(          \\\n+    gplasma_object_get_instance_private(        \\\n+      GPLASMA_OBJECT(object)))\n+\n+static void\n+gplasma_object_dispose(GObject *object)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  // Properties except priv->id must be disposed in subclass.\n+\n+  if (priv->id) {\n+    g_object_unref(priv->id);\n+    priv->id = nullptr;\n+  }\n+\n+  G_OBJECT_CLASS(gplasma_object_parent_class)->dispose(object);\n+}\n+\n+static void\n+gplasma_object_set_property(GObject *object,\n+                            guint prop_id,\n+                            const GValue *value,\n+                            GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_CLIENT:\n+    priv->client = GPLASMA_CLIENT(g_value_dup_object(value));\n+    break;\n+  case PROP_ID:\n+    priv->id = GPLASMA_OBJECT_ID(g_value_dup_object(value));\n+    break;\n+  case PROP_DATA:\n+    priv->data = GARROW_BUFFER(g_value_dup_object(value));\n+    break;\n+  case PROP_METADATA:\n+    priv->metadata = GARROW_BUFFER(g_value_dup_object(value));\n+    break;\n+  case PROP_GPU_DEVICE:\n+    priv->gpu_device = g_value_get_int(value);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_object_get_property(GObject *object,\n+                            guint prop_id,\n+                            GValue *value,\n+                            GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_CLIENT:\n+    g_value_set_object(value, priv->client);\n+    break;\n+  case PROP_ID:\n+    g_value_set_object(value, priv->id);\n+    break;\n+  case PROP_DATA:\n+    g_value_set_object(value, priv->data);\n+    break;\n+  case PROP_METADATA:\n+    g_value_set_object(value, priv->metadata);\n+    break;\n+  case PROP_GPU_DEVICE:\n+    g_value_set_int(value, priv->gpu_device);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_object_init(GPlasmaObject *object)\n+{\n+}\n+\n+static void\n+gplasma_object_class_init(GPlasmaObjectClass *klass)\n+{\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->dispose      = gplasma_object_dispose;\n+  gobject_class->set_property = gplasma_object_set_property;\n+  gobject_class->get_property = gplasma_object_get_property;\n+\n+  GParamSpec *spec;\n+  spec = g_param_spec_object(\"client\",\n+                             \"Client\",\n+                             \"The client\",\n+                             GPLASMA_TYPE_CLIENT,\n+                             static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                      G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_CLIENT, spec);\n+\n+  spec = g_param_spec_object(\"id\",\n+                             \"ID\",\n+                             \"The ID of this object\",\n+                             GPLASMA_TYPE_OBJECT_ID,\n+                             static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                      G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_ID, spec);\n+\n+  spec = g_param_spec_object(\"data\",\n+                             \"Data\",\n+                             \"The data of this object\",\n+                             GARROW_TYPE_BUFFER,\n+                             static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                      G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_DATA, spec);\n+\n+  spec = g_param_spec_object(\"metadata\",\n+                             \"Metadata\",\n+                             \"The metadata of this object\",\n+                             GARROW_TYPE_BUFFER,\n+                             static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                      G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_METADATA, spec);\n+\n+  spec = g_param_spec_int(\"gpu-device\",\n+                          \"GPU device\",\n+                          \"The GPU device number. -1 means GPU isn't used.\",\n+                          -1,\n+                          G_MAXINT,\n+                          -1,\n+                          static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                   G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_GPU_DEVICE, spec);\n+}\n+\n+static bool\n+gplasma_object_check_not_released(GPlasmaObjectPrivate *priv,\n+                                  GError **error,\n+                                  const gchar *context)\n+{\n+  if (priv->client) {\n+    return true;\n+  }\n+\n+  auto id_priv = GPLASMA_OBJECT_ID_GET_PRIVATE(priv->id);\n+  auto id_hex = id_priv->id.hex();\n+  g_set_error(error,\n+              GARROW_ERROR,\n+              GARROW_ERROR_INVALID,\n+              \"%s: Can't process released object: <%s>\",\n+              context,\n+              id_hex.c_str());\n+  return false;\n+}\n+\n+static void\n+gplasma_object_release_resources(GPlasmaObjectPrivate *priv)\n+{\n+  if (priv->client) {\n+    g_object_unref(priv->client);\n+    priv->client = nullptr;\n+  }\n+\n+  if (priv->data) {\n+    g_object_unref(priv->data);\n+    priv->data = nullptr;\n+  }\n+\n+  if (priv->metadata) {\n+    g_object_unref(priv->metadata);\n+    priv->metadata = nullptr;\n+  }\n+}\n+\n+G_DEFINE_TYPE(GPlasmaCreatedObject,\n+              gplasma_created_object,\n+              GPLASMA_TYPE_OBJECT)\n+\n+static void\n+gplasma_created_object_dispose(GObject *object)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  if (priv->client) {\n+    gplasma_created_object_abort(GPLASMA_CREATED_OBJECT(object), NULL);\n+  }\n+\n+  G_OBJECT_CLASS(gplasma_created_object_parent_class)->dispose(object);\n+}\n+\n+static void\n+gplasma_created_object_init(GPlasmaCreatedObject *object)\n+{\n+}\n+\n+static void\n+gplasma_created_object_class_init(GPlasmaCreatedObjectClass *klass)\n+{\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->dispose = gplasma_created_object_dispose;\n+}\n+\n+/**\n+ * gplasma_created_object_seal:\n+ * @object: A #GPlasmaCreatedObject.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Seals the object in the object store. You can't use the sealed\n+ * object anymore.\n+ *\n+ * Returns: %TRUE on success, %FALSE on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+gboolean\n+gplasma_created_object_seal(GPlasmaCreatedObject *object,\n+                            GError **error)\n+{\n+  const auto context = \"[plasma][created-object][seal]\";\n+\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+  if (!gplasma_object_check_not_released(priv, error, context)) {\n+    return FALSE;\n+  }\n+\n+  auto plasma_client = gplasma_client_get_raw(priv->client);\n+  auto id_priv = GPLASMA_OBJECT_ID_GET_PRIVATE(priv->id);\n+  auto status = plasma_client->Seal(id_priv->id);\n+  auto success = garrow_error_check(error, status, context);\n+  if (success) {\n+    plasma_client->Release(id_priv->id);\n \n Review comment:\n   Do we need to receive `status` to silence the warning?\r\n   https://travis-ci.org/apache/arrow/jobs/461631864#L3940\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-02T05:36:36.081+0000",
                    "updated": "2018-12-02T05:36:36.081+0000",
                    "started": "2018-12-02T05:36:36.081+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "171344",
                    "issueId": "13201499"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201499/worklog/171359",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #3056: ARROW-3912: [Plasma][GLib] Add support for creating and referring objects\nURL: https://github.com/apache/arrow/pull/3056#discussion_r238088150\n \n \n\n ##########\n File path: c_glib/plasma-glib/client.cpp\n ##########\n @@ -21,47 +21,192 @@\n #  include <config.h>\n #endif\n \n+#include <arrow-glib/buffer.hpp>\n #include <arrow-glib/error.hpp>\n \n+#ifdef HAVE_ARROW_GPU\n+#  include <arrow-gpu-glib/cuda.hpp>\n+#endif\n+\n #include <plasma-glib/client.hpp>\n+#include <plasma-glib/object.hpp>\n \n G_BEGIN_DECLS\n \n /**\n  * SECTION: client\n- * @title: Client classes\n+ * @section_id: client-classes\n+ * @title: Client related classes\n  * @include: plasma-glib/plasma-glib.h\n  *\n+ * #GPlasmaClientCreateOptions is a class for customizing object creation.\n+ *\n  * #GPlasmaClient is a class for an interface with a plasma store\n  * and a plasma manager.\n  *\n  * Since: 0.12.0\n  */\n \n+typedef struct GPlasmaClientCreateOptionsPrivate_ {\n+  guint8 *metadata;\n+  gsize metadata_size;\n+  gint gpu_device;\n+} GPlasmaClientCreateOptionsPrivate;\n+\n+enum {\n+  PROP_GPU_DEVICE = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GPlasmaClientCreateOptions,\n+                           gplasma_client_create_options,\n+                           G_TYPE_OBJECT)\n+\n+#define GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(object)         \\\n+  static_cast<GPlasmaClientCreateOptionsPrivate *>(               \\\n+    gplasma_client_create_options_get_instance_private(           \\\n+      GPLASMA_CLIENT_CREATE_OPTIONS(object)))\n+\n+static void\n+gplasma_client_create_options_set_property(GObject *object,\n+                                           guint prop_id,\n+                                           const GValue *value,\n+                                           GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_GPU_DEVICE:\n+    priv->gpu_device = g_value_get_int(value);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_client_create_options_get_property(GObject *object,\n+                                           guint prop_id,\n+                                           GValue *value,\n+                                           GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_GPU_DEVICE:\n+    g_value_set_int(value, priv->gpu_device);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_client_create_options_init(GPlasmaClientCreateOptions *object)\n+{\n+}\n+\n+static void\n+gplasma_client_create_options_class_init(GPlasmaClientCreateOptionsClass *klass)\n+{\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->set_property = gplasma_client_create_options_set_property;\n+  gobject_class->get_property = gplasma_client_create_options_get_property;\n+\n+  GParamSpec *spec;\n+  spec = g_param_spec_int(\"gpu-device\",\n+                          \"GPU device\",\n+                          \"The GPU device number. -1 means GPU isn't used.\",\n+                          -1,\n+                          G_MAXINT,\n+                          -1,\n+                          static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                   G_PARAM_CONSTRUCT));\n+  g_object_class_install_property(gobject_class, PROP_GPU_DEVICE, spec);\n+}\n+\n+/**\n+ * gplasma_client_create_options_new:\n+ *\n+ * Returns: A newly created #GPlasmaClientCreateOptions.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaClientCreateOptions *\n+gplasma_client_create_options_new(void)\n+{\n+  auto options = g_object_new(GPLASMA_TYPE_CLIENT_CREATE_OPTIONS,\n+                              NULL);\n+  return GPLASMA_CLIENT_CREATE_OPTIONS(options);\n+}\n+\n+/**\n+ * gplasma_client_create_options_set_metadata:\n+ * @options: A #GPlasmaClientCreateOptions.\n+ * @metadata: (nullable) (array length=size): The metadata of a created object.\n+ * @size: The number of bytes of the metadata.\n+ *\n+ * Since: 0.12.0\n+ */\n+void\n+gplasma_client_create_options_set_metadata(GPlasmaClientCreateOptions *options,\n+                                           const guint8 *metadata,\n+                                           gsize size)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(options);\n+  if (priv->metadata) {\n+    g_free(priv->metadata);\n+  }\n+  priv->metadata = static_cast<guint8 *>(g_memdup(metadata, size));\n+  priv->metadata_size = size;\n+}\n+\n+/**\n+ * gplasma_client_create_options_get_metadata:\n+ * @options: A #GPlasmaClientCreateOptions.\n+ * @size: (nullable) (out): The number of bytes of the metadata.\n+ *\n+ * Returns: (nullable) (array length=size): The metadata of a created object.\n+ *\n+ * Since: 0.12.0\n+ */\n+const guint8 *\n+gplasma_client_create_options_get_metadata(GPlasmaClientCreateOptions *options,\n+                                           gsize *size)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(options);\n+  if (size) {\n+    *size = priv->metadata_size;\n+  }\n+  return priv->metadata;\n+}\n+\n typedef struct GPlasmaClientPrivate_ {\n-  std::shared_ptr<plasma::PlasmaClient> client;\n+  plasma::PlasmaClient *client;\n \n Review comment:\n   No.\r\n   `shared_ptr` is just not needed here. We don't need to share a `plasma::PlasmaClient` created by `plasma_client_new()`.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-02T07:51:28.337+0000",
                    "updated": "2018-12-02T07:51:28.337+0000",
                    "started": "2018-12-02T07:51:28.336+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "171359",
                    "issueId": "13201499"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201499/worklog/171360",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #3056: ARROW-3912: [Plasma][GLib] Add support for creating and referring objects\nURL: https://github.com/apache/arrow/pull/3056#discussion_r238088162\n \n \n\n ##########\n File path: c_glib/plasma-glib/client.cpp\n ##########\n @@ -122,10 +267,160 @@ GPlasmaClient *\n gplasma_client_new(const gchar *store_socket_name,\n                    GError **error)\n {\n-  auto plasma_client = std::make_shared<plasma::PlasmaClient>();\n+  auto plasma_client = new plasma::PlasmaClient();\n   auto status = plasma_client->Connect(store_socket_name, \"\");\n   if (garrow_error_check(error, status, \"[plasma][client][new]\")) {\n-    return gplasma_client_new_raw(&plasma_client);\n+    return gplasma_client_new_raw(plasma_client);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+/**\n+ * gplasma_client_create:\n+ * @client: A #GPlasmaClient.\n+ * @id: The ID for a newly created object.\n+ * @data_size: The number of bytes of data for a newly created object.\n+ * @options: (nullable): The option for creating an object.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full): A newly created #GPlasmaCreatedObject\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaCreatedObject *\n+gplasma_client_create(GPlasmaClient *client,\n+                      GPlasmaObjectID *id,\n+                      gsize data_size,\n+                      GPlasmaClientCreateOptions *options,\n+                      GError **error)\n+{\n+  const auto context = \"[plasma][client][create]\";\n+  auto plasma_client = gplasma_client_get_raw(client);\n+  auto plasma_id = gplasma_object_id_get_raw(id);\n+  const uint8_t *raw_metadata = nullptr;\n+  int64_t raw_metadata_size = 0;\n+  int device_number = 0;\n+  if (options) {\n+    auto options_priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(options);\n+    raw_metadata = options_priv->metadata;\n+    raw_metadata_size = options_priv->metadata_size;\n+    if (options_priv->gpu_device >= 0) {\n+#ifndef HAVE_ARROW_GPU\n+      g_set_error(error,\n+                  GARROW_ERROR,\n+                  GARROW_ERROR_INVALID,\n+                  \"%s Arrow GPU GLib is needed to use GPU\",\n+                  context);\n+      return NULL;\n+#endif\n+      device_number = options_priv->gpu_device + 1;\n+    }\n+  }\n+  std::shared_ptr<arrow::Buffer> plasma_data;\n+  auto status = plasma_client->Create(plasma_id,\n+                                      data_size,\n+                                      raw_metadata,\n+                                      raw_metadata_size,\n+                                      &plasma_data,\n+                                      device_number);\n+  if (garrow_error_check(error, status, context)) {\n+    GArrowBuffer *data = nullptr;\n+    if (device_number == 0) {\n+      auto plasma_mutable_data =\n+        std::static_pointer_cast<arrow::MutableBuffer>(plasma_data);\n+      data = GARROW_BUFFER(garrow_mutable_buffer_new_raw(&plasma_mutable_data));\n+#ifdef HAVE_ARROW_GPU\n+    } else {\n+      auto plasma_cuda_data =\n+        std::static_pointer_cast<arrow::gpu::CudaBuffer>(plasma_data);\n+      data = GARROW_BUFFER(garrow_gpu_cuda_buffer_new_raw(&plasma_cuda_data));\n+#endif\n+    }\n+    GArrowBuffer *metadata = nullptr;\n+    if (raw_metadata_size > 0) {\n+      auto plasma_metadata =\n+        std::make_shared<arrow::Buffer>(raw_metadata, raw_metadata_size);\n+      metadata = garrow_buffer_new_raw(&plasma_metadata);\n+    }\n+    return gplasma_created_object_new_raw(client,\n+                                          id,\n+                                          data,\n+                                          metadata,\n+                                          device_number - 1);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+/**\n+ * gplasma_client_refer_object:\n+ * @client: A #GPlasmaClient.\n+ * @id: The ID of the target object.\n+ * @timeout_ms: The timeout in milliseconds. -1 means no timeout.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full): A found #GPlasmaReferredObject\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaReferredObject *\n+gplasma_client_refer_object(GPlasmaClient *client,\n+                            GPlasmaObjectID *id,\n+                            gint64 timeout_ms,\n+                            GError **error)\n+{\n+  const auto context = \"[plasma][client][refer-object]\";\n+  auto plasma_client = gplasma_client_get_raw(client);\n+  auto plasma_id = gplasma_object_id_get_raw(id);\n+  std::vector<plasma::ObjectID> plasma_ids;\n+  plasma_ids.push_back(plasma_id);\n+  std::vector<plasma::ObjectBuffer> plasma_object_buffers;\n+  auto status = plasma_client->Get(plasma_ids,\n+                                   timeout_ms,\n+                                   &plasma_object_buffers);\n+  if (garrow_error_check(error, status, context)) {\n+    auto plasma_object_buffer = plasma_object_buffers[0];\n+    auto plasma_data = plasma_object_buffer.data;\n+    auto plasma_metadata = plasma_object_buffer.metadata;\n+    GArrowBuffer *data;\n+    GArrowBuffer *metadata;\n \n Review comment:\n   Yes.\r\n   I forgot `return NULL` after `g_set_error()`.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-02T07:52:23.785+0000",
                    "updated": "2018-12-02T07:52:23.785+0000",
                    "started": "2018-12-02T07:52:23.783+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "171360",
                    "issueId": "13201499"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201499/worklog/171361",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on a change in pull request #3056: ARROW-3912: [Plasma][GLib] Add support for creating and referring objects\nURL: https://github.com/apache/arrow/pull/3056#discussion_r238088168\n \n \n\n ##########\n File path: c_glib/plasma-glib/object.cpp\n ##########\n @@ -0,0 +1,537 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#ifdef HAVE_CONFIG_H\n+#  include <config.h>\n+#endif\n+\n+#include <arrow-glib/error.hpp>\n+\n+#include <plasma-glib/client.hpp>\n+#include <plasma-glib/object.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: object\n+ * @section_id: object-classes\n+ * @title: Object related classes\n+ * @include: plasma-glib/plasma-glib.h\n+ *\n+ * #GPlasmaObjectID is a class for an object ID.\n+ *\n+ * #GPlasmaObject is a base class for an object stored in plasma store.\n+ *\n+ * #GPlasmaCreatedObject is a class for a created object. You can\n+ * change data of the object until the object is sealed or aborted.\n+ *\n+ * #GPlasmaReferredObject is a class for a created object. You can\n+ * only refer the data and metadata of the object. You can't change\n+ * the data of the object.\n+ *\n+ * Since: 0.12.0\n+ */\n+\n+typedef struct GPlasmaObjectIDPrivate_ {\n+  plasma::ObjectID id;\n+} GPlasmaObjectIDPrivate;\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GPlasmaObjectID,\n+                           gplasma_object_id,\n+                           G_TYPE_OBJECT)\n+\n+#define GPLASMA_OBJECT_ID_GET_PRIVATE(object)   \\\n+  static_cast<GPlasmaObjectIDPrivate *>(        \\\n+    gplasma_object_id_get_instance_private(     \\\n+      GPLASMA_OBJECT_ID(object)))\n+\n+static void\n+gplasma_object_id_init(GPlasmaObjectID *object)\n+{\n+}\n+\n+static void\n+gplasma_object_id_class_init(GPlasmaObjectIDClass *klass)\n+{\n+}\n+\n+/**\n+ * gplasma_object_id_new:\n+ * @id: (array length=size): The raw ID bytes.\n+ * @size: The number of bytes of the ID. It must be 1..20.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable): A newly created #GPlasmaObjectID on success,\n+ *   %NULL on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaObjectID *\n+gplasma_object_id_new(const guint8 *id,\n+                      gsize size,\n+                      GError **error)\n+{\n+  if (size == 0 || size > plasma::kUniqueIDSize) {\n+    g_set_error(error,\n+                GARROW_ERROR,\n+                GARROW_ERROR_INVALID,\n+                \"[plasma][object-id][new] \"\n+                \"ID must be 1..20 bytes: <%\" G_GSIZE_FORMAT \">\",\n+                size);\n+    return NULL;\n+  }\n+\n+  auto object_id = g_object_new(GPLASMA_TYPE_OBJECT_ID, NULL);\n+  auto priv = GPLASMA_OBJECT_ID_GET_PRIVATE(object_id);\n+  memcpy(priv->id.mutable_data(), id, size);\n+  if (size != plasma::kUniqueIDSize) {\n+    memset(priv->id.mutable_data() + size, 0, plasma::kUniqueIDSize - size);\n+  }\n+  return GPLASMA_OBJECT_ID(object_id);\n+}\n+\n+/**\n+ * gplasma_object_id_to_binary:\n+ * @id: A #GPlasmaObjectID.\n+ * @size: (nullable) (out): The number of bytes of the byte string of\n+ *   the object ID. It's always 20. 20 is `plasma::kUniqueIDSize`.\n+ *\n+ * Returns: (array length=size): The byte string of the object ID.\n+ *\n+ * Since: 0.12.0\n+ */\n+const guint8 *\n+gplasma_object_id_to_binary(GPlasmaObjectID *id,\n+                            gsize *size)\n+{\n+  auto priv = GPLASMA_OBJECT_ID_GET_PRIVATE(id);\n+  if (size) {\n+    *size = plasma::kUniqueIDSize;\n+  }\n+  return priv->id.data();\n+}\n+\n+/**\n+ * gplasma_object_id_to_hex:\n+ * @id: A #GPlasmaObjectID.\n+ *\n+ * Returns: The hex representation of the object ID.\n+ *\n+ *   It should be freed with g_free() when no longer needed.\n+ *\n+ * Since: 0.12.0\n+ */\n+gchar *\n+gplasma_object_id_to_hex(GPlasmaObjectID *id)\n+{\n+  auto priv = GPLASMA_OBJECT_ID_GET_PRIVATE(id);\n+  return g_strdup(priv->id.hex().c_str());\n+}\n+\n+typedef struct GPlasmaObjectPrivate_ {\n+  GPlasmaClient *client;\n+  GPlasmaObjectID *id;\n+  GArrowBuffer *data;\n+  GArrowBuffer *metadata;\n+  gint gpu_device;\n+} GPlasmaObjectPrivate;\n+\n+enum {\n+  PROP_CLIENT = 1,\n+  PROP_ID,\n+  PROP_DATA,\n+  PROP_METADATA,\n+  PROP_GPU_DEVICE\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GPlasmaObject,\n+                           gplasma_object,\n+                           G_TYPE_OBJECT)\n+\n+#define GPLASMA_OBJECT_GET_PRIVATE(object)      \\\n+  static_cast<GPlasmaObjectPrivate *>(          \\\n+    gplasma_object_get_instance_private(        \\\n+      GPLASMA_OBJECT(object)))\n+\n+static void\n+gplasma_object_dispose(GObject *object)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  // Properties except priv->id must be disposed in subclass.\n+\n+  if (priv->id) {\n+    g_object_unref(priv->id);\n+    priv->id = nullptr;\n+  }\n+\n+  G_OBJECT_CLASS(gplasma_object_parent_class)->dispose(object);\n+}\n+\n+static void\n+gplasma_object_set_property(GObject *object,\n+                            guint prop_id,\n+                            const GValue *value,\n+                            GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_CLIENT:\n+    priv->client = GPLASMA_CLIENT(g_value_dup_object(value));\n+    break;\n+  case PROP_ID:\n+    priv->id = GPLASMA_OBJECT_ID(g_value_dup_object(value));\n+    break;\n+  case PROP_DATA:\n+    priv->data = GARROW_BUFFER(g_value_dup_object(value));\n+    break;\n+  case PROP_METADATA:\n+    priv->metadata = GARROW_BUFFER(g_value_dup_object(value));\n+    break;\n+  case PROP_GPU_DEVICE:\n+    priv->gpu_device = g_value_get_int(value);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_object_get_property(GObject *object,\n+                            guint prop_id,\n+                            GValue *value,\n+                            GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_CLIENT:\n+    g_value_set_object(value, priv->client);\n+    break;\n+  case PROP_ID:\n+    g_value_set_object(value, priv->id);\n+    break;\n+  case PROP_DATA:\n+    g_value_set_object(value, priv->data);\n+    break;\n+  case PROP_METADATA:\n+    g_value_set_object(value, priv->metadata);\n+    break;\n+  case PROP_GPU_DEVICE:\n+    g_value_set_int(value, priv->gpu_device);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_object_init(GPlasmaObject *object)\n+{\n+}\n+\n+static void\n+gplasma_object_class_init(GPlasmaObjectClass *klass)\n+{\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->dispose      = gplasma_object_dispose;\n+  gobject_class->set_property = gplasma_object_set_property;\n+  gobject_class->get_property = gplasma_object_get_property;\n+\n+  GParamSpec *spec;\n+  spec = g_param_spec_object(\"client\",\n+                             \"Client\",\n+                             \"The client\",\n+                             GPLASMA_TYPE_CLIENT,\n+                             static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                      G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_CLIENT, spec);\n+\n+  spec = g_param_spec_object(\"id\",\n+                             \"ID\",\n+                             \"The ID of this object\",\n+                             GPLASMA_TYPE_OBJECT_ID,\n+                             static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                      G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_ID, spec);\n+\n+  spec = g_param_spec_object(\"data\",\n+                             \"Data\",\n+                             \"The data of this object\",\n+                             GARROW_TYPE_BUFFER,\n+                             static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                      G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_DATA, spec);\n+\n+  spec = g_param_spec_object(\"metadata\",\n+                             \"Metadata\",\n+                             \"The metadata of this object\",\n+                             GARROW_TYPE_BUFFER,\n+                             static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                      G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_METADATA, spec);\n+\n+  spec = g_param_spec_int(\"gpu-device\",\n+                          \"GPU device\",\n+                          \"The GPU device number. -1 means GPU isn't used.\",\n+                          -1,\n+                          G_MAXINT,\n+                          -1,\n+                          static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                   G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_GPU_DEVICE, spec);\n+}\n+\n+static bool\n+gplasma_object_check_not_released(GPlasmaObjectPrivate *priv,\n+                                  GError **error,\n+                                  const gchar *context)\n+{\n+  if (priv->client) {\n+    return true;\n+  }\n+\n+  auto id_priv = GPLASMA_OBJECT_ID_GET_PRIVATE(priv->id);\n+  auto id_hex = id_priv->id.hex();\n+  g_set_error(error,\n+              GARROW_ERROR,\n+              GARROW_ERROR_INVALID,\n+              \"%s: Can't process released object: <%s>\",\n+              context,\n+              id_hex.c_str());\n+  return false;\n+}\n+\n+static void\n+gplasma_object_release_resources(GPlasmaObjectPrivate *priv)\n+{\n+  if (priv->client) {\n+    g_object_unref(priv->client);\n+    priv->client = nullptr;\n+  }\n+\n+  if (priv->data) {\n+    g_object_unref(priv->data);\n+    priv->data = nullptr;\n+  }\n+\n+  if (priv->metadata) {\n+    g_object_unref(priv->metadata);\n+    priv->metadata = nullptr;\n+  }\n+}\n+\n+G_DEFINE_TYPE(GPlasmaCreatedObject,\n+              gplasma_created_object,\n+              GPLASMA_TYPE_OBJECT)\n+\n+static void\n+gplasma_created_object_dispose(GObject *object)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  if (priv->client) {\n+    gplasma_created_object_abort(GPLASMA_CREATED_OBJECT(object), NULL);\n+  }\n+\n+  G_OBJECT_CLASS(gplasma_created_object_parent_class)->dispose(object);\n+}\n+\n+static void\n+gplasma_created_object_init(GPlasmaCreatedObject *object)\n+{\n+}\n+\n+static void\n+gplasma_created_object_class_init(GPlasmaCreatedObjectClass *klass)\n+{\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->dispose = gplasma_created_object_dispose;\n+}\n+\n+/**\n+ * gplasma_created_object_seal:\n+ * @object: A #GPlasmaCreatedObject.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Seals the object in the object store. You can't use the sealed\n+ * object anymore.\n+ *\n+ * Returns: %TRUE on success, %FALSE on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+gboolean\n+gplasma_created_object_seal(GPlasmaCreatedObject *object,\n+                            GError **error)\n+{\n+  const auto context = \"[plasma][created-object][seal]\";\n+\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+  if (!gplasma_object_check_not_released(priv, error, context)) {\n+    return FALSE;\n+  }\n+\n+  auto plasma_client = gplasma_client_get_raw(priv->client);\n+  auto id_priv = GPLASMA_OBJECT_ID_GET_PRIVATE(priv->id);\n+  auto status = plasma_client->Seal(id_priv->id);\n+  auto success = garrow_error_check(error, status, context);\n+  if (success) {\n+    plasma_client->Release(id_priv->id);\n \n Review comment:\n   Yes.\r\n   I've added it.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-02T07:52:41.314+0000",
                    "updated": "2018-12-02T07:52:41.314+0000",
                    "started": "2018-12-02T07:52:41.314+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "171361",
                    "issueId": "13201499"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201499/worklog/171368",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "shiro615 commented on a change in pull request #3056: ARROW-3912: [Plasma][GLib] Add support for creating and referring objects\nURL: https://github.com/apache/arrow/pull/3056#discussion_r238092289\n \n \n\n ##########\n File path: c_glib/plasma-glib/client.cpp\n ##########\n @@ -21,47 +21,192 @@\n #  include <config.h>\n #endif\n \n+#include <arrow-glib/buffer.hpp>\n #include <arrow-glib/error.hpp>\n \n+#ifdef HAVE_ARROW_GPU\n+#  include <arrow-gpu-glib/cuda.hpp>\n+#endif\n+\n #include <plasma-glib/client.hpp>\n+#include <plasma-glib/object.hpp>\n \n G_BEGIN_DECLS\n \n /**\n  * SECTION: client\n- * @title: Client classes\n+ * @section_id: client-classes\n+ * @title: Client related classes\n  * @include: plasma-glib/plasma-glib.h\n  *\n+ * #GPlasmaClientCreateOptions is a class for customizing object creation.\n+ *\n  * #GPlasmaClient is a class for an interface with a plasma store\n  * and a plasma manager.\n  *\n  * Since: 0.12.0\n  */\n \n+typedef struct GPlasmaClientCreateOptionsPrivate_ {\n+  guint8 *metadata;\n+  gsize metadata_size;\n+  gint gpu_device;\n+} GPlasmaClientCreateOptionsPrivate;\n+\n+enum {\n+  PROP_GPU_DEVICE = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GPlasmaClientCreateOptions,\n+                           gplasma_client_create_options,\n+                           G_TYPE_OBJECT)\n+\n+#define GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(object)         \\\n+  static_cast<GPlasmaClientCreateOptionsPrivate *>(               \\\n+    gplasma_client_create_options_get_instance_private(           \\\n+      GPLASMA_CLIENT_CREATE_OPTIONS(object)))\n+\n+static void\n+gplasma_client_create_options_set_property(GObject *object,\n+                                           guint prop_id,\n+                                           const GValue *value,\n+                                           GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_GPU_DEVICE:\n+    priv->gpu_device = g_value_get_int(value);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_client_create_options_get_property(GObject *object,\n+                                           guint prop_id,\n+                                           GValue *value,\n+                                           GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_GPU_DEVICE:\n+    g_value_set_int(value, priv->gpu_device);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_client_create_options_init(GPlasmaClientCreateOptions *object)\n+{\n+}\n+\n+static void\n+gplasma_client_create_options_class_init(GPlasmaClientCreateOptionsClass *klass)\n+{\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->set_property = gplasma_client_create_options_set_property;\n+  gobject_class->get_property = gplasma_client_create_options_get_property;\n+\n+  GParamSpec *spec;\n+  spec = g_param_spec_int(\"gpu-device\",\n+                          \"GPU device\",\n+                          \"The GPU device number. -1 means GPU isn't used.\",\n+                          -1,\n+                          G_MAXINT,\n+                          -1,\n+                          static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                   G_PARAM_CONSTRUCT));\n+  g_object_class_install_property(gobject_class, PROP_GPU_DEVICE, spec);\n+}\n+\n+/**\n+ * gplasma_client_create_options_new:\n+ *\n+ * Returns: A newly created #GPlasmaClientCreateOptions.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaClientCreateOptions *\n+gplasma_client_create_options_new(void)\n+{\n+  auto options = g_object_new(GPLASMA_TYPE_CLIENT_CREATE_OPTIONS,\n+                              NULL);\n+  return GPLASMA_CLIENT_CREATE_OPTIONS(options);\n+}\n+\n+/**\n+ * gplasma_client_create_options_set_metadata:\n+ * @options: A #GPlasmaClientCreateOptions.\n+ * @metadata: (nullable) (array length=size): The metadata of a created object.\n+ * @size: The number of bytes of the metadata.\n+ *\n+ * Since: 0.12.0\n+ */\n+void\n+gplasma_client_create_options_set_metadata(GPlasmaClientCreateOptions *options,\n+                                           const guint8 *metadata,\n+                                           gsize size)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(options);\n+  if (priv->metadata) {\n+    g_free(priv->metadata);\n+  }\n+  priv->metadata = static_cast<guint8 *>(g_memdup(metadata, size));\n+  priv->metadata_size = size;\n+}\n+\n+/**\n+ * gplasma_client_create_options_get_metadata:\n+ * @options: A #GPlasmaClientCreateOptions.\n+ * @size: (nullable) (out): The number of bytes of the metadata.\n+ *\n+ * Returns: (nullable) (array length=size): The metadata of a created object.\n+ *\n+ * Since: 0.12.0\n+ */\n+const guint8 *\n+gplasma_client_create_options_get_metadata(GPlasmaClientCreateOptions *options,\n+                                           gsize *size)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(options);\n+  if (size) {\n+    *size = priv->metadata_size;\n+  }\n+  return priv->metadata;\n+}\n+\n typedef struct GPlasmaClientPrivate_ {\n-  std::shared_ptr<plasma::PlasmaClient> client;\n+  plasma::PlasmaClient *client;\n \n Review comment:\n   I see.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-02T10:09:05.755+0000",
                    "updated": "2018-12-02T10:09:05.755+0000",
                    "started": "2018-12-02T10:09:05.751+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "171368",
                    "issueId": "13201499"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201499/worklog/171370",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "shiro615 closed pull request #3056: ARROW-3912: [Plasma][GLib] Add support for creating and referring objects\nURL: https://github.com/apache/arrow/pull/3056\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/c_glib/arrow-gpu-glib/meson.build b/c_glib/arrow-gpu-glib/meson.build\nindex e6b170efc5..680982ef12 100644\n--- a/c_glib/arrow-gpu-glib/meson.build\n+++ b/c_glib/arrow-gpu-glib/meson.build\n@@ -57,19 +57,23 @@ pkgconfig.generate(filebase: 'arrow-gpu-glib',\n                    requires: ['arrow-glib', 'arrow-gpu'],\n                    libraries: [libarrow_gpu_glib])\n \n-gnome.generate_gir(libarrow_gpu_glib,\n-                   dependencies: declare_dependency(sources: arrow_glib_gir),\n-                   sources: sources + c_headers,\n-                   namespace: 'ArrowGPU',\n-                   nsversion: api_version,\n-                   identifier_prefix: 'GArrowGPU',\n-                   symbol_prefix: 'garrow_gpu',\n-                   export_packages: 'arrow-gpu-glib',\n-                   includes: [\n-                     'Arrow-1.0',\n-                   ],\n-                   install: true,\n-                   extra_args: [\n-                     '--warn-all',\n-                     '--include-uninstalled=./arrow-glib/Arrow-1.0.gir',\n-                   ])\n+gir_dependencies = [\n+  declare_dependency(sources: arrow_glib_gir),\n+]\n+gir_extra_args = [\n+  '--warn-all',\n+  '--include-uninstalled=./arrow-glib/Arrow-1.0.gir',\n+]\n+arrow_gpu_glib_gir = gnome.generate_gir(libarrow_gpu_glib,\n+                                        dependencies: gir_dependencies,\n+                                        sources: sources + c_headers,\n+                                        namespace: 'ArrowGPU',\n+                                        nsversion: api_version,\n+                                        identifier_prefix: 'GArrowGPU',\n+                                        symbol_prefix: 'garrow_gpu',\n+                                        export_packages: 'arrow-gpu-glib',\n+                                        includes: [\n+                                          'Arrow-1.0',\n+                                        ],\n+                                        install: true,\n+                                        extra_args: gir_extra_args)\ndiff --git a/c_glib/configure.ac b/c_glib/configure.ac\nindex badf9e98da..b84e3d3a7a 100644\n--- a/c_glib/configure.ac\n+++ b/c_glib/configure.ac\n@@ -223,8 +223,12 @@ fi\n \n AM_CONDITIONAL([HAVE_ARROW_GPU], [test \"$HAVE_ARROW_GPU\" = \"yes\"])\n if test \"$HAVE_ARROW_GPU\" = \"yes\"; then\n+  ARROW_GPU_GLIB_PACKAGE=\"arrow-gpu-glib\"\n   AC_DEFINE(HAVE_ARROW_GPU, [1], [Define to 1 if Apache Arrow supports GPU.])\n+else\n+  ARROW_GPU_GLIB_PACKAGE=\"\"\n fi\n+AC_SUBST(ARROW_GPU_GLIB_PACKAGE)\n \n AM_CONDITIONAL([HAVE_GANDIVA], [test \"$HAVE_GANDIVA\" = \"yes\"])\n if test \"$HAVE_GANDIVA\" = \"yes\"; then\ndiff --git a/c_glib/doc/plasma-glib/Makefile.am b/c_glib/doc/plasma-glib/Makefile.am\nindex 6a25bfb484..f4ef9e5ee8 100644\n--- a/c_glib/doc/plasma-glib/Makefile.am\n+++ b/c_glib/doc/plasma-glib/Makefile.am\n@@ -15,6 +15,12 @@\n # specific language governing permissions and limitations\n # under the License.\n \n+PLASMA_ARROW_GPU_GTKDOC_LIBS =\n+if HAVE_ARROW_GPU\n+PLASMA_ARROW_GPU_GTKDOC_LIBS +=\t\t\t\t\t\\\n+\t$(top_builddir)/arrow-gpu-glib/libarrow-gpu-glib.la\n+endif\n+\n if HAVE_PLASMA\n DOC_MODULE = plasma-glib\n \n@@ -50,6 +56,7 @@ AM_CFLAGS =\t\t\t\t\t\\\n \n GTKDOC_LIBS =\t\t\t\t\t\t\\\n \t$(top_builddir)/arrow-glib/libarrow-glib.la\t\\\n+\t$(PLASMA_ARROW_GPU_GTKDOC_LIBS)\t\t\t\\\n \t$(top_builddir)/plasma-glib/libplasma-glib.la\n \n include $(top_srcdir)/gtk-doc.make\ndiff --git a/c_glib/doc/plasma-glib/meson.build b/c_glib/doc/plasma-glib/meson.build\nindex 2572f0f371..95d7db8bbb 100644\n--- a/c_glib/doc/plasma-glib/meson.build\n+++ b/c_glib/doc/plasma-glib/meson.build\n@@ -56,6 +56,9 @@ dependencies = [\n   arrow_glib,\n   plasma_glib,\n ]\n+if arrow_gpu.found()\n+  dependencies += [arrow_gpu_glib]\n+endif\n ignore_headers = []\n gnome.gtkdoc(project_name,\n              main_xml: project_name + '-docs.xml',\ndiff --git a/c_glib/doc/plasma-glib/plasma-glib-docs.xml b/c_glib/doc/plasma-glib/plasma-glib-docs.xml\nindex 86e3245043..83d3aea9b0 100644\n--- a/c_glib/doc/plasma-glib/plasma-glib-docs.xml\n+++ b/c_glib/doc/plasma-glib/plasma-glib-docs.xml\n@@ -36,12 +36,16 @@\n     </releaseinfo>\n   </bookinfo>\n \n-  <part id=\"plasma-client\">\n-    <title>PlasmaClient</title>\n+  <part id=\"client-side\">\n+    <title>Client side</title>\n     <chapter id=\"client\">\n       <title>Client</title>\n       <xi:include href=\"xml/client.xml\"/>\n     </chapter>\n+    <chapter id=\"object\">\n+      <title>Object</title>\n+      <xi:include href=\"xml/object.xml\"/>\n+    </chapter>\n   </part>\n \n   <chapter id=\"object-tree\">\ndiff --git a/c_glib/plasma-glib/Makefile.am b/c_glib/plasma-glib/Makefile.am\nindex f797c97b09..2060472b01 100644\n--- a/c_glib/plasma-glib/Makefile.am\n+++ b/c_glib/plasma-glib/Makefile.am\n@@ -23,13 +23,42 @@ EXTRA_DIST =\t\t\t\t\t\\\n \n AM_CPPFLAGS =\t\t\t\t\t\\\n \t-I$(top_builddir)\t\t\t\\\n-\t-I$(top_srcdir)\n+\t-I$(top_srcdir)\t\t\t\t\\\n+\t-DG_LOG_DOMAIN=\\\"Plasma\\\"\n \n AM_CFLAGS =\t\t\t\t\t\\\n \t$(GLIB_CFLAGS)\t\t\t\t\\\n \t$(GARROW_CFLAGS)\t\t\t\\\n \t$(GPLASMA_CFLAGS)\n \n+PLASMA_ARROW_GPU_LIBS =\n+PLASMA_ARROW_GPU_GLIB_PKG_CONFIG_PATH =\n+PLASMA_INTROSPECTION_COMPILER_ARROW_GPU_ARGS =\n+PLASMA_GIR_ARROW_GPU_PACKAGE =\n+PLASMA_GIR_ARROW_GPU_SCANNER_ADD_INCLUDE_PATH =\n+PLASMA_GIR_ARROW_GPU_LIBS_MACOS =\n+PLASMA_GIR_ARROW_GPU_SCANNER_LIBRARY_PATH_MACOS =\n+PLASMA_GIR_ARROW_GPU_LIBS =\n+if HAVE_ARROW_GPU\n+PLASMA_ARROW_GPU_LIBS +=\t\t\t\\\n+\t$(ARROW_GPU_LIBS)\t\t\t\\\n+\t../arrow-gpu-glib/libarrow-gpu-glib.la\n+PLASMA_ARROW_GPU_GLIB_PKG_CONFIG_PATH +=\t\\\n+\t:${abs_top_builddir}/arrow-gpu-glib\n+PLASMA_INTROSPECTION_COMPILER_ARROW_GPU_ARGS +=\t\\\n+\t--includedir=$(abs_top_builddir)/arrow-gpu-glib\n+PLASMA_GIR_ARROW_GPU_PACKAGE +=\t\t\t\\\n+\tarrow-gpu-glib\n+PLASMA_GIR_ARROW_GPU_SCANNER_ADD_INCLUDE_PATH +=\t\t\\\n+\t--add-include-path=$(abs_top_builddir)/arrow-gpu-glib\n+PLASMA_GIR_ARROW_GPU_LIBS_MACOS +=\t\t\t\\\n+\tarrow-gpu-glib\n+PLASMA_GIR_ARROW_GPU_SCANNER_LIBRARY_PATH_MACOS +=\t\t\\\n+\t--library-path=$(abs_top_builddir)/arrow-gpu-glib/.libs\n+PLASMA_GIR_ARROW_GPU_LIBS +=\t\t\t\t\t\\\n+\t$(abs_top_builddir)/arrow-gpu-glib/libarrow-gpu-glib.la\n+endif\n+\n if HAVE_PLASMA\n lib_LTLIBRARIES =\t\t\t\t\\\n \tlibplasma-glib.la\n@@ -49,18 +78,22 @@ libplasma_glib_la_LIBADD =\t\t\t\\\n \t$(GLIB_LIBS)\t\t\t\t\\\n \t$(ARROW_LIBS)\t\t\t\t\\\n \t$(PLASMA_LIBS)\t\t\t\t\\\n-\t../arrow-glib/libarrow-glib.la\n+\t../arrow-glib/libarrow-glib.la\t\t\\\n+\t$(PLASMA_ARROW_GPU_LIBS)\n \n libplasma_glib_la_headers =\t\t\t\\\n \tclient.h\t\t\t\t\\\n+\tobject.h\t\t\t\t\\\n \tplasma-glib.h\n \n libplasma_glib_la_sources =\t\t\t\\\n \tclient.cpp\t\t\t\t\\\n+\tobject.cpp\t\t\t\t\\\n \t$(libplasma_glib_la_headers)\n \n-libplasma_glib_la_cpp_headers =\t\t\\\n+libplasma_glib_la_cpp_headers =\t\t\t\\\n \tclient.hpp\t\t\t\t\\\n+\tobject.hpp\t\t\t\t\\\n \tplasma-glib.hpp\n \n libplasma_glib_la_SOURCES =\t\t\t\\\n@@ -68,7 +101,7 @@ libplasma_glib_la_SOURCES =\t\t\t\\\n \t$(libplasma_glib_la_cpp_headers)\n \n plasma_glib_includedir = $(includedir)/plasma-glib\n-plasma_glib_include_HEADERS =\t\t\t\t\\\n+plasma_glib_include_HEADERS =\t\t\t\\\n \t$(libplasma_glib_la_headers)\t\t\\\n \t$(libplasma_glib_la_cpp_headers)\n \n@@ -84,17 +117,19 @@ INTROSPECTION_SCANNER_ARGS =\n INTROSPECTION_SCANNER_ENV =\n if USE_ARROW_BUILD_DIR\n INTROSPECTION_SCANNER_ENV +=\t\t\t\\\n-\tPKG_CONFIG_PATH=${abs_top_builddir}/arrow-glib:$(ARROW_BUILD_DIR)/src/arrow:$${PKG_CONFIG_PATH}\n+\tPKG_CONFIG_PATH=${abs_top_builddir}/arrow-glib$(PLASMA_ARROW_GPU_GLIB_PKG_CONFIG_PATH):$(ARROW_BUILD_DIR)/src/arrow:$${PKG_CONFIG_PATH}\n else\n INTROSPECTION_SCANNER_ENV +=\t\t\t\\\n-\tPKG_CONFIG_PATH=${abs_top_builddir}/arrow-glib:$${PKG_CONFIG_PATH}\n+\tPKG_CONFIG_PATH=${abs_top_builddir}/arrow-glib$(PLASMA_ARROW_GPU_GLIB_PKG_CONFIG_PATH):$${PKG_CONFIG_PATH}\n endif\n-INTROSPECTION_COMPILER_ARGS =\t\t\t\t\\\n-\t--includedir=$(abs_top_builddir)/arrow-glib\n+INTROSPECTION_COMPILER_ARGS =\t\t\t\t\t\\\n+\t--includedir=$(abs_top_builddir)/arrow-glib\t\t\\\n+\t$(PLASMA_INTROSPECTION_COMPILER_ARROW_GPU_INCLUDEDIR)\n \n Plasma-1.0.gir: libplasma-glib.la\n Plasma_1_0_gir_PACKAGES =\t\t\t\\\n-\tarrow-glib\n+\tarrow-glib\t\t\t\t\\\n+\t$(PLASMA_GIR_ARROW_GPU_PACKAGE)\n Plasma_1_0_gir_EXPORT_PACKAGES =\t\t\\\n \tplasma-glib\n Plasma_1_0_gir_INCLUDES =\t\t\t\\\n@@ -103,8 +138,9 @@ Plasma_1_0_gir_CFLAGS =\t\t\t\\\n \t$(AM_CPPFLAGS)\n Plasma_1_0_gir_LIBS =\n Plasma_1_0_gir_FILES = $(libplasma_glib_la_sources)\n-Plasma_1_0_gir_SCANNERFLAGS =\t\t\t\t\t\t\\\n+Plasma_1_0_gir_SCANNERFLAGS =\t\t\t\t\t\\\n \t--add-include-path=$(abs_top_builddir)/arrow-glib\t\\\n+\t$(PLASMA_GIR_ARROW_GPU_SCANNER_ADD_INCLUDE_PATH)\t\\\n \t--library-path=$(ARROW_LIB_DIR)\t\t\t\t\\\n \t--warn-all\t\t\t\t\t\t\\\n \t--identifier-prefix=GPlasma\t\t\t\t\\\n@@ -112,14 +148,17 @@ Plasma_1_0_gir_SCANNERFLAGS =\t\t\t\t\t\t\\\n if OS_MACOS\n Plasma_1_0_gir_LIBS +=\t\t\t\t\\\n \tarrow-glib\t\t\t\t\\\n+\t$(PLASMA_GIR_ARROW_GPU_LIBS_MACOS)\t\\\n \tplasma-glib\n Plasma_1_0_gir_SCANNERFLAGS +=\t\t\t\t\t\\\n \t--no-libtool\t\t\t\t\t\t\\\n \t--library-path=$(abs_top_builddir)/arrow-glib/.libs\t\\\n+\t$(PLASMA_GIR_ARROW_GPU_SCANNER_LIBRARY_PATH_MACOS)\t\\\n \t--library-path=$(abs_builddir)/.libs\n else\n Plasma_1_0_gir_LIBS +=\t\t\t\t\t\\\n \t$(abs_top_builddir)/arrow-glib/libarrow-glib.la\t\\\n+\t$(PLASMA_GIR_ARROW_GPU_LIBS)\t\t\t\\\n \tlibplasma-glib.la\n endif\n INTROSPECTION_GIRS += Plasma-1.0.gir\ndiff --git a/c_glib/plasma-glib/client.cpp b/c_glib/plasma-glib/client.cpp\nindex f818c971de..6a2629b38c 100644\n--- a/c_glib/plasma-glib/client.cpp\n+++ b/c_glib/plasma-glib/client.cpp\n@@ -21,47 +21,196 @@\n #  include <config.h>\n #endif\n \n+#include <arrow-glib/buffer.hpp>\n #include <arrow-glib/error.hpp>\n \n+#ifdef HAVE_ARROW_GPU\n+#  include <arrow-gpu-glib/cuda.hpp>\n+#endif\n+\n #include <plasma-glib/client.hpp>\n+#include <plasma-glib/object.hpp>\n \n G_BEGIN_DECLS\n \n /**\n  * SECTION: client\n- * @title: Client classes\n+ * @section_id: client-classes\n+ * @title: Client related classes\n  * @include: plasma-glib/plasma-glib.h\n  *\n+ * #GPlasmaClientCreateOptions is a class for customizing object creation.\n+ *\n  * #GPlasmaClient is a class for an interface with a plasma store\n  * and a plasma manager.\n  *\n  * Since: 0.12.0\n  */\n \n+typedef struct GPlasmaClientCreateOptionsPrivate_ {\n+  guint8 *metadata;\n+  gsize metadata_size;\n+  gint gpu_device;\n+} GPlasmaClientCreateOptionsPrivate;\n+\n+enum {\n+  PROP_GPU_DEVICE = 1\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GPlasmaClientCreateOptions,\n+                           gplasma_client_create_options,\n+                           G_TYPE_OBJECT)\n+\n+#define GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(object)         \\\n+  static_cast<GPlasmaClientCreateOptionsPrivate *>(               \\\n+    gplasma_client_create_options_get_instance_private(           \\\n+      GPLASMA_CLIENT_CREATE_OPTIONS(object)))\n+\n+static void\n+gplasma_client_create_options_set_property(GObject *object,\n+                                           guint prop_id,\n+                                           const GValue *value,\n+                                           GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_GPU_DEVICE:\n+    priv->gpu_device = g_value_get_int(value);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_client_create_options_get_property(GObject *object,\n+                                           guint prop_id,\n+                                           GValue *value,\n+                                           GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_GPU_DEVICE:\n+    g_value_set_int(value, priv->gpu_device);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_client_create_options_init(GPlasmaClientCreateOptions *object)\n+{\n+}\n+\n+static void\n+gplasma_client_create_options_class_init(GPlasmaClientCreateOptionsClass *klass)\n+{\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->set_property = gplasma_client_create_options_set_property;\n+  gobject_class->get_property = gplasma_client_create_options_get_property;\n+\n+  GParamSpec *spec;\n+  spec = g_param_spec_int(\"gpu-device\",\n+                          \"GPU device\",\n+                          \"The GPU device number. -1 means GPU isn't used.\",\n+                          -1,\n+                          G_MAXINT,\n+                          -1,\n+                          static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                   G_PARAM_CONSTRUCT));\n+  g_object_class_install_property(gobject_class, PROP_GPU_DEVICE, spec);\n+}\n+\n+/**\n+ * gplasma_client_create_options_new:\n+ *\n+ * Returns: A newly created #GPlasmaClientCreateOptions.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaClientCreateOptions *\n+gplasma_client_create_options_new(void)\n+{\n+  auto options = g_object_new(GPLASMA_TYPE_CLIENT_CREATE_OPTIONS,\n+                              NULL);\n+  return GPLASMA_CLIENT_CREATE_OPTIONS(options);\n+}\n+\n+/**\n+ * gplasma_client_create_options_set_metadata:\n+ * @options: A #GPlasmaClientCreateOptions.\n+ * @metadata: (nullable) (array length=size): The metadata of a created object.\n+ * @size: The number of bytes of the metadata.\n+ *\n+ * Since: 0.12.0\n+ */\n+void\n+gplasma_client_create_options_set_metadata(GPlasmaClientCreateOptions *options,\n+                                           const guint8 *metadata,\n+                                           gsize size)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(options);\n+  if (priv->metadata) {\n+    g_free(priv->metadata);\n+  }\n+  priv->metadata = static_cast<guint8 *>(g_memdup(metadata, size));\n+  priv->metadata_size = size;\n+}\n+\n+/**\n+ * gplasma_client_create_options_get_metadata:\n+ * @options: A #GPlasmaClientCreateOptions.\n+ * @size: (nullable) (out): The number of bytes of the metadata.\n+ *\n+ * Returns: (nullable) (array length=size): The metadata of a created object.\n+ *\n+ * Since: 0.12.0\n+ */\n+const guint8 *\n+gplasma_client_create_options_get_metadata(GPlasmaClientCreateOptions *options,\n+                                           gsize *size)\n+{\n+  auto priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(options);\n+  if (size) {\n+    *size = priv->metadata_size;\n+  }\n+  return priv->metadata;\n+}\n+\n typedef struct GPlasmaClientPrivate_ {\n-  std::shared_ptr<plasma::PlasmaClient> client;\n+  plasma::PlasmaClient *client;\n } GPlasmaClientPrivate;\n \n enum {\n-  PROP_0,\n-  PROP_CLIENT\n+  PROP_CLIENT = 1\n };\n \n G_DEFINE_TYPE_WITH_PRIVATE(GPlasmaClient,\n                            gplasma_client,\n                            G_TYPE_OBJECT)\n \n-#define GPLASMA_CLIENT_GET_PRIVATE(obj)         \\\n-  static_cast<GPlasmaClientPrivate *>(          \\\n-     gplasma_client_get_instance_private(       \\\n-       GPLASMA_CLIENT(obj)))\n+#define GPLASMA_CLIENT_GET_PRIVATE(object)         \\\n+  static_cast<GPlasmaClientPrivate *>(             \\\n+    gplasma_client_get_instance_private(           \\\n+      GPLASMA_CLIENT(object)))\n \n static void\n gplasma_client_finalize(GObject *object)\n {\n   auto priv = GPLASMA_CLIENT_GET_PRIVATE(object);\n \n-  priv->client = nullptr;\n+  auto status = priv->client->Disconnect();\n+  if (!status.ok()) {\n+    g_warning(\"[plasma][client][finalize] Failed to disconnect: %s\",\n+              status.ToString().c_str());\n+  }\n+  delete priv->client;\n \n   G_OBJECT_CLASS(gplasma_client_parent_class)->finalize(object);\n }\n@@ -77,7 +226,7 @@ gplasma_client_set_property(GObject *object,\n   switch (prop_id) {\n   case PROP_CLIENT:\n     priv->client =\n-      *static_cast<std::shared_ptr<plasma::PlasmaClient> *>(g_value_get_pointer(value));\n+      static_cast<plasma::PlasmaClient *>(g_value_get_pointer(value));\n     break;\n   default:\n     G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n@@ -102,7 +251,7 @@ gplasma_client_class_init(GPlasmaClientClass *klass)\n \n   spec = g_param_spec_pointer(\"client\",\n                               \"Client\",\n-                              \"The raw std::shared<plasma::PlasmaClient> *\",\n+                              \"The raw plasma::PlasmaClient *\",\n                               static_cast<GParamFlags>(G_PARAM_WRITABLE |\n                                                        G_PARAM_CONSTRUCT_ONLY));\n   g_object_class_install_property(gobject_class, PROP_CLIENT, spec);\n@@ -122,10 +271,161 @@ GPlasmaClient *\n gplasma_client_new(const gchar *store_socket_name,\n                    GError **error)\n {\n-  auto plasma_client = std::make_shared<plasma::PlasmaClient>();\n+  auto plasma_client = new plasma::PlasmaClient();\n   auto status = plasma_client->Connect(store_socket_name, \"\");\n   if (garrow_error_check(error, status, \"[plasma][client][new]\")) {\n-    return gplasma_client_new_raw(&plasma_client);\n+    return gplasma_client_new_raw(plasma_client);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+/**\n+ * gplasma_client_create:\n+ * @client: A #GPlasmaClient.\n+ * @id: The ID for a newly created object.\n+ * @data_size: The number of bytes of data for a newly created object.\n+ * @options: (nullable): The option for creating an object.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full): A newly created #GPlasmaCreatedObject\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaCreatedObject *\n+gplasma_client_create(GPlasmaClient *client,\n+                      GPlasmaObjectID *id,\n+                      gsize data_size,\n+                      GPlasmaClientCreateOptions *options,\n+                      GError **error)\n+{\n+  const auto context = \"[plasma][client][create]\";\n+  auto plasma_client = gplasma_client_get_raw(client);\n+  auto plasma_id = gplasma_object_id_get_raw(id);\n+  const uint8_t *raw_metadata = nullptr;\n+  int64_t raw_metadata_size = 0;\n+  int device_number = 0;\n+  if (options) {\n+    auto options_priv = GPLASMA_CLIENT_CREATE_OPTIONS_GET_PRIVATE(options);\n+    raw_metadata = options_priv->metadata;\n+    raw_metadata_size = options_priv->metadata_size;\n+    if (options_priv->gpu_device >= 0) {\n+#ifndef HAVE_ARROW_GPU\n+      g_set_error(error,\n+                  GARROW_ERROR,\n+                  GARROW_ERROR_INVALID,\n+                  \"%s Arrow GPU GLib is needed to use GPU\",\n+                  context);\n+      return NULL;\n+#endif\n+      device_number = options_priv->gpu_device + 1;\n+    }\n+  }\n+  std::shared_ptr<arrow::Buffer> plasma_data;\n+  auto status = plasma_client->Create(plasma_id,\n+                                      data_size,\n+                                      raw_metadata,\n+                                      raw_metadata_size,\n+                                      &plasma_data,\n+                                      device_number);\n+  if (garrow_error_check(error, status, context)) {\n+    GArrowBuffer *data = nullptr;\n+    if (device_number == 0) {\n+      auto plasma_mutable_data =\n+        std::static_pointer_cast<arrow::MutableBuffer>(plasma_data);\n+      data = GARROW_BUFFER(garrow_mutable_buffer_new_raw(&plasma_mutable_data));\n+#ifdef HAVE_ARROW_GPU\n+    } else {\n+      auto plasma_cuda_data =\n+        std::static_pointer_cast<arrow::gpu::CudaBuffer>(plasma_data);\n+      data = GARROW_BUFFER(garrow_gpu_cuda_buffer_new_raw(&plasma_cuda_data));\n+#endif\n+    }\n+    GArrowBuffer *metadata = nullptr;\n+    if (raw_metadata_size > 0) {\n+      auto plasma_metadata =\n+        std::make_shared<arrow::Buffer>(raw_metadata, raw_metadata_size);\n+      metadata = garrow_buffer_new_raw(&plasma_metadata);\n+    }\n+    return gplasma_created_object_new_raw(client,\n+                                          id,\n+                                          data,\n+                                          metadata,\n+                                          device_number - 1);\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n+/**\n+ * gplasma_client_refer_object:\n+ * @client: A #GPlasmaClient.\n+ * @id: The ID of the target object.\n+ * @timeout_ms: The timeout in milliseconds. -1 means no timeout.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable) (transfer full): A found #GPlasmaReferredObject\n+ *   on success, %NULL on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaReferredObject *\n+gplasma_client_refer_object(GPlasmaClient *client,\n+                            GPlasmaObjectID *id,\n+                            gint64 timeout_ms,\n+                            GError **error)\n+{\n+  const auto context = \"[plasma][client][refer-object]\";\n+  auto plasma_client = gplasma_client_get_raw(client);\n+  auto plasma_id = gplasma_object_id_get_raw(id);\n+  std::vector<plasma::ObjectID> plasma_ids;\n+  plasma_ids.push_back(plasma_id);\n+  std::vector<plasma::ObjectBuffer> plasma_object_buffers;\n+  auto status = plasma_client->Get(plasma_ids,\n+                                   timeout_ms,\n+                                   &plasma_object_buffers);\n+  if (garrow_error_check(error, status, context)) {\n+    auto plasma_object_buffer = plasma_object_buffers[0];\n+    auto plasma_data = plasma_object_buffer.data;\n+    auto plasma_metadata = plasma_object_buffer.metadata;\n+    GArrowBuffer *data = nullptr;\n+    GArrowBuffer *metadata = nullptr;\n+    if (plasma_object_buffer.device_num > 0) {\n+#ifdef HAVE_ARROW_GPU\n+      std::shared_ptr<arrow::gpu::CudaBuffer> plasma_cuda_data;\n+      status = arrow::gpu::CudaBuffer::FromBuffer(plasma_data,\n+                                                  &plasma_cuda_data);\n+      if (!garrow_error_check(error, status, context)) {\n+        return NULL;\n+      }\n+      std::shared_ptr<arrow::gpu::CudaBuffer> plasma_cuda_metadata;\n+      status = arrow::gpu::CudaBuffer::FromBuffer(plasma_metadata,\n+                                                  &plasma_cuda_metadata);\n+      if (!garrow_error_check(error, status, context)) {\n+        return NULL;\n+      }\n+\n+      data = GARROW_BUFFER(garrow_gpu_cuda_buffer_new_raw(&plasma_cuda_data));\n+      metadata =\n+        GARROW_BUFFER(garrow_gpu_cuda_buffer_new_raw(&plasma_cuda_metadata));\n+#else\n+      g_set_error(error,\n+                  GARROW_ERROR,\n+                  GARROW_ERROR_INVALID,\n+                  \"%s Arrow GPU GLib is needed to use GPU\",\n+                  context);\n+      return NULL;\n+#endif\n+    } else {\n+      data = garrow_buffer_new_raw(&plasma_data);\n+      metadata = garrow_buffer_new_raw(&plasma_metadata);\n+    }\n+    return gplasma_referred_object_new_raw(client,\n+                                           id,\n+                                           data,\n+                                           metadata,\n+                                           plasma_object_buffer.device_num - 1);\n   } else {\n     return NULL;\n   }\n@@ -134,7 +434,7 @@ gplasma_client_new(const gchar *store_socket_name,\n G_END_DECLS\n \n GPlasmaClient *\n-gplasma_client_new_raw(std::shared_ptr<plasma::PlasmaClient> *plasma_client)\n+gplasma_client_new_raw(plasma::PlasmaClient *plasma_client)\n {\n   auto client = g_object_new(GPLASMA_TYPE_CLIENT,\n                              \"client\", plasma_client,\n@@ -142,7 +442,7 @@ gplasma_client_new_raw(std::shared_ptr<plasma::PlasmaClient> *plasma_client)\n   return GPLASMA_CLIENT(client);\n }\n \n-std::shared_ptr<plasma::PlasmaClient>\n+plasma::PlasmaClient *\n gplasma_client_get_raw(GPlasmaClient *client)\n {\n   auto priv = GPLASMA_CLIENT_GET_PRIVATE(client);\ndiff --git a/c_glib/plasma-glib/client.h b/c_glib/plasma-glib/client.h\nindex 30c8a81aff..6f99f467c8 100644\n--- a/c_glib/plasma-glib/client.h\n+++ b/c_glib/plasma-glib/client.h\n@@ -19,10 +19,33 @@\n \n #pragma once\n \n-#include <arrow-glib/gobject-type.h>\n+#include <plasma-glib/object.h>\n \n G_BEGIN_DECLS\n \n+#define GPLASMA_TYPE_CLIENT_CREATE_OPTIONS      \\\n+  (gplasma_client_create_options_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GPlasmaClientCreateOptions,\n+                         gplasma_client_create_options,\n+                         GPLASMA,\n+                         CLIENT_CREATE_OPTIONS,\n+                         GObject)\n+\n+struct _GPlasmaClientCreateOptionsClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+GPlasmaClientCreateOptions *gplasma_client_create_options_new(void);\n+void\n+gplasma_client_create_options_set_metadata(GPlasmaClientCreateOptions *options,\n+                                           const guint8 *metadata,\n+                                           gsize size);\n+const guint8 *\n+gplasma_client_create_options_get_metadata(GPlasmaClientCreateOptions *options,\n+                                           gsize *size);\n+\n+\n #define GPLASMA_TYPE_CLIENT (gplasma_client_get_type())\n G_DECLARE_DERIVABLE_TYPE(GPlasmaClient,\n                          gplasma_client,\n@@ -37,5 +60,16 @@ struct _GPlasmaClientClass\n \n GPlasmaClient *gplasma_client_new(const gchar *store_socket_name,\n                                   GError **error);\n+GPlasmaCreatedObject *\n+gplasma_client_create(GPlasmaClient *client,\n+                      GPlasmaObjectID *id,\n+                      gsize data_size,\n+                      GPlasmaClientCreateOptions *options,\n+                      GError **error);\n+GPlasmaReferredObject *\n+gplasma_client_refer_object(GPlasmaClient *client,\n+                            GPlasmaObjectID *id,\n+                            gint64 timeout_ms,\n+                            GError **error);\n \n G_END_DECLS\ndiff --git a/c_glib/plasma-glib/client.hpp b/c_glib/plasma-glib/client.hpp\nindex 473ea16ae4..d3e2ab2598 100644\n--- a/c_glib/plasma-glib/client.hpp\n+++ b/c_glib/plasma-glib/client.hpp\n@@ -19,11 +19,11 @@\n \n #pragma once\n \n-#include <memory>\n-\n #include <plasma/client.h>\n \n #include <plasma-glib/client.h>\n \n-GPlasmaClient *gplasma_client_new_raw(std::shared_ptr<plasma::PlasmaClient> *plasma_client);\n-std::shared_ptr<plasma::PlasmaClient> gplasma_client_get_raw(GPlasmaClient *client);\n+GPlasmaClient *\n+gplasma_client_new_raw(plasma::PlasmaClient *plasma_client);\n+plasma::PlasmaClient *\n+gplasma_client_get_raw(GPlasmaClient *client);\ndiff --git a/c_glib/plasma-glib/meson.build b/c_glib/plasma-glib/meson.build\nindex 40a20e9c7d..60a6978658 100644\n--- a/c_glib/plasma-glib/meson.build\n+++ b/c_glib/plasma-glib/meson.build\n@@ -21,15 +21,18 @@ project_name = 'plasma-glib'\n \n sources = files(\n   'client.cpp',\n+  'object.cpp',\n )\n \n c_headers = files(\n   'client.h',\n+  'object.h',\n   'plasma-glib.h',\n )\n \n cpp_headers = files(\n   'client.hpp',\n+  'object.hpp',\n   'plasma-glib.hpp',\n )\n \n@@ -41,13 +44,39 @@ dependencies = [\n   plasma,\n   arrow_glib,\n ]\n+cpp_args = [\n+  '-DG_LOG_DOMAIN=\"Plasma\"',\n+]\n+pkg_config_requires = [\n+  'plasma',\n+  'arrow-glib',\n+]\n+gir_dependencies = [\n+  declare_dependency(sources: arrow_glib_gir),\n+]\n+gir_includes = [\n+  'Arrow-1.0',\n+]\n+gir_extra_args = [\n+  '--warn-all',\n+  '--include-uninstalled=./arrow-glib/Arrow-1.0.gir',\n+]\n+if arrow_gpu.found()\n+  dependencies += [arrow_gpu_glib]\n+  cpp_args += ['-DHAVE_ARROW_GPU']\n+  pkg_config_requires += ['arrow-gpu-glib']\n+  gir_dependencies += [declare_dependency(sources: arrow_gpu_glib_gir)]\n+  gir_includes += ['ArrowGPU-1.0']\n+  gir_extra_args += ['--include-uninstalled=./arrow-gpu-glib/ArrowGPU-1.0.gir']\n+endif\n libplasma_glib = library('plasma-glib',\n-                          sources: sources,\n-                          install: true,\n-                          dependencies: dependencies,\n-                          include_directories: base_include_directories,\n-                          soversion: so_version,\n-                          version: library_version)\n+                         sources: sources,\n+                         install: true,\n+                         dependencies: dependencies,\n+                         include_directories: base_include_directories,\n+                         cpp_args: cpp_args,\n+                         soversion: so_version,\n+                         version: library_version)\n plasma_glib = declare_dependency(link_with: libplasma_glib,\n                                  include_directories: base_include_directories,\n                                  dependencies: dependencies)\n@@ -56,22 +85,17 @@ pkgconfig.generate(filebase: project_name,\n                    name: 'Apache Arrow Plasma GLib',\n                    description: 'C API for Apache Arrow Plasma based on GLib',\n                    version: version,\n-                   requires: ['plasma', 'arrow-glib'],\n+                   requires: pkg_config_requires,\n                    libraries: [libplasma_glib])\n \n gnome.generate_gir(libplasma_glib,\n-                   dependencies: declare_dependency(sources: arrow_glib_gir),\n+                   dependencies: gir_dependencies,\n                    sources: sources + c_headers,\n                    namespace: 'Plasma',\n                    nsversion: api_version,\n                    identifier_prefix: 'GPlasma',\n                    symbol_prefix: 'gplasma',\n                    export_packages: 'plasma-glib',\n-                   includes: [\n-                     'Arrow-1.0',\n-                   ],\n+                   includes: gir_includes,\n                    install: true,\n-                   extra_args: [\n-                     '--warn-all',\n-                     '--include-uninstalled=./arrow-glib/Arrow-1.0.gir',\n-                   ])\n+                   extra_args: gir_extra_args)\ndiff --git a/c_glib/plasma-glib/object.cpp b/c_glib/plasma-glib/object.cpp\nnew file mode 100644\nindex 0000000000..63dc209c83\n--- /dev/null\n+++ b/c_glib/plasma-glib/object.cpp\n@@ -0,0 +1,538 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#ifdef HAVE_CONFIG_H\n+#  include <config.h>\n+#endif\n+\n+#include <arrow-glib/error.hpp>\n+\n+#include <plasma-glib/client.hpp>\n+#include <plasma-glib/object.hpp>\n+\n+G_BEGIN_DECLS\n+\n+/**\n+ * SECTION: object\n+ * @section_id: object-classes\n+ * @title: Object related classes\n+ * @include: plasma-glib/plasma-glib.h\n+ *\n+ * #GPlasmaObjectID is a class for an object ID.\n+ *\n+ * #GPlasmaObject is a base class for an object stored in plasma store.\n+ *\n+ * #GPlasmaCreatedObject is a class for a created object. You can\n+ * change data of the object until the object is sealed or aborted.\n+ *\n+ * #GPlasmaReferredObject is a class for a created object. You can\n+ * only refer the data and metadata of the object. You can't change\n+ * the data of the object.\n+ *\n+ * Since: 0.12.0\n+ */\n+\n+typedef struct GPlasmaObjectIDPrivate_ {\n+  plasma::ObjectID id;\n+} GPlasmaObjectIDPrivate;\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GPlasmaObjectID,\n+                           gplasma_object_id,\n+                           G_TYPE_OBJECT)\n+\n+#define GPLASMA_OBJECT_ID_GET_PRIVATE(object)   \\\n+  static_cast<GPlasmaObjectIDPrivate *>(        \\\n+    gplasma_object_id_get_instance_private(     \\\n+      GPLASMA_OBJECT_ID(object)))\n+\n+static void\n+gplasma_object_id_init(GPlasmaObjectID *object)\n+{\n+}\n+\n+static void\n+gplasma_object_id_class_init(GPlasmaObjectIDClass *klass)\n+{\n+}\n+\n+/**\n+ * gplasma_object_id_new:\n+ * @id: (array length=size): The raw ID bytes.\n+ * @size: The number of bytes of the ID. It must be 1..20.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Returns: (nullable): A newly created #GPlasmaObjectID on success,\n+ *   %NULL on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+GPlasmaObjectID *\n+gplasma_object_id_new(const guint8 *id,\n+                      gsize size,\n+                      GError **error)\n+{\n+  if (size == 0 || size > plasma::kUniqueIDSize) {\n+    g_set_error(error,\n+                GARROW_ERROR,\n+                GARROW_ERROR_INVALID,\n+                \"[plasma][object-id][new] \"\n+                \"ID must be 1..20 bytes: <%\" G_GSIZE_FORMAT \">\",\n+                size);\n+    return NULL;\n+  }\n+\n+  auto object_id = g_object_new(GPLASMA_TYPE_OBJECT_ID, NULL);\n+  auto priv = GPLASMA_OBJECT_ID_GET_PRIVATE(object_id);\n+  memcpy(priv->id.mutable_data(), id, size);\n+  if (size != plasma::kUniqueIDSize) {\n+    memset(priv->id.mutable_data() + size, 0, plasma::kUniqueIDSize - size);\n+  }\n+  return GPLASMA_OBJECT_ID(object_id);\n+}\n+\n+/**\n+ * gplasma_object_id_to_binary:\n+ * @id: A #GPlasmaObjectID.\n+ * @size: (nullable) (out): The number of bytes of the byte string of\n+ *   the object ID. It's always 20. 20 is `plasma::kUniqueIDSize`.\n+ *\n+ * Returns: (array length=size): The byte string of the object ID.\n+ *\n+ * Since: 0.12.0\n+ */\n+const guint8 *\n+gplasma_object_id_to_binary(GPlasmaObjectID *id,\n+                            gsize *size)\n+{\n+  auto priv = GPLASMA_OBJECT_ID_GET_PRIVATE(id);\n+  if (size) {\n+    *size = plasma::kUniqueIDSize;\n+  }\n+  return priv->id.data();\n+}\n+\n+/**\n+ * gplasma_object_id_to_hex:\n+ * @id: A #GPlasmaObjectID.\n+ *\n+ * Returns: The hex representation of the object ID.\n+ *\n+ *   It should be freed with g_free() when no longer needed.\n+ *\n+ * Since: 0.12.0\n+ */\n+gchar *\n+gplasma_object_id_to_hex(GPlasmaObjectID *id)\n+{\n+  auto priv = GPLASMA_OBJECT_ID_GET_PRIVATE(id);\n+  return g_strdup(priv->id.hex().c_str());\n+}\n+\n+typedef struct GPlasmaObjectPrivate_ {\n+  GPlasmaClient *client;\n+  GPlasmaObjectID *id;\n+  GArrowBuffer *data;\n+  GArrowBuffer *metadata;\n+  gint gpu_device;\n+} GPlasmaObjectPrivate;\n+\n+enum {\n+  PROP_CLIENT = 1,\n+  PROP_ID,\n+  PROP_DATA,\n+  PROP_METADATA,\n+  PROP_GPU_DEVICE\n+};\n+\n+G_DEFINE_TYPE_WITH_PRIVATE(GPlasmaObject,\n+                           gplasma_object,\n+                           G_TYPE_OBJECT)\n+\n+#define GPLASMA_OBJECT_GET_PRIVATE(object)      \\\n+  static_cast<GPlasmaObjectPrivate *>(          \\\n+    gplasma_object_get_instance_private(        \\\n+      GPLASMA_OBJECT(object)))\n+\n+static void\n+gplasma_object_dispose(GObject *object)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  // Properties except priv->id must be disposed in subclass.\n+\n+  if (priv->id) {\n+    g_object_unref(priv->id);\n+    priv->id = nullptr;\n+  }\n+\n+  G_OBJECT_CLASS(gplasma_object_parent_class)->dispose(object);\n+}\n+\n+static void\n+gplasma_object_set_property(GObject *object,\n+                            guint prop_id,\n+                            const GValue *value,\n+                            GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_CLIENT:\n+    priv->client = GPLASMA_CLIENT(g_value_dup_object(value));\n+    break;\n+  case PROP_ID:\n+    priv->id = GPLASMA_OBJECT_ID(g_value_dup_object(value));\n+    break;\n+  case PROP_DATA:\n+    priv->data = GARROW_BUFFER(g_value_dup_object(value));\n+    break;\n+  case PROP_METADATA:\n+    priv->metadata = GARROW_BUFFER(g_value_dup_object(value));\n+    break;\n+  case PROP_GPU_DEVICE:\n+    priv->gpu_device = g_value_get_int(value);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_object_get_property(GObject *object,\n+                            guint prop_id,\n+                            GValue *value,\n+                            GParamSpec *pspec)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  switch (prop_id) {\n+  case PROP_CLIENT:\n+    g_value_set_object(value, priv->client);\n+    break;\n+  case PROP_ID:\n+    g_value_set_object(value, priv->id);\n+    break;\n+  case PROP_DATA:\n+    g_value_set_object(value, priv->data);\n+    break;\n+  case PROP_METADATA:\n+    g_value_set_object(value, priv->metadata);\n+    break;\n+  case PROP_GPU_DEVICE:\n+    g_value_set_int(value, priv->gpu_device);\n+    break;\n+  default:\n+    G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);\n+    break;\n+  }\n+}\n+\n+static void\n+gplasma_object_init(GPlasmaObject *object)\n+{\n+}\n+\n+static void\n+gplasma_object_class_init(GPlasmaObjectClass *klass)\n+{\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->dispose      = gplasma_object_dispose;\n+  gobject_class->set_property = gplasma_object_set_property;\n+  gobject_class->get_property = gplasma_object_get_property;\n+\n+  GParamSpec *spec;\n+  spec = g_param_spec_object(\"client\",\n+                             \"Client\",\n+                             \"The client\",\n+                             GPLASMA_TYPE_CLIENT,\n+                             static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                      G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_CLIENT, spec);\n+\n+  spec = g_param_spec_object(\"id\",\n+                             \"ID\",\n+                             \"The ID of this object\",\n+                             GPLASMA_TYPE_OBJECT_ID,\n+                             static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                      G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_ID, spec);\n+\n+  spec = g_param_spec_object(\"data\",\n+                             \"Data\",\n+                             \"The data of this object\",\n+                             GARROW_TYPE_BUFFER,\n+                             static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                      G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_DATA, spec);\n+\n+  spec = g_param_spec_object(\"metadata\",\n+                             \"Metadata\",\n+                             \"The metadata of this object\",\n+                             GARROW_TYPE_BUFFER,\n+                             static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                      G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_METADATA, spec);\n+\n+  spec = g_param_spec_int(\"gpu-device\",\n+                          \"GPU device\",\n+                          \"The GPU device number. -1 means GPU isn't used.\",\n+                          -1,\n+                          G_MAXINT,\n+                          -1,\n+                          static_cast<GParamFlags>(G_PARAM_READWRITE |\n+                                                   G_PARAM_CONSTRUCT_ONLY));\n+  g_object_class_install_property(gobject_class, PROP_GPU_DEVICE, spec);\n+}\n+\n+static bool\n+gplasma_object_check_not_released(GPlasmaObjectPrivate *priv,\n+                                  GError **error,\n+                                  const gchar *context)\n+{\n+  if (priv->client) {\n+    return true;\n+  }\n+\n+  auto id_priv = GPLASMA_OBJECT_ID_GET_PRIVATE(priv->id);\n+  auto id_hex = id_priv->id.hex();\n+  g_set_error(error,\n+              GARROW_ERROR,\n+              GARROW_ERROR_INVALID,\n+              \"%s: Can't process released object: <%s>\",\n+              context,\n+              id_hex.c_str());\n+  return false;\n+}\n+\n+static void\n+gplasma_object_release_resources(GPlasmaObjectPrivate *priv)\n+{\n+  if (priv->client) {\n+    g_object_unref(priv->client);\n+    priv->client = nullptr;\n+  }\n+\n+  if (priv->data) {\n+    g_object_unref(priv->data);\n+    priv->data = nullptr;\n+  }\n+\n+  if (priv->metadata) {\n+    g_object_unref(priv->metadata);\n+    priv->metadata = nullptr;\n+  }\n+}\n+\n+G_DEFINE_TYPE(GPlasmaCreatedObject,\n+              gplasma_created_object,\n+              GPLASMA_TYPE_OBJECT)\n+\n+static void\n+gplasma_created_object_dispose(GObject *object)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  if (priv->client) {\n+    gplasma_created_object_abort(GPLASMA_CREATED_OBJECT(object), NULL);\n+  }\n+\n+  G_OBJECT_CLASS(gplasma_created_object_parent_class)->dispose(object);\n+}\n+\n+static void\n+gplasma_created_object_init(GPlasmaCreatedObject *object)\n+{\n+}\n+\n+static void\n+gplasma_created_object_class_init(GPlasmaCreatedObjectClass *klass)\n+{\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->dispose = gplasma_created_object_dispose;\n+}\n+\n+/**\n+ * gplasma_created_object_seal:\n+ * @object: A #GPlasmaCreatedObject.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Seals the object in the object store. You can't use the sealed\n+ * object anymore.\n+ *\n+ * Returns: %TRUE on success, %FALSE on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+gboolean\n+gplasma_created_object_seal(GPlasmaCreatedObject *object,\n+                            GError **error)\n+{\n+  const auto context = \"[plasma][created-object][seal]\";\n+\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+  if (!gplasma_object_check_not_released(priv, error, context)) {\n+    return FALSE;\n+  }\n+\n+  auto plasma_client = gplasma_client_get_raw(priv->client);\n+  auto id_priv = GPLASMA_OBJECT_ID_GET_PRIVATE(priv->id);\n+  auto status = plasma_client->Seal(id_priv->id);\n+  auto success = garrow_error_check(error, status, context);\n+  if (success) {\n+    status = plasma_client->Release(id_priv->id);\n+    success = garrow_error_check(error, status, context);\n+    gplasma_object_release_resources(priv);\n+  }\n+  return success;\n+}\n+\n+/**\n+ * gplasma_created_object_abort:\n+ * @object: A #GPlasmaCreatedObject.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Aborts the object in the object store. You can't use the aborted\n+ * object anymore.\n+ *\n+ * Returns: %TRUE on success, %FALSE on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+gboolean\n+gplasma_created_object_abort(GPlasmaCreatedObject *object,\n+                             GError **error)\n+{\n+  const auto context = \"[plasma][created-object][abort]\";\n+\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+  if (!gplasma_object_check_not_released(priv, error, context)) {\n+    return FALSE;\n+  }\n+\n+  auto plasma_client = gplasma_client_get_raw(priv->client);\n+  auto id_priv = GPLASMA_OBJECT_ID_GET_PRIVATE(priv->id);\n+  auto status = plasma_client->Release(id_priv->id);\n+  auto success = garrow_error_check(error, status, context);\n+  if (success) {\n+    status = plasma_client->Abort(id_priv->id);\n+    success = garrow_error_check(error, status, context);\n+    gplasma_object_release_resources(priv);\n+  }\n+  return success;\n+}\n+\n+\n+G_DEFINE_TYPE(GPlasmaReferredObject,\n+              gplasma_referred_object,\n+              GPLASMA_TYPE_OBJECT)\n+\n+static void\n+gplasma_referred_object_dispose(GObject *object)\n+{\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+\n+  gplasma_object_release_resources(priv);\n+\n+  G_OBJECT_CLASS(gplasma_referred_object_parent_class)->dispose(object);\n+}\n+\n+static void\n+gplasma_referred_object_init(GPlasmaReferredObject *object)\n+{\n+}\n+\n+static void\n+gplasma_referred_object_class_init(GPlasmaReferredObjectClass *klass)\n+{\n+  auto gobject_class = G_OBJECT_CLASS(klass);\n+\n+  gobject_class->dispose = gplasma_referred_object_dispose;\n+}\n+\n+/**\n+ * gplasma_referred_object_release:\n+ * @object: A #GPlasmaReferredObject.\n+ * @error: (nullable): Return location for a #GError or %NULL.\n+ *\n+ * Releases the object explicitly. The object is no longer valid.\n+ *\n+ * Returns: %TRUE on success, %FALSE on error.\n+ *\n+ * Since: 0.12.0\n+ */\n+gboolean\n+gplasma_referred_object_release(GPlasmaReferredObject *object,\n+                                GError **error)\n+{\n+  const auto context = \"[plasma][referred-object][release]\";\n+\n+  auto priv = GPLASMA_OBJECT_GET_PRIVATE(object);\n+  if (!gplasma_object_check_not_released(priv, error, context)) {\n+    return FALSE;\n+  }\n+\n+  gplasma_object_release_resources(priv);\n+  return TRUE;\n+}\n+\n+G_END_DECLS\n+\n+plasma::ObjectID\n+gplasma_object_id_get_raw(GPlasmaObjectID *id)\n+{\n+  auto priv = GPLASMA_OBJECT_ID_GET_PRIVATE(id);\n+  return priv->id;\n+}\n+\n+GPlasmaCreatedObject *\n+gplasma_created_object_new_raw(GPlasmaClient *client,\n+                               GPlasmaObjectID *id,\n+                               GArrowBuffer *data,\n+                               GArrowBuffer *metadata,\n+                               gint gpu_device)\n+{\n+  auto object = g_object_new(GPLASMA_TYPE_CREATED_OBJECT,\n+                             \"client\", client,\n+                             \"id\", id,\n+                             \"data\", data,\n+                             \"metadata\", metadata,\n+                             \"gpu-device\", gpu_device,\n+                             NULL);\n+  return GPLASMA_CREATED_OBJECT(object);\n+}\n+\n+GPlasmaReferredObject *\n+gplasma_referred_object_new_raw(GPlasmaClient *client,\n+                                GPlasmaObjectID *id,\n+                                GArrowBuffer *data,\n+                                GArrowBuffer *metadata,\n+                                gint gpu_device)\n+{\n+  auto object = g_object_new(GPLASMA_TYPE_REFERRED_OBJECT,\n+                             \"client\", client,\n+                             \"id\", id,\n+                             \"data\", data,\n+                             \"metadata\", metadata,\n+                             \"gpu-device\", gpu_device,\n+                             NULL);\n+  return GPLASMA_REFERRED_OBJECT(object);\n+}\ndiff --git a/c_glib/plasma-glib/object.h b/c_glib/plasma-glib/object.h\nnew file mode 100644\nindex 0000000000..46547d37b4\n--- /dev/null\n+++ b/c_glib/plasma-glib/object.h\n@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#pragma once\n+\n+#include <arrow-glib/buffer.h>\n+\n+G_BEGIN_DECLS\n+\n+#define GPLASMA_TYPE_OBJECT_ID (gplasma_object_id_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GPlasmaObjectID,\n+                         gplasma_object_id,\n+                         GPLASMA,\n+                         OBJECT_ID,\n+                         GObject)\n+\n+struct _GPlasmaObjectIDClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+GPlasmaObjectID *gplasma_object_id_new(const guint8 *id,\n+                                       gsize size,\n+                                       GError **error);\n+const guint8 *gplasma_object_id_to_binary(GPlasmaObjectID *id,\n+                                          gsize *size);\n+gchar *gplasma_object_id_to_hex(GPlasmaObjectID *id);\n+\n+#define GPLASMA_TYPE_OBJECT (gplasma_object_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GPlasmaObject,\n+                         gplasma_object,\n+                         GPLASMA,\n+                         OBJECT,\n+                         GObject)\n+\n+struct _GPlasmaObjectClass\n+{\n+  GObjectClass parent_class;\n+};\n+\n+#define GPLASMA_TYPE_CREATED_OBJECT (gplasma_created_object_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GPlasmaCreatedObject,\n+                         gplasma_created_object,\n+                         GPLASMA,\n+                         CREATED_OBJECT,\n+                         GPlasmaObject)\n+\n+struct _GPlasmaCreatedObjectClass\n+{\n+  GPlasmaObjectClass parent_class;\n+};\n+\n+gboolean gplasma_created_object_seal(GPlasmaCreatedObject *object,\n+                                     GError **error);\n+gboolean gplasma_created_object_abort(GPlasmaCreatedObject *object,\n+                                      GError **error);\n+\n+#define GPLASMA_TYPE_REFERRED_OBJECT (gplasma_referred_object_get_type())\n+G_DECLARE_DERIVABLE_TYPE(GPlasmaReferredObject,\n+                         gplasma_referred_object,\n+                         GPLASMA,\n+                         REFERRED_OBJECT,\n+                         GPlasmaObject)\n+\n+struct _GPlasmaReferredObjectClass\n+{\n+  GPlasmaObjectClass parent_class;\n+};\n+\n+gboolean gplasma_referred_object_release(GPlasmaReferredObject *object,\n+                                         GError **error);\n+\n+G_END_DECLS\ndiff --git a/c_glib/plasma-glib/object.hpp b/c_glib/plasma-glib/object.hpp\nnew file mode 100644\nindex 0000000000..9d598b2ed6\n--- /dev/null\n+++ b/c_glib/plasma-glib/object.hpp\n@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+#pragma once\n+\n+#include <plasma/client.h>\n+\n+#include <plasma-glib/client.h>\n+\n+#include <plasma-glib/object.hpp>\n+\n+plasma::ObjectID\n+gplasma_object_id_get_raw(GPlasmaObjectID *id);\n+\n+GPlasmaCreatedObject *\n+gplasma_created_object_new_raw(GPlasmaClient *client,\n+                               GPlasmaObjectID *id,\n+                               GArrowBuffer *data,\n+                               GArrowBuffer *metadata,\n+                               gint gpu_device);\n+\n+GPlasmaReferredObject *\n+gplasma_referred_object_new_raw(GPlasmaClient *client,\n+                                GPlasmaObjectID *id,\n+                                GArrowBuffer *data,\n+                                GArrowBuffer *metadata,\n+                                gint gpu_device);\ndiff --git a/c_glib/plasma-glib/plasma-glib.h b/c_glib/plasma-glib/plasma-glib.h\nindex 33eed2cc6f..2a6dd76ca3 100644\n--- a/c_glib/plasma-glib/plasma-glib.h\n+++ b/c_glib/plasma-glib/plasma-glib.h\n@@ -20,3 +20,4 @@\n #pragma once\n \n #include <plasma-glib/client.h>\n+#include <plasma-glib/object.h>\ndiff --git a/c_glib/plasma-glib/plasma-glib.hpp b/c_glib/plasma-glib/plasma-glib.hpp\nindex b0af4899ea..b2958c28f8 100644\n--- a/c_glib/plasma-glib/plasma-glib.hpp\n+++ b/c_glib/plasma-glib/plasma-glib.hpp\n@@ -22,3 +22,4 @@\n #include <plasma-glib/plasma-glib.h>\n \n #include <plasma-glib/client.hpp>\n+#include <plasma-glib/object.hpp>\ndiff --git a/c_glib/plasma-glib/plasma-glib.pc.in b/c_glib/plasma-glib/plasma-glib.pc.in\nindex 21f202c9b0..f3a82c237d 100644\n--- a/c_glib/plasma-glib/plasma-glib.pc.in\n+++ b/c_glib/plasma-glib/plasma-glib.pc.in\n@@ -25,4 +25,4 @@ Description: C API for Apache Arrow Plasma based on GLib\n Version: @VERSION@\n Libs: -L${libdir} -lplasma-glib\n Cflags: -I${includedir}\n-Requires: plasma arrow-glib\n+Requires: plasma arrow-glib @ARROW_GPU_GLIB_PACKAGE@\ndiff --git a/c_glib/test/plasma/test-plasma-client.rb b/c_glib/test/plasma/test-plasma-client.rb\nindex aee2d037b3..4bf9fa9b6d 100644\n--- a/c_glib/test/plasma/test-plasma-client.rb\n+++ b/c_glib/test/plasma/test-plasma-client.rb\n@@ -16,20 +16,72 @@\n # under the License.\n \n class TestPlasmaClient < Test::Unit::TestCase\n+  include Helper::Omittable\n+\n   def setup\n     @store = nil\n     omit(\"Plasma is required\") unless defined?(::Plasma)\n     @store = Helper::PlasmaStore.new\n     @store.start\n+    @client = Plasma::Client.new(@store.socket_path)\n   end\n \n   def teardown\n     @store.stop if @store\n   end\n \n-  def test_new\n-    assert_nothing_raised do\n-      Plasma::Client.new(@store.socket_path)\n+  sub_test_case(\"#create\") do\n+    def setup\n+      super\n+\n+      @id = Plasma::ObjectID.new(\"Hello\")\n+      @data = \"World\"\n+      @metadata = \"Metadata\"\n+      @options = Plasma::ClientCreateOptions.new\n+    end\n+\n+    test(\"no options\") do\n+      require_gi(1, 42, 0)\n+\n+      object = @client.create(@id, @data.bytesize)\n+      object.data.set_data(0, @data)\n+      object.seal\n+\n+      object = @client.refer_object(@id, -1)\n+      assert_equal(@data, object.data.data.to_s)\n+    end\n+\n+    test(\"options: metadata\") do\n+      @options.set_metadata(@metadata)\n+      object = @client.create(@id, 1, @options)\n+      object.seal\n+\n+      object = @client.refer_object(@id, -1)\n+      assert_equal(@metadata, object.metadata.data.to_s)\n+    end\n+\n+    test(\"options: GPU device\") do\n+      omit(\"Arrow GPU is required\") unless defined?(::ArrowGPU)\n+\n+      gpu_device = 0\n+\n+      @options.gpu_device = gpu_device\n+      @options.metadata = @metadata\n+      object = @client.create(@id, @data.bytesize, @options)\n+      object.data.copy_from_host(@data)\n+      object.seal\n+\n+      object = @client.refer_object(@id, -1)\n+      assert_equal([\n+                     gpu_device,\n+                     @data,\n+                     @metadata,\n+                   ],\n+                   [\n+                     object.gpu_device,\n+                     object.data.copy_to_host(0, @data.bytesize).to_s,\n+                     object.metadata.copy_to_host(0, @metadata.bytesize).to_s,\n+                   ])\n     end\n   end\n end\ndiff --git a/c_glib/test/plasma/test-plasma-created-object.rb b/c_glib/test/plasma/test-plasma-created-object.rb\nnew file mode 100644\nindex 0000000000..54d6774790\n--- /dev/null\n+++ b/c_glib/test/plasma/test-plasma-created-object.rb\n@@ -0,0 +1,56 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+class TestPlasmaCreatedObject < Test::Unit::TestCase\n+  def setup\n+    @store = nil\n+    omit(\"Plasma is required\") unless defined?(::Plasma)\n+    @store = Helper::PlasmaStore.new\n+    @store.start\n+    @client = Plasma::Client.new(@store.socket_path)\n+\n+    @id = Plasma::ObjectID.new(\"Hello\")\n+    @data = \"World\"\n+    @metadata = \"Metadata\"\n+    @options = Plasma::ClientCreateOptions.new\n+    @options.metadata = @metadata\n+    @object = @client.create(@id, @data.bytesize, @options)\n+  end\n+\n+  def teardown\n+    @store.stop if @store\n+  end\n+\n+  test(\"#seal\") do\n+    @object.data.set_data(0, @data)\n+    @object.seal\n+\n+    object = @client.refer_object(@id, -1)\n+    assert_equal(@data, object.data.data.to_s)\n+  end\n+\n+  test(\"#abort\") do\n+    @object.data.set_data(0, @data)\n+    assert_raise(Arrow::Error::PlasmaObjectExists) do\n+      @client.create(@id, @data.bytesize, @options)\n+    end\n+    @object.abort\n+\n+    object = @client.create(@id, @data.bytesize, @options)\n+    object.abort\n+  end\n+end\ndiff --git a/c_glib/test/plasma/test-plasma-referred-object.rb b/c_glib/test/plasma/test-plasma-referred-object.rb\nnew file mode 100644\nindex 0000000000..f55c0b13c5\n--- /dev/null\n+++ b/c_glib/test/plasma/test-plasma-referred-object.rb\n@@ -0,0 +1,51 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+class TestPlasmaReferredObject < Test::Unit::TestCase\n+  def setup\n+    @store = nil\n+    omit(\"Plasma is required\") unless defined?(::Plasma)\n+    @store = Helper::PlasmaStore.new\n+    @store.start\n+    @client = Plasma::Client.new(@store.socket_path)\n+\n+    @id = Plasma::ObjectID.new(\"Hello\")\n+    @data = \"World\"\n+    @metadata = \"Metadata\"\n+    @options = Plasma::ClientCreateOptions.new\n+    @options.metadata = @metadata\n+    object = @client.create(@id, @data.bytesize, @options)\n+    object.data.set_data(0, @data)\n+    object.seal\n+    @object = @client.refer_object(@id, -1)\n+  end\n+\n+  def teardown\n+    @store.stop if @store\n+  end\n+\n+  test(\"#release\") do\n+    @object.release\n+\n+    message = \"[plasma][referred-object][release]: \"\n+    message << \"Can't process released object: <#{@id.to_hex}>\"\n+    error = Arrow::Error::Invalid.new(message)\n+    assert_raise(error) do\n+      @object.release\n+    end\n+  end\n+end\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-12-02T10:39:45.355+0000",
                    "updated": "2018-12-02T10:39:45.355+0000",
                    "started": "2018-12-02T10:39:45.354+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "171370",
                    "issueId": "13201499"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 4800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@34356502[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1056625f[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6ff4ceb4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4c930d8f[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3bf2c061[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7e072712[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@37cfc708[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@63644b0b[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4eb87ece[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@9c0ffbc[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@407e8e0b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@103a91c[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 4800,
        "customfield_12312520": null,
        "customfield_12312521": "Sun Dec 02 10:39:44 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-12-02T10:39:44.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3912/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2018-11-30T02:39:47.000+0000",
        "updated": "2018-12-02T10:39:45.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 4800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Plasma][GLib] Add support for creating and referring objects",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13201499/comment/16706172",
                    "id": "16706172",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=shiro615",
                        "name": "shiro615",
                        "key": "shiro615",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34043",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34043",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34043",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34043"
                        },
                        "displayName": "Yosuke Shiro",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 3056\n[https://github.com/apache/arrow/pull/3056]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=shiro615",
                        "name": "shiro615",
                        "key": "shiro615",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34043",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34043",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34043",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34043"
                        },
                        "displayName": "Yosuke Shiro",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-12-02T10:39:44.865+0000",
                    "updated": "2018-12-02T10:39:44.865+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|s010s0:",
        "customfield_12314139": null
    }
}