{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13406821",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821",
    "key": "ARROW-14347",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350591",
                "id": "12350591",
                "description": "",
                "name": "7.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-02-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12624648",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12624648",
                "type": {
                    "id": "12310460",
                    "name": "Child-Issue",
                    "inward": "is a child of",
                    "outward": "is a parent of",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310460"
                },
                "inwardIssue": {
                    "id": "13087660",
                    "key": "ARROW-1231",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13087660",
                    "fields": {
                        "summary": "[C++] Add filesystem / IO implementation for Google Cloud Storage",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=coryan",
            "name": "coryan",
            "key": "coryan",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Carlos O'Ryan",
            "active": true,
            "timeZone": "America/New_York"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=coryan",
            "name": "coryan",
            "key": "coryan",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Carlos O'Ryan",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=coryan",
            "name": "coryan",
            "key": "coryan",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Carlos O'Ryan",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 8400,
            "total": 8400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 8400,
            "total": 8400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-14347/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 14,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688134",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#issuecomment-982791321\n\n\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-30T16:17:42.344+0000",
                    "updated": "2021-11-30T16:17:42.344+0000",
                    "started": "2021-11-30T16:17:42.344+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688134",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688162",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#issuecomment-982840476\n\n\n   The `C++ / AMD64 Conda C++` failure seems unrelated.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-11-30T17:10:08.580+0000",
                    "updated": "2021-11-30T17:10:08.580+0000",
                    "started": "2021-11-30T17:10:08.580+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688162",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688646",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#discussion_r760170770\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -172,6 +174,79 @@ class GcsOutputStream : public arrow::io::OutputStream {\n   int64_t tell_ = 0;\n };\n \n+using InputStreamFactory = std::function<Result<std::shared_ptr<io::InputStream>>(\n+    const std::string&, const std::string&, gcs::Generation, gcs::ReadFromOffset)>;\n+\n+class GcsRandomAccessFile : public arrow::io::RandomAccessFile {\n+ public:\n+  GcsRandomAccessFile(InputStreamFactory factory, gcs::ObjectMetadata metadata,\n+                      std::shared_ptr<io::InputStream> stream)\n+      : factory_(std::move(factory)),\n+        metadata_(std::move(metadata)),\n+        stream_(std::move(stream)) {}\n+  ~GcsRandomAccessFile() override = default;\n+\n+  //@{\n+  // @name FileInterface\n+  Status Close() override { return stream_->Close(); }\n+  Status Abort() override { return stream_->Abort(); }\n+  Result<int64_t> Tell() const override { return stream_->Tell(); }\n+  bool closed() const override { return stream_->closed(); }\n+  //@}\n+\n+  //@{\n+  // @name Readable\n+  Result<int64_t> Read(int64_t nbytes, void* out) override {\n+    return stream_->Read(nbytes, out);\n+  }\n+  Result<std::shared_ptr<Buffer>> Read(int64_t nbytes) override {\n+    return stream_->Read(nbytes);\n+  }\n+  const arrow::io::IOContext& io_context() const override {\n+    return stream_->io_context();\n+  }\n+  //@}\n+\n+  //@{\n+  // @name InputStream\n+  Result<std::shared_ptr<const KeyValueMetadata>> ReadMetadata() override {\n+    return internal::FromObjectMetadata(metadata_);\n+  }\n+  //@}\n+\n+  //@{\n+  // @name RandomAccessFile\n+  Result<int64_t> GetSize() override { return metadata_.size(); }\n+  Result<int64_t> ReadAt(int64_t position, int64_t nbytes, void* out) override {\n+    std::shared_ptr<io::InputStream> stream;\n+    ARROW_ASSIGN_OR_RAISE(stream, factory_(metadata_.bucket(), metadata_.name(),\n+                                           gcs::Generation(metadata_.generation()),\n+                                           gcs::ReadFromOffset(position)));\n\nReview comment:\n       Interesting. It seems a bit convoluted, but I guess the GCS C++ API is forcing us to do this.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs_test.cc\n##########\n@@ -521,6 +540,130 @@ TEST_F(GcsIntegrationTest, WriteObjectLarge) {\n   EXPECT_EQ(contents, buffers[0] + buffers[1] + buffers[2]);\n }\n \n+TEST_F(GcsIntegrationTest, OpenInputFileMixedReadVsReadAt) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  // Create a file large enough to make the random access tests non-trivial.\n+  auto constexpr kLineWidth = 100;\n+  auto constexpr kLineCount = 4096;\n+  std::vector<std::string> lines(kLineCount);\n+  int lineno = 0;\n+  std::generate_n(lines.begin(), lines.size(),\n+                  [&] { return RandomLine(++lineno, kLineWidth); });\n+\n+  const auto path =\n+      kPreexistingBucket + std::string(\"/OpenInputFileMixedReadVsReadAt/object-name\");\n+  std::shared_ptr<io::OutputStream> output;\n+  ASSERT_OK_AND_ASSIGN(output, fs->OpenOutputStream(path, {}));\n+  for (auto const& line : lines) {\n+    ASSERT_OK(output->Write(line.data(), line.size()));\n+  }\n+  ASSERT_OK(output->Close());\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(path));\n+  for (int i = 0; i != 32; ++i) {\n+    SCOPED_TRACE(\"Iteration \" + std::to_string(i));\n+    // Verify sequential reads work as expected.\n+    std::array<char, kLineWidth> buffer{};\n+    std::int64_t size;\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto actual, file->Read(kLineWidth));\n+      EXPECT_EQ(lines[2 * i], actual->ToString());\n+    }\n+    {\n+      ASSERT_OK_AND_ASSIGN(size, file->Read(buffer.size(), buffer.data()));\n+      EXPECT_EQ(size, kLineWidth);\n+      auto actual = std::string{buffer.begin(), buffer.end()};\n+      EXPECT_EQ(lines[2 * i + 1], actual);\n+    }\n+\n+    // Verify random reads interleave too.\n+    auto const index = RandomIndex(kLineCount);\n+    auto const position = index * kLineWidth;\n+    ASSERT_OK_AND_ASSIGN(size, file->ReadAt(position, buffer.size(), buffer.data()));\n+    EXPECT_EQ(size, kLineWidth);\n+    auto actual = std::string{buffer.begin(), buffer.end()};\n+    EXPECT_EQ(lines[index], actual);\n+\n+    // Verify random reads using buffers work.\n+    ASSERT_OK_AND_ASSIGN(auto b, file->ReadAt(position, kLineWidth));\n+    EXPECT_EQ(lines[index], b->ToString());\n+  }\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileRandomSeek) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  // Create a file large enough to make the random access tests non-trivial.\n+  auto constexpr kLineWidth = 100;\n+  auto constexpr kLineCount = 4096;\n+  std::vector<std::string> lines(kLineCount);\n+  int lineno = 0;\n+  std::generate_n(lines.begin(), lines.size(),\n+                  [&] { return RandomLine(++lineno, kLineWidth); });\n+\n+  const auto path =\n+      kPreexistingBucket + std::string(\"/OpenInputFileRandomSeek/object-name\");\n+  std::shared_ptr<io::OutputStream> output;\n+  ASSERT_OK_AND_ASSIGN(output, fs->OpenOutputStream(path, {}));\n+  for (auto const& line : lines) {\n+    ASSERT_OK(output->Write(line.data(), line.size()));\n+  }\n+  ASSERT_OK(output->Close());\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(path));\n+  for (int i = 0; i != 32; ++i) {\n+    SCOPED_TRACE(\"Iteration \" + std::to_string(i));\n+    // Verify sequential reads work as expected.\n+    auto const index = RandomIndex(kLineCount);\n+    auto const position = index * kLineWidth;\n+    ASSERT_OK(file->Seek(position));\n+    ASSERT_OK_AND_ASSIGN(auto actual, file->Read(kLineWidth));\n+    EXPECT_EQ(lines[index], actual->ToString());\n+  }\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileInfo) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  arrow::fs::FileInfo info;\n+  ASSERT_OK_AND_ASSIGN(info, fs->GetFileInfo(PreexistingObjectPath()));\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(info));\n+\n+  std::array<char, 1024> buffer{};\n+  std::int64_t size;\n+  auto constexpr kStart = 16;\n+  ASSERT_OK_AND_ASSIGN(size, file->ReadAt(kStart, buffer.size(), buffer.data()));\n+\n+  auto const expected = std::string(kLoremIpsum).substr(kStart);\n+  EXPECT_EQ(std::string(buffer.data(), size), expected);\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileNotFound) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  auto result = fs->OpenInputFile(NotFoundObjectPath());\n+  EXPECT_EQ(result.status().code(), StatusCode::IOError);\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileInfoInvalid) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  arrow::fs::FileInfo info;\n+  ASSERT_OK_AND_ASSIGN(info, fs->GetFileInfo(kPreexistingBucket));\n+\n+  auto result = fs->OpenInputFile(NotFoundObjectPath());\n+  EXPECT_EQ(result.status().code(), StatusCode::IOError);\n+\n+  ASSERT_OK_AND_ASSIGN(info, fs->GetFileInfo(NotFoundObjectPath()));\n+  result = fs->OpenInputFile(NotFoundObjectPath());\n\nReview comment:\n       Did you mean to call `fs->OpenInputFile(info)` instead here as well?\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -324,17 +407,46 @@ Result<std::shared_ptr<io::InputStream>> GcsFileSystem::OpenInputStream(\n     return Status::IOError(\"Only files can be opened as input streams\");\n   }\n   ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(info.path()));\n-  return impl_->OpenInputStream(p);\n+  return impl_->OpenInputStream(p.bucket, p.object, gcs::Generation(),\n+                                gcs::ReadFromOffset());\n }\n \n Result<std::shared_ptr<io::RandomAccessFile>> GcsFileSystem::OpenInputFile(\n     const std::string& path) {\n-  return Status::NotImplemented(\"The GCS FileSystem is not fully implemented\");\n+  ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(path));\n+  auto metadata = impl_->GetObjectMetadata(p);\n\nReview comment:\n       I'm curious, does this add a roundtrip to the server?\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs_test.cc\n##########\n@@ -521,6 +540,130 @@ TEST_F(GcsIntegrationTest, WriteObjectLarge) {\n   EXPECT_EQ(contents, buffers[0] + buffers[1] + buffers[2]);\n }\n \n+TEST_F(GcsIntegrationTest, OpenInputFileMixedReadVsReadAt) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  // Create a file large enough to make the random access tests non-trivial.\n+  auto constexpr kLineWidth = 100;\n+  auto constexpr kLineCount = 4096;\n+  std::vector<std::string> lines(kLineCount);\n+  int lineno = 0;\n+  std::generate_n(lines.begin(), lines.size(),\n+                  [&] { return RandomLine(++lineno, kLineWidth); });\n+\n+  const auto path =\n+      kPreexistingBucket + std::string(\"/OpenInputFileMixedReadVsReadAt/object-name\");\n+  std::shared_ptr<io::OutputStream> output;\n+  ASSERT_OK_AND_ASSIGN(output, fs->OpenOutputStream(path, {}));\n+  for (auto const& line : lines) {\n+    ASSERT_OK(output->Write(line.data(), line.size()));\n+  }\n+  ASSERT_OK(output->Close());\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(path));\n+  for (int i = 0; i != 32; ++i) {\n+    SCOPED_TRACE(\"Iteration \" + std::to_string(i));\n+    // Verify sequential reads work as expected.\n+    std::array<char, kLineWidth> buffer{};\n+    std::int64_t size;\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto actual, file->Read(kLineWidth));\n+      EXPECT_EQ(lines[2 * i], actual->ToString());\n+    }\n+    {\n+      ASSERT_OK_AND_ASSIGN(size, file->Read(buffer.size(), buffer.data()));\n+      EXPECT_EQ(size, kLineWidth);\n+      auto actual = std::string{buffer.begin(), buffer.end()};\n+      EXPECT_EQ(lines[2 * i + 1], actual);\n+    }\n+\n+    // Verify random reads interleave too.\n+    auto const index = RandomIndex(kLineCount);\n+    auto const position = index * kLineWidth;\n+    ASSERT_OK_AND_ASSIGN(size, file->ReadAt(position, buffer.size(), buffer.data()));\n+    EXPECT_EQ(size, kLineWidth);\n+    auto actual = std::string{buffer.begin(), buffer.end()};\n+    EXPECT_EQ(lines[index], actual);\n+\n+    // Verify random reads using buffers work.\n+    ASSERT_OK_AND_ASSIGN(auto b, file->ReadAt(position, kLineWidth));\n+    EXPECT_EQ(lines[index], b->ToString());\n+  }\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileRandomSeek) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  // Create a file large enough to make the random access tests non-trivial.\n+  auto constexpr kLineWidth = 100;\n+  auto constexpr kLineCount = 4096;\n+  std::vector<std::string> lines(kLineCount);\n+  int lineno = 0;\n+  std::generate_n(lines.begin(), lines.size(),\n+                  [&] { return RandomLine(++lineno, kLineWidth); });\n+\n+  const auto path =\n+      kPreexistingBucket + std::string(\"/OpenInputFileRandomSeek/object-name\");\n+  std::shared_ptr<io::OutputStream> output;\n+  ASSERT_OK_AND_ASSIGN(output, fs->OpenOutputStream(path, {}));\n+  for (auto const& line : lines) {\n+    ASSERT_OK(output->Write(line.data(), line.size()));\n+  }\n+  ASSERT_OK(output->Close());\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(path));\n+  for (int i = 0; i != 32; ++i) {\n+    SCOPED_TRACE(\"Iteration \" + std::to_string(i));\n+    // Verify sequential reads work as expected.\n+    auto const index = RandomIndex(kLineCount);\n+    auto const position = index * kLineWidth;\n+    ASSERT_OK(file->Seek(position));\n+    ASSERT_OK_AND_ASSIGN(auto actual, file->Read(kLineWidth));\n+    EXPECT_EQ(lines[index], actual->ToString());\n+  }\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileInfo) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  arrow::fs::FileInfo info;\n+  ASSERT_OK_AND_ASSIGN(info, fs->GetFileInfo(PreexistingObjectPath()));\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(info));\n+\n+  std::array<char, 1024> buffer{};\n+  std::int64_t size;\n+  auto constexpr kStart = 16;\n+  ASSERT_OK_AND_ASSIGN(size, file->ReadAt(kStart, buffer.size(), buffer.data()));\n+\n+  auto const expected = std::string(kLoremIpsum).substr(kStart);\n+  EXPECT_EQ(std::string(buffer.data(), size), expected);\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileNotFound) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  auto result = fs->OpenInputFile(NotFoundObjectPath());\n+  EXPECT_EQ(result.status().code(), StatusCode::IOError);\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileInfoInvalid) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  arrow::fs::FileInfo info;\n+  ASSERT_OK_AND_ASSIGN(info, fs->GetFileInfo(kPreexistingBucket));\n+\n+  auto result = fs->OpenInputFile(NotFoundObjectPath());\n\nReview comment:\n       Did you mean to call `fs->OpenInputFile(info)` instead?\r\n   \n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs_test.cc\n##########\n@@ -521,6 +540,130 @@ TEST_F(GcsIntegrationTest, WriteObjectLarge) {\n   EXPECT_EQ(contents, buffers[0] + buffers[1] + buffers[2]);\n }\n \n+TEST_F(GcsIntegrationTest, OpenInputFileMixedReadVsReadAt) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  // Create a file large enough to make the random access tests non-trivial.\n+  auto constexpr kLineWidth = 100;\n+  auto constexpr kLineCount = 4096;\n+  std::vector<std::string> lines(kLineCount);\n+  int lineno = 0;\n+  std::generate_n(lines.begin(), lines.size(),\n+                  [&] { return RandomLine(++lineno, kLineWidth); });\n+\n+  const auto path =\n+      kPreexistingBucket + std::string(\"/OpenInputFileMixedReadVsReadAt/object-name\");\n+  std::shared_ptr<io::OutputStream> output;\n+  ASSERT_OK_AND_ASSIGN(output, fs->OpenOutputStream(path, {}));\n+  for (auto const& line : lines) {\n+    ASSERT_OK(output->Write(line.data(), line.size()));\n+  }\n+  ASSERT_OK(output->Close());\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(path));\n+  for (int i = 0; i != 32; ++i) {\n+    SCOPED_TRACE(\"Iteration \" + std::to_string(i));\n+    // Verify sequential reads work as expected.\n+    std::array<char, kLineWidth> buffer{};\n+    std::int64_t size;\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto actual, file->Read(kLineWidth));\n+      EXPECT_EQ(lines[2 * i], actual->ToString());\n+    }\n+    {\n+      ASSERT_OK_AND_ASSIGN(size, file->Read(buffer.size(), buffer.data()));\n+      EXPECT_EQ(size, kLineWidth);\n+      auto actual = std::string{buffer.begin(), buffer.end()};\n+      EXPECT_EQ(lines[2 * i + 1], actual);\n+    }\n+\n+    // Verify random reads interleave too.\n+    auto const index = RandomIndex(kLineCount);\n+    auto const position = index * kLineWidth;\n+    ASSERT_OK_AND_ASSIGN(size, file->ReadAt(position, buffer.size(), buffer.data()));\n+    EXPECT_EQ(size, kLineWidth);\n+    auto actual = std::string{buffer.begin(), buffer.end()};\n+    EXPECT_EQ(lines[index], actual);\n+\n+    // Verify random reads using buffers work.\n+    ASSERT_OK_AND_ASSIGN(auto b, file->ReadAt(position, kLineWidth));\n+    EXPECT_EQ(lines[index], b->ToString());\n+  }\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileRandomSeek) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  // Create a file large enough to make the random access tests non-trivial.\n+  auto constexpr kLineWidth = 100;\n+  auto constexpr kLineCount = 4096;\n+  std::vector<std::string> lines(kLineCount);\n+  int lineno = 0;\n+  std::generate_n(lines.begin(), lines.size(),\n+                  [&] { return RandomLine(++lineno, kLineWidth); });\n+\n+  const auto path =\n+      kPreexistingBucket + std::string(\"/OpenInputFileRandomSeek/object-name\");\n+  std::shared_ptr<io::OutputStream> output;\n+  ASSERT_OK_AND_ASSIGN(output, fs->OpenOutputStream(path, {}));\n+  for (auto const& line : lines) {\n+    ASSERT_OK(output->Write(line.data(), line.size()));\n+  }\n+  ASSERT_OK(output->Close());\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(path));\n+  for (int i = 0; i != 32; ++i) {\n+    SCOPED_TRACE(\"Iteration \" + std::to_string(i));\n+    // Verify sequential reads work as expected.\n+    auto const index = RandomIndex(kLineCount);\n+    auto const position = index * kLineWidth;\n+    ASSERT_OK(file->Seek(position));\n+    ASSERT_OK_AND_ASSIGN(auto actual, file->Read(kLineWidth));\n+    EXPECT_EQ(lines[index], actual->ToString());\n+  }\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileInfo) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  arrow::fs::FileInfo info;\n+  ASSERT_OK_AND_ASSIGN(info, fs->GetFileInfo(PreexistingObjectPath()));\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(info));\n+\n+  std::array<char, 1024> buffer{};\n+  std::int64_t size;\n+  auto constexpr kStart = 16;\n+  ASSERT_OK_AND_ASSIGN(size, file->ReadAt(kStart, buffer.size(), buffer.data()));\n+\n+  auto const expected = std::string(kLoremIpsum).substr(kStart);\n+  EXPECT_EQ(std::string(buffer.data(), size), expected);\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileNotFound) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  auto result = fs->OpenInputFile(NotFoundObjectPath());\n+  EXPECT_EQ(result.status().code(), StatusCode::IOError);\n\nReview comment:\n       Can use `ASSERT_RAISES(IOError, fs->OpenInputFile(...))` here, and below as well.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs_test.cc\n##########\n@@ -119,7 +122,23 @@ class GcsIntegrationTest : public ::testing::Test {\n             .set<gc::UnifiedCredentialsOption>(gc::MakeInsecureCredentials()));\n   }\n \n+  std::string RandomLine(int lineno, std::size_t width) {\n+    auto const fillers = std::string(\"abcdefghijlkmnopqrstuvwxyz0123456789\");\n+    std::uniform_int_distribution<std::size_t> d(0, fillers.size() - 1);\n\nReview comment:\n       You can probably reuse `random_string` from `arrow/testing/util.h` instead.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T13:21:35.525+0000",
                    "updated": "2021-12-01T13:21:35.525+0000",
                    "started": "2021-12-01T13:21:35.525+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688646",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688662",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on a change in pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#discussion_r760205288\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -324,17 +407,46 @@ Result<std::shared_ptr<io::InputStream>> GcsFileSystem::OpenInputStream(\n     return Status::IOError(\"Only files can be opened as input streams\");\n   }\n   ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(info.path()));\n-  return impl_->OpenInputStream(p);\n+  return impl_->OpenInputStream(p.bucket, p.object, gcs::Generation(),\n+                                gcs::ReadFromOffset());\n }\n \n Result<std::shared_ptr<io::RandomAccessFile>> GcsFileSystem::OpenInputFile(\n     const std::string& path) {\n-  return Status::NotImplemented(\"The GCS FileSystem is not fully implemented\");\n+  ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(path));\n+  auto metadata = impl_->GetObjectMetadata(p);\n\nReview comment:\n       Yes, it does.  I am trying to ensure that `Read()` and `ReadAt()` and `Seek()` when going back are using the same generation of an object [*].  We could try to use undocumented (and likely to break) APIs to extract the generation without this roundtrip.  If it turns out the roundtrip (and I should add, the additional API charges) are really important, then I would rather add a documented API to the C++ client library and then use that here.\r\n   \r\n   \r\n   [*]: you probably know this, but objects in GCS are versioned.  You can have more than one version of the same object, and/or have the \"latest\" version replaced while you are reading from it.  I would think we want all operations in one `io::RandomAccessFile` to refer to the same generation.\r\n   \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T13:55:04.622+0000",
                    "updated": "2021-12-01T13:55:04.622+0000",
                    "started": "2021-12-01T13:55:04.622+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688662",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688666",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#discussion_r760210518\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -324,17 +407,46 @@ Result<std::shared_ptr<io::InputStream>> GcsFileSystem::OpenInputStream(\n     return Status::IOError(\"Only files can be opened as input streams\");\n   }\n   ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(info.path()));\n-  return impl_->OpenInputStream(p);\n+  return impl_->OpenInputStream(p.bucket, p.object, gcs::Generation(),\n+                                gcs::ReadFromOffset());\n }\n \n Result<std::shared_ptr<io::RandomAccessFile>> GcsFileSystem::OpenInputFile(\n     const std::string& path) {\n-  return Status::NotImplemented(\"The GCS FileSystem is not fully implemented\");\n+  ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(path));\n+  auto metadata = impl_->GetObjectMetadata(p);\n\nReview comment:\n       >  I would think we want all operations in one io::RandomAccessFile to refer to the same generation.\r\n   \r\n   Oh, definitely. I just wonder if there's a way to extract the metadata from the first stream creation? Perhaps this is something that the GCS C++ library can provide (assuming the information exists at all at the HTTP level)?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T14:00:56.704+0000",
                    "updated": "2021-12-01T14:00:56.704+0000",
                    "started": "2021-12-01T14:00:56.704+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688666",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688677",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on a change in pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#discussion_r760223031\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -324,17 +407,46 @@ Result<std::shared_ptr<io::InputStream>> GcsFileSystem::OpenInputStream(\n     return Status::IOError(\"Only files can be opened as input streams\");\n   }\n   ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(info.path()));\n-  return impl_->OpenInputStream(p);\n+  return impl_->OpenInputStream(p.bucket, p.object, gcs::Generation(),\n+                                gcs::ReadFromOffset());\n }\n \n Result<std::shared_ptr<io::RandomAccessFile>> GcsFileSystem::OpenInputFile(\n     const std::string& path) {\n-  return Status::NotImplemented(\"The GCS FileSystem is not fully implemented\");\n+  ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(path));\n+  auto metadata = impl_->GetObjectMetadata(p);\n\nReview comment:\n       And thus my (maybe too obscure) note about \"undocumented (and likely to break) APIs\".  The C++ client library currently returns the HTTP headers, which include thinks like `x-goog-generation` (not the full metadata). This is only intended for debugging, and I **know** of future changes that will make these headers unavailable (sometimes, when the user selects a non-HTTP transport).\r\n   \r\n   I can change the C++ client to return the generation in a future-proof API.  I would rather do that in a separate PR, after I fix the C++ client library (https://github.com/googleapis/google-cloud-cpp/issues/7677).\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T14:15:17.616+0000",
                    "updated": "2021-12-01T14:15:17.616+0000",
                    "started": "2021-12-01T14:15:17.616+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688677",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688681",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#discussion_r760226225\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs.cc\n##########\n@@ -324,17 +407,46 @@ Result<std::shared_ptr<io::InputStream>> GcsFileSystem::OpenInputStream(\n     return Status::IOError(\"Only files can be opened as input streams\");\n   }\n   ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(info.path()));\n-  return impl_->OpenInputStream(p);\n+  return impl_->OpenInputStream(p.bucket, p.object, gcs::Generation(),\n+                                gcs::ReadFromOffset());\n }\n \n Result<std::shared_ptr<io::RandomAccessFile>> GcsFileSystem::OpenInputFile(\n     const std::string& path) {\n-  return Status::NotImplemented(\"The GCS FileSystem is not fully implemented\");\n+  ARROW_ASSIGN_OR_RAISE(auto p, GcsPath::FromString(path));\n+  auto metadata = impl_->GetObjectMetadata(p);\n\nReview comment:\n       > I can change the C++ client to return the generation in a future-proof API. I would rather do that in a separate PR, after I fix the C++ client library\r\n   \r\n   No problem from me.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T14:18:39.977+0000",
                    "updated": "2021-12-01T14:18:39.977+0000",
                    "started": "2021-12-01T14:18:39.977+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688681",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688685",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "coryan commented on a change in pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#discussion_r760230047\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs_test.cc\n##########\n@@ -119,7 +122,23 @@ class GcsIntegrationTest : public ::testing::Test {\n             .set<gc::UnifiedCredentialsOption>(gc::MakeInsecureCredentials()));\n   }\n \n+  std::string RandomLine(int lineno, std::size_t width) {\n+    auto const fillers = std::string(\"abcdefghijlkmnopqrstuvwxyz0123456789\");\n+    std::uniform_int_distribution<std::size_t> d(0, fillers.size() - 1);\n\nReview comment:\n       `random_string()` produces non-printable characters, which are not the easiest thing to troubleshoot.  `random_ascii()` could do it, but has a weird API using a `uint8_t*` output parameter.  I would rather leave this as-is.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs_test.cc\n##########\n@@ -521,6 +540,130 @@ TEST_F(GcsIntegrationTest, WriteObjectLarge) {\n   EXPECT_EQ(contents, buffers[0] + buffers[1] + buffers[2]);\n }\n \n+TEST_F(GcsIntegrationTest, OpenInputFileMixedReadVsReadAt) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  // Create a file large enough to make the random access tests non-trivial.\n+  auto constexpr kLineWidth = 100;\n+  auto constexpr kLineCount = 4096;\n+  std::vector<std::string> lines(kLineCount);\n+  int lineno = 0;\n+  std::generate_n(lines.begin(), lines.size(),\n+                  [&] { return RandomLine(++lineno, kLineWidth); });\n+\n+  const auto path =\n+      kPreexistingBucket + std::string(\"/OpenInputFileMixedReadVsReadAt/object-name\");\n+  std::shared_ptr<io::OutputStream> output;\n+  ASSERT_OK_AND_ASSIGN(output, fs->OpenOutputStream(path, {}));\n+  for (auto const& line : lines) {\n+    ASSERT_OK(output->Write(line.data(), line.size()));\n+  }\n+  ASSERT_OK(output->Close());\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(path));\n+  for (int i = 0; i != 32; ++i) {\n+    SCOPED_TRACE(\"Iteration \" + std::to_string(i));\n+    // Verify sequential reads work as expected.\n+    std::array<char, kLineWidth> buffer{};\n+    std::int64_t size;\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto actual, file->Read(kLineWidth));\n+      EXPECT_EQ(lines[2 * i], actual->ToString());\n+    }\n+    {\n+      ASSERT_OK_AND_ASSIGN(size, file->Read(buffer.size(), buffer.data()));\n+      EXPECT_EQ(size, kLineWidth);\n+      auto actual = std::string{buffer.begin(), buffer.end()};\n+      EXPECT_EQ(lines[2 * i + 1], actual);\n+    }\n+\n+    // Verify random reads interleave too.\n+    auto const index = RandomIndex(kLineCount);\n+    auto const position = index * kLineWidth;\n+    ASSERT_OK_AND_ASSIGN(size, file->ReadAt(position, buffer.size(), buffer.data()));\n+    EXPECT_EQ(size, kLineWidth);\n+    auto actual = std::string{buffer.begin(), buffer.end()};\n+    EXPECT_EQ(lines[index], actual);\n+\n+    // Verify random reads using buffers work.\n+    ASSERT_OK_AND_ASSIGN(auto b, file->ReadAt(position, kLineWidth));\n+    EXPECT_EQ(lines[index], b->ToString());\n+  }\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileRandomSeek) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  // Create a file large enough to make the random access tests non-trivial.\n+  auto constexpr kLineWidth = 100;\n+  auto constexpr kLineCount = 4096;\n+  std::vector<std::string> lines(kLineCount);\n+  int lineno = 0;\n+  std::generate_n(lines.begin(), lines.size(),\n+                  [&] { return RandomLine(++lineno, kLineWidth); });\n+\n+  const auto path =\n+      kPreexistingBucket + std::string(\"/OpenInputFileRandomSeek/object-name\");\n+  std::shared_ptr<io::OutputStream> output;\n+  ASSERT_OK_AND_ASSIGN(output, fs->OpenOutputStream(path, {}));\n+  for (auto const& line : lines) {\n+    ASSERT_OK(output->Write(line.data(), line.size()));\n+  }\n+  ASSERT_OK(output->Close());\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(path));\n+  for (int i = 0; i != 32; ++i) {\n+    SCOPED_TRACE(\"Iteration \" + std::to_string(i));\n+    // Verify sequential reads work as expected.\n+    auto const index = RandomIndex(kLineCount);\n+    auto const position = index * kLineWidth;\n+    ASSERT_OK(file->Seek(position));\n+    ASSERT_OK_AND_ASSIGN(auto actual, file->Read(kLineWidth));\n+    EXPECT_EQ(lines[index], actual->ToString());\n+  }\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileInfo) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  arrow::fs::FileInfo info;\n+  ASSERT_OK_AND_ASSIGN(info, fs->GetFileInfo(PreexistingObjectPath()));\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(info));\n+\n+  std::array<char, 1024> buffer{};\n+  std::int64_t size;\n+  auto constexpr kStart = 16;\n+  ASSERT_OK_AND_ASSIGN(size, file->ReadAt(kStart, buffer.size(), buffer.data()));\n+\n+  auto const expected = std::string(kLoremIpsum).substr(kStart);\n+  EXPECT_EQ(std::string(buffer.data(), size), expected);\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileNotFound) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  auto result = fs->OpenInputFile(NotFoundObjectPath());\n+  EXPECT_EQ(result.status().code(), StatusCode::IOError);\n\nReview comment:\n       Done.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs_test.cc\n##########\n@@ -521,6 +540,130 @@ TEST_F(GcsIntegrationTest, WriteObjectLarge) {\n   EXPECT_EQ(contents, buffers[0] + buffers[1] + buffers[2]);\n }\n \n+TEST_F(GcsIntegrationTest, OpenInputFileMixedReadVsReadAt) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  // Create a file large enough to make the random access tests non-trivial.\n+  auto constexpr kLineWidth = 100;\n+  auto constexpr kLineCount = 4096;\n+  std::vector<std::string> lines(kLineCount);\n+  int lineno = 0;\n+  std::generate_n(lines.begin(), lines.size(),\n+                  [&] { return RandomLine(++lineno, kLineWidth); });\n+\n+  const auto path =\n+      kPreexistingBucket + std::string(\"/OpenInputFileMixedReadVsReadAt/object-name\");\n+  std::shared_ptr<io::OutputStream> output;\n+  ASSERT_OK_AND_ASSIGN(output, fs->OpenOutputStream(path, {}));\n+  for (auto const& line : lines) {\n+    ASSERT_OK(output->Write(line.data(), line.size()));\n+  }\n+  ASSERT_OK(output->Close());\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(path));\n+  for (int i = 0; i != 32; ++i) {\n+    SCOPED_TRACE(\"Iteration \" + std::to_string(i));\n+    // Verify sequential reads work as expected.\n+    std::array<char, kLineWidth> buffer{};\n+    std::int64_t size;\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto actual, file->Read(kLineWidth));\n+      EXPECT_EQ(lines[2 * i], actual->ToString());\n+    }\n+    {\n+      ASSERT_OK_AND_ASSIGN(size, file->Read(buffer.size(), buffer.data()));\n+      EXPECT_EQ(size, kLineWidth);\n+      auto actual = std::string{buffer.begin(), buffer.end()};\n+      EXPECT_EQ(lines[2 * i + 1], actual);\n+    }\n+\n+    // Verify random reads interleave too.\n+    auto const index = RandomIndex(kLineCount);\n+    auto const position = index * kLineWidth;\n+    ASSERT_OK_AND_ASSIGN(size, file->ReadAt(position, buffer.size(), buffer.data()));\n+    EXPECT_EQ(size, kLineWidth);\n+    auto actual = std::string{buffer.begin(), buffer.end()};\n+    EXPECT_EQ(lines[index], actual);\n+\n+    // Verify random reads using buffers work.\n+    ASSERT_OK_AND_ASSIGN(auto b, file->ReadAt(position, kLineWidth));\n+    EXPECT_EQ(lines[index], b->ToString());\n+  }\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileRandomSeek) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  // Create a file large enough to make the random access tests non-trivial.\n+  auto constexpr kLineWidth = 100;\n+  auto constexpr kLineCount = 4096;\n+  std::vector<std::string> lines(kLineCount);\n+  int lineno = 0;\n+  std::generate_n(lines.begin(), lines.size(),\n+                  [&] { return RandomLine(++lineno, kLineWidth); });\n+\n+  const auto path =\n+      kPreexistingBucket + std::string(\"/OpenInputFileRandomSeek/object-name\");\n+  std::shared_ptr<io::OutputStream> output;\n+  ASSERT_OK_AND_ASSIGN(output, fs->OpenOutputStream(path, {}));\n+  for (auto const& line : lines) {\n+    ASSERT_OK(output->Write(line.data(), line.size()));\n+  }\n+  ASSERT_OK(output->Close());\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(path));\n+  for (int i = 0; i != 32; ++i) {\n+    SCOPED_TRACE(\"Iteration \" + std::to_string(i));\n+    // Verify sequential reads work as expected.\n+    auto const index = RandomIndex(kLineCount);\n+    auto const position = index * kLineWidth;\n+    ASSERT_OK(file->Seek(position));\n+    ASSERT_OK_AND_ASSIGN(auto actual, file->Read(kLineWidth));\n+    EXPECT_EQ(lines[index], actual->ToString());\n+  }\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileInfo) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  arrow::fs::FileInfo info;\n+  ASSERT_OK_AND_ASSIGN(info, fs->GetFileInfo(PreexistingObjectPath()));\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(info));\n+\n+  std::array<char, 1024> buffer{};\n+  std::int64_t size;\n+  auto constexpr kStart = 16;\n+  ASSERT_OK_AND_ASSIGN(size, file->ReadAt(kStart, buffer.size(), buffer.data()));\n+\n+  auto const expected = std::string(kLoremIpsum).substr(kStart);\n+  EXPECT_EQ(std::string(buffer.data(), size), expected);\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileNotFound) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  auto result = fs->OpenInputFile(NotFoundObjectPath());\n+  EXPECT_EQ(result.status().code(), StatusCode::IOError);\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileInfoInvalid) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  arrow::fs::FileInfo info;\n+  ASSERT_OK_AND_ASSIGN(info, fs->GetFileInfo(kPreexistingBucket));\n+\n+  auto result = fs->OpenInputFile(NotFoundObjectPath());\n+  EXPECT_EQ(result.status().code(), StatusCode::IOError);\n+\n+  ASSERT_OK_AND_ASSIGN(info, fs->GetFileInfo(NotFoundObjectPath()));\n+  result = fs->OpenInputFile(NotFoundObjectPath());\n\nReview comment:\n       Yes, thanks. Fixed.\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs_test.cc\n##########\n@@ -521,6 +540,130 @@ TEST_F(GcsIntegrationTest, WriteObjectLarge) {\n   EXPECT_EQ(contents, buffers[0] + buffers[1] + buffers[2]);\n }\n \n+TEST_F(GcsIntegrationTest, OpenInputFileMixedReadVsReadAt) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  // Create a file large enough to make the random access tests non-trivial.\n+  auto constexpr kLineWidth = 100;\n+  auto constexpr kLineCount = 4096;\n+  std::vector<std::string> lines(kLineCount);\n+  int lineno = 0;\n+  std::generate_n(lines.begin(), lines.size(),\n+                  [&] { return RandomLine(++lineno, kLineWidth); });\n+\n+  const auto path =\n+      kPreexistingBucket + std::string(\"/OpenInputFileMixedReadVsReadAt/object-name\");\n+  std::shared_ptr<io::OutputStream> output;\n+  ASSERT_OK_AND_ASSIGN(output, fs->OpenOutputStream(path, {}));\n+  for (auto const& line : lines) {\n+    ASSERT_OK(output->Write(line.data(), line.size()));\n+  }\n+  ASSERT_OK(output->Close());\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(path));\n+  for (int i = 0; i != 32; ++i) {\n+    SCOPED_TRACE(\"Iteration \" + std::to_string(i));\n+    // Verify sequential reads work as expected.\n+    std::array<char, kLineWidth> buffer{};\n+    std::int64_t size;\n+    {\n+      ASSERT_OK_AND_ASSIGN(auto actual, file->Read(kLineWidth));\n+      EXPECT_EQ(lines[2 * i], actual->ToString());\n+    }\n+    {\n+      ASSERT_OK_AND_ASSIGN(size, file->Read(buffer.size(), buffer.data()));\n+      EXPECT_EQ(size, kLineWidth);\n+      auto actual = std::string{buffer.begin(), buffer.end()};\n+      EXPECT_EQ(lines[2 * i + 1], actual);\n+    }\n+\n+    // Verify random reads interleave too.\n+    auto const index = RandomIndex(kLineCount);\n+    auto const position = index * kLineWidth;\n+    ASSERT_OK_AND_ASSIGN(size, file->ReadAt(position, buffer.size(), buffer.data()));\n+    EXPECT_EQ(size, kLineWidth);\n+    auto actual = std::string{buffer.begin(), buffer.end()};\n+    EXPECT_EQ(lines[index], actual);\n+\n+    // Verify random reads using buffers work.\n+    ASSERT_OK_AND_ASSIGN(auto b, file->ReadAt(position, kLineWidth));\n+    EXPECT_EQ(lines[index], b->ToString());\n+  }\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileRandomSeek) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  // Create a file large enough to make the random access tests non-trivial.\n+  auto constexpr kLineWidth = 100;\n+  auto constexpr kLineCount = 4096;\n+  std::vector<std::string> lines(kLineCount);\n+  int lineno = 0;\n+  std::generate_n(lines.begin(), lines.size(),\n+                  [&] { return RandomLine(++lineno, kLineWidth); });\n+\n+  const auto path =\n+      kPreexistingBucket + std::string(\"/OpenInputFileRandomSeek/object-name\");\n+  std::shared_ptr<io::OutputStream> output;\n+  ASSERT_OK_AND_ASSIGN(output, fs->OpenOutputStream(path, {}));\n+  for (auto const& line : lines) {\n+    ASSERT_OK(output->Write(line.data(), line.size()));\n+  }\n+  ASSERT_OK(output->Close());\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(path));\n+  for (int i = 0; i != 32; ++i) {\n+    SCOPED_TRACE(\"Iteration \" + std::to_string(i));\n+    // Verify sequential reads work as expected.\n+    auto const index = RandomIndex(kLineCount);\n+    auto const position = index * kLineWidth;\n+    ASSERT_OK(file->Seek(position));\n+    ASSERT_OK_AND_ASSIGN(auto actual, file->Read(kLineWidth));\n+    EXPECT_EQ(lines[index], actual->ToString());\n+  }\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileInfo) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  arrow::fs::FileInfo info;\n+  ASSERT_OK_AND_ASSIGN(info, fs->GetFileInfo(PreexistingObjectPath()));\n+\n+  std::shared_ptr<io::RandomAccessFile> file;\n+  ASSERT_OK_AND_ASSIGN(file, fs->OpenInputFile(info));\n+\n+  std::array<char, 1024> buffer{};\n+  std::int64_t size;\n+  auto constexpr kStart = 16;\n+  ASSERT_OK_AND_ASSIGN(size, file->ReadAt(kStart, buffer.size(), buffer.data()));\n+\n+  auto const expected = std::string(kLoremIpsum).substr(kStart);\n+  EXPECT_EQ(std::string(buffer.data(), size), expected);\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileNotFound) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  auto result = fs->OpenInputFile(NotFoundObjectPath());\n+  EXPECT_EQ(result.status().code(), StatusCode::IOError);\n+}\n+\n+TEST_F(GcsIntegrationTest, OpenInputFileInfoInvalid) {\n+  auto fs = internal::MakeGcsFileSystemForTest(TestGcsOptions());\n+\n+  arrow::fs::FileInfo info;\n+  ASSERT_OK_AND_ASSIGN(info, fs->GetFileInfo(kPreexistingBucket));\n+\n+  auto result = fs->OpenInputFile(NotFoundObjectPath());\n\nReview comment:\n       Yup, fixed too.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T14:22:42.125+0000",
                    "updated": "2021-12-01T14:22:42.125+0000",
                    "started": "2021-12-01T14:22:42.124+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688685",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688694",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#discussion_r760242370\n\n\n\n##########\nFile path: cpp/src/arrow/filesystem/gcsfs_test.cc\n##########\n@@ -119,7 +122,23 @@ class GcsIntegrationTest : public ::testing::Test {\n             .set<gc::UnifiedCredentialsOption>(gc::MakeInsecureCredentials()));\n   }\n \n+  std::string RandomLine(int lineno, std::size_t width) {\n+    auto const fillers = std::string(\"abcdefghijlkmnopqrstuvwxyz0123456789\");\n+    std::uniform_int_distribution<std::size_t> d(0, fillers.size() - 1);\n\nReview comment:\n       Fair enough :-)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T14:35:07.762+0000",
                    "updated": "2021-12-01T14:35:07.762+0000",
                    "started": "2021-12-01T14:35:07.762+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688694",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688719",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou closed pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812\n\n\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T15:01:12.812+0000",
                    "updated": "2021-12-01T15:01:12.812+0000",
                    "started": "2021-12-01T15:01:12.812+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688719",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688720",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot commented on pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#issuecomment-983726458\n\n\n   Benchmark runs are scheduled for baseline = f589610e6b6b1606073882b6b2f95d31fe8625ad and contender = 5227f24f60b38de46a8a8df10e53e6f4bbce56ee. 5227f24f60b38de46a8a8df10e53e6f4bbce56ee is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Scheduled] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/63582d1642a04ab0b96294529dcc34c1...e05e9c15ca704313af7343d9888626af/)\n   [Scheduled] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/5e57aa923a4540ce9babf21b92eff4f2...5032e4c1e9354d4799ae949d793661f1/)\n   [Scheduled] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/787dac4ea3b544e6bcaa947d8315eb85...205861ed8eaf41bda4242ea520f244d1/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T15:01:35.646+0000",
                    "updated": "2021-12-01T15:01:35.646+0000",
                    "started": "2021-12-01T15:01:35.646+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688720",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688732",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot edited a comment on pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#issuecomment-983726458\n\n\n   Benchmark runs are scheduled for baseline = f589610e6b6b1606073882b6b2f95d31fe8625ad and contender = 5227f24f60b38de46a8a8df10e53e6f4bbce56ee. 5227f24f60b38de46a8a8df10e53e6f4bbce56ee is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/63582d1642a04ab0b96294529dcc34c1...e05e9c15ca704313af7343d9888626af/)\n   [Scheduled] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/5e57aa923a4540ce9babf21b92eff4f2...5032e4c1e9354d4799ae949d793661f1/)\n   [Scheduled] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/787dac4ea3b544e6bcaa947d8315eb85...205861ed8eaf41bda4242ea520f244d1/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T15:14:37.911+0000",
                    "updated": "2021-12-01T15:14:37.911+0000",
                    "started": "2021-12-01T15:14:37.911+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688732",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/688976",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot edited a comment on pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#issuecomment-983726458\n\n\n   Benchmark runs are scheduled for baseline = f589610e6b6b1606073882b6b2f95d31fe8625ad and contender = 5227f24f60b38de46a8a8df10e53e6f4bbce56ee. 5227f24f60b38de46a8a8df10e53e6f4bbce56ee is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/63582d1642a04ab0b96294529dcc34c1...e05e9c15ca704313af7343d9888626af/)\n   [Scheduled] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/5e57aa923a4540ce9babf21b92eff4f2...5032e4c1e9354d4799ae949d793661f1/)\n   [Finished :arrow_down:0.09% :arrow_up:0.04%] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/787dac4ea3b544e6bcaa947d8315eb85...205861ed8eaf41bda4242ea520f244d1/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-01T23:44:46.153+0000",
                    "updated": "2021-12-01T23:44:46.153+0000",
                    "started": "2021-12-01T23:44:46.153+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "688976",
                    "issueId": "13406821"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/worklog/689061",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "ursabot edited a comment on pull request #11812:\nURL: https://github.com/apache/arrow/pull/11812#issuecomment-983726458\n\n\n   Benchmark runs are scheduled for baseline = f589610e6b6b1606073882b6b2f95d31fe8625ad and contender = 5227f24f60b38de46a8a8df10e53e6f4bbce56ee. 5227f24f60b38de46a8a8df10e53e6f4bbce56ee is a master commit associated with this PR. Results will be available as each benchmark for each run completes.\n   Conbench compare runs links:\n   [Finished :arrow_down:0.0% :arrow_up:0.0%] [ec2-t3-xlarge-us-east-2](https://conbench.ursa.dev/compare/runs/63582d1642a04ab0b96294529dcc34c1...e05e9c15ca704313af7343d9888626af/)\n   [Failed :arrow_down:0.0% :arrow_up:0.0%] [ursa-i9-9960x](https://conbench.ursa.dev/compare/runs/5e57aa923a4540ce9babf21b92eff4f2...5032e4c1e9354d4799ae949d793661f1/)\n   [Finished :arrow_down:0.09% :arrow_up:0.04%] [ursa-thinkcentre-m75q](https://conbench.ursa.dev/compare/runs/787dac4ea3b544e6bcaa947d8315eb85...205861ed8eaf41bda4242ea520f244d1/)\n   Supported benchmarks:\n   ursa-i9-9960x: langs = Python, R, JavaScript\n   ursa-thinkcentre-m75q: langs = C++, Java\n   ec2-t3-xlarge-us-east-2: cloud = True\n   \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-02T06:55:39.650+0000",
                    "updated": "2021-12-02T06:55:39.650+0000",
                    "started": "2021-12-02T06:55:39.650+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "689061",
                    "issueId": "13406821"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 8400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@45afc91d[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3e8fd8c0[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@12966573[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@521ff639[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5db2164[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@79dede2f[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@58c2819a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@75411a85[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@29cdc548[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@26ed49f8[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6a6fd2ee[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@17877814[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 8400,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Dec 01 15:00:59 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-12-01T15:00:59.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-14347/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-10-15T14:43:58.000+0000",
        "updated": "2021-12-02T06:55:40.000+0000",
        "timeoriginalestimate": null,
        "description": "Implement the {{GcsFileSystem::OpenInputFile()}} overloads and tests for them.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 8400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Implement \"random access\" reads for GCS FileSystem",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13406821/comment/17451880",
                    "id": "17451880",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 11812\n[https://github.com/apache/arrow/pull/11812]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2021-12-01T15:00:59.372+0000",
                    "updated": "2021-12-01T15:00:59.372+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0vw1k:",
        "customfield_12314139": null
    }
}