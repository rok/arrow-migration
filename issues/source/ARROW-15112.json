{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13417725",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725",
    "key": "ARROW-15112",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12350591",
                "id": "12350591",
                "description": "",
                "name": "7.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2022-02-03"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12629265",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12629265",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13407798",
                    "key": "ARROW-14421",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13407798",
                    "fields": {
                        "summary": "[C++][FlightRPC] Implement Flight SQL for C++",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/3",
                            "id": "3",
                            "description": "A task that needs to be done.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21148&avatarType=issuetype",
                            "name": "Task",
                            "subtask": false,
                            "avatarId": 21148
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rafaeltelles",
            "name": "rafaeltelles",
            "key": "rafaeltelles",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Rafael Telles",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334621",
                "id": "12334621",
                "name": "FlightRPC"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333774",
                "id": "12333774",
                "name": "Integration",
                "description": "Issues related to integration / compatibility tests between implementations"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328933",
                "id": "12328933",
                "name": "Java"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
            "name": "lidavidm",
            "key": "lidavidm",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "David Li",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 16200,
            "total": 16200,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 16200,
            "total": 16200,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15112/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 27,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/698116",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rafael-telles opened a new pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989\n\n\n   This adds Flight SQL scenarios for integration tests for C++ and Java implementations.\r\n   The integrations tests assert that:\r\n   - RPC objects built on clients are parsed correctly on servers\r\n   - Arrow vectors built on servers have the expected Arrow schemas when received on clients\r\n   \r\n   While working on this I found some inconsistencies between both implementation, this PR also fixes these problems.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-17T21:46:37.424+0000",
                    "updated": "2021-12-17T21:46:37.424+0000",
                    "started": "2021-12-17T21:46:37.424+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "698116",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/698117",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-997050056\n\n\n   https://issues.apache.org/jira/browse/ARROW-15112\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-17T21:47:00.335+0000",
                    "updated": "2021-12-17T21:47:00.335+0000",
                    "started": "2021-12-17T21:47:00.335+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "698117",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/698118",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rafael-telles commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-997051330\n\n\n   Hi @lidavidm ! We wrote the integration tests for Flight SQL as requested :)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-17T21:49:53.772+0000",
                    "updated": "2021-12-17T21:49:53.772+0000",
                    "started": "2021-12-17T21:49:53.772+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "698118",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/698134",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#discussion_r771725031\n\n\n\n##########\nFile path: cpp/src/arrow/flight/integration_tests/test_integration.h\n##########\n@@ -28,22 +28,27 @@\n \n namespace arrow {\n\nReview comment:\n       This isn't your mistake, but this file is missing a `#pragma once` up top - hence the CI failure.\n\n##########\nFile path: java/flight/flight-integration-tests/src/main/java/org/apache/arrow/flight/integration/tests/FlightSqlScenarioProducer.java\n##########\n@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.integration.tests;\n+\n+import static com.google.protobuf.Any.pack;\n+import static java.util.Collections.singletonList;\n+\n+import java.util.List;\n+\n+import org.apache.arrow.flight.Criteria;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightEndpoint;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.FlightSqlProducer;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Message;\n+\n+/**\n+ * Hardcoded Flight SQL producer used for cross-language integration tests.\n+ */\n+public class FlightSqlScenarioProducer implements FlightSqlProducer {\n+  private final BufferAllocator allocator;\n+\n+  public FlightSqlScenarioProducer(BufferAllocator allocator) {\n+    this.allocator = allocator;\n+  }\n+\n+  static Schema getQuerySchema() {\n+    return new Schema(\n+        singletonList(\n+            new Field(\"id\", FieldType.nullable(new ArrowType.Int(64, true)), null)\n+        )\n+    );\n+  }\n+\n+  @Override\n+  public void createPreparedStatement(FlightSql.ActionCreatePreparedStatementRequest request,\n+                                      CallContext context, StreamListener<Result> listener) {\n+    IntegrationAssertions.assertTrue(\"Expect to be one of the two queries used on tests\",\n+        request.getQuery().equals(\"SELECT PREPARED STATEMENT\") ||\n+            request.getQuery().equals(\"UPDATE PREPARED STATEMENT\"));\n+\n+    final FlightSql.ActionCreatePreparedStatementResult\n+        result = FlightSql.ActionCreatePreparedStatementResult.newBuilder()\n+        .setPreparedStatementHandle(ByteString.copyFromUtf8(request.getQuery() + \" HANDLE\"))\n+        .build();\n+    listener.onNext(new Result(pack(result).toByteArray()));\n+    listener.onCompleted();\n+  }\n+\n+  @Override\n+  public void closePreparedStatement(FlightSql.ActionClosePreparedStatementRequest request,\n+                                     CallContext context, StreamListener<Result> listener) {\n+    IntegrationAssertions.assertTrue(\"Expect to be one of the two queries used on tests\",\n+        request.getPreparedStatementHandle().toStringUtf8().equals(\"SELECT PREPARED STATEMENT HANDLE\") ||\n+            request.getPreparedStatementHandle().toStringUtf8().equals(\"UPDATE PREPARED STATEMENT HANDLE\"));\n+\n+    listener.onCompleted();\n+  }\n+\n+  @Override\n+  public FlightInfo getFlightInfoStatement(FlightSql.CommandStatementQuery command,\n+                                           CallContext context, FlightDescriptor descriptor) {\n+    IntegrationAssertions.assertEquals(command.getQuery(), \"SELECT STATEMENT\");\n+\n+    ByteString handle = ByteString.copyFromUtf8(\"SELECT STATEMENT HANDLE\");\n+\n+    FlightSql.TicketStatementQuery ticket = FlightSql.TicketStatementQuery.newBuilder()\n+        .setStatementHandle(handle)\n+        .build();\n+    return getFlightInfoForSchema(ticket, descriptor, getQuerySchema());\n+  }\n+\n+  @Override\n+  public FlightInfo getFlightInfoPreparedStatement(FlightSql.CommandPreparedStatementQuery command,\n+                                                   CallContext context,\n+                                                   FlightDescriptor descriptor) {\n+    IntegrationAssertions.assertEquals(command.getPreparedStatementHandle().toStringUtf8(),\n+        \"SELECT PREPARED STATEMENT HANDLE\");\n+\n+    return getFlightInfoForSchema(command, descriptor, getQuerySchema());\n+  }\n+\n+  @Override\n+  public SchemaResult getSchemaStatement(FlightSql.CommandStatementQuery command,\n+                                         CallContext context, FlightDescriptor descriptor) {\n+    return new SchemaResult(getQuerySchema());\n+  }\n+\n+  @Override\n+  public void getStreamStatement(FlightSql.TicketStatementQuery ticket, CallContext context,\n+                                 ServerStreamListener listener) {\n+    serveJsonToStreamListener(listener, getQuerySchema());\n+  }\n+\n+  @Override\n+  public void getStreamPreparedStatement(FlightSql.CommandPreparedStatementQuery command,\n+                                         CallContext context, ServerStreamListener listener) {\n+    serveJsonToStreamListener(listener, getQuerySchema());\n+  }\n+\n+  private Runnable acceptPutReturnConstant(StreamListener<PutResult> ackStream, int value) {\n+    return () -> {\n+      final FlightSql.DoPutUpdateResult build =\n+          FlightSql.DoPutUpdateResult.newBuilder().setRecordCount(value).build();\n+\n+      try (final ArrowBuf buffer = allocator.buffer(build.getSerializedSize())) {\n+        buffer.writeBytes(build.toByteArray());\n+        ackStream.onNext(PutResult.metadata(buffer));\n+        ackStream.onCompleted();\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public Runnable acceptPutStatement(FlightSql.CommandStatementUpdate command, CallContext context,\n+                                     FlightStream flightStream,\n+                                     StreamListener<PutResult> ackStream) {\n+    IntegrationAssertions.assertEquals(command.getQuery(), \"UPDATE STATEMENT\");\n+\n+    return acceptPutReturnConstant(ackStream, 10000);\n+  }\n+\n+  @Override\n+  public Runnable acceptPutPreparedStatementUpdate(FlightSql.CommandPreparedStatementUpdate command,\n+                                                   CallContext context, FlightStream flightStream,\n+                                                   StreamListener<PutResult> ackStream) {\n+    IntegrationAssertions.assertEquals(command.getPreparedStatementHandle().toStringUtf8(),\n+        \"UPDATE PREPARED STATEMENT HANDLE\");\n+\n+    return acceptPutReturnConstant(ackStream, 20000);\n+  }\n+\n+  @Override\n+  public Runnable acceptPutPreparedStatementQuery(FlightSql.CommandPreparedStatementQuery command,\n+                                                  CallContext context, FlightStream flightStream,\n+                                                  StreamListener<PutResult> ackStream) {\n+    IntegrationAssertions.assertEquals(command.getPreparedStatementHandle(),\n+        \"SELECT PREPARED STATEMENT HANDLE\");\n+\n+    return null;\n+  }\n+\n+  @Override\n+  public FlightInfo getFlightInfoSqlInfo(FlightSql.CommandGetSqlInfo request, CallContext context,\n+                                         FlightDescriptor descriptor) {\n+    IntegrationAssertions.assertEquals(request.getInfoCount(), 2);\n+    IntegrationAssertions.assertEquals(request.getInfo(0),\n+        FlightSql.SqlInfo.FLIGHT_SQL_SERVER_NAME_VALUE);\n+    IntegrationAssertions.assertEquals(request.getInfo(1),\n+        FlightSql.SqlInfo.FLIGHT_SQL_SERVER_READ_ONLY_VALUE);\n+\n+    return getFlightInfoForSchema(request, descriptor, Schemas.GET_SQL_INFO_SCHEMA);\n+  }\n+\n+  @Override\n+  public void getStreamSqlInfo(FlightSql.CommandGetSqlInfo command, CallContext context,\n+                               ServerStreamListener listener) {\n+    serveJsonToStreamListener(listener, Schemas.GET_SQL_INFO_SCHEMA);\n+  }\n+\n+  @Override\n+  public FlightInfo getFlightInfoCatalogs(FlightSql.CommandGetCatalogs request, CallContext context,\n+                                          FlightDescriptor descriptor) {\n+    return getFlightInfoForSchema(request, descriptor, Schemas.GET_CATALOGS_SCHEMA);\n+  }\n+\n+  private void serveJsonToStreamListener(ServerStreamListener stream, Schema schema) {\n\nReview comment:\n       What does this have to do with JSON?\n\n##########\nFile path: cpp/src/arrow/CMakeLists.txt\n##########\n@@ -736,6 +736,10 @@ if(ARROW_FLIGHT_SQL)\n   add_subdirectory(flight/sql)\n endif()\n \n+if(ARROW_FLIGHT AND ARROW_BUILD_INTEGRATION)\n\nReview comment:\n       `AND ARROW_FLIGHT_SQL`?\n\n##########\nFile path: java/flight/flight-integration-tests/src/main/java/org/apache/arrow/flight/integration/tests/FlightSqlScenarioProducer.java\n##########\n@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.integration.tests;\n+\n+import static com.google.protobuf.Any.pack;\n+import static java.util.Collections.singletonList;\n+\n+import java.util.List;\n+\n+import org.apache.arrow.flight.Criteria;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightEndpoint;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.FlightSqlProducer;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Message;\n+\n+/**\n+ * Hardcoded Flight SQL producer used for cross-language integration tests.\n+ */\n+public class FlightSqlScenarioProducer implements FlightSqlProducer {\n+  private final BufferAllocator allocator;\n+\n+  public FlightSqlScenarioProducer(BufferAllocator allocator) {\n+    this.allocator = allocator;\n+  }\n+\n+  static Schema getQuerySchema() {\n+    return new Schema(\n+        singletonList(\n+            new Field(\"id\", FieldType.nullable(new ArrowType.Int(64, true)), null)\n+        )\n+    );\n+  }\n+\n+  @Override\n+  public void createPreparedStatement(FlightSql.ActionCreatePreparedStatementRequest request,\n+                                      CallContext context, StreamListener<Result> listener) {\n+    IntegrationAssertions.assertTrue(\"Expect to be one of the two queries used on tests\",\n+        request.getQuery().equals(\"SELECT PREPARED STATEMENT\") ||\n+            request.getQuery().equals(\"UPDATE PREPARED STATEMENT\"));\n+\n+    final FlightSql.ActionCreatePreparedStatementResult\n+        result = FlightSql.ActionCreatePreparedStatementResult.newBuilder()\n+        .setPreparedStatementHandle(ByteString.copyFromUtf8(request.getQuery() + \" HANDLE\"))\n+        .build();\n+    listener.onNext(new Result(pack(result).toByteArray()));\n+    listener.onCompleted();\n+  }\n+\n+  @Override\n+  public void closePreparedStatement(FlightSql.ActionClosePreparedStatementRequest request,\n+                                     CallContext context, StreamListener<Result> listener) {\n+    IntegrationAssertions.assertTrue(\"Expect to be one of the two queries used on tests\",\n+        request.getPreparedStatementHandle().toStringUtf8().equals(\"SELECT PREPARED STATEMENT HANDLE\") ||\n+            request.getPreparedStatementHandle().toStringUtf8().equals(\"UPDATE PREPARED STATEMENT HANDLE\"));\n+\n+    listener.onCompleted();\n+  }\n+\n+  @Override\n+  public FlightInfo getFlightInfoStatement(FlightSql.CommandStatementQuery command,\n+                                           CallContext context, FlightDescriptor descriptor) {\n+    IntegrationAssertions.assertEquals(command.getQuery(), \"SELECT STATEMENT\");\n+\n+    ByteString handle = ByteString.copyFromUtf8(\"SELECT STATEMENT HANDLE\");\n+\n+    FlightSql.TicketStatementQuery ticket = FlightSql.TicketStatementQuery.newBuilder()\n+        .setStatementHandle(handle)\n+        .build();\n+    return getFlightInfoForSchema(ticket, descriptor, getQuerySchema());\n+  }\n+\n+  @Override\n+  public FlightInfo getFlightInfoPreparedStatement(FlightSql.CommandPreparedStatementQuery command,\n+                                                   CallContext context,\n+                                                   FlightDescriptor descriptor) {\n+    IntegrationAssertions.assertEquals(command.getPreparedStatementHandle().toStringUtf8(),\n+        \"SELECT PREPARED STATEMENT HANDLE\");\n+\n+    return getFlightInfoForSchema(command, descriptor, getQuerySchema());\n+  }\n+\n+  @Override\n+  public SchemaResult getSchemaStatement(FlightSql.CommandStatementQuery command,\n+                                         CallContext context, FlightDescriptor descriptor) {\n+    return new SchemaResult(getQuerySchema());\n+  }\n+\n+  @Override\n+  public void getStreamStatement(FlightSql.TicketStatementQuery ticket, CallContext context,\n+                                 ServerStreamListener listener) {\n+    serveJsonToStreamListener(listener, getQuerySchema());\n+  }\n+\n+  @Override\n+  public void getStreamPreparedStatement(FlightSql.CommandPreparedStatementQuery command,\n+                                         CallContext context, ServerStreamListener listener) {\n+    serveJsonToStreamListener(listener, getQuerySchema());\n+  }\n+\n+  private Runnable acceptPutReturnConstant(StreamListener<PutResult> ackStream, int value) {\n+    return () -> {\n+      final FlightSql.DoPutUpdateResult build =\n+          FlightSql.DoPutUpdateResult.newBuilder().setRecordCount(value).build();\n+\n+      try (final ArrowBuf buffer = allocator.buffer(build.getSerializedSize())) {\n+        buffer.writeBytes(build.toByteArray());\n+        ackStream.onNext(PutResult.metadata(buffer));\n+        ackStream.onCompleted();\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public Runnable acceptPutStatement(FlightSql.CommandStatementUpdate command, CallContext context,\n+                                     FlightStream flightStream,\n+                                     StreamListener<PutResult> ackStream) {\n+    IntegrationAssertions.assertEquals(command.getQuery(), \"UPDATE STATEMENT\");\n+\n+    return acceptPutReturnConstant(ackStream, 10000);\n+  }\n+\n+  @Override\n+  public Runnable acceptPutPreparedStatementUpdate(FlightSql.CommandPreparedStatementUpdate command,\n+                                                   CallContext context, FlightStream flightStream,\n+                                                   StreamListener<PutResult> ackStream) {\n+    IntegrationAssertions.assertEquals(command.getPreparedStatementHandle().toStringUtf8(),\n+        \"UPDATE PREPARED STATEMENT HANDLE\");\n+\n+    return acceptPutReturnConstant(ackStream, 20000);\n+  }\n+\n+  @Override\n+  public Runnable acceptPutPreparedStatementQuery(FlightSql.CommandPreparedStatementQuery command,\n+                                                  CallContext context, FlightStream flightStream,\n+                                                  StreamListener<PutResult> ackStream) {\n+    IntegrationAssertions.assertEquals(command.getPreparedStatementHandle(),\n+        \"SELECT PREPARED STATEMENT HANDLE\");\n+\n+    return null;\n+  }\n+\n+  @Override\n+  public FlightInfo getFlightInfoSqlInfo(FlightSql.CommandGetSqlInfo request, CallContext context,\n+                                         FlightDescriptor descriptor) {\n+    IntegrationAssertions.assertEquals(request.getInfoCount(), 2);\n+    IntegrationAssertions.assertEquals(request.getInfo(0),\n+        FlightSql.SqlInfo.FLIGHT_SQL_SERVER_NAME_VALUE);\n+    IntegrationAssertions.assertEquals(request.getInfo(1),\n+        FlightSql.SqlInfo.FLIGHT_SQL_SERVER_READ_ONLY_VALUE);\n+\n+    return getFlightInfoForSchema(request, descriptor, Schemas.GET_SQL_INFO_SCHEMA);\n+  }\n+\n+  @Override\n+  public void getStreamSqlInfo(FlightSql.CommandGetSqlInfo command, CallContext context,\n+                               ServerStreamListener listener) {\n+    serveJsonToStreamListener(listener, Schemas.GET_SQL_INFO_SCHEMA);\n+  }\n+\n+  @Override\n+  public FlightInfo getFlightInfoCatalogs(FlightSql.CommandGetCatalogs request, CallContext context,\n+                                          FlightDescriptor descriptor) {\n+    return getFlightInfoForSchema(request, descriptor, Schemas.GET_CATALOGS_SCHEMA);\n+  }\n+\n+  private void serveJsonToStreamListener(ServerStreamListener stream, Schema schema) {\n\nReview comment:\n       Maybe `putEmptyBatchToStreamListener`?\n\n##########\nFile path: java/flight/flight-integration-tests/src/main/java/org/apache/arrow/flight/integration/tests/FlightSqlScenarioProducer.java\n##########\n@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.integration.tests;\n+\n+import static com.google.protobuf.Any.pack;\n+import static java.util.Collections.singletonList;\n+\n+import java.util.List;\n+\n+import org.apache.arrow.flight.Criteria;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightEndpoint;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.FlightSqlProducer;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Message;\n+\n+/**\n+ * Hardcoded Flight SQL producer used for cross-language integration tests.\n+ */\n+public class FlightSqlScenarioProducer implements FlightSqlProducer {\n+  private final BufferAllocator allocator;\n+\n+  public FlightSqlScenarioProducer(BufferAllocator allocator) {\n+    this.allocator = allocator;\n+  }\n+\n+  static Schema getQuerySchema() {\n+    return new Schema(\n+        singletonList(\n+            new Field(\"id\", FieldType.nullable(new ArrowType.Int(64, true)), null)\n+        )\n+    );\n+  }\n+\n+  @Override\n+  public void createPreparedStatement(FlightSql.ActionCreatePreparedStatementRequest request,\n+                                      CallContext context, StreamListener<Result> listener) {\n+    IntegrationAssertions.assertTrue(\"Expect to be one of the two queries used on tests\",\n+        request.getQuery().equals(\"SELECT PREPARED STATEMENT\") ||\n+            request.getQuery().equals(\"UPDATE PREPARED STATEMENT\"));\n+\n+    final FlightSql.ActionCreatePreparedStatementResult\n+        result = FlightSql.ActionCreatePreparedStatementResult.newBuilder()\n+        .setPreparedStatementHandle(ByteString.copyFromUtf8(request.getQuery() + \" HANDLE\"))\n+        .build();\n+    listener.onNext(new Result(pack(result).toByteArray()));\n+    listener.onCompleted();\n+  }\n+\n+  @Override\n+  public void closePreparedStatement(FlightSql.ActionClosePreparedStatementRequest request,\n+                                     CallContext context, StreamListener<Result> listener) {\n+    IntegrationAssertions.assertTrue(\"Expect to be one of the two queries used on tests\",\n+        request.getPreparedStatementHandle().toStringUtf8().equals(\"SELECT PREPARED STATEMENT HANDLE\") ||\n+            request.getPreparedStatementHandle().toStringUtf8().equals(\"UPDATE PREPARED STATEMENT HANDLE\"));\n+\n+    listener.onCompleted();\n+  }\n+\n+  @Override\n+  public FlightInfo getFlightInfoStatement(FlightSql.CommandStatementQuery command,\n+                                           CallContext context, FlightDescriptor descriptor) {\n+    IntegrationAssertions.assertEquals(command.getQuery(), \"SELECT STATEMENT\");\n+\n+    ByteString handle = ByteString.copyFromUtf8(\"SELECT STATEMENT HANDLE\");\n+\n+    FlightSql.TicketStatementQuery ticket = FlightSql.TicketStatementQuery.newBuilder()\n+        .setStatementHandle(handle)\n+        .build();\n+    return getFlightInfoForSchema(ticket, descriptor, getQuerySchema());\n+  }\n+\n+  @Override\n+  public FlightInfo getFlightInfoPreparedStatement(FlightSql.CommandPreparedStatementQuery command,\n+                                                   CallContext context,\n+                                                   FlightDescriptor descriptor) {\n+    IntegrationAssertions.assertEquals(command.getPreparedStatementHandle().toStringUtf8(),\n+        \"SELECT PREPARED STATEMENT HANDLE\");\n+\n+    return getFlightInfoForSchema(command, descriptor, getQuerySchema());\n+  }\n+\n+  @Override\n+  public SchemaResult getSchemaStatement(FlightSql.CommandStatementQuery command,\n+                                         CallContext context, FlightDescriptor descriptor) {\n+    return new SchemaResult(getQuerySchema());\n+  }\n+\n+  @Override\n+  public void getStreamStatement(FlightSql.TicketStatementQuery ticket, CallContext context,\n+                                 ServerStreamListener listener) {\n+    serveJsonToStreamListener(listener, getQuerySchema());\n+  }\n+\n+  @Override\n+  public void getStreamPreparedStatement(FlightSql.CommandPreparedStatementQuery command,\n+                                         CallContext context, ServerStreamListener listener) {\n+    serveJsonToStreamListener(listener, getQuerySchema());\n+  }\n+\n+  private Runnable acceptPutReturnConstant(StreamListener<PutResult> ackStream, int value) {\n+    return () -> {\n+      final FlightSql.DoPutUpdateResult build =\n+          FlightSql.DoPutUpdateResult.newBuilder().setRecordCount(value).build();\n+\n+      try (final ArrowBuf buffer = allocator.buffer(build.getSerializedSize())) {\n+        buffer.writeBytes(build.toByteArray());\n+        ackStream.onNext(PutResult.metadata(buffer));\n+        ackStream.onCompleted();\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public Runnable acceptPutStatement(FlightSql.CommandStatementUpdate command, CallContext context,\n+                                     FlightStream flightStream,\n+                                     StreamListener<PutResult> ackStream) {\n+    IntegrationAssertions.assertEquals(command.getQuery(), \"UPDATE STATEMENT\");\n+\n+    return acceptPutReturnConstant(ackStream, 10000);\n+  }\n+\n+  @Override\n+  public Runnable acceptPutPreparedStatementUpdate(FlightSql.CommandPreparedStatementUpdate command,\n+                                                   CallContext context, FlightStream flightStream,\n+                                                   StreamListener<PutResult> ackStream) {\n+    IntegrationAssertions.assertEquals(command.getPreparedStatementHandle().toStringUtf8(),\n+        \"UPDATE PREPARED STATEMENT HANDLE\");\n+\n+    return acceptPutReturnConstant(ackStream, 20000);\n+  }\n+\n+  @Override\n+  public Runnable acceptPutPreparedStatementQuery(FlightSql.CommandPreparedStatementQuery command,\n+                                                  CallContext context, FlightStream flightStream,\n+                                                  StreamListener<PutResult> ackStream) {\n+    IntegrationAssertions.assertEquals(command.getPreparedStatementHandle(),\n+        \"SELECT PREPARED STATEMENT HANDLE\");\n+\n+    return null;\n\nReview comment:\n       Hmm, this should throw an exception if it's not implemented.\n\n##########\nFile path: java/flight/flight-integration-tests/src/main/java/org/apache/arrow/flight/integration/tests/FlightSqlScenarioProducer.java\n##########\n@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.integration.tests;\n+\n+import static com.google.protobuf.Any.pack;\n+import static java.util.Collections.singletonList;\n+\n+import java.util.List;\n+\n+import org.apache.arrow.flight.Criteria;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightEndpoint;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.FlightSqlProducer;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Message;\n+\n+/**\n+ * Hardcoded Flight SQL producer used for cross-language integration tests.\n+ */\n+public class FlightSqlScenarioProducer implements FlightSqlProducer {\n+  private final BufferAllocator allocator;\n+\n+  public FlightSqlScenarioProducer(BufferAllocator allocator) {\n+    this.allocator = allocator;\n+  }\n+\n+  static Schema getQuerySchema() {\n\nReview comment:\n       Can we explicitly document this as the schema returned for a mock select query (both here and in C++)?\n\n##########\nFile path: cpp/src/arrow/flight/integration_tests/CMakeLists.txt\n##########\n@@ -0,0 +1,47 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+add_custom_target(arrow_flight_integration_tests)\n\nReview comment:\n       Is the target necessary?\n\n##########\nFile path: cpp/src/arrow/flight/integration_tests/test_integration.cc\n##########\n@@ -0,0 +1,665 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/integration_tests/test_integration.h\"\n+#include \"arrow/flight/client_middleware.h\"\n+#include \"arrow/flight/server_middleware.h\"\n+#include \"arrow/flight/sql/client.h\"\n+#include \"arrow/flight/sql/server.h\"\n+#include \"arrow/flight/test_util.h\"\n+#include \"arrow/flight/types.h\"\n+#include \"arrow/ipc/dictionary.h\"\n+\n+#include <arrow/testing/gtest_util.h>\n+#include <arrow/testing/json_integration.h>\n+#include <iostream>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+namespace arrow {\n+namespace flight {\n+namespace integration_tests {\n+\n+/// \\brief The server for the basic auth integration test.\n+class AuthBasicProtoServer : public FlightServerBase {\n+  Status DoAction(const ServerCallContext& context, const Action& action,\n+                  std::unique_ptr<ResultStream>* result) override {\n+    // Respond with the authenticated username.\n+    auto buf = Buffer::FromString(context.peer_identity());\n+    *result = std::unique_ptr<ResultStream>(new SimpleResultStream({Result{buf}}));\n+    return Status::OK();\n+  }\n+};\n+\n+/// Validate the result of a DoAction.\n+Status CheckActionResults(FlightClient* client, const Action& action,\n+                          std::vector<std::string> results) {\n+  std::unique_ptr<ResultStream> stream;\n+  RETURN_NOT_OK(client->DoAction(action, &stream));\n+  std::unique_ptr<Result> result;\n+  for (const std::string& expected : results) {\n+    RETURN_NOT_OK(stream->Next(&result));\n+    if (!result) {\n+      return Status::Invalid(\"Action result stream ended early\");\n+    }\n+    const auto actual = result->body->ToString();\n+    if (expected != actual) {\n+      return Status::Invalid(\"Got wrong result; expected\", expected, \"but got\", actual);\n+    }\n+  }\n+  RETURN_NOT_OK(stream->Next(&result));\n+  if (result) {\n+    return Status::Invalid(\"Action result stream had too many entries\");\n+  }\n+  return Status::OK();\n+}\n+\n+// The expected username for the basic auth integration test.\n+constexpr auto kAuthUsername = \"arrow\";\n+// The expected password for the basic auth integration test.\n+constexpr auto kAuthPassword = \"flight\";\n+\n+/// \\brief A scenario testing the basic auth protobuf.\n+class AuthBasicProtoScenario : public Scenario {\n+  Status MakeServer(std::unique_ptr<FlightServerBase>* server,\n+                    FlightServerOptions* options) override {\n+    server->reset(new AuthBasicProtoServer());\n+    options->auth_handler =\n+        std::make_shared<TestServerBasicAuthHandler>(kAuthUsername, kAuthPassword);\n+    return Status::OK();\n+  }\n+\n+  Status MakeClient(FlightClientOptions* options) override { return Status::OK(); }\n+\n+  Status RunClient(std::unique_ptr<FlightClient> client) override {\n+    Action action;\n+    std::unique_ptr<ResultStream> stream;\n+    std::shared_ptr<FlightStatusDetail> detail;\n+    const auto& status = client->DoAction(action, &stream);\n+    detail = FlightStatusDetail::UnwrapStatus(status);\n+    // This client is unauthenticated and should fail.\n+    if (detail == nullptr) {\n+      return Status::Invalid(\"Expected UNAUTHENTICATED but got \", status.ToString());\n+    }\n+    if (detail->code() != FlightStatusCode::Unauthenticated) {\n+      return Status::Invalid(\"Expected UNAUTHENTICATED but got \", detail->ToString());\n+    }\n+\n+    auto client_handler = std::unique_ptr<ClientAuthHandler>(\n+        new TestClientBasicAuthHandler(kAuthUsername, kAuthPassword));\n+    RETURN_NOT_OK(client->Authenticate({}, std::move(client_handler)));\n+    return CheckActionResults(client.get(), action, {kAuthUsername});\n+  }\n+};\n+\n+/// \\brief Test middleware that echoes back the value of a particular\n+/// incoming header.\n+///\n+/// In Java, gRPC may consolidate this header with HTTP/2 trailers if\n+/// the call fails, but C++ generally doesn't do this. The integration\n+/// test confirms the presence of this header to ensure we can read it\n+/// regardless of what gRPC does.\n+class TestServerMiddleware : public ServerMiddleware {\n+ public:\n+  explicit TestServerMiddleware(std::string received) : received_(received) {}\n+\n+  void SendingHeaders(AddCallHeaders* outgoing_headers) override {\n+    outgoing_headers->AddHeader(\"x-middleware\", received_);\n+  }\n+\n+  void CallCompleted(const Status& status) override {}\n+\n+  std::string name() const override { return \"GrpcTrailersMiddleware\"; }\n+\n+ private:\n+  std::string received_;\n+};\n+\n+class TestServerMiddlewareFactory : public ServerMiddlewareFactory {\n+ public:\n+  Status StartCall(const CallInfo& info, const CallHeaders& incoming_headers,\n+                   std::shared_ptr<ServerMiddleware>* middleware) override {\n+    const std::pair<CallHeaders::const_iterator, CallHeaders::const_iterator>& iter_pair =\n+        incoming_headers.equal_range(\"x-middleware\");\n+    std::string received = \"\";\n+    if (iter_pair.first != iter_pair.second) {\n+      const util::string_view& value = (*iter_pair.first).second;\n+      received = std::string(value);\n+    }\n+    *middleware = std::make_shared<TestServerMiddleware>(received);\n+    return Status::OK();\n+  }\n+};\n+\n+/// \\brief Test middleware that adds a header on every outgoing call,\n+/// and gets the value of the expected header sent by the server.\n+class TestClientMiddleware : public ClientMiddleware {\n+ public:\n+  explicit TestClientMiddleware(std::string* received_header)\n+      : received_header_(received_header) {}\n+\n+  void SendingHeaders(AddCallHeaders* outgoing_headers) {\n+    outgoing_headers->AddHeader(\"x-middleware\", \"expected value\");\n+  }\n+\n+  void ReceivedHeaders(const CallHeaders& incoming_headers) {\n+    // We expect the server to always send this header. gRPC/Java may\n+    // send it in trailers instead of headers, so we expect Flight to\n+    // account for this.\n+    const std::pair<CallHeaders::const_iterator, CallHeaders::const_iterator>& iter_pair =\n+        incoming_headers.equal_range(\"x-middleware\");\n+    if (iter_pair.first != iter_pair.second) {\n+      const util::string_view& value = (*iter_pair.first).second;\n+      *received_header_ = std::string(value);\n+    }\n+  }\n+\n+  void CallCompleted(const Status& status) {}\n+\n+ private:\n+  std::string* received_header_;\n+};\n+\n+class TestClientMiddlewareFactory : public ClientMiddlewareFactory {\n+ public:\n+  void StartCall(const CallInfo& info, std::unique_ptr<ClientMiddleware>* middleware) {\n+    *middleware =\n+        std::unique_ptr<ClientMiddleware>(new TestClientMiddleware(&received_header_));\n+  }\n+\n+  std::string received_header_;\n+};\n+\n+/// \\brief The server used for testing middleware. Implements only one\n+/// endpoint, GetFlightInfo, in such a way that it either succeeds or\n+/// returns an error based on the input, in order to test both paths.\n+class MiddlewareServer : public FlightServerBase {\n+  Status GetFlightInfo(const ServerCallContext& context,\n+                       const FlightDescriptor& descriptor,\n+                       std::unique_ptr<FlightInfo>* result) override {\n+    if (descriptor.type == FlightDescriptor::DescriptorType::CMD &&\n+        descriptor.cmd == \"success\") {\n+      // Don't fail\n+      std::shared_ptr<Schema> schema = arrow::schema({});\n+      Location location;\n+      // Return a fake location - the test doesn't read it\n+      RETURN_NOT_OK(Location::ForGrpcTcp(\"localhost\", 10010, &location));\n+      std::vector<FlightEndpoint> endpoints{FlightEndpoint{{\"foo\"}, {location}}};\n+      ARROW_ASSIGN_OR_RAISE(auto info,\n+                            FlightInfo::Make(*schema, descriptor, endpoints, -1, -1));\n+      *result = std::unique_ptr<FlightInfo>(new FlightInfo(info));\n+      return Status::OK();\n+    }\n+    // Fail the call immediately. In some gRPC implementations, this\n+    // means that gRPC sends only HTTP/2 trailers and not headers. We want\n+    // Flight middleware to be agnostic to this difference.\n+    return Status::UnknownError(\"Unknown\");\n+  }\n+};\n+\n+/// \\brief The middleware scenario.\n+///\n+/// This tests that the server and client get expected header values.\n+class MiddlewareScenario : public Scenario {\n+  Status MakeServer(std::unique_ptr<FlightServerBase>* server,\n+                    FlightServerOptions* options) override {\n+    options->middleware.push_back(\n+        {\"grpc_trailers\", std::make_shared<TestServerMiddlewareFactory>()});\n+    server->reset(new MiddlewareServer());\n+    return Status::OK();\n+  }\n+\n+  Status MakeClient(FlightClientOptions* options) override {\n+    client_middleware_ = std::make_shared<TestClientMiddlewareFactory>();\n+    options->middleware.push_back(client_middleware_);\n+    return Status::OK();\n+  }\n+\n+  Status RunClient(std::unique_ptr<FlightClient> client) override {\n+    std::unique_ptr<FlightInfo> info;\n+    // This call is expected to fail. In gRPC/Java, this causes the\n+    // server to combine headers and HTTP/2 trailers, so to read the\n+    // expected header, Flight must check for both headers and\n+    // trailers.\n+    if (client->GetFlightInfo(FlightDescriptor::Command(\"\"), &info).ok()) {\n+      return Status::Invalid(\"Expected call to fail\");\n+    }\n+    if (client_middleware_->received_header_ != \"expected value\") {\n+      return Status::Invalid(\n+          \"Expected to receive header 'x-middleware: expected value', but instead got: '\",\n+          client_middleware_->received_header_, \"'\");\n+    }\n+    std::cerr << \"Headers received successfully on failing call.\" << std::endl;\n+\n+    // This call should succeed\n+    client_middleware_->received_header_ = \"\";\n+    RETURN_NOT_OK(client->GetFlightInfo(FlightDescriptor::Command(\"success\"), &info));\n+    if (client_middleware_->received_header_ != \"expected value\") {\n+      return Status::Invalid(\n+          \"Expected to receive header 'x-middleware: expected value', but instead got '\",\n+          client_middleware_->received_header_, \"'\");\n+    }\n+    std::cerr << \"Headers received successfully on passing call.\" << std::endl;\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<TestClientMiddlewareFactory> client_middleware_;\n+};\n+\n+std::shared_ptr<Schema> GetQuerySchema() {\n+  return arrow::schema({arrow::field(\"id\", int64())});\n+}\n+\n+template <typename T>\n+arrow::Status AssertEq(const T& expected, const T& actual) {\n+  if (expected != actual) {\n+    return Status::Invalid(\"Expected \\\"\", expected, \"\\\", got \\'\", actual, \"\\\"\");\n+  }\n+  return Status::OK();\n+}\n+\n+/// \\brief The server used for testing Flight SQL, this implements a static Flight SQL server which only asserts\n+/// that commands called during integration tests are being parsed correctly and returns the expected schemas to be\n+/// validated on client.\n+class FlightSqlScenarioServer : public sql::FlightSqlServerBase {\n+ public:\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoStatement(\n+      const ServerCallContext& context, const sql::StatementQuery& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"SELECT STATEMENT\", command.query));\n+\n+    ARROW_ASSIGN_OR_RAISE(auto handle,\n+                          sql::CreateStatementQueryTicket(\"SELECT STATEMENT HANDLE\"));\n+\n+    std::vector<FlightEndpoint> endpoints{FlightEndpoint{{handle}, {}}};\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto result, FlightInfo::Make(*GetQuerySchema(), descriptor, endpoints, -1, -1))\n+\n+    return std::unique_ptr<FlightInfo>(new FlightInfo(result));\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetStatement(\n+      const ServerCallContext& context,\n+      const sql::StatementQueryTicket& command) override {\n+    return DoGetForTestCase(GetQuerySchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoPreparedStatement(\n+      const ServerCallContext& context, const sql::PreparedStatementQuery& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"SELECT PREPARED STATEMENT HANDLE\",\n+                                              command.prepared_statement_handle));\n+\n+    return GetFlightInfoForCommand(descriptor, GetQuerySchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetPreparedStatement(\n+      const ServerCallContext& context,\n+      const sql::PreparedStatementQuery& command) override {\n+    return DoGetForTestCase(GetQuerySchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoCatalogs(\n+      const ServerCallContext& context, const FlightDescriptor& descriptor) override {\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetCatalogsSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetCatalogs(\n+      const ServerCallContext& context) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetCatalogsSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoSqlInfo(\n+      const ServerCallContext& context, const sql::GetSqlInfo& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(2, command.info.size()));\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(\n+        sql::SqlInfoOptions::SqlInfo::FLIGHT_SQL_SERVER_NAME, command.info[0]));\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(\n+        sql::SqlInfoOptions::SqlInfo::FLIGHT_SQL_SERVER_READ_ONLY, command.info[1]));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetSqlInfoSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetSqlInfo(\n+      const ServerCallContext& context, const sql::GetSqlInfo& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetSqlInfoSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoSchemas(\n+      const ServerCallContext& context, const sql::GetDbSchemas& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"catalog\", command.catalog.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"db_schema_filter_pattern\",\n+                                              command.db_schema_filter_pattern.value()));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetDbSchemasSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetDbSchemas(\n+      const ServerCallContext& context, const sql::GetDbSchemas& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetDbSchemasSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoTables(\n+      const ServerCallContext& context, const sql::GetTables& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"catalog\", command.catalog.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"db_schema_filter_pattern\",\n+                                              command.db_schema_filter_pattern.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table_filter_pattern\",\n+                                              command.table_name_filter_pattern.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(2, command.table_types.size()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_types[0]));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"view\", command.table_types[1]));\n+    ARROW_RETURN_NOT_OK(AssertEq<bool>(true, command.include_schema));\n+\n+    return GetFlightInfoForCommand(descriptor,\n+                                   sql::SqlSchema::GetTablesSchemaWithIncludedSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetTables(\n+      const ServerCallContext& context, const sql::GetTables& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetTablesSchemaWithIncludedSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoTableTypes(\n+      const ServerCallContext& context, const FlightDescriptor& descriptor) override {\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetTableTypesSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetTableTypes(\n+      const ServerCallContext& context) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetTableTypesSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoPrimaryKeys(\n+      const ServerCallContext& context, const sql::GetPrimaryKeys& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"catalog\", command.table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"db_schema\", command.table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetPrimaryKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetPrimaryKeys(\n+      const ServerCallContext& context, const sql::GetPrimaryKeys& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetPrimaryKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoExportedKeys(\n+      const ServerCallContext& context, const sql::GetExportedKeys& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"catalog\", command.table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"db_schema\", command.table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetExportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetExportedKeys(\n+      const ServerCallContext& context, const sql::GetExportedKeys& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetExportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoImportedKeys(\n+      const ServerCallContext& context, const sql::GetImportedKeys& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"catalog\", command.table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"db_schema\", command.table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetImportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetImportedKeys(\n+      const ServerCallContext& context, const sql::GetImportedKeys& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetImportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoCrossReference(\n+      const ServerCallContext& context, const sql::GetCrossReference& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"pk_catalog\", command.pk_table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"pk_db_schema\", command.pk_table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"pk_table\", command.pk_table_ref.table));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"fk_catalog\", command.fk_table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"fk_db_schema\", command.fk_table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"fk_table\", command.fk_table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetTableTypesSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetCrossReference(\n+      const ServerCallContext& context, const sql::GetCrossReference& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetCrossReferenceSchema());\n+  }\n+\n+  arrow::Result<int64_t> DoPutCommandStatementUpdate(\n+      const ServerCallContext& context, const sql::StatementUpdate& command) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"UPDATE STATEMENT\", command.query));\n+\n+    return 10000;\n+  }\n+\n+  arrow::Result<sql::ActionCreatePreparedStatementResult> CreatePreparedStatement(\n+      const ServerCallContext& context,\n+      const sql::ActionCreatePreparedStatementRequest& request) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<bool>(true, request.query == \"SELECT PREPARED STATEMENT\" ||\n+                                 request.query == \"UPDATE PREPARED STATEMENT\"));\n+\n+    sql::ActionCreatePreparedStatementResult result;\n+    result.prepared_statement_handle = request.query + \" HANDLE\";\n+\n+    return result;\n+  }\n+\n+  Status ClosePreparedStatement(\n+      const ServerCallContext& context,\n+      const sql::ActionClosePreparedStatementRequest& request) override {\n+    return Status::OK();\n+  }\n+\n+  Status DoPutPreparedStatementQuery(const ServerCallContext& context,\n+                                     const sql::PreparedStatementQuery& command,\n+                                     FlightMessageReader* reader,\n+                                     FlightMetadataWriter* writer) override {\n+    return Status::NotImplemented(\"Not implemented\");\n+  }\n+\n+  arrow::Result<int64_t> DoPutPreparedStatementUpdate(\n+      const ServerCallContext& context, const sql::PreparedStatementUpdate& command,\n+      FlightMessageReader* reader) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"UPDATE PREPARED STATEMENT HANDLE\",\n+                                              command.prepared_statement_handle));\n+\n+    return 20000;\n+  }\n+\n+ private:\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoForCommand(\n+      const FlightDescriptor& descriptor, const std::shared_ptr<Schema>& schema) {\n+    std::vector<FlightEndpoint> endpoints{FlightEndpoint{{descriptor.cmd}, {}}};\n+    ARROW_ASSIGN_OR_RAISE(auto result,\n+                          FlightInfo::Make(*schema, descriptor, endpoints, -1, -1))\n+\n+    return std::unique_ptr<FlightInfo>(new FlightInfo(result));\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetForTestCase(\n+      std::shared_ptr<Schema> schema) {\n+    ARROW_ASSIGN_OR_RAISE(auto reader2, RecordBatchReader::Make({}, schema));\n\nReview comment:\n       Also, why is it `reader2`?\n\n##########\nFile path: cpp/src/arrow/flight/integration_tests/test_integration.cc\n##########\n@@ -0,0 +1,665 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/integration_tests/test_integration.h\"\n+#include \"arrow/flight/client_middleware.h\"\n+#include \"arrow/flight/server_middleware.h\"\n+#include \"arrow/flight/sql/client.h\"\n+#include \"arrow/flight/sql/server.h\"\n+#include \"arrow/flight/test_util.h\"\n+#include \"arrow/flight/types.h\"\n+#include \"arrow/ipc/dictionary.h\"\n+\n+#include <arrow/testing/gtest_util.h>\n+#include <arrow/testing/json_integration.h>\n+#include <iostream>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+namespace arrow {\n+namespace flight {\n+namespace integration_tests {\n+\n+/// \\brief The server for the basic auth integration test.\n+class AuthBasicProtoServer : public FlightServerBase {\n+  Status DoAction(const ServerCallContext& context, const Action& action,\n+                  std::unique_ptr<ResultStream>* result) override {\n+    // Respond with the authenticated username.\n+    auto buf = Buffer::FromString(context.peer_identity());\n+    *result = std::unique_ptr<ResultStream>(new SimpleResultStream({Result{buf}}));\n+    return Status::OK();\n+  }\n+};\n+\n+/// Validate the result of a DoAction.\n+Status CheckActionResults(FlightClient* client, const Action& action,\n+                          std::vector<std::string> results) {\n+  std::unique_ptr<ResultStream> stream;\n+  RETURN_NOT_OK(client->DoAction(action, &stream));\n+  std::unique_ptr<Result> result;\n+  for (const std::string& expected : results) {\n+    RETURN_NOT_OK(stream->Next(&result));\n+    if (!result) {\n+      return Status::Invalid(\"Action result stream ended early\");\n+    }\n+    const auto actual = result->body->ToString();\n+    if (expected != actual) {\n+      return Status::Invalid(\"Got wrong result; expected\", expected, \"but got\", actual);\n+    }\n+  }\n+  RETURN_NOT_OK(stream->Next(&result));\n+  if (result) {\n+    return Status::Invalid(\"Action result stream had too many entries\");\n+  }\n+  return Status::OK();\n+}\n+\n+// The expected username for the basic auth integration test.\n+constexpr auto kAuthUsername = \"arrow\";\n+// The expected password for the basic auth integration test.\n+constexpr auto kAuthPassword = \"flight\";\n+\n+/// \\brief A scenario testing the basic auth protobuf.\n+class AuthBasicProtoScenario : public Scenario {\n+  Status MakeServer(std::unique_ptr<FlightServerBase>* server,\n+                    FlightServerOptions* options) override {\n+    server->reset(new AuthBasicProtoServer());\n+    options->auth_handler =\n+        std::make_shared<TestServerBasicAuthHandler>(kAuthUsername, kAuthPassword);\n+    return Status::OK();\n+  }\n+\n+  Status MakeClient(FlightClientOptions* options) override { return Status::OK(); }\n+\n+  Status RunClient(std::unique_ptr<FlightClient> client) override {\n+    Action action;\n+    std::unique_ptr<ResultStream> stream;\n+    std::shared_ptr<FlightStatusDetail> detail;\n+    const auto& status = client->DoAction(action, &stream);\n+    detail = FlightStatusDetail::UnwrapStatus(status);\n+    // This client is unauthenticated and should fail.\n+    if (detail == nullptr) {\n+      return Status::Invalid(\"Expected UNAUTHENTICATED but got \", status.ToString());\n+    }\n+    if (detail->code() != FlightStatusCode::Unauthenticated) {\n+      return Status::Invalid(\"Expected UNAUTHENTICATED but got \", detail->ToString());\n+    }\n+\n+    auto client_handler = std::unique_ptr<ClientAuthHandler>(\n+        new TestClientBasicAuthHandler(kAuthUsername, kAuthPassword));\n+    RETURN_NOT_OK(client->Authenticate({}, std::move(client_handler)));\n+    return CheckActionResults(client.get(), action, {kAuthUsername});\n+  }\n+};\n+\n+/// \\brief Test middleware that echoes back the value of a particular\n+/// incoming header.\n+///\n+/// In Java, gRPC may consolidate this header with HTTP/2 trailers if\n+/// the call fails, but C++ generally doesn't do this. The integration\n+/// test confirms the presence of this header to ensure we can read it\n+/// regardless of what gRPC does.\n+class TestServerMiddleware : public ServerMiddleware {\n+ public:\n+  explicit TestServerMiddleware(std::string received) : received_(received) {}\n+\n+  void SendingHeaders(AddCallHeaders* outgoing_headers) override {\n+    outgoing_headers->AddHeader(\"x-middleware\", received_);\n+  }\n+\n+  void CallCompleted(const Status& status) override {}\n+\n+  std::string name() const override { return \"GrpcTrailersMiddleware\"; }\n+\n+ private:\n+  std::string received_;\n+};\n+\n+class TestServerMiddlewareFactory : public ServerMiddlewareFactory {\n+ public:\n+  Status StartCall(const CallInfo& info, const CallHeaders& incoming_headers,\n+                   std::shared_ptr<ServerMiddleware>* middleware) override {\n+    const std::pair<CallHeaders::const_iterator, CallHeaders::const_iterator>& iter_pair =\n+        incoming_headers.equal_range(\"x-middleware\");\n+    std::string received = \"\";\n+    if (iter_pair.first != iter_pair.second) {\n+      const util::string_view& value = (*iter_pair.first).second;\n+      received = std::string(value);\n+    }\n+    *middleware = std::make_shared<TestServerMiddleware>(received);\n+    return Status::OK();\n+  }\n+};\n+\n+/// \\brief Test middleware that adds a header on every outgoing call,\n+/// and gets the value of the expected header sent by the server.\n+class TestClientMiddleware : public ClientMiddleware {\n+ public:\n+  explicit TestClientMiddleware(std::string* received_header)\n+      : received_header_(received_header) {}\n+\n+  void SendingHeaders(AddCallHeaders* outgoing_headers) {\n+    outgoing_headers->AddHeader(\"x-middleware\", \"expected value\");\n+  }\n+\n+  void ReceivedHeaders(const CallHeaders& incoming_headers) {\n+    // We expect the server to always send this header. gRPC/Java may\n+    // send it in trailers instead of headers, so we expect Flight to\n+    // account for this.\n+    const std::pair<CallHeaders::const_iterator, CallHeaders::const_iterator>& iter_pair =\n+        incoming_headers.equal_range(\"x-middleware\");\n+    if (iter_pair.first != iter_pair.second) {\n+      const util::string_view& value = (*iter_pair.first).second;\n+      *received_header_ = std::string(value);\n+    }\n+  }\n+\n+  void CallCompleted(const Status& status) {}\n+\n+ private:\n+  std::string* received_header_;\n+};\n+\n+class TestClientMiddlewareFactory : public ClientMiddlewareFactory {\n+ public:\n+  void StartCall(const CallInfo& info, std::unique_ptr<ClientMiddleware>* middleware) {\n+    *middleware =\n+        std::unique_ptr<ClientMiddleware>(new TestClientMiddleware(&received_header_));\n+  }\n+\n+  std::string received_header_;\n+};\n+\n+/// \\brief The server used for testing middleware. Implements only one\n+/// endpoint, GetFlightInfo, in such a way that it either succeeds or\n+/// returns an error based on the input, in order to test both paths.\n+class MiddlewareServer : public FlightServerBase {\n+  Status GetFlightInfo(const ServerCallContext& context,\n+                       const FlightDescriptor& descriptor,\n+                       std::unique_ptr<FlightInfo>* result) override {\n+    if (descriptor.type == FlightDescriptor::DescriptorType::CMD &&\n+        descriptor.cmd == \"success\") {\n+      // Don't fail\n+      std::shared_ptr<Schema> schema = arrow::schema({});\n+      Location location;\n+      // Return a fake location - the test doesn't read it\n+      RETURN_NOT_OK(Location::ForGrpcTcp(\"localhost\", 10010, &location));\n+      std::vector<FlightEndpoint> endpoints{FlightEndpoint{{\"foo\"}, {location}}};\n+      ARROW_ASSIGN_OR_RAISE(auto info,\n+                            FlightInfo::Make(*schema, descriptor, endpoints, -1, -1));\n+      *result = std::unique_ptr<FlightInfo>(new FlightInfo(info));\n+      return Status::OK();\n+    }\n+    // Fail the call immediately. In some gRPC implementations, this\n+    // means that gRPC sends only HTTP/2 trailers and not headers. We want\n+    // Flight middleware to be agnostic to this difference.\n+    return Status::UnknownError(\"Unknown\");\n+  }\n+};\n+\n+/// \\brief The middleware scenario.\n+///\n+/// This tests that the server and client get expected header values.\n+class MiddlewareScenario : public Scenario {\n+  Status MakeServer(std::unique_ptr<FlightServerBase>* server,\n+                    FlightServerOptions* options) override {\n+    options->middleware.push_back(\n+        {\"grpc_trailers\", std::make_shared<TestServerMiddlewareFactory>()});\n+    server->reset(new MiddlewareServer());\n+    return Status::OK();\n+  }\n+\n+  Status MakeClient(FlightClientOptions* options) override {\n+    client_middleware_ = std::make_shared<TestClientMiddlewareFactory>();\n+    options->middleware.push_back(client_middleware_);\n+    return Status::OK();\n+  }\n+\n+  Status RunClient(std::unique_ptr<FlightClient> client) override {\n+    std::unique_ptr<FlightInfo> info;\n+    // This call is expected to fail. In gRPC/Java, this causes the\n+    // server to combine headers and HTTP/2 trailers, so to read the\n+    // expected header, Flight must check for both headers and\n+    // trailers.\n+    if (client->GetFlightInfo(FlightDescriptor::Command(\"\"), &info).ok()) {\n+      return Status::Invalid(\"Expected call to fail\");\n+    }\n+    if (client_middleware_->received_header_ != \"expected value\") {\n+      return Status::Invalid(\n+          \"Expected to receive header 'x-middleware: expected value', but instead got: '\",\n+          client_middleware_->received_header_, \"'\");\n+    }\n+    std::cerr << \"Headers received successfully on failing call.\" << std::endl;\n+\n+    // This call should succeed\n+    client_middleware_->received_header_ = \"\";\n+    RETURN_NOT_OK(client->GetFlightInfo(FlightDescriptor::Command(\"success\"), &info));\n+    if (client_middleware_->received_header_ != \"expected value\") {\n+      return Status::Invalid(\n+          \"Expected to receive header 'x-middleware: expected value', but instead got '\",\n+          client_middleware_->received_header_, \"'\");\n+    }\n+    std::cerr << \"Headers received successfully on passing call.\" << std::endl;\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<TestClientMiddlewareFactory> client_middleware_;\n+};\n+\n+std::shared_ptr<Schema> GetQuerySchema() {\n+  return arrow::schema({arrow::field(\"id\", int64())});\n+}\n+\n+template <typename T>\n+arrow::Status AssertEq(const T& expected, const T& actual) {\n+  if (expected != actual) {\n+    return Status::Invalid(\"Expected \\\"\", expected, \"\\\", got \\'\", actual, \"\\\"\");\n+  }\n+  return Status::OK();\n+}\n+\n+/// \\brief The server used for testing Flight SQL, this implements a static Flight SQL server which only asserts\n+/// that commands called during integration tests are being parsed correctly and returns the expected schemas to be\n+/// validated on client.\n+class FlightSqlScenarioServer : public sql::FlightSqlServerBase {\n+ public:\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoStatement(\n+      const ServerCallContext& context, const sql::StatementQuery& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"SELECT STATEMENT\", command.query));\n+\n+    ARROW_ASSIGN_OR_RAISE(auto handle,\n+                          sql::CreateStatementQueryTicket(\"SELECT STATEMENT HANDLE\"));\n+\n+    std::vector<FlightEndpoint> endpoints{FlightEndpoint{{handle}, {}}};\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto result, FlightInfo::Make(*GetQuerySchema(), descriptor, endpoints, -1, -1))\n+\n+    return std::unique_ptr<FlightInfo>(new FlightInfo(result));\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetStatement(\n+      const ServerCallContext& context,\n+      const sql::StatementQueryTicket& command) override {\n+    return DoGetForTestCase(GetQuerySchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoPreparedStatement(\n+      const ServerCallContext& context, const sql::PreparedStatementQuery& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"SELECT PREPARED STATEMENT HANDLE\",\n+                                              command.prepared_statement_handle));\n+\n+    return GetFlightInfoForCommand(descriptor, GetQuerySchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetPreparedStatement(\n+      const ServerCallContext& context,\n+      const sql::PreparedStatementQuery& command) override {\n+    return DoGetForTestCase(GetQuerySchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoCatalogs(\n+      const ServerCallContext& context, const FlightDescriptor& descriptor) override {\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetCatalogsSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetCatalogs(\n+      const ServerCallContext& context) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetCatalogsSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoSqlInfo(\n+      const ServerCallContext& context, const sql::GetSqlInfo& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(2, command.info.size()));\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(\n+        sql::SqlInfoOptions::SqlInfo::FLIGHT_SQL_SERVER_NAME, command.info[0]));\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(\n+        sql::SqlInfoOptions::SqlInfo::FLIGHT_SQL_SERVER_READ_ONLY, command.info[1]));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetSqlInfoSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetSqlInfo(\n+      const ServerCallContext& context, const sql::GetSqlInfo& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetSqlInfoSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoSchemas(\n+      const ServerCallContext& context, const sql::GetDbSchemas& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"catalog\", command.catalog.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"db_schema_filter_pattern\",\n+                                              command.db_schema_filter_pattern.value()));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetDbSchemasSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetDbSchemas(\n+      const ServerCallContext& context, const sql::GetDbSchemas& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetDbSchemasSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoTables(\n+      const ServerCallContext& context, const sql::GetTables& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"catalog\", command.catalog.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"db_schema_filter_pattern\",\n+                                              command.db_schema_filter_pattern.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table_filter_pattern\",\n+                                              command.table_name_filter_pattern.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(2, command.table_types.size()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_types[0]));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"view\", command.table_types[1]));\n+    ARROW_RETURN_NOT_OK(AssertEq<bool>(true, command.include_schema));\n+\n+    return GetFlightInfoForCommand(descriptor,\n+                                   sql::SqlSchema::GetTablesSchemaWithIncludedSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetTables(\n+      const ServerCallContext& context, const sql::GetTables& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetTablesSchemaWithIncludedSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoTableTypes(\n+      const ServerCallContext& context, const FlightDescriptor& descriptor) override {\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetTableTypesSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetTableTypes(\n+      const ServerCallContext& context) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetTableTypesSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoPrimaryKeys(\n+      const ServerCallContext& context, const sql::GetPrimaryKeys& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"catalog\", command.table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"db_schema\", command.table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetPrimaryKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetPrimaryKeys(\n+      const ServerCallContext& context, const sql::GetPrimaryKeys& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetPrimaryKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoExportedKeys(\n+      const ServerCallContext& context, const sql::GetExportedKeys& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"catalog\", command.table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"db_schema\", command.table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetExportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetExportedKeys(\n+      const ServerCallContext& context, const sql::GetExportedKeys& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetExportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoImportedKeys(\n+      const ServerCallContext& context, const sql::GetImportedKeys& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"catalog\", command.table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"db_schema\", command.table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetImportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetImportedKeys(\n+      const ServerCallContext& context, const sql::GetImportedKeys& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetImportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoCrossReference(\n+      const ServerCallContext& context, const sql::GetCrossReference& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"pk_catalog\", command.pk_table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"pk_db_schema\", command.pk_table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"pk_table\", command.pk_table_ref.table));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"fk_catalog\", command.fk_table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"fk_db_schema\", command.fk_table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"fk_table\", command.fk_table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetTableTypesSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetCrossReference(\n+      const ServerCallContext& context, const sql::GetCrossReference& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetCrossReferenceSchema());\n+  }\n+\n+  arrow::Result<int64_t> DoPutCommandStatementUpdate(\n+      const ServerCallContext& context, const sql::StatementUpdate& command) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"UPDATE STATEMENT\", command.query));\n+\n+    return 10000;\n+  }\n+\n+  arrow::Result<sql::ActionCreatePreparedStatementResult> CreatePreparedStatement(\n+      const ServerCallContext& context,\n+      const sql::ActionCreatePreparedStatementRequest& request) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<bool>(true, request.query == \"SELECT PREPARED STATEMENT\" ||\n+                                 request.query == \"UPDATE PREPARED STATEMENT\"));\n+\n+    sql::ActionCreatePreparedStatementResult result;\n+    result.prepared_statement_handle = request.query + \" HANDLE\";\n+\n+    return result;\n+  }\n+\n+  Status ClosePreparedStatement(\n+      const ServerCallContext& context,\n+      const sql::ActionClosePreparedStatementRequest& request) override {\n+    return Status::OK();\n+  }\n+\n+  Status DoPutPreparedStatementQuery(const ServerCallContext& context,\n+                                     const sql::PreparedStatementQuery& command,\n+                                     FlightMessageReader* reader,\n+                                     FlightMetadataWriter* writer) override {\n+    return Status::NotImplemented(\"Not implemented\");\n+  }\n+\n+  arrow::Result<int64_t> DoPutPreparedStatementUpdate(\n+      const ServerCallContext& context, const sql::PreparedStatementUpdate& command,\n+      FlightMessageReader* reader) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"UPDATE PREPARED STATEMENT HANDLE\",\n+                                              command.prepared_statement_handle));\n+\n+    return 20000;\n+  }\n+\n+ private:\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoForCommand(\n+      const FlightDescriptor& descriptor, const std::shared_ptr<Schema>& schema) {\n+    std::vector<FlightEndpoint> endpoints{FlightEndpoint{{descriptor.cmd}, {}}};\n+    ARROW_ASSIGN_OR_RAISE(auto result,\n+                          FlightInfo::Make(*schema, descriptor, endpoints, -1, -1))\n+\n+    return std::unique_ptr<FlightInfo>(new FlightInfo(result));\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetForTestCase(\n+      std::shared_ptr<Schema> schema) {\n+    ARROW_ASSIGN_OR_RAISE(auto reader2, RecordBatchReader::Make({}, schema));\n\nReview comment:\n       nit: `std::move(schema)`? (or declare the parameter as `const&`)\n\n##########\nFile path: cpp/src/arrow/flight/integration_tests/test_integration.cc\n##########\n@@ -0,0 +1,665 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/integration_tests/test_integration.h\"\n+#include \"arrow/flight/client_middleware.h\"\n+#include \"arrow/flight/server_middleware.h\"\n+#include \"arrow/flight/sql/client.h\"\n+#include \"arrow/flight/sql/server.h\"\n+#include \"arrow/flight/test_util.h\"\n+#include \"arrow/flight/types.h\"\n+#include \"arrow/ipc/dictionary.h\"\n+\n+#include <arrow/testing/gtest_util.h>\n+#include <arrow/testing/json_integration.h>\n+#include <iostream>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+namespace arrow {\n+namespace flight {\n+namespace integration_tests {\n+\n+/// \\brief The server for the basic auth integration test.\n+class AuthBasicProtoServer : public FlightServerBase {\n+  Status DoAction(const ServerCallContext& context, const Action& action,\n+                  std::unique_ptr<ResultStream>* result) override {\n+    // Respond with the authenticated username.\n+    auto buf = Buffer::FromString(context.peer_identity());\n+    *result = std::unique_ptr<ResultStream>(new SimpleResultStream({Result{buf}}));\n+    return Status::OK();\n+  }\n+};\n+\n+/// Validate the result of a DoAction.\n+Status CheckActionResults(FlightClient* client, const Action& action,\n+                          std::vector<std::string> results) {\n+  std::unique_ptr<ResultStream> stream;\n+  RETURN_NOT_OK(client->DoAction(action, &stream));\n+  std::unique_ptr<Result> result;\n+  for (const std::string& expected : results) {\n+    RETURN_NOT_OK(stream->Next(&result));\n+    if (!result) {\n+      return Status::Invalid(\"Action result stream ended early\");\n+    }\n+    const auto actual = result->body->ToString();\n+    if (expected != actual) {\n+      return Status::Invalid(\"Got wrong result; expected\", expected, \"but got\", actual);\n+    }\n+  }\n+  RETURN_NOT_OK(stream->Next(&result));\n+  if (result) {\n+    return Status::Invalid(\"Action result stream had too many entries\");\n+  }\n+  return Status::OK();\n+}\n+\n+// The expected username for the basic auth integration test.\n+constexpr auto kAuthUsername = \"arrow\";\n+// The expected password for the basic auth integration test.\n+constexpr auto kAuthPassword = \"flight\";\n+\n+/// \\brief A scenario testing the basic auth protobuf.\n+class AuthBasicProtoScenario : public Scenario {\n+  Status MakeServer(std::unique_ptr<FlightServerBase>* server,\n+                    FlightServerOptions* options) override {\n+    server->reset(new AuthBasicProtoServer());\n+    options->auth_handler =\n+        std::make_shared<TestServerBasicAuthHandler>(kAuthUsername, kAuthPassword);\n+    return Status::OK();\n+  }\n+\n+  Status MakeClient(FlightClientOptions* options) override { return Status::OK(); }\n+\n+  Status RunClient(std::unique_ptr<FlightClient> client) override {\n+    Action action;\n+    std::unique_ptr<ResultStream> stream;\n+    std::shared_ptr<FlightStatusDetail> detail;\n+    const auto& status = client->DoAction(action, &stream);\n+    detail = FlightStatusDetail::UnwrapStatus(status);\n+    // This client is unauthenticated and should fail.\n+    if (detail == nullptr) {\n+      return Status::Invalid(\"Expected UNAUTHENTICATED but got \", status.ToString());\n+    }\n+    if (detail->code() != FlightStatusCode::Unauthenticated) {\n+      return Status::Invalid(\"Expected UNAUTHENTICATED but got \", detail->ToString());\n+    }\n+\n+    auto client_handler = std::unique_ptr<ClientAuthHandler>(\n+        new TestClientBasicAuthHandler(kAuthUsername, kAuthPassword));\n+    RETURN_NOT_OK(client->Authenticate({}, std::move(client_handler)));\n+    return CheckActionResults(client.get(), action, {kAuthUsername});\n+  }\n+};\n+\n+/// \\brief Test middleware that echoes back the value of a particular\n+/// incoming header.\n+///\n+/// In Java, gRPC may consolidate this header with HTTP/2 trailers if\n+/// the call fails, but C++ generally doesn't do this. The integration\n+/// test confirms the presence of this header to ensure we can read it\n+/// regardless of what gRPC does.\n+class TestServerMiddleware : public ServerMiddleware {\n+ public:\n+  explicit TestServerMiddleware(std::string received) : received_(received) {}\n+\n+  void SendingHeaders(AddCallHeaders* outgoing_headers) override {\n+    outgoing_headers->AddHeader(\"x-middleware\", received_);\n+  }\n+\n+  void CallCompleted(const Status& status) override {}\n+\n+  std::string name() const override { return \"GrpcTrailersMiddleware\"; }\n+\n+ private:\n+  std::string received_;\n+};\n+\n+class TestServerMiddlewareFactory : public ServerMiddlewareFactory {\n+ public:\n+  Status StartCall(const CallInfo& info, const CallHeaders& incoming_headers,\n+                   std::shared_ptr<ServerMiddleware>* middleware) override {\n+    const std::pair<CallHeaders::const_iterator, CallHeaders::const_iterator>& iter_pair =\n+        incoming_headers.equal_range(\"x-middleware\");\n+    std::string received = \"\";\n+    if (iter_pair.first != iter_pair.second) {\n+      const util::string_view& value = (*iter_pair.first).second;\n+      received = std::string(value);\n+    }\n+    *middleware = std::make_shared<TestServerMiddleware>(received);\n+    return Status::OK();\n+  }\n+};\n+\n+/// \\brief Test middleware that adds a header on every outgoing call,\n+/// and gets the value of the expected header sent by the server.\n+class TestClientMiddleware : public ClientMiddleware {\n+ public:\n+  explicit TestClientMiddleware(std::string* received_header)\n+      : received_header_(received_header) {}\n+\n+  void SendingHeaders(AddCallHeaders* outgoing_headers) {\n+    outgoing_headers->AddHeader(\"x-middleware\", \"expected value\");\n+  }\n+\n+  void ReceivedHeaders(const CallHeaders& incoming_headers) {\n+    // We expect the server to always send this header. gRPC/Java may\n+    // send it in trailers instead of headers, so we expect Flight to\n+    // account for this.\n+    const std::pair<CallHeaders::const_iterator, CallHeaders::const_iterator>& iter_pair =\n+        incoming_headers.equal_range(\"x-middleware\");\n+    if (iter_pair.first != iter_pair.second) {\n+      const util::string_view& value = (*iter_pair.first).second;\n+      *received_header_ = std::string(value);\n+    }\n+  }\n+\n+  void CallCompleted(const Status& status) {}\n+\n+ private:\n+  std::string* received_header_;\n+};\n+\n+class TestClientMiddlewareFactory : public ClientMiddlewareFactory {\n+ public:\n+  void StartCall(const CallInfo& info, std::unique_ptr<ClientMiddleware>* middleware) {\n+    *middleware =\n+        std::unique_ptr<ClientMiddleware>(new TestClientMiddleware(&received_header_));\n+  }\n+\n+  std::string received_header_;\n+};\n+\n+/// \\brief The server used for testing middleware. Implements only one\n+/// endpoint, GetFlightInfo, in such a way that it either succeeds or\n+/// returns an error based on the input, in order to test both paths.\n+class MiddlewareServer : public FlightServerBase {\n+  Status GetFlightInfo(const ServerCallContext& context,\n+                       const FlightDescriptor& descriptor,\n+                       std::unique_ptr<FlightInfo>* result) override {\n+    if (descriptor.type == FlightDescriptor::DescriptorType::CMD &&\n+        descriptor.cmd == \"success\") {\n+      // Don't fail\n+      std::shared_ptr<Schema> schema = arrow::schema({});\n+      Location location;\n+      // Return a fake location - the test doesn't read it\n+      RETURN_NOT_OK(Location::ForGrpcTcp(\"localhost\", 10010, &location));\n+      std::vector<FlightEndpoint> endpoints{FlightEndpoint{{\"foo\"}, {location}}};\n+      ARROW_ASSIGN_OR_RAISE(auto info,\n+                            FlightInfo::Make(*schema, descriptor, endpoints, -1, -1));\n+      *result = std::unique_ptr<FlightInfo>(new FlightInfo(info));\n+      return Status::OK();\n+    }\n+    // Fail the call immediately. In some gRPC implementations, this\n+    // means that gRPC sends only HTTP/2 trailers and not headers. We want\n+    // Flight middleware to be agnostic to this difference.\n+    return Status::UnknownError(\"Unknown\");\n+  }\n+};\n+\n+/// \\brief The middleware scenario.\n+///\n+/// This tests that the server and client get expected header values.\n+class MiddlewareScenario : public Scenario {\n+  Status MakeServer(std::unique_ptr<FlightServerBase>* server,\n+                    FlightServerOptions* options) override {\n+    options->middleware.push_back(\n+        {\"grpc_trailers\", std::make_shared<TestServerMiddlewareFactory>()});\n+    server->reset(new MiddlewareServer());\n+    return Status::OK();\n+  }\n+\n+  Status MakeClient(FlightClientOptions* options) override {\n+    client_middleware_ = std::make_shared<TestClientMiddlewareFactory>();\n+    options->middleware.push_back(client_middleware_);\n+    return Status::OK();\n+  }\n+\n+  Status RunClient(std::unique_ptr<FlightClient> client) override {\n+    std::unique_ptr<FlightInfo> info;\n+    // This call is expected to fail. In gRPC/Java, this causes the\n+    // server to combine headers and HTTP/2 trailers, so to read the\n+    // expected header, Flight must check for both headers and\n+    // trailers.\n+    if (client->GetFlightInfo(FlightDescriptor::Command(\"\"), &info).ok()) {\n+      return Status::Invalid(\"Expected call to fail\");\n+    }\n+    if (client_middleware_->received_header_ != \"expected value\") {\n+      return Status::Invalid(\n+          \"Expected to receive header 'x-middleware: expected value', but instead got: '\",\n+          client_middleware_->received_header_, \"'\");\n+    }\n+    std::cerr << \"Headers received successfully on failing call.\" << std::endl;\n+\n+    // This call should succeed\n+    client_middleware_->received_header_ = \"\";\n+    RETURN_NOT_OK(client->GetFlightInfo(FlightDescriptor::Command(\"success\"), &info));\n+    if (client_middleware_->received_header_ != \"expected value\") {\n+      return Status::Invalid(\n+          \"Expected to receive header 'x-middleware: expected value', but instead got '\",\n+          client_middleware_->received_header_, \"'\");\n+    }\n+    std::cerr << \"Headers received successfully on passing call.\" << std::endl;\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<TestClientMiddlewareFactory> client_middleware_;\n+};\n+\n+std::shared_ptr<Schema> GetQuerySchema() {\n+  return arrow::schema({arrow::field(\"id\", int64())});\n+}\n+\n+template <typename T>\n+arrow::Status AssertEq(const T& expected, const T& actual) {\n+  if (expected != actual) {\n+    return Status::Invalid(\"Expected \\\"\", expected, \"\\\", got \\'\", actual, \"\\\"\");\n+  }\n+  return Status::OK();\n+}\n+\n+/// \\brief The server used for testing Flight SQL, this implements a static Flight SQL server which only asserts\n+/// that commands called during integration tests are being parsed correctly and returns the expected schemas to be\n+/// validated on client.\n+class FlightSqlScenarioServer : public sql::FlightSqlServerBase {\n+ public:\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoStatement(\n+      const ServerCallContext& context, const sql::StatementQuery& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"SELECT STATEMENT\", command.query));\n+\n+    ARROW_ASSIGN_OR_RAISE(auto handle,\n+                          sql::CreateStatementQueryTicket(\"SELECT STATEMENT HANDLE\"));\n+\n+    std::vector<FlightEndpoint> endpoints{FlightEndpoint{{handle}, {}}};\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto result, FlightInfo::Make(*GetQuerySchema(), descriptor, endpoints, -1, -1))\n+\n+    return std::unique_ptr<FlightInfo>(new FlightInfo(result));\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetStatement(\n+      const ServerCallContext& context,\n+      const sql::StatementQueryTicket& command) override {\n+    return DoGetForTestCase(GetQuerySchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoPreparedStatement(\n+      const ServerCallContext& context, const sql::PreparedStatementQuery& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"SELECT PREPARED STATEMENT HANDLE\",\n+                                              command.prepared_statement_handle));\n+\n+    return GetFlightInfoForCommand(descriptor, GetQuerySchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetPreparedStatement(\n+      const ServerCallContext& context,\n+      const sql::PreparedStatementQuery& command) override {\n+    return DoGetForTestCase(GetQuerySchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoCatalogs(\n+      const ServerCallContext& context, const FlightDescriptor& descriptor) override {\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetCatalogsSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetCatalogs(\n+      const ServerCallContext& context) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetCatalogsSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoSqlInfo(\n+      const ServerCallContext& context, const sql::GetSqlInfo& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(2, command.info.size()));\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(\n+        sql::SqlInfoOptions::SqlInfo::FLIGHT_SQL_SERVER_NAME, command.info[0]));\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(\n+        sql::SqlInfoOptions::SqlInfo::FLIGHT_SQL_SERVER_READ_ONLY, command.info[1]));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetSqlInfoSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetSqlInfo(\n+      const ServerCallContext& context, const sql::GetSqlInfo& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetSqlInfoSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoSchemas(\n+      const ServerCallContext& context, const sql::GetDbSchemas& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"catalog\", command.catalog.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"db_schema_filter_pattern\",\n+                                              command.db_schema_filter_pattern.value()));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetDbSchemasSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetDbSchemas(\n+      const ServerCallContext& context, const sql::GetDbSchemas& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetDbSchemasSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoTables(\n+      const ServerCallContext& context, const sql::GetTables& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"catalog\", command.catalog.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"db_schema_filter_pattern\",\n+                                              command.db_schema_filter_pattern.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table_filter_pattern\",\n+                                              command.table_name_filter_pattern.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(2, command.table_types.size()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_types[0]));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"view\", command.table_types[1]));\n+    ARROW_RETURN_NOT_OK(AssertEq<bool>(true, command.include_schema));\n+\n+    return GetFlightInfoForCommand(descriptor,\n+                                   sql::SqlSchema::GetTablesSchemaWithIncludedSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetTables(\n+      const ServerCallContext& context, const sql::GetTables& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetTablesSchemaWithIncludedSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoTableTypes(\n+      const ServerCallContext& context, const FlightDescriptor& descriptor) override {\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetTableTypesSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetTableTypes(\n+      const ServerCallContext& context) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetTableTypesSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoPrimaryKeys(\n+      const ServerCallContext& context, const sql::GetPrimaryKeys& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"catalog\", command.table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"db_schema\", command.table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetPrimaryKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetPrimaryKeys(\n+      const ServerCallContext& context, const sql::GetPrimaryKeys& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetPrimaryKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoExportedKeys(\n+      const ServerCallContext& context, const sql::GetExportedKeys& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"catalog\", command.table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"db_schema\", command.table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetExportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetExportedKeys(\n+      const ServerCallContext& context, const sql::GetExportedKeys& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetExportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoImportedKeys(\n+      const ServerCallContext& context, const sql::GetImportedKeys& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"catalog\", command.table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"db_schema\", command.table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetImportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetImportedKeys(\n+      const ServerCallContext& context, const sql::GetImportedKeys& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetImportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoCrossReference(\n+      const ServerCallContext& context, const sql::GetCrossReference& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"pk_catalog\", command.pk_table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"pk_db_schema\", command.pk_table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"pk_table\", command.pk_table_ref.table));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"fk_catalog\", command.fk_table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"fk_db_schema\", command.fk_table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"fk_table\", command.fk_table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetTableTypesSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetCrossReference(\n+      const ServerCallContext& context, const sql::GetCrossReference& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetCrossReferenceSchema());\n+  }\n+\n+  arrow::Result<int64_t> DoPutCommandStatementUpdate(\n+      const ServerCallContext& context, const sql::StatementUpdate& command) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"UPDATE STATEMENT\", command.query));\n+\n+    return 10000;\n+  }\n+\n+  arrow::Result<sql::ActionCreatePreparedStatementResult> CreatePreparedStatement(\n+      const ServerCallContext& context,\n+      const sql::ActionCreatePreparedStatementRequest& request) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<bool>(true, request.query == \"SELECT PREPARED STATEMENT\" ||\n+                                 request.query == \"UPDATE PREPARED STATEMENT\"));\n+\n+    sql::ActionCreatePreparedStatementResult result;\n+    result.prepared_statement_handle = request.query + \" HANDLE\";\n+\n+    return result;\n+  }\n+\n+  Status ClosePreparedStatement(\n+      const ServerCallContext& context,\n+      const sql::ActionClosePreparedStatementRequest& request) override {\n+    return Status::OK();\n+  }\n+\n+  Status DoPutPreparedStatementQuery(const ServerCallContext& context,\n+                                     const sql::PreparedStatementQuery& command,\n+                                     FlightMessageReader* reader,\n+                                     FlightMetadataWriter* writer) override {\n+    return Status::NotImplemented(\"Not implemented\");\n\nReview comment:\n       Shall we test this flow as well?\n\n##########\nFile path: cpp/src/arrow/flight/integration_tests/test_integration.cc\n##########\n@@ -0,0 +1,665 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/flight/integration_tests/test_integration.h\"\n+#include \"arrow/flight/client_middleware.h\"\n+#include \"arrow/flight/server_middleware.h\"\n+#include \"arrow/flight/sql/client.h\"\n+#include \"arrow/flight/sql/server.h\"\n+#include \"arrow/flight/test_util.h\"\n+#include \"arrow/flight/types.h\"\n+#include \"arrow/ipc/dictionary.h\"\n+\n+#include <arrow/testing/gtest_util.h>\n+#include <arrow/testing/json_integration.h>\n+#include <iostream>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+namespace arrow {\n+namespace flight {\n+namespace integration_tests {\n+\n+/// \\brief The server for the basic auth integration test.\n+class AuthBasicProtoServer : public FlightServerBase {\n+  Status DoAction(const ServerCallContext& context, const Action& action,\n+                  std::unique_ptr<ResultStream>* result) override {\n+    // Respond with the authenticated username.\n+    auto buf = Buffer::FromString(context.peer_identity());\n+    *result = std::unique_ptr<ResultStream>(new SimpleResultStream({Result{buf}}));\n+    return Status::OK();\n+  }\n+};\n+\n+/// Validate the result of a DoAction.\n+Status CheckActionResults(FlightClient* client, const Action& action,\n+                          std::vector<std::string> results) {\n+  std::unique_ptr<ResultStream> stream;\n+  RETURN_NOT_OK(client->DoAction(action, &stream));\n+  std::unique_ptr<Result> result;\n+  for (const std::string& expected : results) {\n+    RETURN_NOT_OK(stream->Next(&result));\n+    if (!result) {\n+      return Status::Invalid(\"Action result stream ended early\");\n+    }\n+    const auto actual = result->body->ToString();\n+    if (expected != actual) {\n+      return Status::Invalid(\"Got wrong result; expected\", expected, \"but got\", actual);\n+    }\n+  }\n+  RETURN_NOT_OK(stream->Next(&result));\n+  if (result) {\n+    return Status::Invalid(\"Action result stream had too many entries\");\n+  }\n+  return Status::OK();\n+}\n+\n+// The expected username for the basic auth integration test.\n+constexpr auto kAuthUsername = \"arrow\";\n+// The expected password for the basic auth integration test.\n+constexpr auto kAuthPassword = \"flight\";\n+\n+/// \\brief A scenario testing the basic auth protobuf.\n+class AuthBasicProtoScenario : public Scenario {\n+  Status MakeServer(std::unique_ptr<FlightServerBase>* server,\n+                    FlightServerOptions* options) override {\n+    server->reset(new AuthBasicProtoServer());\n+    options->auth_handler =\n+        std::make_shared<TestServerBasicAuthHandler>(kAuthUsername, kAuthPassword);\n+    return Status::OK();\n+  }\n+\n+  Status MakeClient(FlightClientOptions* options) override { return Status::OK(); }\n+\n+  Status RunClient(std::unique_ptr<FlightClient> client) override {\n+    Action action;\n+    std::unique_ptr<ResultStream> stream;\n+    std::shared_ptr<FlightStatusDetail> detail;\n+    const auto& status = client->DoAction(action, &stream);\n+    detail = FlightStatusDetail::UnwrapStatus(status);\n+    // This client is unauthenticated and should fail.\n+    if (detail == nullptr) {\n+      return Status::Invalid(\"Expected UNAUTHENTICATED but got \", status.ToString());\n+    }\n+    if (detail->code() != FlightStatusCode::Unauthenticated) {\n+      return Status::Invalid(\"Expected UNAUTHENTICATED but got \", detail->ToString());\n+    }\n+\n+    auto client_handler = std::unique_ptr<ClientAuthHandler>(\n+        new TestClientBasicAuthHandler(kAuthUsername, kAuthPassword));\n+    RETURN_NOT_OK(client->Authenticate({}, std::move(client_handler)));\n+    return CheckActionResults(client.get(), action, {kAuthUsername});\n+  }\n+};\n+\n+/// \\brief Test middleware that echoes back the value of a particular\n+/// incoming header.\n+///\n+/// In Java, gRPC may consolidate this header with HTTP/2 trailers if\n+/// the call fails, but C++ generally doesn't do this. The integration\n+/// test confirms the presence of this header to ensure we can read it\n+/// regardless of what gRPC does.\n+class TestServerMiddleware : public ServerMiddleware {\n+ public:\n+  explicit TestServerMiddleware(std::string received) : received_(received) {}\n+\n+  void SendingHeaders(AddCallHeaders* outgoing_headers) override {\n+    outgoing_headers->AddHeader(\"x-middleware\", received_);\n+  }\n+\n+  void CallCompleted(const Status& status) override {}\n+\n+  std::string name() const override { return \"GrpcTrailersMiddleware\"; }\n+\n+ private:\n+  std::string received_;\n+};\n+\n+class TestServerMiddlewareFactory : public ServerMiddlewareFactory {\n+ public:\n+  Status StartCall(const CallInfo& info, const CallHeaders& incoming_headers,\n+                   std::shared_ptr<ServerMiddleware>* middleware) override {\n+    const std::pair<CallHeaders::const_iterator, CallHeaders::const_iterator>& iter_pair =\n+        incoming_headers.equal_range(\"x-middleware\");\n+    std::string received = \"\";\n+    if (iter_pair.first != iter_pair.second) {\n+      const util::string_view& value = (*iter_pair.first).second;\n+      received = std::string(value);\n+    }\n+    *middleware = std::make_shared<TestServerMiddleware>(received);\n+    return Status::OK();\n+  }\n+};\n+\n+/// \\brief Test middleware that adds a header on every outgoing call,\n+/// and gets the value of the expected header sent by the server.\n+class TestClientMiddleware : public ClientMiddleware {\n+ public:\n+  explicit TestClientMiddleware(std::string* received_header)\n+      : received_header_(received_header) {}\n+\n+  void SendingHeaders(AddCallHeaders* outgoing_headers) {\n+    outgoing_headers->AddHeader(\"x-middleware\", \"expected value\");\n+  }\n+\n+  void ReceivedHeaders(const CallHeaders& incoming_headers) {\n+    // We expect the server to always send this header. gRPC/Java may\n+    // send it in trailers instead of headers, so we expect Flight to\n+    // account for this.\n+    const std::pair<CallHeaders::const_iterator, CallHeaders::const_iterator>& iter_pair =\n+        incoming_headers.equal_range(\"x-middleware\");\n+    if (iter_pair.first != iter_pair.second) {\n+      const util::string_view& value = (*iter_pair.first).second;\n+      *received_header_ = std::string(value);\n+    }\n+  }\n+\n+  void CallCompleted(const Status& status) {}\n+\n+ private:\n+  std::string* received_header_;\n+};\n+\n+class TestClientMiddlewareFactory : public ClientMiddlewareFactory {\n+ public:\n+  void StartCall(const CallInfo& info, std::unique_ptr<ClientMiddleware>* middleware) {\n+    *middleware =\n+        std::unique_ptr<ClientMiddleware>(new TestClientMiddleware(&received_header_));\n+  }\n+\n+  std::string received_header_;\n+};\n+\n+/// \\brief The server used for testing middleware. Implements only one\n+/// endpoint, GetFlightInfo, in such a way that it either succeeds or\n+/// returns an error based on the input, in order to test both paths.\n+class MiddlewareServer : public FlightServerBase {\n+  Status GetFlightInfo(const ServerCallContext& context,\n+                       const FlightDescriptor& descriptor,\n+                       std::unique_ptr<FlightInfo>* result) override {\n+    if (descriptor.type == FlightDescriptor::DescriptorType::CMD &&\n+        descriptor.cmd == \"success\") {\n+      // Don't fail\n+      std::shared_ptr<Schema> schema = arrow::schema({});\n+      Location location;\n+      // Return a fake location - the test doesn't read it\n+      RETURN_NOT_OK(Location::ForGrpcTcp(\"localhost\", 10010, &location));\n+      std::vector<FlightEndpoint> endpoints{FlightEndpoint{{\"foo\"}, {location}}};\n+      ARROW_ASSIGN_OR_RAISE(auto info,\n+                            FlightInfo::Make(*schema, descriptor, endpoints, -1, -1));\n+      *result = std::unique_ptr<FlightInfo>(new FlightInfo(info));\n+      return Status::OK();\n+    }\n+    // Fail the call immediately. In some gRPC implementations, this\n+    // means that gRPC sends only HTTP/2 trailers and not headers. We want\n+    // Flight middleware to be agnostic to this difference.\n+    return Status::UnknownError(\"Unknown\");\n+  }\n+};\n+\n+/// \\brief The middleware scenario.\n+///\n+/// This tests that the server and client get expected header values.\n+class MiddlewareScenario : public Scenario {\n+  Status MakeServer(std::unique_ptr<FlightServerBase>* server,\n+                    FlightServerOptions* options) override {\n+    options->middleware.push_back(\n+        {\"grpc_trailers\", std::make_shared<TestServerMiddlewareFactory>()});\n+    server->reset(new MiddlewareServer());\n+    return Status::OK();\n+  }\n+\n+  Status MakeClient(FlightClientOptions* options) override {\n+    client_middleware_ = std::make_shared<TestClientMiddlewareFactory>();\n+    options->middleware.push_back(client_middleware_);\n+    return Status::OK();\n+  }\n+\n+  Status RunClient(std::unique_ptr<FlightClient> client) override {\n+    std::unique_ptr<FlightInfo> info;\n+    // This call is expected to fail. In gRPC/Java, this causes the\n+    // server to combine headers and HTTP/2 trailers, so to read the\n+    // expected header, Flight must check for both headers and\n+    // trailers.\n+    if (client->GetFlightInfo(FlightDescriptor::Command(\"\"), &info).ok()) {\n+      return Status::Invalid(\"Expected call to fail\");\n+    }\n+    if (client_middleware_->received_header_ != \"expected value\") {\n+      return Status::Invalid(\n+          \"Expected to receive header 'x-middleware: expected value', but instead got: '\",\n+          client_middleware_->received_header_, \"'\");\n+    }\n+    std::cerr << \"Headers received successfully on failing call.\" << std::endl;\n+\n+    // This call should succeed\n+    client_middleware_->received_header_ = \"\";\n+    RETURN_NOT_OK(client->GetFlightInfo(FlightDescriptor::Command(\"success\"), &info));\n+    if (client_middleware_->received_header_ != \"expected value\") {\n+      return Status::Invalid(\n+          \"Expected to receive header 'x-middleware: expected value', but instead got '\",\n+          client_middleware_->received_header_, \"'\");\n+    }\n+    std::cerr << \"Headers received successfully on passing call.\" << std::endl;\n+    return Status::OK();\n+  }\n+\n+  std::shared_ptr<TestClientMiddlewareFactory> client_middleware_;\n+};\n+\n+std::shared_ptr<Schema> GetQuerySchema() {\n+  return arrow::schema({arrow::field(\"id\", int64())});\n+}\n+\n+template <typename T>\n+arrow::Status AssertEq(const T& expected, const T& actual) {\n+  if (expected != actual) {\n+    return Status::Invalid(\"Expected \\\"\", expected, \"\\\", got \\'\", actual, \"\\\"\");\n+  }\n+  return Status::OK();\n+}\n+\n+/// \\brief The server used for testing Flight SQL, this implements a static Flight SQL server which only asserts\n+/// that commands called during integration tests are being parsed correctly and returns the expected schemas to be\n+/// validated on client.\n+class FlightSqlScenarioServer : public sql::FlightSqlServerBase {\n+ public:\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoStatement(\n+      const ServerCallContext& context, const sql::StatementQuery& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"SELECT STATEMENT\", command.query));\n+\n+    ARROW_ASSIGN_OR_RAISE(auto handle,\n+                          sql::CreateStatementQueryTicket(\"SELECT STATEMENT HANDLE\"));\n+\n+    std::vector<FlightEndpoint> endpoints{FlightEndpoint{{handle}, {}}};\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto result, FlightInfo::Make(*GetQuerySchema(), descriptor, endpoints, -1, -1))\n+\n+    return std::unique_ptr<FlightInfo>(new FlightInfo(result));\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetStatement(\n+      const ServerCallContext& context,\n+      const sql::StatementQueryTicket& command) override {\n+    return DoGetForTestCase(GetQuerySchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoPreparedStatement(\n+      const ServerCallContext& context, const sql::PreparedStatementQuery& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"SELECT PREPARED STATEMENT HANDLE\",\n+                                              command.prepared_statement_handle));\n+\n+    return GetFlightInfoForCommand(descriptor, GetQuerySchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetPreparedStatement(\n+      const ServerCallContext& context,\n+      const sql::PreparedStatementQuery& command) override {\n+    return DoGetForTestCase(GetQuerySchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoCatalogs(\n+      const ServerCallContext& context, const FlightDescriptor& descriptor) override {\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetCatalogsSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetCatalogs(\n+      const ServerCallContext& context) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetCatalogsSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoSqlInfo(\n+      const ServerCallContext& context, const sql::GetSqlInfo& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(2, command.info.size()));\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(\n+        sql::SqlInfoOptions::SqlInfo::FLIGHT_SQL_SERVER_NAME, command.info[0]));\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(\n+        sql::SqlInfoOptions::SqlInfo::FLIGHT_SQL_SERVER_READ_ONLY, command.info[1]));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetSqlInfoSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetSqlInfo(\n+      const ServerCallContext& context, const sql::GetSqlInfo& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetSqlInfoSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoSchemas(\n+      const ServerCallContext& context, const sql::GetDbSchemas& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"catalog\", command.catalog.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"db_schema_filter_pattern\",\n+                                              command.db_schema_filter_pattern.value()));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetDbSchemasSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetDbSchemas(\n+      const ServerCallContext& context, const sql::GetDbSchemas& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetDbSchemasSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoTables(\n+      const ServerCallContext& context, const sql::GetTables& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"catalog\", command.catalog.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"db_schema_filter_pattern\",\n+                                              command.db_schema_filter_pattern.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table_filter_pattern\",\n+                                              command.table_name_filter_pattern.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<int>(2, command.table_types.size()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_types[0]));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"view\", command.table_types[1]));\n+    ARROW_RETURN_NOT_OK(AssertEq<bool>(true, command.include_schema));\n+\n+    return GetFlightInfoForCommand(descriptor,\n+                                   sql::SqlSchema::GetTablesSchemaWithIncludedSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetTables(\n+      const ServerCallContext& context, const sql::GetTables& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetTablesSchemaWithIncludedSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoTableTypes(\n+      const ServerCallContext& context, const FlightDescriptor& descriptor) override {\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetTableTypesSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetTableTypes(\n+      const ServerCallContext& context) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetTableTypesSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoPrimaryKeys(\n+      const ServerCallContext& context, const sql::GetPrimaryKeys& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"catalog\", command.table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"db_schema\", command.table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetPrimaryKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetPrimaryKeys(\n+      const ServerCallContext& context, const sql::GetPrimaryKeys& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetPrimaryKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoExportedKeys(\n+      const ServerCallContext& context, const sql::GetExportedKeys& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"catalog\", command.table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"db_schema\", command.table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetExportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetExportedKeys(\n+      const ServerCallContext& context, const sql::GetExportedKeys& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetExportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoImportedKeys(\n+      const ServerCallContext& context, const sql::GetImportedKeys& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"catalog\", command.table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"db_schema\", command.table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"table\", command.table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetImportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetImportedKeys(\n+      const ServerCallContext& context, const sql::GetImportedKeys& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetImportedKeysSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoCrossReference(\n+      const ServerCallContext& context, const sql::GetCrossReference& command,\n+      const FlightDescriptor& descriptor) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"pk_catalog\", command.pk_table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"pk_db_schema\", command.pk_table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"pk_table\", command.pk_table_ref.table));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"fk_catalog\", command.fk_table_ref.catalog.value()));\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<std::string>(\"fk_db_schema\", command.fk_table_ref.db_schema.value()));\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"fk_table\", command.fk_table_ref.table));\n+\n+    return GetFlightInfoForCommand(descriptor, sql::SqlSchema::GetTableTypesSchema());\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetCrossReference(\n+      const ServerCallContext& context, const sql::GetCrossReference& command) override {\n+    return DoGetForTestCase(sql::SqlSchema::GetCrossReferenceSchema());\n+  }\n+\n+  arrow::Result<int64_t> DoPutCommandStatementUpdate(\n+      const ServerCallContext& context, const sql::StatementUpdate& command) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"UPDATE STATEMENT\", command.query));\n+\n+    return 10000;\n+  }\n+\n+  arrow::Result<sql::ActionCreatePreparedStatementResult> CreatePreparedStatement(\n+      const ServerCallContext& context,\n+      const sql::ActionCreatePreparedStatementRequest& request) override {\n+    ARROW_RETURN_NOT_OK(\n+        AssertEq<bool>(true, request.query == \"SELECT PREPARED STATEMENT\" ||\n+                                 request.query == \"UPDATE PREPARED STATEMENT\"));\n+\n+    sql::ActionCreatePreparedStatementResult result;\n+    result.prepared_statement_handle = request.query + \" HANDLE\";\n+\n+    return result;\n+  }\n+\n+  Status ClosePreparedStatement(\n+      const ServerCallContext& context,\n+      const sql::ActionClosePreparedStatementRequest& request) override {\n+    return Status::OK();\n+  }\n+\n+  Status DoPutPreparedStatementQuery(const ServerCallContext& context,\n+                                     const sql::PreparedStatementQuery& command,\n+                                     FlightMessageReader* reader,\n+                                     FlightMetadataWriter* writer) override {\n+    return Status::NotImplemented(\"Not implemented\");\n+  }\n+\n+  arrow::Result<int64_t> DoPutPreparedStatementUpdate(\n+      const ServerCallContext& context, const sql::PreparedStatementUpdate& command,\n+      FlightMessageReader* reader) override {\n+    ARROW_RETURN_NOT_OK(AssertEq<std::string>(\"UPDATE PREPARED STATEMENT HANDLE\",\n+                                              command.prepared_statement_handle));\n+\n+    return 20000;\n+  }\n+\n+ private:\n+  arrow::Result<std::unique_ptr<FlightInfo>> GetFlightInfoForCommand(\n+      const FlightDescriptor& descriptor, const std::shared_ptr<Schema>& schema) {\n+    std::vector<FlightEndpoint> endpoints{FlightEndpoint{{descriptor.cmd}, {}}};\n+    ARROW_ASSIGN_OR_RAISE(auto result,\n+                          FlightInfo::Make(*schema, descriptor, endpoints, -1, -1))\n+\n+    return std::unique_ptr<FlightInfo>(new FlightInfo(result));\n+  }\n+\n+  arrow::Result<std::unique_ptr<FlightDataStream>> DoGetForTestCase(\n+      std::shared_ptr<Schema> schema) {\n+    ARROW_ASSIGN_OR_RAISE(auto reader2, RecordBatchReader::Make({}, schema));\n+    return std::unique_ptr<FlightDataStream>(new RecordBatchStream(reader2));\n+  }\n+};\n+\n+/// \\brief Integration test scenario for validating Flight SQL specs across multiple\n+/// implementations. This should ensure that RPC objects are being built and parsed\n+/// correctly for multiple languages and that the Arrow schemas are returned as expected.\n+class FlightSqlScenario : public Scenario {\n+  Status MakeServer(std::unique_ptr<FlightServerBase>* server,\n+                    FlightServerOptions* options) override {\n+    server->reset(new FlightSqlScenarioServer());\n+    return Status::OK();\n+  }\n+\n+  Status MakeClient(FlightClientOptions* options) override { return Status::OK(); }\n+\n+  Status Validate(std::shared_ptr<Schema> expectedSchema,\n+                  arrow::Result<std::unique_ptr<FlightInfo>> flightInfo,\n+                  sql::FlightSqlClient* sql_client) {\n+    FlightCallOptions call_options;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto flight_info, flightInfo);\n+    ARROW_ASSIGN_OR_RAISE(\n+        auto reader, sql_client->DoGet(call_options, flight_info->endpoints()[0].ticket));\n+\n+    ARROW_ASSIGN_OR_RAISE(auto actual_schema, reader->GetSchema());\n+\n+    AssertSchemaEqual(expectedSchema, actual_schema);\n+\n+    return Status::OK();\n+  }\n+\n+  Status RunClient(std::unique_ptr<FlightClient> client) override {\n+    sql::FlightSqlClient sql_client(std::move(client));\n+\n+    ARROW_RETURN_NOT_OK(ValidateMetadataRetrieval(&sql_client));\n+\n+    ARROW_RETURN_NOT_OK(ValidateStatementExecution(&sql_client));\n+\n+    ARROW_RETURN_NOT_OK(ValidatePreparedStatementExecution(&sql_client));\n+\n+    return Status::OK();\n+  }\n+\n+  Status ValidateMetadataRetrieval(sql::FlightSqlClient* sql_client) {\n+    FlightCallOptions options;\n+\n+    std::string catalog = \"catalog\";\n+    std::string db_schema_filter_pattern = \"db_schema_filter_pattern\";\n+    std::string table_filter_pattern = \"table_filter_pattern\";\n+    std::string table = \"table\";\n+    std::string db_schema = \"db_schema\";\n+    std::vector<std::string> table_types = {\"table\", \"view\"};\n+\n+    sql::TableRef table_ref = {catalog, db_schema, table};\n+    sql::TableRef pk_table_ref = {\"pk_catalog\", \"pk_db_schema\", \"pk_table\"};\n+    sql::TableRef fk_table_ref = {\"fk_catalog\", \"fk_db_schema\", \"fk_table\"};\n+\n+    ARROW_RETURN_NOT_OK(Validate(sql::SqlSchema::GetCatalogsSchema(),\n+                                 sql_client->GetCatalogs(options), sql_client));\n+    ARROW_RETURN_NOT_OK(\n+        Validate(sql::SqlSchema::GetDbSchemasSchema(),\n+                 sql_client->GetDbSchemas(options, &catalog, &db_schema_filter_pattern),\n+                 sql_client));\n+    ARROW_RETURN_NOT_OK(\n+        Validate(sql::SqlSchema::GetTablesSchemaWithIncludedSchema(),\n+                 sql_client->GetTables(options, &catalog, &db_schema_filter_pattern,\n+                                       &table_filter_pattern, true, &table_types),\n+                 sql_client));\n+    ARROW_RETURN_NOT_OK(Validate(sql::SqlSchema::GetTableTypesSchema(),\n+                                 sql_client->GetTableTypes(options), sql_client));\n+    ARROW_RETURN_NOT_OK(Validate(sql::SqlSchema::GetPrimaryKeysSchema(),\n+                                 sql_client->GetPrimaryKeys(options, table_ref),\n+                                 sql_client));\n+    ARROW_RETURN_NOT_OK(Validate(sql::SqlSchema::GetExportedKeysSchema(),\n+                                 sql_client->GetExportedKeys(options, table_ref),\n+                                 sql_client));\n+    ARROW_RETURN_NOT_OK(Validate(sql::SqlSchema::GetImportedKeysSchema(),\n+                                 sql_client->GetImportedKeys(options, table_ref),\n+                                 sql_client));\n+    ARROW_RETURN_NOT_OK(Validate(\n+        sql::SqlSchema::GetCrossReferenceSchema(),\n+        sql_client->GetCrossReference(options, pk_table_ref, fk_table_ref), sql_client));\n+    ARROW_RETURN_NOT_OK(Validate(\n+        sql::SqlSchema::GetSqlInfoSchema(),\n+        sql_client->GetSqlInfo(\n+            options, {sql::SqlInfoOptions::SqlInfo::FLIGHT_SQL_SERVER_NAME,\n+                      sql::SqlInfoOptions::SqlInfo::FLIGHT_SQL_SERVER_READ_ONLY}),\n+        sql_client));\n+\n+    return Status::OK();\n+  }\n+\n+  Status ValidateStatementExecution(sql::FlightSqlClient* sql_client) {\n+    FlightCallOptions options;\n+\n+    ARROW_RETURN_NOT_OK(Validate(\n+            GetQuerySchema(), sql_client->Execute(options, \"SELECT STATEMENT\"), sql_client));\n+    ARROW_ASSIGN_OR_RAISE(auto update_statement_result,\n+                          sql_client->ExecuteUpdate(options, \"UPDATE STATEMENT\"));\n+    if (update_statement_result != 10000L) {\n+      return Status::Invalid(\"Expected 'UPDATE STATEMENT' return 10000, got \",\n+                             update_statement_result);\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  Status ValidatePreparedStatementExecution(sql::FlightSqlClient* sql_client) {\n+    FlightCallOptions options;\n+\n+    ARROW_ASSIGN_OR_RAISE(auto select_prepared_statement,\n+                          sql_client->Prepare(options, \"SELECT PREPARED STATEMENT\"));\n+    ARROW_RETURN_NOT_OK(\n+            Validate(GetQuerySchema(), select_prepared_statement->Execute(), sql_client));\n+\n+    ARROW_ASSIGN_OR_RAISE(auto update_prepared_statement,\n+                          sql_client->Prepare(options, \"UPDATE PREPARED STATEMENT\"));\n+    ARROW_ASSIGN_OR_RAISE(auto update_prepared_statement_result,\n+                          update_prepared_statement->ExecuteUpdate());\n+    if (update_prepared_statement_result != 20000L) {\n+      return Status::Invalid(\"Expected 'UPDATE STATEMENT' return 20000, got \",\n+                             update_prepared_statement_result);\n+    }\n+\n+    return Status::OK();\n\nReview comment:\n       Can we explicitly close the prepared statement here?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-17T22:35:05.538+0000",
                    "updated": "2021-12-17T22:35:05.538+0000",
                    "started": "2021-12-17T22:35:05.538+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "698134",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/698173",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rafael-telles commented on a change in pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#discussion_r771763907\n\n\n\n##########\nFile path: java/flight/flight-integration-tests/src/main/java/org/apache/arrow/flight/integration/tests/FlightSqlScenarioProducer.java\n##########\n@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.integration.tests;\n+\n+import static com.google.protobuf.Any.pack;\n+import static java.util.Collections.singletonList;\n+\n+import java.util.List;\n+\n+import org.apache.arrow.flight.Criteria;\n+import org.apache.arrow.flight.FlightDescriptor;\n+import org.apache.arrow.flight.FlightEndpoint;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.PutResult;\n+import org.apache.arrow.flight.Result;\n+import org.apache.arrow.flight.SchemaResult;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.FlightSqlProducer;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.memory.ArrowBuf;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.ArrowType;\n+import org.apache.arrow.vector.types.pojo.Field;\n+import org.apache.arrow.vector.types.pojo.FieldType;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Message;\n+\n+/**\n+ * Hardcoded Flight SQL producer used for cross-language integration tests.\n+ */\n+public class FlightSqlScenarioProducer implements FlightSqlProducer {\n+  private final BufferAllocator allocator;\n+\n+  public FlightSqlScenarioProducer(BufferAllocator allocator) {\n+    this.allocator = allocator;\n+  }\n+\n+  static Schema getQuerySchema() {\n+    return new Schema(\n+        singletonList(\n+            new Field(\"id\", FieldType.nullable(new ArrowType.Int(64, true)), null)\n+        )\n+    );\n+  }\n+\n+  @Override\n+  public void createPreparedStatement(FlightSql.ActionCreatePreparedStatementRequest request,\n+                                      CallContext context, StreamListener<Result> listener) {\n+    IntegrationAssertions.assertTrue(\"Expect to be one of the two queries used on tests\",\n+        request.getQuery().equals(\"SELECT PREPARED STATEMENT\") ||\n+            request.getQuery().equals(\"UPDATE PREPARED STATEMENT\"));\n+\n+    final FlightSql.ActionCreatePreparedStatementResult\n+        result = FlightSql.ActionCreatePreparedStatementResult.newBuilder()\n+        .setPreparedStatementHandle(ByteString.copyFromUtf8(request.getQuery() + \" HANDLE\"))\n+        .build();\n+    listener.onNext(new Result(pack(result).toByteArray()));\n+    listener.onCompleted();\n+  }\n+\n+  @Override\n+  public void closePreparedStatement(FlightSql.ActionClosePreparedStatementRequest request,\n+                                     CallContext context, StreamListener<Result> listener) {\n+    IntegrationAssertions.assertTrue(\"Expect to be one of the two queries used on tests\",\n+        request.getPreparedStatementHandle().toStringUtf8().equals(\"SELECT PREPARED STATEMENT HANDLE\") ||\n+            request.getPreparedStatementHandle().toStringUtf8().equals(\"UPDATE PREPARED STATEMENT HANDLE\"));\n+\n+    listener.onCompleted();\n+  }\n+\n+  @Override\n+  public FlightInfo getFlightInfoStatement(FlightSql.CommandStatementQuery command,\n+                                           CallContext context, FlightDescriptor descriptor) {\n+    IntegrationAssertions.assertEquals(command.getQuery(), \"SELECT STATEMENT\");\n+\n+    ByteString handle = ByteString.copyFromUtf8(\"SELECT STATEMENT HANDLE\");\n+\n+    FlightSql.TicketStatementQuery ticket = FlightSql.TicketStatementQuery.newBuilder()\n+        .setStatementHandle(handle)\n+        .build();\n+    return getFlightInfoForSchema(ticket, descriptor, getQuerySchema());\n+  }\n+\n+  @Override\n+  public FlightInfo getFlightInfoPreparedStatement(FlightSql.CommandPreparedStatementQuery command,\n+                                                   CallContext context,\n+                                                   FlightDescriptor descriptor) {\n+    IntegrationAssertions.assertEquals(command.getPreparedStatementHandle().toStringUtf8(),\n+        \"SELECT PREPARED STATEMENT HANDLE\");\n+\n+    return getFlightInfoForSchema(command, descriptor, getQuerySchema());\n+  }\n+\n+  @Override\n+  public SchemaResult getSchemaStatement(FlightSql.CommandStatementQuery command,\n+                                         CallContext context, FlightDescriptor descriptor) {\n+    return new SchemaResult(getQuerySchema());\n+  }\n+\n+  @Override\n+  public void getStreamStatement(FlightSql.TicketStatementQuery ticket, CallContext context,\n+                                 ServerStreamListener listener) {\n+    serveJsonToStreamListener(listener, getQuerySchema());\n+  }\n+\n+  @Override\n+  public void getStreamPreparedStatement(FlightSql.CommandPreparedStatementQuery command,\n+                                         CallContext context, ServerStreamListener listener) {\n+    serveJsonToStreamListener(listener, getQuerySchema());\n+  }\n+\n+  private Runnable acceptPutReturnConstant(StreamListener<PutResult> ackStream, int value) {\n+    return () -> {\n+      final FlightSql.DoPutUpdateResult build =\n+          FlightSql.DoPutUpdateResult.newBuilder().setRecordCount(value).build();\n+\n+      try (final ArrowBuf buffer = allocator.buffer(build.getSerializedSize())) {\n+        buffer.writeBytes(build.toByteArray());\n+        ackStream.onNext(PutResult.metadata(buffer));\n+        ackStream.onCompleted();\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public Runnable acceptPutStatement(FlightSql.CommandStatementUpdate command, CallContext context,\n+                                     FlightStream flightStream,\n+                                     StreamListener<PutResult> ackStream) {\n+    IntegrationAssertions.assertEquals(command.getQuery(), \"UPDATE STATEMENT\");\n+\n+    return acceptPutReturnConstant(ackStream, 10000);\n+  }\n+\n+  @Override\n+  public Runnable acceptPutPreparedStatementUpdate(FlightSql.CommandPreparedStatementUpdate command,\n+                                                   CallContext context, FlightStream flightStream,\n+                                                   StreamListener<PutResult> ackStream) {\n+    IntegrationAssertions.assertEquals(command.getPreparedStatementHandle().toStringUtf8(),\n+        \"UPDATE PREPARED STATEMENT HANDLE\");\n+\n+    return acceptPutReturnConstant(ackStream, 20000);\n+  }\n+\n+  @Override\n+  public Runnable acceptPutPreparedStatementQuery(FlightSql.CommandPreparedStatementQuery command,\n+                                                  CallContext context, FlightStream flightStream,\n+                                                  StreamListener<PutResult> ackStream) {\n+    IntegrationAssertions.assertEquals(command.getPreparedStatementHandle(),\n+        \"SELECT PREPARED STATEMENT HANDLE\");\n+\n+    return null;\n\nReview comment:\n       Implemented this case as well\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-18T01:27:56.737+0000",
                    "updated": "2021-12-18T01:27:56.737+0000",
                    "started": "2021-12-18T01:27:56.736+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "698173",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/698689",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-997949857\n\n\n   We need to exclude Go and Rust from the new test scenario.\r\n   \r\n   Also, the PR needs to be formatted (see https://arrow.apache.org/docs/developers/cpp/development.html#code-style-linting-and-ci, note that we use ClangTools 12 now not version 8)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-20T14:01:57.550+0000",
                    "updated": "2021-12-20T14:01:57.550+0000",
                    "started": "2021-12-20T14:01:57.550+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "698689",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/698846",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rafael-telles commented on a change in pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#discussion_r772542505\n\n\n\n##########\nFile path: cpp/src/arrow/flight/integration_tests/CMakeLists.txt\n##########\n@@ -0,0 +1,47 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+add_custom_target(arrow_flight_integration_tests)\n\nReview comment:\n       It was already there on arrow/flight/CMakeLists.txt before moving to the new directory\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-20T17:21:54.650+0000",
                    "updated": "2021-12-20T17:21:54.650+0000",
                    "started": "2021-12-20T17:21:54.650+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "698846",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/698853",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rafael-telles commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-998137221\n\n\n   Done @lidavidm \n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-20T17:38:46.498+0000",
                    "updated": "2021-12-20T17:38:46.498+0000",
                    "started": "2021-12-20T17:38:46.497+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "698853",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/698986",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rafael-telles commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-998282667\n\n\n   Hey @lidavidm , I don't know if these CI failures has something to do with these changes... Please let me know if there is anything else to do here\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-20T21:27:14.729+0000",
                    "updated": "2021-12-20T21:27:14.729+0000",
                    "started": "2021-12-20T21:27:14.729+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "698986",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/698991",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-998295185\n\n\n   There's some lint failures:\r\n   \r\n   ```\r\n   \r\n   [1/1] cd /tmp/arrow-lint-6fb2hzaq/cpp-build && /usr/local/bin/python /arrow/cpp/build-support/lint_cpp_cli.py /arrow/cpp/src\r\n   INFO:archery:Running Python formatter (autopep8)\r\n   INFO:archery:Running Python linter (flake8)\r\n   /arrow/dev/archery/archery/integration/tester_java.py:52:80: E501 line too long (95 > 79 characters)\r\n   /arrow/dev/archery/archery/integration/runner.py:387:80: E501 line too long (82 > 79 characters)\r\n   INFO:archery:Running cmake-format linters\r\n   ERROR __main__.py:618: Check failed: /arrow/cpp/src/arrow/CMakeLists.txt\r\n   ```\r\n   \r\n   I think the other one is unrelated, but could you rebase on master to see if it goes away?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-20T21:48:47.607+0000",
                    "updated": "2021-12-20T21:48:47.607+0000",
                    "started": "2021-12-20T21:48:47.606+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "698991",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/699012",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rafael-telles commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-998323182\n\n\n   Ops @lidavidm ... Sorry, I don't know if I messed up when `git rebase master` or if also need to run it in the base branch `flight-sql`...\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-20T22:39:29.882+0000",
                    "updated": "2021-12-20T22:39:29.882+0000",
                    "started": "2021-12-20T22:39:29.882+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "699012",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/699020",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-998334422\n\n\n   Ah, right, we have a branch\u2026How about I rebase the branch, and then we can rebase the PRs?\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-20T23:05:57.922+0000",
                    "updated": "2021-12-20T23:05:57.922+0000",
                    "started": "2021-12-20T23:05:57.921+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "699020",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/699021",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-998335552\n\n\n   Hmm. I just rebased the branch\u2026so do you mind trying to rebase again here? Sorry for the trouble.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-20T23:08:05.278+0000",
                    "updated": "2021-12-20T23:08:05.278+0000",
                    "started": "2021-12-20T23:08:05.277+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "699021",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/699023",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rafael-telles commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-998338029\n\n\n   No problem! Just rebased :)\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-20T23:13:15.586+0000",
                    "updated": "2021-12-20T23:13:15.586+0000",
                    "started": "2021-12-20T23:13:15.585+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "699023",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/699025",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-998345145\n\n\n   Well, looks like the Docker registry isn't doing so well right now. I'll kick all the CI pipelines in a bit to try again.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-20T23:26:46.507+0000",
                    "updated": "2021-12-20T23:26:46.507+0000",
                    "started": "2021-12-20T23:26:46.506+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "699025",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/699357",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-998773336\n\n\n   Hmm, I wonder if the test failure in Dev is just because it's getting confused since we're on a branch. I think we can resolve that when we make the final PR from flight-sql into master, then.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-21T13:20:06.867+0000",
                    "updated": "2021-12-21T13:20:06.867+0000",
                    "started": "2021-12-21T13:20:06.867+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "699357",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/699362",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on a change in pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#discussion_r773142629\n\n\n\n##########\nFile path: java/flight/flight-integration-tests/src/main/java/org/apache/arrow/flight/integration/tests/FlightSqlScenario.java\n##########\n@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.integration.tests;\n+\n+import java.util.Arrays;\n+\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightProducer;\n+import org.apache.arrow.flight.FlightServer;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.Location;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.FlightSqlClient;\n+import org.apache.arrow.flight.sql.FlightSqlProducer;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.util.TableRef;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+/**\n+ * Integration test scenario for validating Flight SQL specs across multiple implementations.\n+ * This should ensure that RPC objects are being built and parsed correctly for multiple languages\n+ * and that the Arrow schemas are returned as expected.\n+ */\n+public class FlightSqlScenario implements Scenario {\n+\n+  @Override\n+  public FlightProducer producer(BufferAllocator allocator, Location location) throws Exception {\n+    return new FlightSqlScenarioProducer(allocator);\n+  }\n+\n+  @Override\n+  public void buildServer(FlightServer.Builder builder) throws Exception {\n+\n+  }\n+\n+  @Override\n+  public void client(BufferAllocator allocator, Location location, FlightClient client)\n+      throws Exception {\n+    final FlightSqlClient sqlClient = new FlightSqlClient(client);\n+\n+    validateMetadataRetrieval(sqlClient);\n+\n+    validateStatementExecution(sqlClient);\n+\n+    validatePreparedStatementExecution(sqlClient, allocator);\n+  }\n+\n+  private void validateMetadataRetrieval(FlightSqlClient sqlClient) throws Exception {\n+    final CallOption[] options = new CallOption[0];\n+\n+    validate(FlightSqlProducer.Schemas.GET_CATALOGS_SCHEMA, sqlClient.getCatalogs(options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_SCHEMAS_SCHEMA,\n+        sqlClient.getSchemas(\"catalog\", \"db_schema_filter_pattern\", options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_TABLES_SCHEMA,\n+        sqlClient.getTables(\"catalog\", \"db_schema_filter_pattern\", \"table_filter_pattern\",\n+            Arrays.asList(\"table\", \"view\"), true, options), sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_TABLE_TYPES_SCHEMA, sqlClient.getTableTypes(options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_PRIMARY_KEYS_SCHEMA,\n+        sqlClient.getPrimaryKeys(TableRef.of(\"catalog\", \"db_schema\", \"table\"), options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_EXPORTED_KEYS_SCHEMA,\n+        sqlClient.getExportedKeys(TableRef.of(\"catalog\", \"db_schema\", \"table\"), options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_IMPORTED_KEYS_SCHEMA,\n+        sqlClient.getImportedKeys(TableRef.of(\"catalog\", \"db_schema\", \"table\"), options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_CROSS_REFERENCE_SCHEMA,\n+        sqlClient.getCrossReference(TableRef.of(\"pk_catalog\", \"pk_db_schema\", \"pk_table\"),\n+            TableRef.of(\"fk_catalog\", \"fk_db_schema\", \"fk_table\"), options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_SQL_INFO_SCHEMA,\n+        sqlClient.getSqlInfo(new FlightSql.SqlInfo[] {FlightSql.SqlInfo.FLIGHT_SQL_SERVER_NAME,\n+            FlightSql.SqlInfo.FLIGHT_SQL_SERVER_READ_ONLY}, options), sqlClient);\n+  }\n+\n+  private void validateStatementExecution(FlightSqlClient sqlClient) throws Exception {\n+    final CallOption[] options = new CallOption[0];\n+\n+    validate(FlightSqlScenarioProducer.getQuerySchema(),\n+        sqlClient.execute(\"SELECT STATEMENT\", options), sqlClient);\n+\n+    IntegrationAssertions.assertEquals(sqlClient.executeUpdate(\"UPDATE STATEMENT\", options),\n+        10000L);\n\nReview comment:\n       Just a nit, but can we move these numbers to constants so it's clear what they represent? (`UPDATE_STATEMENT_EXPECTED_ROWS` or something)\n\n##########\nFile path: java/flight/flight-integration-tests/src/main/java/org/apache/arrow/flight/integration/tests/FlightSqlScenario.java\n##########\n@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.integration.tests;\n+\n+import java.util.Arrays;\n+\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightProducer;\n+import org.apache.arrow.flight.FlightServer;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.Location;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.FlightSqlClient;\n+import org.apache.arrow.flight.sql.FlightSqlProducer;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.util.TableRef;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+/**\n+ * Integration test scenario for validating Flight SQL specs across multiple implementations.\n+ * This should ensure that RPC objects are being built and parsed correctly for multiple languages\n+ * and that the Arrow schemas are returned as expected.\n+ */\n+public class FlightSqlScenario implements Scenario {\n+\n+  @Override\n+  public FlightProducer producer(BufferAllocator allocator, Location location) throws Exception {\n+    return new FlightSqlScenarioProducer(allocator);\n+  }\n+\n+  @Override\n+  public void buildServer(FlightServer.Builder builder) throws Exception {\n+\n+  }\n+\n+  @Override\n+  public void client(BufferAllocator allocator, Location location, FlightClient client)\n+      throws Exception {\n+    final FlightSqlClient sqlClient = new FlightSqlClient(client);\n+\n+    validateMetadataRetrieval(sqlClient);\n+\n+    validateStatementExecution(sqlClient);\n+\n+    validatePreparedStatementExecution(sqlClient, allocator);\n+  }\n+\n+  private void validateMetadataRetrieval(FlightSqlClient sqlClient) throws Exception {\n+    final CallOption[] options = new CallOption[0];\n+\n+    validate(FlightSqlProducer.Schemas.GET_CATALOGS_SCHEMA, sqlClient.getCatalogs(options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_SCHEMAS_SCHEMA,\n+        sqlClient.getSchemas(\"catalog\", \"db_schema_filter_pattern\", options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_TABLES_SCHEMA,\n+        sqlClient.getTables(\"catalog\", \"db_schema_filter_pattern\", \"table_filter_pattern\",\n+            Arrays.asList(\"table\", \"view\"), true, options), sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_TABLE_TYPES_SCHEMA, sqlClient.getTableTypes(options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_PRIMARY_KEYS_SCHEMA,\n+        sqlClient.getPrimaryKeys(TableRef.of(\"catalog\", \"db_schema\", \"table\"), options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_EXPORTED_KEYS_SCHEMA,\n+        sqlClient.getExportedKeys(TableRef.of(\"catalog\", \"db_schema\", \"table\"), options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_IMPORTED_KEYS_SCHEMA,\n+        sqlClient.getImportedKeys(TableRef.of(\"catalog\", \"db_schema\", \"table\"), options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_CROSS_REFERENCE_SCHEMA,\n+        sqlClient.getCrossReference(TableRef.of(\"pk_catalog\", \"pk_db_schema\", \"pk_table\"),\n+            TableRef.of(\"fk_catalog\", \"fk_db_schema\", \"fk_table\"), options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_SQL_INFO_SCHEMA,\n+        sqlClient.getSqlInfo(new FlightSql.SqlInfo[] {FlightSql.SqlInfo.FLIGHT_SQL_SERVER_NAME,\n+            FlightSql.SqlInfo.FLIGHT_SQL_SERVER_READ_ONLY}, options), sqlClient);\n+  }\n+\n+  private void validateStatementExecution(FlightSqlClient sqlClient) throws Exception {\n+    final CallOption[] options = new CallOption[0];\n+\n+    validate(FlightSqlScenarioProducer.getQuerySchema(),\n+        sqlClient.execute(\"SELECT STATEMENT\", options), sqlClient);\n+\n+    IntegrationAssertions.assertEquals(sqlClient.executeUpdate(\"UPDATE STATEMENT\", options),\n+        10000L);\n\nReview comment:\n       (The same goes for the producer, C++, etc.)\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-21T13:41:45.337+0000",
                    "updated": "2021-12-21T13:41:45.337+0000",
                    "started": "2021-12-21T13:41:45.336+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "699362",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/699404",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rafael-telles commented on a change in pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#discussion_r773195206\n\n\n\n##########\nFile path: java/flight/flight-integration-tests/src/main/java/org/apache/arrow/flight/integration/tests/FlightSqlScenario.java\n##########\n@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.arrow.flight.integration.tests;\n+\n+import java.util.Arrays;\n+\n+import org.apache.arrow.flight.CallOption;\n+import org.apache.arrow.flight.FlightClient;\n+import org.apache.arrow.flight.FlightInfo;\n+import org.apache.arrow.flight.FlightProducer;\n+import org.apache.arrow.flight.FlightServer;\n+import org.apache.arrow.flight.FlightStream;\n+import org.apache.arrow.flight.Location;\n+import org.apache.arrow.flight.Ticket;\n+import org.apache.arrow.flight.sql.FlightSqlClient;\n+import org.apache.arrow.flight.sql.FlightSqlProducer;\n+import org.apache.arrow.flight.sql.impl.FlightSql;\n+import org.apache.arrow.flight.sql.util.TableRef;\n+import org.apache.arrow.memory.BufferAllocator;\n+import org.apache.arrow.vector.VectorSchemaRoot;\n+import org.apache.arrow.vector.types.pojo.Schema;\n+\n+/**\n+ * Integration test scenario for validating Flight SQL specs across multiple implementations.\n+ * This should ensure that RPC objects are being built and parsed correctly for multiple languages\n+ * and that the Arrow schemas are returned as expected.\n+ */\n+public class FlightSqlScenario implements Scenario {\n+\n+  @Override\n+  public FlightProducer producer(BufferAllocator allocator, Location location) throws Exception {\n+    return new FlightSqlScenarioProducer(allocator);\n+  }\n+\n+  @Override\n+  public void buildServer(FlightServer.Builder builder) throws Exception {\n+\n+  }\n+\n+  @Override\n+  public void client(BufferAllocator allocator, Location location, FlightClient client)\n+      throws Exception {\n+    final FlightSqlClient sqlClient = new FlightSqlClient(client);\n+\n+    validateMetadataRetrieval(sqlClient);\n+\n+    validateStatementExecution(sqlClient);\n+\n+    validatePreparedStatementExecution(sqlClient, allocator);\n+  }\n+\n+  private void validateMetadataRetrieval(FlightSqlClient sqlClient) throws Exception {\n+    final CallOption[] options = new CallOption[0];\n+\n+    validate(FlightSqlProducer.Schemas.GET_CATALOGS_SCHEMA, sqlClient.getCatalogs(options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_SCHEMAS_SCHEMA,\n+        sqlClient.getSchemas(\"catalog\", \"db_schema_filter_pattern\", options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_TABLES_SCHEMA,\n+        sqlClient.getTables(\"catalog\", \"db_schema_filter_pattern\", \"table_filter_pattern\",\n+            Arrays.asList(\"table\", \"view\"), true, options), sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_TABLE_TYPES_SCHEMA, sqlClient.getTableTypes(options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_PRIMARY_KEYS_SCHEMA,\n+        sqlClient.getPrimaryKeys(TableRef.of(\"catalog\", \"db_schema\", \"table\"), options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_EXPORTED_KEYS_SCHEMA,\n+        sqlClient.getExportedKeys(TableRef.of(\"catalog\", \"db_schema\", \"table\"), options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_IMPORTED_KEYS_SCHEMA,\n+        sqlClient.getImportedKeys(TableRef.of(\"catalog\", \"db_schema\", \"table\"), options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_CROSS_REFERENCE_SCHEMA,\n+        sqlClient.getCrossReference(TableRef.of(\"pk_catalog\", \"pk_db_schema\", \"pk_table\"),\n+            TableRef.of(\"fk_catalog\", \"fk_db_schema\", \"fk_table\"), options),\n+        sqlClient);\n+    validate(FlightSqlProducer.Schemas.GET_SQL_INFO_SCHEMA,\n+        sqlClient.getSqlInfo(new FlightSql.SqlInfo[] {FlightSql.SqlInfo.FLIGHT_SQL_SERVER_NAME,\n+            FlightSql.SqlInfo.FLIGHT_SQL_SERVER_READ_ONLY}, options), sqlClient);\n+  }\n+\n+  private void validateStatementExecution(FlightSqlClient sqlClient) throws Exception {\n+    final CallOption[] options = new CallOption[0];\n+\n+    validate(FlightSqlScenarioProducer.getQuerySchema(),\n+        sqlClient.execute(\"SELECT STATEMENT\", options), sqlClient);\n+\n+    IntegrationAssertions.assertEquals(sqlClient.executeUpdate(\"UPDATE STATEMENT\", options),\n+        10000L);\n\nReview comment:\n       Thanks! Done\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-21T14:45:42.568+0000",
                    "updated": "2021-12-21T14:45:42.568+0000",
                    "started": "2021-12-21T14:45:42.568+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "699404",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/699542",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rafael-telles commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-998975102\n\n\n   Hey @lidavidm ! Are we good to merge this on `flight-sql` branch and then on `master`?\r\n   \r\n   Thank you\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-21T17:46:09.262+0000",
                    "updated": "2021-12-21T17:46:09.262+0000",
                    "started": "2021-12-21T17:46:09.261+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "699542",
                    "issueId": "13417725"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/worklog/699545",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "lidavidm commented on pull request #11989:\nURL: https://github.com/apache/arrow/pull/11989#issuecomment-998979560\n\n\n   We should be. I just kicked off CI.\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nTo unsubscribe, e-mail: github-unsubscribe@arrow.apache.org\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-12-21T17:53:51.221+0000",
                    "updated": "2021-12-21T17:53:51.221+0000",
                    "started": "2021-12-21T17:53:51.221+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "699545",
                    "issueId": "13417725"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 16200,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@52ccbcd2[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7718ef72[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@32b9fa44[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@2eae01e[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5729ddc3[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@754f0fa4[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@8d9a093[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5d665b86[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4438522c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@49875720[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@c9fbbbb[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@634a7bc5[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 16200,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Dec 23 19:19:42 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-12-23T19:19:42.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-15112/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-12-15T13:58:30.000+0000",
        "updated": "2021-12-23T19:19:57.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "4.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 16200
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][FlightRPC][Integration][Java] Implement Flight RPC integration tests",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/comment/17459955",
                    "id": "17459955",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "CC [~rafaeltelles] and [~kylep]\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-12-15T13:58:59.796+0000",
                    "updated": "2021-12-15T13:58:59.796+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13417725/comment/17464759",
                    "id": "17464759",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 12013\r\n[https://github.com/apache/arrow/pull/12013]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=lidavidm",
                        "name": "lidavidm",
                        "key": "lidavidm",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "David Li",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-12-23T19:19:42.721+0000",
                    "updated": "2021-12-23T19:19:42.721+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|z0xqo0:",
        "customfield_12314139": null
    }
}